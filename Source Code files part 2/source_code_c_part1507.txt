RCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.hpp"

void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\lighting.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        lighting.cpp
 *  Content:     Direct3D material/light management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "tlhal.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckLightParams"

void CheckLightParams(LPD3DLIGHT7 lpData)
{
    if (!VALID_D3DLIGHT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer" );
        throw DDERR_INVALIDPARAMS;
    }
    if (lpData->dltType != D3DLIGHT_POINT &&
        lpData->dltType != D3DLIGHT_SPOT &&
        lpData->dltType != D3DLIGHT_DIRECTIONAL)
    {
        D3D_ERR( "Invalid D3DLIGHT type" );
        throw DDERR_INVALIDPARAMS;
    }

    if (lpData->dvRange < 0.0f || lpData->dvRange > D3DLIGHT_RANGE_MAX)
    {
        D3D_ERR( "Invalid D3DLIGHT range" );
        throw DDERR_INVALIDPARAMS;
    }
    if (lpData->dltType == D3DLIGHT_SPOT || lpData->dltType == D3DLIGHT_DIRECTIONAL)
    {
        float   magnitude;
        magnitude = lpData->dvDirection.x * lpData->dvDirection.x +
            lpData->dvDirection.y * lpData->dvDirection.y +
            lpData->dvDirection.z * lpData->dvDirection.z;
        if (magnitude < 0.00001f)
        {
            D3D_ERR( "Invalid D3DLIGHT direction" );
            throw DDERR_INVALIDPARAMS;
        }
        if (lpData->dltType == D3DLIGHT_SPOT)
        {
            if (lpData->dvPhi < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvPhi > 3.1415927f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvTheta < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvTheta > lpData->dvPhi)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvAttenuation0 < 0 ||
                lpData->dvAttenuation1 < 0 ||
                lpData->dvAttenuation2 < 0)
            {
                D3D_ERR( "Attenuation factor can not be negative" );
                throw DDERR_INVALIDPARAMS;
            }
        }
    }
    return;
}
//=====================================================================
//
//         DIRECT3DDEVICEI interface
//
//=====================================================================
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetMaterialI"

void DIRECT3DDEVICEI::SetMaterialI(LPD3DMATERIAL7 lpData)
{
    this->lighting.material = *lpData;
    this->MaterialChanged();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetMaterial"

HRESULT D3DAPI DIRECT3DDEVICEI::SetMaterial(LPD3DMATERIAL7 lpData)
{
    if (!VALID_D3DMATERIAL_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer" );
        return DDERR_INVALIDPARAMS;
    }

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertMaterial(lpData);
        else
            this->SetMaterialI(lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetMaterial"

HRESULT D3DAPI DIRECT3DDEVICEI::GetMaterial(LPD3DMATERIAL7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DMATERIAL_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->lighting.material;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetLightI"

void DIRECT3DDEVICEI::SetLightI(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    if (dwLightIndex >= m_dwNumLights)
    {
        // Now we have to grow the light array. We create new array and copy
        // old lights there.
        DIRECT3DLIGHTI *pLights = new DIRECT3DLIGHTI[dwLightIndex + 10];
        if (pLights == NULL)
        {
            D3D_ERR("Not enough memory to grow light array");
            throw DDERR_OUTOFMEMORY;
        }
        LIST_INITIALIZE(&m_ActiveLights);   // Clear active light list
        for (DWORD i = 0; i < m_dwNumLights; i++)
        {
            if (m_pLights[i].Valid())
            {
                pLights[i] = m_pLights[i];
                if (pLights[i].Enabled())
                    LIST_INSERT_ROOT(&m_ActiveLights, &pLights[i], m_List);
            }
        }
        m_dwNumLights = dwLightIndex + 10;
        DIRECT3DLIGHTI *pLightsTemp = m_pLights;
        m_pLights = pLights;
        delete [] pLightsTemp;
    }
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];

    pLight->m_Light = *lpData;
    this->LightChanged(dwLightIndex);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetLight"

HRESULT D3DAPI DIRECT3DDEVICEI::SetLight(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        CheckLightParams(lpData);

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertLight(dwLightIndex, lpData);
        else
            this->SetLightI(dwLightIndex, lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetLight"

HRESULT D3DAPI DIRECT3DDEVICEI::GetLight(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DLIGHT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwLightIndex >= m_dwNumLights)
    {
        D3D_ERR( "Invalid light index" );
        return DDERR_INVALIDPARAMS;
    }
    DIRECT3DLIGHTI *pLight = &m_pLights[dwLightIndex];
    if (!pLight->Valid())
    {
        return DDERR_INVALIDPARAMS;
    }

    *lpData = pLight->m_Light;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::MaterialChanged"

void DIRECT3DDEVICEI::MaterialChanged()
{
    this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightChanged"

void DIRECT3DDEVICEI::LightChanged(DWORD dwLightIndex)
{
    dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
    // Valid flag should be set in this function, because
    // CDirect3DDeviceTL uses this flag to check if the light is set
    // first time
    m_pLights[dwLightIndex].m_LightI.flags |= D3DLIGHTI_VALID | D3DLIGHTI_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightEnableI"

void DIRECT3DDEVICEI::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    if (dwLightIndex >= m_dwNumLights ||
        !m_pLights[dwLightIndex].Valid())
    {
        // Set default value to the light
        D3DLIGHT7 light;
        memset(&light, 0, sizeof(light));
        light.dltType = D3DLIGHT_DIRECTIONAL;
        light.dvDirection.x = D3DVAL(0);
        light.dvDirection.y = D3DVAL(0);
        light.dvDirection.z = D3DVAL(1);
        light.dcvDiffuse.r = D3DVAL(1);
        light.dcvDiffuse.g = D3DVAL(1);
        light.dcvDiffuse.b = D3DVAL(1);
        SetLightI(dwLightIndex, &light);
    }
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];
    if (bEnable)
    {
        if (!pLight->Enabled())
        {

            LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
            pLight->m_LightI.flags |= D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    else
    {
        if (pLight->Enabled())
        {
            LIST_DELETE(pLight, m_List);
            pLight->m_LightI.flags &= ~D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightEnable"

HRESULT D3DAPI DIRECT3DDEVICEI::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertLightEnable(dwLightIndex, bEnable);
        else
            LightEnableI(dwLightIndex, bEnable);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetLightEnable"

HRESULT D3DAPI DIRECT3DDEVICEI::GetLightEnable(DWORD dwLightIndex, BOOL *pbEnable)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    if (dwLightIndex >= m_dwNumLights ||
        !m_pLights[dwLightIndex].Valid())
    {
        D3D_ERR("Invalid light index OR light is not initialized");
        return DDERR_INVALIDPARAMS;
    }
    *pbEnable = m_pLights[dwLightIndex].Enabled();
    return D3D_OK;
}
//---------------------------------------------------------------------
// Update internal light state
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DLIGHTI::SetInternalData"

HRESULT DIRECT3DLIGHTI::SetInternalData()
{
    m_LightI.type   = m_Light.dltType;
    m_LightI.flags &= ~D3DLIGHTI_OPTIMIZATIONFLAGS;

    if (FLOAT_EQZ(m_Light.dcvSpecular.r) &&
        FLOAT_EQZ(m_Light.dcvSpecular.g) &&
        FLOAT_EQZ(m_Light.dcvSpecular.b))
    {
        m_LightI.flags |= D3DLIGHTI_SPECULAR_IS_ZERO;
    }

    if (FLOAT_EQZ(m_Light.dcvAmbient.r) &&
        FLOAT_EQZ(m_Light.dcvAmbient.g) &&
        FLOAT_EQZ(m_Light.dcvAmbient.b))
    {
        m_LightI.flags |= D3DLIGHTI_AMBIENT_IS_ZERO;
    }

    m_LightI.ambient.r = m_Light.dcvAmbient.r;
    m_LightI.ambient.g = m_Light.dcvAmbient.g;
    m_LightI.ambient.b = m_Light.dcvAmbient.b;

    m_LightI.specular.r = m_Light.dcvSpecular.r;
    m_LightI.specular.g = m_Light.dcvSpecular.g;
    m_LightI.specular.b = m_Light.dcvSpecular.b;

    m_LightI.diffuse.r = m_Light.dcvDiffuse.r;
    m_LightI.diffuse.g = m_Light.dcvDiffuse.g;
    m_LightI.diffuse.b = m_Light.dcvDiffuse.b;

    m_LightI.position.x = m_Light.dvPosition.x;
    m_LightI.position.y = m_Light.dvPosition.y;
    m_LightI.position.z = m_Light.dvPosition.z;
    m_LightI.direction.x = m_Light.dvDirection.x;
    m_LightI.direction.y = m_Light.dvDirection.y;
    m_LightI.direction.z = m_Light.dvDirection.z;
    m_LightI.attenuation0 = m_Light.dvAttenuation0;
    m_LightI.attenuation1 = m_Light.dvAttenuation1;
    m_LightI.attenuation2 = m_Light.dvAttenuation2;

    m_LightI.range = m_Light.dvRange;
    m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;

    if (m_Light.dltType == D3DLIGHT_SPOT)
    {
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);

        m_LightI.falloff = m_Light.dvFalloff;
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
    }
    if (m_Light.dltType == D3DLIGHT_DIRECTIONAL ||
        m_Light.dltType == D3DLIGHT_SPOT)
    {
        VecNormalize(m_LightI.direction);
    }

    // set internal flags
    if (m_LightI.attenuation0 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
    }
    if (m_LightI.attenuation1 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
    }
    if (m_LightI.attenuation2 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
    }
    if (m_LightI.falloff == 1.0)
    {
        m_LightI.flags |= D3DLIGHTI_LINEAR_FALLOFF;
    }
    m_LightI.flags &= ~D3DLIGHTI_DIRTY;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "d3dpr.hpp"
#include "d3dtypesp.h"
#include "ddrawp.h"
#include "haldrv.hpp"
#include "memalloc.h"
#include "fltval.h"
#include "texman.hpp"
#include "tlhal.h"
#include "stateset.hpp"
#include "surfiter.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dfe
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX7)\tnl
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)
USE_NATIVE_EH = 1

SOURCES=\
    ..\d3dcreat.cpp \
    ..\d3ddev.cpp   \
    ..\d3diunk.cpp  \
    ..\d3dmem.cpp   \
    ..\d3dtex.cpp   \
    ..\deviunk.cpp  \
    ..\devstate.cpp \
    ..\dlld3d.cpp   \
    ..\dp2hal.cpp   \
    ..\dphal.cpp    \
    ..\dpoldhal.cpp \
    ..\drawprim.cpp \
    ..\halbuf.cpp   \
    ..\haldrv.cpp   \
    ..\halscene.cpp \
    ..\haltex.cpp   \
    ..\hwprov.cpp   \
    ..\init.c       \
    ..\lighting.cpp \
    ..\stateset.cpp \
    ..\table.cpp    \
    ..\texman.cpp   \
    ..\tldevice.cpp \
    ..\vertbuf.cpp  \
    ..\testprov.cpp \
    ..\vwport.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\table.cpp ===
#include "pch.cpp"
#pragma hdrstop

D3DLINE LineListPrecomp[] = {
    { 0, 1 }, { 2, 3 }, { 4, 5 }, { 6, 7 }, 
    { 8, 9 }, { 10, 11 }, { 12, 13 }, { 14, 15 }, 
    { 16, 17 }, { 18, 19 }, { 20, 21 }, { 22, 23 }, 
    { 24, 25 }, { 26, 27 }, { 28, 29 }, { 30, 31 }, 
    { 32, 33 }, { 34, 35 }, { 36, 37 }, { 38, 39 }, 
    { 40, 41 }, { 42, 43 }, { 44, 45 }, { 46, 47 }, 
    { 48, 49 }, { 50, 51 }, { 52, 53 }, { 54, 55 }, 
    { 56, 57 }, { 58, 59 }, { 60, 61 }, { 62, 63 }, 
    { 64, 65 }, { 66, 67 }, { 68, 69 }, { 70, 71 }, 
    { 72, 73 }, { 74, 75 }, { 76, 77 }, { 78, 79 }, 
    { 80, 81 }, { 82, 83 }, { 84, 85 }, { 86, 87 }, 
    { 88, 89 }, { 90, 91 }, { 92, 93 }, { 94, 95 }, 
    { 96, 97 }, { 98, 99 }, { 100, 101 }, { 102, 103 }, 
    { 104, 105 }, { 106, 107 }, { 108, 109 }, { 110, 111 }, 
    { 112, 113 }, { 114, 115 }, { 116, 117 }, { 118, 119 }, 
    { 120, 121 }, { 122, 123 }, { 124, 125 }, { 126, 127 }, 
    { 128, 129 }, { 130, 131 }, { 132, 133 }, { 134, 135 }, 
    { 136, 137 }, { 138, 139 }, { 140, 141 }, { 142, 143 }, 
    { 144, 145 }, { 146, 147 }, { 148, 149 }, { 150, 151 }, 
    { 152, 153 }, { 154, 155 }, { 156, 157 }, { 158, 159 }, 
    { 160, 161 }, { 162, 163 }, { 164, 165 }, { 166, 167 }, 
    { 168, 169 }, { 170, 171 }, { 172, 173 }, { 174, 175 }, 
    { 176, 177 }, { 178, 179 }, { 180, 181 }, { 182, 183 }, 
    { 184, 185 }, { 186, 187 }, { 188, 189 }, { 190, 191 }, 
    { 192, 193 }, { 194, 195 }, { 196, 197 }, { 198, 199 }, 
    { 200, 201 }, { 202, 203 }, { 204, 205 }, { 206, 207 }, 
    { 208, 209 }, { 210, 211 }, { 212, 213 }, { 214, 215 }, 
    { 216, 217 }, { 218, 219 }, { 220, 221 }, { 222, 223 }, 
    { 224, 225 }, { 226, 227 }, { 228, 229 }, { 230, 231 }, 
    { 232, 233 }, { 234, 235 }, { 236, 237 }, { 238, 239 }, 
    { 240, 241 }, { 242, 243 }, { 244, 245 }, { 246, 247 }, 
    { 248, 249 }, { 250, 251 }, { 252, 253 }, { 254, 255 }, 
    { 256, 257 }, { 258, 259 }, { 260, 261 }, { 262, 263 }, 
    { 264, 265 }, { 266, 267 }, { 268, 269 }, { 270, 271 }, 
    { 272, 273 }, { 274, 275 }, { 276, 277 }, { 278, 279 }, 
    { 280, 281 }, { 282, 283 }, { 284, 285 }, { 286, 287 }, 
    { 288, 289 }, { 290, 291 }, { 292, 293 }, { 294, 295 }, 
    { 296, 297 }, { 298, 299 }, { 300, 301 }, { 302, 303 }, 
    { 304, 305 }, { 306, 307 }, { 308, 309 }, { 310, 311 }, 
    { 312, 313 }, { 314, 315 }, { 316, 317 }, { 318, 319 }, 
    { 320, 321 }, { 322, 323 }, { 324, 325 }, { 326, 327 }, 
    { 328, 329 }, { 330, 331 }, { 332, 333 }, { 334, 335 }, 
    { 336, 337 }, { 338, 339 }, { 340, 341 }, { 342, 343 }, 
    { 344, 345 }, { 346, 347 }, { 348, 349 }, { 350, 351 }, 
    { 352, 353 }, { 354, 355 }, { 356, 357 }, { 358, 359 }, 
    { 360, 361 }, { 362, 363 }, { 364, 365 }, { 366, 367 }, 
    { 368, 369 }, { 370, 371 }, { 372, 373 }, { 374, 375 }, 
    { 376, 377 }, { 378, 379 }, { 380, 381 }, { 382, 383 }, 
    { 384, 385 }, { 386, 387 }, { 388, 389 }, { 390, 391 }, 
    { 392, 393 }, { 394, 395 }, { 396, 397 }, { 398, 399 }, 
    { 400, 401 }, { 402, 403 }, { 404, 405 }, { 406, 407 }, 
    { 408, 409 }, { 410, 411 }, { 412, 413 }, { 414, 415 }, 
    { 416, 417 }, { 418, 419 }, { 420, 421 }, { 422, 423 }, 
    { 424, 425 }, { 426, 427 }, { 428, 429 }, { 430, 431 }, 
    { 432, 433 }, { 434, 435 }, { 436, 437 }, { 438, 439 }, 
    { 440, 441 }, { 442, 443 }, { 444, 445 }, { 446, 447 }, 
    { 448, 449 }, { 450, 451 }, { 452, 453 }, { 454, 455 }, 
    { 456, 457 }, { 458, 459 }, { 460, 461 }, { 462, 463 }, 
    { 464, 465 }, { 466, 467 }, { 468, 469 }, { 470, 471 }, 
    { 472, 473 }, { 474, 475 }, { 476, 477 }, { 478, 479 }, 
    { 480, 481 }, { 482, 483 }, { 484, 485 }, { 486, 487 }, 
    { 488, 489 }, { 490, 491 }, { 492, 493 }, { 494, 495 }, 
    { 496, 497 }, { 498, 499 }, { 500, 501 }, { 502, 503 }, 
    { 504, 505 }, { 506, 507 }, { 508, 509 }, { 510, 511 },
    { 512, 513 }, { 514, 515 }, { 516, 517 }, { 518, 519 },
    { 520, 521 }, { 522, 523 }, { 524, 525 }, { 526, 527 }, 
    { 528, 529 }, { 530, 531 }, { 532, 533 }, { 534, 535 }, 
    { 536, 537 }, { 538, 539 }, { 540, 541 }, { 542, 543 }, 
    { 544, 545 }, { 546, 547 }, { 548, 549 }, { 550, 551 }, 
    { 552, 553 }, { 554, 555 }, { 556, 557 }, { 558, 559 }, 
    { 560, 561 }, { 562, 563 }, { 564, 565 }, { 566, 567 }, 
    { 568, 569 }, { 570, 571 }, { 572, 573 }, { 574, 575 }, 
    { 576, 577 }, { 578, 579 }, { 580, 581 }, { 582, 583 }, 
    { 584, 585 }, { 586, 587 }, { 588, 589 }, { 590, 591 }, 
    { 592, 593 }, { 594, 595 }, { 596, 597 }, { 598, 599 }, 
    { 600, 601 }, { 602, 603 }, { 604, 605 }, { 606, 607 }, 
    { 608, 609 }, { 610, 611 }, { 612, 613 }, { 614, 615 }, 
    { 616, 617 }, { 618, 619 }, { 620, 621 }, { 622, 623 }, 
    { 624, 625 }, { 626, 627 }, { 628, 629 }, { 630, 631 }, 
    { 632, 633 }, { 634, 635 }, { 636, 637 }, { 638, 639 }, 
    { 640, 641 }, { 642, 643 }, { 644, 645 }, { 646, 647 }, 
    { 648, 649 }, { 650, 651 }, { 652, 653 }, { 654, 655 }, 
    { 656, 657 }, { 658, 659 }, { 660, 661 }, { 662, 663 }, 
    { 664, 665 }, { 666, 667 }, { 668, 669 }, { 670, 671 }, 
    { 672, 673 }, { 674, 675 }, { 676, 677 }, { 678, 679 }, 
    { 680, 681 }, { 682, 683 }, { 684, 685 }, { 686, 687 }, 
    { 688, 689 }, { 690, 691 }, { 692, 693 }, { 694, 695 }, 
    { 696, 697 }, { 698, 699 }, { 700, 701 }, { 702, 703 }, 
    { 704, 705 }, { 706, 707 }, { 708, 709 }, { 710, 711 }, 
    { 712, 713 }, { 714, 715 }, { 716, 717 }, { 718, 719 }, 
    { 720, 721 }, { 722, 723 }, { 724, 725 }, { 726, 727 }, 
    { 728, 729 }, { 730, 731 }, { 732, 733 }, { 734, 735 }, 
    { 736, 737 }, { 738, 739 }, { 740, 741 }, { 742, 743 }, 
    { 744, 745 }, { 746, 747 }, { 748, 749 }, { 750, 751 }, 
    { 752, 753 }, { 754, 755 }, { 756, 757 }, { 758, 759 }, 
    { 760, 761 }, { 762, 763 }, { 764, 765 }, { 766, 767 }, 
    { 768, 769 }, { 770, 771 }, { 772, 773 }, { 774, 775 }, 
    { 776, 777 }, { 778, 779 }, { 780, 781 }, { 782, 783 }, 
    { 784, 785 }, { 786, 787 }, { 788, 789 }, { 790, 791 }, 
    { 792, 793 }, { 794, 795 }, { 796, 797 }, { 798, 799 }, 
    { 800, 801 }, { 802, 803 }, { 804, 805 }, { 806, 807 }, 
    { 808, 809 }, { 810, 811 }, { 812, 813 }, { 814, 815 }, 
    { 816, 817 }, { 818, 819 }, { 820, 821 }, { 822, 823 }, 
    { 824, 825 }, { 826, 827 }, { 828, 829 }, { 830, 831 }, 
    { 832, 833 }, { 834, 835 }, { 836, 837 }, { 838, 839 }, 
    { 840, 841 }, { 842, 843 }, { 844, 845 }, { 846, 847 }, 
    { 848, 849 }, { 850, 851 }, { 852, 853 }, { 854, 855 }, 
    { 856, 857 }, { 858, 859 }, { 860, 861 }, { 862, 863 }, 
    { 864, 865 }, { 866, 867 }, { 868, 869 }, { 870, 871 }, 
    { 872, 873 }, { 874, 875 }, { 876, 877 }, { 878, 879 }, 
    { 880, 881 }, { 882, 883 }, { 884, 885 }, { 886, 887 }, 
    { 888, 889 }, { 890, 891 }, { 892, 893 }, { 894, 895 }, 
    { 896, 897 }, { 898, 899 }, { 900, 901 }, { 902, 903 }, 
    { 904, 905 }, { 906, 907 }, { 908, 909 }, { 910, 911 }, 
    { 912, 913 }, { 914, 915 }, { 916, 917 }, { 918, 919 }, 
    { 920, 921 }, { 922, 923 }, { 924, 925 }, { 926, 927 }, 
    { 928, 929 }, { 930, 931 }, { 932, 933 }, { 934, 935 }, 
    { 936, 937 }, { 938, 939 }, { 940, 941 }, { 942, 943 }, 
    { 944, 945 }, { 946, 947 }, { 948, 949 }, { 950, 951 }, 
    { 952, 953 }, { 954, 955 }, { 956, 957 }, { 958, 959 }, 
    { 960, 961 }, { 962, 963 }, { 964, 965 }, { 966, 967 }, 
    { 968, 969 }, { 970, 971 }, { 972, 973 }, { 974, 975 }, 
    { 976, 977 }, { 978, 979 }, { 980, 981 }, { 982, 983 }, 
    { 984, 985 }, { 986, 987 }, { 988, 989 }, { 990, 991 }, 
    { 992, 993 }, { 994, 995 }, { 996, 997 }, { 998, 999 }, 
    { 1000, 1001 }, { 1002, 1003 }, { 1004, 1005 }, { 1006, 1007 }, 
    { 1008, 1009 }, { 1010, 1011 }, { 1012, 1013 }, { 1014, 1015 }, 
    { 1016, 1017 }, { 1018, 1019 }, { 1020, 1021 }, { 1022, 1023 }, 
    };

D3DLINE LineStripPrecomp[] = {
    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 }, 
    { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 }, 
    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 }, 
    { 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 }, 
    { 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 }, 
    { 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 }, 
    { 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 }, 
    { 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 }, 
    { 32, 33 }, { 33, 34 }, { 34, 35 }, { 35, 36 }, 
    { 36, 37 }, { 37, 38 }, { 38, 39 }, { 39, 40 }, 
    { 40, 41 }, { 41, 42 }, { 42, 43 }, { 43, 44 }, 
    { 44, 45 }, { 45, 46 }, { 46, 47 }, { 47, 48 }, 
    { 48, 49 }, { 49, 50 }, { 50, 51 }, { 51, 52 }, 
    { 52, 53 }, { 53, 54 }, { 54, 55 }, { 55, 56 }, 
    { 56, 57 }, { 57, 58 }, { 58, 59 }, { 59, 60 }, 
    { 60, 61 }, { 61, 62 }, { 62, 63 }, { 63, 64 }, 
    { 64, 65 }, { 65, 66 }, { 66, 67 }, { 67, 68 }, 
    { 68, 69 }, { 69, 70 }, { 70, 71 }, { 71, 72 }, 
    { 72, 73 }, { 73, 74 }, { 74, 75 }, { 75, 76 }, 
    { 76, 77 }, { 77, 78 }, { 78, 79 }, { 79, 80 }, 
    { 80, 81 }, { 81, 82 }, { 82, 83 }, { 83, 84 }, 
    { 84, 85 }, { 85, 86 }, { 86, 87 }, { 87, 88 }, 
    { 88, 89 }, { 89, 90 }, { 90, 91 }, { 91, 92 }, 
    { 92, 93 }, { 93, 94 }, { 94, 95 }, { 95, 96 }, 
    { 96, 97 }, { 97, 98 }, { 98, 99 }, { 99, 100 }, 
    { 100, 101 }, { 101, 102 }, { 102, 103 }, { 103, 104 }, 
    { 104, 105 }, { 105, 106 }, { 106, 107 }, { 107, 108 }, 
    { 108, 109 }, { 109, 110 }, { 110, 111 }, { 111, 112 }, 
    { 112, 113 }, { 113, 114 }, { 114, 115 }, { 115, 116 }, 
    { 116, 117 }, { 117, 118 }, { 118, 119 }, { 119, 120 }, 
    { 120, 121 }, { 121, 122 }, { 122, 123 }, { 123, 124 }, 
    { 124, 125 }, { 125, 126 }, { 126, 127 }, { 127, 128 }, 
    { 128, 129 }, { 129, 130 }, { 130, 131 }, { 131, 132 }, 
    { 132, 133 }, { 133, 134 }, { 134, 135 }, { 135, 136 }, 
    { 136, 137 }, { 137, 138 }, { 138, 139 }, { 139, 140 }, 
    { 140, 141 }, { 141, 142 }, { 142, 143 }, { 143, 144 }, 
    { 144, 145 }, { 145, 146 }, { 146, 147 }, { 147, 148 }, 
    { 148, 149 }, { 149, 150 }, { 150, 151 }, { 151, 152 }, 
    { 152, 153 }, { 153, 154 }, { 154, 155 }, { 155, 156 }, 
    { 156, 157 }, { 157, 158 }, { 158, 159 }, { 159, 160 }, 
    { 160, 161 }, { 161, 162 }, { 162, 163 }, { 163, 164 }, 
    { 164, 165 }, { 165, 166 }, { 166, 167 }, { 167, 168 }, 
    { 168, 169 }, { 169, 170 }, { 170, 171 }, { 171, 172 }, 
    { 172, 173 }, { 173, 174 }, { 174, 175 }, { 175, 176 }, 
    { 176, 177 }, { 177, 178 }, { 178, 179 }, { 179, 180 }, 
    { 180, 181 }, { 181, 182 }, { 182, 183 }, { 183, 184 }, 
    { 184, 185 }, { 185, 186 }, { 186, 187 }, { 187, 188 }, 
    { 188, 189 }, { 189, 190 }, { 190, 191 }, { 191, 192 }, 
    { 192, 193 }, { 193, 194 }, { 194, 195 }, { 195, 196 }, 
    { 196, 197 }, { 197, 198 }, { 198, 199 }, { 199, 200 }, 
    { 200, 201 }, { 201, 202 }, { 202, 203 }, { 203, 204 }, 
    { 204, 205 }, { 205, 206 }, { 206, 207 }, { 207, 208 }, 
    { 208, 209 }, { 209, 210 }, { 210, 211 }, { 211, 212 }, 
    { 212, 213 }, { 213, 214 }, { 214, 215 }, { 215, 216 }, 
    { 216, 217 }, { 217, 218 }, { 218, 219 }, { 219, 220 }, 
    { 220, 221 }, { 221, 222 }, { 222, 223 }, { 223, 224 }, 
    { 224, 225 }, { 225, 226 }, { 226, 227 }, { 227, 228 }, 
    { 228, 229 }, { 229, 230 }, { 230, 231 }, { 231, 232 }, 
    { 232, 233 }, { 233, 234 }, { 234, 235 }, { 235, 236 }, 
    { 236, 237 }, { 237, 238 }, { 238, 239 }, { 239, 240 }, 
    { 240, 241 }, { 241, 242 }, { 242, 243 }, { 243, 244 }, 
    { 244, 245 }, { 245, 246 }, { 246, 247 }, { 247, 248 }, 
    { 248, 249 }, { 249, 250 }, { 250, 251 }, { 251, 252 }, 
    { 252, 253 }, { 253, 254 }, { 254, 255 }, { 255, 256 },
    { 256, 257 }, { 257, 258 }, { 258, 259 }, { 259, 260 }, 
    { 260, 261 }, { 261, 262 }, { 262, 263 }, { 263, 264 }, 
    { 264, 265 }, { 265, 266 }, { 266, 267 }, { 267, 268 }, 
    { 268, 269 }, { 269, 270 }, { 270, 271 }, { 271, 272 }, 
    { 272, 273 }, { 273, 274 }, { 274, 275 }, { 275, 276 }, 
    { 276, 277 }, { 277, 278 }, { 278, 279 }, { 279, 280 }, 
    { 280, 281 }, { 281, 282 }, { 282, 283 }, { 283, 284 }, 
    { 284, 285 }, { 285, 286 }, { 286, 287 }, { 287, 288 }, 
    { 288, 289 }, { 289, 290 }, { 290, 291 }, { 291, 292 }, 
    { 292, 293 }, { 293, 294 }, { 294, 295 }, { 295, 296 }, 
    { 296, 297 }, { 297, 298 }, { 298, 299 }, { 299, 300 }, 
    { 300, 301 }, { 301, 302 }, { 302, 303 }, { 303, 304 }, 
    { 304, 305 }, { 305, 306 }, { 306, 307 }, { 307, 308 }, 
    { 308, 309 }, { 309, 310 }, { 310, 311 }, { 311, 312 }, 
    { 312, 313 }, { 313, 314 }, { 314, 315 }, { 315, 316 }, 
    { 316, 317 }, { 317, 318 }, { 318, 319 }, { 319, 320 }, 
    { 320, 321 }, { 321, 322 }, { 322, 323 }, { 323, 324 }, 
    { 324, 325 }, { 325, 326 }, { 326, 327 }, { 327, 328 }, 
    { 328, 329 }, { 329, 330 }, { 330, 331 }, { 331, 332 }, 
    { 332, 333 }, { 333, 334 }, { 334, 335 }, { 335, 336 }, 
    { 336, 337 }, { 337, 338 }, { 338, 339 }, { 339, 340 }, 
    { 340, 341 }, { 341, 342 }, { 342, 343 }, { 343, 344 }, 
    { 344, 345 }, { 345, 346 }, { 346, 347 }, { 347, 348 }, 
    { 348, 349 }, { 349, 350 }, { 350, 351 }, { 351, 352 }, 
    { 352, 353 }, { 353, 354 }, { 354, 355 }, { 355, 356 }, 
    { 356, 357 }, { 357, 358 }, { 358, 359 }, { 359, 360 }, 
    { 360, 361 }, { 361, 362 }, { 362, 363 }, { 363, 364 }, 
    { 364, 365 }, { 365, 366 }, { 366, 367 }, { 367, 368 }, 
    { 368, 369 }, { 369, 370 }, { 370, 371 }, { 371, 372 }, 
    { 372, 373 }, { 373, 374 }, { 374, 375 }, { 375, 376 }, 
    { 376, 377 }, { 377, 378 }, { 378, 379 }, { 379, 380 }, 
    { 380, 381 }, { 381, 382 }, { 382, 383 }, { 383, 384 }, 
    { 384, 385 }, { 385, 386 }, { 386, 387 }, { 387, 388 }, 
    { 388, 389 }, { 389, 390 }, { 390, 391 }, { 391, 392 }, 
    { 392, 393 }, { 393, 394 }, { 394, 395 }, { 395, 396 }, 
    { 396, 397 }, { 397, 398 }, { 398, 399 }, { 399, 400 }, 
    { 400, 401 }, { 401, 402 }, { 402, 403 }, { 403, 404 }, 
    { 404, 405 }, { 405, 406 }, { 406, 407 }, { 407, 408 }, 
    { 408, 409 }, { 409, 410 }, { 410, 411 }, { 411, 412 }, 
    { 412, 413 }, { 413, 414 }, { 414, 415 }, { 415, 416 }, 
    { 416, 417 }, { 417, 418 }, { 418, 419 }, { 419, 420 }, 
    { 420, 421 }, { 421, 422 }, { 422, 423 }, { 423, 424 }, 
    { 424, 425 }, { 425, 426 }, { 426, 427 }, { 427, 428 }, 
    { 428, 429 }, { 429, 430 }, { 430, 431 }, { 431, 432 }, 
    { 432, 433 }, { 433, 434 }, { 434, 435 }, { 435, 436 }, 
    { 436, 437 }, { 437, 438 }, { 438, 439 }, { 439, 440 }, 
    { 440, 441 }, { 441, 442 }, { 442, 443 }, { 443, 444 }, 
    { 444, 445 }, { 445, 446 }, { 446, 447 }, { 447, 448 }, 
    { 448, 449 }, { 449, 450 }, { 450, 451 }, { 451, 452 }, 
    { 452, 453 }, { 453, 454 }, { 454, 455 }, { 455, 456 }, 
    { 456, 457 }, { 457, 458 }, { 458, 459 }, { 459, 460 }, 
    { 460, 461 }, { 461, 462 }, { 462, 463 }, { 463, 464 }, 
    { 464, 465 }, { 465, 466 }, { 466, 467 }, { 467, 468 }, 
    { 468, 469 }, { 469, 470 }, { 470, 471 }, { 471, 472 }, 
    { 472, 473 }, { 473, 474 }, { 474, 475 }, { 475, 476 }, 
    { 476, 477 }, { 477, 478 }, { 478, 479 }, { 479, 480 }, 
    { 480, 481 }, { 481, 482 }, { 482, 483 }, { 483, 484 }, 
    { 484, 485 }, { 485, 486 }, { 486, 487 }, { 487, 488 }, 
    { 488, 489 }, { 489, 490 }, { 490, 491 }, { 491, 492 }, 
    { 492, 493 }, { 493, 494 }, { 494, 495 }, { 495, 496 }, 
    { 496, 497 }, { 497, 498 }, { 498, 499 }, { 499, 500 }, 
    { 500, 501 }, { 501, 502 }, { 502, 503 }, { 503, 504 }, 
    { 504, 505 }, { 505, 506 }, { 506, 507 }, { 507, 508 }, 
    { 508, 509 }, { 509, 510 }, { 510, 511 }, { 511, 512 }, 
    };

D3DTRIANGLE TriangleListPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 4, 5, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 10, 11, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 16, 17, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 22, 23, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 28, 29, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 34, 35, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 40, 41, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 46, 47, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 52, 53, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 58, 59, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 64, 65, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 70, 71, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 76, 77, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 82, 83, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 88, 89, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 94, 95, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 100, 101, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 106, 107, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 112, 113, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 118, 119, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 124, 125, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 130, 131, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 136, 137, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 142, 143, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 148, 149, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 154, 155, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 160, 161, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 166, 167, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 172, 173, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 178, 179, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 184, 185, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 190, 191, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 196, 197, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 202, 203, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 208, 209, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 214, 215, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 220, 221, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 226, 227, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 232, 233, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 238, 239, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 244, 245, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 250, 251, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 256, 257, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 258, 259, 260, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 261, 262, 263, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 264, 265, 266, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 267, 268, 269, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 270, 271, 272, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 273, 274, 275, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 276, 277, 278, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 279, 280, 281, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 282, 283, 284, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 285, 286, 287, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 288, 289, 290, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 291, 292, 293, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 294, 295, 296, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 297, 298, 299, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 300, 301, 302, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 303, 304, 305, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 306, 307, 308, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 309, 310, 311, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 312, 313, 314, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 315, 316, 317, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 318, 319, 320, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 321, 322, 323, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 324, 325, 326, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 327, 328, 329, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 330, 331, 332, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 333, 334, 335, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 336, 337, 338, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 339, 340, 341, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 342, 343, 344, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 345, 346, 347, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 348, 349, 350, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 351, 352, 353, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 354, 355, 356, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 357, 358, 359, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 360, 361, 362, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 363, 364, 365, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 366, 367, 368, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 369, 370, 371, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 372, 373, 374, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 375, 376, 377, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 378, 379, 380, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 381, 382, 383, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 384, 385, 386, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 387, 388, 389, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 390, 391, 392, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 393, 394, 395, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 396, 397, 398, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 399, 400, 401, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 402, 403, 404, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 405, 406, 407, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 408, 409, 410, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 411, 412, 413, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 414, 415, 416, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 417, 418, 419, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 420, 421, 422, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 423, 424, 425, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 426, 427, 428, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 429, 430, 431, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 432, 433, 434, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 435, 436, 437, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 438, 439, 440, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 441, 442, 443, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 444, 445, 446, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 447, 448, 449, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 450, 451, 452, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 453, 454, 455, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 456, 457, 458, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 459, 460, 461, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 462, 463, 464, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 465, 466, 467, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 468, 469, 470, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 471, 472, 473, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 474, 475, 476, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 477, 478, 479, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 480, 481, 482, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 483, 484, 485, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 486, 487, 488, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 489, 490, 491, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 492, 493, 494, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 495, 496, 497, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 498, 499, 500, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 501, 502, 503, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 504, 505, 506, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 507, 508, 509, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 510, 511, 512, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 513, 514, 515, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 516, 517, 518, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 519, 520, 521, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 522, 523, 524, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 525, 526, 527, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 528, 529, 530, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 531, 532, 533, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 534, 535, 536, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 537, 538, 539, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 540, 541, 542, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 543, 544, 545, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 546, 547, 548, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 549, 550, 551, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 552, 553, 554, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 555, 556, 557, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 558, 559, 560, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 561, 562, 563, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 564, 565, 566, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 567, 568, 569, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 570, 571, 572, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 573, 574, 575, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 576, 577, 578, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 579, 580, 581, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 582, 583, 584, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 585, 586, 587, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 588, 589, 590, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 591, 592, 593, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 594, 595, 596, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 597, 598, 599, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 600, 601, 602, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 603, 604, 605, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 606, 607, 608, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 609, 610, 611, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 612, 613, 614, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 615, 616, 617, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 618, 619, 620, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 621, 622, 623, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 624, 625, 626, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 627, 628, 629, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 630, 631, 632, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 633, 634, 635, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 636, 637, 638, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 639, 640, 641, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 642, 643, 644, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 645, 646, 647, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 648, 649, 650, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 651, 652, 653, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 654, 655, 656, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 657, 658, 659, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 660, 661, 662, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 663, 664, 665, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 666, 667, 668, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 669, 670, 671, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 672, 673, 674, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 675, 676, 677, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 678, 679, 680, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 681, 682, 683, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 684, 685, 686, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 687, 688, 689, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 690, 691, 692, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 693, 694, 695, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 696, 697, 698, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 699, 700, 701, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 702, 703, 704, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 705, 706, 707, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 708, 709, 710, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 711, 712, 713, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 714, 715, 716, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 717, 718, 719, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 720, 721, 722, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 723, 724, 725, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 726, 727, 728, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 729, 730, 731, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 732, 733, 734, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 735, 736, 737, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 738, 739, 740, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 741, 742, 743, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 744, 745, 746, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 747, 748, 749, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 750, 751, 752, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 753, 754, 755, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 756, 757, 758, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 759, 760, 761, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 762, 763, 764, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 765, 766, 767, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

D3DTRIANGLE TriangleStripPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 1, 3, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 2, 3, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 5, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 4, 5, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 5, 7, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 7, 9, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 8, 9, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 11, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 10, 11, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 11, 13, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 13, 15, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 14, 15, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 17, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 16, 17, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 17, 19, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 19, 21, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 20, 21, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 23, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 22, 23, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 23, 25, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 25, 27, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 26, 27, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 29, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 28, 29, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 29, 31, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 31, 33, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 32, 33, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 35, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 34, 35, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 35, 37, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 37, 39, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 38, 39, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 41, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 40, 41, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 41, 43, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 43, 45, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 44, 45, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 47, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 46, 47, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 47, 49, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 49, 51, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 50, 51, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 53, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 52, 53, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 53, 55, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 55, 57, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 56, 57, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 59, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 58, 59, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 59, 61, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 61, 63, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 62, 63, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 65, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 64, 65, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 65, 67, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 67, 69, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 68, 69, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 71, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 70, 71, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 71, 73, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 73, 75, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 74, 75, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 77, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 76, 77, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 77, 79, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 79, 81, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 80, 81, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 83, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 82, 83, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 83, 85, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 85, 87, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 86, 87, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 89, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 88, 89, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 89, 91, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 91, 93, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 92, 93, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 95, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 94, 95, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 95, 97, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 97, 99, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 98, 99, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 101, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 100, 101, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 101, 103, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 103, 105, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 104, 105, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 107, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 106, 107, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 107, 109, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 109, 111, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 110, 111, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 113, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 112, 113, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 113, 115, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 115, 117, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 116, 117, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 119, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 118, 119, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 119, 121, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 121, 123, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 122, 123, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 125, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 124, 125, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 125, 127, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 127, 129, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 128, 129, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 131, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 130, 131, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 131, 133, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 133, 135, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 134, 135, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 137, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 136, 137, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 137, 139, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 139, 141, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 140, 141, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 143, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 142, 143, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 143, 145, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 145, 147, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 146, 147, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 149, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 148, 149, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 149, 151, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 151, 153, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 152, 153, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 155, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 154, 155, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 155, 157, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 157, 159, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 158, 159, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 161, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 160, 161, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 161, 163, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 163, 165, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 164, 165, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 167, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 166, 167, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 167, 169, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 169, 171, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 170, 171, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 173, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 172, 173, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 173, 175, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 175, 177, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 176, 177, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 179, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 178, 179, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 179, 181, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 181, 183, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 182, 183, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 185, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 184, 185, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 185, 187, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 187, 189, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 188, 189, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 191, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 190, 191, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 191, 193, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 193, 195, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 194, 195, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 197, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 196, 197, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 197, 199, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 199, 201, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 200, 201, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 203, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 202, 203, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 203, 205, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 205, 207, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 206, 207, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 209, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 208, 209, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 209, 211, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 211, 213, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 212, 213, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 215, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 214, 215, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 215, 217, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 217, 219, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 218, 219, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 221, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 220, 221, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 221, 223, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 223, 225, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 224, 225, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 227, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 226, 227, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 227, 229, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 229, 231, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 230, 231, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 233, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 232, 233, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 233, 235, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 235, 237, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 236, 237, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 239, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 238, 239, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 239, 241, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 241, 243, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 242, 243, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 245, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 244, 245, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 245, 247, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 247, 249, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 248, 249, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 251, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 250, 251, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 251, 253, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 253, 255, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 254, 255, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 257, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    };

D3DTRIANGLE TriangleFanPrecomp[] = {
    { 1, 2, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 2, 3, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 3, 4, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 4, 5, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 5, 6, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 6, 7, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 7, 8, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 8, 9, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 9, 10, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 10, 11, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 11, 12, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 12, 13, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 13, 14, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 14, 15, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 15, 16, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 16, 17, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 17, 18, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 18, 19, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 19, 20, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 20, 21, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 21, 22, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 22, 23, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 23, 24, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 24, 25, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 25, 26, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 26, 27, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 27, 28, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 28, 29, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 29, 30, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 30, 31, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 31, 32, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 32, 33, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 33, 34, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 34, 35, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 35, 36, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 36, 37, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 37, 38, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 38, 39, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 39, 40, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 40, 41, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 41, 42, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 42, 43, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 43, 44, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 44, 45, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 45, 46, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 46, 47, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 47, 48, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 48, 49, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 49, 50, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 50, 51, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 51, 52, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 52, 53, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 53, 54, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 54, 55, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 55, 56, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 56, 57, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 57, 58, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 58, 59, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 59, 60, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 60, 61, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 61, 62, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 62, 63, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 63, 64, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 64, 65, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 65, 66, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 66, 67, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 67, 68, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 68, 69, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 69, 70, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 70, 71, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 71, 72, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 72, 73, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 73, 74, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 74, 75, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 75, 76, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 76, 77, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 77, 78, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 78, 79, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 79, 80, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 80, 81, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 81, 82, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 82, 83, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 83, 84, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 84, 85, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 85, 86, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 86, 87, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 87, 88, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 88, 89, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 89, 90, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 90, 91, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 91, 92, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 92, 93, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 93, 94, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 94, 95, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 95, 96, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 96, 97, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 97, 98, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 98, 99, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 99, 100, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 100, 101, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 101, 102, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 102, 103, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 103, 104, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 104, 105, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 105, 106, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 106, 107, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 107, 108, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 108, 109, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 109, 110, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 110, 111, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 111, 112, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 112, 113, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 113, 114, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 114, 115, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 115, 116, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 116, 117, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 117, 118, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 118, 119, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 119, 120, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 120, 121, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 121, 122, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 122, 123, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 123, 124, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 124, 125, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 125, 126, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 126, 127, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 127, 128, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 128, 129, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 129, 130, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 130, 131, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 131, 132, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 132, 133, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 133, 134, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 134, 135, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 135, 136, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 136, 137, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 137, 138, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 138, 139, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 139, 140, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 140, 141, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 141, 142, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 142, 143, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 143, 144, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 144, 145, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 145, 146, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 146, 147, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 147, 148, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 148, 149, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 149, 150, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 150, 151, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 151, 152, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 152, 153, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 153, 154, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 154, 155, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 155, 156, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 156, 157, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 157, 158, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 158, 159, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 159, 160, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 160, 161, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 161, 162, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 162, 163, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 163, 164, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 164, 165, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 165, 166, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 166, 167, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 167, 168, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 168, 169, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 169, 170, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 170, 171, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 171, 172, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 172, 173, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 173, 174, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 174, 175, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 175, 176, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 176, 177, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 177, 178, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 178, 179, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 179, 180, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 180, 181, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 181, 182, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 182, 183, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 183, 184, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 184, 185, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 185, 186, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 186, 187, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 187, 188, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 188, 189, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 189, 190, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 190, 191, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 191, 192, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 192, 193, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 193, 194, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 194, 195, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 195, 196, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 196, 197, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 197, 198, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 198, 199, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 199, 200, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 200, 201, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 201, 202, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 202, 203, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 203, 204, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 204, 205, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 205, 206, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 206, 207, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 207, 208, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 208, 209, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 209, 210, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 210, 211, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 211, 212, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 212, 213, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 213, 214, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 214, 215, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 215, 216, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 216, 217, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 217, 218, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 218, 219, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 219, 220, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 220, 221, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 221, 222, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 222, 223, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 223, 224, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 224, 225, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 225, 226, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 226, 227, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 227, 228, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 228, 229, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 229, 230, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 230, 231, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 231, 232, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 232, 233, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 233, 234, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 234, 235, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 235, 236, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 236, 237, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 237, 238, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 238, 239, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 239, 240, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 240, 241, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 241, 242, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 242, 243, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 243, 244, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 244, 245, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 245, 246, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 246, 247, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 247, 248, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 248, 249, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 249, 250, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 250, 251, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 251, 252, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 252, 253, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 253, 254, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 254, 255, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 255, 256, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 256, 257, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

/* This can be (and should be) replaced by LineListPrecomp */
WORD TriangleListPrecompDP[][3] = {
    { 0, 1, 2 }, { 3, 4, 5 },
    { 6, 7, 8 }, { 9, 10, 11 },
    { 12, 13, 14 }, { 15, 16, 17 },
    { 18, 19, 20 }, { 21, 22, 23 },
    { 24, 25, 26 }, { 27, 28, 29 },
    { 30, 31, 32 }, { 33, 34, 35 },
    { 36, 37, 38 }, { 39, 40, 41 },
    { 42, 43, 44 }, { 45, 46, 47 },
    { 48, 49, 50 }, { 51, 52, 53 },
    { 54, 55, 56 }, { 57, 58, 59 },
    { 60, 61, 62 }, { 63, 64, 65 },
    { 66, 67, 68 }, { 69, 70, 71 },
    { 72, 73, 74 }, { 75, 76, 77 },
    { 78, 79, 80 }, { 81, 82, 83 },
    { 84, 85, 86 }, { 87, 88, 89 },
    { 90, 91, 92 }, { 93, 94, 95 },
    { 96, 97, 98 }, { 99, 100, 101 },
    { 102, 103, 104 }, { 105, 106, 107 },
    { 108, 109, 110 }, { 111, 112, 113 },
    { 114, 115, 116 }, { 117, 118, 119 },
    { 120, 121, 122 }, { 123, 124, 125 },
    { 126, 127, 128 }, { 129, 130, 131 },
    { 132, 133, 134 }, { 135, 136, 137 },
    { 138, 139, 140 }, { 141, 142, 143 },
    { 144, 145, 146 }, { 147, 148, 149 },
    { 150, 151, 152 }, { 153, 154, 155 },
    { 156, 157, 158 }, { 159, 160, 161 },
    { 162, 163, 164 }, { 165, 166, 167 },
    { 168, 169, 170 }, { 171, 172, 173 },
    { 174, 175, 176 }, { 177, 178, 179 },
    { 180, 181, 182 }, { 183, 184, 185 },
    { 186, 187, 188 }, { 189, 190, 191 },
    { 192, 193, 194 }, { 195, 196, 197 },
    { 198, 199, 200 }, { 201, 202, 203 },
    { 204, 205, 206 }, { 207, 208, 209 },
    { 210, 211, 212 }, { 213, 214, 215 },
    { 216, 217, 218 }, { 219, 220, 221 },
    { 222, 223, 224 }, { 225, 226, 227 },
    { 228, 229, 230 }, { 231, 232, 233 },
    { 234, 235, 236 }, { 237, 238, 239 },
    { 240, 241, 242 }, { 243, 244, 245 },
    { 246, 247, 248 }, { 249, 250, 251 },
    { 252, 253, 254 }, { 255, 256, 257 },
    { 258, 259, 260 }, { 261, 262, 263 },
    { 264, 265, 266 }, { 267, 268, 269 },
    { 270, 271, 272 }, { 273, 274, 275 },
    { 276, 277, 278 }, { 279, 280, 281 },
    { 282, 283, 284 }, { 285, 286, 287 },
    { 288, 289, 290 }, { 291, 292, 293 },
    { 294, 295, 296 }, { 297, 298, 299 },
    { 300, 301, 302 }, { 303, 304, 305 },
    { 306, 307, 308 }, { 309, 310, 311 },
    { 312, 313, 314 }, { 315, 316, 317 },
    { 318, 319, 320 }, { 321, 322, 323 },
    { 324, 325, 326 }, { 327, 328, 329 },
    { 330, 331, 332 }, { 333, 334, 335 },
    { 336, 337, 338 }, { 339, 340, 341 },
    { 342, 343, 344 }, { 345, 346, 347 },
    { 348, 349, 350 }, { 351, 352, 353 },
    { 354, 355, 356 }, { 357, 358, 359 },
    { 360, 361, 362 }, { 363, 364, 365 },
    { 366, 367, 368 }, { 369, 370, 371 },
    { 372, 373, 374 }, { 375, 376, 377 },
    { 378, 379, 380 }, { 381, 382, 383 },
    { 384, 385, 386 }, { 387, 388, 389 },
    { 390, 391, 392 }, { 393, 394, 395 },
    { 396, 397, 398 }, { 399, 400, 401 },
    { 402, 403, 404 }, { 405, 406, 407 },
    { 408, 409, 410 }, { 411, 412, 413 },
    { 414, 415, 416 }, { 417, 418, 419 },
    { 420, 421, 422 }, { 423, 424, 425 },
    { 426, 427, 428 }, { 429, 430, 431 },
    { 432, 433, 434 }, { 435, 436, 437 },
    { 438, 439, 440 }, { 441, 442, 443 },
    { 444, 445, 446 }, { 447, 448, 449 },
    { 450, 451, 452 }, { 453, 454, 455 },
    { 456, 457, 458 }, { 459, 460, 461 },
    { 462, 463, 464 }, { 465, 466, 467 },
    { 468, 469, 470 }, { 471, 472, 473 },
    { 474, 475, 476 }, { 477, 478, 479 },
    { 480, 481, 482 }, { 483, 484, 485 },
    { 486, 487, 488 }, { 489, 490, 491 },
    { 492, 493, 494 }, { 495, 496, 497 },
    { 498, 499, 500 }, { 501, 502, 503 },
    { 504, 505, 506 }, { 507, 508, 509 },
    { 510, 511, 512 }, { 513, 514, 515 },
    { 516, 517, 518 }, { 519, 520, 521 },
    { 522, 523, 524 }, { 525, 526, 527 },
    { 528, 529, 530 }, { 531, 532, 533 },
    { 534, 535, 536 }, { 537, 538, 539 },
    { 540, 541, 542 }, { 543, 544, 545 },
    { 546, 547, 548 }, { 549, 550, 551 },
    { 552, 553, 554 }, { 555, 556, 557 },
    { 558, 559, 560 }, { 561, 562, 563 },
    { 564, 565, 566 }, { 567, 568, 569 },
    { 570, 571, 572 }, { 573, 574, 575 },
    { 576, 577, 578 }, { 579, 580, 581 },
    { 582, 583, 584 }, { 585, 586, 587 },
    { 588, 589, 590 }, { 591, 592, 593 },
    { 594, 595, 596 }, { 597, 598, 599 },
    { 600, 601, 602 }, { 603, 604, 605 },
    { 606, 607, 608 }, { 609, 610, 611 },
    { 612, 613, 614 }, { 615, 616, 617 },
    { 618, 619, 620 }, { 621, 622, 623 },
    { 624, 625, 626 }, { 627, 628, 629 },
    { 630, 631, 632 }, { 633, 634, 635 },
    { 636, 637, 638 }, { 639, 640, 641 },
    { 642, 643, 644 }, { 645, 646, 647 },
    { 648, 649, 650 }, { 651, 652, 653 },
    { 654, 655, 656 }, { 657, 658, 659 },
    { 660, 661, 662 }, { 663, 664, 665 },
    { 666, 667, 668 }, { 669, 670, 671 },
    { 672, 673, 674 }, { 675, 676, 677 },
    { 678, 679, 680 }, { 681, 682, 683 },
    { 684, 685, 686 }, { 687, 688, 689 },
    { 690, 691, 692 }, { 693, 694, 695 },
    { 696, 697, 698 }, { 699, 700, 701 },
    { 702, 703, 704 }, { 705, 706, 707 },
    { 708, 709, 710 }, { 711, 712, 713 },
    { 714, 715, 716 }, { 717, 718, 719 },
    { 720, 721, 722 }, { 723, 724, 725 },
    { 726, 727, 728 }, { 729, 730, 731 },
    { 732, 733, 734 }, { 735, 736, 737 },
    { 738, 739, 740 }, { 741, 742, 743 },
    { 744, 745, 746 }, { 747, 748, 749 },
    { 750, 751, 752 }, { 753, 754, 755 },
    { 756, 757, 758 }, { 759, 760, 761 },
    { 762, 763, 764 }, { 765, 766, 767 },
};

WORD TriangleStripPrecompDP[][3] = {
    { 0, 1, 2 }, { 1, 3, 2 },
    { 2, 3, 4 }, { 3, 5, 4 },
    { 4, 5, 6 }, { 5, 7, 6 },
    { 6, 7, 8 }, { 7, 9, 8 },
    { 8, 9, 10 }, { 9, 11, 10 },
    { 10, 11, 12 }, { 11, 13, 12 },
    { 12, 13, 14 }, { 13, 15, 14 },
    { 14, 15, 16 }, { 15, 17, 16 },
    { 16, 17, 18 }, { 17, 19, 18 },
    { 18, 19, 20 }, { 19, 21, 20 },
    { 20, 21, 22 }, { 21, 23, 22 },
    { 22, 23, 24 }, { 23, 25, 24 },
    { 24, 25, 26 }, { 25, 27, 26 },
    { 26, 27, 28 }, { 27, 29, 28 },
    { 28, 29, 30 }, { 29, 31, 30 },
    { 30, 31, 32 }, { 31, 33, 32 },
    { 32, 33, 34 }, { 33, 35, 34 },
    { 34, 35, 36 }, { 35, 37, 36 },
    { 36, 37, 38 }, { 37, 39, 38 },
    { 38, 39, 40 }, { 39, 41, 40 },
    { 40, 41, 42 }, { 41, 43, 42 },
    { 42, 43, 44 }, { 43, 45, 44 },
    { 44, 45, 46 }, { 45, 47, 46 },
    { 46, 47, 48 }, { 47, 49, 48 },
    { 48, 49, 50 }, { 49, 51, 50 },
    { 50, 51, 52 }, { 51, 53, 52 },
    { 52, 53, 54 }, { 53, 55, 54 },
    { 54, 55, 56 }, { 55, 57, 56 },
    { 56, 57, 58 }, { 57, 59, 58 },
    { 58, 59, 60 }, { 59, 61, 60 },
    { 60, 61, 62 }, { 61, 63, 62 },
    { 62, 63, 64 }, { 63, 65, 64 },
    { 64, 65, 66 }, { 65, 67, 66 },
    { 66, 67, 68 }, { 67, 69, 68 },
    { 68, 69, 70 }, { 69, 71, 70 },
    { 70, 71, 72 }, { 71, 73, 72 },
    { 72, 73, 74 }, { 73, 75, 74 },
    { 74, 75, 76 }, { 75, 77, 76 },
    { 76, 77, 78 }, { 77, 79, 78 },
    { 78, 79, 80 }, { 79, 81, 80 },
    { 80, 81, 82 }, { 81, 83, 82 },
    { 82, 83, 84 }, { 83, 85, 84 },
    { 84, 85, 86 }, { 85, 87, 86 },
    { 86, 87, 88 }, { 87, 89, 88 },
    { 88, 89, 90 }, { 89, 91, 90 },
    { 90, 91, 92 }, { 91, 93, 92 },
    { 92, 93, 94 }, { 93, 95, 94 },
    { 94, 95, 96 }, { 95, 97, 96 },
    { 96, 97, 98 }, { 97, 99, 98 },
    { 98, 99, 100 }, { 99, 101, 100 },
    { 100, 101, 102 }, { 101, 103, 102 },
    { 102, 103, 104 }, { 103, 105, 104 },
    { 104, 105, 106 }, { 105, 107, 106 },
    { 106, 107, 108 }, { 107, 109, 108 },
    { 108, 109, 110 }, { 109, 111, 110 },
    { 110, 111, 112 }, { 111, 113, 112 },
    { 112, 113, 114 }, { 113, 115, 114 },
    { 114, 115, 116 }, { 115, 117, 116 },
    { 116, 117, 118 }, { 117, 119, 118 },
    { 118, 119, 120 }, { 119, 121, 120 },
    { 120, 121, 122 }, { 121, 123, 122 },
    { 122, 123, 124 }, { 123, 125, 124 },
    { 124, 125, 126 }, { 125, 127, 126 },
    { 126, 127, 128 }, { 127, 129, 128 },
    { 128, 129, 130 }, { 129, 131, 130 },
    { 130, 131, 132 }, { 131, 133, 132 },
    { 132, 133, 134 }, { 133, 135, 134 },
    { 134, 135, 136 }, { 135, 137, 136 },
    { 136, 137, 138 }, { 137, 139, 138 },
    { 138, 139, 140 }, { 139, 141, 140 },
    { 140, 141, 142 }, { 141, 143, 142 },
    { 142, 143, 144 }, { 143, 145, 144 },
    { 144, 145, 146 }, { 145, 147, 146 },
    { 146, 147, 148 }, { 147, 149, 148 },
    { 148, 149, 150 }, { 149, 151, 150 },
    { 150, 151, 152 }, { 151, 153, 152 },
    { 152, 153, 154 }, { 153, 155, 154 },
    { 154, 155, 156 }, { 155, 157, 156 },
    { 156, 157, 158 }, { 157, 159, 158 },
    { 158, 159, 160 }, { 159, 161, 160 },
    { 160, 161, 162 }, { 161, 163, 162 },
    { 162, 163, 164 }, { 163, 165, 164 },
    { 164, 165, 166 }, { 165, 167, 166 },
    { 166, 167, 168 }, { 167, 169, 168 },
    { 168, 169, 170 }, { 169, 171, 170 },
    { 170, 171, 172 }, { 171, 173, 172 },
    { 172, 173, 174 }, { 173, 175, 174 },
    { 174, 175, 176 }, { 175, 177, 176 },
    { 176, 177, 178 }, { 177, 179, 178 },
    { 178, 179, 180 }, { 179, 181, 180 },
    { 180, 181, 182 }, { 181, 183, 182 },
    { 182, 183, 184 }, { 183, 185, 184 },
    { 184, 185, 186 }, { 185, 187, 186 },
    { 186, 187, 188 }, { 187, 189, 188 },
    { 188, 189, 190 }, { 189, 191, 190 },
    { 190, 191, 192 }, { 191, 193, 192 },
    { 192, 193, 194 }, { 193, 195, 194 },
    { 194, 195, 196 }, { 195, 197, 196 },
    { 196, 197, 198 }, { 197, 199, 198 },
    { 198, 199, 200 }, { 199, 201, 200 },
    { 200, 201, 202 }, { 201, 203, 202 },
    { 202, 203, 204 }, { 203, 205, 204 },
    { 204, 205, 206 }, { 205, 207, 206 },
    { 206, 207, 208 }, { 207, 209, 208 },
    { 208, 209, 210 }, { 209, 211, 210 },
    { 210, 211, 212 }, { 211, 213, 212 },
    { 212, 213, 214 }, { 213, 215, 214 },
    { 214, 215, 216 }, { 215, 217, 216 },
    { 216, 217, 218 }, { 217, 219, 218 },
    { 218, 219, 220 }, { 219, 221, 220 },
    { 220, 221, 222 }, { 221, 223, 222 },
    { 222, 223, 224 }, { 223, 225, 224 },
    { 224, 225, 226 }, { 225, 227, 226 },
    { 226, 227, 228 }, { 227, 229, 228 },
    { 228, 229, 230 }, { 229, 231, 230 },
    { 230, 231, 232 }, { 231, 233, 232 },
    { 232, 233, 234 }, { 233, 235, 234 },
    { 234, 235, 236 }, { 235, 237, 236 },
    { 236, 237, 238 }, { 237, 239, 238 },
    { 238, 239, 240 }, { 239, 241, 240 },
    { 240, 241, 242 }, { 241, 243, 242 },
    { 242, 243, 244 }, { 243, 245, 244 },
    { 244, 245, 246 }, { 245, 247, 246 },
    { 246, 247, 248 }, { 247, 249, 248 },
    { 248, 249, 250 }, { 249, 251, 250 },
    { 250, 251, 252 }, { 251, 253, 252 },
    { 252, 253, 254 }, { 253, 255, 254 },
    { 254, 255, 256 }, { 255, 257, 256 },
};

WORD TriangleFanPrecompDP[][3] = {
    { 1, 2, 0 }, { 2, 3, 0 },
    { 3, 4, 0 }, { 4, 5, 0 },
    { 5, 6, 0 }, { 6, 7, 0 },
    { 7, 8, 0 }, { 8, 9, 0 },
    { 9, 10, 0 }, { 10, 11, 0 },
    { 11, 12, 0 }, { 12, 13, 0 },
    { 13, 14, 0 }, { 14, 15, 0 },
    { 15, 16, 0 }, { 16, 17, 0 },
    { 17, 18, 0 }, { 18, 19, 0 },
    { 19, 20, 0 }, { 20, 21, 0 },
    { 21, 22, 0 }, { 22, 23, 0 },
    { 23, 24, 0 }, { 24, 25, 0 },
    { 25, 26, 0 }, { 26, 27, 0 },
    { 27, 28, 0 }, { 28, 29, 0 },
    { 29, 30, 0 }, { 30, 31, 0 },
    { 31, 32, 0 }, { 32, 33, 0 },
    { 33, 34, 0 }, { 34, 35, 0 },
    { 35, 36, 0 }, { 36, 37, 0 },
    { 37, 38, 0 }, { 38, 39, 0 },
    { 39, 40, 0 }, { 40, 41, 0 },
    { 41, 42, 0 }, { 42, 43, 0 },
    { 43, 44, 0 }, { 44, 45, 0 },
    { 45, 46, 0 }, { 46, 47, 0 },
    { 47, 48, 0 }, { 48, 49, 0 },
    { 49, 50, 0 }, { 50, 51, 0 },
    { 51, 52, 0 }, { 52, 53, 0 },
    { 53, 54, 0 }, { 54, 55, 0 },
    { 55, 56, 0 }, { 56, 57, 0 },
    { 57, 58, 0 }, { 58, 59, 0 },
    { 59, 60, 0 }, { 60, 61, 0 },
    { 61, 62, 0 }, { 62, 63, 0 },
    { 63, 64, 0 }, { 64, 65, 0 },
    { 65, 66, 0 }, { 66, 67, 0 },
    { 67, 68, 0 }, { 68, 69, 0 },
    { 69, 70, 0 }, { 70, 71, 0 },
    { 71, 72, 0 }, { 72, 73, 0 },
    { 73, 74, 0 }, { 74, 75, 0 },
    { 75, 76, 0 }, { 76, 77, 0 },
    { 77, 78, 0 }, { 78, 79, 0 },
    { 79, 80, 0 }, { 80, 81, 0 },
    { 81, 82, 0 }, { 82, 83, 0 },
    { 83, 84, 0 }, { 84, 85, 0 },
    { 85, 86, 0 }, { 86, 87, 0 },
    { 87, 88, 0 }, { 88, 89, 0 },
    { 89, 90, 0 }, { 90, 91, 0 },
    { 91, 92, 0 }, { 92, 93, 0 },
    { 93, 94, 0 }, { 94, 95, 0 },
    { 95, 96, 0 }, { 96, 97, 0 },
    { 97, 98, 0 }, { 98, 99, 0 },
    { 99, 100, 0 }, { 100, 101, 0 },
    { 101, 102, 0 }, { 102, 103, 0 },
    { 103, 104, 0 }, { 104, 105, 0 },
    { 105, 106, 0 }, { 106, 107, 0 },
    { 107, 108, 0 }, { 108, 109, 0 },
    { 109, 110, 0 }, { 110, 111, 0 },
    { 111, 112, 0 }, { 112, 113, 0 },
    { 113, 114, 0 }, { 114, 115, 0 },
    { 115, 116, 0 }, { 116, 117, 0 },
    { 117, 118, 0 }, { 118, 119, 0 },
    { 119, 120, 0 }, { 120, 121, 0 },
    { 121, 122, 0 }, { 122, 123, 0 },
    { 123, 124, 0 }, { 124, 125, 0 },
    { 125, 126, 0 }, { 126, 127, 0 },
    { 127, 128, 0 }, { 128, 129, 0 },
    { 129, 130, 0 }, { 130, 131, 0 },
    { 131, 132, 0 }, { 132, 133, 0 },
    { 133, 134, 0 }, { 134, 135, 0 },
    { 135, 136, 0 }, { 136, 137, 0 },
    { 137, 138, 0 }, { 138, 139, 0 },
    { 139, 140, 0 }, { 140, 141, 0 },
    { 141, 142, 0 }, { 142, 143, 0 },
    { 143, 144, 0 }, { 144, 145, 0 },
    { 145, 146, 0 }, { 146, 147, 0 },
    { 147, 148, 0 }, { 148, 149, 0 },
    { 149, 150, 0 }, { 150, 151, 0 },
    { 151, 152, 0 }, { 152, 153, 0 },
    { 153, 154, 0 }, { 154, 155, 0 },
    { 155, 156, 0 }, { 156, 157, 0 },
    { 157, 158, 0 }, { 158, 159, 0 },
    { 159, 160, 0 }, { 160, 161, 0 },
    { 161, 162, 0 }, { 162, 163, 0 },
    { 163, 164, 0 }, { 164, 165, 0 },
    { 165, 166, 0 }, { 166, 167, 0 },
    { 167, 168, 0 }, { 168, 169, 0 },
    { 169, 170, 0 }, { 170, 171, 0 },
    { 171, 172, 0 }, { 172, 173, 0 },
    { 173, 174, 0 }, { 174, 175, 0 },
    { 175, 176, 0 }, { 176, 177, 0 },
    { 177, 178, 0 }, { 178, 179, 0 },
    { 179, 180, 0 }, { 180, 181, 0 },
    { 181, 182, 0 }, { 182, 183, 0 },
    { 183, 184, 0 }, { 184, 185, 0 },
    { 185, 186, 0 }, { 186, 187, 0 },
    { 187, 188, 0 }, { 188, 189, 0 },
    { 189, 190, 0 }, { 190, 191, 0 },
    { 191, 192, 0 }, { 192, 193, 0 },
    { 193, 194, 0 }, { 194, 195, 0 },
    { 195, 196, 0 }, { 196, 197, 0 },
    { 197, 198, 0 }, { 198, 199, 0 },
    { 199, 200, 0 }, { 200, 201, 0 },
    { 201, 202, 0 }, { 202, 203, 0 },
    { 203, 204, 0 }, { 204, 205, 0 },
    { 205, 206, 0 }, { 206, 207, 0 },
    { 207, 208, 0 }, { 208, 209, 0 },
    { 209, 210, 0 }, { 210, 211, 0 },
    { 211, 212, 0 }, { 212, 213, 0 },
    { 213, 214, 0 }, { 214, 215, 0 },
    { 215, 216, 0 }, { 216, 217, 0 },
    { 217, 218, 0 }, { 218, 219, 0 },
    { 219, 220, 0 }, { 220, 221, 0 },
    { 221, 222, 0 }, { 222, 223, 0 },
    { 223, 224, 0 }, { 224, 225, 0 },
    { 225, 226, 0 }, { 226, 227, 0 },
    { 227, 228, 0 }, { 228, 229, 0 },
    { 229, 230, 0 }, { 230, 231, 0 },
    { 231, 232, 0 }, { 232, 233, 0 },
    { 233, 234, 0 }, { 234, 235, 0 },
    { 235, 236, 0 }, { 236, 237, 0 },
    { 237, 238, 0 }, { 238, 239, 0 },
    { 239, 240, 0 }, { 240, 241, 0 },
    { 241, 242, 0 }, { 242, 243, 0 },
    { 243, 244, 0 }, { 244, 245, 0 },
    { 245, 246, 0 }, { 246, 247, 0 },
    { 247, 248, 0 }, { 248, 249, 0 },
    { 249, 250, 0 }, { 250, 251, 0 },
    { 251, 252, 0 }, { 252, 253, 0 },
    { 253, 254, 0 }, { 254, 255, 0 },
    { 255, 256, 0 }, { 256, 257, 0 },
    { 257, 258, 0 },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\surfiter.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surfiter.hpp
 *  Content:    Utility iterator classes for cubemaps and mipmaps
 *
 ***************************************************************************/
#ifndef _SURFITER_HPP_
#define _SURFITER_HPP_

/* Mipmap iterator utility class */
class CMipmapIter
{
    // Private Data

    LPDDRAWI_DDRAWSURFACE_LCL m_currlcl;

    // Public Members

public:

    // Construct and Destroy

    CMipmapIter(LPDDRAWI_DDRAWSURFACE_LCL lpLcl) : m_currlcl(lpLcl) {}
    
    // Modifiers
    inline void operator++();
    
    // Accessors
    operator const void* () const { return m_currlcl; }
    LPDDRAWI_DDRAWSURFACE_LCL operator()() const { return m_currlcl; }
};

inline void CMipmapIter::operator++()
{
    LPATTACHLIST al = m_currlcl->lpAttachList;
    while(al != NULL)
    {
        if(al->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL)
        {
            m_currlcl = al->lpAttached;
            return;
        }
        al = al->lpLink;
    }
    m_currlcl = 0;
}

/* Cubemap iterator utility class */
class CCubemapIter
{
    // Private Data

    LPDDRAWI_DDRAWSURFACE_LCL m_currlcl;
    LPATTACHLIST m_al;

    // Public Members

public:

    // Construct and Destroy

    CCubemapIter(LPDDRAWI_DDRAWSURFACE_LCL lpLcl) : m_currlcl(lpLcl), m_al(lpLcl->lpAttachList) {}
    
    // Modifiers
    inline void operator++();
    
    // Accessors
    operator const void* () const { return m_currlcl; }
    LPDDRAWI_DDRAWSURFACE_LCL operator()() const { return m_currlcl; }
};

inline void CCubemapIter::operator++()
{
    while(m_al != NULL)
    {
        DWORD &caps2 = m_al->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        if((caps2 & DDSCAPS2_CUBEMAP_ALLFACES) && !(caps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            m_currlcl = m_al->lpAttached;
            m_al = m_al->lpLink;
            return;
        }
        m_al = m_al->lpLink;
    }
    m_currlcl = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\stateset.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.hpp
 *  Content:    State sets handling interfaces
 *
 ***************************************************************************/
#ifndef _STATESET_HPP_
#define _STATESET_HPP_

struct  CHandle;
const   DWORD __INVALIDHANDLE = 0xFFFFFFFF;

extern void InsertStateSetOp(LPDIRECT3DDEVICEI pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt);
//---------------------------------------------------------------------
// This class is used to generate sequential integer numbers (handles).
// When a handle is released it will be reused.
// Number of handles is unlimited
//
class CHandleFactory
{
public: 
    CHandleFactory() {m_dwArraySize = 0; m_Handles = NULL;}
    ~CHandleFactory();
    HRESULT Init(DWORD dwInitialSize, DWORD dwGrowSize);
    DWORD CreateNewHandle();
    void ReleaseHandle(DWORD handle);
protected:
    CHandle* CreateHandleArray(DWORD dwSize);

    CHandle        *m_Handles;      // Array of objects
    DWORD           m_dwGrowSize;   
    DWORD           m_dwArraySize;  // Number of objects in the array
    DWORD           m_Free;         // Header for free elements in the array
};
 //---------------------------------------------------------------------
// This class provides interface to the growing state set buffer
//
class CStateSetBuffer
{
public:
    CStateSetBuffer()  
        {
            m_pBuffer = NULL; 
            m_dwCurrentSize = 0; 
            m_dwBufferSize = 0;
            m_pDP2CurrCommand = 0;
        }
    CStateSetBuffer(CStateSetBuffer& src)  
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            m_dwBufferSize = src.m_dwCurrentSize;
            if(m_dwCurrentSize != 0)
            {
                m_pBuffer = new BYTE[m_dwCurrentSize];
                if(m_pBuffer == 0)
                {
                    m_dwCurrentSize = 0;
                    m_pDP2CurrCommand = 0;
                    throw DDERR_OUTOFMEMORY;
                }
                memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            }
            else
            {
                m_pBuffer = 0;
            }
            m_pDP2CurrCommand = 0;
        }
    ~CStateSetBuffer() 
        {
            delete [] m_pBuffer;
        }
    void operator=(CStateSetBuffer& src)  
        {
            m_dwCurrentSize = src.m_dwCurrentSize; 
            if(m_dwBufferSize != m_dwCurrentSize)
            {
                m_dwBufferSize = m_dwCurrentSize;
                delete [] m_pBuffer;
                if(m_dwCurrentSize != 0)
                {
                    m_pBuffer = new BYTE[m_dwCurrentSize];
                    if(m_pBuffer == 0)
                    {
                        m_dwCurrentSize = 0;
                        m_pDP2CurrCommand = 0;
                        throw DDERR_OUTOFMEMORY;
                    }
                }
                else
                {
                    m_pBuffer = 0;
                    m_pDP2CurrCommand = 0;
                    return;
                }
            }
            memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            m_pDP2CurrCommand = 0;
        }
    // Insert a command to the buffer. Grow buffer if necessary
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize);
    // Reset current command
    void ResetCurrentCommand()
        {
            m_pDP2CurrCommand = 0;
        }
    // Set buffer to its initial state. Memory is not freed
    void Reset() 
        {
            m_dwCurrentSize = 0;
            m_pDP2CurrCommand = 0;
        }

    DWORD   m_dwCurrentSize;
    DWORD   m_dwBufferSize;
    BYTE    *m_pBuffer;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND m_pDP2CurrCommand;
};
//---------------------------------------------------------------------
// This class provides interface to a state set
//
const DWORD __STATESET_INITIALIZED          = 1;
// Set if we have to check if we need to restore texture stage indices
const DWORD __STATESET_NEEDCHECKREMAPPING   = 2;
class CStateSet
{
public:
    CStateSet() 
        {
            m_dwStateSetFlags = 0;
            m_dwDeviceHandle = __INVALIDHANDLE;
        }
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    // Mark the state set as unused. The object is not destroyed and can be
    // reused
    HRESULT Release();
    // Execute the front-end only or device state subset
    void Execute(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer);
    // Capture the current device state into the state block
    void Capture(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer);
    // Reset the current command in both buffers
    void ResetCurrentCommand()
        {
            m_FEOnlyBuffer.ResetCurrentCommand();
            m_DriverBuffer.ResetCurrentCommand();
        }
protected:
    CStateSetBuffer m_FEOnlyBuffer; // Contains commands that driver can not 
                                    // understand
    CStateSetBuffer m_DriverBuffer; // Contains commands that driver can 
                                    // understand
    DWORD   m_dwDeviceHandle;       // Some sets could not have corresponding
                                    // device buffers, so device handle is not 
                                    // equal to the user visible handle
    DWORD   m_dwStateSetFlags;
    friend class CStateSets;
};
//---------------------------------------------------------------------
// This class encapsulates handling of array of state sets
//
class CStateSets
{
public:
    CStateSets();
    ~CStateSets();
    HRESULT Init(DWORD dwFlags);
    HRESULT StartNewSet();
    void EndSet();
    // Returns current handle
    DWORD GetCurrentHandle() {return m_dwCurrentHandle;}
    // Delete state set
    void DeleteStateSet(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Returns information about state set data to be written to the device
    // Allocates a new handle for the device buffer
    void GetDeviceBufferInfo(DWORD* dwStateSetHandle, LPVOID *pBuffer, DWORD* dwBufferSize);
    // Insert a render state to the current state set
    // Throws an exception in case of error
    void InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue, 
                           BOOL bDriverCanHandle);
    void InsertLight(DWORD dwLightIndex, LPD3DLIGHT7);
    void InsertLightEnable(DWORD dwLightIndex, BOOL bEnable);
    void InsertMaterial(LPD3DMATERIAL7);
    void InsertViewport(LPD3DVIEWPORT7);
    void InsertTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat);
    void InsertTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void InsertTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 pTex);
    void InsertClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    // Execute a state set with the specified handle
    void Execute(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Capture a state set to the the specified handle
    void Capture(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Capture predefined state
    void CreatePredefined(LPDIRECT3DDEVICEI pDevI, D3DSTATEBLOCKTYPE sbt);
    void Cleanup(DWORD dwHandle);
protected:
    const DWORD m_GrowSize;
    DWORD       m_dwMaxSets;        // Maximum number of state sets
    DWORD       m_dwCurrentHandle;
    CStateSet * m_pStateSets;       // Array of state sets
    CStateSet * m_pCurrentStateSet; 
    CHandleFactory m_DeviceHandles; // Used to create device handles
    CHandleFactory m_SetHandles;    // Used to create state sets
    CStateSet   m_BufferSet;
    DWORD       m_dwFlags;
};

// This is RESERVED0 in d3dhal.h
#define D3DDP2OP_FRONTENDDATA   4           // Used by the front-end only

// This structure is used by the front-end only
typedef struct _D3DHAL_DP2FRONTENDDATA
{
    WORD   wStage;      // texture stage
    LPVOID pTexture;    // Texture pointer
} D3DHAL_DP2FRONTENDDATA, *LPD3DHAL_DP2FRONTENDDATA;

#endif //_STATESTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\stateset.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.cpp
 *  Content:    State sets handling
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

//=====================================================================
//      CStateSets interface
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CStateSets"

CStateSets::CStateSets(): m_GrowSize(10)
{
    m_dwMaxSets = 0;
    m_dwCurrentHandle = __INVALIDHANDLE;
    m_pStateSets = NULL;
    // Init handle factory
    m_SetHandles.Init(m_GrowSize, m_GrowSize);
    m_SetHandles.CreateNewHandle(); // Reserve handle 0
    m_DeviceHandles.Init(m_GrowSize, m_GrowSize);
    m_DeviceHandles.CreateNewHandle(); // Reserve handle 0
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::~CStateSets"

CStateSets::~CStateSets()
{
    delete [] m_pStateSets;
    m_SetHandles.ReleaseHandle(0);
    m_DeviceHandles.ReleaseHandle(0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Init"

HRESULT CStateSets::Init(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::StartNewSet"

HRESULT CStateSets::StartNewSet()
{
    m_dwCurrentHandle = m_SetHandles.CreateNewHandle();
    if (m_dwCurrentHandle == __INVALIDHANDLE)
        return DDERR_OUTOFMEMORY;
    if (m_dwCurrentHandle >= m_dwMaxSets)
    {
        // Time to grow the array
        CStateSet *pNew = new CStateSet[m_dwMaxSets + m_GrowSize];
        if (pNew == NULL)
        {
            m_SetHandles.ReleaseHandle(m_dwCurrentHandle);
            return DDERR_OUTOFMEMORY;
        }
        for (DWORD i=0; i < m_dwMaxSets; i++)
            pNew[i] = m_pStateSets[i];
        delete [] m_pStateSets;
        m_pStateSets = pNew;
        m_dwMaxSets += m_GrowSize;
    }
    m_BufferSet.m_FEOnlyBuffer.Reset();
    m_BufferSet.m_DriverBuffer.Reset();
    m_pCurrentStateSet = &m_BufferSet;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::EndSet"

void CStateSets::EndSet()
{
    m_pStateSets[m_dwCurrentHandle] = *m_pCurrentStateSet;
    m_pCurrentStateSet = &m_pStateSets[m_dwCurrentHandle];
    m_pCurrentStateSet->m_dwStateSetFlags |= __STATESET_INITIALIZED;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::DeleteStateSet"

void CStateSets::DeleteStateSet(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("State block handle is greater than available number of blocks");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block is not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }

    // Pass delete instruction to the driver only if there was some data recorded
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
        InsertStateSetOp(pDevI, D3DHAL_STATESETDELETE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);

    Cleanup(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Cleanup"

void CStateSets::Cleanup(DWORD dwHandle)
{
    CStateSet &pStateSet = m_pStateSets[dwHandle];
    m_SetHandles.ReleaseHandle(dwHandle);
    if (pStateSet.m_dwDeviceHandle != __INVALIDHANDLE)
        m_DeviceHandles.ReleaseHandle(pStateSet.m_dwDeviceHandle);
    pStateSet.Release();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Capture"

void CStateSets::Capture(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    pStateSet->Capture(pDevI, TRUE);
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
    {
        pStateSet->Capture(pDevI, FALSE);
        InsertStateSetOp(pDevI, D3DHAL_STATESETCAPTURE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CreatePredefined"

void CStateSets::CreatePredefined(LPDIRECT3DDEVICEI pDevI, D3DSTATEBLOCKTYPE sbt)
{
    static D3DRENDERSTATETYPE ALLrstates[] =
    {
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_EXTENTS,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRENDERSTATE_COLORKEYBLENDENABLE
    };
    static D3DTEXTURESTAGESTATETYPE ALLtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESS,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };
    static D3DRENDERSTATETYPE PIXELrstates[] =
    {
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_COLORKEYBLENDENABLE
    };
    static D3DTEXTURESTAGESTATETYPE PIXELtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESS,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };
    static D3DRENDERSTATETYPE VERTEXrstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_EXTENTS,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE
    };
    static D3DTEXTURESTAGESTATETYPE VERTEXtsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    DWORD i;

    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        for(i = 0; i < sizeof(ALLrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(ALLrstates[i], pDevI->rstates[ALLrstates[i]], pDevI->CanHandleRenderState(ALLrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(ALLtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, ALLtsstates[j], pDevI->tsstates[i][ALLtsstates[j]]);

        // Capture textures
        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
        {
            LPDIRECTDRAWSURFACE7 pTexture;
            if (pDevI->lpD3DMappedTexI[i])
            {
                if(pDevI->lpD3DMappedTexI[i]->D3DManaged())
                    pTexture = pDevI->lpD3DMappedTexI[i]->lpDDSSys;
                else
                    pTexture = pDevI->lpD3DMappedTexI[i]->lpDDS;
            }
            else
            {
                pTexture = NULL;
            }
            InsertTexture(i, pTexture);
        }

        // Capture current viewport
        InsertViewport(&pDevI->m_Viewport);

        // Capture current transforms
        InsertTransform(D3DTRANSFORMSTATE_WORLD, (LPD3DMATRIX)&pDevI->transform.world[0]);
        InsertTransform(D3DTRANSFORMSTATE_VIEW, (LPD3DMATRIX)&pDevI->transform.view);
        InsertTransform(D3DTRANSFORMSTATE_PROJECTION, (LPD3DMATRIX)&pDevI->transform.proj);
        InsertTransform(D3DTRANSFORMSTATE_WORLD1, (LPD3DMATRIX)&pDevI->transform.world[1]);
        InsertTransform(D3DTRANSFORMSTATE_WORLD2, (LPD3DMATRIX)&pDevI->transform.world[2]);
        InsertTransform(D3DTRANSFORMSTATE_WORLD3, (LPD3DMATRIX)&pDevI->transform.world[3]);
        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
        {
            InsertTransform((D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i), (LPD3DMATRIX)&pDevI->mTexture[i]);
        }

        // Capture current clip-planes
        for (i = 0; i < pDevI->transform.dwMaxUserClipPlanes; i++)
        {
            InsertClipPlane(i, (LPD3DVALUE)&pDevI->transform.userClipPlane[i]);
        }

        // Capture current material
        InsertMaterial(&pDevI->lighting.material);

        // Capture current lights
        for (i = 0; i < pDevI->m_dwNumLights; i++)
        {
            if(pDevI->m_pLights[i].Valid())
            {
                InsertLight(i, &pDevI->m_pLights[i].m_Light);
                if(pDevI->m_pLights[i].Enabled())
                {
                    InsertLightEnable(i, TRUE);
                }
                else
                {
                    InsertLightEnable(i, FALSE);
                }
            }
        }
        break;

    case D3DSBT_PIXELSTATE:
        for(i = 0; i < sizeof(PIXELrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(PIXELrstates[i], pDevI->rstates[PIXELrstates[i]], pDevI->CanHandleRenderState(PIXELrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(PIXELtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, PIXELtsstates[j], pDevI->tsstates[i][PIXELtsstates[j]]);
        break;

    case D3DSBT_VERTEXSTATE:
        for(i = 0; i < sizeof(VERTEXrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(VERTEXrstates[i], pDevI->rstates[VERTEXrstates[i]], pDevI->CanHandleRenderState(VERTEXrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(VERTEXtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, VERTEXtsstates[j], pDevI->tsstates[i][VERTEXtsstates[j]]);

        // Capture current light enables
        for (i = 0; i < pDevI->m_dwNumLights; i++)
        {
            if(pDevI->m_pLights[i].Valid())
            {
                if(pDevI->m_pLights[i].Enabled())
                {
                    InsertLightEnable(i, TRUE);
                }
                else
                {
                    InsertLightEnable(i, FALSE);
                }
            }
        }
        break;

    default:
        throw DDERR_INVALIDPARAMS;
   }
}
//---------------------------------------------------------------------
// Allocates device handle if necessary
// And returns information of the device buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::GetDeviceBufferInfo(DWORD* dwStateSetHandle,
                                     LPVOID *pBuffer,
                                     DWORD* dwBufferSize)
{
    if (m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize != 0)
    {
        // Allocate  a handle for the device
        m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle();
        if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
        {
            D3D_ERR("Cannot allocate device handle for a state block");
            throw DDERR_OUTOFMEMORY;
        }
    }
    *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
    *pBuffer = (LPVOID)m_pCurrentStateSet->m_DriverBuffer.m_pBuffer;
    *dwBufferSize = m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertRenderState"

void CStateSets::InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                                      BOOL bDriverCanHandle)
{
    struct
    {
        D3DRENDERSTATETYPE state;
        DWORD dwValue;
    } data = {state, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_RENDERSTATE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && bDriverCanHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLight"

void CStateSets::InsertLight(DWORD dwLightIndex, LPD3DLIGHT7 pData)
{
    struct
    {
        D3DHAL_DP2SETLIGHT header;
        D3DLIGHT7   light;
    } data;
    data.header.dwIndex = dwLightIndex;
    data.header.dwDataType = D3DHAL_SETLIGHT_DATA;
    data.light= *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLightEnable"

void CStateSets::InsertLightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    D3DHAL_DP2SETLIGHT data;
    data.dwIndex = dwLightIndex;
    if (bEnable)
        data.dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        data.dwDataType = D3DHAL_SETLIGHT_DISABLE;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertViewport"

void CStateSets::InsertViewport(LPD3DVIEWPORT7 lpVwpData)
{
    D3DHAL_DP2VIEWPORTINFO data2;
    data2.dwX = lpVwpData->dwX;
    data2.dwY = lpVwpData->dwY;
    data2.dwWidth = lpVwpData->dwWidth;
    data2.dwHeight = lpVwpData->dwHeight;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_VIEWPORTINFO, &data2, sizeof(data2),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    D3DHAL_DP2ZRANGE data1;
    data1.dvMinZ = lpVwpData->dvMinZ;
    data1.dvMaxZ = lpVwpData->dvMaxZ;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_ZRANGE, &data1, sizeof(data1),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertMaterial"

void CStateSets::InsertMaterial(LPD3DMATERIAL7 pData)
{
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETMATERIAL,
                                      pData, sizeof(D3DMATERIAL7),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertClipPlane"

void CStateSets::InsertClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    D3DHAL_DP2SETCLIPPLANE data;
    data.dwIndex = dwPlaneIndex;
    data.plane[0] = pPlaneEquation[0];
    data.plane[1] = pPlaneEquation[1];
    data.plane[2] = pPlaneEquation[2];
    data.plane[3] = pPlaneEquation[3];
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETCLIPPLANE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTransform"

void CStateSets::InsertTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    D3DHAL_DP2SETTRANSFORM data;
    data.xfrmType = state;
    data.matrix = *lpMat;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETTRANSFORM,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTextureStageState"

void CStateSets::InsertTextureStageState(DWORD dwStage,
                                            D3DTEXTURESTAGESTATETYPE type,
                                            DWORD dwValue)
{
    D3DHAL_DP2TEXTURESTAGESTATE data = {(WORD)dwStage, type, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_TEXTURESTAGESTATE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTexture"

void CStateSets::InsertTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 pTex)
{
    D3DHAL_DP2FRONTENDDATA data = {(WORD)dwStage, (LPVOID)pTex};
    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FRONTENDDATA, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Execute"

void CStateSets::Execute(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
#if DBG
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
#endif
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
#if DBG
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
#endif
    // Parse recorded data first
    pStateSet->Execute(pDevI, TRUE);
    // If the hardware buffer is not empty, we pass recorded data to it
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
    {
        pStateSet->Execute(pDevI, FALSE);
        InsertStateSetOp(pDevI, D3DHAL_STATESETEXECUTE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
    }
}
//=====================================================================
//      CStateSet interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Release"

HRESULT CStateSet::Release()
{
     if (!(m_dwStateSetFlags & __STATESET_INITIALIZED))
        return D3DERR_INVALIDSTATEBLOCK;
    m_dwStateSetFlags &= ~__STATESET_INITIALIZED;
    m_FEOnlyBuffer.Reset();
    m_DriverBuffer.Reset();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::InsertCommand"

void CStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                 DWORD dwDataSize,
                                 BOOL bDriverCanHandle)
{
    if (op == D3DDP2OP_TEXTURESTAGESTATE ||
        (op == D3DDP2OP_RENDERSTATE &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState >= D3DRENDERSTATE_WRAP0 &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState <= D3DRENDERSTATE_WRAP7))
    {
        m_dwStateSetFlags |= __STATESET_NEEDCHECKREMAPPING;
    }
    if (bDriverCanHandle)
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    else
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Execute"

void CStateSet::Execute(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    try
    {
        // Texture stages could be re-mapped during texture transform processing.
        // Before we set new values we have to restore original ones
        if (pDevI->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES &&
            m_dwStateSetFlags & __STATESET_NEEDCHECKREMAPPING)
        {
            RestoreTextureStages(pDevI);
            pDevI->ForceFVFRecompute();
        }

        if (bFrontEndBuffer)
        {
            p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
            dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
        }
        else
        {
            p = (DWORD*)m_DriverBuffer.m_pBuffer;
            dwSize = m_DriverBuffer.m_dwCurrentSize;
            pDevI->dwFEFlags |= D3DFE_EXECUTESTATEMODE;
        }
        pEnd = (DWORD*)((BYTE*)p + dwSize);
        while (p < pEnd)
        {
            LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
            switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
            {
            case D3DDP2OP_RENDERSTATE:
                {
                    if(pDevI->dwFEFlags & D3DFE_EXECUTESTATEMODE)
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if (pDevI->rstates[dwState] != dwValue)
                            {
                                if (!(pDevI->rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState");
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if (pDevI->rstates[dwState] != dwValue)
                            {
                                if (!(pDevI->rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                    HRESULT ret = pDevI->SetRenderStateI(dwState, dwValue);
                                    if(ret != D3D_OK)
                                        throw ret;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                    if (pDevI->CanHandleRenderState(dwState))
                                    {
                                        HRESULT ret = pDevI->SetRenderStateI(dwState, dwValue);
                                        if(ret != D3D_OK)
                                            throw ret;
                                    }
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState");
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETLIGHT:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                        switch (pData->dwDataType)
                        {
                        case D3DHAL_SETLIGHT_ENABLE:
                            pDevI->LightEnableI( pData->dwIndex, TRUE );
                            break;
                        case D3DHAL_SETLIGHT_DISABLE:
                            pDevI->LightEnableI( pData->dwIndex, FALSE );
                            break;
                        case D3DHAL_SETLIGHT_DATA:
                            pDevI->SetLightI(pData->dwIndex, (D3DLIGHT7 *)p);
                            p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT7));
                            break;
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETMATERIAL:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                        pDevI->SetMaterialI(pData);
                    }
                    break;
                }
            case D3DDP2OP_SETTRANSFORM:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETTRANSFORM *pData = (D3DHAL_DP2SETTRANSFORM*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                        pDevI->SetTransformI(pData->xfrmType, &pData->matrix);
                    }
                    break;
                }
            case D3DDP2OP_TEXTURESTAGESTATE:
                {
                    if (pDevI->dwFEFlags & D3DFE_EXECUTESTATEMODE)
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                    pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                                else
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState");
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    if(pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue))
                                        continue;
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                                if (dwStage >= pDevI->dwMaxTextureBlendStages)
                                    continue;
                                HRESULT ret = pDevI->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                                if(ret != D3D_OK)
                                    throw ret;
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState");
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_FRONTENDDATA:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                        HRESULT ret = pDevI->SetTexture(pData->wStage, (LPDIRECTDRAWSURFACE7)pData->pTexture);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_VIEWPORTINFO:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DVIEWPORT7 viewport;
                        LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                        viewport.dwX      = lpVwpData->dwX;
                        viewport.dwY      = lpVwpData->dwY;
                        viewport.dwWidth  = lpVwpData->dwWidth;
                        viewport.dwHeight = lpVwpData->dwHeight;

                        // The next command has to be D3DDP2OP_ZRANGE
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                        LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                        viewport.dvMinZ      = pData->dvMinZ;
                        viewport.dvMaxZ      = pData->dvMaxZ;

                        pDevI->SetViewportI(&viewport);
                    }
                    break;
                }
            case D3DDP2OP_SETCLIPPLANE:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETCLIPPLANE *pData = (D3DHAL_DP2SETCLIPPLANE*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                        pDevI->SetClipPlaneI(pData->dwIndex, pData->plane);
                    }
                    break;
                }
#ifdef DBG
            default:
                DDASSERT(FALSE);
#endif
            }
        }
        pDevI->dwFEFlags &= ~D3DFE_EXECUTESTATEMODE;
    }
    catch(HRESULT ret)
    {
        pDevI->dwFEFlags &= ~D3DFE_EXECUTESTATEMODE;
        throw ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Capture"

void CStateSet::Capture(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        p = (DWORD*)m_DriverBuffer.m_pBuffer;
        dwSize = m_DriverBuffer.m_dwCurrentSize;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    const D3DRENDERSTATETYPE state = (D3DRENDERSTATETYPE)*p++;
                    *p++ = pDevI->rstates[state];
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    if(pData->dwIndex >= pDevI->m_dwNumLights)
                    {
                        D3D_ERR("Unable to capture light state (light not set?)");
                        throw D3DERR_LIGHT_SET_FAILED;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!pDevI->m_pLights[pData->dwIndex].Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(pDevI->m_pLights[pData->dwIndex].Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        *((LPD3DLIGHT7)p) = pDevI->m_pLights[pData->dwIndex].m_Light;
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT7));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = pDevI->lighting.material;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_WORLD:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[0]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD1:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[1]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD2:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[2]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD3:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[3]);
                        break;
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.view);
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.proj);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[0]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE1:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[1]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE2:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[2]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE3:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[3]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE4:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[4]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE5:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[5]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE6:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[6]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[7]);
                        break;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = pDevI->tsstates[pData->wStage][pData->TSState];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                }
                break;
            }
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    if (pDevI->lpD3DMappedTexI[pData->wStage])
                    {
                        if(pDevI->lpD3DMappedTexI[pData->wStage]->D3DManaged())
                            pData->pTexture = pDevI->lpD3DMappedTexI[pData->wStage]->lpDDSSys;
                        else
                            pData->pTexture = pDevI->lpD3DMappedTexI[pData->wStage]->lpDDS;
                    }
                    else
                    {
                        pData->pTexture = NULL;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DVIEWPORT7 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = pDevI->m_Viewport.dwX;
                    lpVwpData->dwY      = pDevI->m_Viewport.dwY;
                    lpVwpData->dwWidth  = pDevI->m_Viewport.dwWidth;
                    lpVwpData->dwHeight = pDevI->m_Viewport.dwHeight;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = pDevI->m_Viewport.dvMinZ;
                    pData->dvMaxZ = pDevI->m_Viewport.dvMaxZ;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPD3DVECTORH)pData->plane) = pDevI->transform.userClipPlane[pData->dwIndex];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
#ifdef DBG
        default:
            DDASSERT(FALSE);
#endif
        }
    }
}
//=====================================================================
//      CStateSetBuffer interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSetBuffer::InsertCommand"

void CStateSetBuffer::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData, DWORD dwDataSize)
{
    const DWORD GROWSIZE = 1024;
    if (m_pDP2CurrCommand != 0 && m_pDP2CurrCommand->bCommand == op)
    {
        if (dwDataSize + m_dwCurrentSize <= m_dwBufferSize)
        {
            ++m_pDP2CurrCommand->wStateCount;
            memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
            m_dwCurrentSize += dwDataSize;
            return;
        }
    }
    // Check for space
    if (sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize > m_dwBufferSize)
    {
        // We need to grow the buffer
        DWORD dwNewBufferSize = max(m_dwBufferSize + GROWSIZE, sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize);
        BYTE *pTmp = new BYTE[dwNewBufferSize];
        if (pTmp == NULL)
        {
            D3D_ERR("Not enough memory to create state block buffer");
            throw DDERR_OUTOFMEMORY;
        }
        if (m_pBuffer)
        {
            memcpy(pTmp, m_pBuffer, m_dwCurrentSize);
            delete [] m_pBuffer;
        }
        m_pBuffer = pTmp;
        m_dwBufferSize = dwNewBufferSize;
    }
    // Add new instruction
    m_pDP2CurrCommand = (LPD3DHAL_DP2COMMAND)(m_pBuffer + m_dwCurrentSize);
    m_pDP2CurrCommand->bCommand = op;
    m_pDP2CurrCommand->bReserved = 0;
    m_pDP2CurrCommand->wStateCount = 1;
    m_dwCurrentSize += sizeof(D3DHAL_DP2COMMAND);
    memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
    m_dwCurrentSize += dwDataSize;
    return;
}
//=====================================================================
void InsertStateSetOp(LPDIRECT3DDEVICEI pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt)
{
    CDirect3DDeviceIDP2 *device = static_cast<CDirect3DDeviceIDP2*>(pDevI);
    LPD3DHAL_DP2STATESET pData;
    pData = (LPD3DHAL_DP2STATESET)device->GetHalBufferPointer(D3DDP2OP_STATESET, sizeof(*pData));
    pData->dwOperation = dwOperation;
    pData->dwParam = dwParam;
    pData->sbType = sbt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\testprov.h ===
//----------------------------------------------------------------------------
//
// testprov.h
//
// Test HAL provider class.
//
// Test HAL provider is an itermediate object between D3DIM and
// real HAL provider. Itis used to print some data sent to a driver to a
// file. After that the real HAL driver is called.
// Test HAL provider is enabled by specifying non-empty string key "TestFile"
// under DIRECT3D key in the registry. The specified string is the name for
// a binary file to output data to. File format is described in TESTFILE.H
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTPROV_H_
#define _TESTPROV_H_

class CTestHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlags     - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//      D3D_OK if success
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid,
                          DDRAWI_DIRECTDRAW_GBL *pGlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlags);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\testprov.cpp ===
//----------------------------------------------------------------------------
//
// testprov.cpp
//
// Test HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//#ifdef DEBUG_PIPELINE

#include "testprov.h"
#include "testfile.h"
#include "stdio.h"

// Real rasterizer data
static D3DHALPROVIDER_INTERFACEDATA CurInterfaceData;
static IHalProvider    *pCurHalProvider;    // Real HAL provider

// Test provider data
static CTestHalProvider g_TestHalProvider;
static D3DHALPROVIDER_INTERFACEDATA TestInterfaceData;
static D3DHAL_CALLBACKS  TestCallbacks;
static D3DHAL_CALLBACKS2 TestCallbacks2;
static D3DHAL_CALLBACKS3 TestCallbacks3;
static char szFileName[_MAX_PATH] = "";     // Output file name
static FILE *fout = NULL;                   // Output file
DWORD g_dwTestHalFlags = 0;                   // Could be set from debugger

// Bits for g_dwTestHalFlags
const DWORD __TESTHAL_OUTPUTFILE    = 1;    // If need output to test file
const DWORD __TESTHAL_NORENDER      = 2;    // If no rendering needed

//---------------------------------------------------------------------
// Provides access to DIRECTDRAWSURFACE memory;
// In the constructor the surface is locked.
// In the destructor it is unlocked.
// LPBYTE() or LPVOID() casts will get pointer to the surface bits.
//
class CLockedDDSurface
{
public:
    CLockedDDSurface(LPDIRECTDRAWSURFACE surface);
    ~CLockedDDSurface();
    operator LPVOID() {return descr.lpSurface;}
    operator LPBYTE() {return (LPBYTE)descr.lpSurface;}
protected:
    DDSURFACEDESC descr;
    LPDIRECTDRAWSURFACE pSurface;
};

CLockedDDSurface::CLockedDDSurface(LPDIRECTDRAWSURFACE surface)
{
    pSurface = surface;
    memset (&descr, 0, sizeof(descr));
    descr.dwSize = sizeof(descr);
    surface->Lock(NULL, &descr,  0, NULL);
}

CLockedDDSurface::~CLockedDDSurface()
{
    if (descr.lpSurface)
        pSurface->Unlock(descr.lpSurface);
}
//---------------------------------------------------------------------
void PutHeader(DWORD id, DWORD size)
{
    if (fout)
    {
        fwrite(&id, sizeof(DWORD), 1, fout);
        fwrite(&size, sizeof(DWORD), 1, fout);
    }
}
//---------------------------------------------------------------------
DWORD GetCurrentPosition()
{
    if (fout)
        return ftell(fout);
    else
        return 0;
}
//---------------------------------------------------------------------
void SetCurrentPosition(DWORD offset)
{
    if (fout)
        fseek(fout, offset, SEEK_SET);
}
//---------------------------------------------------------------------
void PutBuffer(LPVOID buffer, DWORD size)
{
    if (fout)
    {
        fwrite(buffer, 1, size, fout);
    }
}
//---------------------------------------------------------------------
// Implementation of test callbacks
//
DWORD __stdcall
TestDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEPRIMITIVE rec;
        PutHeader(TFID_DRAWONEPRIMITIVE,
                  sizeof(rec) + data->dwNumVertices*sizeof(D3DTLVERTEX));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);
    }

    if (CurInterfaceData.pCallbacks2->DrawOnePrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOnePrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEINDEXEDPRIMITIVE rec;
        PutHeader(TFID_DRAWONEINDEXEDPRIMITIVE,
                  sizeof(rec) +
                  data->dwNumVertices*sizeof(D3DTLVERTEX) +
                  data->dwNumIndices*sizeof(WORD));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        rec.indexCount = data->dwNumIndices;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);
        PutBuffer(data->lpwIndices, sizeof(WORD)*data->dwNumIndices);
    }

    if (CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        DWORD endPos = 0;
        LPVOID header = data->lpvData;
        PutHeader(0,0);     // Dummy header. Will be filled later
        DWORD startPos = GetCurrentPosition();
        for (;;)
        {
            DWORD nStates = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumStateChanges;
            DWORD nVertices = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumVertices;
            DWORD size;
        // Primitive header
            PutBuffer(header, sizeof(D3DHAL_DRAWPRIMCOUNTS));
            header = (char*)header + sizeof(D3DHAL_DRAWPRIMCOUNTS);
        // States
            size = nStates * sizeof(WORD);
            PutBuffer(header, size);
            header = (char*)header + size;
            header = (LPVOID)(((LONG_PTR)header + 31) & ~31);  //32 bytes aligned
        // Vertices
            if (!nVertices)
                break;
            size = nVertices * sizeof(D3DTLVERTEX);
            PutBuffer(header, size);

        }
        // Write record header
        endPos = GetCurrentPosition();
        SetCurrentPosition(startPos - sizeof(TF_HEADER));
        PutHeader(TFID_DRAWPRIMITIVES, endPos - startPos);
        SetCurrentPosition(endPos);
    }

    if (CurInterfaceData.pCallbacks2->DrawPrimitives &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawPrimitives(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWPRIMITIVES2 rec;
        rec.dwFlags = 0;
        PutBuffer(&rec, sizeof(rec));
        PutHeader(TFID_DRAWPRIMITIVES, sizeof(rec));
    }

    if (CurInterfaceData.pCallbacks3->DrawPrimitives2 &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks3->DrawPrimitives2(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderState(LPD3DHAL_RENDERSTATEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem should be destroyed before calling to real driver to unlock
        // the surface
        CLockedDDSurface mem(data->lpExeBuf);
        LPD3DSTATE      pState;
        pState = (LPD3DSTATE)(LPBYTE(mem) + data->dwOffset);
        PutHeader(TFID_RENDERSTATE, sizeof(DWORD) + data->dwCount*sizeof(D3DSTATE));
        PutBuffer(&data->dwCount, sizeof(DWORD));
        for (DWORD i = 0; i < data->dwCount; i++)
        {
            PutBuffer(&pState, sizeof(D3DSTATE));
                pState++;
        }
    }

    if (CurInterfaceData.pCallbacks->RenderState)
        return CurInterfaceData.pCallbacks->RenderState(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem and tlmem should be destroyed before calling the real driver
        // to unlock the surface
        CLockedDDSurface mem(data->lpExeBuf);
        CLockedDDSurface tlmem(data->lpTLBuf);
        LPBYTE        lpPrimData;
        LPD3DTLVERTEX lpTLData;
        DWORD         i;
        DWORD         primitiveDataSize;
        DWORD         count = data->diInstruction.wCount;
        TFREC_RENDERPRIMITIVE rec;

        // Find the pointer to the first primitive structure
        lpPrimData = (LPBYTE)mem + data->dwOffset;

        // Find the pointer to the vertex data
        // Find the pointer to the first TL vertex
        lpTLData = (LPD3DTLVERTEX)((LPBYTE)tlmem + data->dwTLOffset);

        rec.status = data->dwStatus;
        rec.vertexType = D3DVT_TLVERTEX;
        // Find out number of vertices, primitive type and
        // size of primitive data
        switch (data->diInstruction.bOpcode)
        {
        case D3DOP_POINT:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DPOINT);
                break;
        case D3DOP_LINE:
            rec.primitiveType = D3DPT_LINELIST;
            rec.vertexCount = count*2;
            primitiveDataSize = count*sizeof(D3DLINE);
                break;
        case D3DOP_SPAN:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DSPAN);
                break;
        case D3DOP_TRIANGLE:
            rec.primitiveType = D3DPT_TRIANGLELIST;
            rec.vertexCount = count*3;
            primitiveDataSize = count*sizeof(D3DTRIANGLE);
                break;
        }

        PutHeader(TFID_RENDERPRIMITIVE,
                  sizeof(D3DINSTRUCTION) +
                  sizeof(rec) + rec.vertexCount*sizeof(D3DTLVERTEX) +
                  primitiveDataSize);
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(&data->diInstruction, sizeof(D3DINSTRUCTION));

        // Parse the structures based on the instruction
        switch (data->diInstruction.bOpcode)
        {
        case D3DOP_POINT:
        {
                LPD3DPOINT lpPoint = (LPD3DPOINT)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpPoint, sizeof(D3DPOINT));
                PutBuffer(&lpTLData[lpPoint->wFirst],
                          lpPoint->wCount*sizeof(D3DTLVERTEX));
                lpPoint++;
                }
                break;
        }
        case D3DOP_LINE:
        {
                LPD3DLINE lpLine = (LPD3DLINE)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpLine, sizeof(D3DLINE));
                PutBuffer(&lpTLData[lpLine->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpLine->v2], sizeof(D3DTLVERTEX));
                lpLine++;
                }
                break;
        }
        case D3DOP_SPAN:
        {
                LPD3DSPAN lpSpan = (LPD3DSPAN)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpSpan, sizeof(D3DSPAN));
                PutBuffer(&lpTLData[lpSpan->wFirst],
                          lpSpan->wCount*sizeof(D3DTLVERTEX));
                lpSpan++;
                }
                break;
        }
        case D3DOP_TRIANGLE:
        {
                LPD3DTRIANGLE lpTri = (LPD3DTRIANGLE)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpTri, sizeof(D3DTRIANGLE));
                PutBuffer(&lpTLData[lpTri->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v2], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v3], sizeof(D3DTLVERTEX));
                lpTri++;
                }
                break;
        }
        }
    }

    if (CurInterfaceData.pCallbacks->RenderPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks->RenderPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        PutHeader(TFID_SCENECAPTURE, sizeof(DWORD));
        PutBuffer(&pData->dwFlag, sizeof(DWORD));
        fflush(fout);
    }

    if (CurInterfaceData.pCallbacks->SceneCapture)
        return CurInterfaceData.pCallbacks->SceneCapture(pData);
    else
        return DDHAL_DRIVER_HANDLED;
}
//----------------------------------------------------------------------------
//
// TestHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP CTestHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::Release(THIS)
{
    if (fout)
    {
        fclose(fout);
        fout = NULL;
    }
    return pCurHalProvider->Release();
}
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to
//      the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlagsInp  - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//
// Notes:
//      Only one instance of the test HAL is handled correctly.
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid,
                          DDRAWI_DIRECTDRAW_GBL *GlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlagsInp)
{
    *ppHalProvider = &g_TestHalProvider;
    pCurHalProvider = pCurrentHalProvider;

    g_dwTestHalFlags |= __TESTHAL_NORENDER;
    if (GetD3DRegValue(REG_SZ, "TestHalFile", &szFileName, _MAX_PATH) &&
        szFileName[0] != 0)
    {
        g_dwTestHalFlags |= __TESTHAL_OUTPUTFILE;
    }
    DWORD dwValue;
    if (GetD3DRegValue(REG_DWORD, "TestHalDoRender", &dwValue, sizeof(DWORD)) &&
        dwValue != 0)
    {
        g_dwTestHalFlags &= ~__TESTHAL_NORENDER;
    }
// Get interface from the current hal provider to call to it
    pCurrentHalProvider->GetInterface(GlobalData, &CurInterfaceData, 4);

    TestInterfaceData = CurInterfaceData;
    TestInterfaceData.pCallbacks  = &TestCallbacks;
    TestInterfaceData.pCallbacks2 = &TestCallbacks2;
    TestInterfaceData.pCallbacks3 = &TestCallbacks3;

// Initialize callbacks we do not care of

    TestCallbacks  = *CurInterfaceData.pCallbacks;
    TestCallbacks2 = *CurInterfaceData.pCallbacks2;
    TestCallbacks3 = *CurInterfaceData.pCallbacks3;

// Initialize callbacks that we want to intersept

    TestCallbacks.RenderState = &TestRenderState;
    TestCallbacks.RenderPrimitive = &TestRenderPrimitive;
    TestCallbacks.SceneCapture = &TestSceneCapture;

    TestCallbacks2.DrawOnePrimitive = &TestDrawOnePrimitive;
    TestCallbacks2.DrawOneIndexedPrimitive = &TestDrawOneIndexedPrimitive;
    TestCallbacks2.DrawPrimitives = &TestDrawPrimitives;

    TestCallbacks3.DrawPrimitives2 = &TestDrawPrimitives2;

    fout = NULL;
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        fout = fopen(szFileName, "wb");
        if (!fout)
            return DDERR_GENERIC;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::GetInterface
//
// Returns  test provider interface and real rasterizer global data.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTestHalProvider::GetInterface(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                               DWORD dwVersion)
{
    *pInterfaceData = TestInterfaceData;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::GetCaps
//
// Returns real rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CTestHalProvider::GetCaps(THIS_
                          LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                          LPD3DDEVICEDESC7 pHwDesc,
                          LPD3DDEVICEDESC7 pHelDesc,
                          DWORD dwVersion)
{
    return pCurHalProvider->GetCaps(pDdGbl, pHwDesc, pHelDesc, dwVersion);
}

//#endif //DEBUG_PIPELINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\texman.hpp ===
#ifndef TEXMAN_INCLUDED
#define TEXMAN_INCLUDED

typedef class TextureCacheManager *LPTextureCacheManager;

class TextureHeap 
{
    enum { InitialSize = 1023 };

    DWORD m_next, m_size;
    LPDIRECT3DTEXTUREI *m_data_p;

    DWORD parent(DWORD k) const { return k / 2; }
    DWORD lchild(DWORD k) const { return k * 2; }
    DWORD rchild(DWORD k) const { return k * 2 + 1; }
    void heapify(DWORD k);

public:

    TextureHeap(DWORD size = InitialSize);
    ~TextureHeap();
    bool Initialize();

    DWORD length() const { return m_next - 1; }
    const LPDIRECT3DTEXTUREI minCost() const { return m_data_p[1]; }

    bool add(LPDIRECT3DTEXTUREI);
    LPDIRECT3DTEXTUREI extractMin();
    LPDIRECT3DTEXTUREI extractMax();
    LPDIRECT3DTEXTUREI extractNotInScene(DWORD dwScene);
    void del(DWORD k);
    void update(DWORD k, BOOL inuse, DWORD priority, DWORD ticks); 
    void resetAllTimeStamps(DWORD ticks);
};

class TextureCacheManager {
    
    TextureHeap *m_heap_p;
    unsigned int tcm_ticks, m_dwScene, m_dwNumHeaps;
    LPDIRECT3DI	lpDirect3DI;
#if COLLECTSTATS
    D3DDEVINFO_TEXTUREMANAGER m_stats;
#endif

    // Free the LRU texture 
    BOOL FreeTextures(DWORD dwStage, DWORD dwCount);
    
public:
    //remove all HW handles and release surface
    void remove(LPDIRECT3DTEXTUREI lpD3DTexI);  
    
    HRESULT allocNode(LPDIRECT3DTEXTUREI lpD3DTexI, LPDIRECT3DDEVICEI lpDevI);
    TextureCacheManager(LPDIRECT3DI lpD3DI);
    ~TextureCacheManager();
    HRESULT Initialize();
    
    void RemoveFromHeap(LPDIRECT3DTEXTUREI lpD3DTexI) 
    { 
        m_heap_p[lpD3DTexI->ddsd.dwTextureStage].del(lpD3DTexI->m_dwHeapIndex); 
    }
    void UpdatePriority(LPDIRECT3DTEXTUREI lpD3DTexI) 
    { 
        if(lpD3DTexI->m_dwHeapIndex)
            m_heap_p[lpD3DTexI->ddsd.dwTextureStage].update(lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_bInUse, lpD3DTexI->m_dwPriority, lpD3DTexI->m_dwTicks); 
    }
#if COLLECTSTATS
    void IncTotSz(DWORD dwSize)
    {
        ++m_stats.dwTotalManaged;
        m_stats.dwTotalBytes += dwSize;
    }
    void DecTotSz(DWORD dwSize)
    {
        --m_stats.dwTotalManaged;
        m_stats.dwTotalBytes -= dwSize;
    }
    void IncNumSetTexInVid()
    {
        ++m_stats.dwNumUsedTexInVid;
    }
    void IncNumTexturesSet()
    {
        ++m_stats.dwNumTexturesUsed;
    }
    void IncBytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
    {
        m_stats.dwApproxBytesDownloaded += BytesDownloaded(lpLcl, lpRect);
    }
    void ResetStatCounters()
    {
        m_stats.bThrashing = 0;
        m_stats.dwApproxBytesDownloaded = 0;
        m_stats.dwNumEvicts = 0;
        m_stats.dwNumVidCreates = 0;
        m_stats.dwNumUsedTexInVid = 0;
        m_stats.dwNumTexturesUsed = 0;
    }
    void GetStats(LPD3DDEVINFO_TEXTUREMANAGER stats)
    {
        memcpy(stats, &m_stats, sizeof(D3DDEVINFO_TEXTUREMANAGER));
    }
#endif
    void EvictTextures(); // Empty the entire cache
    BOOL CheckIfLost(); // check if any of the managed textures are lost
    void TimeStamp(LPDIRECT3DTEXTUREI);
    void SceneStamp() { ++m_dwScene; }
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\texman.cpp ===
#include "pch.cpp"
#pragma hdrstop

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::TextureHeap"

TextureHeap::TextureHeap(DWORD size)
{
    m_next = 1;
    m_size = size + 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::~TextureHeap"

TextureHeap::~TextureHeap()
{
    delete[] m_data_p;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::Initialize"
bool TextureHeap::Initialize()
{
    m_data_p = new LPDIRECT3DTEXTUREI[m_size];
    if(m_data_p == 0)
    {
        D3D_ERR("Failed to allocate texture heap.");
        return false;
    }
    memset(m_data_p, 0, sizeof(LPDIRECT3DTEXTUREI) * m_size);
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::heapify"

void TextureHeap::heapify(DWORD k)
{
    while(true)
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if(l < m_next)
            if(m_data_p[l]->Cost() < m_data_p[k]->Cost())
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if(r < m_next)
            if(m_data_p[r]->Cost() < m_data_p[smallest]->Cost())
                smallest = r;
        if(smallest != k)
        {
            LPDIRECT3DTEXTUREI t = m_data_p[k];
            m_data_p[k] = m_data_p[smallest];
            m_data_p[k]->m_dwHeapIndex = k;
            m_data_p[smallest] = t;
            m_data_p[smallest]->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::add"

bool TextureHeap::add(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    if(m_next == m_size)
    {
        m_size = m_size * 2 - 1;
        LPDIRECT3DTEXTUREI *p = new LPDIRECT3DTEXTUREI[m_size];
        if(p == 0)
        {
            D3D_ERR("Failed to allocate memory to grow heap.");
            m_size = (m_size + 1) / 2; // restore size
            return false;
        }
        memcpy(p + 1, m_data_p + 1, sizeof(LPDIRECT3DTEXTUREI) * (m_next - 1));
        delete[] m_data_p;
        m_data_p = p;
    }
    ULONGLONG Cost = lpD3DTexI->Cost();
    for(DWORD k = m_next; k > 1; k = parent(k))
        if(Cost < m_data_p[parent(k)]->Cost())
        {
            m_data_p[k] = m_data_p[parent(k)];
            m_data_p[k]->m_dwHeapIndex = k;
        }
        else
            break;
    m_data_p[k] = lpD3DTexI;
    m_data_p[k]->m_dwHeapIndex = k;
    ++m_next;
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractMin"

LPDIRECT3DTEXTUREI TextureHeap::extractMin()
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[1];
    --m_next;
    m_data_p[1] = m_data_p[m_next];
    m_data_p[1]->m_dwHeapIndex = 1;
    heapify(1);
    lpD3DTexI->m_dwHeapIndex = 0;
    return lpD3DTexI;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractMax"

LPDIRECT3DTEXTUREI TextureHeap::extractMax()
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper.
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = m_next - 1;
    ULONGLONG maxcost = 0;
    for(unsigned i = max; lchild(i) >= m_next; --i)
    {
        ULONGLONG Cost = m_data_p[i]->Cost();
        if(maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[max];
    if(lpD3DTexI->m_bInUse)
    {
        max = 0;
        maxcost = 0;
        for(i = m_next - 1; i > 0; --i)
        {
            ULONGLONG Cost = m_data_p[i]->Cost();
            if(maxcost < Cost && !m_data_p[i]->m_bInUse)
            {
                maxcost = Cost;
                max = i;
            }
        }
        if(max == 0) // All textures in use
            return NULL;
        lpD3DTexI = m_data_p[max];
    }
    del(max);
    return lpD3DTexI;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractNotInScene"

LPDIRECT3DTEXTUREI TextureHeap::extractNotInScene(DWORD dwScene)
{
    for(unsigned i = 1; i < m_next; ++i)
    {
        if(m_data_p[i]->m_dwScene != dwScene)
        {
            LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[i];
            del(i);
            return lpD3DTexI;
        }
    }
    return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::del"

void TextureHeap::del(DWORD k)
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[k];
    --m_next;
    ULONGLONG Cost = m_data_p[m_next]->Cost();
    if(Cost < lpD3DTexI->Cost())
    {
        while(k > 1)
        {
            if(Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_dwHeapIndex = k;
        heapify(k);
    }
    lpD3DTexI->m_dwHeapIndex = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::update"

void TextureHeap::update(DWORD k, BOOL inuse, DWORD priority, DWORD ticks)
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[k];
    ULONGLONG Cost;
#ifdef _X86_
    _asm
    {
        mov     edx, inuse;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)inuse << 63) + ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if(Cost < lpD3DTexI->Cost())
    {
        while(k > 1)
        {
            if(Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        lpD3DTexI->m_bInUse = inuse;
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        lpD3DTexI->m_dwHeapIndex = k;
        m_data_p[k] = lpD3DTexI;
    }
    else
    {
        lpD3DTexI->m_bInUse = inuse;
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        heapify(k);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::resetAllTimeStamps"

void TextureHeap::resetAllTimeStamps(DWORD ticks)
{
    for(unsigned i = 1; i < m_next; ++i)
    {
        update(i, m_data_p[i]->m_bInUse, m_data_p[i]->m_dwPriority, ticks);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::TextureCacheManager"

TextureCacheManager::TextureCacheManager(LPDIRECT3DI lpD3DI)
{
    tcm_ticks = 0;
    m_dwScene = 0;
    m_dwNumHeaps = 0;
    lpDirect3DI=lpD3DI;
#if COLLECTSTATS
    m_stats.dwWorkingSet = 0;
    m_stats.dwWorkingSetBytes = 0;
    m_stats.dwTotalManaged = 0;
    m_stats.dwTotalBytes = 0;
    m_stats.dwLastPri = 0;
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::~TextureCacheManager"

TextureCacheManager::~TextureCacheManager()
{
    EvictTextures();
    delete[] m_heap_p;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::Initialize"

HRESULT TextureCacheManager::Initialize()
{
    DDASSERT(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl);
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData;
    if(lpD3DHALGlobalDriverData != NULL)
        if(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            m_dwNumHeaps = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DExtendedCaps->wMaxSimultaneousTextures;
            DDASSERT(m_dwNumHeaps);
            if(m_dwNumHeaps < 1)
            {
                D3D_ERR("Max simultaneous textures not set. Forced to 1.");
                m_dwNumHeaps = 1;
            }
            D3D_INFO(2, "Number of heaps set to %u.", m_dwNumHeaps);
        }
        else
            m_dwNumHeaps = 1;
    else
        m_dwNumHeaps = 1;
    m_heap_p = new TextureHeap[m_dwNumHeaps];
    if(m_heap_p == 0)
    {
        D3D_ERR("Out of memory allocating texture heap.");
        return E_OUTOFMEMORY;
    }
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if(m_heap_p[i].Initialize() == FALSE)
            return E_OUTOFMEMORY;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::FreeTextures"

BOOL TextureCacheManager::FreeTextures(DWORD dwStage, DWORD dwBytes)
{
    if(m_heap_p[dwStage].length() == 0)
        return false;
    LPDIRECT3DTEXTUREI rc;
    for(unsigned i = 0; m_heap_p[dwStage].length() != 0 && i < dwBytes; i += rc->m_dwVidBytes)
    {
        // Find the LRU texture and remove it.
        rc = m_heap_p[dwStage].minCost();
        if(rc->m_bInUse)
            return false;
        if(rc->m_dwScene == m_dwScene)
        {
            if(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            {
                D3D_WARN(0, "Trying to locate texture not used in current scene...");
                rc = m_heap_p[dwStage].extractNotInScene(m_dwScene);
                if(rc == NULL)
                {
                    D3D_ERR("No such texture found. Cannot evict textures used in current scene.");
                    return false;
                }
                D3D_WARN(0, "Texture found!");
                remove(rc);
#if COLLECTSTATS
                m_stats.dwLastPri = rc->m_dwPriority;
                ++m_stats.dwNumEvicts;
#endif
            }
            else
            {
                D3D_WARN(1, "Texture cache thrashing. Removing MRU texture.");
                rc = m_heap_p[dwStage].extractMax();
                if(rc == NULL)
                {
                    D3D_ERR("All textures in use, cannot evict texture.");
                    return false;
                }
                remove(rc);
#if COLLECTSTATS
                m_stats.bThrashing = TRUE;
                m_stats.dwLastPri = rc->m_dwPriority;
                ++m_stats.dwNumEvicts;
#endif
            }
        }
        else
        {
            rc = m_heap_p[dwStage].extractMin();
            remove(rc);
#if COLLECTSTATS
            m_stats.dwLastPri = rc->m_dwPriority;
            ++m_stats.dwNumEvicts;
#endif
        }
        D3D_INFO(2, "Removed texture with timestamp %u,%u (current = %u).", rc->m_dwPriority, rc->m_dwTicks, tcm_ticks);
    }
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::allocNode"

HRESULT TextureCacheManager::allocNode(LPDIRECT3DTEXTUREI lpD3DTexI, LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ddrval;
    DWORD trycount = 0, bytecount = lpD3DTexI->m_dwBytes;
    // We need to make sure that we don't evict any mapped textures
    for(DWORD dwStage = 0; dwStage < lpDevI->dwMaxTextureBlendStages; ++dwStage)
    {
        if(lpDevI->lpD3DMappedTexI[dwStage])
        {
            lpDevI->lpD3DMappedTexI[dwStage]->m_bInUse = TRUE;
            UpdatePriority(lpDevI->lpD3DMappedTexI[dwStage]);
        }
    }
    // Attempt to allocate a texture.
    do
    {
        ++trycount;
        DDASSERT(lpD3DTexI->lpDDS == NULL);
        ddrval = lpDirect3DI->lpDD7->CreateSurface(&lpD3DTexI->ddsd, &lpD3DTexI->lpDDS, NULL);
        if (DD_OK == ddrval) // No problem, there is enough memory.
        {
            static_cast<DIRECT3DTEXTURED3DM*>(lpD3DTexI)->MarkDirtyPointers();
            lpD3DTexI->m_dwScene = m_dwScene;
            lpD3DTexI->m_dwTicks = tcm_ticks;
            DDASSERT(lpD3DTexI->m_dwHeapIndex == 0);
            if(!m_heap_p[lpD3DTexI->ddsd.dwTextureStage].add(lpD3DTexI))
            {
                ddrval = DDERR_OUTOFMEMORY;
                goto exit2;
            }
#if COLLECTSTATS
            ++m_stats.dwWorkingSet;
            m_stats.dwWorkingSetBytes += lpD3DTexI->m_dwVidBytes;
            ++m_stats.dwNumVidCreates;
#endif
        }
        else if(ddrval == DDERR_OUTOFVIDEOMEMORY) // If out of video memory
        {
            if (!FreeTextures(lpD3DTexI->ddsd.dwTextureStage, bytecount))
            {
                D3D_ERR("all Freed no further video memory available");
                ddrval = DDERR_OUTOFVIDEOMEMORY;        //nothing left
                goto exit1;
            }
            bytecount <<= 1;
        }
        else
        {
            D3D_ERR("Unexpected error got in allocNode %08x", ddrval);
            goto exit1;
        }
    }
    while(ddrval == DDERR_OUTOFVIDEOMEMORY);
    if(trycount > 1)
    {
        D3DTextureUpdate(static_cast<LPUNKNOWN>(&(lpDirect3DI->mD3DUnk)));
        D3D_WARN(1, "Allocated texture after %u tries.", trycount);
    }
    if (lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1))
    {
        LPDIRECTDRAWPALETTE lpDDPal;
        if (DD_OK != (ddrval = lpD3DTexI->lpDDSSys->GetPalette(&lpDDPal)))
        {
            D3D_ERR("failed to check for palette on texture");
            goto exit3;
        }
        if (DD_OK != (ddrval = lpD3DTexI->lpDDS->SetPalette(lpDDPal)))
        {
            lpDDPal->Release();
            D3D_ERR("SetPalette returned error");
            goto exit3;
        }
        lpDDPal->Release();
    }
    { // scope for CLockD3DST
        // Mark everything dirty before copying sysmem to vidmem
        // else CopySurface will not copy anything
        lpD3DTexI->bDirty = TRUE;
        CLockD3DST lockObject(lpDevI, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
        // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
        // that this is a sysmem -> vidmem transfer.
        if (DD_OK != (ddrval = lpDevI->CopySurface(lpD3DTexI->lpDDS, NULL, lpD3DTexI->lpDDSSys, NULL, 0xFFFFFFFF)))
        {
            D3D_ERR("CopySurface returned error");
            goto exit3;
        }
        lpD3DTexI->bDirty = FALSE;
    }
    lpD3DTexI->DDS1Tex.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(lpD3DTexI->lpDDS))->lpLcl;
    lpD3DTexI->m_hTex = ((LPDDRAWI_DDRAWSURFACE_INT)lpD3DTexI->lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    ddrval = D3D_OK;
    goto exit1;
exit3:
    m_heap_p[lpD3DTexI->ddsd.dwTextureStage].del(lpD3DTexI->m_dwHeapIndex);
exit2:
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS = NULL;
exit1:
    for(dwStage = 0; dwStage < lpDevI->dwMaxTextureBlendStages; ++dwStage)
    {
        if(lpDevI->lpD3DMappedTexI[dwStage])
        {
            lpDevI->lpD3DMappedTexI[dwStage]->m_bInUse = FALSE;
            UpdatePriority(lpDevI->lpD3DMappedTexI[dwStage]);
        }
    }
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::remove"

//remove all HW handles and release surface
void TextureCacheManager::remove(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&lpD3DTexI->blocks);
    while(tBlock)
    {
        CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"removing lpD3DTexI=%08lx lpDDS=%08lx",lpD3DTexI,lpD3DTexI->lpDDS);
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS = NULL;
    lpD3DTexI->m_hTex = 0;
#if COLLECTSTATS
    --m_stats.dwWorkingSet;
    m_stats.dwWorkingSetBytes -= lpD3DTexI->m_dwVidBytes;
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::EvictTextures"

void TextureCacheManager::EvictTextures()
{
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
        while(m_heap_p[i].length())
        {
            LPDIRECT3DTEXTUREI lpD3DTexI = m_heap_p[i].extractMin();
            remove(lpD3DTexI);
        }
    D3DTextureUpdate(static_cast<LPUNKNOWN>(&(lpDirect3DI->mD3DUnk)));
    tcm_ticks = 0;
    m_dwScene = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::CheckIfLost"

BOOL TextureCacheManager::CheckIfLost()
{
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if(m_heap_p[i].length())
        {
            if(((LPDDRAWI_DDRAWSURFACE_INT)(m_heap_p[i].minCost()->lpDDS))->lpLcl->dwFlags & DDRAWISURF_INVALID)
                return TRUE;
            else
                return FALSE;
        }
    }
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::TimeStamp"

void TextureCacheManager::TimeStamp(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    lpD3DTexI->m_dwScene = m_dwScene;
    m_heap_p[lpD3DTexI->ddsd.dwTextureStage].update(lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_bInUse, lpD3DTexI->m_dwPriority, tcm_ticks);
    unsigned tickp2 = tcm_ticks + 2;
    if(tickp2 > tcm_ticks)
    {
        tcm_ticks = tickp2;
    }
    else // counter has overflowed. Let's reset all timestamps to zero
    {
        D3D_INFO(2, "Timestamp counter overflowed. Reseting timestamps for all textures.");
        tcm_ticks = 0;
        for(DWORD i = 0; i < m_dwNumHeaps; ++i)
            m_heap_p[i].resetAllTimeStamps(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\commdrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       commdrv.h
 *  Content:    Common driver structures
 *
 ***************************************************************************/

#ifndef _COMMDRV_H_
#define _COMMDRV_H_

#include "haldrv.hpp"

extern int      GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI );
extern LPD3DTLVERTEX    GenGetExtraVerticesPointer( LPDIRECT3DDEVICEI lpDevI );
extern HRESULT DrawPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimCB(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimCB(LPDIRECT3DDEVICEI);
//---------------------------------------------------------------------
// This class builds a DDRAWSURFACE around memory bits
//
class CDDSurfaceFromMem
{
public:
    CDDSurfaceFromMem(LPVOID lpvMemory)
        {
            gblTL.fpVidMem = (ULONG_PTR)lpvMemory;
            lclTL.lpGbl = &gblTL;
            exeTL.lpLcl = &lclTL;
        }
    ~CDDSurfaceFromMem() {};
    LPDIRECTDRAWSURFACE GetSurface() {return (LPDIRECTDRAWSURFACE) &exeTL;}
    void SetBits(LPVOID lpvMemory)   {gblTL.fpVidMem = (ULONG_PTR)lpvMemory;}
protected:
    DDRAWI_DDRAWSURFACE_INT exeTL;
    DDRAWI_DDRAWSURFACE_LCL lclTL;
    DDRAWI_DDRAWSURFACE_GBL gblTL;
};
#endif /* _COMMDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\dditypes.hpp ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.hpp"


#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\tldevice.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tldevice.cpp
 *
 *  Content:    Support code for device with transformation and lighting
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include "tlhal.h"
#include "drawprim.hpp"
#include "pvvid.h"
//=====================================================================
//
//      CDirect3DDevice7 interface
//
//=====================================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::Init"

HRESULT CDirect3DDevice7::Init(
     REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
     IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
#if 0
    // Stateblocks are always emulated on DX7
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
    if(value == 0)
    {
        // All DX7 devices should support state sets
        this->dwFEFlags |= D3DFE_STATESETS;
    }
#endif

    HRESULT ret = CDirect3DDeviceIDP2::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    // Do device specific initialization here
    return D3D_OK;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::WriteStateSetToDevice"

void CDirect3DDevice7::WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt)
{
    DWORD  dwDeviceHandle;
    LPVOID pBuffer;
    DWORD  dwBufferSize;
    
    m_pStateSets->GetDeviceBufferInfo(&dwDeviceHandle, &pBuffer, &dwBufferSize);

    // If device buffer is empty we do not create the set state macro in the device
    if (dwBufferSize == 0)
        return;

    DWORD dwByteCount = dwBufferSize + (sizeof(D3DHAL_DP2STATESET) + sizeof(D3DHAL_DP2COMMAND)) * 2;

    // Check to see if there is space to add a new command for space
    if (dwByteCount + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        HRESULT ret = FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            throw ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            throw ret;
        }
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    LPD3DHAL_DP2STATESET pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETBEGIN;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Copy the entire state macro to the DP2 buffer
    memcpy(pData + 1, pBuffer, dwBufferSize);

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pData + 1) + dwBufferSize);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETEND;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    dwDP2CommandLength += dwByteCount;

    HRESULT ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in WriteStateSetToDevice");
        throw ret;
    }
    else
    {
        if(this->dwFEFlags & D3DFE_LOSTSURFACES)
        {
            D3D_ERR("State blocks lost in WriteStateSetToDevice");
            throw DDERR_SURFACELOST;
        }
    }
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::TexBltI"

HRESULT CDirect3DDevice7::TexBltI(LPDDRAWI_DDRAWSURFACE_LCL lpDst,
                                  LPDDRAWI_DDRAWSURFACE_LCL lpSrc,
                                  LPPOINT p, RECTL *r, DWORD dwFlags)
{
    HRESULT ret = D3D_OK;
#ifdef  WINNT
    // WINNT allows delay create of Kernel object
    // if such a create fails, we can't pass handle to driver
    if(dwFEFlags & D3DFE_REALHAL)
    {
        if (!lpSrc->hDDSurface && !CompleteCreateSysmemSurface(lpSrc))
        {
            return DDERR_GENERIC;
        }
        if (lpDst && !lpDst->hDDSurface && !CompleteCreateSysmemSurface(lpDst))
        {
            return DDERR_GENERIC;
        }
    }
#endif
    // If the driver supports the GetSysmemBltStatus call, then the driver can
    // do the Blt asynchronously. In this case, set the HARDWAREOP_STARTED
    // flags so that Locks and Blts to the surface(s) in concern spin until
    // the async Blt is finished.
    if((lpSrc->lpSurfMore->lpDD_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus != NULL)
        && (lpSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        lpSrc->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
    }
    if (bDP2CurrCmdOP == D3DDP2OP_TEXBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXBLT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpTexBlt->dwDDDestSurface   = lpDst == NULL ? 0 : lpDst->lpSurfMore->dwSurfaceHandle;
            lpTexBlt->dwDDSrcSurface    = lpSrc->lpSurfMore->dwSurfaceHandle;
            lpTexBlt->pDest             = *p;
            lpTexBlt->rSrc              = *r;
            lpTexBlt->dwFlags           = dwFlags;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXBLT) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXBLT;
    bDP2CurrCmdOP = D3DDP2OP_TEXBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)(lpDP2CurrCommand + 1);
    lpTexBlt->dwDDDestSurface   = lpDst == NULL ? 0 : lpDst->lpSurfMore->dwSurfaceHandle;
    lpTexBlt->dwDDSrcSurface    = lpSrc->lpSurfMore->dwSurfaceHandle;
    lpTexBlt->pDest             = *p;
    lpTexBlt->rSrc              = *r;
    lpTexBlt->dwFlags           = dwFlags;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXBLT);
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetPriorityI"

HRESULT CDirect3DDevice7::SetPriorityI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwPriority)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPRIORITY)
    { // Last instruction is a set priority, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETPRIORITY) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPriority->dwDDSurface    = lpDst->lpSurfMore->dwSurfaceHandle;
            lpSetPriority->dwPriority     = dwPriority;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETPRIORITY);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPRIORITY) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetPriorityI");
            return ret;
        }
    }
    // Add new setpriority instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPRIORITY;
    bDP2CurrCmdOP = D3DDP2OP_SETPRIORITY;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)(lpDP2CurrCommand + 1);
    lpSetPriority->dwDDSurface = lpDst->lpSurfMore->dwSurfaceHandle;
    lpSetPriority->dwPriority  = dwPriority;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPRIORITY);
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetTexLODI"

HRESULT CDirect3DDevice7::SetTexLODI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwLOD)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_SETTEXLOD)
    { // Last instruction is a set LOD, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETTEXLOD) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetTexLOD->dwDDSurface      = lpDst->lpSurfMore->dwSurfaceHandle;
            lpSetTexLOD->dwLOD            = dwLOD;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETTEXLOD);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETTEXLOD) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetTexLODI");
            return ret;
        }
    }
    // Add new set LOD instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETTEXLOD;
    bDP2CurrCmdOP = D3DDP2OP_SETTEXLOD;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)(lpDP2CurrCommand + 1);
    lpSetTexLOD->dwDDSurface = lpDst->lpSurfMore->dwSurfaceHandle;
    lpSetTexLOD->dwLOD       = dwLOD;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTEXLOD);
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::UpdatePalette"
//---------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
HRESULT CDirect3DDevice7::UpdatePalette(
        DWORD dwPaletteHandle,
        DWORD dwStartIndex,
        DWORD dwNumberOfIndices,
        LPPALETTEENTRY pFirstIndex)
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetPalette"
//---------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
HRESULT CDirect3DDevice7::SetPalette(DWORD dwPaletteHandle,
                                     DWORD dwPaletteFlags,
                                     DWORD dwSurfaceHandle )
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }

    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=dwSurfaceHandle;
    dwDP2CommandLength += dwSizeChange;
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::UpdateTextures"

HRESULT CDirect3DDevice7::UpdateTextures()
{
    HRESULT result = D3D_OK;
    DWORD dwSavedFlags = this->dwFlags;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
            if (lpTexI->InVidmem())
            {
                if (lpTexI->bDirty)
                {

                    CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
                    // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                    // that this is a sysmem -> vidmem transfer.
                    result = CopySurface(lpTexI->lpDDS,NULL,lpTexI->lpDDSSys,NULL,0xFFFFFFFF);
                    if (DD_OK != result)
                    {
                        D3D_ERR("Error copying surface while updating textures");
                        goto l_exit;
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            else
            {
                if(lpTexI->D3DManaged())
                {
                    // Not in vidmem, so we need to call GetTextureDDIHandle
                    m_dwStageDirty |= (1 << dwStage);
                }
            }
            if (m_dwStageDirty & (1 << dwStage))
            {
                result = GetTextureDDIHandle(lpTexI, &dwDDIHandle);
                if (result != D3D_OK)
                {
                    D3D_ERR("Failed to get texture handle");
                    goto l_exit;
                }
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl);
                m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
            }
            else
            {
                continue; // Ok, then nothing needs to be done further
            }
        }
        else if (m_dwStageDirty & (1 << dwStage))
        {
            dwDDIHandle = 0;    //tell driver to disable this texture
            m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
        }
        else
        {
            continue;
        }
        result = SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
        if(result != D3D_OK)
        {
            D3D_ERR("Failed to batch set texture instruction");
            goto l_exit;
        }
        // Update runtime copy of state.
        this->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
    }
l_exit:
    this->dwFlags = dwSavedFlags;
    return result;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::GetTextureDDIHandle"

HRESULT CDirect3DDevice7::GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI, D3DTEXTUREHANDLE *phTex)
{
    if(lpTexI->D3DManaged())
    {
        if(!lpTexI->InVidmem())
        {
            HRESULT ret = lpDirect3DI->lpTextureManager->allocNode(lpTexI, this);
            if (D3D_OK != ret)
            {
                D3D_ERR("Failed to create video memory surface");
                return ret;
            }
        }
        lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
    }
    *phTex = lpTexI->m_hTex;
    return D3D_OK;
}

void CDirect3DDevice7::SetRenderTargetI(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;

    // Flush before switching RenderTarget..
    HRESULT ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        throw ret;
    }

}
void CDirect3DDevice7::SetRenderTargetINoFlush(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::CanDoTexBlt"

bool CDirect3DDevice7::CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                                   LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl)
{
    if(dwFEFlags & D3DFE_REALHAL)
    {
        DWORD &srccaps     = lpDDSSrcSubFace_lcl->ddsCaps.dwCaps;
        DWORD &dstcaps     = lpDDSDstSubFace_lcl->ddsCaps.dwCaps;
        DDCORECAPS &ddcaps = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->ddCaps;
        if(srccaps & DDSCAPS_VIDEOPORT)
        {
            return false;
        }
        DDPIXELFORMAT &srcpf = PixelFormat(lpDDSSrcSubFace_lcl);
        DDPIXELFORMAT &dstpf = PixelFormat(lpDDSDstSubFace_lcl);
        if(!MatchDDPIXELFORMAT(&srcpf, &dstpf))
        {
            return false;
        }
        else if((srcpf.dwFlags & DDPF_FOURCC) && srcpf.dwFourCC == dstpf.dwFourCC &&
            !(ddcaps.dwCaps2 & DDCAPS2_COPYFOURCC))
        {
            return false;
        }
        if(ddcaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
        {
            if(srccaps & DDSCAPS_SYSTEMMEMORY)
            {
                if((dstcaps & DDSCAPS_NONLOCALVIDMEM) && (this->d3dDevDesc.dwDevCaps & D3DDEVCAPS_CANBLTSYSTONONLOCAL))
                {
                    return true;
                }
                else if((dstcaps & DDSCAPS_LOCALVIDMEM) && (ddcaps.dwSVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_NONLOCALVIDMEM)
            {
                LPDDNONLOCALVIDMEMCAPS &lpnlvcaps = ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD7)->lpLcl->lpGbl->lpddNLVCaps;
                DDASSERT(lpnlvcaps);
                if((dstcaps & DDSCAPS_LOCALVIDMEM) && (lpnlvcaps->dwNLVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_LOCALVIDMEM)
            {
                if((dstcaps & DDSCAPS_LOCALVIDMEM) && (ddcaps.dwCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else
        {
            if(srccaps & DDSCAPS_SYSTEMMEMORY)
            {
                if((dstcaps & DDSCAPS_VIDEOMEMORY) && (ddcaps.dwSVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_VIDEOMEMORY)
            {
                if((dstcaps & DDSCAPS_VIDEOMEMORY) && (ddcaps.dwCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
    }
    return false;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::ClearI"

void CDirect3DDevice7::ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CDirect3DDevice7::ClearI");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::GetInfo"

HRESULT D3DAPI CDirect3DDevice7::GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR( "Invalid structure pointer or size" );
        return DDERR_INVALIDOBJECT;
    }
    memset(pDevInfoStruct, 0, dwSize);
#if DBG
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_WARN( 2, "GetInfo called within a scene" );
    }
    if( this->pfnGetDriverState == NULL )
    {
        D3D_ERR( "GetDriverState not implemented by the driver" );
        DDASSERT( this->pfnGetDriverState );
    }
#endif
    try
    {
        switch(dwDevInfoID)
        {
#if COLLECTSTATS
        case D3DDEVINFOID_TEXTUREMANAGER:
            if(!(((LPDDRAWI_DIRECTDRAW_INT)(this->lpDirect3DI->lpDD7))->lpLcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE))
            {
                lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
                return D3D_OK;
            }
            break;
#else
        case D3DDEVINFOID_TEXTUREMANAGER:
            D3D_WARN( 0, "Stats not collected in this build" );
            return S_FALSE;
#endif
        default:
            if(GetInfoInternal(dwDevInfoID, pDevInfoStruct, dwSize))
                return D3D_OK;
        }

        HRESULT hr = FlushStates();
        if(hr != D3D_OK)
        {
            D3D_ERR("Error flushing device");
            return hr;
        }
    }
    catch(HRESULT ret)
    {
        memset(pDevInfoStruct, 0, dwSize);
        return ret;
    }

    HRESULT hr;
    DDHAL_GETDRIVERSTATEDATA dsd;
    dsd.dwFlags = dwDevInfoID;
    dsd.dwhContext = this->dwhContext;
    dsd.lpdwStates = (LPDWORD)pDevInfoStruct;
    dsd.dwLength = dwSize;
    LOCK_HAL(hr, this);
    hr = this->pfnGetDriverState(&dsd);
    UNLOCK_HAL(this);
    if (hr != DDHAL_DRIVER_HANDLED)
    {
        D3D_WARN( 1, "Device information query unsupported" );
        memset(pDevInfoStruct, 0, dwSize);
        return S_FALSE;
    }
    else if (dsd.ddRVal != DD_OK)
    {
        D3D_INFO(1,"Driver failed GetInfo");
        memset(pDevInfoStruct, 0, dwSize);
        return E_FAIL;
    }

    return D3D_OK;    
}
//=====================================================================
//
//      CDirect3DDeviceTL interface
//
//=====================================================================
CDirect3DDeviceTL::CDirect3DDeviceTL()
{
    deviceType = D3DDEVTYPE_DX7TLHAL;
    m_rsMax = D3D_MAXRENDERSTATES;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::Init"

HRESULT CDirect3DDeviceTL::Init(
     REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
     IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    this->dwFEFlags |= D3DFE_TLHAL;

#if 0
    // Stateblocks are always emulated on DX7
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
    if(value == 0)
    {
        // All DX7 devices should support state sets
        this->dwFEFlags |= D3DFE_STATESETS;
    }
#endif

    HRESULT ret = CDirect3DDevice7::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    // Do device specific initialization here
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::MaterialChanged"

void CDirect3DDeviceTL::MaterialChanged()
{
    // Update front-end state (for ProcessVertices calls)
    DIRECT3DDEVICEI::MaterialChanged();

    // Driver should not be called because it will execute the macro)
    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;

    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = this->lighting.material;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetClipPlaneI"

void CDirect3DDeviceTL::SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    // Update front-end state (for DrawPrimitiveStrided calls)
    DIRECT3DDEVICEI::SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
    // Driver should not be called because it will execute the macro)
    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;
#if DBG
    if (dwPlaneIndex >= this->transform.dwMaxUserClipPlanes)
    {
        D3D_WARN(1, "Device does not support that many clipping planes");
        return;
    }
#endif
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::LightChanged"

void CDirect3DDeviceTL::LightChanged(DWORD dwLightIndex)
{
    // Update front-end state (for ProcessVertices calls)
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];
    BOOL bValid = pLight->Valid(); // Valid bit will be set in LightChanged
    DIRECT3DDEVICEI::LightChanged(dwLightIndex);

    // If this is first time we set the light data, we call HALL to create
    // light. HAL could grow the internal light list at this time
    if (!bValid)
    {
        LPD3DHAL_DP2CREATELIGHT pData;
        pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
        pData->dwIndex = dwLightIndex;
        pLight->m_LightI.flags |= D3DLIGHTI_VALID;
    }

    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;

    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                                      sizeof(*pData)+sizeof(D3DLIGHT7));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    *(D3DLIGHT7 *)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT)) =
        pLight->m_Light;
}
//---------------------------------------------------------------------
// Nothing to do here, because render state is used to enable/disable
// lights
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::LightEnableI"

void CDirect3DDeviceTL::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    DIRECT3DDEVICEI::LightEnableI(dwLightIndex, bEnable);
    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        LPD3DHAL_DP2SETLIGHT pData;
        pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
        pData->dwIndex = dwLightIndex;
        if (bEnable)
            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
        else
            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetTransformI"

void CDirect3DDeviceTL::SetTransformI(D3DTRANSFORMSTATETYPE type,
                                               LPD3DMATRIX pMat)
{
    DDASSERT(pMat != NULL);
    DIRECT3DDEVICEI::SetTransformI(type, pMat);
    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        LPD3DHAL_DP2SETTRANSFORM pData;
        pData = (LPD3DHAL_DP2SETTRANSFORM)GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
        pData->xfrmType = type;
        pData->matrix = *pMat;
    }
}
//---------------------------------------------------------------------
// ProcessPrimitive processes indexed and non-indexed primitives
// as defined by "op"
// It is assumed that only untransformed vertices are passed to this function
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::ProcessPrimitive"

HRESULT CDirect3DDeviceTL::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret;

#if DBG
    // Do some validation
    if (!FVF_TRANSFORMED(this->dwVIDIn))
    {
        if (this->rstates[D3DRENDERSTATE_VERTEXBLEND])
        {
            if(this->rstates[D3DRENDERSTATE_VERTEXBLEND] + 1 > this->d3dDevDesc.wMaxVertexBlendMatrices)
            {
                D3D_WARN(1, "Device does not support that many blend weights");
            }
        }
    }
#endif

    this->dwVIDOut = this->dwVIDIn;
    if (this->dwDeviceFlags & D3DDEV_STRIDE)
    {
        DWORD dwTexCoordSizeDummy[8];
        DWORD dwFVF = this->dwVIDIn;
        DWORD dwPositionSize = GetPositionSizeFVF(dwFVF);
        DWORD dwVertexSize = GetVertexSizeFVF(dwFVF) +
                            ComputeTextureCoordSize(dwFVF, dwTexCoordSizeDummy);
        this->dwOutputSize = dwVertexSize;
        this->dwVertexPoolSize = this->dwNumVertices * dwVertexSize;
        if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
        {
            D3D_ERR( "Could not grow TL vertex buffer" );
            return DDERR_OUTOFMEMORY;
        }
        ret = this->StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        D3DVALUE *p = (D3DVALUE*)this->TLVbuf_GetAddress();
        for (DWORD n = this->dwNumVertices; n; n--)
        {
            // XYZ and wheights
            memcpy(p, this->position.lpvData, dwPositionSize);
            p = (D3DVALUE*)((BYTE*)p + dwPositionSize);
            this->position.lpvData = (char*)this->position.lpvData + this->position.dwStride;
            if (dwFVF & D3DFVF_NORMAL)
            {
                *p++ = ((D3DVALUE*)this->normal.lpvData)[0];
                *p++ = ((D3DVALUE*)this->normal.lpvData)[1];
                *p++ = ((D3DVALUE*)this->normal.lpvData)[2];
                this->normal.lpvData = (char*)this->normal.lpvData + this->normal.dwStride;
            }
            if (dwFVF & D3DFVF_RESERVED1)
            {
                *p++ = 0;
            }
            if (dwFVF & D3DFVF_DIFFUSE)
            {
                *p++ = *(D3DVALUE*)this->diffuse.lpvData;
                this->diffuse.lpvData = (char*)this->diffuse.lpvData + this->diffuse.dwStride;
            }
            if (dwFVF & D3DFVF_SPECULAR)
            {
                *p++ = *(D3DVALUE*)this->specular.lpvData;
                this->specular.lpvData = (char*)this->specular.lpvData + this->specular.dwStride;
            }
            for (DWORD i=0; i < this->nTexCoord; i++)
            {
                DWORD dwSize = dwTexCoordSizeDummy[i];
                memcpy(p, this->textures[i].lpvData, dwSize);
                this->textures[i].lpvData = (char*)this->textures[i].lpvData + this->textures[i].dwStride;
                p = (D3DVALUE*)((char*)p + dwSize);
            }
        }
    }
    else
    {
        // Pass vertices directly from the user memory
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        ret = this->StartPrimUserMem(this->position.lpvData);
        if (ret != D3D_OK)
            return ret;
    }

    if (op == __PROCPRIMOP_INDEXEDPRIM)
    {
        ret = this->DrawIndexPrim();
    }
    else
    { // Non indexed primitive
        ret = this->DrawPrim();
    }
    if (ret != D3D_OK)
        return ret;
    return this->EndPrim();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::UpdateDrvViewInfo"

void CDirect3DDeviceTL::UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData)
{
    // Update viewport size
    CDirect3DDeviceIDP2::UpdateDrvViewInfo(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->dvMinZ;
    pData->dvMaxZ = lpVwpData->dvMaxZ;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetupFVFData"

HRESULT CDirect3DDeviceTL::SetupFVFData(DWORD *pdwInpVertexSize)
{
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);
    DWORD dwSize = GetVertexSizeFVF(this->dwVIDIn);
    // Add size of texture coordinates
    DWORD dwTextureFormats = this->dwVIDIn >> 16;
    for (DWORD i=this->nTexCoord; i; i--)
    {
        dwSize += g_TextureSize[dwTextureFormats & 0x3];
        dwTextureFormats >>= 2;
    }
    if (pdwInpVertexSize)
        *pdwInpVertexSize = dwSize;

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\vertbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:    vertbuf.cpp
 *  Content:    Direct3DVertexBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date    By    Reason
 *   ====    ==    ======
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "d3dfei.h"
#include "clipfunc.h"
#include "pvvid.h"

// The bit is set when a vertex buffer was the destination in a ProcessVerticesCall
// with clipping enabled. We cannot pass such a buffer to TL HAL, because some vertices
// could be in the screen space and some in the clipping space. There is no DDI to pass
// clip codes together with a vertex buffer
const DWORD D3DPV_CLIPCODESGENERATED = D3DPV_RESERVED2;

const DWORD D3DVOP_RENDER = 1 << 31;
const DWORD D3DVBCAPS_VALID = D3DVBCAPS_SYSTEMMEMORY |
                              D3DVBCAPS_WRITEONLY |
                              D3DVBCAPS_OPTIMIZED |
                              D3DVBCAPS_DONOTCLIP;

void hookVertexBufferToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVERTEXBUFFERI lpVBufI)
{

    LIST_INSERT_ROOT(&lpDirect3DI->vbufs, lpVBufI, list);
    lpVBufI->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numVBufs++;
}

/*
 * Direct3DVertexBuffer::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::QueryInterface"

HRESULT D3DAPI CDirect3DVertexBuffer::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(ppvObj)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    *ppvObj = NULL;
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DVertexBuffer7))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DVERTEXBUFFER7>(this));
        return(D3D_OK);
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* CDirect3DVertexBuffer::QueryInterface */

/*
 * Direct3DVertexBuffer::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::AddRef"

ULONG D3DAPI CDirect3DVertexBuffer::AddRef()
{
    DWORD        rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return 0;
    }
#endif
    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);

} /* Direct3DVertexBuffer::AddRef */

/*
  * Direct3DVertexBuffer::Release
  *
*/
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Release"

ULONG D3DAPI CDirect3DVertexBuffer::Release()
{
    DWORD            lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return 0;
    }
#endif
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }

    return lastrefcnt;

} /* D3DTex3_Release */
//---------------------------------------------------------------------
// Internal version.
// No D3D lock, no checks
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBufferI"

HRESULT DIRECT3DI::CreateVertexBufferI(LPD3DVERTEXBUFFERDESC lpDesc,
                                       LPDIRECT3DVERTEXBUFFER7 *lplpVBuf,
                                       DWORD dwFlags)
{
    CDirect3DVertexBuffer*     lpVBufI;
    HRESULT ret = D3D_OK;

    *lplpVBuf = NULL;

    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(new CDirect3DVertexBuffer(this));
    if (!lpVBufI) {
        D3D_ERR("failed to allocate space for vertex buffer");
        return (DDERR_OUTOFMEMORY);
    }

    if ((ret=lpVBufI->Init(this, lpDesc, dwFlags))!=D3D_OK)
    {
        D3D_ERR("Failed to initialize the vertex buffer object");
        delete lpVBufI;
        return ret;
    }
    *lplpVBuf = (LPDIRECT3DVERTEXBUFFER7)lpVBufI;

    return(D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBuffer"

HRESULT D3DAPI DIRECT3DI::CreateVertexBuffer(
    LPD3DVERTEXBUFFERDESC lpDesc,
    LPDIRECT3DVERTEXBUFFER7* lplpVBuf,
    DWORD dwFlags)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    /*
     * validate parms
     */
    if (!VALID_DIRECT3D_PTR(this))
    {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpVBuf))
    {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if ((lpDesc->dwCaps & D3DVBCAPS_VALID) != lpDesc->dwCaps)
    {
        D3D_ERR("Invalid caps");
        return DDERR_INVALIDCAPS;
    }
    if (dwFlags != 0)
    {
        D3D_ERR("Invalid dwFlags");
        return DDERR_INVALIDPARAMS;
    }
#endif
    return CreateVertexBufferI(lpDesc, lplpVBuf, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::constructor"

CDirect3DVertexBuffer::CDirect3DVertexBuffer(LPDIRECT3DI lpD3DI)
{
    refCnt = 1;
    /*
     * Put this vertex buffer in the list of those owned by the
     * Direct3D object
     */
    hookVertexBufferToD3D(lpD3DI, this);
    srcVOP = dstVOP = dwPVFlags = position.dwStride = dwLockCnt = 0;
    position.lpvData = NULL;
    clipCodes = NULL;
    lpDDSVB = NULL;
    dwCaps = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::destructor"

CDirect3DVertexBuffer::~CDirect3DVertexBuffer()
{
    /*
    * Remove ourselves from the Direct3D object
    */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numVBufs--;
    delete [] clipCodes;
    if (lpDDSVB)
    {
        lpDDSVB->Release();
        lpDDS1VB->Release();
    }
}
//---------------------------------------------------------------------
//
// Create the vertex memory buffer through DirectDraw
//
// Notes:
//    this->dwMemType should be set before calling this function
//    this->dwCaps should be set too.
//    this->dwMemType is set to DDSCAPS_VIDEOMEMORY is the VB was driver allocated
//

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::CreateMemoryBuffer"
HRESULT CDirect3DVertexBuffer::CreateMemoryBuffer(
    LPDIRECT3DI lpD3DI,
    LPDIRECTDRAWSURFACE7 *lplpSurface7,
    LPDIRECTDRAWSURFACE  *lplpSurface,
    LPVOID *lplpMemory,
    DWORD dwBufferSize)
{
    HRESULT ret;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS | DDSD_FVF;
    ddsd.dwWidth = dwBufferSize;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
    ddsd.ddsCaps.dwCaps2 = this->dwMemType;
    ddsd.dwFVF = this->fvf; // Let driver know about the FVF

    // The meaning of DDSCAPS_VIDEOMEMORY and DDSCAPS_SYSTEMEMORY are
    // slightly different in case of VBs. the former only means that
    // the buffer is driver allocated and could be in any memory type.
    // The latter means that the driver did not care to allocate VBs
    // hence they are always in DDraw allocated system memory.

    // The reason we try video memory followed by system memory
    // (rather than simply not specifying the memory type) is for
    // drivers which do not care to do any special VB allocations, we
    // do not want DDraw to take the Win16 lock for locking system memory
    // surfaces.

    bool bTLHAL = DDGBL(lpD3DI)->lpD3DGlobalDriverData &&
            (DDGBL(lpD3DI)->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
             D3DDEVCAPS_HWTRANSFORMANDLIGHT);

    if ((this->dwCaps & D3DVBCAPS_SYSTEMMEMORY) || !(bTLHAL || FVF_TRANSFORMED(fvf)))
    {
        // This VB cannot reside in driver friendly memory since either:
        // 1. The app explicitly specified system memory
        // 2. The vertex buffer is untransformed and it is not a T&L hal
        //    thus the driver will never see this VB
        D3D_INFO(8, "Trying to create a sys mem vertex buffer");
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ret = lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not allocate the Vertex buffer.");
            return ret;
        }
    }
    else
    {
        // Try explicit video memory first
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        if ((this->dwCaps & D3DVBCAPS_DONOTCLIP) || bTLHAL)
            ddsd.ddsCaps.dwCaps |= this->dwCaps & DDSCAPS_WRITEONLY;
        D3D_INFO(8, "Trying to create a vid mem vertex buffer");
#ifdef __DISABLE_VIDMEM_VBS__
        if ((lpD3DI->bDisableVidMemVBs == TRUE) ||
            (lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL) != DD_OK))
#else  //__DISABLE_VIDMEM_VBS__
        if (lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL) != DD_OK)
#endif //__DISABLE_VIDMEM_VBS__
        {
            // If that failed, or user requested sys mem, try explicit system
            // memory
            D3D_INFO(6, "Trying to create a sys mem vertex buffer");
            ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_WRITEONLY);
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            ret = lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("Could not allocate the Vertex buffer.");
                return ret;
            }
        }
        else
        {
            this->dwMemType = DDSCAPS_VIDEOMEMORY;
            // Stick in our pointer so that we can be notified about mode changes
            DDSLCL(*lplpSurface7)->lpSurfMore->lpVB = static_cast<LPVOID>(this);
        }
    }
    ret = (*lplpSurface7)->QueryInterface(IID_IDirectDrawSurfaceNew, (LPVOID*)lplpSurface);
    if (ret != DD_OK)
    {
        D3D_ERR("failed to QI for DDS1");
        return ret;
    }
    ret = (*lplpSurface7)->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock vertex buffer.");
        return ret;
    }
    *lplpMemory = ddsd.lpSurface;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::init"

HRESULT CDirect3DVertexBuffer::Init(LPDIRECT3DI lpD3DI, LPD3DVERTEXBUFFERDESC lpDesc, DWORD dwFlags)
{
    HRESULT ret;

    bReallyOptimized = FALSE;
    dwCaps = lpDesc->dwCaps;
    fvf = lpDesc->dwFVF;
    dwNumVertices = lpDesc->dwNumVertices;
#ifdef VTABLE_HACK
    // Copy with vtable
    lpVtbl = *((LPVOID**)this);
    memcpy(newVtbl, lpVtbl, sizeof(PVOID)*D3DVB_NUM_VIRTUAL_FUNCTIONS);
    // Point to the new one
    *((LPVOID*)this) = (LPVOID)newVtbl;
#endif // VTABLE_HACK
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("Direct3D for DirectX 6.0 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    if (lpDesc->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("D3DVBCAPS_OPTIMIZED flag should not be set");
        return DDERR_INVALIDPARAMS;
    }

    this->nTexCoord = FVF_TEXCOORD_NUMBER(fvf);
    this->dwTexCoordSizeTotal = ComputeTextureCoordSize(this->fvf, this->dwTexCoordSize);
    position.dwStride = GetVertexSizeFVF(this->fvf) + this->dwTexCoordSizeTotal;
    if (position.dwStride == 0)
    {
        D3D_ERR("Vertex size is zero according to the FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (dwFlags & D3DVBFLAGS_CREATEMULTIBUFFER)
        dwMemType = 0;
    else
        dwMemType = DDSCAPS2_VERTEXBUFFER;
#ifdef DBG
    // Allocate space for one more vertex and fill with deadbeef. Used to check for
    // overwrites during unlock
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData,
                             position.dwStride * (dwNumVertices + 1));
    if (ret != D3D_OK)
        return ret;
    LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
    for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
        *pPad++ = 0xdeadbeef;
#else
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData,
                             position.dwStride * dwNumVertices);
    if (ret != D3D_OK)
        return ret;
#endif

    /* Classify the operations that can be done using this VB */
    if ((fvf & D3DFVF_POSITION_MASK))
    {
        if ((fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
        {
            D3D_INFO(4, "D3DFVF_XYZ set. Can be source VB for Transform");
            srcVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS | D3DVOP_CLIP;
        }
        else
        {
            D3D_INFO(4, "D3DFVF_XYZRHW set. Can be dest VB for Transform");
            dstVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS;
            srcVOP = D3DVOP_EXTENTS;
            if ((dwCaps & D3DVBCAPS_DONOTCLIP) == 0)
            {
                clipCodes = new D3DFE_CLIPCODE[dwNumVertices];
                if (clipCodes == NULL)
                {
                    D3D_ERR("Could not allocate space for clip flags");
                    return DDERR_OUTOFMEMORY;
                }
                memset(clipCodes, 0, dwNumVertices * sizeof(D3DFE_CLIPCODE));
                dstVOP |= D3DVOP_CLIP;
            }
        }
    }
    if (srcVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "Can be src VB for lighting.");
        srcVOP |= D3DVOP_LIGHT;
    }
    if (fvf & D3DFVF_DIFFUSE)
    {
        D3D_INFO(4, "D3DFVF_DIFFUSE set. Can be dest VB for lighting");
        dstVOP |= D3DVOP_LIGHT;
    }
    if (dstVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "VB can be rendered");
        srcVOP |= D3DVOP_RENDER;
    }

    return(D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Lock"

HRESULT D3DAPI CDirect3DVertexBuffer::Lock(DWORD dwFlags, LPVOID* lplpData, DWORD* lpdwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    HRESULT ret;
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (IsBadWritePtr( lplpData, sizeof(LPVOID)))
    {
        D3D_ERR( "Invalid lpData pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (lpdwSize)
    {
        if (IsBadWritePtr( lpdwSize, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
#endif
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("Cannot lock optimized vertex buffer");
        return(D3DERR_VERTEXBUFFEROPTIMIZED);
    }
    if (!this->position.lpvData)
    {
        // Unlock if previous lock was broken due to mode switch
        if (DDSGBL(lpDDSVB)->dwUsageCount > 0)
        {
            DDASSERT(DDSGBL(lpDDSVB)->dwUsageCount == 1);
            D3D_INFO(2, "Lock: Unlocking broken VB lock");
            lpDDSVB->Unlock(NULL);
        }
        if (lpDevIBatched)
        {
            ret = lpDevIBatched->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Could not flush batch referring to VB during Lock");
                return ret;
            }
        }
#ifdef DBG
        LPVOID pOldBuf = (LPVOID)((LPDDRAWI_DDRAWSURFACE_INT)lpDDSVB)->lpLcl->lpGbl->fpVidMem;
#endif // DBG
        // Do a real Lock
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ret = lpDDSVB->Lock(NULL, &ddsd, dwFlags | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Lock: Could not lock Vertex Buffer: %08x", ret);
            return ret;
        }
        position.lpvData = ddsd.lpSurface;
#if DBG
        if(ddsd.lpSurface != pOldBuf)
        {
            D3D_INFO(2, "Driver swapped VB pointer in Lock");
        }
        LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
        for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
            *pPad++ = 0xdeadbeef;
#endif
    }
#ifdef VTABLE_HACK
    /* Single threaded or Multi threaded app ? */
    if (!(((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED))
        VtblLockFast();
#endif // VTABLE_HACK
    return this->LockI(dwFlags, lplpData, lpdwSize);
}

//---------------------------------------------------------------------
// Side effect:
//      position.lpvData is set.
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockI"

HRESULT D3DAPI CDirect3DVertexBuffer::LockI(DWORD dwFlags, LPVOID* lplpData,
                                            DWORD* lpdwSize)
{
    dwLockCnt++;
    D3D_INFO(6, "VB Lock: %lx Lock Cnt =%d", this, dwLockCnt);
    if (!(dwFlags & (DDLOCK_READONLY | DDLOCK_NOOVERWRITE)) && lpDevIBatched)
    {
        HRESULT ret;
        if (dwFlags & DDLOCK_OKTOSWAP)
        {
            ret = lpDevIBatched->FlushStatesReq(position.dwStride * dwNumVertices);
#if DBG
            if (!(this->dwCaps & D3DVBCAPS_OPTIMIZED))
            {
                // Make sure the size of the new buffer is the same
                DDASSERT(position.dwStride * (dwNumVertices + 1) <= DDSGBL(lpDDSVB)->dwLinearSize);
                // Write deadbeaf in the pad area
                LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
                for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
                    *pPad++ = 0xdeadbeef;
            }
#endif
        }
        else
            ret = lpDevIBatched->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not flush batch referring to VB during Lock");
            return ret;
        }
    }
    *lplpData = position.lpvData;
    if (lpdwSize)
        *lpdwSize = position.dwStride * dwNumVertices;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Unlock"

HRESULT D3DAPI CDirect3DVertexBuffer::Unlock()
{
    if (dwLockCnt)
    {
        dwLockCnt--;
    }
#ifdef DBG
    if (!(this->dwCaps & D3DVBCAPS_OPTIMIZED))
    {
        // Check for VB overruns
        LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
        for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
            if (*pPad++ != 0xdeadbeef)
            {
                D3D_ERR("Vertex buffer was overrun. Make sure that you do not write past the VB size!");
                return D3DERR_VERTEXBUFFERUNLOCKFAILED;
            }
        D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
    }
#endif
    return D3D_OK;
}

// Called from FlushStates to undo cached VB pointer so that the next lock causes a driver lock
// This is necessary if the we did not flush with SWAPVERTEXBUFFER.
void CDirect3DVertexBuffer::UnlockI()
{
    if ((this->dwMemType == DDSCAPS_VIDEOMEMORY) && (dwLockCnt == 0))
    {
#ifdef VTABLE_HACK
        VtblLockDefault();
#endif
        lpDDSVB->Unlock(NULL);
        position.lpvData = 0;
    }
    else if (dwLockCnt !=0 )
    {
        D3D_WARN(4, "App has a lock on VB %08x so driver call may be slow", this);
    }
}

#ifndef WIN95
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockWorkAround"

HRESULT CDirect3DVertexBuffer::LockWorkAround(CDirect3DDeviceIDP2 *pDev)
{
    if (this->dwMemType == DDSCAPS_VIDEOMEMORY)
    {
#ifdef DBG
        LPVOID pOldBuf = (LPVOID)((LPDDRAWI_DDRAWSURFACE_INT)lpDDSVB)->lpLcl->lpGbl->fpVidMem;
#endif // DBG
        // Do a real Lock
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        HRESULT ret = lpDDSVB->Lock(NULL, &ddsd, DDLOCK_OKTOSWAP | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Lock: Could not lock Vertex Buffer: %08x", ret);
            return ret;
        }
        position.lpvData = ddsd.lpSurface;
        pDev->alignedBuf = ddsd.lpSurface;
#ifdef DBG
        if(ddsd.lpSurface != pOldBuf)
        {
            D3D_INFO(2, "Driver swapped TLVBuf pointer in Lock");
        }
#endif
        // Make sure the size of the new buffer is the same
        DDASSERT(position.dwStride * (dwNumVertices + 1) <= DDSGBL(lpDDSVB)->dwLinearSize);
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::UnlockWorkAround"

void CDirect3DVertexBuffer::UnlockWorkAround()
{
    if ((this->dwMemType == DDSCAPS_VIDEOMEMORY) &&
        (position.lpvData != 0))
    {
        lpDDSVB->Unlock(NULL);
        position.lpvData = 0;
    }
}

#endif // WIN95

// Cause us to go thru the slow path and force a lock
// The slow path will do the unlock if necessary. This
// is because we are called from DDraw's invalidate
// surface code and it might not be the best time to
// call back ddraw to unlock the surface.
void CDirect3DVertexBuffer::BreakLock()
{
    D3D_INFO(6, "Notified of restore on VB %08x", this);
#ifdef VTABLE_HACK
    VtblLockDefault();
#endif
    position.lpvData = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::GetVertexBufferDesc"

HRESULT D3DAPI CDirect3DVertexBuffer::GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC lpDesc)
{
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (IsBadWritePtr( lpDesc, lpDesc->dwSize))
    {
        D3D_ERR( "Invalid lpData pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (! VALID_D3DVERTEXBUFFERDESC_PTR(lpDesc) )
    {
        D3D_ERR( "Invalid D3DVERTEXBUFFERDESC" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    lpDesc->dwCaps = dwCaps;
    lpDesc->dwFVF = fvf;
    lpDesc->dwNumVertices = this->dwNumVertices;
    return D3D_OK;
}
//---------------------------------------------------------------------
// Common validation for ProcessVertices and ProcessVerticesStrided
//
HRESULT CDirect3DVertexBuffer::ValidateProcessVertices(
                    DWORD vertexOP,
                    DWORD dwDstIndex,
                    DWORD dwCount,
                    LPVOID lpSrc,
                    LPDIRECT3DDEVICE7 lpDevice,
                    DWORD dwFlags)
{
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid destination Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_DIRECT3DDEVICE_PTR(lpDevice))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpDevI->ValidateFVF(this->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (dwFlags & ~D3DPV_DONOTCOPYDATA)
    {
        D3D_ERR( "Invalid dwFlags set" );
        return DDERR_INVALIDPARAMS;
    }
    if ((dwDstIndex + dwCount) > this->dwNumVertices)
    {
        D3D_ERR( "Vertex count plus destination index is greater than number of vertices" );
        return DDERR_INVALIDPARAMS;
    }
    // Validate Dst Vertex Formats
    if (lpSrc)
    {
        if ((this->dstVOP & vertexOP) != vertexOP)
            goto error;
    }
    else
    {
        if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        {
            if (vertexOP & ~(D3DVOP_CLIP | D3DVOP_EXTENTS))
                goto error;
        }
        else
        {
            if (vertexOP & ~(D3DVOP_CLIP))
                goto error;
        }
    }
    return D3D_OK;
error:
    D3D_ERR("Destination VB cannot support this operation");
    return D3DERR_INVALIDVERTEXFORMAT;
}
//---------------------------------------------------------------------
// Common part for ProcessVertices and ProcessVerticesStrided
//
HRESULT CDirect3DVertexBuffer::DoProcessVertices(
                            LPDIRECT3DVERTEXBUFFERI lpSrcI,
                            LPDIRECT3DDEVICEI lpDevI,
                            DWORD vertexOP,
                            DWORD dwSrcIndex,
                            DWORD dwDstIndex,
                            DWORD dwFlags)
{
    lpDevI->lpClipFlags = clipCodes + dwDstIndex;
    // Compute needed output FVF
    {
        DWORD dwInputVertexSize;
        HRESULT ret = lpDevI->SetupFVFDataCommon(&dwInputVertexSize);
        if (ret != D3D_OK)
            return ret;
        // Make sure we have specular in output VB if the current state settings
        // require us to write to specular
        if (vertexOP & D3DVOP_LIGHT)
            if (lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE] || lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
                if (!(fvf & D3DFVF_SPECULAR))
                {
                    D3D_ERR("Destination VB FVF format cannot be used with the current D3D settings");
                    return D3DERR_INVALIDVERTEXFORMAT;
                }
        // Check number of texture coordinates and texture formats in the
        // destination VB are the same as in the computed FVF
        DWORD dwComputedOutFVF = lpDevI->dwVIDOut & 0xFFFF0000;
        if (lpDevI->nOutTexCoord > this->nTexCoord ||
            ((fvf & dwComputedOutFVF) != dwComputedOutFVF))
        {
            D3D_ERR("Destination VB FVF format cannot be used with the current D3D settings");
            return D3DERR_INVALIDVERTEXFORMAT;
        }
    }
    // Output
    lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
    lpDevI->dwOutputSize = this->position.dwStride;
    lpDevI->dwVIDOut = fvf;

    // Set up vertex pointers, because SetupFVFData works with "computed" FVF
    UpdateGeometryLoopData(lpDevI);

    // Save current flags to restore later
    DWORD dwOrigDeviceFlags = lpDevI->dwDeviceFlags;
    if (vertexOP & D3DVOP_CLIP)
    {
        lpDevI->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        this->dwPVFlags |= D3DPV_CLIPCODESGENERATED;
    }
    else
    {
        lpDevI->dwDeviceFlags |= D3DDEV_DONOTCLIP;
    }

    if (vertexOP & D3DVOP_LIGHT)
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTING;
    else
        lpDevI->dwDeviceFlags &= ~D3DDEV_LIGHTING;

    if (vertexOP & D3DVOP_EXTENTS)
    {
        lpDevI->dwDeviceFlags &= ~D3DDEV_DONOTUPDATEEXTENTS;
    }
    else
    {
        lpDevI->dwDeviceFlags |= D3DDEV_DONOTUPDATEEXTENTS;
    }

    DoUpdateState(lpDevI);

    if (lpSrcI)
    {
        if (lpSrcI->bReallyOptimized)
        { // SOA
          // Assume that SOA.lpvData is the same as position.lpvData
            lpDevI->SOA.lpvData = lpSrcI->position.lpvData;
            lpDevI->SOA.dwStride = lpSrcI->dwNumVertices;
            lpDevI->dwSOAStartVertex = dwSrcIndex;
            lpDevI->dwOutputSize = position.dwStride;
        }
        else
        { // AOS FVF
            lpDevI->dwOutputSize = position.dwStride;
            lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
            lpDevI->position.dwStride = lpSrcI->position.dwStride;
        }
    }

    if (dwFlags & D3DPV_DONOTCOPYDATA)
    {
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE | D3DPV_DONOTCOPYSPECULAR |
                           D3DPV_DONOTCOPYTEXTURE;
        // If D3DIM generates colors or texture, we should clear DONOTCOPY bits
        if (lpDevI->dwFlags & D3DPV_LIGHTING)
        {
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYDIFFUSE;
            if (lpDevI->dwDeviceFlags & D3DDEV_SPECULARENABLE)
                lpDevI->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
        }
        if (lpDevI->dwFlags & D3DPV_FOG)
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
        // If front-end is asked to do something with texture coordinates
        // we disable DONOTCOPYTEXTURE
        if (__TEXTURETRANSFORMENABLED(lpDevI) || lpDevI->dwFlags2 & __FLAGS2_TEXGEN)
        {
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYTEXTURE;
        }
    }

    lpDevI->pGeometryFuncs->ProcessVertices(lpDevI);

    // This bit should be cleared, because for ProcessVertices calls user should
    // set texture stage indices and wrap modes himself
    lpDevI->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;

    if (!(lpDevI->dwDeviceFlags & D3DDEV_DONOTCLIP))
        D3DFE_UpdateClipStatus(lpDevI);
    // Restore _DONOTCLIP & _DONOTUPDATEEXTENTS flags
    const DWORD PRESERVED_FLAGS = D3DDEV_DONOTCLIP |
                                  D3DDEV_DONOTUPDATEEXTENTS |
                                  D3DDEV_LIGHTING;
    lpDevI->dwDeviceFlags = (dwOrigDeviceFlags & PRESERVED_FLAGS) |
                            (lpDevI->dwDeviceFlags & ~PRESERVED_FLAGS);

    // Force recompute fvf next time around
    lpDevI->ForceFVFRecompute();

    // Unlock the VB
    Unlock();

    // If we used SOA then the dwVIDIn <-> position.dwStride relationship
    // violated. This fixes that. This is required since in non VB code
    // we will not recompute position.dwStride if FVF matched dwVIDIn.
    if (lpSrcI)
        lpDevI->position.dwStride = lpSrcI->position.dwStride;

    return D3D_OK;
}
//---------------------------------------------------------------------
// lpSrc should be NULL for XYZRHW buffers
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVertices"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVertices(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount,
                                                      LPDIRECT3DVERTEXBUFFER7 lpSrc,
                                                      DWORD dwSrcIndex,
                                                      LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpSrcI;
    LPDIRECT3DDEVICEI lpDevI;
    HRESULT ret = D3D_OK;

#if DBG
    ret = this->ValidateProcessVertices(vertexOP, dwDstIndex, dwCount, lpSrc, lpDevice, dwFlags);
    if (ret != D3D_OK)
        return ret;
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpSrc != NULL)
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpSrc))
        {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
        if (lpDevI->ValidateFVF(lpSrcI->fvf) != D3D_OK)
        {
            D3D_ERR("Invalid source vertex buffer FVF for the device");
            return DDERR_INVALIDPARAMS;
        }
        // Validate Src Vertex Formats
        if ((lpSrcI->srcVOP & vertexOP) != vertexOP)
        {
            D3D_ERR("Source VB cannot support this operation");
            return D3DERR_INVALIDVERTEXFORMAT;
        }
        if ((dwSrcIndex + dwCount) > lpSrcI->dwNumVertices)
        {
            D3D_ERR( "Source index plus vertex count is greater than number of vertices" );
            return DDERR_INVALIDPARAMS;
        }
        if (!(vertexOP & D3DVOP_TRANSFORM))
        {
            D3D_ERR("D3DVOP_TRANSFORM flag should be set");
            return DDERR_INVALIDPARAMS;
        }
        // Source to ProcessVertices must be in system memory. This is for reasons similar
        // to why we insist on sys mem VB for SW rast. For instance, a driver may have optimized
        // the VB into some cryptic format which D3D FE will have no clue to decipher.
        if (!(lpSrcI->dwCaps & D3DVBCAPS_SYSTEMMEMORY))
        {
            D3D_ERR("Source VB must be created with D3DVBCAPS_SYSTEMMEMORY");
            return DDERR_INVALIDPARAMS;
        }
    }
#else
    lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    lpDevI->dwNumVertices = dwCount;

    // Lock the VBs
    LPVOID lpVoid;
    // We call the API level lock since dest VB may be in vid mem. This function will fail for
    // optimized VBs and that is OK since we cannot write out optimized vertices anyway.
    ret = Lock(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    if (lpSrc == NULL)
    {
        lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
        if ((fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
        {
            if (vertexOP & D3DVOP_CLIP)
            {
                CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.
                if (lpDevI->dwFEFlags & (D3DFE_TRANSFORM_DIRTY | D3DFE_CLIPPLANES_DIRTY))
                {
                    DoUpdateState(lpDevI);
                }
                lpDevI->CheckClipStatus((D3DVALUE*)lpDevI->lpvOut,
                                         position.dwStride,
                                         dwCount,
                                         &lpDevI->dwClipUnion,
                                         &lpDevI->dwClipIntersection);
                D3DFE_UpdateClipStatus(lpDevI);
            }
        }
        else
        {
            // For transformed vertices we support only clip code generation and extens
            lpDevI->lpClipFlags = clipCodes + dwDstIndex;
            lpDevI->position.lpvData = lpDevI->lpvOut;
            lpDevI->position.dwStride = position.dwStride;
            lpDevI->dwOutputSize = position.dwStride;
            if (vertexOP & D3DVOP_CLIP)
            {
                D3DFE_GenClipFlags(lpDevI);
                D3DFE_UpdateClipStatus(lpDevI);
                // Mark this buffer as "transformed" for clipping
                dwPVFlags |= D3DPV_TLVCLIP;
            }
            if (vertexOP & D3DVOP_EXTENTS)
            {
                D3DFE_updateExtents(lpDevI);
            }
        }
        Unlock();
        return D3D_OK;
    }
    // Safe to LockI since source is guaranteed to be in system memory
    // Cannot call API Lock since we need to be able to lock optimized VBs
    ret = lpSrcI->LockI(DDLOCK_WAIT | DDLOCK_READONLY, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    dwPVFlags &= ~D3DPV_TLVCLIP;    // Mark the dest VB as "not transformed" for clipping
    lpDevI->dwFlags = (lpSrcI->dwPVFlags & D3DPV_SOA) | D3DPV_VBCALL;
    lpDevI->dwDeviceFlags &= ~D3DDEV_STRIDE;

    // Input
    lpDevI->dwVIDIn = lpSrcI->fvf;

    ret = this->DoProcessVertices(lpSrcI, lpDevI, vertexOP, dwSrcIndex, dwDstIndex, dwFlags);
    if (ret != D3D_OK)
        lpSrcI->Unlock();
    else
        ret = lpSrc->Unlock();
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVerticesStrided"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVerticesStrided(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount,
                                                      LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                                      DWORD dwSrcFVF,
                                                      LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DDEVICEI lpDevI;
    HRESULT ret = D3D_OK;

#if DBG
    ret = this->ValidateProcessVertices(vertexOP, dwDstIndex, dwCount, lpDrawData, lpDevice, dwFlags);
    if (ret != D3D_OK)
        return ret;
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpDevI->ValidateFVF(dwSrcFVF) != D3D_OK)
    {
        D3D_ERR("Invalid source FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if ((dwSrcFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        D3D_ERR("ProcessVerticesStrided cannot handle transformed vertices");
        return D3DERR_INVALIDVERTEXTYPE;
    }
    if (!(vertexOP & D3DVOP_TRANSFORM))
    {
        D3D_ERR("D3DVOP_TRANSFORM flag should be set");
        return DDERR_INVALIDPARAMS;
    }
#else
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    // Lock the VBs
    LPVOID lpVoid;
    // We call the API level lock since dest VB may be in vid mem. This function will fail for
    // optimized VBs and that is OK since we cannot write out optimized vertices anyway.
    ret = Lock(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    dwPVFlags &= ~D3DPV_TLVCLIP;    // Mark the dest VB as "not transformed" for clipping
    lpDevI->dwDeviceFlags |= D3DDEV_STRIDE;
    lpDevI->dwFlags = D3DPV_VBCALL;

    // Input
    lpDevI->dwNumVertices = dwCount;
    lpDevI->dwVIDIn = dwSrcFVF;
    lpDevI->position = lpDrawData->position;
    lpDevI->normal = lpDrawData->normal;
    lpDevI->diffuse = lpDrawData->diffuse;
    lpDevI->specular = lpDrawData->specular;
    for (DWORD i=0; i < this->nTexCoord; i++)
        lpDevI->textures[i] = lpDrawData->textureCoords[i];

    return this->DoProcessVertices(NULL, lpDevI, vertexOP, 0, dwDstIndex, dwFlags);
}
//---------------------------------------------------------------------
#ifdef DBG
HRESULT DIRECT3DDEVICEI::CheckDrawPrimitiveVB(LPDIRECT3DVERTEXBUFFER7 lpVBuf, DWORD dwStartVertex, DWORD dwNumVertices, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (this->ValidateFVF(lpVBufI->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (!IsDPFlagsValid(dwFlags))
    {
        D3D_ERR("Invalid Flags in dwFlags field");
        return DDERR_INVALIDPARAMS;
    }
    if (!(dwDeviceFlags & D3DDEV_DONOTCLIP) && (lpVBufI->clipCodes == NULL) && (lpVBufI->srcVOP & D3DVOP_RENDER))
    {
        D3D_ERR("Vertex buffer does not support clipping");
        return DDERR_INVALIDPARAMS;
    }
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    /* If we are on HAL with an untransformed vid mem VB then we disallow
       This will happen only on T&L HW. The reason we disallow this is that
       it'll be very slow so this is not an interesting thing to do anyway */
    if ( !IS_TLHAL_DEVICE(this) &&
         !(lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY) &&
         !FVF_TRANSFORMED(lpVBufI->fvf) )
    {
        D3D_ERR("DrawPrimitiveVB: Untransformed VB for HAL device must be created with D3DVBCAPS_SYSTEMMEMORY");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (dwStartVertex + dwNumVertices > lpVBufI->dwNumVertices)
    {
        D3D_ERR("Vertex range is outside the vertex buffer");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    HRESULT ret;
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwNumIndices = dwIndexCount;
    this->lpwIndices = lpwIndices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats
#if DBG
    if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
#endif

    if (lpVBufI->srcVOP & D3DVOP_RENDER || IS_TLHAL_DEVICE(this))
    { // TLVERTEX or TLHAL

        this->dwOutputSize = lpVBufI->position.dwStride;
        this->position.dwStride = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        DWORD dwOldVidIn = this->dwVIDIn;
        this->dwVIDIn = lpVBufI->fvf;
        BOOL bNoClipping = this->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                           (!(lpVBufI->dwPVFlags & D3DPV_CLIPCODESGENERATED) && IS_TLHAL_DEVICE(this));
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
             if (ret != D3D_OK)
                return ret;
            lpVBufI->lpDevIBatched = this;
#ifdef VTABLE_HACK
            if (bNoClipping && !IS_MT_DEVICE(this))
                VtblDrawIndexedPrimitiveVBTL();
#endif
            this->nOutTexCoord = lpVBufI->nTexCoord;
        }
        else
        {
            // needed for legacy drivers' DrawIndexPrim code
            this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) +
                           dwStartVertex * this->dwOutputSize;
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, lpVBufI->dwTexCoordSize, TRUE);
        }
        if (bNoClipping)
        {
            return DrawIndexPrim();
        }
        else
        {
            this->dwTextureCoordSizeTotal = lpVBufI->dwTexCoordSizeTotal;
            for (DWORD i=0; i < this->nOutTexCoord; i++)
            {
                this->dwTextureCoordSize[i] = lpVBufI->dwTexCoordSize[i];
            }
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            if (dwOldVidIn != lpVBufI->fvf)
            {
                ComputeOutputVertexOffsets(this);
            }
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) +
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
                this->position.lpvData = this->lpvOut;
#if DBG
                ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
                if (ret == D3D_OK)
                    ret = DoDrawIndexedPrimitive(this);
#else
                ret = DoDrawIndexedPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
                this->lpvOut = (BYTE*)lpVBufI->position.lpvData + dwStartVertex * this->dwOutputSize;
                this->position.lpvData = this->lpvOut;
#if DBG
                ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawIndexedPrimitive(this);
            }
        }
    }
    else
    {
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
#ifdef VTABLE_HACK
            if (IS_DP2HAL_DEVICE(this) && !IS_MT_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->lpDP2LastVBI = lpVBufI;
                dev->VtblDrawIndexedPrimitiveVBFE();
            }
#endif
        }
        if (this->dwVIDIn != lpVBufI->fvf || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn = lpVBufI->fvf;
            ret = SetupFVFData(NULL);
            if (ret != D3D_OK)
                goto l_exit;
        }
#if DBG
        ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
        if (ret != D3D_OK)
            goto l_exit;
#endif
        ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
l_exit:
        // If we used SOA then the dwVIDIn <-> position.dwStride relationship
        // violated. This fixes that. This is required since in non VB code
        // we will not recompute position.dwStride if FVF matched dwVIDIn.
        this->position.dwStride = lpVBufI->position.dwStride;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock
    HRESULT ret;
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats
#if DBG
    if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
#endif
    if (lpVBufI->srcVOP & D3DVOP_RENDER || IS_TLHAL_DEVICE(this))
    { // TLVERTEX or TLHAL
        this->position.dwStride = lpVBufI->position.dwStride;
        this->dwOutputSize = lpVBufI->position.dwStride;
        DWORD dwOldVidIn = this->dwVIDIn;
        this->dwVIDIn = lpVBufI->fvf;
        this->dwVIDOut = lpVBufI->fvf;
        BOOL bNoClipping = this->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                           (!(lpVBufI->dwPVFlags & D3DPV_CLIPCODESGENERATED) && IS_TLHAL_DEVICE(this));
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
            if (ret != D3D_OK)
                return ret;
            lpVBufI->lpDevIBatched = this;
#ifdef VTABLE_HACK
            if (bNoClipping && !IS_MT_DEVICE(this))
                VtblDrawPrimitiveVBTL();
#endif
            this->nOutTexCoord = lpVBufI->nTexCoord;
        }
        else
        {
            // needed for legacy drivers' DrawPrim code
            this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) +
                           dwStartVertex * this->dwOutputSize;
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, lpVBufI->dwTexCoordSize, TRUE);
        }
        if (bNoClipping)
        {
            return DrawPrim();
        }
        else
        {
            this->dwTextureCoordSizeTotal = lpVBufI->dwTexCoordSizeTotal;
            for (DWORD i=0; i < this->nOutTexCoord; i++)
            {
                this->dwTextureCoordSize[i] = lpVBufI->dwTexCoordSize[i];
            }
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            if (dwOldVidIn != lpVBufI->fvf)
            {
                ComputeOutputVertexOffsets(this);
            }
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) +
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
                this->position.lpvData = this->lpvOut;
#if DBG
                ret=CheckDrawPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawPrimitive(this);
#else
                ret = DoDrawPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
                this->lpvOut = (BYTE*)lpVBufI->position.lpvData + dwStartVertex * this->dwOutputSize;
                this->position.lpvData = this->lpvOut;
#if DBG
                ret=CheckDrawPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawPrimitive(this);
            }
        }
    }
    else
    {
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
#ifdef VTABLE_HACK
            if (IS_DP2HAL_DEVICE(this) && !IS_MT_DEVICE(this) && IS_FPU_SETUP(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->lpDP2LastVBI = lpVBufI;
                dev->VtblDrawPrimitiveVBFE();
            }
#endif
        }
        if (this->dwVIDIn != lpVBufI->fvf || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn = lpVBufI->fvf;
            ret = SetupFVFData(NULL);
            if (ret != D3D_OK)
                goto l_exit;
        }
#if DBG
        ret=CheckDrawPrimitive(this);
        if (ret != D3D_OK)
            goto l_exit;
#endif
        ret = this->ProcessPrimitive();
l_exit:
        // If we used SOA then the dwVIDIn <-> position.dwStride relationship
        // violated. This fixes that. This is required since in non VB code
        // we will not recompute position.dwStride if FVF matched dwVIDIn.
        this->position.dwStride = lpVBufI->position.dwStride;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DVertexBuffer::Optimize"

HRESULT D3DAPI CDirect3DVertexBuffer::Optimize(LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    HRESULT ret;
    LPDIRECT3DDEVICEI lpDevI;
    DWORD bufferSize;
    LPDIRECTDRAWSURFACE7 lpSurface7;
    LPDIRECTDRAWSURFACE  lpSurface;
    LPVOID lpMemory;


// Validate parms
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_DIRECT3DDEVICE_PTR(lpDevice))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (dwFlags != 0)
    {
        D3D_ERR("dwFlags should be zero");
        return DDERR_INVALIDPARAMS;
    }

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));

    if (lpDevI->ValidateFVF(this->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("The vertex buffer already optimized");
        return D3DERR_VERTEXBUFFEROPTIMIZED;
    }
    if (this->dwLockCnt != 0)
    {
        D3D_ERR("Could not optimize locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (IS_TLHAL_DEVICE(lpDevI) && (this->dwCaps & D3DVBCAPS_SYSTEMMEMORY)==0)
    {
        if (this->dwPVFlags & D3DPV_CLIPCODESGENERATED || (!IS_HW_DEVICE(lpDevI)))
        {
            // silently ignore since we'll be either
            // using our front end or this is ref rast
            // Either way we need no special optimization
            goto success;
        }
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_CAPS | DDSD_FVF | DDSD_SRCVBHANDLE;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_VERTEXBUFFER;
        ddsd.dwFVF = this->fvf; // Let driver know about the FVF
        ddsd.dwSrcVBHandle = DDSLCL(this->lpDDSVB)->lpSurfMore->dwSurfaceHandle;
        if (lpDevI->lpDirect3DI->lpDD7->CreateSurface(&ddsd, &lpSurface7, NULL) != DD_OK)
        {
            // Driver could not or did not want to optimize the VB
            goto success;
        }
        ret = lpSurface7->QueryInterface(IID_IDirectDrawSurfaceNew, (LPVOID*)&lpSurface);
        if (ret != DD_OK)
        {
            D3D_ERR("failed to QI for DDS1");
            lpSurface7->Release();
            return ret;
        }
        // Destroy old surfaces
        lpDDSVB->Release();
        lpDDS1VB->Release();
        // And use new ones
        lpDDSVB = lpSurface7;
        lpDDS1VB = lpSurface;

        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
#ifdef VTABLE_HACK
        VtblLockDefault();
#endif // VTABLE_HACK
        return D3D_OK;
    }
    else
    {
    // Do nothing for transformed vertices
        if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        {
            goto success;
        }
    // Get the buffer size to allocate
        bufferSize = lpDevI->pGeometryFuncs->ComputeOptimizedVertexBufferSize
                                                    (this->fvf, this->position.dwStride,
                                                     dwNumVertices);
    // Create new surfaces for optimized vertex buffer
        if (bufferSize == 0)
        {
            goto success;
        }

        ret = CreateMemoryBuffer(lpDevI->lpDirect3DI, &lpSurface7, &lpSurface,
                                 &lpMemory, bufferSize);
        if (ret != D3D_OK)
            return ret;
    // Try to optimize
    // If optimized vertex buffer are not supported by the implementation
    // it returns E_NOTIMPL. In this case we still set D3DVBCAPS_OPTIMIZED to prevent
    // locking of the vertex buffer. But bReallyOptimized is set to FALSE, to use
    // the original buffer.
        ret = lpDevI->pGeometryFuncs->OptimizeVertexBuffer
            (fvf, dwNumVertices, position.dwStride, position.lpvData,
             lpMemory, dwFlags);

        if (ret)
        {
            lpSurface7->Release();
            lpSurface->Release();
            if (ret == E_NOTIMPL)
            {
                goto success;
            }
            else
            {
                D3D_ERR("Failed to optimize vertex buffer");
                return ret;
            }
        }
        bReallyOptimized = TRUE;
        this->dwPVFlags |= D3DPV_SOA;
    // Destroy old surfaces
        lpDDSVB->Release();
        lpDDS1VB->Release();
    // And use new ones
        lpDDSVB = lpSurface7;
        lpDDS1VB = lpSurface;
        position.lpvData = lpMemory;
    success:
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
#ifdef VTABLE_HACK
        // Disable all fast path optimizations
        VtblLockDefault();
        if (this->lpDevIBatched)
        {
            this->lpDevIBatched->VtblDrawPrimitiveVBDefault();
            this->lpDevIBatched->VtblDrawIndexedPrimitiveVBDefault();
        }
#endif
        return D3D_OK;
    }
}

#ifdef VTABLE_HACK
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVBTL"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawPrimitiveVBTL(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    HRESULT ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2CurrBatchVBI) && (this->dwVIDIn))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = dwStartVertex;
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
        lpVBufI->lpDevIBatched = this;
        return DrawPrim();
    }
    VtblDrawPrimitiveVBDefault();
    return DrawPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVBTL"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    HRESULT ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2CurrBatchVBI) && (this->dwVIDIn))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = dwStartVertex;
        this->dwNumIndices = dwIndexCount;
        this->lpwIndices = lpwIndices;
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
        lpVBufI->lpDevIBatched = this;
        return DrawIndexPrim();
    }
    VtblDrawIndexedPrimitiveVBDefault();
    return DrawIndexedPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, lpwIndices, dwIndexCount, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVBFE"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawPrimitiveVBFE(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    HRESULT ret;
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2LastVBI) &&
        !(this->dwFEFlags & D3DFE_FRONTEND_DIRTY))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = this->dwLastFlags | dwFlags | lpVBufI->dwPVFlags;
        this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                 dwStartVertex * lpVBufI->position.dwStride;
#if DBG
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
        }
        if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
            this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
        }
        DDASSERT(this->dwDP2VertexCount * this->dwOutputSize == this->TLVbuf_Base());
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
        this->lpvOut = this->TLVbuf_GetAddress();
//        try
//        {
        switch (this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumPrimitives = dwNumVertices;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINELIST:
            this->dwNumPrimitives = dwNumVertices >> 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINESTRIP:
            this->dwNumPrimitives = dwNumVertices - 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleFan(this);
            break;
        case D3DPT_TRIANGLESTRIP:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleStrip(this);
            break;
        case D3DPT_TRIANGLELIST:
    #ifdef _X86_
            {
                DWORD tmp;
                __asm
                {
                    mov  eax, 0x55555555    // fractional part of 1.0/3.0
                    mul  dwNumVertices
                    add  eax, 0x80000000    // Rounding
                    adc  edx, 0
                    mov  tmp, edx
                }
                this->dwNumPrimitives = tmp;
            }
    #else
            this->dwNumPrimitives = dwNumVertices / 3;
    #endif
            ret = this->pGeometryFuncs->ProcessTriangleList(this);
            break;
        }
//        }
//        catch (HRESULT ret)
//        {
//            return ret;
//        }
        D3DFE_UpdateClipStatus(this);
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
        return ret;
    }
    VtblDrawPrimitiveVBDefault();
    return DrawPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVBFE"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    HRESULT ret;
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2LastVBI) &&
        !(this->dwFEFlags & D3DFE_FRONTEND_DIRTY))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = this->dwLastFlags | dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = 0;
        this->dwNumIndices = dwIndexCount;
        this->lpwIndices = lpwIndices;
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
        this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                 dwStartVertex * lpVBufI->position.dwStride;
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize,
                (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
        }
        if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
            this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
        }
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
        this->lpvOut = this->TLVbuf_GetAddress();
//        try
//        {
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
//        }
//        catch (HRESULT ret)
//        {
//            return ret;
//        }
        D3DFE_UpdateClipStatus(this);
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
        return ret;
    }
    VtblDrawIndexedPrimitiveVBDefault();
    return DrawIndexedPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, lpwIndices, dwIndexCount, dwFlags);
}
#endif // VTABLE_HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "d3dfei.h"
#include "drawprim.hpp"

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;
// Maximum number of clear rectangles considered legal.
// This limit is set by NT kernel for Clear2 callback
const DWORD MAX_CLEAR_RECTS  = 0x1000;

void
UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT7 *data)
{
#if DBG
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if (data->dwWidth == 0 || data->dwHeight == 0)
    {
        D3D_ERR("Viewport width or height is zero");
        throw DDERR_INVALIDPARAMS;
    }
    if (data->dvMaxZ < 0 ||
        data->dvMinZ < 0 ||
        data->dvMaxZ > 1 ||
        data->dvMinZ > 1)
    {
        D3D_ERR("dvMaxZ and dvMinZ should be between 0 and 1");
        throw DDERR_INVALIDPARAMS;
    }
    if (data->dvMaxZ < data->dvMinZ)
    {
        D3D_ERR("dvMaxZ should not be smaller than dvMinZ");
        throw DDERR_INVALIDPARAMS;
    }
#endif // DBG
    const D3DVALUE eps = 0.001f;
    if (data->dvMaxZ - data->dvMinZ < eps)
    {
        // When we clip, we transform vertices from the screen space to the
        // clipping space. With the above condition it is impossible. So we do
        // a little hack here by setting dvMinZ and dvMaxZ to different values
        if (data->dvMaxZ >= 0.5f)
            data->dvMinZ = data->dvMaxZ - eps;
        else
            data->dvMaxZ = data->dvMinZ + eps;
    }
    D3DFE_VIEWPORTCACHE *cache = &device->vcache;
    cache->dvX = D3DVAL(data->dwX);
    cache->dvY = D3DVAL(data->dwY);
    cache->dvWidth = D3DVAL(data->dwWidth);
    cache->dvHeight = D3DVAL(data->dwHeight);

    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->scaleZ  = D3DVAL(data->dvMaxZ - data->dvMinZ);
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    cache->offsetZ = D3DVAL(data->dvMinZ);
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    cache->offsetX += SMALL_NUMBER;
    cache->offsetY += SMALL_NUMBER;

    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->scaleZi = D3DVAL(1) / cache->scaleZ;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        LPD3DHAL_D3DEXTENDEDCAPS lpCaps = device->lpD3DExtendedCaps;

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = lpCaps->dvGuardBandLeft;
        cache->maxXgb = lpCaps->dvGuardBandRight;
        cache->minYgb = lpCaps->dvGuardBandTop;
        cache->maxYgb = lpCaps->dvGuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -(lpCaps->dvGuardBandLeft - cache->dvX)   * w + 1.0f;
        D3DVALUE ax2 =  (lpCaps->dvGuardBandRight  - cache->dvX) * w - 1.0f;
        D3DVALUE ay1 =  (lpCaps->dvGuardBandBottom - cache->dvY) * h - 1.0f;
        D3DVALUE ay2 = -(lpCaps->dvGuardBandTop - cache->dvY)    * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
DWORD
ProcessRects(LPDIRECT3DDEVICEI pDevI, DWORD dwCount, LPD3DRECT rects)
{
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

    if(dwCount == 0 && rects == NULL)
    {
        dwCount = 1;
    }
#if DBG
    else if(rects == NULL)
    {
        D3D_ERR("invalid clear rectangle parameter rects == NULL");
        throw DDERR_INVALIDPARAMS;
    }
#endif

    if (dwCount > pDevI->clrCount) {
        if (D3DRealloc((void**)&pDevI->clrRects, dwCount * sizeof(D3DRECT)) != DD_OK)
        {
            pDevI->clrCount = 0;
            pDevI->clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            throw DDERR_OUTOFMEMORY;
        }
    }
    pDevI->clrCount = dwCount;

    // If nothing is specified, assume the viewport needs to be cleared
    if (!rects)
    {
        pDevI->clrRects[0].x1 = pDevI->m_Viewport.dwX;
        pDevI->clrRects[0].y1 = pDevI->m_Viewport.dwY;
        pDevI->clrRects[0].x2 = pDevI->m_Viewport.dwX + pDevI->m_Viewport.dwWidth;
        pDevI->clrRects[0].y2 = pDevI->m_Viewport.dwY + pDevI->m_Viewport.dwHeight;
        return 1;
    }
    else
    {
        vwport.left   = pDevI->m_Viewport.dwX;
        vwport.top    = pDevI->m_Viewport.dwY;
        vwport.right  = pDevI->m_Viewport.dwX + pDevI->m_Viewport.dwWidth;
        vwport.bottom = pDevI->m_Viewport.dwY + pDevI->m_Viewport.dwHeight;

        j=0;
        for (i = 0; i < dwCount; i++)
        {
            if (IntersectRect((LPRECT)(pDevI->clrRects + j), &vwport, (LPRECT)(rects + i)))
                j++;
        }
        return j;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetViewportI"

void DIRECT3DDEVICEI::SetViewportI(LPD3DVIEWPORT7 lpData)
{
    // We have to check parameters here, because viewport could be changed
    // after creating a state set
    DWORD uSurfWidth,uSurfHeight;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;

    uSurfWidth=    ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
    uSurfHeight=   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

    if (lpData->dwX > uSurfWidth ||
        lpData->dwY > uSurfHeight ||
        lpData->dwX + lpData->dwWidth > uSurfWidth ||
        lpData->dwY + lpData->dwHeight > uSurfHeight)
    {
        D3D_ERR("Viewport outside the render target surface");
        throw DDERR_INVALIDPARAMS;
    }

    this->m_Viewport = *lpData;

    // Update front-end data
    UpdateViewportCache(this, &this->m_Viewport);

    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        // Download viewport data
        this->UpdateDrvViewInfo(&this->m_Viewport);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::SetViewport(LPD3DVIEWPORT7 lpData)
{
    if (!VALID_D3DVIEWPORT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DVIEWPORT7 pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertViewport(lpData);
        else
            SetViewportI(lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetViewport"

HRESULT
D3DAPI DIRECT3DDEVICEI::GetViewport(LPD3DVIEWPORT7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DVIEWPORT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->m_Viewport;

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Clear"
extern void BltFillRects(LPDIRECT3DDEVICEI, DWORD, LPD3DRECT, D3DCOLOR);
extern void BltFillZRects(LPDIRECT3DDEVICEI, unsigned long,DWORD, LPD3DRECT, DWORD);

#define bDoRGBClear ((dwFlags & D3DCLEAR_TARGET)!=0)
#define bDoZClear   ((dwFlags & D3DCLEAR_ZBUFFER)!=0)
#define bDoStencilClear ((dwFlags & D3DCLEAR_STENCIL)!=0)


HRESULT
D3DAPI DIRECT3DDEVICEI::Clear(DWORD dwCount, LPD3DRECT rects, DWORD dwFlags,
                              D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
#if DBG
    if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT)))
    {
        D3D_ERR( "Invalid rects pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        HRESULT err;
        LPDDPIXELFORMAT pZPixFmt=NULL;
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (dwCount > MAX_CLEAR_RECTS)
        {
            D3D_ERR("Cannot support more than 64K rectangles");
            return DDERR_INVALIDPARAMS;
        }
        if (!(lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
        {
            if (bDoStencilClear||bDoZClear)
            {
                if(lpDDSZBuffer==NULL)
                {
                    // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
                    // be considered an error
#if DBG
                    if(bDoZClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device");
                    }
                    if(bDoStencilClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device");
                    }
#endif
                    return D3DERR_ZBUFFER_NOTPRESENT;
                }
                pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
                if(bDoStencilClear)
                {
                    if(!(pZPixFmt->dwFlags & DDPF_STENCILBUFFER))
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits");
                        return D3DERR_STENCILBUFFER_NOTPRESENT;
                    }
                }
            }
        }
        if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)))
        {
            D3D_ERR("No valid flags passed to Clear");
            return DDERR_INVALIDPARAMS;
        }

        // bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

        DDASSERT(!bDoZClear || ((dvZ>=0.0) && (dvZ<=1.0)));
        DDASSERT(!bDoStencilClear || !pZPixFmt || (dwStencil <= (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1)));

        dwCount = ProcessRects(this, dwCount, rects);

        // Call DDI specific Clear routine
        ClearI(dwFlags, dwCount, dwColor, dvZ, dwStencil);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

void DIRECT3DDEVICEI::ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    HRESULT err;
    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later


    if ((err = FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear2");
        throw  err;
    }

    if (lpD3DHALCallbacks3->Clear2)
    {
        // Clear2 HAL Callback exists
        D3DHAL_CLEAR2DATA Clear2Data;
        Clear2Data.dwhContext   = dwhContext;
        Clear2Data.dwFlags      = dwFlags;
        // Here I will follow the ClearData.dwFillColor convention that
        // color word is raw 32bit ARGB, unadjusted for surface bit depth
        Clear2Data.dwFillColor  = dwColor;
        // depth/stencil values both passed straight from user args
        Clear2Data.dvFillDepth  = dvZ;
        Clear2Data.dwFillStencil= dwStencil;
        Clear2Data.lpRects      = clrRects;
        Clear2Data.dwNumRects   = clrCount;
        Clear2Data.ddrval       = D3D_OK;
    #ifndef WIN95
        if((err = CheckContextSurface(this)) != D3D_OK)
        {
            throw err;
        }
    #endif
        CALL_HAL3ONLY(err, this, Clear2, &Clear2Data);
        if (err != DDHAL_DRIVER_HANDLED)
        {
            throw DDERR_UNSUPPORTED;
        }
        else if (Clear2Data.ddrval != DD_OK)
        {
            throw Clear2Data.ddrval;
        }
        else
            return;
    }


    if (lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        if (bDoStencilClear)
        {
            D3D_ERR("Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR device doesn't support Clear2()");
            throw D3DERR_ZBUFFER_NOTPRESENT;
        }
        if (bDoZClear)
        {
            if (!(lpD3DHALCallbacks2->Clear) || (dvZ!=1.0))
            {
                D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this ZBUFFERLESSHSR device doesn't even support Clear() or Z!=1");
                dwFlags &= ~(D3DCLEAR_ZBUFFER);
            }
        }
    }
    LPDDPIXELFORMAT pZPixFmt;
    if (NULL != lpDDSZBuffer)
    {
        pZPixFmt = &((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
    }
    else
    {
        pZPixFmt = NULL;
    }
    if (lpD3DHALCallbacks2->Clear)
    {
        if(bDoZClear || bDoStencilClear)
        {
            if((pZPixFmt!=NULL) && //PowerVR need no Zbuffer
               (DDPF_STENCILBUFFER & pZPixFmt->dwFlags)
              )
            {
                // if surface has stencil bits, must verify either Clear2 callback exists or
                // we're using SW rasterizers (which require the special WriteMask DDHEL blt)
                // This case should not be hit since we check right at the
                // driver initialization time if the driver doesnt report Clear2
                // yet it supports stencils
                if(((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    goto Emulateclear;
                }
                else
                {
                    D3D_ERR("Driver HAL doesn't provide Clear2 callback, cannot use Clear2 with HW stencil surfaces");
                    throw DDERR_INVALIDPIXELFORMAT;
                }
            }
            // if Clear2 callback doesnt exist and it's a z-only surface and not doing zclear to
            // non-max value then Clear2 is attempting to do no more than Clear could do, so it's
            // safe to call Clear() instead of Clear2(), which will take advantage of older
            // drivers that implement Clear but not Clear2

            dwFlags &= ~D3DCLEAR_STENCIL;   // Device cannot do stencil
        }
        D3DHAL_CLEARDATA ClearData;
        if (bDoZClear && dvZ != 1.0)
        {
            ClearData.dwFlags   = dwFlags & ~D3DCLEAR_ZBUFFER;
            dwFlags = D3DCLEAR_ZBUFFER;
        }
        else
        {
            ClearData.dwFlags   = dwFlags;
            dwFlags = 0;
        }
        if (ClearData.dwFlags)
        {
            ClearData.dwhContext   = dwhContext;
            // Here I will follow the ClearData.dwFillColor convention that
            // color word is raw 32bit ARGB, unadjusted for surface bit depth
            ClearData.dwFillColor  = dwColor;
            // must clear to 0xffffffff because legacy drivers expect this
            ClearData.dwFillDepth  = 0xffffffff;
            ClearData.lpRects      = clrRects;
            ClearData.dwNumRects   = clrCount;
            ClearData.ddrval       = D3D_OK;
    #ifndef WIN95
            if((err = CheckContextSurface(this)) != D3D_OK)
            {
                throw err;
            }
    #endif
            CALL_HAL2ONLY(err, this, Clear, &ClearData);
            if (err != DDHAL_DRIVER_HANDLED)
            {
                throw DDERR_UNSUPPORTED;
            }
        }
    }
Emulateclear:
    // Fall back to Emulation using Blt

    if(bDoRGBClear)
    {
        BltFillRects(this, clrCount, clrRects, dwColor);
        //ok to not return possible errors from Blt?
    }

    if ((bDoZClear || bDoStencilClear) && NULL != pZPixFmt)
    {
        DWORD   dwZbufferClearValue=0;
        DWORD   dwZbufferClearMask=0;
        DDASSERT(pZPixFmt->dwZBufferBitDepth<=32);
        DDASSERT(pZPixFmt->dwStencilBitDepth<32);
        DDASSERT(pZPixFmt->dwZBitMask!=0x0);
        DDASSERT((0xFFFFFFFF == (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)) |
            ((DWORD)((1<<pZPixFmt->dwZBufferBitDepth)-1) == (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)));
        DDASSERT(0==(pZPixFmt->dwZBitMask & pZPixFmt->dwStencilBitMask));
        if(bDoZClear)
        {
            dwZbufferClearMask = pZPixFmt->dwZBitMask;
            // special case the common cases
            if(dvZ==1.0)
            {
                dwZbufferClearValue=pZPixFmt->dwZBitMask;
            }
            else if(dvZ > 0.0)
            {
                dwZbufferClearValue=((DWORD)((dvZ*(pZPixFmt->dwZBitMask >> zmask_shift))+0.5)) << zmask_shift;
            }
        }
        if(bDoStencilClear)
        {
            DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
            DDASSERT(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);
            dwZbufferClearMask |= pZPixFmt->dwStencilBitMask;
            // special case the common case
            if(dwStencil!=0)
            {
                dwZbufferClearValue |=(dwStencil << stencilmask_shift) & pZPixFmt->dwStencilBitMask;
            }
        }
        if (dwZbufferClearMask == (pZPixFmt->dwStencilBitMask | pZPixFmt->dwZBitMask))
        {
            // do Stencil & Z Blt together, using regular DepthFill blt which will be faster
            // than the writemask blt because its write-only, instead of read-modify-write
            dwZbufferClearMask = 0;
        }
        BltFillZRects(this, dwZbufferClearValue, clrCount, clrRects, dwZbufferClearMask);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\genlight.h ===
#ifndef __GENLIGHT_H__
#define __GENLIGHT_H__

typedef struct _SpecularTable 
{
    LIST_MEMBER(_SpecularTable) list;
    float          power;          /* shininess power */
    unsigned char   table[260]; /* space for overflows */
} SpecularTable;

void RLDDI_DoLights(D3DVALUE ar, D3DVALUE ag, D3DVALUE ab, int count,
                    D3DLIGHTINGELEMENT* elements, size_t in_size,
                    unsigned long *out, size_t out_size, int lightc, 
                    D3DI_LIGHT* lightv, D3DMATERIAL* mat, D3DVALUE gain, 
                    SpecularTable* tab);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\tlhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlhal.h
 *  Content:    Support code for HALs with hardware transform & light
 *
 ***************************************************************************/
#ifndef _TLHAL_H_
#define _TLHAL_H_

#include "drawprim.hpp"
//---------------------------------------------------------------------
// DirectX7 device
//
class CDirect3DDevice7 : public CDirect3DDeviceIDP2
{
public: 
    CDirect3DDevice7() { deviceType = D3DDEVTYPE_DX7HAL; m_tssMax = D3DTSS_MAX;}
    ~CDirect3DDevice7() { CleanupTextures(); }
    HRESULT TexBltI(LPDDRAWI_DDRAWSURFACE_LCL lpDst,
                    LPDDRAWI_DDRAWSURFACE_LCL lpSrc,
                    LPPOINT p, RECTL *r, DWORD dwFlags);
    HRESULT SetPriorityI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwPriority);
    HRESULT SetTexLODI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwLOD);
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                         IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    void WriteStateSetToDevice(D3DSTATEBLOCKTYPE);
    HRESULT UpdatePalette(DWORD,DWORD,DWORD,LPPALETTEENTRY);
    HRESULT SetPalette(DWORD,DWORD,DWORD);
    HRESULT UpdateTextures();
    HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI, D3DTEXTUREHANDLE *hTex);
    void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    void SetRenderTargetINoFlush(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    bool CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl, 
                     LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl);
    void ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
};
//---------------------------------------------------------------------
// Device, that supports hardware Transformation and Lighting
//
class CDirect3DDeviceTL : public CDirect3DDevice7
{
public: 
    CDirect3DDeviceTL();
    ~CDirect3DDeviceTL() { CleanupTextures(); }

    void LightEnableI(DWORD dwLightIndex, BOOL bEnable);

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                         IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData);
    void SetTransformI(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT SetupFVFData(DWORD *pdwInpVertexSize);
protected:
    HRESULT ProcessPrimitive(__PROCPRIMOP op);
    void LightChanged(DWORD dwLightIndex);
    void MaterialChanged();
    void SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
};

#endif /* _TLHAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *  $Id:
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

#include "ddrawp.h"
#include "d3dp.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "object.h"
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>

#include <d3dfe.hpp>

// Allow vtable hacking
#define VTABLE_HACK

// DEBUG_PIPELINE is defined to check performance and to allow to choose
// diifferent paths in the geometry pipeline

#if DBG
#define DEBUG_PIPELINE
#endif // DBG

#ifndef WIN95
// This is NT only
// Comment this out to disable registry based VidMemVB enables
#define __DISABLE_VIDMEM_VBS__
#endif

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
const DWORD __MAX_VERTEX_SIZE = 180;    // Max size of FVF vertex in bytes
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#define STATS_FONT_FACE "Terminal"
#define STATS_FONT_SIZE 9

#if COLLECTSTATS
DWORD BytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect);
#endif

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Intel Willamette CPU
#define D3DCPU_WLMT         0x000000040L

#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

#if !defined(BUILD_DDDDK)

class DIRECT3DDEVICEI;
class CStateSets;

typedef class DIRECT3DI *LPDIRECT3DI;
typedef class DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef class DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef class CDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFERI;

class CDirect3DUnk : public IUnknown
{
public:
    unsigned refCnt;    /* Reference count object */
public:
    LPDIRECT3DI pD3DI;
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

class DIRECT3DI :  public IDirect3D7,
                   public CD3DAlloc
{
public: //Private Data

    /*** Object Relations ***/

    /* Devices */
    int             numDevs;/* Number of devices */
    struct _devices { DIRECT3DDEVICEI* Root;} devices;
    /* Associated IDirect3DDevices */

    /* Vertex Buffers */
    int             numVBufs; /* Number of vertex buffers */
    LIST_ROOT(_vbufs, CDirect3DVertexBuffer) vbufs;
    /* Created IDirect3DVertexBuffers */

    /* Textures */
    LIST_ROOT(_textures, DIRECT3DTEXTUREI) textures;

    /*** Object Data ***/

    CDirect3DUnk mD3DUnk;

    //RLDDIRegistry*      lpReg;  /* Registry */
    struct _D3DBUCKET  *lpFreeList; /* Free linked list  */
    struct _D3DBUCKET  *lpBufferList;/* link list of headers of big chunks allocated*/
    class TextureCacheManager   *lpTextureManager;
    /*
     * DirectDraw Interface
     */
    LPDIRECTDRAW lpDD;
    LPDIRECTDRAW7 lpDD7;    /* needed for CreateSurface to get LPDIRECTDRAWSURFACE7 */

    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.   But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)
    // More disgusting still: These need to be large enough to hold ddrawex interface structs

    DDRAWI_DIRECTDRAW_INT DDInt_DD1;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

#if COLLECTSTATS
    // For displaying stats
    HFONT m_hFont;

    // Various counters for stats
    DWORD m_setpris, m_setLODs, m_texCreates, m_texDestroys;
#endif

#ifdef __DISABLE_VIDMEM_VBS__
    BOOL bDisableVidMemVBs;
#endif //__DISABLE_VIDMEM_VBS__

public: //Private methods
    DIRECT3DI(); // Constructor called Direct3DCreate()
    ~DIRECT3DI(); // Destructor called by CDirect3DUnk::Release()
    HRESULT Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt);
    HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK7, LPVOID, DWORD, DWORD);
    // Internal CreateVertexBuffer
    HRESULT CreateVertexBufferI(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER7*, DWORD);
    // Device flushing
    HRESULT FlushDevicesExcept(LPDIRECT3DDEVICEI pDev);
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK7, LPVOID);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE7, LPDIRECT3DDEVICE7*);
    HRESULT D3DAPI CreateVertexBuffer(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER7*, DWORD);
    HRESULT D3DAPI EnumZBufferFormats(REFCLSID, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI EvictManagedTextures();

#if COLLECTSTATS
    // Stats collection funcs
    void ResetTexStats();
    void GetTexStats(LPD3DDEVINFO_TEXTURING);
    void IncNumSetPris()
    {
        ++m_setpris;
    }
    void IncNumSetLODs()
    {
        ++m_setLODs;
    }
    void IncNumTexCreates()
    {
        ++m_texCreates;
    }
    void IncNumTexDestroys()
    {
        ++m_texDestroys;
    }
    DWORD GetNumSetPris()
    {
        return m_setpris;
    }
    DWORD GetNumSetLODs()
    {
        return m_setLODs;
    }
    DWORD GetNumTexCreates()
    {
        return m_texCreates;
    }
    DWORD GetNumTexDestroys()
    {
        return m_texDestroys;
    }
    DWORD GetNumTexLocks()
    {
        return ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexLocks;
    }
    DWORD GetNumTexGetDCs()
    {
        return ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexGetDCs;
    }
#endif
};

typedef DIRECT3DI* LPDIRECT3DI;

#include "d3dhal.h"
#include "halprov.h"

//---------------------------------------------------------------------
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7,
                                         LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);

typedef struct _D3DBUCKET
{
    struct _D3DBUCKET *next;
    union
    {
    LPVOID  lpD3DDevI;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPVOID  lpBuffer;
    LPDIRECT3DTEXTUREI lpD3DTexI;
    };
    union
    {
    HRESULT (__cdecl *pfnFlushStates)(LPVOID);
    unsigned int ticks;
    };
    LPDIRECTDRAWSURFACE *lplpDDSZBuffer;    //if not NULL, points to lpDDSZBuffer in Direct3DDeviceI
} D3DBUCKET,*LPD3DBUCKET;

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) list;
    /* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) devList;
    /* Next block in IDirect3DDevice */

    LPDIRECT3DDEVICEI           lpDevI;

    /*  this texture block refers to either an
     * IDirect3DTexture/IDirect3DTexture2, so one of these pointers will
     * always be NULL
     */
    LPDIRECT3DTEXTUREI          lpD3DTextureI;
    /* pointer to internal struct for IDirect3DTexture/IDirect3DTexture2 */

    D3DTEXTUREHANDLE            hTex;
    /* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   pfnDirectional;
    LIGHT_VERTEX_FUNC   pfnPointSpot;
// Used in multi-loop pipeline
    PFN_LIGHTLOOP       pfnDirectionalFirst;
    PFN_LIGHTLOOP       pfnDirectionalNext;
    PFN_LIGHTLOOP       pfnPointSpotFirst;
    PFN_LIGHTLOOP       pfnPointSpotNext;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
class DIRECT3DLIGHTI : public CD3DAlloc
{
public:
    DIRECT3DLIGHTI() {m_LightI.flags = 0;}   // VALID bit is not set
    HRESULT SetInternalData();
    BOOL Enabled() {return (m_LightI.flags & D3DLIGHTI_ENABLED);}
    BOOL Valid()   {return (m_LightI.flags & D3DLIGHTI_VALID);}

    LIST_MEMBER(DIRECT3DLIGHTI) m_List;     // Active light list member
    D3DLIGHT7   m_Light;
    D3DI_LIGHT  m_LightI;
};
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in DIRECT3DDEVICEI)
//
const DWORD D3DFE_WORLDMATRIX_DIRTY         = 1 << 0;   // World matrix dirty bits
const DWORD D3DFE_WORLDMATRIX1_DIRTY        = 1 << 1;   // must be sequential !!!
const DWORD D3DFE_WORLDMATRIX2_DIRTY        = 1 << 2;
const DWORD D3DFE_WORLDMATRIX3_DIRTY        = 1 << 3;
const DWORD D3DFE_TLVERTEX                  = 1 << 5;
const DWORD D3DFE_REALHAL                   = 1 << 6;
const DWORD D3DFE_PROJMATRIX_DIRTY          = 1 << 8;
const DWORD D3DFE_VIEWMATRIX_DIRTY          = 1 << 9;
// Set when we need to check world-view matrix for orthogonality
const DWORD D3DFE_NEEDCHECKWORLDVIEWVMATRIX = 1 << 10;
// Set when some state has been changed and we have to go through the slow path
// Currently the bit is set when one of the following bits is set:
//     D3DFE_PROJMATRIX_DIRTY 
//     D3DFE_VIEWMATRIX_DIRTY 
//     D3DFE_WORLDMATRIX_DIRTY 
//     D3DFE_WORLDMATRIX1_DIRTY 
//     D3DFE_WORLDMATRIX2_DIRTY 
//     D3DFE_WORLDMATRIX3_DIRTY 
//     D3DFE_VERTEXBLEND_DIRTY
//     D3DFE_LIGHTS_DIRTY 
//     D3DFE_MATERIAL_DIRTY 
//     D3DFE_FVF_DIRTY 
//     D3DFE_CLIPPLANES_DIRTY
const DWORD D3DFE_FRONTEND_DIRTY            = 1 << 11;
// We are in recording state set mode
const DWORD D3DFE_RECORDSTATEMODE           = 1 << 12;
// We are in execution state set mode
// In this mode the front-and executes recorded states but does not pass
// them to the driver (the states will be passed using a set state handle)
const DWORD D3DFE_EXECUTESTATEMODE          = 1 << 13;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS     = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY            = 1 << 15;
const DWORD D3DFE_CLIPPLANES_DIRTY          = 1 << 16;
const DWORD D3DFE_LIGHTS_DIRTY              = 1 << 18;
// This bit is set when vertex blending state is dirty
const DWORD D3DFE_VERTEXBLEND_DIRTY         = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY       = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY     = 1 << 21;
const DWORD D3DFE_FVF_DIRTY                 = 1 << 22;
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DFE_NEED_TEXTURE_UPDATE       = 1 << 23;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS             = 1 << 24;
const DWORD D3DFE_INVWORLDVIEWMATRIX_DIRTY  = 1 << 25;

//
const DWORD D3DFE_LOSTSURFACES              = 1 << 27;
// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES          = 1 << 28;
// Clip matrix is used to transform user clipping planes
// to the clipping space
const DWORD D3DFE_CLIPMATRIX_DIRTY          = 1 << 29;
// HAL supports Transformation and Lighting
const DWORD D3DFE_TLHAL                     = 1 << 30;
// HAL supports state sets
const DWORD D3DFE_STATESETS                 = 1 << 31;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX1_DIRTY |
                                    D3DFE_WORLDMATRIX2_DIRTY |
                                    D3DFE_WORLDMATRIX3_DIRTY |
                                    D3DFE_VERTEXBLEND_DIRTY;

const DWORD D3DDEVBOOL_HINTFLAGS_INSCENE       = 1 << 0; // Are we in a scene?
const DWORD D3DDEVBOOL_HINTFLAGS_MULTITHREADED = 1 << 1; // multithreaded device
const DWORD D3DDEVBOOL_HINTFLAGS_FPUSETUP      = 1 << 3; // Means the FPU is already in preferred state.

//---------------------------------------------------------------------
//
// Bits for dwDebugFlags
//
// Set if DisableFVF key is not 0 in registry and driver supports FVF
const DWORD D3DDEBUG_DISABLEFVF = 1 << 0;
#ifdef WIN95
// Disable Draw Primitive DDI
const DWORD D3DDEBUG_DISABLEDP  = 1 << 1;
// Disable Draw Primitive 2 DDI
const DWORD D3DDEBUG_DISABLEDP2 = 1 << 2;
#endif // WIN95

#ifdef  WIN95
#define _D3D_FORCEDOUBLE    1
#else   //WIN95
#define _D3D_FORCEDOUBLE    0
#endif  //WIN95
#if _D3D_FORCEDOUBLE
// Set if ForceDouble key is not 0 in the registry and driver is pre-DX6 REALHAL
const DWORD D3DDEBUG_FORCEDOUBLE= 1 << 2;
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

// Frastum plane equations are valid
const DWORD D3DTRANS_VALIDFRUSTUM   = 1 << 2;
//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    D3DMATRIXI  proj;
    D3DMATRIXI  view;
    D3DMATRIXI  world[4];   // Up to 4 world matrix
    D3DMATRIXI  mPC;        // Mproj * Mclip
    D3DMATRIXI  mVPC;       // Mview * PC
    D3DMATRIXI  mVPCI;      // Inverse Mview * PC, used to transform clipping planes
    D3DMATRIXI  mCTMI;      // Inverse current transformation matrix
    D3DVECTORH  frustum[6]; // Normalized plane equations for viewing frustum
                                // in the model space
    D3DVECTORH  userClipPlane[D3DMAXUSERCLIPPLANES];

    DWORD       dwMaxUserClipPlanes;    // Number provided by the driver
    DWORD       dwFlags;
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPDIRECT3DDEVICEI lpD3DDevI);

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef enum {
    D3DDEVTYPE_OLDHAL = 1,
    D3DDEVTYPE_DPHAL,
    D3DDEVTYPE_DP2HAL,          // DX6 HAL
    D3DDEVTYPE_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    D3DDEVTYPE_DX7TLHAL
} D3DDEVICETYPE;
//---------------------------------------------------------------------
typedef HRESULT (DIRECT3DDEVICEI::*PFN_DRAWPRIM)();

//---------------------------------------------------------------------
// This type is used to define operation for ProcessPrimitive
//
typedef enum
{
    __PROCPRIMOP_INDEXEDPRIM,       // Process indexed primitive
    __PROCPRIMOP_NONINDEXEDPRIM,    // Process non-indexed primitive
} __PROCPRIMOP;
//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

// We modify the compiler generated VTable for DIRECT3DDEVICEI object. To make
// life easy, all virtual functions are defined in DIRECT3DDEVICEI. Also since
// DEVICEI has multiple inheritance, there are more than 1 VTable.
// Currently we assume that it only inherits from IDirect3DDevice7 and
// D3DFE_PROCESSVERTICES and, in that order! Thus IDirect3DDevice7 and
// DIRECT3DDEVICEI share the same vtable. This is the VTable we copy and
// modify. The define below is the total entries in this vtable. It is the
// sum of the methods in IDirect3DDevice7 (incl. IUnknown) (49) and all the
// virtual methods in DIRECT3DDEVICEI ()
#define D3D_NUM_API_FUNCTIONS (49)
#define D3D_NUM_VIRTUAL_FUNCTIONS (D3D_NUM_API_FUNCTIONS+38)

// These constants are based on the assumption that rsVec array is an array
// of 32-bit intergers
const D3D_RSVEC_SHIFT = 5; // log2(sizeof(DWORD)*8);
const D3D_RSVEC_MASK = sizeof(DWORD) * 8 - 1;

class DIRECT3DDEVICEI : public IDirect3DDevice7,
                        public CD3DAlloc,
                        public D3DFE_PROCESSVERTICES
{
public: // Private Data

    ULONGLONG           m_qwBatch; // current batch number

    DWORD               dwHintFlags;
    // Pointer to the PV funcs that we need to call
    LPD3DFE_PVFUNCS     pGeometryFuncs;
    // buffer for H vertices
    CAlignedBuffer32    HVbuf;              // Used for clip flags

// Should be cache line aligned. Now it is not
    D3DDEVICETYPE       deviceType;         // Device Type

    /*** Object Relations ***/
    LPDIRECT3DI         lpDirect3DI;        // parent
    LIST_MEMBER(DIRECT3DDEVICEI)list;       // Next device IDirect3D

    /* Textures */
    LIST_ROOT(_dmtextures, _D3DI_TEXTUREBLOCK) texBlocks;
    /* Ref to created IDirect3DTextures */

    /* Viewports */
    D3DVIEWPORT7    m_Viewport;
    DWORD           clrCount;   // Number of rects allocated
    LPD3DRECT       clrRects;   // Rects used for clearing

    /* Reference count object */
    unsigned refCnt;

    // for DX3-style devices aggregated onto ddraw, guid should be IID_IDirect3DRGBDevice,
    // IID_IDirect3DHALDevice, etc.  for DX5 and beyond, guid is IID_IDirect3DDevice,
    // IID_IDirect3DDevice2, etc
    GUID        guid;

    LPD3DHAL_CALLBACKS      lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA   lpD3DHALGlobalDriverData; /* HW specific */
    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2;    /* HW specific */
    LPD3DHAL_CALLBACKS3         lpD3DHALCallbacks3; /* DX6 DDI */

    /* DirectDraw objects that we are holding references to */

    LPDIRECTDRAW lpDD;    // DirectDraw object
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    //
    LPDIRECTDRAWSURFACE lpDDSTarget;    // Render target
    LPDIRECTDRAWSURFACE lpDDSZBuffer;   // Z buffer
    LPDIRECTDRAWPALETTE lpDDPalTarget;  // Palette for render target (if any)

    // these are saved for use by new GetRenderTarget and anything else that requires DDS4 functionality
    LPDIRECTDRAWSURFACE7 lpDDSTarget_DDS7;
    LPDIRECTDRAWSURFACE7 lpDDSZBuffer_DDS7;

    // Front end data
    D3DFE_TRANSFORM     transform;      // Transformation state
    int                 iClipStatus;    // Clipping status
    DWORD               dwhContext;     // Driver context

// RenderTarget/ZBuf bit depth info used by Clear to Blt
     DWORD              red_mask;
     DWORD              red_scale;
     DWORD              red_shift;
     DWORD              green_mask;
     DWORD              green_scale;
     DWORD              green_shift;
     DWORD              blue_mask;
     DWORD              blue_scale;
     DWORD              blue_shift;
     DWORD              alpha_mask;
     DWORD              alpha_scale;
     DWORD              alpha_shift;
     DWORD              zmask_shift,stencilmask_shift;
     BOOL               bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget

// Pipeline state info
    DWORD               dwDebugFlags;       // See debug bits above

#ifndef WIN95
    DWORD_PTR           hSurfaceTarget;
#else
    DWORD               hSurfaceTarget;
#endif

#ifdef TRACK_HAL_CALLS
    DWORD hal_calls;
#endif

    //--------------- Lights start -----------------------
    DIRECT3DLIGHTI      *m_pLights;         // Growable light array
    DWORD               m_dwNumLights;      // Size of m_Lights array
    LIST_ROOT(_dlights, DIRECT3DLIGHTI) m_ActiveLights;

    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;
    //--------------- Lights end -----------------------

    /* Provider backing this driver */
    IHalProvider*       pHalProv;
    HINSTANCE           hDllProv;

    /* Device description */
    D3DDEVICEDESC7   d3dDevDesc;

    /*
     *  Pointer to texture objects for currently installed textures.  NULL indicates
     *  that the texture is either not set (rstate NULL) or that the handle to tex3 pointer
     *  mapping is not done.  This mapping is expensive, so it is deferred until needed.
     *
     *  This is needed for finding the WRAPU,V mode for texture index clipping (since
     *  the WRAPU,V state is part of the device).
     */
    LPDIRECT3DTEXTUREI          lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    LPD3DI_TEXTUREBLOCK         lpD3DMappedBlock[D3DHAL_TSS_MAXSTAGES];
    DWORD                       dwMaxTextureBlendStages; // Max number of blend stages supported by a driver
    DWORD                       m_dwStageDirty;
    LPDIRECTDRAWCLIPPER         lpClipper;

    /*
     * DrawPrimitives batching
     */


    // Buffer to put DrawPrimitives stuff into
    // Used for both legacy and DrawPrimitive HALs
    WORD *lpwDPBuffer;
    WORD *lpwDPBufferAlloced;
#ifndef WIN95
    DWORD dwDPBufferSize;
#endif
    DWORD dwCurrentBatchVID;        // Current FVF type in the batch buffer

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    // Object to record state sets
    CStateSets * m_pStateSets;

    // This is a function provided by sw rasterizers.
    // Currently, its only function is to provide an RGB8 clear color.
    // It should be non-NULL for anything that supports an 8 bit RGB output
    // type.
    PFN_RASTSERVICE pfnRastService;

    //
    // This is function pointer is obtained through the
    // HalProvider interface. For real_hals, it is found in all DX7+
    // drivers in pDdGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState
    // Of the software drivers, only Refrast supports it in its DX7+ mode.
    LPDDHAL_GETDRIVERSTATE pfnGetDriverState;

    // Max TSS that can be passed to the driver
    D3DTEXTURESTAGESTATETYPE m_tssMax;
    // Max RS that can be passed to the driver, used for CanHandleRenderState
    D3DRENDERSTATETYPE m_rsMax;
    // We use 32-bit ints for rsVec. The size if computed using ceil(D3D_MAXRENDERSTATES/32)
    DWORD rsVec[(D3D_MAXRENDERSTATES + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT];
    DWORD rsVecRetired[(D3D_MAXRENDERSTATES + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT];
#if COLLECTSTATS
    D3DDEVINFO_TEXTURING m_texstats;
#endif
#ifdef VTABLE_HACK
    // This points to the original (compiler generated) read-only vtable of DIRECT3DDEVICEI
    PVOID* lpVtbl;
    // The new vtable which is a read/write copy of the original to allow hacking
    PVOID newVtbl[D3D_NUM_VIRTUAL_FUNCTIONS];
#endif // VTABLE_HACK
#ifdef PROFILE4
    DWORD m_dwProfStart, m_dwProfStop;
#endif // PROFILE4
#ifdef PROFILE
    DWORD m_dwProfStart, m_dwProfStop;
#endif // PROFILE
public: // virtual methods
    DIRECT3DDEVICEI();
    virtual ~DIRECT3DDEVICEI(); // 0
    virtual HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice); // 1
    virtual HRESULT FlushStates(bool bWithinPrimitive = false)=0;    // 2 // Use to flush current batch to the driver
    virtual HRESULT FlushStatesReq(DWORD) { return FlushStates(); }; // 3
    virtual HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM)=0; // 4
    virtual HRESULT CheckSurfaces();    // 5 // Check if the surfaces necessary for rendering are lost
    virtual void WriteStateSetToDevice(D3DSTATEBLOCKTYPE) {} // 6
    // Function to download viewport info to the driver
    virtual void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData) {}; // 7
    virtual void UpdateDrvWInfo() {}; // 8
    virtual HRESULT halCreateContext(); // 9
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    virtual HRESULT UpdateDriverStates(); // 10
    virtual HRESULT ValidateFVF(DWORD dwFVF); // 11
    virtual HRESULT SetupFVFData(DWORD *pdwInpVertexSize); // 12

    virtual void LightChanged(DWORD dwLightIndex); // 13
    virtual void MaterialChanged(); // 14
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, LPD3DMATRIX); // 15
    virtual void SetViewportI(LPD3DVIEWPORT7); // 16
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage,
                                                    D3DTEXTURESTAGESTATETYPE dwState,
                                                    DWORD dwValue); // 17
    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE, DWORD); // 18
    virtual void LightEnableI(DWORD dwLightIndex, BOOL); // 19
    virtual HRESULT UpdateTextures(); // 20
    virtual void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE); // 21
    virtual bool CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl); // 22
    virtual void ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil); // 23
#ifdef VTABLE_HACK
    virtual HRESULT D3DAPI DrawPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD) // 24
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD) // 25
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD) // 26
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD) // 27
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD) // 28
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD) // 29
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD) // 30
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD) // 31
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
#endif
    virtual void SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation); // 32
    virtual HRESULT D3DAPI SetTextureInternal(DWORD, LPDIRECTDRAWSURFACE7); // 33
    virtual HRESULT D3DAPI ApplyStateBlockInternal(DWORD); // 34
    virtual HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD) = 0; // 35
    virtual HRESULT D3DAPI PreLoadFast(LPDIRECTDRAWSURFACE7); // 36
public: // non virtual methods
    BOOL UpdateInternalTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD dwValue);
    HRESULT stateInitialize(BOOL bZEnable);
    HRESULT checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid);
    HRESULT HookToD3D(LPDIRECT3DI lpD3DI);
    HRESULT UnhookFromD3D();
    HRESULT SetupFVFDataCommon(DWORD *pdwInpVertexSize);
    void CleanupTextures();
    BOOL NeedInternalTSSUpdate(DWORD dwState)
    {
        return dwState == D3DTSS_TEXCOORDINDEX || dwState >= D3DTSS_TEXTURETRANSFORMFLAGS ||
               dwState == D3DTSS_COLOROP;
    }
    // Always use this function to update "rstates", because we have to
    // set some internal flags when "rstats" is changed.
    void UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value);
    // Checks for 'retired' render state - returns TRUE if not retired
    BOOL CheckForRetiredRenderState(D3DRENDERSTATETYPE type)
    {
        if (!(rsVecRetired[type >> D3D_RSVEC_SHIFT] & (1ul << (type & D3D_RSVEC_MASK))))
        {
            // not retired
            return TRUE;
        }
        return FALSE;
    }
    // Checks if we can pass the render state to the driver
    BOOL CanHandleRenderState(D3DRENDERSTATETYPE type)
    {
        if (type >= m_rsMax)
        {
            // not an error condition because we don't send front-end stuff to
            // non-TL Hal devices, for example, but don't send to HAL anyway
            return FALSE;
        }
        return TRUE;
    };

    // Update internal state
    void SetMaterialI(LPD3DMATERIAL7);
    void SetLightI(DWORD dwLightIndex, LPD3DLIGHT7);
    inline void SetFogFlags(void);
    void ForceFVFRecompute(void) { dwVIDIn = 0; dwFEFlags |= D3DFE_FVF_DIRTY | D3DFE_FRONTEND_DIRTY; };
    HRESULT CopySurface(LPDIRECTDRAWSURFACE7 lpDDSDst, LPRECT lpDestRect,
                        LPDIRECTDRAWSURFACE7 lpDDSSrc, LPRECT lpSrcRect,
                        DWORD dwFlags);
    HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                                LPD3DI_TEXTUREBLOCK* lplpBlock);
    LPD3DI_TEXTUREBLOCK HookTexture(LPDIRECT3DTEXTUREI lpD3DText);
    LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex);
    void BatchTexture(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
    {
        if(m_qwBatch > lpLcl->lpSurfMore->qwBatch.QuadPart)
            lpLcl->lpSurfMore->qwBatch.QuadPart = m_qwBatch;
    }
    HRESULT VerifyTextureCaps(LPDIRECT3DTEXTUREI lpTexI);
    HRESULT CheckDrawPrimitiveVB(LPDIRECT3DVERTEXBUFFER7 lpVBuf, DWORD dwStartVertex, DWORD dwNumVertices, DWORD dwFlags);
    void DisplayStats();
    void CheckClipStatus(D3DVALUE * pPositions, DWORD dwStride, DWORD dwNumVertices,
                         DWORD *pdwClipUnion, DWORD *pdwClipIntersection);
    HRESULT VerifyTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex);
    HRESULT SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);
    BOOL GetInfoInternal(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
#if COLLECTSTATS
    void ResetTexStats();
    void GetTexStats(LPD3DDEVINFO_TEXTURING);
    void IncNumLoads()
    {
        ++m_texstats.dwNumLoads;
    }
    void IncNumTexturesSet()
    {
        ++m_texstats.dwNumSet;
    }
    void IncNumPreLoads()
    {
        ++m_texstats.dwNumPreLoads;
    }
    void IncBytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
    {
        m_texstats.dwApproxBytesLoaded += BytesDownloaded(lpLcl, lpRect);
    }
#endif
#ifdef VTABLE_HACK
    void VtblPreLoadFast()
    {
        // DIRECT3DDEVICEI::PreLoadFast
        newVtbl[24] = lpVtbl[D3D_NUM_API_FUNCTIONS+36];
    }
    void VtblApplyStateBlockRecord()
    {
        // IDirect3DDevice7::ApplyStateBlock
        newVtbl[39] = lpVtbl[39];
    }
    void VtblApplyStateBlockExecute()
    {
        // IDirect3DDevice7::ApplyStateBlockInternal
        newVtbl[39] = lpVtbl[D3D_NUM_API_FUNCTIONS+34];
    }
    void VtblSetTextureRecord()
    {
        // IDirect3DDevice7::SetTexture
        newVtbl[35] = lpVtbl[35];
    }
    void VtblSetTextureExecute()
    {
        // IDirect3DDevice7::SetTextureInternal
        newVtbl[35] = lpVtbl[D3D_NUM_API_FUNCTIONS+33];
    }
    void VtblSetTextureStageStateRecord()
    {
        // IDirect3DDevice7::SetTextureStageState
        newVtbl[37] = lpVtbl[37];
    }
    void VtblSetTextureStageStateExecute()
    {
        // IDirect3DDevice7::SetTextureStageStateI
        newVtbl[37] = lpVtbl[D3D_NUM_API_FUNCTIONS+17];
    }
    void VtblSetRenderStateRecord()
    {
        // IDirect3DDevice7::SetRenderState
        newVtbl[20] = lpVtbl[20];
    }
    void VtblSetRenderStateExecute()
    {
        // DIRECT3DDEVICEI::SetRenderStateFast
        newVtbl[20] = lpVtbl[D3D_NUM_API_FUNCTIONS+18];
    }
    void VtblDrawPrimitiveDefault()
    {
        // IDirect3DDevice7::DrawPrimitive
        newVtbl[25] = lpVtbl[25];
    }
    void VtblDrawPrimitiveTL()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveTL
        newVtbl[25] = lpVtbl[D3D_NUM_API_FUNCTIONS+24];
    }
    void VtblDrawPrimitiveVBDefault()
    {
        // IDirect3DDevice7::DrawPrimitiveVB
        newVtbl[31] = lpVtbl[31];
    }
    void VtblDrawPrimitiveVBTL()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveVBTL
        newVtbl[31] = lpVtbl[D3D_NUM_API_FUNCTIONS+25];
    }
    void VtblDrawIndexedPrimitiveDefault()
    {
        // IDirect3DDevice7::DrawIndexedPrimitive
        newVtbl[26] = lpVtbl[26];
    }
    void VtblDrawIndexedPrimitiveTL()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveTL
        newVtbl[26] = lpVtbl[D3D_NUM_API_FUNCTIONS+26];
    }
    void VtblDrawIndexedPrimitiveVBDefault()
    {
        // IDirect3DDevice7::DrawIndexedPrimitiveVB
        newVtbl[32] = lpVtbl[32];
    }
    void VtblDrawIndexedPrimitiveVBTL()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveVBTL
        newVtbl[32] = lpVtbl[D3D_NUM_API_FUNCTIONS+27];
    }
    void VtblDrawPrimitiveFE()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveFE
        newVtbl[25] = lpVtbl[D3D_NUM_API_FUNCTIONS+28];
    }
    void VtblDrawIndexedPrimitiveFE()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveFE
        newVtbl[26] = lpVtbl[D3D_NUM_API_FUNCTIONS+29];
    }
    void VtblDrawPrimitiveVBFE()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveFE
        newVtbl[31] = lpVtbl[D3D_NUM_API_FUNCTIONS+30];
    }
    void VtblDrawIndexedPrimitiveVBFE()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveFE
        newVtbl[32] = lpVtbl[D3D_NUM_API_FUNCTIONS+31];
    }
#endif

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DDevice7 Methods
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC7);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI BeginScene();
    HRESULT D3DAPI EndScene();
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D7*);
    HRESULT D3DAPI Clear(DWORD, LPD3DRECT, DWORD, D3DCOLOR, D3DVALUE, DWORD);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE7, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE7 *);
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI SetViewport(LPD3DVIEWPORT7);
    HRESULT D3DAPI GetViewport(LPD3DVIEWPORT7);
    HRESULT D3DAPI SetMaterial(LPD3DMATERIAL7);
    HRESULT D3DAPI GetMaterial(LPD3DMATERIAL7);
    HRESULT D3DAPI SetLight(DWORD, LPD3DLIGHT7);
    HRESULT D3DAPI GetLight(DWORD, LPD3DLIGHT7);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI SetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI GetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI DrawPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI ComputeSphereVisibility(LPD3DVECTOR, LPD3DVALUE, DWORD, DWORD, LPDWORD);
    HRESULT D3DAPI GetTexture(DWORD, LPDIRECTDRAWSURFACE7 *);
    HRESULT D3DAPI SetTexture(DWORD, LPDIRECTDRAWSURFACE7);
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD);
    HRESULT D3DAPI DuplicateStateBlock(DWORD InHandle, LPDWORD OutHandle);
    HRESULT D3DAPI OverlayStateBlock(DWORD Handle);
    HRESULT D3DAPI BeginStateBlock();
    HRESULT D3DAPI EndStateBlock(LPDWORD);
    HRESULT D3DAPI DeleteStateBlock(DWORD);
    HRESULT D3DAPI ApplyStateBlock(DWORD);
    HRESULT D3DAPI CaptureStateBlock(DWORD Handle);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses) = 0;
    HRESULT D3DAPI Load(LPDIRECTDRAWSURFACE7 lpDest, LPPOINT lpDestPoint,
                        LPDIRECTDRAWSURFACE7 lpSrc, LPRECT lpSrcRect,
                        DWORD dwFlags);
    HRESULT D3DAPI LightEnable(DWORD dwLightIndex, BOOL);
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);
    HRESULT D3DAPI PreLoad(LPDIRECTDRAWSURFACE7 lpTex);
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
    HRESULT D3DAPI SetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle);
};

// There is only DP2 HAL on NT
#ifdef WIN95

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;


class CDirect3DDeviceIHW : public DIRECT3DDEVICEI
{
private: // Data
    /* Legacy HALs */

    // Buffer of counts structures that keep track of the
    // number of render states and vertices buffered
    LPD3DI_HWCOUNTS lpHWCounts;

    // Buffer of triangle structures.
    LPD3DTRIANGLE lpHWTris;

    // Byte offset into lpHWVertices. This gets incremented
    // by 8 when a render state is batched and by 32*dwNumVertices
    // when a primitive is batched.
    DWORD dwHWOffset;

    // Max value of dwHWOffset. Used to decide whether to flush.
    DWORD dwHWMaxOffset;

    // Index into lpHWTris.
    DWORD dwHWTriIndex;

    // Number of counts structures used so far. This actually
    // gives the number of primitives batched and the index of
    // the counts structure to batch render states into.
    DWORD dwHWNumCounts;

    WORD *wTriIndex;

    HRESULT DrawIndexedPrimitiveInBatchesHW(D3DPRIMITIVETYPE PrimitiveType,
                                            D3DVERTEXTYPE VertexType,
                                            LPD3DTLVERTEX lpVertices,
                                            DWORD dwNumPrimitives,
                                            LPWORD lpwIndices);
protected:
    CBufferDDS TLVbuf;
public:
    CDirect3DDeviceIHW() { deviceType = D3DDEVTYPE_OLDHAL; }
    ~CDirect3DDeviceIHW(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim() {return DrawPrim();}
    HRESULT FlushStates(bool bWithinPrimitive = false);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    HRESULT MapTSSToRS();

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    HRESULT MapFVFtoTLVertex(LPVOID lpAddress);
    HRESULT MapFVFtoTLVertexIndexed();
};

class CDirect3DDeviceIDP : public CDirect3DDeviceIHW
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX5 DrawPrimitive HAL drivers
       should go here */
    /* DrawPrimitive-aware HALs */

    // pointer to current prim counts struct
    LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

    // Byte offset into buffer (we are currently
    // using the device's wTriIndex)
    DWORD dwDPOffset;

    // Maximum offset. If dwDPOffset exceeds this, it is
    // time to flush.
    DWORD dwDPMaxOffset;

public:
    CDirect3DDeviceIDP() { deviceType = D3DDEVTYPE_DPHAL; }
    ~CDirect3DDeviceIDP() { CleanupTextures(); }
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim() {return DrawPrim();}
    HRESULT FlushStates(bool bWithinPrimitive = false);

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT halCreateContext();
};

#define IS_DPHAL_DEVICE(lpDevI) ((lpDevI)->deviceType == D3DDEVTYPE_DPHAL)

#endif // WIN95

// Flags passed by the runtime to the DDI batching code via PV structure
// to enable new DDI batching to be done efficiently. These flags are
// marked as reserved in d3dfe.hpp
const DWORD D3DPV_WITHINPRIMITIVE = D3DPV_RESERVED1; // This flags that the flush has occured
                                                     // within an primitive. This indicates
                                                     // that we should not flush the vertex buffer

// If the vertices are in user memory
const DWORD D3DPV_USERMEMVERTICES = D3DPV_RESERVED3;
//---------------------------------------------------------------------
class CDirect3DDeviceIDP2 : public DIRECT3DDEVICEI
{
public: // data
    static const DWORD dwD3DDefaultCommandBatchSize;

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CDirect3DVertexBuffer* lpDP2CurrBatchVBI;
    DWORD TLVbuf_size;
    DWORD TLVbuf_base;
#ifdef VTABLE_HACK
    // Cached dwFlags for fast path
    DWORD dwLastFlags;
    // Last VB used in a call that involved D3D's FE.
    CDirect3DVertexBuffer* lpDP2LastVBI;
#endif
    DWORD dwDP2CommandBufSize;
    DWORD dwDP2CommandLength;

    // Cache line should start here

    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;


    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    // Perf issue: replace the below 3 fields by a 32 bit D3DHAL_DP2COMMAND struct
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    BYTE bDummy;         // Force DWORD alignment of next member

    D3DHAL_DRAWPRIMITIVES2DATA dp2data;

    // The buffer we currently batch into
    LPDIRECTDRAWSURFACE7 lpDDSCB1;
    LPDIRECT3DVERTEXBUFFER7 allocatedBuf;
    LPVOID alignedBuf;

    // Count read/write <-> write-only transistions
    DWORD dwTLVbufChanges;
    // Flags specific to DP2 device
    DWORD dwDP2Flags;
    // If a mode switch occurs just before a TLVbuf_Grow which requires to create a new
    // VB, then the create will fail. This will leave the device in a state where
    // allocatedBuf is NULL. This is bad since many places in the code we derefence this
    // without checking for NULL. To have a contained fix, we create a small dummy system
    // memory VB at device create and if we ever fail the grow due to mode switch, we assign
    // this VB instead to allocated buf and set the TLVbuf_size to 0.
    LPDIRECT3DVERTEXBUFFER7 pNullVB;

protected: // methods
    inline void ClearBatch(bool);
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize);
#if DBG
    void ValidateVertex(LPDWORD lpdwVertex);
    void ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif
public:
    CDirect3DDeviceIDP2() { deviceType = D3DDEVTYPE_DP2HAL; }

    ~CDirect3DDeviceIDP2(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT FlushStates(bool bWithinPrimitive = false);
    HRESULT FlushStatesReq(DWORD dwReqSize);
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim();
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    // Called from DrawPrimitiveVB if a vertex buffer or TL buffer is used for rendering
    HRESULT StartPrimVB(LPDIRECT3DVERTEXBUFFERI vb, DWORD dwStartVertex);
    // Called if user memory buffer is used for rendering
    HRESULT StartPrimUserMem(LPVOID memory);
    // Called if TL buffer of used memory was used for rendering
    HRESULT EndPrim();

    HRESULT CheckSurfaces();

    void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData);
    void UpdateDrvWInfo();
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    HRESULT UpdateDriverStates();
    HRESULT SetupFVFData(DWORD *pdwInpVertexSize);
    HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    // Returns aligned buffer address
    LPVOID TLVbuf_GetAddress()
    {
        return (LPBYTE)alignedBuf + TLVbuf_base;
    }
    // Returns aligned buffer size
    DWORD TLVbuf_GetSize() { return TLVbuf_size - TLVbuf_base; }
    DWORD& TLVbuf_Base() { return TLVbuf_base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* TLVbuf_GetVBI();
    inline LPDIRECTDRAWSURFACE TLVbuf_GetDDS();
    HRESULT TLVbuf_Grow(DWORD dwSize, bool bWriteOnly);
    // Initializes command header in the DP2 command buffer,
    // reserves space for the comamnd data and returns pointer to the command
    // data
    // Throws an HRESULT exception in case of error
    LPVOID GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize);
    HRESULT D3DAPI DrawPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
};
//  macros to characterize device

#define IS_DP2HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DP2HAL)
#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7HAL)
#define IS_TLHAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7TLHAL)
#define IS_MT_DEVICE(lpDevI) ( (lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_MULTITHREADED )
#define IS_HW_DEVICE(lpDevI) ((lpDevI)->dwFEFlags & D3DFE_REALHAL)
#define IS_FPU_SETUP(lpDevI) ((lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_FPUSETUP )

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
class DIRECT3DTEXTUREI : public CD3DAlloc
{
public:

    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    /* Devices we're associated with */
    /* Next member in texture chain */
    LIST_MEMBER(DIRECT3DTEXTUREI) m_List;

    /*** Object Data ***/
    LPDIRECT3DI             lpDirect3DI;
    DDRAWI_DDRAWSURFACE_INT DDS1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE7    lpDDS;
    LPDIRECTDRAWSURFACE7    lpDDSSys;
    DDSURFACEDESC2          ddsd;
    DWORD                   m_dwBytes;
    DWORD                   m_dwVidBytes;
    DWORD                   m_dwScene;
    DWORD                   m_dwPriority;
    DWORD                   m_dwTicks;
    DWORD                   m_dwHeapIndex;
    DWORD                   m_dwLOD;
    D3DTEXTUREHANDLE        m_hTex;
    BOOL                    m_bInUse;
    BOOL                    bDirty;

    /*
    * The special IUnknown interface for the aggregate that does
    * not punt to the parent object.
    */

public:
    DIRECT3DTEXTUREI();
    virtual HRESULT Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS);
    virtual void Destroy();
    ULONGLONG Cost() const
    {
#ifdef _X86_
        ULONGLONG retval;
        _asm
        {
            mov     ebx, this;
            mov     edx, [ebx]DIRECT3DTEXTUREI.m_bInUse;
            shl     edx, 31;
            mov     eax, [ebx]DIRECT3DTEXTUREI.m_dwPriority;
            mov     ecx, eax;
            shr     eax, 1;
            or      edx, eax;
            mov     DWORD PTR retval + 4, edx;
            shl     ecx, 31;
            mov     eax, [ebx]DIRECT3DTEXTUREI.m_dwTicks;
            shr     eax, 1;
            or      eax, ecx;
            mov     DWORD PTR retval, eax;
        }
        return retval;
#else
        return ((ULONGLONG)m_bInUse << 63) + ((ULONGLONG)m_dwPriority << 31) + ((ULONGLONG)(m_dwTicks >> 1));
#endif
    }
    bool D3DManaged()
    {
        return this->lpDDSSys != NULL;
    }
    bool InVidmem()
    {
        return m_dwHeapIndex != 0;
    }

    void AddRef()
    {
        LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)(D3DManaged() ? this->lpDDSSys : this->lpDDS);
        ++(surf_int->dwIntRefCnt);
        ++(surf_int->lpLcl->dwLocalRefCnt);
        ++(surf_int->lpLcl->lpGbl->dwRefCnt);
    }
    void Release()
    {
        LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)(D3DManaged() ? this->lpDDSSys : this->lpDDS);
        if(surf_int->dwIntRefCnt > 1)  // only do this short way when it's not going away
        {
            --(surf_int->dwIntRefCnt);
            --(surf_int->lpLcl->dwLocalRefCnt);
            --(surf_int->lpLcl->lpGbl->dwRefCnt);
        }
        else
        {
            ((LPDIRECTDRAWSURFACE7)surf_int)->Release();
        }
    }

    virtual HRESULT SetPriority(DWORD dwPriority);
    virtual HRESULT GetPriority(LPDWORD lpdwPriority);
    virtual HRESULT SetLOD(DWORD dwLOD);
    virtual HRESULT GetLOD(LPDWORD lpdwLOD);
};

// DIRECT3DTEXTUREM is used when the texture is desired
// to be driver managed
class DIRECT3DTEXTUREM : public DIRECT3DTEXTUREI
{
public:
    HRESULT SetPriority(DWORD dwPriority);
    HRESULT GetPriority(LPDWORD lpdwPriority);
    HRESULT SetLOD(DWORD dwLOD);
    HRESULT GetLOD(LPDWORD lpdwLOD);
};

// DIRECT3DTEXTUREM is used when the texture is desired
// to be managed by Direct3D
class DIRECT3DTEXTURED3DM : public DIRECT3DTEXTUREM
{
public:
    void Destroy();
    HRESULT Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS);
    void MarkDirtyPointers();
    HRESULT SetPriority(DWORD dwPriority);
    HRESULT SetLOD(DWORD dwLOD);
};

#define D3DVB_NUM_VIRTUAL_FUNCTIONS 10
// Internal VB create flag:
#define D3DVBFLAGS_CREATEMULTIBUFFER    0x80000000L

class CDirect3DVertexBuffer : public IDirect3DVertexBuffer7,
                              public CD3DAlloc
{
private:
    HRESULT CreateMemoryBuffer(LPDIRECT3DI lpD3DI,
                               LPDIRECTDRAWSURFACE7 *lplpSurface7,
                               LPDIRECTDRAWSURFACE  *lplpS,
                               LPVOID *lplpMemory,
                               DWORD dwBufferSize);
#ifdef VTABLE_HACK
    // The new vtable which is a read/write copy of the original to allow hacking
    PVOID newVtbl[D3DVB_NUM_VIRTUAL_FUNCTIONS];
#endif // VTABLE_HACK
    // Internal data
    DWORD dwPVFlags;
    LPDIRECT3DDEVICEI lpDevIBatched; // Is this VB batched in a device ? If so we need to flush the device
                                     // on Lock
    DWORD dwLockCnt;
    /* position.lpData = start of vertex buffer data
     * position.dwStride = Number of bytes per vertex
     */
    union {
        D3DDP_PTRSTRIDE position;
        D3DDP_PTRSTRIDE SOA;
    };
    DWORD dwNumVertices;
    DWORD fvf; // Used in Input and Output
    DWORD dwCaps;
    DWORD dwMemType; // DDSCAPS_VIDEOMEMORY, DDSCAPS2_VERTEXBUFFER
    DWORD srcVOP, dstVOP;
    DWORD nTexCoord;                        // Number of texture coordinates
    DWORD dwTexCoordSize[D3DDP_MAXTEXCOORD];// Size of every texture coordinate set
    DWORD dwTexCoordSizeTotal;              // Total size of all texture coordinates
    int             refCnt; /* Reference count */
    D3DFE_CLIPCODE* clipCodes;
    LPDIRECTDRAWSURFACE7 lpDDSVB; // DDraw Surface containing the actual VB memory
    LPDIRECTDRAWSURFACE lpDDS1VB; // same dds, legacy interface for legacy hal.
    BOOL bReallyOptimized;        // VB could have OPTIMIZED caps set, but be
                                  // not optimized
    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(CDirect3DVertexBuffer)list;  /* Next vertex buffer in IDirect3D */

    // Friends
    friend void hookVertexBufferToD3D(LPDIRECT3DI, LPDIRECT3DVERTEXBUFFERI);
    friend class DIRECT3DDEVICEI;
    friend class CDirect3DDeviceIDP2;
#ifdef VTABLE_HACK
    // This points to the original (compiler generated) read-only vtable of DIRECT3DDEVICEI
    PVOID* lpVtbl;
#endif // VTABLE_HACK
public:
    CDirect3DVertexBuffer(LPDIRECT3DI);
    ~CDirect3DVertexBuffer();
    HRESULT Init(LPDIRECT3DI, LPD3DVERTEXBUFFERDESC, DWORD);
    LPDIRECTDRAWSURFACE GetDDS() { return lpDDS1VB; }
    HRESULT Restore() { return lpDDSVB->Restore(); }
    void UnlockI();
    void BreakLock();
#ifndef WIN95
    HRESULT LockWorkAround(CDirect3DDeviceIDP2 *pDev);
    void UnlockWorkAround();
#endif // WIN95

    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj); // 0
    ULONG D3DAPI AddRef(); // 1
    ULONG D3DAPI Release(); // 2

    // IDirect3DVertexBuffer Methods
    HRESULT D3DAPI Lock(DWORD, LPVOID*, LPDWORD); // 3
    HRESULT D3DAPI Unlock(); // 4
    HRESULT D3DAPI ProcessVertices(DWORD, DWORD, DWORD, LPDIRECT3DVERTEXBUFFER7, DWORD, LPDIRECT3DDEVICE7, DWORD); // 5
    HRESULT D3DAPI GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC); // 6
    HRESULT D3DAPI Optimize(LPDIRECT3DDEVICE7 lpDevI, DWORD dwFlags); // 7
    HRESULT D3DAPI ProcessVerticesStrided(DWORD, DWORD, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPDIRECT3DDEVICE7, DWORD); // 8
protected:
    // Internal Lock
    virtual HRESULT D3DAPI LockI(DWORD, LPVOID*, LPDWORD); // 9
#ifdef VTABLE_HACK
    void VtblLockDefault()
    {
        // 3: IDirect3DVertexBuffer7::Lock
        newVtbl[3] = lpVtbl[3];
    }
    void VtblLockFast()
    {
        // 9: CDirect3DVertexBuffer::LockI
        newVtbl[3] = lpVtbl[9];
    }
#endif // VTABLE_HACK
    HRESULT ValidateProcessVertices(DWORD vertexOP,
                                    DWORD dwDstIndex,
                                    DWORD dwCount,
                                    LPVOID lpSrc,
                                    LPDIRECT3DDEVICE7 lpDevice,
                                    DWORD dwFlags);
    HRESULT DoProcessVertices(LPDIRECT3DVERTEXBUFFERI lpSrcI,
                              LPDIRECT3DDEVICEI lpDevI,
                              DWORD vertexOP,
                              DWORD dwSrcIndex,
                              DWORD dwDstIndex,
                              DWORD dwFlags);
};

// Now that LPDIRECT3DVERTEXBUFFERI is defined...
inline CDirect3DVertexBuffer* CDirect3DDeviceIDP2::TLVbuf_GetVBI()
{
    return static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
}

inline LPDIRECTDRAWSURFACE CDirect3DDeviceIDP2::TLVbuf_GetDDS()
{
    return TLVbuf_GetVBI()->GetDDS();
}

// The instance of the class providing a guaranteed implementation
// This is defined / instantiated in pipeln\helxfrm.cpp
extern D3DFE_PVFUNCS GeometryFuncsGuaranteed;

extern void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt);

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\genpick.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   genpick.h
 *  Content:    Generic picking function prototypes
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: commdrv.h,v 1.2 1995/12/04 11:30:59 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   17/05/96   v-jonsh Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _GENPICK_H_
#define _GENPICK_H_

#include "commdrv.hpp"

extern int  GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                            D3DTLVERTEX*   base,
                            D3DTRIANGLE*   tri,
                            D3DRECT*   rect,
                            D3DVALUE*  result);

extern HRESULT  GenPickTriangles(LPDIRECT3DDEVICEI lpDevI,
                                 LPDIRECTDRAWSURFACE lpDDExeBuf,
                                 LPBYTE      lpData,
                                 D3DINSTRUCTION* ins,
                                 D3DTRIANGLE*    tri,
                                 LPD3DRECTV      extent,
                                 D3DRECT*    pick_region);

extern HRESULT  GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                                 D3DOPCODE op,
                                 int offset,
                                 float result);

extern HRESULT  GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI,
                                  D3DI_PICKDATA* pdata);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/
#ifndef _D3DFE_H

#include "d3d.h"
#include "lists.hpp"
#include "d3dmem.h"
#include "d3ditype.h"

//---------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//--------------------------------------------------------------------
// Base definitions
//

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;

const DWORD VER_IN_BATCH = 8;      // Size of Microsoft's internal clip vertex batch

typedef WORD D3DFE_CLIPCODE;

struct BATCHBUFFER;
//---------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DVERTEX *pInpCoord, 
                                  D3DVECTOR *pInpNormal,
                                  D3DLIGHTINGELEMENT *pEyeSpaceData);
typedef void (*PFN_LIGHTLOOP)(LPD3DFE_PROCESSVERTICES pv, 
                              DWORD dwVerCount,
                              BATCHBUFFER *pBatchBuffer,
                              D3DI_LIGHT *light, 
                              D3DVERTEX *in,
                              D3DVECTOR *pNormal,
                              DWORD *pDiffuse,
                              DWORD *pSpecular);
}
//---------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
typedef struct _D3DMATRIXI
{
    D3DVALUE            _11, _12, _13, _14;
    D3DVALUE            _21, _22, _23, _24;
    D3DVALUE            _31, _32, _33, _34;
    D3DVALUE            _41, _42, _43, _44;
} D3DMATRIXI, *LPD3DMATRIXI;
//---------------------------------------------------------------------
// This is per texture stage data
//
typedef struct _D3DFE_TEXTURESTAGE
{
    DWORD       dwInpCoordIndex;    // Original value of the texture stage - input index
    DWORD       dwInpOffset;        // Texture coord offset in the FVF vertex
    DWORD       dwOutCoordIndex;    // Input index of the texture set is mapped to this 
                                    // output index
    DWORD       dwOrgStage;         // Original texture stage 
    DWORD       dwOrgWrapMode;      // Original WRAP mode
    D3DMATRIXI *pmTextureTransform; // NULL if texture transform is disabled for the stage
    // Bits 0-1 - (number of input  texture coordinates - 1)
    // Bits 2-3 - (number of output texture coordinates - 1)
    DWORD       dwTexTransformFuncIndex; 
    DWORD       dwTexGenMode;       // Mode of texture generation
} D3DFE_TEXTURESTAGE, *LPD3DFE_TEXTURESTAGE;
//---------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//---------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//---------------------------------------------------------------------
// Internal version of lightdata and constants for "flags" member of D3DI_LIGHT
//
const DWORD D3DLIGHTI_ATT0_IS_NONZERO   = 1 << 0;
const DWORD D3DLIGHTI_ATT1_IS_NONZERO   = 1 << 1;  
const DWORD D3DLIGHTI_ATT2_IS_NONZERO   = 1 << 2;   
const DWORD D3DLIGHTI_LINEAR_FALLOFF    = 1 << 3;
// Set when light data is changed
const DWORD D3DLIGHTI_DIRTY             = 1 << 4;
// This flag depends on D3DRENDERSTATE_SPACULARENABLE and light specular color
const DWORD D3DLIGHTI_COMPUTE_SPECULAR  = 1 << 5;
// Set when light data is set
const DWORD D3DLIGHTI_VALID             = 1 << 6;
// Set when the light is enabled
const DWORD D3DLIGHTI_ENABLED           = 1 << 7;        
const DWORD D3DLIGHTI_SPECULAR_IS_ZERO  = 1 << 8;
const DWORD D3DLIGHTI_AMBIENT_IS_ZERO   = 1 << 9;
const DWORD D3DLIGHTI_OPTIMIZATIONFLAGS = D3DLIGHTI_SPECULAR_IS_ZERO |
                                          D3DLIGHTI_AMBIENT_IS_ZERO  |
                                          D3DLIGHTI_ATT0_IS_NONZERO  |
                                          D3DLIGHTI_ATT1_IS_NONZERO  |
                                          D3DLIGHTI_ATT2_IS_NONZERO  |
                                          D3DLIGHTI_LINEAR_FALLOFF;
//--------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position; // In the camera or model space
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;// In the camera or model space
    D3DVALUE        falloff;
    // Should be QWORD aligned
    DWORD           flags;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     diffuseMat;     // Material diffuse times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     specularMat;    // Material specular times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     ambientMat;     // Material specular times light color
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;        // Used by directional, parallel-point and 
                                    // spot lights when camera is in infinity
    struct _D3DI_LIGHT *next;       // Next in the active light list
    // Should be QWORD aligned
    D3DFE_COLOR     diffuse;        // Original color scaled to 0 - 255
    D3DFE_COLOR     specular;       // Original color scaled to 0 - 255
    D3DFE_COLOR     ambient;        // Original color scaled to 0 - 255

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;       // In the world space
    D3DVECTOR       direction;      // In the world space
    D3DVALUE        range;
    LPVOID          pPSGPData;      // Pointer to a PSGP specific "per light" data
// Microsoft's pipeline specific data
    PFN_LIGHTLOOP   pfnLightFirst;  // Used in multi-loop pipeline for first lights
    PFN_LIGHTLOOP   pfnLightNext;   // Used in multi-loop pipeline for not first lights
} D3DI_LIGHT, *LPD3DI_LIGHT;
//---------------------------------------------------------------------
// Bits for lighting flags (dwLightingFlags
//
const DWORD __LIGHT_VERTEXTRANSFORMED = 1;  // Vertex is in the camera space
const DWORD __LIGHT_NORMALTRANSFORMED = 2;  // Normal is in the camera space
const DWORD __LIGHT_SPECULARCOMPUTED  = 4;
const DWORD __LIGHT_DIFFUSECOMPUTED   = 8;
//---------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    DWORD             alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         model_eye;      // camera position in model or camera space
    DWORD             vertexAmbient;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientSceneScaled;   // Scene ambient color (scaled 0.0-255.0)
    DWORD             vertexDiffuse;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientScene;         // Scene ambient color (0.0-1.0)
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         directionToCamera;    // Direction to camera in the model space
                                            // Used in model space lighting
    DWORD             vertexSpecular;       // Provided with a vertex
    // Should be QWORD aligned
    D3DMATERIAL7      material;
    DWORD             dwLightingFlags;
    DWORD             alphaSpecular;  // Alpha to use for output specular vertex color
                                      // (could be overriden by vertex specular
                                      // color) (0-255) shifted left by 24 bits
// End of temporary data
    D3DI_LIGHT       *activeLights;
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material diffuse alpha (0-255)
                                      // shifted left by 24 bits
    int               materialAlphaS; // Current material specular alpha (0-255)
                                      // shifted left by 24 bits
    DWORD             dwDiffuse0;     // Packed diffuse0    
    DWORD             dwAmbientSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwDiffuseSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwSpecularSrcIndex;   // 0 - diffuse, 1 - specular
    DWORD             dwEmissiveSrcIndex;   // 0 - diffuse, 1 - specular
} D3DFE_LIGHTING;
//---------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth
    D3DVALUE scaleY;            // -dvHeight
    D3DVALUE offsetX;           // dvX
    D3DVALUE offsetY;           // dvY + dvHeight
    D3DVALUE scaleZ;            // dvMaxZ - dvMinZ
    D3DVALUE offsetZ;           // dvY + dvHeight
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
} D3DFE_VIEWPORTCACHE;
//---------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
// 8 bits are reserved for Draw Primitive flags
//
// D3DDEV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_DOCOLORVERTEX  = 1 << 9;  // Need to apply color vertex
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting 
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
const DWORD D3DPV_COLORVERTEX_E  = 1 << 13; // Need to replace emissive material color
const DWORD D3DPV_COLORVERTEX_D  = 1 << 14; // Need to replace diffuse material color
const DWORD D3DPV_COLORVERTEX_S  = 1 << 15; // Need to replace specular material color
const DWORD D3DPV_COLORVERTEX_A  = 1 << 16; // Need to replace ambient material color
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Specular color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYSPECULAR = 1 << 20;
// Set when one pass clipping and vertex processing is used
const DWORD D3DPV_ONEPASSCLIPPING= 1 << 21; 
const DWORD D3DPV_RESERVED1      = 1 << 22;
const DWORD D3DPV_RESERVED2      = 1 << 23;
const DWORD D3DPV_RESERVED3      = 1 << 24;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by SetupFVFData function.
const DWORD D3DPV_VBCALL         = 1 << 27;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Texture coordinates should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYTEXTURE = 1 << 28;
// To mark whether we are doing TLVERTEX clipping or not
const DWORD D3DPV_TLVCLIP        = 1 << 29;
// Mictosoft internal !!! Set when only transformation is required 
// (no lightng or texture copy)
const DWORD D3DPV_TRANSFORMONLY  = 1 << 30; 
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Diffuse color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYDIFFUSE = 1 << 31;
// These flags persist from call to call till something cuses them to change
const DWORD D3DPV_PERSIST = D3DPV_FOG                   |
                            D3DPV_LIGHTING              |
                            D3DPV_DONOTCOPYDIFFUSE      |
                            D3DPV_DONOTCOPYSPECULAR     |
                            D3DPV_DONOTCOPYTEXTURE      |
                            D3DPV_TRANSFORMONLY         |
                            D3DPV_TLVCLIP               ;

// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_RANGEBASEDFOG = 1 << 2;  // Set if range based fog is enabled
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DDEV_FOG           = 1 << 3;
const DWORD D3DDEV_FVF           = 1 << 4;  // FVF supported
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6; // Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS

// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.
//
// Set when D3DRENDERSTATE_SPECULARENABLE is TRUE
const DWORD D3DDEV_SPECULARENABLE       = 1 << 11;   
// Set if diffuse color should be interpolated during clipping
const DWORD D3DDEV_INTERPOLATE_COLOR    = 1 << 12;   
// Set if specular color should be interpolated during clipping
const DWORD D3DDEV_INTERPOLATE_SPECULAR = 1 << 13;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_FRUSTUMPLANES_DIRTY  = 1 << 14;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_TEXTRANSFORMDIRTY    = 1 << 15; // Need to re-evaluate texture transforms
// The flag is set when the number of output texture coord is greater then the 
// number of the input ones. This could happen when the same texture transform 
// matrix is used with the same input texture coord set. In this case we save
// texture indices from the texture stages in the textureStages and map all 
// indices sequentially.
const DWORD D3DDEV_REMAPTEXTUREINDICES  = 1 << 16;  

// These two flags are for PSGP only. PSGP implementation should clear the flags
const DWORD D3DDEV_TRANSFORMDIRTY       = 1 << 17; // Transform matrix has been changed
const DWORD D3DDEV_LIGHTSDIRTY          = 1 << 18; // Lights have been changed

const DWORD D3DDEV_DONOTCLIP            = 1 << 19; // Clipping is disabled
const DWORD D3DDEV_DONOTUPDATEEXTENTS   = 1 << 20; // Extents computation is disabled
// Set, if driver does not support FVF and there is no texture coordinates in
// the vertex
const DWORD D3DDEV_NOFVFANDNOTEXTURE    = 1 << 21;
// This flag is set if the current TLVbuf is write only
const DWORD D3DDEV_TLVBUFWRITEONLY      = 1 << 22;
// World-view matrix does not have scale, so we can do lighting 
// in the model space
const DWORD D3DDEV_MODELSPACELIGHTING   = 1 << 23;  
// Set if viewer is local (used for lighting)
const DWORD D3DDEV_LOCALVIEWER          = 1 << 24;  
// Set if we wave to normalize normals after transforming them to the camera space
const DWORD D3DDEV_NORMALIZENORMALS     = 1 << 25;  
// Set if we wave to do texture transform
const DWORD D3DDEV_TEXTURETRANSFORM     = 1 << 26; 
// Set if the last draw primitive call was strided
const DWORD D3DDEV_STRIDE               = 1 << 27; 
// Set if D3DRENDERSTATE_COLORVERTEX is TRUE
const DWORD D3DDEV_COLORVERTEX          = 1 << 28;
// Set if position in camera space is always needed
const DWORD D3DDEV_POSITIONINCAMERASPACE= 1 << 29;
// Set if normal in camera space is always needed
const DWORD D3DDEV_NORMALINCAMERASPACE  = 1 << 30;
// Set if D3DRENDERSTATE_LIGHTING is set
const DWORD D3DDEV_LIGHTING             = 1 << 31;
//--------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

class ClipVertex
{
public:
    D3DVALUE    hx;                 // Clipping space coordinates. Must be in this order
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    int         clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;                 // Screen space coordinates. Must be in this order
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    ClipVertex *next;
    D3DVALUE    tex[MAX_FVF_TEXCOORD*4];
};

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    CBufferDDS   clipBuf;      // Used for TL vertices, generated by the clipper
    CBufferDDS   clipBufPrim;  // Used for primitives, generated by the clipper
                              // for execute buffers
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
    LPDIRECTDRAWSURFACE lpDDExeBuf; // Current user execute buffer
    LPVOID      lpvExeBufMem;       // Current memory for user execute buffer
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;

// These bit are set when a vertex is clipped by a frustum plane

#define CLIPPED_LEFT    (D3DCLIP_GEN5 << 1)
#define CLIPPED_RIGHT   (D3DCLIP_GEN5 << 2)
#define CLIPPED_TOP     (D3DCLIP_GEN5 << 3)
#define CLIPPED_BOTTOM  (D3DCLIP_GEN5 << 4)
#define CLIPPED_FRONT   (D3DCLIP_GEN5 << 5)
#define CLIPPED_BACK    (D3DCLIP_GEN5 << 6)

#define CLIPPED_ENABLE  (D3DCLIP_GEN5 << 7) /* wireframe enable flag */

// These bit are set when a vertex is clipped by a user clipping plane

const DWORD CLIPPED_GEN0 = D3DCLIP_GEN5 << 8;
const DWORD CLIPPED_GEN1 = D3DCLIP_GEN5 << 9;
const DWORD CLIPPED_GEN2 = D3DCLIP_GEN5 << 10;
const DWORD CLIPPED_GEN3 = D3DCLIP_GEN5 << 11;
const DWORD CLIPPED_GEN4 = D3DCLIP_GEN5 << 12;
const DWORD CLIPPED_GEN5 = D3DCLIP_GEN5 << 13;

// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCLIP_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCLIP_GEN5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCLIP_GEN5 << 2)
#define __D3DCLIPGB_TOP     (D3DCLIP_GEN5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCLIP_GEN5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

const DWORD __D3DCLIP_USERPLANES =  D3DCLIP_GEN0 | D3DCLIP_GEN1 | D3DCLIP_GEN2 | 
                                    D3DCLIP_GEN3 | D3DCLIP_GEN4 | D3DCLIP_GEN5;
// If only these bits are set, then this point is inside the guard band
//
#define __D3DCLIP_INGUARDBAND (D3DCLIP_LEFT | D3DCLIP_RIGHT | \
                               D3DCLIP_TOP  | D3DCLIP_BOTTOM)

//---------------------------------------------------------------------
// Bits in the dwFlags2 
//
// The bit is set when the texture transform is enabled
const DWORD __FLAGS2_TEXTRANSFORM0 = 1 << 0;
const DWORD __FLAGS2_TEXTRANSFORM1 = 1 << 1;
const DWORD __FLAGS2_TEXTRANSFORM2 = 1 << 2;
const DWORD __FLAGS2_TEXTRANSFORM3 = 1 << 3;
const DWORD __FLAGS2_TEXTRANSFORM4 = 1 << 4;
const DWORD __FLAGS2_TEXTRANSFORM5 = 1 << 5;
const DWORD __FLAGS2_TEXTRANSFORM6 = 1 << 6;
const DWORD __FLAGS2_TEXTRANSFORM7 = 1 << 7;

const DWORD __FLAGS2_TEXTRANSFORM = __FLAGS2_TEXTRANSFORM0 |
                                    __FLAGS2_TEXTRANSFORM1 |
                                    __FLAGS2_TEXTRANSFORM2 |
                                    __FLAGS2_TEXTRANSFORM3 |
                                    __FLAGS2_TEXTRANSFORM4 |
                                    __FLAGS2_TEXTRANSFORM5 |
                                    __FLAGS2_TEXTRANSFORM6 |
                                    __FLAGS2_TEXTRANSFORM7;
// The bit is set when the texture coordinate set is taken from the vertex data
// (position or normal)
const DWORD __FLAGS2_TEXGEN0 = 1 << 16;
const DWORD __FLAGS2_TEXGEN1 = 1 << 17;
const DWORD __FLAGS2_TEXGEN2 = 1 << 18;
const DWORD __FLAGS2_TEXGEN3 = 1 << 19;
const DWORD __FLAGS2_TEXGEN4 = 1 << 20;
const DWORD __FLAGS2_TEXGEN5 = 1 << 21;
const DWORD __FLAGS2_TEXGEN6 = 1 << 22;
const DWORD __FLAGS2_TEXGEN7 = 1 << 23;

const DWORD __FLAGS2_TEXGEN = __FLAGS2_TEXGEN0 |
                              __FLAGS2_TEXGEN1 |
                              __FLAGS2_TEXGEN2 |
                              __FLAGS2_TEXGEN3 |
                              __FLAGS2_TEXGEN4 |
                              __FLAGS2_TEXGEN5 |
                              __FLAGS2_TEXGEN6 |
                              __FLAGS2_TEXGEN7;
//---------------------------------------------------------------------
#define __TEXTURETRANSFORMENABLED(pv) pv->dwFlags2 & __FLAGS2_TEXTRANSFORM

const DWORD __MAXUSERCLIPPLANES = 6;
//---------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
    D3DFE_PROCESSVERTICES();
    virtual HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD) = 0;
// State
    // Should be QWORD aligned
    D3DMATRIXI mTexture[D3DDP_MAXTEXCOORD];  // Texture transform;
    D3DMATRIXI mCTM2[3];
    D3DMATRIXI mWV2[3];
    D3DMATRIXI mWVI2[3];
    D3DMATRIXI mWV;                 // Transforms to camera space (Mworld*Mview)
    D3DMATRIXI mWVI;                // Inverse mWV
    D3DMATRIXI mCTM;                // Current Transformation Matrix
                                    // supported by driver
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD    dwClipUnion;           // OR of all vertex clip flags
    DWORD    dwClipIntersection;    // AND of all vertex clip flags
    DWORD    dwTextureIndexToCopy;  // Used for not FVF devices. Used by PSGP
    D3DVALUE dvExtentsAdjust;       // Replicated here from device caps

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    union {
        D3DDP_PTRSTRIDE normal;
        DWORD dwSOAStartVertex;
    };
    D3DDP_PTRSTRIDE diffuse;
    // Cache line should start here
    D3DPRIMITIVETYPE primType;
    DWORD   dwNumVertices;  // Number of vertices to process
    DWORD   dwFlags;        // Flags word describing what to do
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD   dwVertexBase;
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    DWORD   dwNumPrimitives;
    DWORD   dwDP2VertexCount;       // Number of vertices in DP2 vertex buffer
                                    // Internal data for Microsoft implementation

    // Cache line should start here
    DWORD   dwVIDIn;        // Vertex ID of input vertices
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    DWORD   dwOutputSize;   // Output vertex size
    DWORD   dwFEFlags;      // MS internal use Only!!
    DWORD   dwVIDOut;       // Vertex ID of output vertices
    LPVOID  lpvOut;                 // Output pointer (output always packed)

    DWORD   dwVertexPoolSize;       // Size of vertices in the un-clipped part of a primitive
                                    // in bytes, put to the DP2 vertex buffer
                                    // Internal data for Microsoft implementation
    union {
        D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
        D3DDP_PTRSTRIDE SOA;
    };
    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   nTexCoord;      // Number of the input texture coordinate sets
    DWORD   nOutTexCoord;   // Number of the output texture coordinate sets to process.
                            // WARNING. It could be different from the texture count in dwVIDOut
                            // (it could be zero for example when dwVIDOut has 1 texture coord set).
                            // If D3DDEV_REMAPTEXTUREINDICES is set this is equal
                            // to the number of active texture stages
    // Total size of all output texture coordinates in bytes
    DWORD   dwTextureCoordSizeTotal;    
    D3DDP_PTRSTRIDE specular;
    D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
    // Size of output texture coordinate sets in bytes
    DWORD   dwTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Size of input texture coordinate sets in bytes
    DWORD   dwInpTextureCoordSize[D3DDP_MAXTEXCOORD];
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DRECTV rExtents;              // Extents rectangle to update, if required
    D3DFE_TEXTURESTAGE textureStage[D3DDP_MAXTEXCOORD]; // Texture state stages
    DWORD   dwNumTextureStages;     // Used when we have to re-map texture indices
    // This array is used when we do not do re-mapping of texture coordinates
    D3DMATRIXI *pmTexture[D3DDP_MAXTEXCOORD]; 
    D3DVECTORH userClipPlane[__MAXUSERCLIPPLANES];
    DWORD   dwFlags2;       // Low 8 bits are texture transform enable: 
                            // bit 0 corresponds to the texture stage 0
                            // Bits 8-15 are for user clipping plane
                            // Bits 16-23 are set if corresponding texture coord set
                            // is taken from the vertex data (position or normal)
    DWORD   dwNumVerBlends;                 // Number of weights for vertex blending
    DWORD   dwMaxUserClipPlanes;
    virtual HRESULT DrawPrim()=0;           // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;      // Use to pass indexed primitives to driver
    virtual HRESULT DrawClippedPrim()=0;    // Use to pass clipped non-indexed primitives to driver
// Internal data for Microsoft implementation
    DWORD   texOffset;              // Offsets in the input FVF vertex. Recomputed
    DWORD   normalOffset;           // when FVF is changed.
    DWORD   diffuseOffset;          // 
    DWORD   specularOffset;
    DWORD   texOffsetOut;           // Offsets in the output FVF vertex. Recomputed
    DWORD   diffuseOffsetOut;       // when FVF is changed.
    DWORD   specularOffsetOut;
    DWORD   dwClipMaskOffScreen;    // When and this mask with the clip code we 
                                    // have bits that are outside the guard band
    ClipVertex  clipVer[VER_IN_BATCH];  // Clip vertices. Used in processing 
                                        // and clipping in the one loop
    DWORD   dwFirstClippedVertex;   // Index of the first vertex with non-zero clip code
    DWORD dwMaxTextureIndices;      // Max number of texture coord sets
};
//---------------------------------------------------------------------
// Prototype for the function to be written for a given processor implementation
//
// Returns clip intersection.
//

class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() { };
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer) = 0;
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues) = 0;
    virtual HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES)=0;
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;

//---------------------------------------------------------------------
// Direct3D implementation of PVFUNCS
//
class D3DFE_PVFUNCS : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer);
    HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues);
    HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES);
private:
    HRESULT ProcessLineStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessLineList(D3DFE_PROCESSVERTICES *pv);
};

// GeometrySetup function takes a DWORD describing the dirty bits and the new state vector
// and passes back the 3 new leaf routines to use.
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);

// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#include <limits.h>
#if defined(i386)
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

 class DIRECT3DDEVICEI;

 /*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI      D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);
HRESULT ReallocAligned(void** p_inout, size_t size);

/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s)
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p)
    {
        FreeAligned(p);
    };
};
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  {size = 0; allocatedBuf = 0; alignedBuf = 0;}
    ~CAlignedBuffer32() {if (allocatedBuf) D3DFree(allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(dwSize + 1024);
            else
                return D3D_OK;
        }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class DIRECT3DDEVICEI;
class CDirect3DVertexBuffer;
class CDirect3DDeviceIDP2;
//----------------------------------------------------------------------
// This class manages a growing buffer using DDraw Surfaces.
class CBufferDDS
{
protected:
    LPDIRECTDRAWSURFACE allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
public:
    CBufferDDS()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
    }
    ~CBufferDDS()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize()
    {
        return size;
    }
    LPDIRECTDRAWSURFACE GetDDS()
    {
        return allocatedBuf;
    }
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(lpDevI, dwSize + 1024);
        else
            return D3D_OK;
    }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    // define these later on in this file after CDirect3DVertexBuffer is defined
};
//----------------------------------------------------------------------
// This class manages a growing vertex buffer.
// Allocate it in driver friendly memory.
// Do not use except for DP2 DDI
class CBufferVB
{
protected:
    LPDIRECT3DVERTEXBUFFER7 allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size, base;
public:
    CBufferVB()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
        base = 0;
    }
    ~CBufferVB()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf + base;
    }
    // Returns aligned buffer size
    DWORD GetSize() { return size - base; }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    DWORD& Base() { return base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* GetVBI();
    inline LPDIRECTDRAWSURFACE GetDDS();
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(lpDevI, dwSize + 1024);
            else
                return D3D_OK;
        }
    friend CDirect3DDeviceIDP2;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\halprov.h ===
//----------------------------------------------------------------------------
//
// halprov.h
//
// Defines the IHalProvider interface.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HALPROV_H_
#define _HALPROV_H_

// The following stuff is for Ramp Rasterizer.
typedef enum _RastRampServiceType
{
    RAMP_SERVICE_CREATEMAT              = 0,
    RAMP_SERVICE_DESTORYMAT             = 1,
    RAMP_SERVICE_SETMATDATA             = 2,
    RAMP_SERVICE_SETLIGHTSTATE          = 3,
    // This returns base, size, and a texture ramp.
    // Arg1 is a pointer to RAMP_RANGE_INFO.
    RAMP_SERVICE_FIND_LIGHTINGRANGE     = 4,
    // This service only calls BeginSceneHook. Both arg1 and arg2 are ignored.
    RAMP_SERVICE_CLEAR                  = 5,
    // Arg1 is a D3DMATERIALHANDLE, arg2 is a DWORD* to get the pixel value.
    RAMP_SERVICE_MATERIAL_TO_PIXEL      = 6,
    // Arg1 is 0 if end scene, != 0 if begin scene
    RAMP_SERVICE_SCENE_CAPTURE          = 8,
    // Arg1 is hTex
    RAMP_SERVICE_PALETTE_CHANGED        = 9,
} RastRampServiceType;

typedef enum _RastServiceType
{
    // Arg1 is a D3DCOLOR, and Arg2 is a DWORD* to get the pixel value
    RAST_SERVICE_RGB8COLORTOPIXEL              = 0,
} RastServiceType;

typedef HRESULT (*PFN_RASTRAMPSERVICE)
    (ULONG_PTR dwCtx, RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

typedef HRESULT (*PFN_RASTSERVICE)
    (ULONG_PTR dwCtx, RastServiceType srvType, DWORD arg1, LPVOID arg2);

typedef struct _D3DHALPROVIDER_INTERFACEDATA
{
    DWORD                       dwSize;
    LPD3DHAL_GLOBALDRIVERDATA   pGlobalData;
    LPD3DHAL_D3DEXTENDEDCAPS    pExtCaps;
    LPD3DHAL_CALLBACKS          pCallbacks;
    LPD3DHAL_CALLBACKS2         pCallbacks2;
    LPD3DHAL_CALLBACKS3         pCallbacks3;

    PFN_RASTSERVICE             pfnRastService;
    LPDDHAL_GETDRIVERSTATE      pfnGetDriverState;
} D3DHALPROVIDER_INTERFACEDATA, *LPD3DHALPROVIDER_INTERFACEDATA;


#undef INTERFACE
#define INTERFACE IHalProvider

DECLARE_INTERFACE_(IHalProvider, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion) PURE;
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion) PURE;
};

STDAPI GetHwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll, LPDDRAWI_DIRECTDRAW_GBL pDdGbl);
STDAPI GetSwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll);

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

#endif // #ifndef _HALPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "cspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\haldrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL driver include file
 *
 ***************************************************************************/

#ifndef _HALDRV_H_
#define _HALDRV_H_

#undef DPF_MODNAME
#define DPF_MODNAME     "Direct3D HAL"

#define SURFACE_MEMORY(surf) \
(LPVOID)(((LPDDRAWI_DDRAWSURFACE_INT)(surf))->lpLcl->lpGbl->fpVidMem)

#ifdef TRACK_HAL_CALLS
#define RESET_HAL_CALLS(lpDevI) ((lpDevI)->hal_calls = 0)
#define TRACK_HAL_CALL(lpDevI) ((lpDevI)->hal_calls++)
#else
#define RESET_HAL_CALLS(lpDevI)
#define TRACK_HAL_CALL(lpDevI)
#endif


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str


#ifdef WIN95

extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
extern void _stdcall    _EnterSysLevel( LPVOID );
extern void _stdcall    _LeaveSysLevel( LPVOID );
extern LPVOID           lpWin16Lock;

#define LOCK_HAL(ret, lpDevI)                                           \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _EnterSysLevel(lpWin16Lock);                                    \
    }                                                                   \
    ret = D3D_OK;                                                       \
}

#define UNLOCK_HAL(lpDevI)                                              \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _LeaveSysLevel(lpWin16Lock);                                    \
    }                                                                   \
}

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI);
void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI);

#define LOCK_DIBENGINE(ret, lpDevI)                                     \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        ret = D3DHAL_LockDibEngine(lpDevI);                             \
    }                                                                   \
    else    {                                                           \
        ret = D3D_OK;                                                   \
    }                                                                   \
}

#define UNLOCK_DIBENGINE(lpDevI)                                        \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        D3DHAL_UnlockDibEngine(lpDevI);                                 \
    }                                                                   \
}

#else // WIN95

#define LOCK_HAL(ret, lpDevI) ret = DD_OK
#define UNLOCK_HAL(lpDevI)
#define LOCK_DIBENGINE(ret, lpDevI) ret = DD_OK
#define UNLOCK_DIBENGINE(lpDevI)

#endif // WIN95


#define CALL_HALONLY_NOLOCK(ret, lpDevI, call, data)                          \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks->call) {                                    \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks->call)(data);                   \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks2->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks2->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data)                        \
{                                                                             \
    if (lpDevI->lpD3DHALCommandBufferCallbacks->call) {                       \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCommandBufferCallbacks->call)(data);      \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks3->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks3->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}


#define CALL_HALONLY(ret, lpDevI, call, data)                           \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALONLY_NOLOCK(ret, lpDevI, call, data);                   \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HALCBONLY(ret, lpDevI, call, data)                         \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data);                 \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HAL2ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}
//-----------------------------------------------------------------------
// Call for callbacks that are not required to be implemented
//
#define CALL_HAL3ONLY_OPTIONAL(ret, lpDevI, call, data)                 \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    if (lpDevI->lpD3DHALCallbacks3->call)                               \
    {                                                                   \
        CALL_HAL3ONLY(ret, lpDevI, call, data);                         \
    }                                                                   \
}
//-----------------------------------------------------------------------
#define CALL_HAL3ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI, LPD3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE);
HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK);
HRESULT D3DFE_SetViewportData(LPDIRECT3DDEVICEI, DWORD, LPD3DVIEWPORT2);
HRESULT D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_LightSet(LPDIRECT3DDEVICEI, DWORD, LPD3DI_LIGHT);
HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI, BOOL);

/*********************
 * HEL Calls
 *********************/

extern HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                            LPDIRECTDRAW lpDD,
                            LPDIRECTDRAW7 lpDD7,
                            LPDIRECTDRAWSURFACE lpDDS,
                            LPDIRECTDRAWSURFACE lpZ,
                            LPDIRECTDRAWPALETTE lpPal);
extern void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI);

DWORD   D3DFE_QueryTextureFormat (LPDIRECT3DDEVICEI, LPDDSURFACEDESC*);
HRESULT D3DFE_UpdateTexture (LPDIRECT3DDEVICEI, DWORD, D3DTEXTUREHANDLE);
HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,DWORD numRect, LPD3DRECT lpRect, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);

#ifndef WIN95
__inline HRESULT CheckContextSurface(LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
            
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR ( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = (DWORD)(((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface);
    }
    return(D3D_OK);
}
#endif //WIN95

// This struct is used for FindLightingRange RampService
typedef struct tagRAMP_RANGE_INFO
{
    DWORD base;
    DWORD size;
    LPVOID pTexRampMap;
    BOOL specular;
}RAMP_RANGE_INFO;

// This inline is for calling RastService when nothing special is required.
inline HRESULT CallRastService(LPDIRECT3DDEVICEI lpDevI,
                               RastServiceType ServiceType,
                               DWORD arg1,
                               LPVOID arg2)
{
    if (lpDevI->pfnRastService != NULL)
    {
        return lpDevI->pfnRastService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

#endif /* _HALDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\link\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dim700
TARGETPATH=obj

TARGETTYPE=DYNLINK
DLLDEF=$O\$(TARGETNAME).def

!IFDEF D3DBBT
X3DLIB=x3dbbt.lib
KINTELLIB=ikpsgp7bbt.lib
WINTELLIB=iwpsgp7bbt.lib
!ELSE
X3DLIB=x3d.lib
KINTELLIB=ikpsgp700.lib
WINTELLIB=iwpsgp700.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\gdi32.lib\
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(KINTELLIB) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(WINTELLIB) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif

LINKLIBS = \
        $(D3DDX7)\util\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DDX7)\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dtnl.lib \
        $(D3DDX7)\fe\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfe.lib \
        $(D3DDX7)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DDX7)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DDX7)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DDX7)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DDX7)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DDX7)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

!if !($(AMD64) || $(IA64))
LINKLIBS=$(LINKLIBS) \
        $(D3DDX7)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib \
!endif

DLLENTRY = _DllMainCRTStartup

SOURCES = ..\d3dim700.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhal.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[D3DHAL_TSS_MAXSTAGES];

    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\makefile.inc ===
$(GENTGT)\pmfns_mh.h: ..\pmfns_mh.mh $(RAST_STD_M4)

$(GENTGT)\pmfns.cpp: ..\pmfns.mcp $(RAST_STD_M4)

$(GENTGT)\dprim2.cpp: ..\dprim2.mcp $(RAST_STD_M4)

$(GENTGT)\refif.cpp: ..\refif.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\makefile.inc ===
$(GENTGT)\ccrbd_mh.h: ..\ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ..\ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ..\ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxa_mh.h: ..\ctxa_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)


$(GENTGT)\ctxbd_mh.h: ..\ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ..\ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ..\ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: ..\catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: ..\cbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: ..\cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: ..\cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: ..\cloop.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ..\ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctxaddr.cpp: ..\ctxaddr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ..\ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ..\ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: ..\catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ..\ctstfail.mcp ..\ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\sources.inc ===
TARGETNAME = rcspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\catest.cpp\
        $O\cbeadtbl.cpp\
        ..\cbldfncs.cpp\
        ..\cbufread.cpp\
        ..\cbufwrt.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        ..\cspnpars.cpp\
        ..\cspnutil.cpp\
        $O\ctest.cpp\
        $O\ctxaddr.cpp\
        $O\ctxblend.cpp\
        ..\ctexfilt.cpp\
        $O\ctexread.cpp\
        $O\ctstfail.cpp

NTTARGETFILE0 = \
        $O\catest_mh.h\
        $O\ccrbd_mh.h\
        $O\ccrgn_mh.h\
        $O\ctest_mh.h\
        $O\ctxa_mh.h\
        $O\ctxbd_mh.h\
        $O\ctxrd_mh.h\
        $O\ctstf_mh.h\
        $O\cbeadtbl.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        $O\ctest.cpp\
        $O\ctxaddr.cpp\
        $O\ctxblend.cpp\
        $O\ctexread.cpp\
        $O\catest.cpp\
        $O\ctstfail.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "d3dif.hpp"
#include "swprov.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rastctx.cpp ===
//----------------------------------------------------------------------------
//
// rastctx.cpp
//
// Context functions + state functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Unlock previous texture if necessary. It's called before the texture handle
// is going to be changed.
#define CHECK_AND_UNLOCK_TEXTURE    \
{   \
    if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)   \
    {   \
        RastUnlockSpanTexture();    \
    }   \
}

//----------------------------------------------------------------------------
//
// FillContext
//
// Fill the context with the info. from the surfaces.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::FillContext(LPDIRECTDRAWSURFACE pDDS,
                               LPDIRECTDRAWSURFACE pDDSZ)
{
    HRESULT hr;

    LPDDRAWI_DDRAWSURFACE_LCL pLcl =
        ((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl;
    m_RastCtx.iSurfaceStride = DDSurf_Pitch(pLcl);
    m_RastCtx.iSurfaceBitCount = DDSurf_BitDepth(pLcl);
    m_RastCtx.iSurfaceStep = m_RastCtx.iSurfaceBitCount/8;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)),
        (D3DI_SPANTEX_FORMAT *)&(m_RastCtx.iSurfaceType)));
    m_RastCtx.Clip.left = m_RastCtx.Clip.top = 0;
    m_RastCtx.Clip.bottom = DDSurf_Height(pLcl);
    m_RastCtx.Clip.right = DDSurf_Width(pLcl);

    if (pDDSZ != NULL)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pDDSZ))->lpLcl;
        m_RastCtx.pZBits = (PUINT8)SURFACE_MEMORY(pDDSZ);
        m_RastCtx.iZStride = DDSurf_Pitch(pLcl);
        m_RastCtx.iZBitCount = DDSurf_BitDepth(pLcl);
        m_RastCtx.iZStep = m_RastCtx.iZBitCount/8;
    }
    else
    {
        m_RastCtx.pZBits = NULL;
        m_RastCtx.iZStride = 0;
        m_RastCtx.iZBitCount = 0;
        m_RastCtx.iZStep = 0;
    }

    m_RastCtx.pDDS = pDDS;
    m_RastCtx.pDDSZ = pDDSZ;

    m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

    // Make sure SpanInit is called at least once
    SetAllStatesDirtyBits();

    // Check for MsGolf AppHack
    if (pLcl->lpSurfMore->lpDD_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_FORCEMODULATED)
    {
        m_uFlags |= D3DCONTEXT_APPHACK_MSGOLF;
    }

    return D3D_OK;
}

HRESULT
D3DContext::Initialize(LPDIRECTDRAWSURFACE pDDS,
                       LPDIRECTDRAWSURFACE pDDSZ,
                       DWORD BeadSet,
                       DWORD devVer)
{
    HRESULT hr;

    // Initialize the primitive processor.
    HR_RET(m_PrimProc.Initialize());

    memset(&m_RastCtx, 0, sizeof(m_RastCtx));

    m_uFlags = 0;
    HR_RET(FillContext(pDDS, pDDSZ));

    m_PrimProc.SetCtx(&m_RastCtx);

    dwSize = sizeof(D3DContext);

    // Initialize bead table enum
    m_RastCtx.BeadSet = (D3DI_BEADSET)BeadSet;

    // Init FVF data as legacy TL vertex
    m_fvfData.preFVF = -1;
    CheckFVF(D3DFVF_TLVERTEX);

    m_RastCtx.uDevVer = devVer;

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    // Init prim function table. It will be updated for, or when FVF
    // control word changes or when fill mode changes.
    m_fnPrims.pfnTri = RGB_TriNoPackSolid;
    m_fnPrims.pfnPoint = RGB_PointNoPack;
    m_fnPrims.pfnLine = RGB_LineNoPack;
    // This one should be always the same.
    m_fnPrims.pfnStoreLastPixelState = RGB_StoreLastPixelState;
    m_fnPrims.pfnDp2SetRenderStates = RGB_Dp2SetRenderStates;
    m_fnPrims.pfnDp2TextureStageState = RGB_Dp2TextureStageState;
    m_fnPrims.pfnDp2SetViewport = RGB_Dp2SetViewport;
    m_fnPrims.pfnDp2SetWRange = RGB_Dp2SetWRange;

    // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
    m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwDisableMask[MMX_FP_DISABLE_MASK_NUM] = {0x0};
        DWORD dwSize = 4;

        // only code up looking at one mask, for now
        DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMXFPDisableMask0", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD )
        {
           dwDisableMask[0] = dwValue;
        }
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMX Fast Path", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD)
        {
            if (dwValue == 0)
            {
                // Override MMXFPDisableMask0 and disable all MMX Fast Paths
                m_RastCtx.dwMMXFPDisableMask[0] = 0xffffffff;
            }
            else
            {
                // Take all MMX paths not disabled by MMXFPDisableMask0
                m_RastCtx.dwMMXFPDisableMask[0] = dwDisableMask[0];
            }
        }

        RegCloseKey( hKey );
    }

    return D3D_OK;
}

HRESULT
D3DContext::SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt)
{
    m_RastCtx.Clip.left = pVpt->dwX;
    m_RastCtx.Clip.top = pVpt->dwY;
    m_RastCtx.Clip.bottom = pVpt->dwY + pVpt->dwHeight;
    m_RastCtx.Clip.right = pVpt->dwX + pVpt->dwWidth;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastContextCreateC
//
// Calls RastContextCreate with the C bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_C);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMX
//
// Calls RastContextCreate with the MMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMXAsRGB
//
// Calls RastContextCreate with the MMX bead set, but remember that we
// came from RGB.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMXASRGB);
}

//----------------------------------------------------------------------------
//
// RastContextCreate
//
// Creates a RASTCTX and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet)
{
    DDASSERT(pCtxData != NULL);

    D3DContext *pDCtx = new D3DContext;

    if (pDCtx == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pCtxData->ddrval =
        pDCtx->Initialize(pCtxData->lpDDS,
                          pCtxData->lpDDSZ,
                          BeadSet,
                          (DWORD)pCtxData->dwhContext);

    pCtxData->dwhContext = (ULONG_PTR)pDCtx;

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if (D3DI_SPTFMT_PALETTE8 == pCtx->iSurfaceType)
    {
        // 8 bit surfaces no longer supported by DX7
        // AnanKan: Need to return a proer error message.
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroy
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// ValidateTextureStageState
//
// Utility function that returns an appropriate D3DERR_ if the current
// multi-texture setup can not be rendered, D3D_OK otherwise.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::ValidateTextureStageState(void)
{
#if DBG
    if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
        (m_RastCtx.pTexture[0] != NULL) )
    {
        // except under very special circumstances, this will not work in RGB/MMX
        // since we keep a lot of stage state in the D3DI_SPANTEX structure
        D3D_ERR("(Rast) ValidateTextureStageState Warning, pTexture[0] == pTexture[1]");
    }
#endif
    for (INT i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLOROP])
        {
        default:
            return D3DERR_UNSUPPORTEDCOLOROPERATION;
        case D3DTOP_DISABLE:
            return D3D_OK;  // don't have to validate further if the stage is disabled
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
        case D3DTOP_ADDSIGNED2X:
        case D3DTOP_SUBTRACT:
        case D3DTOP_ADDSMOOTH:
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG1] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TEXTURE):
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG2] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TFACTOR):
        case (D3DTA_CURRENT):
        case (D3DTA_DIFFUSE):
        case (D3DTA_SPECULAR):
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAOP])
        {
        default:
            return D3DERR_UNSUPPORTEDALPHAOPERATION;
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
        case D3DTOP_ADDSIGNED2X:
        case D3DTOP_SUBTRACT:
        case D3DTOP_ADDSMOOTH:
            // only validate alpha args if alpha op is not disable
            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG1] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG2] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
            case (D3DTA_SPECULAR):
                break;
            }
            break;
        }

    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastValidateTextureStageState
//
// Returns whether the current multitexture setup can be rendered and, if
// so, the number of passes required to render it.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;

    pData->ddrval = pDCtx->ValidateTextureStageState();

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastSetRenderTarget
//
// Update a rast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastSetRenderTarget", pTgtData);

    pTgtData->ddrval = pDCtx->FillContext(pTgtData->lpDDS, pTgtData->lpDDSZ);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// SetRenderState
//
// Check to see if a state change requires an update to the D3DCTX.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetRenderState(UINT32 uState, UINT32 uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(uState);

    m_RastCtx.pdwRenderState[uState] = uStateVal;

    switch(uState)
    {
    case D3DRENDERSTATE_FOGENABLE      :
    case D3DRENDERSTATE_FOGCOLOR       :
    case D3DRENDERSTATE_FOGTABLEMODE   :
    case D3DRENDERSTATE_FOGTABLESTART  :
    case D3DRENDERSTATE_FOGTABLEEND    :
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        break;
    case D3DRENDERSTATE_CULLMODE:
        // Set face culling sign from state.
        switch(uStateVal)
        {
        case D3DCULL_CCW:
            m_RastCtx.uCullFaceSign = 1;
            break;
        case D3DCULL_CW:
            m_RastCtx.uCullFaceSign = 0;
            break;
        case D3DCULL_NONE:
            m_RastCtx.uCullFaceSign = 2;
            break;
        }
        break;
    case D3DRENDERSTATE_ZENABLE:
        if ( (D3DZB_FALSE != uStateVal) && (NULL == m_RastCtx.pDDSZ) )
        {
            DPF(0, "(ERROR) (Rast) SetRenderState: Can't set D3DRENDERSTATE_ZENABLE to %d if there is no Z Buffer", uStateVal);
            m_RastCtx.pdwRenderState[uState] = D3DZB_FALSE;
        }
        break;
    case D3DRENDERSTATE_LASTPIXEL:
        // Set last-pixel flag from state.
        if (uStateVal)
        {
            m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        else
        {
            m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        break;


        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESS] =
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSU] =
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSU] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPMAPLODBIAS] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_BORDERCOLOR] = uStateVal;
        MapTextureStageState(0);
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        // assign to current texture
        MapTextureStageState(0);
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy WRAPU/V to per-index controls
    case D3DRENDERSTATE_WRAPU:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_U : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_V : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;

//
// NOTE - this compututation of cActTex does not account for blend-only stages
//
    case D3DRENDERSTATE_TEXTUREHANDLE:

        CHECK_AND_UNLOCK_TEXTURE;

        // map handle thru to stage 0
        m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXTUREMAP] = uStateVal;
        m_RastCtx.pTexture[1] = NULL;
        // set up for single stage
        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[0] = NULL;
        }
        else
        {
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }
        // map stage 0 state to first texture
        MapTextureStageState(0);
        UpdateActiveTexStageCount();
        break;

    }

    return D3D_OK;
}

HRESULT
D3DContext::SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(RAST_TSS_DIRTYBIT(dwStage, dwState));

    m_RastCtx.pdwTextureStageState[dwStage][dwState] = uStateVal;
    switch (dwState)
    {
    case D3DTSS_TEXTUREMAP:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            if (dwStage == 0)
            {
                if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == 0 )
                {
                    m_RastCtx.pTexture[0] = NULL;
                }
            }
            else
            {
                m_RastCtx.pTexture[dwStage] = NULL;
            }
            // disables higher stages also, but don't clear pTexture[i]'s
            // since they may be used later when this stage is set to non-NULL
        }
        else
        {
            // if lower stages are null, this will be noted by UpdateActiveTexStageCount
            m_RastCtx.pTexture[dwStage] = HANDLE_TO_SPANTEX(uStateVal);
        }

#if DBG
        if (m_RastCtx.pTexture[dwStage])
        {
            int iTexCount = 0;
            for (int i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
            {
                if (m_RastCtx.pTexture[dwStage] == m_RastCtx.pTexture[i])
                {
                    iTexCount ++;
                }
            }
            if (iTexCount > 1)
            {
                D3D_ERR( "Same texture handle was used more than once." );
                return DDERR_INVALIDPARAMS;
            }
        }
#endif
        // map stage state to texture
        MapTextureStageState(dwStage);
        UpdateActiveTexStageCount();
        break;

    // map single set ADDRESS to both U and V controls for stages 0 & 1
    case D3DTSS_ADDRESS:
        m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU] = uStateVal;
        m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(dwStage);
        break;
    case D3DTSS_ADDRESSU:
    case D3DTSS_ADDRESSV:
    case D3DTSS_MIPMAPLODBIAS:
    case D3DTSS_MAXMIPLEVEL:
    case D3DTSS_BORDERCOLOR:
    case D3DTSS_MAGFILTER:
    case D3DTSS_MINFILTER:
    case D3DTSS_MIPFILTER:
         MapTextureStageState(dwStage);
        break;
    case D3DTSS_COLOROP:
    case D3DTSS_COLORARG1:
    case D3DTSS_COLORARG2:
    case D3DTSS_ALPHAOP:
    case D3DTSS_ALPHAARG1:
    case D3DTSS_ALPHAARG2:
        // anything that effects the validity of the texture blending
        // could change the number of active texture stages
        UpdateActiveTexStageCount();
        break;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is at most one.
//
//-----------------------------------------------------------------------------
HRESULT D3DContext::UpdateActiveTexStageCount( void )
{
    HRESULT hr;
    UINT cNewActTex = 0;

    // conservative but correct
    if ((hr = ValidateTextureStageState()) == D3D_OK)
    {
        // always one active texture stage for legacy texture mode
        if ( NULL != m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
        {
            cNewActTex = 1;
        }
        else
        {
            // count number of contiguous-from-zero active texture blend stages
            for ( INT iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
            {
                // check for disabled stage (subsequent are thus inactive)
                // also conservatively checks for incorrectly enabled stage (might be legacy)
                if ( ( m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP] == D3DTOP_DISABLE ) ||
                     ( m_RastCtx.pTexture[iStage] == NULL ) )
                {
                    break;
                }

                // stage is active
                cNewActTex ++;
            }
        }
    }
    if (m_RastCtx.cActTex != cNewActTex)
    {
        CHECK_AND_UNLOCK_TEXTURE;
        StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
        m_RastCtx.cActTex = cNewActTex;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// UpdateRenderStates
//
// Update a list of render states and notify components of state change.
//
//----------------------------------------------------------------------------
HRESULT D3DContext::
UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges)
{
    HRESULT hr;
    INT i;
    UINT32 State, StateVal;

    if (cStateChanges == 0)
    {
        return D3D_OK;
    }

    // Update the D3DCTX
    for (i = 0; i < (INT)cStateChanges; i++)
    {
        State = *puStateChange ++;
        StateVal = * puStateChange++;
        HR_RET(SetRenderState(State, StateVal));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdateAllRenderStates
//
// Update all render states.
// It is still kept here because we probably need it in the case of fail-over.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::UpdateAllRenderStates(LPDWORD puStates)
{
    HRESULT hr, hrSet;
    INT i;

    DDASSERT(puStates != NULL);

    // Update D3DCTX.
    // Attempt to set as many states as possible, even if there are
    // errors on some.  This allows context initialization to work
    // even though some of the states fail due to dependencies on
    // other state, such as active texture handles.
    // SetRenderState failures are noted and returned eventually,
    // even if everything else succeeds.
    hrSet = D3D_OK;
    for (i = 0; i < D3DHAL_MAX_RSTATES_AND_STAGES; i++)
    {
        if ((hr = SetRenderState(i, puStates[i])) != D3D_OK)
        {
            hrSet = hr;
        }
    }

    return hrSet;
}

//----------------------------------------------------------------------------
//
// Dp2SetRenderStates
//
// Called by Drawprim2 to set render states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

            // Set the state
        HR_RET(SetRenderState(pRenderState->RenderState,
                            pRenderState->dwState));
    }

    hr = Begin();
    return hr;
}
//----------------------------------------------------------------------------
//
// Begin - Before rendering preparation
//
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Begin(void)
{
    HRESULT hr;

    DDASSERT((m_uFlags & D3DCONTEXT_IN_BEGIN) == 0);

    // ATTENTION call this less often?
    UpdateColorKeyAndPalette();

    // Check for state changes
    if (IsAnyStatesChanged())
    {
        // Check for fillmode change
        if (IsStateChanged(D3DRENDERSTATE_FILLMODE))
        {
            UpdatePrimFunctionTbl();
        }

        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }

        if (IsStateChanged(D3DRENDERSTATE_TEXTUREHANDLE) ||
            IsStateChanged(RAST_TSS_DIRTYBIT(0, D3DTSS_TEXTUREMAP)) ||
            IsStateChanged(RAST_TSS_DIRTYBIT(1, D3DTSS_TEXTUREMAP)) ||
            bMaxMipLevelsDirty)
        {
            // Relock texture if texture handles have changed.
            // SetRenderState should have already unlocked the texture.
            if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)
            {
                RastUnlockSpanTexture();
            }
            HR_RET(RastLockSpanTexture());
        }

        // Check for WRAP state change
        for (int iWrap=0; iWrap<8; iWrap++)
        {
            D3DRENDERSTATETYPE iWrapState = (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+iWrap);
            if (IsStateChanged(iWrapState))
            {
                int i;
                for (i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (m_fvfData.TexIdx[i] == iWrap)
                    {
                        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[iWrapState];
                    }
                }
            }
        }

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Clear state dirtybits
        ClearAllStatesDirtyBits();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        HR_RET(SpanInit(&m_RastCtx));
    }

    // If texture is not locked yet, lock it
    if (!(m_uFlags & D3DCONTEXT_TEXTURE_LOCKED))
    {
        HR_RET(RastLockSpanTexture());
    }

    // Lock rendering target.
    if ((hr=LockSurface(m_RastCtx.pDDS, (LPVOID *)&(m_RastCtx.pSurfaceBits))) != D3D_OK)
    {
        RastUnlockSpanTexture();
        return hr;
    }
    if (m_RastCtx.pDDSZ != NULL)
    {
        if ((hr=LockSurface(m_RastCtx.pDDSZ, (LPVOID *)&(m_RastCtx.pZBits))) != D3D_OK)
        {
            RastUnlockSpanTexture();
            UnlockSurface(m_RastCtx.pDDS);
            return hr;
        }
    }
    else
    {
        m_RastCtx.pZBits = NULL;
    }

    // Prepare the primitive processor
    m_PrimProc.Begin();
    m_uFlags |= D3DCONTEXT_IN_BEGIN;

    return D3D_OK;

}


//-----------------------------------------------------------------------------
//
// MapTextureStageState - Maps statestage texture state to spantex object
//
//-----------------------------------------------------------------------------
void
D3DContext::MapTextureStageState( DWORD dwStage )
{
    if (m_RastCtx.pTexture[dwStage] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[dwStage]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
    m_RastCtx.pTexture[dwStage]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
    m_RastCtx.pTexture[dwStage]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
    m_RastCtx.pTexture[dwStage]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
    m_RastCtx.pTexture[dwStage]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
    m_RastCtx.pTexture[dwStage]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
    m_RastCtx.pTexture[dwStage]->fLODBias = m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

    if (m_RastCtx.pTexture[dwStage]->iMaxMipLevel != (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
    {
        m_RastCtx.pTexture[dwStage]->iMaxMipLevel = (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
        m_RastCtx.pTexture[dwStage]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter -
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureFilter( void )
{
    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MAGFILTER] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_RastCtx.pdwTextureStageState[1][D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }

    // since we change [D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP), we can go from DISABLE to
    // something else, and we can need to update the TexStageCount
    UpdateActiveTexStageCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\d3dif.cpp ===
//----------------------------------------------------------------------------
//
// d3dif.cpp
//
// shared interface functions
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to D3DI_SPANTEX_FORMAT.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = D3DI_SPTFMT_Z16S0; break;
        case 0xFFFFFF00: *pFmt = D3DI_SPTFMT_Z24S8; break;
        case 0x0000FFFE: *pFmt = D3DI_SPTFMT_Z15S1; break;
        case 0xFFFFFFFF: *pFmt = D3DI_SPTFMT_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = D3DI_SPTFMT_U8V8L8;
                break;
            case 16:
                *pFmt = D3DI_SPTFMT_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = D3DI_SPTFMT_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = D3DI_SPTFMT_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = D3DI_SPTFMT_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = D3DI_SPTFMT_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = D3DI_SPTFMT_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = D3DI_SPTFMT_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = D3DI_SPTFMT_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = D3DI_SPTFMT_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = D3DI_SPTFMT_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = D3DI_SPTFMT_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = D3DI_SPTFMT_B8G8R8X8;
                break;
            case 24:
                *pFmt = D3DI_SPTFMT_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = D3DI_SPTFMT_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = D3DI_SPTFMT_B5G5R5A1;
            }
            else
            {
                *pFmt = D3DI_SPTFMT_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = D3DI_SPTFMT_B5G5R5;
            break;
        case 0xff0:
            *pFmt = D3DI_SPTFMT_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = D3DI_SPTFMT_B4G4R4A4;
            break;
        case 0xff:
            *pFmt = D3DI_SPTFMT_L8;
            break;
        case 0xffff:
            *pFmt = D3DI_SPTFMT_L8A8;
            break;
        case 0xfc:
            *pFmt = D3DI_SPTFMT_B2G3R3;
            break;
        default:
            *pFmt = D3DI_SPTFMT_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   22

int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType)
{
    int i = 0;

    if (RastType == SW_RAST_MMX && dwVersion < 3)
    {
        static DDSURFACEDESC mmx_ddsd[1];

        /* pal8 */
        mmx_ddsd[i].dwSize = sizeof(mmx_ddsd[0]);
        mmx_ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        mmx_ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        mmx_ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        mmx_ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
        mmx_ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

        i++;

        *lplpddsd = mmx_ddsd;

        return i;
    }

    static DDSURFACEDESC ddsd_RGBMMX_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (dwVersion >= 3)
    {
        ddsd = ddsd_RGBMMX_Dev3;
    }
    else
    {
        ddsd = ddsd_RGBMMX_Dev2;
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    if (dwVersion >= 3)
    {
        /* 1555 */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

        i++;

        // A formats for PC98 consistency
        // 4444 ARGB (it is already supported by S3 Virge)
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

        i++;
    }

    if ((dwVersion >= 2) && (RastType == SW_RAST_REFNULL))
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;
    }

    *lplpddsd = ddsd;

    return i;
}

//----------------------------------------------------------------------------
//
// ZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_ZBUFFER_FORMATS   4

int
ZBufferFormats(DDPIXELFORMAT** ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    *ppDDPF = DDPF;

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\d3dif.hpp ===
//----------------------------------------------------------------------------
//
// d3dif.hpp
//
// D3D front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DIF_HPP_
#define _D3DIF_HPP_

#include <setup.hpp>

// For Primitive function prototypes.
#include <pmfns_mh.h>

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32

// Flags for uflags of D3DContex
#define D3DCONTEXT_IN_BEGIN             0x0001
#define D3DCONTEXT_TEXTURE_LOCKED       0x0002
#define D3DCONTEXT_APPHACK_MSGOLF       0x0004

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// Note: This must be replicated in ddraw\ddd3dapi.h so DDHEL can pick them up
//       It only affect what legacy apps see when using GetCaps or EnumDevices,
//       internally ZBufferFormats() is checked when on ZBuffer creation.
//       Note stencil formats should have no representation in this flag word
//       becase legacy apps will be fooled into trying to create a Z-only surface
//       at the DDBD bitdepth and fail.   New apps should ignore dwDeviceZBufferBitDepth
//       and use EnumZBufferFormats

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

// Macros used to access DDRAW surface info.
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDS) \
    (!(((LPDDRAWI_DDRAWSURFACE_INT) (pDDS))->lpLcl->lpGbl->dwGlobalFlags & \
    DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDS) \
    (((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl->lpGbl->dwUsageCount > 0)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                           \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

// Triangle/Line/Point function
typedef HRESULT (*PFN_TRIANGLE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1,
                                PUINT8 pV2,
                                WORD wFlags =
                                  D3DTRIFLAG_EDGEENABLE1 |
                                  D3DTRIFLAG_EDGEENABLE2 |
                                  D3DTRIFLAG_EDGEENABLE3 );
typedef HRESULT (*PFN_POINT)(LPVOID pCtx, PUINT8 pV0);
typedef HRESULT (*PFN_LINE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1);
typedef void (*PFN_STORELASTPIXELSTATE)(LPVOID pCtx, BOOL bStore);
typedef HRESULT (*PFN_DP2SETRENDERSTATES)(LPVOID pCtx,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2TEXTURESTAGESTATE)(LPVOID pCtx,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);

typedef HRESULT (*PFN_DP2SETVIEWPORT)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2SETWRANGE)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);

typedef struct _PRIMITIVE_FUNTIONS
{
    PFN_TRIANGLE pfnTri;
    PFN_POINT pfnPoint;
    PFN_LINE pfnLine;
    PFN_STORELASTPIXELSTATE pfnStoreLastPixelState;
    PFN_DP2SETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2TEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2SETVIEWPORT pfnDp2SetViewport;
    PFN_DP2SETWRANGE pfnDp2SetWRange;
}PRIMITIVE_FUNTIONS;

typedef enum _SW_RAST_TYPE
{
    SW_RAST_REFNULL = 1,
    SW_RAST_RGB = 2,
    SW_RAST_MMX = 3,
    SW_RAST_MMXASRGB = 4,
}SW_RAST_TYPE;

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex[D3DHAL_TSS_MAXSTAGES];

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[D3DHAL_TSS_MAXSTAGES];
    UINT cActTex;
}FVFDATA;

// Class used for the context returned to D3DIM.
class D3DContext
{
public:
    D3DI_RASTCTX m_RastCtx;

    // InBegin and TextureLockd flags
    // TextureLockd bit is set/cleared by texture Lock/Unlock functions.
    // It is used by texture Lock/Unlock and Begin functions.
    // InBegin bit is set by Begin and cleared by End
    unsigned short m_uFlags;

    // This is init'ed according to the fill mode.
    // It is init'ed after state change and before rendering
    PRIMITIVE_FUNTIONS m_fnPrims;

    // Used to store the old last pixel setting when drawing line strips.
    UINT uOldFlags;

    inline BOOL IsTextureOff(void);

    inline void UpdatePrimFunctionTbl(void);    // Init m_pfnTri
    inline BOOL IsAnyStatesChanged(void);
    inline BOOL IsStateChanged(UINT32 uState);
    inline void StateChanged(UINT32 uState);
    inline void SetAllStatesDirtyBits(void);
    inline void ClearAllStatesDirtyBits(void);
    inline void ClearStateDirtyBit(UINT32 uState);

    // FVF stuff
    FVFDATA m_fvfData;


#if DBG
    inline HRESULT ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType);
#endif

    PrimProcessor m_PrimProc;

    UINT32 dwSize;

    D3DContext(void){};
    ~D3DContext(void){};

    HRESULT Initialize(LPDIRECTDRAWSURFACE pDDS,
        LPDIRECTDRAWSURFACE pDDSZ, DWORD BeadSet, DWORD devVer);
    HRESULT FillContext(LPDIRECTDRAWSURFACE pDDS, LPDIRECTDRAWSURFACE pDDSZ);
    HRESULT SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt);
    HRESULT TextureSetState(PD3DI_SPANTEX pSpanTex, DWORD dwState, DWORD dwValue);
    HRESULT ValidateTextureStageState(void);
    HRESULT UpdateActiveTexStageCount(void);

    inline PD3DI_RASTCTX GetRastCtx(void){return &m_RastCtx;};

    HRESULT Begin(void);
    inline HRESULT End(BOOL bNotFlush = TRUE);
    inline void BeginPrimSet(D3DPRIMITIVETYPE PrimType, RAST_VERTEX_TYPE VertType)
        {m_PrimProc.BeginPrimSet(PrimType, VertType);};
    inline void StoreLastPixelState(BOOL bStore);
    inline PRIMITIVE_FUNTIONS *GetFunsTbl(void){return &m_fnPrims;};

    void RastUnlockSpanTexture(void);
    HRESULT RastLockSpanTexture(void);
    void UpdateColorKeyAndPalette(void);
    void RemoveTexture(PD3DI_SPANTEX pSpanTex);
    HRESULT InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS);
    HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex);

    HRESULT SetRenderState(UINT32 uState, UINT32 uStateVal);
    HRESULT UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges);
    HRESULT UpdateAllRenderStates(LPDWORD puStates);
    HRESULT SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD uStateVal);
    HRESULT Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf);
    void MapTextureStageState( DWORD dwStage );
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

    inline HRESULT CheckDrawOnePrimitive(
        LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);
    inline HRESULT CheckDrawOneIndexedPrimitive(
        LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData);
    inline HRESULT DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
    inline HRESULT DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);

    // Check if a triangle is culled or not. It's only used for wireframe and
    // point mode. It's done in PrimProc.Tri for solid mode.
    inline BOOL NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                                             LPD3DTLVERTEX pV2);

    // FVF stuff
    HRESULT FASTCALL CheckFVF(DWORD dwFVF);
    void FASTCALL PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx);
    inline UINT16 GetFvfStride(void){return m_fvfData.stride;};
    inline RAST_VERTEX_TYPE GetFvfVertexType(void){return m_fvfData.vtxType;};

    inline void BeginSceneHook(void);
    inline void EndSceneHook(void);
};

inline void D3DContext::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        uOldFlags = m_PrimProc.GetFlags();
        m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
    }
    else
    {
        m_PrimProc.SetFlags(uOldFlags & PPF_DRAW_LAST_LINE_PIXEL);
    }
}

inline BOOL D3DContext::NotCulled(LPD3DTLVERTEX pV0,
              LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
{
    if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE)
    {
        return TRUE;
    }

    FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;

    x1 = pV0->sx;
    y1 = pV0->sy;
    x2x1 = pV1->sx - x1;
    y2y1 = pV1->sy - y1;
    x3x1 = pV2->sx - x1;
    y3y1 = pV2->sy - y1;

    fDet = x2x1 * y3y1 - x3x1 * y2y1;

    if (0. == fDet)
    {
        return FALSE;
    }
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] )
    {
    case D3DCULL_CW:
        if ( fDet > 0.f )
        {
            return FALSE;
        }
        break;
    case D3DCULL_CCW:
        if ( fDet < 0.f )
        {
            return FALSE;
        }
        break;
    }
    return TRUE;
}
// Update m_pfnPrims according to the current fill mode, device type
// and vertextype. It's called when fill mode or FVF type chang.
inline void D3DContext::UpdatePrimFunctionTbl(void)
{
    if (m_fvfData.vtxType == RAST_GENVERTEX)
    {
        m_fnPrims.pfnPoint = RGB_PointPack;
        m_fnPrims.pfnLine = RGB_LinePack;
    }
    else
    {
        m_fnPrims.pfnPoint = RGB_PointNoPack;
        m_fnPrims.pfnLine = RGB_LineNoPack;
    }
    switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
    {
    case D3DFILL_POINT:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackPoint;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackPoint;
        }
        break;
    case D3DFILL_WIREFRAME:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackWireframe;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackWireframe;
        }
        break;
        break;
    case D3DFILL_SOLID:
    default:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackSolid;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackSolid;
        }
        break;
    }
}

// The following inline functions are provided to manipulate StatesDirtyBits.
// StatesDirtyBits is used to store one dirty bit for each render state. It
// contains (D3DHAL_MAX_RSTATES_AND_STAGES>>3+1) bytes.
// For a particular state, say uState,
// it is represented by i'th bit of j'th byte, where i=(uState & 7) and
// j=uState>>3. So,
// StatesDirtyBits[uState>>3]&(1<<(uState&7)) gives the bit info. for uState
// StatesDirtyBits[uState>>3] |= (1<<(uState&7)) sets the bit to 1
// StatesDirtyBits[uState>>3] &= ~(1 <<(uState&7)) clears the bit to 0

// Check if any render states have changed. The info. is stored in the bit
// corresponding to D3DHAL_MAX_RSTATES_AND_STAGES.
inline BOOL D3DContext::IsAnyStatesChanged()
{
    return (m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] &
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7)));
}
// Check if uState has changed.
inline BOOL D3DContext::IsStateChanged(UINT32 uState)
{
    return (m_RastCtx.StatesDirtyBits[uState>>3] & (1<<(uState & 7)));
};

// uState has changed so set the according dirty bit and the AnyStates bit.
inline void D3DContext::StateChanged(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] |= (1<<(uState & 7));
    m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] |=
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7));
};

// Called after bead chooser to clear all the dirty bits.
inline void D3DContext::ClearAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 0, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Called at context creation time to set all the dirty bits.
inline void D3DContext::SetAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 7, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Clear the dirty bit corresponding to uState.
inline void D3DContext::ClearStateDirtyBit(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] &= ~(1 << (uState & 7));
}
inline BOOL D3DContext::IsTextureOff(void)
{
    return
        (m_RastCtx.cActTex == 0 ||
        (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
        (m_RastCtx.cActTex == 2 &&
         (m_RastCtx.pTexture[0] == NULL ||
          m_RastCtx.pTexture[1] == NULL)));
}
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

// Lock surfaces before rendering
inline HRESULT LockSurface(LPDIRECTDRAWSURFACE pDDS, LPVOID *ppData)
{
    if (pDDS)
    {
        if (!VIDEO_MEMORY(pDDS))
        {
            if (SURFACE_LOCKED(pDDS))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDS);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                LPDDRAWI_DDRAWSURFACE_INT lpInt;

                lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
                ddrval = DDInternalLock(lpInt->lpLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDIRECTDRAWSURFACE pDDS)
{
    if (pDDS && VIDEO_MEMORY(pDDS))
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;

        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        DDInternalUnlock(lpInt->lpLcl);
    }
}
// After rendering cleanup: flush primitive processor, unlock textures
inline HRESULT
D3DContext::End(BOOL bNotFlush)
{
    if (m_uFlags & D3DCONTEXT_IN_BEGIN)
    {
        HRESULT hr = m_PrimProc.End();

        // Unlock texture if this is not called in the middle of drawPrims to
        // flush for possible state changes. In the 2nd case, let
        // SetRenderState to handle it.
        if (bNotFlush)
        {
            RastUnlockSpanTexture();
        }

        // Unlock surfaces
        UnlockSurface(m_RastCtx.pDDS);
        if (m_RastCtx.pDDSZ != NULL)
        {
            UnlockSurface(m_RastCtx.pDDSZ);
        }

        m_uFlags &= ~D3DCONTEXT_IN_BEGIN;
        return (hr);
    }
    else
    {
        // In the case of DrawPrims being called just to set render states,
        // Begin is actually not called.
        return D3D_OK;
    }
}

// Following primitive functions are shared by RGB/REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags);
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(LPVOID pCtx,
                  PRIMITIVE_FUNTIONS *pfnPrims,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
                  );


inline HRESULT
D3DContext::DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOnePrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    PrimType,
                                    cVertices);

}

inline HRESULT
D3DContext::DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOneIndexedPrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    puIndices,
                                    PrimType,
                                    cIndices);
}

// Macros to check if a pointer is valid
#if DBG
#define VALID_D3DCONTEX_PTR(pDCtx)  ((pDCtx)->dwSize == sizeof(D3DContext))
#define VALID_D3DI_RASTCTX_PTR(pRastCtx) \
            ((pRastCtx)->dwSize == sizeof(D3DI_RASTCTX))
#define VALID_D3DI_SPANTEX_PTR(pSpanTex) \
            ((pSpanTex)->dwSize == sizeof(D3DI_SPANTEX))
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex) \
            ((ppSpanTex) && VALID_D3DI_SPANTEX_PTR(*(ppSpanTex)))
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        D3D_INFO(0, "in %s, data pointer = NULL", (caller_name));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        D3D_INFO(0, "in %s, dwhContext = NULL", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
#define VALID_D3DCONTEX_PTR(pDCtx)              1
#define VALID_D3DI_RASTCTX_PTR(pRastCtx)        1
#define VALID_D3DI_SPANTEX_PTR(pSpanTex)        1
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex)   1
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate D3DCxt. pDCtx should be declared before this macro
#define VALIDATE_D3DCONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pDCtx, D3DContext*); \
    if (!VALID_D3DCONTEX_PTR(pDCtx) ||  \
        !VALID_D3DI_RASTCTX_PTR((pDCtx)->GetRastCtx()))    \
    {   \
        D3D_INFO(0, "in %s, invalid dwhContext", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt);

extern int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType);

extern int
ZBufferFormats(DDPIXELFORMAT** ppDDPF);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData);

DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData);

DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf);

DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData);

DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData);

DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);

DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData);

DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData);

DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD __stdcall
RastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

#endif // #ifndef _D3DIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// CheckFVF
//
// Check a FVF control word and then init m_fvfData accordingly
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
D3DContext::CheckFVF(DWORD dwFVF)
{
    // check if FVF controls have changed
    if ( (m_fvfData.preFVF == dwFVF) &&
         (m_fvfData.TexIdx[0] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[1] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[1][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[2] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[2][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[3] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[3][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[4] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[4][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[5] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[5][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[6] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[6][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[7] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[7][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.cActTex == m_RastCtx.cActTex) )
    {
        return D3D_OK;
    }
#if DBG
    // This is added here per Iouri's request. It will make it easier for him
    // to test his code for legacy drivers.
    if (dwFVF == 0)
    {
        dwFVF = D3DFVF_TLVERTEX;
    }
#endif

    memset(&m_fvfData, 0, sizeof(FVFDATA));
    m_fvfData.preFVF = dwFVF;
    INT32 i;
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_fvfData.TexIdx[i] = 0xffff&m_RastCtx.pdwTextureStageState[i][D3DTSS_TEXCOORDINDEX];
    }
    m_fvfData.cActTex = m_RastCtx.cActTex;

#if DBG
    // We only support max 8 texture coords
    if (m_fvfData.TexIdx[0] > 7 || m_fvfData.TexIdx[1] > 7)
    {
        D3D_WARN(0, "(Rast) Texture coord index bigger than max supported.");
        return DDERR_INVALIDPARAMS;
    }
#endif

    // Update the copy of wrap states in RastCtx
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[i])];
    }

    // do either true FVF parsing or legacy TLVERTEX handling
    if ( (m_RastCtx.BeadSet != D3DIBS_RAMP) &&
         ( (dwFVF != D3DFVF_TLVERTEX) ||
           (0 != m_fvfData.TexIdx[0]) ||
           (m_RastCtx.cActTex > 1) ) )
    {   // New (non TL)FVF vertex
        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
#if DBG
        INT iTexIdx0 = m_fvfData.TexIdx[0], iTexIdx1 = m_fvfData.TexIdx[1];
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                INT iTexIdx = m_fvfData.TexIdx[i];
               if ( iTexIdx >= iTexCount)
               {
                   D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                   iTexIdx = 0;
               }
               m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                   2*sizeof(D3DVALUE)*iTexIdx);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#else
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[i]);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#endif

        m_fvfData.vtxType = RAST_GENVERTEX;
    }
    else
    {
        // (Legacy) TL vertex
        if (0 < m_fvfData.TexIdx[0])
        {
            D3D_ERR("(Rast) Texture coord index bigger than 0 for legacy TL vertex.");
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DTLVERTEX);
        m_fvfData.vtxType = RAST_TLVERTEX;
    }

    UpdatePrimFunctionTbl();

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PackGenVertex
//
// Pack a FvFVertex into RAST_GENERIC_VERTEX. This is called for every non TL
// FVF vertex. It can be optimized for speed later.
//
//----------------------------------------------------------------------------
void FASTCALL
D3DContext::PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
{
    pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
    pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
    pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
    if (m_fvfData.offsetRHW)
    {
        pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
    }
    else
    {
        pGenVtx->rhw = 1.0f;
    }
    if (m_fvfData.offsetDiff)
    {
        pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
    }
    else
    {
        pGenVtx->color = __DEFAULT_DIFFUSE;
    }
    if (m_fvfData.offsetSpec)
    {
        pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
    }
    else
    {
        pGenVtx->specular = __DEFAULT_SPECULAR;
    }
    for (INT32 i = 0; i < (INT32)m_fvfData.cActTex; i++)
    {
       if (m_fvfData.offsetTex[i])
       {
           pGenVtx->texCoord[i].tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]));
           pGenVtx->texCoord[i].tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]) + 1);
       }
       else
       {
           pGenVtx->texCoord[i].tu = 0.0f;
           pGenVtx->texCoord[i].tv = 0.0f;
       }
    }
}

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            HR_RET(pfnPrims->pfnPoint(pCtx, pVtx));
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }

            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnPoint(pCtx, pV0));
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }
            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
        return D3D_OK;
    }
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1));
        }
        else
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, 0));
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));

    return D3D_OK;
}

#if DBG
//----------------------------------------------------------------------------
//
// ValidatePrimType
//
// Check if the primitive type is supported. We could remove this function
// after we have implemented all primitive types and then depend on D3DIM
// to check if the primitive type is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType)
{
    switch(PrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        break;
    default:
        D3D_ERR("(Rast) PrimitiveType not supported by the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//----------------------------------------------------------------------------
//
// CheckDrawOnePrimitive
//
// Check if the DRAWONEPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
#if DBG
    HRESULT hr;

    if (pOnePrimData == NULL ||
        pOnePrimData->dwhContext == 0 ||
        pOnePrimData->lpvVertices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOnePrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CheckDrawOneIndexedPrimitive
//
// Check if the DRAWONEINDEXEDPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOneIndexedPrimitive(
                         LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData)
{
#if DBG
    HRESULT hr;

    if (pOneIdxPrimData == NULL ||
        pOneIdxPrimData->dwhContext == 0 ||
        pOneIdxPrimData->lpvVertices == NULL ||
        pOneIdxPrimData->lpwIndices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOneIdxPrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval =
        pDCtx->CheckDrawOnePrimitive(pOnePrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOnePrimData->ddrval, pDCtx, (DWORD)pOnePrimData->dwFVFControl);

    pOnePrimData->ddrval = pDCtx->Begin();
    if (pOnePrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOnePrimData->ddrval =
        pDCtx->DrawOnePrimitive((PUINT8)pOnePrimData->lpvVertices,
                         pOnePrimData->PrimitiveType,
                         pOnePrimData->dwNumVertices);

    hr = pDCtx->End();
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOneIndexedPrimitive", pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval =
         pDCtx->CheckDrawOneIndexedPrimitive(pOneIdxPrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOneIdxPrimData->ddrval, pDCtx, (DWORD)pOneIdxPrimData->dwFVFControl);

    pOneIdxPrimData->ddrval = pDCtx->Begin();
    if (pOneIdxPrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
        pDCtx->DrawOneIndexedPrimitive((PUINT8)pOneIdxPrimData->lpvVertices,
                                pOneIdxPrimData->lpwIndices,
                                pOneIdxPrimData->PrimitiveType,
                                pOneIdxPrimData->dwNumIndices);

    hr = pDCtx->End();
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;

    // Check for FVF vertex when there are actually something to be drawn, and
    // init FVF related fileds if necessary Assume the control word is passed
    // in through dwReserved
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        CHECK_FVF(pDrawPrimData->ddrval, pDCtx, pDrawPrimData->dwFVFControl);
    }

    // Skip state check and texture lock if the first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges == 0)
    {
        pDrawPrimData->ddrval =pDCtx->Begin();
        if (pDrawPrimData->ddrval != D3D_OK)
        {
            goto EH_Exit;
        }
    }

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        //
        // Update render states
        //

        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // Flush the prim proc before any state changs
            pDrawPrimData->ddrval = pDCtx->End(FALSE);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                return DDHAL_DRIVER_HANDLED;
            }

            pDrawPrimData->ddrval =
                pDCtx->UpdateRenderStates((LPDWORD)pData,
                                   pDrawPrimitiveCounts->wNumStateChanges);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
            ((UINT_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // Delayed change until we really need to render something
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // We might have a new texture so lock.
            pDrawPrimData->ddrval = pDCtx->Begin();
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }
        }

        //
        // Primitives
        //
        pDrawPrimData->ddrval =
            pDCtx->DrawOnePrimitive((PUINT8)pData,
                        (D3DPRIMITIVETYPE)pDrawPrimitiveCounts->wPrimitiveType,
                        pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_Exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * pDCtx->GetFvfStride();
    }

 EH_Exit:
    HRESULT hr;

    hr = pDCtx->End();

    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rendprim.cpp ===
//----------------------------------------------------------------------------
//
// rendprim.cpp
//
// RastRenderState and RastRenderPrimitive.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            HR_RET(pfnPrims->pfnPoint(pCtx, (PUINT8)pV));
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        HR_RET(pfnPrims->pfnLine(pCtx, (PUINT8)pV0, (PUINT8)pV1));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        HR_RET(pfnPrims->pfnTri(pCtx, (PUINT8)pV0, (PUINT8)pV1, 
                                (PUINT8)pV2, pTri->wFlags));
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderPrimitive", pRenderData);

    if (pDCtx->GetRastCtx()->pdwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(DDS_LCL(pRenderData->lpExeBuf)->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)
                ((PUINT8)DDS_LCL(pRenderData->lpTLBuf)->lpGbl->fpVidMem
                + pRenderData->dwTLOffset);

    pRenderData->ddrval = pDCtx->Begin();
    if (pRenderData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pDCtx->BeginPrimSet(D3DPT_POINTLIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendPoints((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pDCtx->BeginPrimSet(D3DPT_LINELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendLines((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pDCtx->BeginPrimSet(D3DPT_TRIANGLELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendTriangles((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DTRIANGLE)pPrim);
        break;
    default:
        D3D_ERR("(Rast) Wrong Opcode passed to the new rasterizer.");
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr;

    hr = pDCtx->End();
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderState", pStateData);

    // Updates D3DCTX
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
        (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
         i < (INT)pStateData->dwCount;
         i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Set the state
        pStateData->ddrval = pDCtx->SetRenderState(type, pState->dwArg[0]);
        if (pStateData->ddrval != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\sources.inc ===
TARGETNAME = rd3dif
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\..\ref\rast;..\..\..\ref\inc;$(D3DDX7)\tnl;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        ..\d3dif.cpp\
        ..\swprov.cpp\
        ..\drawprim.cpp\
        $O\dprim2.cpp\
        ..\rendprim.cpp\
        ..\rastctx.cpp\
        ..\rasttex.cpp\
        $O\pmfns.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\pmfns_mh.h\
        $O\pmfns.cpp\
        $O\dprim2.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rasttex.cpp ===
//----------------------------------------------------------------------------
//
// rasttex.cpp
//
// Texture functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// SetSizesSpanTexture
//
// Initialize pSpanTex data using current iMaxMipLevel info, Getting the
// surfaces from pSurf.  Assumes InitSpanTexture has been called first.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
{
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
    LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
    INT i;

    // Init
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    pSpanTex->iSizeU = (INT16)DDSurf_Width(pLcl);
    pSpanTex->iSizeV = (INT16)DDSurf_Height(pLcl);
    pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
    pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
    pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
    if (0 != DDSurf_BitDepth(pLcl))
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2((UINT32)(DDSurf_Pitch(pLcl) * 8)/DDSurf_BitDepth(pLcl));
    }
    else
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl) * 8));
    }
    pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
    pSpanTex->uMaskV = pSpanTex->uMaskV;

    // Check if the texture size is power of 2
    if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                          pSpanTex->iSizeV, pSpanTex->iShiftV))
    {
        return DDERR_INVALIDPARAMS;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
    {
        pDDS = pSpanTex->pSurf[i];
        // Check for invalid mipmap texture size
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
        if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
            !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
        {
            return DDERR_INVALIDPARAMS;
        }
        if (0 != DDSurf_BitDepth(pLcl))
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Pitch(pLcl)*8)/DDSurf_BitDepth(pLcl));
        }
        else
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl)*8));
        }
        iPreSizeU = (INT16)DDSurf_Width(pLcl);
        iPreSizeV = (INT16)DDSurf_Height(pLcl);
    }
    pSpanTex->cLOD = pSpanTex->cLODTex - iFirstSurf;
    pSpanTex->iMaxScaledLOD = ((pSpanTex->cLOD + 1) << LOD_SHIFT) - 1;
    pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// InitSpanTexture
//
// Initializes the entire array of pSurf's (regardless of iMaxMipLevel) pointed
// to by the root surface of pDDS.  Sets all pSpanTex state that will not ever
// change in SetSizesSpanTexture.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS)
{
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    DDSCAPS ddscaps;
    static INT32 iGeneration = 0;

    // Init
    pSpanTex->iGeneration = iGeneration++;

    // Note that all pSpanTex elements are initialized to 0
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Set the transparent bit and the transparent color with pSurf[0]
    // initially
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;
        pSpanTex->TransparentColor =
            pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    }
    else
    {
        pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;
    }

    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &(pSpanTex->Format)));

    if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
            }
            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
        }
        if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            pSpanTex->iPaletteSize = 256;
        }
        else
        {
            // PALETTE4
            pSpanTex->iPaletteSize = 16;
        }
    }
    pSpanTex->TexAddrU = D3DTADDRESS_WRAP;
    pSpanTex->TexAddrV = D3DTADDRESS_WRAP;
    pSpanTex->BorderColor = RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

    // assign first pSurf here (mipmap chain gets assigned below)
    pSpanTex->pSurf[0] = pDDS;

    // Check for mipmap if any.
    LPDIRECTDRAWSURFACE pTmpS;
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for (;;)
    {
        memset(&ddscaps, 0, sizeof(DDSCAPS));
        ddscaps.dwCaps = DDSCAPS_TEXTURE;
        hr = pDDS->GetAttachedSurface(&ddscaps, &pTmpS);    //implicit AddRef
        if (hr == DDERR_NOTFOUND)
        {
            break;
        }
        else if (hr != D3D_OK)
        {
            return hr;
        }
        pDDS = pTmpS;

        pSpanTex->cLODTex ++;
        pSpanTex->pSurf[pSpanTex->cLODTex] = pTmpS;
    }

    pSpanTex->dwSize = sizeof(D3DI_SPANTEX);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RemoveTexture
//
// Check to see if the to-be-destroyed pSpanTex is currently used by the
// context. If yes, set the according entry to be NULL to disable texture.
//
//----------------------------------------------------------------------------
void D3DContext::RemoveTexture(PD3DI_SPANTEX pSpanTex)
{
    INT i;
    INT cActTex = (INT)m_RastCtx.cActTex;

    for (i = 0; i < cActTex; i++)
    {
        if (m_RastCtx.pTexture[i] == pSpanTex)
        {
            // NULL out the according texture and set dirty bits
            m_RastCtx.cActTex --;
            StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
            m_RastCtx.pTexture[i] = NULL;
            for (int j=pSpanTex->cLODTex;j>0;j--)   //release attached surfs
            {
                pSpanTex->pSurf[j]->Release();
            }
        }
    }
}
//----------------------------------------------------------------------------
//
// RastTextureCreate
//
// Creates a RAST texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureCreate", pTexData);

    // Create the span texture
    ppSpanTex = new PD3DI_SPANTEX;
    pSpanTex = new D3DI_SPANTEX;
    if (ppSpanTex == NULL || pSpanTex == NULL)
    {
        delete ppSpanTex;
        delete pSpanTex;
        D3D_ERR("(Rast) Out of memory in RastTextureCreate");
        pTexData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }
    memset(pSpanTex, 0, sizeof(D3DI_SPANTEX));

    // Point indirector to this texture initially.
    *ppSpanTex = pSpanTex;

    // Init the span texture
    if ((pTexData->ddrval = pDCtx->InitSpanTexture(pSpanTex, pTexData->lpDDS))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pTexData->ddrval = pDCtx->SetSizesSpanTexture(pSpanTex))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }

    // ppSpanTex is used as the texture handle returned to d3dim.
    pTexData->dwHandle = (UINT32)(ULONG_PTR)ppSpanTex;

    pTexData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureDestroy
//
// Destroy a RAST texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureDestroy", pTexDestroyData);
    if (!VALID_D3DI_SPANTEX_PTR_PTR(
        (PD3DI_SPANTEX*)ULongToPtr(pTexDestroyData->dwHandle)))
    {
        D3D_ERR("(Rast) in RastTextureDestroy, invalid texture handle");
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find the texture
    ppSpanTex = (PD3DI_SPANTEX *)ULongToPtr(pTexDestroyData->dwHandle);
    pSpanTex = *ppSpanTex;

    pDCtx->RemoveTexture(pSpanTex);

    // Delete it
    if (pSpanTex)
    {
        delete ppSpanTex;
        delete pSpanTex;
    }
    else
    {
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureGetSurf", pTexGetSurf);

    // Check out the span texture
    PD3DI_SPANTEX pSpanTex;
    pSpanTex = HANDLE_TO_SPANTEX(pTexGetSurf->dwHandle);

    if (pSpanTex)
    {
        pTexGetSurf->lpDDS = (UINT_PTR)pSpanTex->pSurf[0];
        pTexGetSurf->ddrval = D3D_OK;
    }
    else
    {
        pTexGetSurf->ddrval = DDERR_INVALIDPARAMS;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastLockSpanTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::RastLockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;
    HRESULT hr;

    if (IsTextureOff())
    {
        return D3D_OK;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) == 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)
        {
            hr = SetSizesSpanTexture(pSpanTex);
            if (hr != D3D_OK)
            {
                goto EH_Unlock;
            }
        }
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

        // Currently recursive locks are not allowed.
        DDASSERT((pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED) == 0);

        for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
        {
            hr = LockSurface(pSpanTex->pSurf[i],
                            (LPVOID*)&(pSpanTex->pBits[i-iFirstSurf]));
            if (hr != D3D_OK)
            {
                // Unlock any partial mipmap locks we've taken, as
                // RastUnlock can only handle entire textures being
                // locked or unlocked.
                while (--i >= 0)
                {
                    UnlockSurface(pSpanTex->pSurf[i]);
                }

                // Make sure that i is signed and that the above
                // loop exited properly.
                DDASSERT(i < 0);

                goto EH_Unlock;
            }
        }

        pSpanTex->uFlags |= D3DI_SPANTEX_SURFACES_LOCKED;
    }

    m_uFlags |= D3DCONTEXT_TEXTURE_LOCKED;

    return D3D_OK;

 EH_Unlock:
    if (j > 0)
    {
        // Unlock complete textures we've already locked.
        // RastUnlock will check the flags to figure
        // out which ones to unlock.
        RastUnlockSpanTexture();
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
// The input is a D3DI_SPANTEX. NULL texture needs to be checked before this
// function gets called.
//
//----------------------------------------------------------------------------
void
D3DContext::RastUnlockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;;

    if (IsTextureOff())
    {
        return;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) != 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];

        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED)
        {
            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                UnlockSurface(pSpanTex->pSurf[i]);
            }

            pSpanTex->uFlags &= ~D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    m_uFlags &= ~D3DCONTEXT_TEXTURE_LOCKED;
}

//----------------------------------------------------------------------------
//
// UpdateColorKeyAndPalette
//
// Updates the color key value and palette.
//
// Also, if the ColorKey enable for the texture has changed, set the texture handle
// dirty bit so the new mode is recognized in span init.
//
//----------------------------------------------------------------------------
void
D3DContext::UpdateColorKeyAndPalette(void)
{
    INT j;
    PD3DI_SPANTEX pSpanTex;

    // Set the transparent bit and the transparent color with pSurf[0]
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
        {
            pLcl = ((LPDDRAWI_DDRAWSURFACE_INT) pSpanTex->pSurf[0])->lpLcl;

            // Palette might be changed
            if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                    pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
            {
                    if (pLcl->lpDDPalette)
                    {
                            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                            {
                                    pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
                            }
                            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
                    }
            }

            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                // texture has a ColorKey value
                pSpanTex->TransparentColor =
                    pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                if (!(pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT))
                {
                    pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
            else
            {
                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Dp2TextureStageState
//
// Called by Drawprim2 to set texture stage states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    LPD3DHAL_DP2TEXTURESTAGESTATE pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        HR_RET(SetTextureStageState((DWORD)pTexStageState->wStage,
                                    (DWORD)pTexStageState->TSState,
                                    pTexStageState->dwValue));
    }

    HR_RET(CheckFVF(dwFvf));

    hr = Begin();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\swprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "d3dref.h"


#define MAX_CLIPPING_PLANES     12
#define MAX_CLIP_VERTICES       (( 2 * MAX_CLIPPING_PLANES ) + 3 )
#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

extern HRESULT
RastService(DWORD dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC7 g_nullDevDesc =
{
    0,                          /* dwDevCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0, 0,
    0, 0,
};

static D3DDEVICEDESC7 rgbDevDesc = {0};
static D3DHAL_D3DEXTENDEDCAPS OptSwExtCaps;
static BOOL g_bFilledRGBCaps = FALSE;

static void
FillOutDeviceCaps( void )
{
    //
    //  set device description
    //
    rgbDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     ;

    rgbDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    rgbDevDesc.dpcTriCaps.dwMiscCaps =
        D3DPMISCCAPS_CULLNONE |
        D3DPMISCCAPS_CULLCW   |
        D3DPMISCCAPS_CULLCCW  ;
    rgbDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
        D3DPRASTERCAPS_ROP2                     |
        D3DPRASTERCAPS_XOR                      |
    //    D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
    //    D3DPRASTERCAPS_STIPPLE                  |
    //    D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
    //    D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
    //    D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
    //    D3DPRASTERCAPS_ZBIAS                    |
    //    D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
//        D3DPRASTERCAPS_WFOG                   |
        D3DPRASTERCAPS_ZFOG ;
    //    D3DPRASTERCAPS_ANISOTROPY               ;
        rgbDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    rgbDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    rgbDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    rgbDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    rgbDevDesc.dpcTriCaps.dwZCmpCaps;
    rgbDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    rgbDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE  |
        D3DPTEXTURECAPS_POW2         |
        D3DPTEXTURECAPS_ALPHA        |
        D3DPTEXTURECAPS_TRANSPARENCY |
        D3DPTEXTURECAPS_ALPHAPALETTE |
        D3DPTEXTURECAPS_BORDER       |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             ;
    rgbDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       ;
    rgbDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    rgbDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    rgbDevDesc.dpcTriCaps.dwStippleWidth = 4;
    rgbDevDesc.dpcTriCaps.dwStippleHeight = 4;

    //  line caps - copy tricaps and modify
    memcpy( &rgbDevDesc.dpcLineCaps, &rgbDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    rgbDevDesc.dwDeviceRenderBitDepth = DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32;
    rgbDevDesc.dwDeviceZBufferBitDepth = D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS;

    // DX5 stuff (should be in sync with the extended caps reported below)
    rgbDevDesc.dwMinTextureWidth = 1;
    rgbDevDesc.dwMaxTextureWidth = 1024;
    rgbDevDesc.dwMinTextureHeight = 1;
    rgbDevDesc.dwMaxTextureHeight = 1024;

    //
    //  set extended caps
    //
    OptSwExtCaps.dwSize = sizeof(OptSwExtCaps);

    OptSwExtCaps.dwMinTextureWidth = 1;
    OptSwExtCaps.dwMaxTextureWidth = 1024;
    OptSwExtCaps.dwMinTextureHeight = 1;
    OptSwExtCaps.dwMaxTextureHeight = 1024;

    OptSwExtCaps.dwMinStippleWidth = 0; // stipple unsupported
    OptSwExtCaps.dwMaxStippleWidth = 0;
    OptSwExtCaps.dwMinStippleHeight = 0;
    OptSwExtCaps.dwMaxStippleHeight = 0;

    OptSwExtCaps.dwMaxTextureRepeat = 256;
    OptSwExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    OptSwExtCaps.dwMaxAnisotropy = 1;
    OptSwExtCaps.dvGuardBandLeft  = -4096.f;
    OptSwExtCaps.dvGuardBandTop   = -4096.f;
    OptSwExtCaps.dvGuardBandRight  = 4095.f;
    OptSwExtCaps.dvGuardBandBottom = 4095.f;
    OptSwExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    OptSwExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    OptSwExtCaps.dwFVFCaps = 8;
    OptSwExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
//        D3DTEXOPCAPS_ADDSIGNED2X               |
//        D3DTEXOPCAPS_SUBTRACT                  |
//        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       ;
//        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
//        D3DTEXOPCAPS_PREMODULATE               |
//        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
//        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
//        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
//        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
    OptSwExtCaps.wMaxTextureBlendStages = 8;
    OptSwExtCaps.wMaxSimultaneousTextures = 8;

    // DX7
    OptSwExtCaps.dwMaxActiveLights = 0;
    OptSwExtCaps.dvMaxVertexW = 10000.;
    OptSwExtCaps.wMaxUserClipPlanes = 0;
    OptSwExtCaps.wMaxVertexBlendMatrices = 0;
    OptSwExtCaps.dwVertexProcessingCaps = 0;

    OptSwExtCaps.dwReserved1 = 0;
    OptSwExtCaps.dwReserved2 = 0;
    OptSwExtCaps.dwReserved3 = 0;
    OptSwExtCaps.dwReserved4 = 0;

    g_bFilledRGBCaps = TRUE;
}
//----------------------------------------------------------------------------
//
// SwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP SwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::GetCaps
//
// Returns software rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OptRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    if( g_bFilledRGBCaps == FALSE )
    {
        FillOutDeviceCaps();
        // add extended caps to rgbDevDesc
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);
    }

    *pHelDesc = rgbDevDesc;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS OptRastCallbacksC =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateC,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMXAsRGB =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMXAsRGB,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 OptRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 OptRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, //lpvReserved
    RastValidateTextureStageState,
    RastDrawPrimitives2,
};

static void DevDesc7ToDevDescV1( D3DDEVICEDESC_V1 *pOut, D3DDEVICEDESC7 *pIn )
{

    // These fields are not available in D3DDEVICEDESC7.
    // Zeroing them out, the front-end should not be using them
    //     DWORD            dwFlags
    //     D3DCOLORMODEL    dcmColorModel
    //     D3DTRANSFORMCAPS dtcTransformCaps
    //     BOOL             bClipping
    //     D3DLIGHTINGCAPS  dlcLightingCaps
    //     DWORD            dwMaxBufferSize
    //     DWORD            dwMaxVertexCount
    //     DWORD            dwMinStippleWidth, dwMaxStippleWidth
    //     DWORD            dwMinStippleHeight, dwMaxStippleHeight;
    //
    ZeroMemory( pOut, sizeof( D3DDEVICEDESC_V1 ) );
    pOut->dwSize = sizeof( D3DDEVICEDESC_V1 );

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
}


STDMETHODIMP
OptRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    if( g_bFilledRGBCaps == FALSE )
    {
        FillOutDeviceCaps();
        // add extended caps to rgbDevDesc
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);
    }

    //
    // Need to fix up SwDriverData.hwCaps (D3DDEVICEDESC) from
    // rgbDevDesc (D3DDEVICEDESC7)
    //
    DevDesc7ToDevDescV1( &SwDriverData.hwCaps, &rgbDevDesc );

    SW_RAST_TYPE RastType;
    switch(m_BeadSet)
    {
    default:
    case D3DIBS_C:
        RastType = SW_RAST_RGB;
        break;
    case D3DIBS_MMX:
        RastType = SW_RAST_MMX;
        break;
    case D3DIBS_MMXASRGB:
        RastType = SW_RAST_MMXASRGB;
        break;
    }
    // Vertex counts are left zero.
    SwDriverData.dwNumTextureFormats =
        TextureFormats(&SwDriverData.lpTextureFormats, dwVersion, RastType);
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = &OptSwExtCaps;

    switch(m_BeadSet)
    {
    case D3DIBS_MMX:        pInterfaceData->pCallbacks = &OptRastCallbacksMMX;      break;
    case D3DIBS_MMXASRGB:   pInterfaceData->pCallbacks = &OptRastCallbacksMMXAsRGB; break;
    case D3DIBS_C:          pInterfaceData->pCallbacks = &OptRastCallbacksC;        break;
    }
    pInterfaceData->pCallbacks2 = &OptRastCallbacks2;
    pInterfaceData->pCallbacks3 = &OptRastCallbacks3;

    pInterfaceData->pfnRastService = NULL;
    pInterfaceData->pfnGetDriverState = NULL;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Constructor for OptRastHalProvider to allow a bit of private state to be
// kept to indicate which optimized rasterizer is to be used.
//
//----------------------------------------------------------------------------
OptRastHalProvider::OptRastHalProvider(THIS_
                       DWORD BeadSet)
{
    m_BeadSet = BeadSet;
}

//----------------------------------------------------------------------------
//
// GetSwProvider
//
// Returns the appropriate software HAL provider based on the given GUID.
//
//----------------------------------------------------------------------------

static OptRastHalProvider g_OptRastHalProviderC(D3DIBS_C);
static OptRastHalProvider g_OptRastHalProviderMMX(D3DIBS_MMX);
static OptRastHalProvider g_OptRastHalProviderMMXAsRGB(D3DIBS_MMXASRGB);

STDAPI GetSwHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderC;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
             IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFHALPROVIDER pfnGetRefHalProvider;
        if (NULL == (pfnGetRefHalProvider =
            (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
        {
            *ppHalProvider = NULL;
            return E_NOINTERFACE;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        pfnGetRefHalProvider(riid, ppHalProvider, phDll);
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    // As a debugging aid, allow the particular rasterizer to be forced
    // via a registry setting.  This lets a developer run an app on any
    // rasterizer regardless of what it asks for.

    LONG iRet;
    HKEY hKey;

    iRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (iRet == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        dwDataSize = sizeof(dwData);
        iRet = RegQueryValueEx(hKey, "ForceRgbRasterizer", NULL,
                               &dwType, (BYTE *)&dwData, &dwDataSize);
        if (iRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            switch(dwData)
            {
            case 1:
            case 2:
                *ppHalProvider = &g_OptRastHalProviderC;
                break;
            case 3:
                *ppHalProvider = &g_OptRastHalProviderMMX;
                break;
            case 4:
            case 5:
                // try to get provider from external DLL ref device
                PFNGETREFHALPROVIDER pfnGetRefHalProvider;
                if (NULL == (pfnGetRefHalProvider =
                             (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
                {
                    *ppHalProvider = NULL;
                    return E_NOINTERFACE;
                }
                D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
                pfnGetRefHalProvider(riid, ppHalProvider, phDll);
                break;
            case 6:
                *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
                break;
            case 0:
                // no override for 0
                break;
            default:
                D3D_ERR("(Rast) Unknown ForceRgbRasterizer setting - no force");
                break;
            }

            D3D_INFO(0, "(Rast) ForceRgbRasterizer to %d", dwData);
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}

STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice) ||
       IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ||
       IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: HAL and Ramp GUIDs are not valid args");
        *lplpddsd=NULL;
        return 0;
    }

    if(IsEqualIID(riid, IID_IDirect3DRefDevice) ||
       IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFTEXTUREFORMATS pfnGetRefTextureFormats;
        if (NULL == (pfnGetRefTextureFormats =
                     (PFNGETREFTEXTUREFORMATS)LoadReferenceDeviceProc("GetRefTextureFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: d3dref.dll not found");
            *lplpddsd=NULL;
            return 0;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        return pfnGetRefTextureFormats(riid, lplpddsd, dwD3DDeviceVersion);
    }

    SW_RAST_TYPE RastType = SW_RAST_RGB;
    if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        RastType = SW_RAST_MMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        RastType = SW_RAST_MMXASRGB;
    }

    return TextureFormats(lplpddsd,dwD3DDeviceVersion, RastType);
}

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice) ||
       IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ||
        IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: HAL and Ramp GUIDs are not valid args");
        *ppDDPF=NULL;
        return 0;
    }

    if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
        IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get Z buffer formats from external DLL ref device
        PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
        if (NULL == (pfnGetRefZBufferFormats =
            (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: d3dref.dll not found");
            *ppDDPF=NULL;
            return 0;
        }
        return pfnGetRefZBufferFormats(riid, ppDDPF);
    }

    return ZBufferFormats(ppDDPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mlspan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\swprov.hpp ===
//----------------------------------------------------------------------------
//
// swprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SWPROV_HPP_
#define _SWPROV_HPP_

//----------------------------------------------------------------------------
//
// SwHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class SwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Specific provider for the optimized software rasterizer.
//
//----------------------------------------------------------------------------

class OptRastHalProvider : public SwHalProvider
{
private:
    DWORD m_BeadSet;
public:
    OptRastHalProvider(THIS_
                       DWORD);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _SWPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\sources.inc ===
TARGETNAME = rmlspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\cmlrast.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>

typedef enum _RASTSurfaceType
{
    RAST_STYPE_NULL     = 0,
    RAST_STYPE_B8G8R8   = 1,
    RAST_STYPE_B8G8R8A8 = 2,
    RAST_STYPE_B8G8R8X8 = 3,
    RAST_STYPE_B5G6R5   = 4,
    RAST_STYPE_B5G5R5   = 5,
    RAST_STYPE_PALETTE4 = 6,
    RAST_STYPE_PALETTE8 = 7,
    RAST_STYPE_B5G5R5A1 = 8,
    RAST_STYPE_B4G4R4   = 9,
    RAST_STYPE_B4G4R4A4 =10,
    RAST_STYPE_L8       =11,          // 8 bit luminance-only
    RAST_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RAST_STYPE_U8V8     =13,          // 16 bit bump map format
    RAST_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RAST_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RAST_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RAST_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RAST_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RAST_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RAST_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RAST_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RAST_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RAST_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RAST_STYPE_Z16S0    =32,
    RAST_STYPE_Z24S8    =33,
    RAST_STYPE_Z15S1    =34,
    RAST_STYPE_Z32S0    =35,

} RASTSurfaceType;


#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxemul\sources.inc ===
TARGETNAME = mmxemul
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\mmxemul.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };


    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTexEnd;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        ..\spanutil.cpp\
        $O\test.asm\
        $O\texaddr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\makefile.inc ===
$(GENTGT)\clrbd_mh.h: ..\clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: ..\clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: ..\test_mh.mh $(RAST_STD_M4)

$(GENTGT)\texa_mh.h: ..\texa_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: ..\texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: ..\texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: ..\tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: ..\atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h ..\..\..\..\ref\inc\refrast.hpp

$(GENTGT)\beadtbl.cpp: ..\beadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: ..\atest.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: ..\bldfuncs.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: ..\bufread.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: ..\bufwrite.mas ..\bufwrite.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: ..\colorbld.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: ..\colorgen.mas ..\colorgen.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: ..\test.mas ..\test.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texaddr.asm: ..\texaddr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: ..\texblend.mas ..\texblend.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: ..\texread.mas ..\texread.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: ..\tstfail.mas ..\tstfail.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: ..\spanpars.mas ..\cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ..\ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ..\ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ..\ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ..\ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ..\ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ..\ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ..\ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ..\ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ..\ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ..\ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ..\ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ..\ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ..\ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ..\ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ..\ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ..\ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ..\ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ..\ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ..\ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ..\ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ..\ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ..\ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ..\ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ..\ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ..\ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ..\ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ..\ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ..\ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = D3D_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != D3D_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\sources.inc ===
TARGETNAME = rmmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadtbl.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\beadtbl.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\makefile.inc ===
$(GENTGT)\attrs_mh.h: ..\attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: ..\tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: ..\walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\attrsx86.asm: ..\attrsx86.mas ..\attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: ..\attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: ..\tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: ..\tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: ..\walkx86.mas ..\attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(RS);

#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;
    
        pAttr->fUoW[0] += pDelta->fUoW[0];
        pAttr->fVoW[0] += pDelta->fVoW[0];
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i];
            pAttr->fVoW[i] += pDelta->fVoW[i];
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW[0] = pStpCtx->fNextUoW1;
            pAttr->fVoW[0] = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW[0] += pDelta->fUoW[0] * fScale;
            pAttr->fVoW[0] += pDelta->fVoW[0] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i] * fScale;
            pAttr->fVoW[i] += pDelta->fVoW[i] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
    
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }
        
        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW[0] * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW[0] * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }
        
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;
            
                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }
                
            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW[0] + pStpCtx->DAttrDX.fUoW[0] * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW[0] + pStpCtx->DAttrDX.fVoW[0] * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;
                
            pSpan->iDLOD =
                (INT16)(FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix));
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }
            
        pSpan->iOoW = FTOI(pAttr->fOoW);
    
        pSpan->UVoW[0].iUoW = FTOI(pAttr->fUoW[0]);
        pSpan->UVoW[0].iVoW = FTOI(pAttr->fVoW[0]);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pSpan->UVoW[i].iUoW = FTOI(pAttr->fUoW[i]);
            pSpan->UVoW[i].iVoW = FTOI(pAttr->fVoW[i]);
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT16)(FTOI(pAttr->fB));
        pSpan->uG = (UINT16)(FTOI(pAttr->fG));
        pSpan->uR = (UINT16)(FTOI(pAttr->fR));
        pSpan->uA = (UINT16)(FTOI(pAttr->fA));
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT16)(FTOI(pAttr->fBS));
        pSpan->uGS = (UINT16)(FTOI(pAttr->fGS));
        pSpan->uRS = (UINT16)(FTOI(pAttr->fRS));
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (UINT16)(FTOI(pAttr->fFog));
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;
        
        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.
        
        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }
        
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;
                
            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->UVoW[0].iUoW = FTOI(fUoW * TEX_SCALE);
        pSpan->UVoW[0].iVoW = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)m_StpCtx.pCtx->cActTex; i++)
        {
            if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU *
                         pV0->dvRHW * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV *
                         pV0->dvRHW * TEX_SCALE);
            }
            else
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV * TEX_SCALE);
            }
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (UINT16)(
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE));
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return D3D_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != D3D_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != D3D_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup, if flat shaded.
    if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
    {
        m_StpCtx.pFlatVtx = pFlatVtx;
    }
    else
    {
        m_StpCtx.pFlatVtx = pV0;
    }


    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor));

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    INT32 uSize = sizeof(D3DI_RASTPRIM);

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((uSize & (CACHE_LINE - 1)) == 0 &&
             (uSize & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE,
                            ((FLOAT)pSpan->UVoW[0].iUoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->UVoW[0].iVoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = D3D_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = D3D_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = D3D_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != D3D_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//   
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <rast.h>
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW, fVoW;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW[0] =
                TextureDiff(pV1->dvTU, fUoW,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                TextureDiff(pV1->dvTV, fVoW,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW[0] = TEX_SCALE * fUoW +
            pStpCtx->DAttrDMajor.fUoW[0] * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW[0] = TEX_SCALE * fVoW +
            pStpCtx->DAttrDMajor.fVoW[0] * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW, fVoW;

        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                fUoW = pVM0->texCoord[i].dvTU * pVM0->dvRHW;
                fVoW = pVM0->texCoord[i].dvTV * pVM0->dvRHW;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTU, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTU, fUoW,
                                        pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_U) *
                                        TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTV, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTV, fVoW,
                                        pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_V) *
                                        TEX_SCALE * pStpCtx->fOoLen;
            }
            else
            {
                fUoW = pVM0->texCoord[i].dvTU;
                fVoW = pVM0->texCoord[i].dvTV;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTU, fUoW,
                                pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_U) *
                                TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTV, fVoW,
                                pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_V) *
                                TEX_SCALE * pStpCtx->fOoLen;
            }

            pStpCtx->Attr.fUoW[i] = TEX_SCALE * fUoW +
                pStpCtx->DAttrDMajor.fUoW[i] * pStpCtx->fDMajor;
            pStpCtx->Attr.fVoW[i] = TEX_SCALE * fVoW +
                pStpCtx->DAttrDMajor.fVoW[i] * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
    else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTexEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\sources.inc ===
TARGETNAME = rsetup
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#C_DEFINES = $(C_DEFINES) -DSTEP_FIXED

SOURCES = \
        ..\attrs.cpp\
        ..\buffer.cpp\
        ..\line.cpp\
        ..\lstp.cpp\
        ..\point.cpp\
        ..\primproc.cpp\
        ..\rsdbg.cpp\
        ..\tri.cpp\
        ..\tstp.cpp\
        ..\walk.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\attrs_mh.h\
        $O\tstp_mh.h\
        $O\walk_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->texCoord[1].tu > 256.0F) || (pGV->texCoord[1].tu < -256.0F) ||
                (pGV->texCoord[1].tv > 256.0F) || (pGV->texCoord[1].tv < -256.0F))
            {
                RSDPF(("ValidateVertex: texCoord[1].tu,texCoord[1].tv out of range (%f,%f)\n",pGV->texCoord[1].tu,pGV->texCoord[1].tv));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return D3D_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "pch.cpp"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(SPI);

#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)

#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3dhal.h>

#include "rast.h"
#include "spindbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\makefile.inc ===
$(GENTGT)\bdstr_mh.h: ..\bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: ..\beadstr.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: ..\spaninit.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\sources.inc ===
TARGETNAME = rspanini
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadstr.cpp\
        $O\spaninit.cpp\
        ..\spindbg.cpp\
        ..\rastcoll.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\bdstr_mh.h\
        $O\beadstr.cpp\
        $O\spaninit.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != D3D_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipper.h"
#include "d3dfei.h"

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
void SetInterpolationFlags(LPD3DFE_PROCESSVERTICES pv)
{
    // Figure out which pieces need to be interpolated in new vertices.
    pv->dwDeviceFlags &= ~(D3DDEV_INTERPOLATE_COLOR | D3DDEV_INTERPOLATE_SPECULAR);
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD)
    {
        pv->dwDeviceFlags |= D3DDEV_INTERPOLATE_COLOR;
        if (pv->dwVIDOut & D3DFVF_SPECULAR)
            pv->dwDeviceFlags |= D3DDEV_INTERPOLATE_SPECULAR;
    }
}
//---------------------------------------------------------------------
__inline void
InterpolateColor(ClipVertex *p,
                 ClipVertex *p1,
                 ClipVertex *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    p->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                         (WORD)(g1 + (g2 - g1) * num_denom),
                         (WORD)(b1 + (b2 - b1) * num_denom),
                         (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline void
InterpolateSpecular(ClipVertex *p,
                    ClipVertex *p1,
                    ClipVertex *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    p->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                            (WORD)(g1 + (g2 - g1) * num_denom),
                            (WORD)(b1 + (b2 - b1) * num_denom),
                            (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p,
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    p->color = pv->ClipperState.clip_color;
    p->specular = pv->ClipperState.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (pv->dwDeviceFlags & D3DDEV_INTERPOLATE_COLOR)
    {
        InterpolateColor(p, p1, p2, num_denom);
    }

    if (pv->dwDeviceFlags & D3DDEV_INTERPOLATE_SPECULAR)
    {
        InterpolateSpecular(p, p1, p2, num_denom);
    }

    // Assume that D3DRENDERSTATE_WRAPi are sequential
    D3DVALUE *pTexture1 = p1->tex;
    D3DVALUE *pTexture2 = p2->tex;
    D3DVALUE *pTexture = p->tex;
    for (DWORD i = 0; i < pv->nOutTexCoord; i++)
    {
        DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
        DWORD n = (DWORD)(pv->dwTextureCoordSize[i] >> 2);
        DWORD dwWrapBit = 1;
        for (DWORD j=0; j < n; j++)
        {
            *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                           num_denom, wrapState & dwWrapBit);
            dwWrapBit <<= 1;
            pTexture ++;
            pTexture1++;
            pTexture2++;
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int ClipByPlane (D3DFE_PROCESSVERTICES *pv,
                 ClipVertex **inv, 
                 ClipVertex **outv,
                 D3DVECTORH *plane,
                 DWORD dwClipFlag,
                 int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y + 
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--) 
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y + 
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            dwClipFlag,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int ClipLineByPlane(D3DFE_PROCESSVERTICES *pv, 
                    ClipTriangle *line, 
                    D3DVECTORH *plane,
                    DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
    in1 = line->v[0]->hx * plane->x + 
          line->v[0]->hy * plane->y + 
          line->v[0]->hz * plane->z + 
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x + 
          line->v[1]->hy * plane->y + 
          line->v[1]->hz * plane->z + 
          line->v[1]->hw * plane->w;
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv,
                              ClipVertex **inv,
                              int count, D3DRECTV *extent)
{
    int i;
    BOOL updateExtent = !(pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS);
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++)
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
                if (p->sx < VPORT.minXgb)
                        p->sx = VPORT.minXgb;
                if (p->sx > VPORT.maxXgb)
                        p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
                if (p->sy < VPORT.minYgb)
                        p->sy = VPORT.minYgb;
                if (p->sy > VPORT.maxYgb)
                        p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
            p->rhw = w;
            if (updateExtent)
            {
                if (p->sx < extent->x1)
                    extent->x1 = p->sx;
                if (p->sy < extent->y1)
                    extent->y1 = p->sy;
                if (p->sx  > extent->x2)
                    extent->x2 = p->sx;
                if (p->sy > extent->y2)
                    extent->y2 = p->sy;
            }
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = D3DCLIP_GEN0;
    for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
    {
        if ((p->hx*pv->userClipPlane[i].x + 
             p->hy*pv->userClipPlane[i].y + 
             p->hz*pv->userClipPlane[i].z + 
             p->hw*pv->userClipPlane[i].w) < 0)
        {
            clip |= dwClipBit;
        }
        dwClipBit <<= 1;
    }
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCLIP_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCS::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCLIP_FRONT)
    {
        count = ClipFront(pv, inv, outv, count);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT)
        {
            count = ClipLeftGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT)
        {
            count = ClipRightGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM)
        {
            count = ClipBottomGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP)
        {
            count = ClipTopGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_LEFT)
        {
            count = ClipLeft(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_RIGHT)
        {
            count = ClipRight(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_BOTTOM)
        {
            count = ClipBottom(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_TOP)
        {
            count = ClipTop(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCLIP_GEN0;
        DWORD dwClippedBit = CLIPPED_GEN0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                count = ClipByPlane(pv, inv, outv, &pv->userClipPlane[i], 
                                    dwClippedBit, count);
                if (count < 3)
                    goto out_of_here;
                SWAP(inv, outv);
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count, &pv->rExtents);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int
ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
               ClipTriangle *line,
               D3DRECTV *extent)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT)
        if (ClipLineFront(pv, line))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT)
            if (ClipLineLeftGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT)
            if (ClipLineRightGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP)
            if (ClipLineTopGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM)
            if (ClipLineBottomGB(pv, line))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT)
            if (ClipLineLeft(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT)
            if (ClipLineRight(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_TOP)
            if (ClipLineTop(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM)
            if (ClipLineBottom(pv, line))
                goto out_of_here;
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCLIP_GEN0;
        DWORD dwClippedBit = CLIPPED_GEN0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                if (ClipLineByPlane(pv, line, &pv->userClipPlane[i], 
                                    dwClippedBit))
                    goto out_of_here;
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

    ComputeScreenCoordinates(pv, line->v, 2, extent);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
    if (pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS)
    { /* Only generate clip flags */
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        DWORD i;
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb)
                    clip |= __D3DCLIPGB_LEFT;
                else
                if (x >= rightgb)
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb)
                    clip |= __D3DCLIPGB_TOP;
                else
                if (y >= bottomgb)
                    clip |= __D3DCLIPGB_BOTTOM;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    }
    else
    { /* Generate Clip Flags and Update Extents */
        DWORD i;
        float minx = pv->rExtents.x1;
        float miny = pv->rExtents.y1;
        float maxx = pv->rExtents.x2;
        float maxy = pv->rExtents.y2;
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb)
                    clip |= __D3DCLIPGB_LEFT;
                else
                if (x >= rightgb)
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb)
                    clip |= __D3DCLIPGB_TOP;
                else
                if (y >= bottomgb)
                    clip |= __D3DCLIPGB_BOTTOM;
            }
            // Update extents only if the vertex is inside
            if (clip == 0 || 
                ((pv->dwDeviceFlags & D3DDEV_GUARDBAND) && 
                 ((clip & ~__D3DCLIP_INGUARDBAND) == 0)))
            {
                if (x < minx)
                    minx = x;
                if (x > maxx)
                    maxx = x;
                if (y < miny)
                    miny = y;
                if (y > maxy)
                    maxy = y;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
        pv->rExtents.x1 = minx;
        pv->rExtents.y1 = miny;
        pv->rExtents.x2 = maxx;
        pv->rExtents.y2 = maxy;
    }

    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                          DWORD clipFlag, BOOL transformed)
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & pv->dwClipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.rhw = ((D3DVALUE*)v)[3];
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw * VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw * VPORT.scaleYi;                                
        pp1.hz  = (pp1.sz - VPORT.offsetZ) * pp1.hw * VPORT.scaleZi;
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                             
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    memcpy(pp1.tex, v, pv->dwTextureCoordSizeTotal);
    pp1.clip = clipFlag; 
}              
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{
    *(D3DVECTORH*)out = *(D3DVECTORH*)&(in)->sx;               
    *(DWORD*)&out[pv->diffuseOffsetOut]  =  (in)->color;               
    *(DWORD*)&out[pv->specularOffsetOut] =  (in)->specular;               
    memcpy(&out[pv->texOffsetOut], in->tex, pv->dwTextureCoordSizeTotal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCLIP_LEFTBIT     1
#define D3DCLIP_RIGHTBIT    2
#define D3DCLIP_TOPBIT      3
#define D3DCLIP_BOTTOMBIT   4
#define D3DCLIP_FRONTBIT    5
#define D3DCLIP_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

const DWORD __DEBUG_MULTILOOP = 1;      // Disable multi-loop geometry pipeline
const DWORD __DEBUG_ONEPASS = 2;        // Disable clip and light in one pass
const DWORD __DEBUG_MODELSPACE = 4;     // Disable lighting in model space

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                         DWORD clipFlag, BOOL transformed);
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in);

#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"

int ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                   ClipTriangle *line,
                   D3DRECTV *extent);

HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleList (D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleList (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of a primitive
//
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType,
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    return pv->DrawPrim();
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw clipped part of a primitive
//
inline HRESULT DRAW_CLIPPED_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    return pv->DrawClippedPrim();
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of an 
// indexed primitive
//
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    return pv->DrawIndexPrim();
}
//----------------------------------------------------------------------
// Clip a triangle made by 3 vertices
// bCanModifyVertices is set to TRUE, if the function can modify the original 
// vertices
//
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3);
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\d3dfei.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfei.hpp
 *  Content:    Direct3D frontend internal include file
 *
 ***************************************************************************/
#ifndef _D3DFEI_H_
#define _D3DFEI_H_

#include "tlhal.h"
#include "clipper.h"

extern void setIdentity(D3DMATRIXI * m);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI);
extern void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to);
extern void SetInterpolationFlags(LPD3DFE_PROCESSVERTICES pv);
extern LIGHT_VERTEX_FUNC_TABLE lightVertexTable;

//---------------------------------------------------------------------
// Clamp extents to viewport window.
// For guard band it is possible that extents are outside viewport window
// after clipping
//
inline void ClampExtents(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && 
        !(pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
    {
        if (pv->rExtents.x1 < pv->vcache.minX)
            pv->rExtents.x1 = pv->vcache.minX;
        if (pv->rExtents.x2 > pv->vcache.maxX)
            pv->rExtents.x2 = pv->vcache.maxX;
        if (pv->rExtents.y1 < pv->vcache.minY)
            pv->rExtents.y1 = pv->vcache.minY;
        if (pv->rExtents.y2 > pv->vcache.maxY)
            pv->rExtents.y2 = pv->vcache.maxY;
    }
}
//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCLIP_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
extern void DoUpdateState(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
// Updates clip status in the device
//
// We have to mask all guard band bits
//
inline void D3DFE_UpdateClipStatus(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->iClipStatus |= lpDevI->dwClipUnion & D3DSTATUS_CLIPUNIONALL;
    lpDevI->iClipStatus &= (~D3DSTATUS_CLIPINTERSECTIONALL |
                         ((lpDevI->dwClipIntersection & D3DSTATUS_CLIPUNIONALL) << 12));
}
#endif // _D3DFEI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipfunc.h"
#include "drawprim.hpp"

//----------------------------------------------------------------------
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = cv1;
    newtri.v[1] = cv2;
    newtri.v[2] = cv3;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    cv1->clip |= CLIPPED_ENABLE;
    cv2->clip |= CLIPPED_ENABLE;
    cv3->clip |= CLIPPED_ENABLE;
    // For the  flat shading mode we have to use first vertex color as 
    // color for all vertices
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = cv1->color;
        D3DCOLOR specular = cv1->specular;

        //Save original colors
        diffuse1  = cv2->color;
        specular1 = cv2->specular;
        diffuse2  = cv3->color;
        specular2 = cv3->specular;

        cv2->color= diffuse;
        cv2->specular = specular;
        cv3->color = diffuse;
        cv3->specular = specular;
    }

    if (count = lpDevI->pGeometryFuncs->ClipSingleTriangle(pv, &newtri, &ver))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        if (ret)
            return ret;
    }
    // CLIPPED_ENABLE bit could be set in the ClipSingleTriangle.
    // If this bit is not cleared, clipping will be wrong. Because, clip 
    // vertices are re-used by next triangles.
    // This bit should be cleared *after* drawing command. Otherwise, edge flags 
    // will be incorrect
    cv1->clip &= ~CLIPPED_ENABLE;
    cv2->clip &= ~CLIPPED_ENABLE;
    cv3->clip &= ~CLIPPED_ENABLE;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Restore original colors
        cv2->color    = diffuse1;
        cv2->specular = specular1;
        cv3->color    = diffuse2;
        cv3->specular = specular2;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//----------------------------------------------------------------------
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2)
{
    ClipTriangle newline;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    ClipVertex cv1 = *v1;
    ClipVertex cv2 = *v2;
    newline.v[0] = &cv1;
    newline.v[1] = &cv2;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        cv2.color    = cv1.color;
        cv2.specular = cv1.specular;
    }

    if (ClipSingleLine(pv, &newline, &pv->rExtents))
    {
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
        p += pv->dwOutputSize;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
        HRESULT ret = DRAW_CLIPPED_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                         
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                    // Mark this call as gen by clipper, but set non clipped bit
                    pv->dwFlags |= D3DPV_NONCLIPPED; 
                    ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                            vertexCount);
                    pv->dwFlags &= ~D3DPV_NONCLIPPED;
                }
                else
                {
                    ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
                }
                if (ret)
                    return ret;
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex == p1)
        {
            ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        }
        else
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
            // Mark this call as gen by clipper
            pv->dwFlags |= D3DPV_NONCLIPPED; 
            ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
        }
        if (ret)
            return ret;

        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    WORD        *p1;
    DWORD        f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    LPWORD       startVertex;                               
    LPWORD index = pv->lpwIndices;                               \
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[index[0]];
    p1 = index;
    index++;
    BYTE *ver = vertex + p1[0]*vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        WORD  v1, v2;
        v1 = index[0];
        v2 = index[1];
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD tmp;
                WORD *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart--;
                    tmp = *pStart;  // Save old value to restore later
                    *pStart = *p1;
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                  vertexCount);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    *pStart = tmp;   // Restore old value
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = &index[1];

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index++;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD tmp;
        WORD *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart--;
            tmp = *pStart;  // Save old value to restore later
            *pStart = *p1;
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        if (ret)
            return ret;
        if (startVertex != p1)
            *pStart = tmp;   // Restore old value
        if (ret)
            return ret;
    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    DWORD dwVertexBaseOrg = pv->dwVertexBase;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            pv->dwVertexBase = dwVertexBaseOrg + i - count;
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        pv->dwVertexBase = dwVertexBaseOrg + nVertices - count;
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include "d3dpr.hpp"
#include "haldrv.hpp"
#include "fltval.h"
#include "d3dfei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT __PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD      startVertex = pv->lpwIndices;
    LPWORD      index = pv->lpwIndices;
    DWORD       triangleSize;   // 3 for DrawPrimitives, 
                                // 4 for ExecuteBuffers (include wFlags)
    triangleSize = 3;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = index + triangleSize;
#else
            pv->dwVertexBase += 3;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

#ifdef __INDEX_PRIM
#endif
                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += triangleSize;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT __PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += primitiveCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[1];
#else
            pv->dwVertexBase++;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_NONCLIPPED; 
                ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~D3DPV_NONCLIPPED;
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = &index[1];
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->dwVertexBase++;
                D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index++;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
#ifndef __INDEX_PRIM
        pv->dwVertexBase += primitiveCount;
#endif
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT __PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;                               
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
        nextLineOffset = 1;
        countAdd = 1;
    }
    else
    {
        nextLineOffset = 2;
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        WORD v1, v2;
        v1 = index[0];
        v2 = index[1];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[nextLineOffset];
#else
            pv->dwVertexBase += nextLineOffset;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + nextLineOffset*vertexSize;
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);

                ret = ClipLine(pv, &cv[0], &cv[1]);
                if (ret != D3D_OK)
                    return ret;
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffset;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include <stdio.h>
#include "ddrawp.h"
#include "dpf.h"
#include "d3di.hpp"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

main()
// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0x%08lX\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_VCACHE_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
} 

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
} 

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
} 

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(DIRECT3DDEVICEI, name)); \
} 

#define printPV(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "D3DPV_"#name, OFFSET(D3DFE_PROCESSVERTICES, name)); \
} 

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CDirect3DDeviceIDP2, name)); \
} 

{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);
    
    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DLVERTEX, color);
    DEFINE(D3DLVERTEX, specular);

    DEFINE(D3DTLVERTEX, sx);
    DEFINE(D3DTLVERTEX, sy);
    DEFINE(D3DTLVERTEX, sz);
    DEFINE(D3DTLVERTEX, rhw);
    DEFINE(D3DTLVERTEX, color);
    DEFINE(D3DTLVERTEX, specular);
    DEFINE(D3DTLVERTEX, tu);
    DEFINE(D3DTLVERTEX, tv);
    printf("D3DTLVERTEX_size    equ %d\n", sizeof(D3DTLVERTEX));

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));
    
    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);

    DEFINE(D3DLIGHTINGELEMENT, dvPosition);
    DEFINE(D3DLIGHTINGELEMENT, dvNormal);
    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCLIP_LEFT);
    MACRO(D3DCLIP_RIGHT);
    MACRO(D3DCLIP_TOP);
    MACRO(D3DCLIP_BOTTOM);
    MACRO(D3DCLIP_FRONT);
    MACRO(D3DCLIP_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDEV_DONOTUPDATEEXTENTS);
    MACRO(D3DDEV_DONOTCLIP);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(scaleZ);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(offsetZ);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexAmbient);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(dwLightingFlags);
    printD3DFE_LIGHTING(alphaSpecular);
    printD3DFE_LIGHTING(model_eye);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(ambientSceneScaled);
    printD3DFE_LIGHTING(ambientScene);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(ambient_save);
    printD3DFE_LIGHTING(materialAlpha);
    printD3DFE_LIGHTING(materialAlphaS);
    printD3DFE_LIGHTING(dwDiffuse0);
    printD3DFE_LIGHTING(directionToCamera);
    printD3DFE_LIGHTING(dwAmbientSrcIndex);
    printD3DFE_LIGHTING(dwDiffuseSrcIndex);
    printD3DFE_LIGHTING(dwSpecularSrcIndex);
    printD3DFE_LIGHTING(dwEmissiveSrcIndex);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);
  
pcomment("---------------- D3DFE_PROCESSVERTICES ------------------------------");
    printPV(mCTM);
    printPV(dwMaxTextureIndices);
    printPV(lighting);
    printPV(vcache);
    printPV(dvExtentsAdjust);
    printPV(lpdwRStates);
    printPV(ClipperState);
    printPV(dwVertexBase);
    printPV(dwFlags);
    printPV(dwDeviceFlags);
    printPV(dwNumVertices);
    printPV(dwNumPrimitives);
    printPV(dwNumIndices);
    printPV(lpwIndices);
    printPV(primType);
    printPV(nTexCoord);
    printPV(position);
    printPV(normal);
    printPV(diffuse);
    printPV(specular);
    printPV(textures);
    printPV(dwVIDIn);
    printPV(dwVIDOut);
    printPV(dwOutputSize);
    printPV(lpvOut);
    printPV(lpClipFlags);
    printPV(rExtents);
    printPV(dwClipUnion);
    printPV(dwClipIntersection);
    printPV(texOffset);          
    printPV(normalOffset);       
    printPV(diffuseOffset);      
    printPV(specularOffset);     
    printPV(texOffsetOut);       
    printPV(diffuseOffsetOut);   
    printPV(specularOffsetOut);  
    printPV(dwClipMaskOffScreen);
    printPV(dwFirstClippedVertex);
    printPV(dwDP2VertexCount);   
    printPV(dwVertexPoolSize);   
    printPV(userClipPlane);   
    printPV(dwFlags2);   

pcomment("---------------- DIRECT3DDEVICEI ------------------------------------");
    printDevice(mCTM);
    printDevice(dwMaxTextureIndices);
    printDevice(lighting);
    printDevice(vcache);
    printDevice(dvExtentsAdjust);
    printDevice(lpdwRStates);
    printDevice(pD3DMappedTexI);
    printDevice(ClipperState);
    printDevice(dwVertexBase);
    printDevice(dwFlags);
    printDevice(dwDeviceFlags);
    printDevice(dwNumVertices);
    printDevice(dwNumPrimitives);
    printDevice(dwNumIndices);
    printDevice(lpwIndices);
    printDevice(primType);
    printDevice(nTexCoord);
    printDevice(position);
    printDevice(normal);
    printDevice(diffuse);
    printDevice(specular);
    printDevice(textures);
    printDevice(dwVIDIn);
    printDevice(dwVIDOut);
    printDevice(dwOutputSize);
    printDevice(lpvOut);
    printDevice(lpClipFlags);
    printDevice(rExtents);
    printDevice(dwClipUnion);
    printDevice(dwClipIntersection);
    printDevice(deviceType                );
    printDevice(lpDirect3DI               );
    printDevice(list                      );
    printDevice(texBlocks                 );
    printDevice(guid                      );
    printDevice(guid                      );
    printDevice(lpD3DHALCallbacks         );
    printDevice(lpD3DHALGlobalDriverData  );
    printDevice(lpD3DHALCallbacks2        );
    printDevice(lpD3DHALCallbacks3        );
    printDevice(lpDD                      );
    printDevice(lpDDGbl                   );
    printDevice(lpDDSTarget               );
    printDevice(lpDDSZBuffer              );
    printDevice(lpDDPalTarget             );
    printDevice(lpDDSTarget_DDS7          );
    printDevice(lpDDSZBuffer_DDS7         );
    printDevice(transform                 );
    printDevice(dwhContext                );
    printDevice(red_mask                  );
    printDevice(red_scale                 );
    printDevice(red_shift                 );
    printDevice(green_mask);
    printDevice(green_scale);
    printDevice(green_shift);
    printDevice(blue_mask);
    printDevice(blue_scale);
    printDevice(blue_shift);
    printDevice(zmask_shift);
    printDevice(stencilmask_shift);
    printDevice(bDDSTargetIsPalettized);
    printDevice(iClipStatus);
    printDevice(dwFEFlags);
    printDevice(dwDebugFlags);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(lightVertexFuncTable);
    printDevice(pHalProv);
    printDevice(hDllProv);
    printDevice(d3dDevDesc);
    printDevice(lpD3DMappedTexI);
    printDevice(lpD3DMappedBlock);
    printDevice(lpClipper);
    printDevice(dwHintFlags);
    printDevice(lpwDPBuffer);
    printDevice(dwCurrentBatchVID);
    printDevice(HVbuf);
    printDevice(lpD3DExtendedCaps);
    printDevice(rstates);
    printDevice(tsstates);
    printDevice(pfnRastService);
    printDevice(pGeometryFuncs);
    printDevice(mWV);
pcomment("---------------- CDirect3DDeviceIDP2 ----------------------");
    printDeviceDP2(lpDDSCB1);
    printDeviceDP2(allocatedBuf);
    printDeviceDP2(dp2data);
    printDeviceDP2(lpDP2CurrCommand);
    printDeviceDP2(wDP2CurrCmdCnt);
    printDeviceDP2(bDP2CurrCmdOP);
    printDeviceDP2(TLVbuf_size);
    printDeviceDP2(TLVbuf_base);
    printDeviceDP2(dwDP2CommandLength);
    printDeviceDP2(dwDP2CommandBufSize);
    printDeviceDP2(lpvDP2Commands);
    printDeviceDP2(dwDP2Flags);
#ifdef VTABLE_HACK
    printDeviceDP2(dwLastFlags);
    printDeviceDP2(lpDP2LastVBI);
#endif
pcomment("---------------- MISC ------------------------------------");
    /*                                     
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

pcomment("---------------- dwHintFlags-----------------------------------");

    pequate("D3DDEVBOOL_HINTFLAGS_INSCENE        ", D3DDEVBOOL_HINTFLAGS_INSCENE      );
    pequate("D3DDEVBOOL_HINTFLAGS_MULTITHREADED  ", D3DDEVBOOL_HINTFLAGS_MULTITHREADED);

pcomment("---------------- dwFEFlags ------------------------------------");

    pequate("D3DFE_WORLDMATRIX_DIRTY         ", D3DFE_WORLDMATRIX_DIRTY       );
    pequate("D3DFE_WORLDMATRIX1_DIRTY        ", D3DFE_WORLDMATRIX1_DIRTY      );
    pequate("D3DFE_WORLDMATRIX2_DIRTY        ", D3DFE_WORLDMATRIX2_DIRTY      );
    pequate("D3DFE_WORLDMATRIX3_DIRTY        ", D3DFE_WORLDMATRIX3_DIRTY      );
    pequate("D3DFE_TLVERTEX                  ", D3DFE_TLVERTEX                );
    pequate("D3DFE_REALHAL                   ", D3DFE_REALHAL                 );
    pequate("D3DFE_PROJMATRIX_DIRTY          ", D3DFE_PROJMATRIX_DIRTY        );
    pequate("D3DFE_VIEWMATRIX_DIRTY          ", D3DFE_VIEWMATRIX_DIRTY        );
    pequate("D3DFE_RECORDSTATEMODE           ", D3DFE_RECORDSTATEMODE         );
    pequate("D3DFE_EXECUTESTATEMODE          ", D3DFE_EXECUTESTATEMODE        );
    pequate("D3DFE_NEED_TRANSFORM_LIGHTS     ", D3DFE_NEED_TRANSFORM_LIGHTS   );
    pequate("D3DFE_MATERIAL_DIRTY            ", D3DFE_MATERIAL_DIRTY          );
    pequate("D3DFE_CLIPPLANES_DIRTY          ", D3DFE_CLIPPLANES_DIRTY        );
    pequate("D3DFE_LIGHTS_DIRTY              ", D3DFE_LIGHTS_DIRTY            );
    pequate("D3DFE_VERTEXBLEND_DIRTY         ", D3DFE_VERTEXBLEND_DIRTY       );
    pequate("D3DFE_FRUSTUMPLANES_DIRTY       ", D3DFE_FRUSTUMPLANES_DIRTY     );
    pequate("D3DFE_WORLDVIEWMATRIX_DIRTY     ", D3DFE_WORLDVIEWMATRIX_DIRTY   );
    pequate("D3DFE_FVF_DIRTY                 ", D3DFE_FVF_DIRTY               );
    pequate("D3DFE_NEED_TEXTURE_UPDATE       ", D3DFE_NEED_TEXTURE_UPDATE     );
    pequate("D3DFE_MAP_TSS_TO_RS             ", D3DFE_MAP_TSS_TO_RS           );
    pequate("D3DFE_INVWORLDVIEWMATRIX_DIRTY  ", D3DFE_INVWORLDVIEWMATRIX_DIRTY);
    pequate("D3DFE_LOSTSURFACES              ", D3DFE_LOSTSURFACES            );
    pequate("D3DFE_DISABLE_TEXTURES          ", D3DFE_DISABLE_TEXTURES        );
    pequate("D3DFE_CLIPMATRIX_DIRTY          ", D3DFE_CLIPMATRIX_DIRTY        );
    pequate("D3DFE_TLHAL                     ", D3DFE_TLHAL                   );
    pequate("D3DFE_STATESETS                 ", D3DFE_STATESETS               );

pcomment("---------------- pv->dwFlags ------------------------------------");
    pequate("D3DPV_FOG                   ", D3DPV_FOG                 );
    pequate("D3DPV_DOCOLORVERTEX         ", D3DPV_DOCOLORVERTEX       );
    pequate("D3DPV_LIGHTING              ", D3DPV_LIGHTING            );
    pequate("D3DPV_SOA                   ", D3DPV_SOA                 );
    pequate("D3DPV_COLORVERTEX_E         ", D3DPV_COLORVERTEX_E       );
    pequate("D3DPV_COLORVERTEX_D         ", D3DPV_COLORVERTEX_D       );
    pequate("D3DPV_COLORVERTEX_S         ", D3DPV_COLORVERTEX_S       );
    pequate("D3DPV_COLORVERTEX_A         ", D3DPV_COLORVERTEX_A       );
    pequate("D3DPV_DONOTCOPYSPECULAR     ", D3DPV_DONOTCOPYSPECULAR   );
    pequate("D3DPV_RESERVED1             ", D3DPV_RESERVED1           );
    pequate("D3DPV_RESERVED2             ", D3DPV_RESERVED2           );
    pequate("D3DPV_RESERVED3             ", D3DPV_RESERVED3           );
    pequate("D3DPV_NONCLIPPED            ", D3DPV_NONCLIPPED          );
    pequate("D3DPV_FRUSTUMPLANES_DIRTY   ", D3DPV_FRUSTUMPLANES_DIRTY );
    pequate("D3DPV_VBCALL                ", D3DPV_VBCALL              );
    pequate("D3DPV_DONOTCOPYTEXTURE      ", D3DPV_DONOTCOPYTEXTURE    );
    pequate("D3DPV_TLVCLIP               ", D3DPV_TLVCLIP             );
    pequate("D3DPV_TRANSFORMONLY         ", D3DPV_TRANSFORMONLY       );
    pequate("D3DPV_DONOTCOPYDIFFUSE      ", D3DPV_DONOTCOPYDIFFUSE    );
    pequate("D3DPV_PERSIST               ", D3DPV_PERSIST             );
pcomment("---------------- pv->dwDeviceFlags ------------------------------");
    pequate("D3DDEV_GUARDBAND            ", D3DDEV_GUARDBAND          );
    pequate("D3DDEV_RANGEBASEDFOG        ", D3DDEV_RANGEBASEDFOG      );
    pequate("D3DDEV_FOG                  ", D3DDEV_FOG                );
    pequate("D3DDEV_FVF                  ", D3DDEV_FVF                );
    pequate("D3DDEV_DONOTSTRIPELEMENTS   ", D3DDEV_DONOTSTRIPELEMENTS );
    pequate("D3DDEV_TEXTRANSFORMDIRTY    ", D3DDEV_TEXTRANSFORMDIRTY  );
    pequate("D3DDEV_REMAPTEXTUREINDICES  ", D3DDEV_REMAPTEXTUREINDICES);
    pequate("D3DDEV_TRANSFORMDIRTY       ", D3DDEV_TRANSFORMDIRTY     );
    pequate("D3DDEV_LIGHTSDIRTY          ", D3DDEV_LIGHTSDIRTY        );
    pequate("D3DDEV_DONOTCLIP            ", D3DDEV_DONOTCLIP          );
    pequate("D3DDEV_DONOTUPDATEEXTENTS   ", D3DDEV_DONOTUPDATEEXTENTS );
    pequate("D3DDEV_NOFVFANDNOTEXTURE    ", D3DDEV_NOFVFANDNOTEXTURE  );
    pequate("D3DDEV_TLVBUFWRITEONLY      ", D3DDEV_TLVBUFWRITEONLY    );
    pequate("D3DDEV_MODELSPACELIGHTING   ", D3DDEV_MODELSPACELIGHTING );
    pequate("D3DDEV_LOCALVIEWER          ", D3DDEV_LOCALVIEWER        );
    pequate("D3DDEV_NORMALIZENORMALS     ", D3DDEV_NORMALIZENORMALS   );
    pequate("D3DDEV_TEXTURETRANSFORM     ", D3DDEV_TEXTURETRANSFORM   );
    pequate("D3DDEV_STRIDE               ", D3DDEV_STRIDE             );
    pequate("D3DDEV_COLORVERTEX          ", D3DDEV_COLORVERTEX        );
    pequate("D3DDEV_INTERPOLATE_COLOR    ", D3DDEV_INTERPOLATE_COLOR  );
    pequate("D3DDEV_INTERPOLATE_SPECULAR ", D3DDEV_INTERPOLATE_SPECULAR);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

D3DFE_PVFUNCS GeometryFuncsGuaranteed; // Our implementation

//---------------------------------------------------------------------
void CheckWorldViewMatrix(LPD3DFE_PROCESSVERTICES pv)
{
    D3DMATRIXI *m = &pv->mWV;
    D3DMATRIXI res;
    res._11 = m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13;
    res._12 = m->_11*m->_21 + m->_12*m->_22 + m->_13*m->_23;
    res._13 = m->_11*m->_31 + m->_12*m->_32 + m->_13*m->_33;

    res._21 = m->_21*m->_11 + m->_22*m->_12 + m->_23*m->_13;
    res._22 = m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23;
    res._23 = m->_21*m->_31 + m->_22*m->_32 + m->_23*m->_33;

    res._31 = m->_31*m->_11 + m->_32*m->_12 + m->_33*m->_13;
    res._32 = m->_31*m->_21 + m->_32*m->_22 + m->_33*m->_23;
    res._33 = m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33;

    const D3DVALUE eps = 0.0001f;
    if (m->_14 == 0.0f && 
        m->_24 == 0.0f && 
        m->_34 == 0.0f && 
        m->_44 == 1.0f && 
        ABSF(res._12) < eps && 
        ABSF(res._13) < eps &&
        ABSF(res._21) < eps && 
        ABSF(res._23) < eps &&
        ABSF(res._31) < eps && 
        ABSF(res._32) < eps &&
        ABSF(1.0f - res._11) < eps && 
        ABSF(1.0f - res._22) < eps && 
        ABSF(1.0f - res._33) < eps)
    {
        pv->dwDeviceFlags |= D3DDEV_MODELSPACELIGHTING;
    }
    else
    {
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
    }
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
const DWORD __VPC_DIRTY = D3DFE_VIEWMATRIX_DIRTY |
                          D3DFE_PROJMATRIX_DIRTY;

void updateTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    if (lpDevI->dwFEFlags & D3DFE_PROJMATRIX_DIRTY)
    { 
      // We modify the projection matrix to make the clipping rules to be
      // 0 < x,y,z < w
        TRANSFORM.mPC._11 = (TRANSFORM.proj._11 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._12 = (TRANSFORM.proj._12 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._13 = TRANSFORM.proj._13;
        TRANSFORM.mPC._14 = TRANSFORM.proj._14;
        TRANSFORM.mPC._21 = (TRANSFORM.proj._21 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._22 = (TRANSFORM.proj._22 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._23 = TRANSFORM.proj._23;
        TRANSFORM.mPC._24 = TRANSFORM.proj._24;
        TRANSFORM.mPC._31 = (TRANSFORM.proj._31 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._32 = (TRANSFORM.proj._32 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._33 = TRANSFORM.proj._33;
        TRANSFORM.mPC._34 = TRANSFORM.proj._34;
        TRANSFORM.mPC._41 = (TRANSFORM.proj._41 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._42 = (TRANSFORM.proj._42 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._43 = TRANSFORM.proj._43;
        TRANSFORM.mPC._44 = TRANSFORM.proj._44;
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&TRANSFORM.mVPC, &TRANSFORM.view, &TRANSFORM.mPC);
        lpDevI->dwFEFlags |= D3DFE_CLIPMATRIX_DIRTY | D3DFE_CLIPPLANES_DIRTY;
    }

    MatrixProduct(&lpDevI->mCTM, &TRANSFORM.world[0], &TRANSFORM.mVPC);

    // Set dirty bit for world*view matrix (needed for fog and lighting)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX1_DIRTY |
                             D3DFE_WORLDMATRIX2_DIRTY |
                             D3DFE_WORLDMATRIX3_DIRTY))
    {
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY | 
                             D3DFE_INVWORLDVIEWMATRIX_DIRTY |
                             D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
    }

    if (lpDevI->dwFEFlags & (__VPC_DIRTY |
                             D3DFE_WORLDMATRIX1_DIRTY |
                             D3DFE_WORLDMATRIX2_DIRTY |
                             D3DFE_WORLDMATRIX3_DIRTY))
    {
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX1_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[0], &TRANSFORM.world[1], &TRANSFORM.mVPC);
        }
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX2_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[1], &TRANSFORM.world[2], &TRANSFORM.mVPC);
        }
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX3_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[2], &TRANSFORM.world[3], &TRANSFORM.mVPC);
        }
    }

    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;

    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_FRUSTUMPLANES_DIRTY;

    lpDevI->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//----------------------------------------------------------------------------
#ifdef DEBUG_PIPELINE

extern DWORD g_DebugFlags;

#endif
//
// DoUpdateState should be called for every DrawPrimitive call in the slow path,
// because it sets some internal pipeline flags. These flags are persistent for the
// fast path
//
void DoUpdateState(LPDIRECT3DDEVICEI lpDevI)
{
    // only set up lights if something has changed
    if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY) 
    {
        LPDIRECT3DLIGHTI    lpD3DLightI;
        lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_FIRST(&lpDevI->m_ActiveLights);
        lpDevI->lighting.activeLights = NULL;

        // Set lights in the device
        while (lpD3DLightI)
        {
            if (lpD3DLightI->m_LightI.flags & D3DLIGHTI_DIRTY)
                lpD3DLightI->SetInternalData();
            lpD3DLightI->m_LightI.next = lpDevI->lighting.activeLights;
            lpDevI->lighting.activeLights = &lpD3DLightI->m_LightI;
            lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_NEXT(lpD3DLightI, m_List);
        }
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_LIGHTING &&
        lpDevI->dwVIDOut & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
    {
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_FOG && lpDevI->dwVIDOut & D3DFVF_SPECULAR)
    {
        lpDevI->dwFlags |= D3DPV_FOG;
    }

    if (lpDevI->dwFEFlags & D3DFE_VERTEXBLEND_DIRTY)
    {
        lpDevI->dwNumVerBlends = min(lpDevI->rstates[D3DRENDERSTATE_VERTEXBLEND],
                                   ((lpDevI->dwVIDIn & D3DFVF_POSITION_MASK) >> 1) - 2);
        lpDevI->dwFEFlags &= ~D3DFE_VERTEXBLEND_DIRTY;
        // Lighting is done in the camera space when there is vertex blending
        if (lpDevI->dwNumVerBlends)
        {
            if (lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                lpDevI->dwDeviceFlags &= ~(D3DDEV_MODELSPACELIGHTING | D3DFE_NEEDCHECKWORLDVIEWVMATRIX);
                // We have to transform lights to the camera space
                lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
            }
        }
        else
        {
            if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                lpDevI->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
        }
    }

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(lpDevI);
    }
    // We need World-View matrix for lighting, fog and when texture coordinates
    // are taken from the vertex data in the camera space
    if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY &&
        (lpDevI->dwFlags & (D3DPV_LIGHTING | D3DPV_FOG) ||
        lpDevI->dwDeviceFlags & (D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE)))
    {
        MatrixProduct(&lpDevI->mWV, &lpDevI->transform.world[0],
                                    &lpDevI->transform.view);
        for (DWORD i=0; i < lpDevI->dwNumVerBlends; i++)
        {
            MatrixProduct(&lpDevI->mWV2[i], &lpDevI->transform.world[i+1],
                          &lpDevI->transform.view);
        }
        lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
    }
// Detect where to do lighting: in model or eye space 
    if (lpDevI->dwFEFlags & D3DFE_NEEDCHECKWORLDVIEWVMATRIX &&
        lpDevI->dwFlags & D3DPV_LIGHTING)
    {
        // We try to do lighting in the model space if
        // 1. we do not have to normalize normals 
        // 2. we do not need to do vertex blending
        lpDevI->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
        if (lpDevI->dwNumVerBlends == 0 &&
            !(lpDevI->dwDeviceFlags & D3DDEV_NORMALIZENORMALS))
        {
#ifdef DEBUG_PIPELINE
            if (!(g_DebugFlags & __DEBUG_MODELSPACE))
#endif
            {
                CheckWorldViewMatrix(lpDevI);
                lpDevI->dwFEFlags &= ~D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
            }
        }
        // If D3DDEV_MODELSPACELIGHTING has been changed we need to re-transform lights
        lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
    }
    
// Updating inverse World-View matrix
    if (lpDevI->dwFEFlags & D3DFE_INVWORLDVIEWMATRIX_DIRTY &&
        ((lpDevI->dwFlags & D3DPV_LIGHTING && !(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)) || 
         lpDevI->dwDeviceFlags & D3DDEV_NORMALINCAMERASPACE))
    {
        Inverse4x4((D3DMATRIX*)&lpDevI->mWV, (D3DMATRIX*)&lpDevI->mWVI);
        for (DWORD i=0; i < lpDevI->dwNumVerBlends; i++)
        {
            Inverse4x4((D3DMATRIX*)&lpDevI->mWV2[i], (D3DMATRIX*)&lpDevI->mWVI2[i]);
        }
        lpDevI->dwFEFlags &= ~D3DFE_INVWORLDVIEWMATRIX_DIRTY;
    }

    // Update clipping planes if there are any
    if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
    {
        if (lpDevI->dwFEFlags & D3DFE_CLIPMATRIX_DIRTY)
        {
            // View and projection matrix are inversed separately, because it 
            // is possible that combined matrix cannot be inverted. This could happend
            // when the view matrix has huge _43 value (> 10^7). Floating point precision
            // is not enough in this case
            D3DMATRIXI mPCInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.mPC, (D3DMATRIX*)&mPCInverse))
            {
                D3D_ERR("Cannot invert projection matrix");
                setIdentity((D3DMATRIXI*)&mPCInverse);
            }
            D3DMATRIXI mViewInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.view, (D3DMATRIX*)&mViewInverse))
            {
                D3D_ERR("Cannot invert view matrix");
                setIdentity((D3DMATRIXI*)&mViewInverse);
            }
            MatrixProduct(&lpDevI->transform.mVPCI, &mPCInverse, &mViewInverse);
            lpDevI->dwFEFlags &= ~D3DFE_CLIPMATRIX_DIRTY;
        }
        DWORD dwMaxUserClipPlanes = 0;
        DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
        for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
        {
            if (dwPlanes & (1 << i))
            {
                VecMatMul4HT(&lpDevI->transform.userClipPlane[i], 
                             (D3DMATRIX*)&lpDevI->transform.mVPCI, 
                             &lpDevI->userClipPlane[dwMaxUserClipPlanes]);
                dwMaxUserClipPlanes++;
            }
        }
        lpDevI->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
        lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
    }

    if (lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        // Set a flag for PSGP
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden 
    // by vertex alpha
    lpDevI->lighting.alpha = (DWORD)lpDevI->lighting.materialAlpha;
    lpDevI->lighting.alphaSpecular = (DWORD)lpDevI->lighting.materialAlphaS;

    if (!(lpDevI->dwVIDOut & D3DFVF_DIFFUSE))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
    if (!(lpDevI->dwVIDOut & D3DFVF_SPECULAR))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYSPECULAR;

    // This is a hint that only the inPosition pointer needs to be updated
    // for speed reasons.
    if (((lpDevI->dwVIDIn & ( D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_NORMAL)) == 0) && 
        (lpDevI->nTexCoord == 0))
        lpDevI->dwFlags |= D3DPV_TRANSFORMONLY;

    if (lpDevI->nOutTexCoord == 0)
        lpDevI->dwFlags |= D3DPV_DONOTCOPYTEXTURE;

     SetInterpolationFlags(lpDevI);

    lpDevI->dwFEFlags &= ~D3DFE_FRONTEND_DIRTY;
}
//---------------------------------------------------------------------
// Convert extents from floating point to integer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_ConvertExtent"

void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to)
{
    to->x1 = FTOI(from->x1) - 1;
    to->y1 = FTOI(from->y1) - 1;
    to->x2 = FTOI(from->x2) + 1;
    to->y2 = FTOI(from->y2) + 1;
    if (to->x1 < lpDevI->vcache.minXi)
        to->x1 = lpDevI->vcache.minXi;
    if (to->y1 < lpDevI->vcache.minYi)
        to->y1 = lpDevI->vcache.minYi;
    if (to->x2 > lpDevI->vcache.maxXi)
        to->x2 = lpDevI->vcache.maxXi;
    if (to->y2 > lpDevI->vcache.maxYi)
        to->y2 = lpDevI->vcache.maxYi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dtnl
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(INCLUDES)

C_DEFINES = $(C_DEFINES)
USE_NATIVE_EH = 1

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \
             $O\pvone.cpp \
             $O\loops.cpp

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp   \
    ..\helxfrm.cpp   \
    ..\rgblt.cpp     \
    $O\pvvid.cpp     \
    $O\pvone.cpp     \
    $O\loops.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__

extern void D3DFE_UpdateLights(LPDIRECT3DDEVICEI);

struct BATCHBUFFER;

extern "C"
{
void Directional7(LPD3DFE_PROCESSVERTICES pv, 
                  D3DI_LIGHT *light, 
                  D3DVERTEX *pInpCoord, 
                  D3DVECTOR *pInpNormal,
                  D3DLIGHTINGELEMENT *pEyeSpaceData);
void Directional7Model(LPD3DFE_PROCESSVERTICES pv, 
                       D3DI_LIGHT *light, 
                       D3DVERTEX *pInpCoord, 
                       D3DVECTOR *pInpNormal,
                       D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7(LPD3DFE_PROCESSVERTICES pv, 
                D3DI_LIGHT *light, 
                D3DVERTEX *pInpCoord, 
                D3DVECTOR *pInpNormal,
                D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7Model(LPD3DFE_PROCESSVERTICES pv, 
                     D3DI_LIGHT *light, 
                     D3DVERTEX *pInpCoord, 
                     D3DVECTOR *pInpNormal,
                     D3DLIGHTINGELEMENT *pEyeSpaceData);
void DirectionalFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
}

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX7)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\pvvid.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pvvid.h
 *  Content:    Common defines for the geometry inner loop
 *
 ***************************************************************************/
#ifndef _PVVID_H
#define _PVVID_H

#include "clipper.h"
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
extern void UpdateGeometryLoopData(LPD3DFE_PROCESSVERTICES pv);
// We use power of 2 because it preserves the mantissa when we multiply
const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void ComputeFogFactor(LPD3DFE_PROCESSVERTICES pv, D3DVALUE dist, DWORD *pOutput)
{
    if (pv->lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < pv->lighting.fog_start)
            D3DFE_SET_ALPHA((*pOutput), 255)
        else
        if (dist >= pv->lighting.fog_end)
            D3DFE_SET_ALPHA((*pOutput), 0)
        else
        {
            D3DVALUE v = (pv->lighting.fog_end - dist) * pv->lighting.fog_factor;
            int f = FTOI(v);
            D3DFE_SET_ALPHA((*pOutput), f)
        }
    }
    else
    {
        D3DVALUE tmp = dist*pv->lighting.fog_density;
        if (pv->lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        D3DFE_SET_ALPHA((*pOutput), f)
    }
}
//--------------------------------------------------------------------------
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//
void ComputeFog(LPD3DFE_PROCESSVERTICES pv, D3DVECTOR &v, D3DLIGHTINGELEMENT *le);
//---------------------------------------------------------------------
typedef void (*PFN_TEXTURETRANSFORM)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m);
typedef void (*PFN_TEXTURETRANSFORMLOOP)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m, 
                                        DWORD dwCount, DWORD dwInpStride, DWORD dwOutStride);

extern PFN_TEXTURETRANSFORM g_pfnTextureTransform[16];
extern PFN_TEXTURETRANSFORMLOOP g_pfnTextureTransformLoop[16];
//---------------------------------------------------------------------
inline void ComputeReflectionVector(D3DVECTOR *vertexPosition, D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVECTOR vertex = *vertexPosition;
    VecNormalizeFast(vertex);
    D3DVALUE dot = 2*(vertex.x * normal->x + vertex.y * normal->y + vertex.z * normal->z); 
    reflectionVector->x = vertex.x - dot*normal->x;
    reflectionVector->y = vertex.y - dot*normal->y;
    reflectionVector->z = vertex.z - dot*normal->z;
}
//---------------------------------------------------------------------
inline void ComputeReflectionVectorInfiniteViewer(D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVALUE dot = 2*normal->z; 
    reflectionVector->x = - dot*normal->x;
    reflectionVector->y = - dot*normal->y;
    reflectionVector->z = 1.0f - dot*normal->z;
}
#endif // _PVVID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp $(GENSYMFLAGS) -DIS_32
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS = 

INCPATHS = \
	-I$(BASEDIR)\public\sdk\inc\
	-I$(BASEDIR)\public\sdk\inc\crt\
	-I$(BASEDIR)\public\oak\inc\
	-I$(INCLUDES:;= -I)

..\pvvid.mcp: ..\pvvid.mh
..\pvone.mcp: ..\pvvid.mh
..\loops.mcp: ..\pvvid.mh

$(GENTGT)\pvvid.cpp: ..\pvvid.mcp $(RAST_STD_M4)
$(GENTGT)\pvone.cpp: ..\pvone.mcp $(RAST_STD_M4)
$(GENTGT)\loops.cpp: ..\loops.mcp $(RAST_STD_M4)

!ifndef SD_BUILD
COFFFILE = $(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt
!else
COFFFILE = $(BASEDIR)\tools\coffbase.txt
!endif


$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
   $(TARGET_CPP) -c $(INCPATHS) $(GENSYMFLAGS) -Fo$(GENSYMBASE).obj $(GENSYMSOURCE)
    -link -out:$(GENSYMEXE) @<<
-machine:$(TARGET_DIRECTORY)
-base:@$(COFFFILE),usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4089
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\msvcrt.lib
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
    -erase $(GENSYMBASE).obj
    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

// Functions to use when lighting is done in the camera space
LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional7,
    PointSpot7,
    DirectionalFirst,
    DirectionalNext,
    PointSpotFirst,
    PointSpotNext
};

// Functions to use when lighting is done in the model space
static LIGHT_VERTEX_FUNC_TABLE lightVertexTableModel =
{
    Directional7Model,
    PointSpot7Model,
    DirectionalFirstModel,
    DirectionalNextModel,
    PointSpotFirstModel,
    PointSpotNextModel
};
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}
//-------------------------------------------------------------------------
static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* result,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    result->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    result->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    result->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}
//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    BOOL        specular;       // TRUE, if specular component sould be computed
    D3DMATERIAL7 *mat = &LIGHTING.material;

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {

        if (lpDevI->lighting.material.power > D3DVAL(0.001))
        {
            if (lpDevI->lighting.material.power > D3DVAL(0.001))
            {
                SpecularTable* spec;

                for (spec = LIST_FIRST(&lpDevI->specular_tables);
                     spec;
                     spec = LIST_NEXT(spec,list))
                {
                    if (spec->power == lpDevI->lighting.material.power)
                        break;
                }
                if (spec == NULL)
                {
                    spec = CreateSpecularTable(lpDevI->lighting.material.power);
                    if (spec == NULL)
                    {
                        D3D_ERR("Failed tp create specular table");
                        throw DDERR_OUTOFMEMORY;
                    }
                    LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
                }
                lpDevI->specular_table = spec;
                lpDevI->lighting.specThreshold = D3DVAL(pow(0.001, 1.0/lpDevI->lighting.material.power));
            }
            else
                lpDevI->specular_table = NULL;
        }
        if (lpDevI->specular_table && lpDevI->dwDeviceFlags & D3DDEV_SPECULARENABLE)
            specular = TRUE;
        else
            specular = FALSE;

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.materialAlphaS = FTOI(D3DVAL(255) * mat->specular.a);
        if (LIGHTING.materialAlphaS < 0)
            LIGHTING.materialAlphaS = 0;
        else
            if (LIGHTING.materialAlphaS > 255)
                LIGHTING.materialAlphaS = 255 << 24;
            else LIGHTING.materialAlphaS <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        LIGHTING.diffuse0.r = LIGHTING.ambientSceneScaled.r * mat->ambient.r;
        LIGHTING.diffuse0.g = LIGHTING.ambientSceneScaled.g * mat->ambient.g;
        LIGHTING.diffuse0.b = LIGHTING.ambientSceneScaled.b * mat->ambient.b;
        LIGHTING.diffuse0.r += mat->emissive.r * D3DVAL(255);
        LIGHTING.diffuse0.g += mat->emissive.g * D3DVAL(255);
        LIGHTING.diffuse0.b += mat->emissive.b * D3DVAL(255);
        int r,g,b;
        r = (int)FTOI(LIGHTING.diffuse0.r);
        g = (int)FTOI(LIGHTING.diffuse0.g);
        b = (int)FTOI(LIGHTING.diffuse0.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        LIGHTING.dwDiffuse0 = (r << 16) + (g << 8) + b;
    }

    lpDevI->lighting.model_eye.x = (D3DVALUE)0;
    lpDevI->lighting.model_eye.y = (D3DVALUE)0;
    lpDevI->lighting.model_eye.z = (D3DVALUE)0;
    lpDevI->lighting.directionToCamera.x =  0;
    lpDevI->lighting.directionToCamera.y =  0;
    lpDevI->lighting.directionToCamera.z = -1;
    if (lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
    {
        inverseTransformVector(&lpDevI->lighting.model_eye, 
                               &lpDevI->lighting.model_eye,
                               &lpDevI->mWV);
        lpDevI->lightVertexFuncTable = &lightVertexTableModel;
        inverseRotateVector(&lpDevI->lighting.directionToCamera, 
                            &lpDevI->lighting.directionToCamera,
                            &lpDevI->mWV);
    }
    else
    {
        lpDevI->lightVertexFuncTable = &lightVertexTable;
    }
    while (light)
    {
        // Whenever light type is changed the D3DFE_NEED_TRANSFORM_LIGHTS should be set
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            { // Point and Spot lights
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnPointSpot;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnPointSpotFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnPointSpotNext;
                if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light position to the camera space
                    VecMatMul(&light->position, 
                              (D3DMATRIX*)&lpDevI->transform.view,
                              &light->model_position);
                }
                else
                {
                    inverseTransformVector(&light->model_position, &light->position,
                                           &lpDevI->transform.world[0]);
                }
            }
            else
            { // Directional light
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnDirectional;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnDirectionalFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnDirectionalNext;
            }

            if (light->type != D3DLIGHT_POINT)
            {
                // Light direction is flipped to be the direction TO the light
                if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light direction to the camera space
                    VecMatMul3(&light->direction, 
                               (D3DMATRIX*)&lpDevI->transform.view,
                               &light->model_direction);
                    VecNormalizeFast(light->model_direction);
                }
                else
                {
                    inverseRotateVector(&light->model_direction, &light->direction,
                                           &lpDevI->transform.world[0]);
                }
                VecNeg(light->model_direction, light->model_direction);
                // For the infinite viewer the half vector is constant
                if (!(lpDevI->dwDeviceFlags & D3DDEV_LOCALVIEWER))
                {
                    VecAdd(light->model_direction, lpDevI->lighting.directionToCamera,
                           light->halfway);
                    VecNormalizeFast(light->halfway);
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            light->diffuseMat.r = D3DVAL(255) * mat->diffuse.r * light->diffuse.r;
            light->diffuseMat.g = D3DVAL(255) * mat->diffuse.g * light->diffuse.g;
            light->diffuseMat.b = D3DVAL(255) * mat->diffuse.b * light->diffuse.b;


            if (!(light->flags & D3DLIGHTI_AMBIENT_IS_ZERO))
            {
                light->ambientMat.r = D3DVAL(255) * mat->ambient.r * light->ambient.r;
                light->ambientMat.g = D3DVAL(255) * mat->ambient.g * light->ambient.g;
                light->ambientMat.b = D3DVAL(255) * mat->ambient.b * light->ambient.b;
            }

            if (specular && !(light->flags & D3DLIGHTI_SPECULAR_IS_ZERO))
            {
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
                light->specularMat.r = D3DVAL(255) * mat->specular.r * light->specular.r;
                light->specularMat.g = D3DVAL(255) * mat->specular.g * light->specular.g;
                light->specularMat.b = D3DVAL(255) * mat->specular.b * light->specular.b;
            }
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }
        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCLIP_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCLIP_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCLIP_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCLIP_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCLIP_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCLIP_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCLIP_LEFT   dd  01h
gD3DCLIP_RIGHT  dd  02h
gD3DCLIP_TOP    dd  04h
gD3DCLIP_BOTTOM dd  08h
gD3DCLIP_FRONT  dd  10h
gD3DCLIP_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCLIP_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCLIP_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCLIP_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCLIP_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCLIP_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCLIP_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCLIP_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCLIP_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCLIP_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCLIP_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCLIP_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCLIP_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(D3DERR_BADMAJORVERSION),
    HRDEF(D3DERR_BADMINORVERSION),
    HRDEF(D3DERR_EXECUTE_LOCKED),
    HRDEF(D3DERR_EXECUTE_NOT_LOCKED),
    HRDEF(D3DERR_EXECUTE_CREATE_FAILED),
    HRDEF(D3DERR_EXECUTE_DESTROY_FAILED),
    HRDEF(D3DERR_EXECUTE_LOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_UNLOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_FAILED),
    HRDEF(D3DERR_EXECUTE_CLIPPED_FAILED),
    HRDEF(D3DERR_TEXTURE_NO_SUPPORT),
    HRDEF(D3DERR_TEXTURE_NOT_LOCKED),
    HRDEF(D3DERR_TEXTURE_LOCKED),
    HRDEF(D3DERR_TEXTURE_CREATE_FAILED),
    HRDEF(D3DERR_TEXTURE_DESTROY_FAILED),
    HRDEF(D3DERR_TEXTURE_LOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_UNLOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_LOAD_FAILED),
    HRDEF(D3DERR_MATRIX_CREATE_FAILED),
    HRDEF(D3DERR_MATRIX_DESTROY_FAILED),
    HRDEF(D3DERR_MATRIX_SETDATA_FAILED),
    HRDEF(D3DERR_SETVIEWPORTDATA_FAILED),
    HRDEF(D3DERR_MATERIAL_CREATE_FAILED),
    HRDEF(D3DERR_MATERIAL_DESTROY_FAILED),
    HRDEF(D3DERR_MATERIAL_SETDATA_FAILED),
    HRDEF(D3DERR_LIGHT_SET_FAILED),
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\tnl\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX7)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;

    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }

    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }

        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#if 0   // ndef WIN95
    // This is DEADCODE, that is can be potentially used on NT ONLY to
    // bring up a debugging prompt. It requires linking with NTDLL.LIB
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;

        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
            DebugBreak();
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }

        switch(szInput[0])
        {
        case 'b':
            DebugBreak();
            break;
        case 'g':
            return;

        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;

        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }

            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
#if DBG
    DebugBreak();
#endif
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;

        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;

            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;

    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;

        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");

        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;

    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;

    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }

    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>
#include "cppdbg.hpp"

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
#if DBG
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <d3dp.h>
#include <cppdbg.hpp>
#include "d3ditype.h"
#include "d3dflt.h"
#include "d3dutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3dflt.h>

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef __cplusplus
extern "C" {
#endif

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize((LPD3DVECTOR)&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2((LPD3DVECTOR)&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize((LPD3DVECTOR)(pVec))
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2((LPD3DVECTOR)(pVec), pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = (D3DVALUE) 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a 
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern DOUBLE g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\sources.inc ===
TARGETNAME = d3dutil
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = $(INCLUDES);$(D3DDX7)\tnl
        
SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\_dpf.cpp\
        ..\hrstr.cpp\
        ..\_memalloc.c

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D7: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\_memalloc.c ===
#include <stdlib.h>
#define __DXGUSEALLOC 1
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\init.c ===
#define INITGUID

#include <objbase.h>
#ifdef BUILD_MSREF
#include <d3dp.h>
#else   
#include <d3d.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\dprim2.cpp ===
//----------------------------------------------------------------------------
//
// dprim2.cpp
//
// Implements DrawPrimitives2.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
//---------------------------------------------------------------------
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};

HRESULT
RRFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride )
{
    if( NULL == pdwStride )
    {
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD vertexType = dwFVF & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if( dwFVF & g_TextureFormatMask[dwTexCoord] )
    {
        DPFM( 0, TNL, ("FVF has incorrect texture format") );
        return DDERR_INVALIDPARAMS;
    }

    if( dwFVF & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        ((dwFVF & D3DFVF_RESERVED1) && !(dwFVF & D3DFVF_LVERTEX)) )
    {
        DPFM( 0, TNL, ("FVF has reserved bit(s) set") );
        return DDERR_INVALIDPARAMS;
    }

    if( !(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5) )
    {
        DPFM( 0, TNL, ("FVF has incorrect position type") );
        return DDERR_INVALIDPARAMS;
    }

    if( (vertexType == D3DFVF_XYZRHW) && (dwFVF & D3DFVF_NORMAL) )
    {
        DPFM( 0, TNL, ("Normal should not be used with XYZRHW position type"));
        return DDERR_INVALIDPARAMS;
    }

    *pdwStride = GetFVFVertexSize( dwFVF );
    return D3D_OK;
}


inline D3DPRIMITIVETYPE ConvertDP2OPToPrimType(D3DHAL_DP2OPERATION Dp2Op)
{
    switch (Dp2Op)
    {
    case D3DDP2OP_POINTS              :
        return D3DPT_POINTLIST;
    case D3DDP2OP_INDEXEDLINELIST     :
    case D3DDP2OP_INDEXEDLINELIST2    :
    case D3DDP2OP_LINELIST_IMM        :
    case D3DDP2OP_LINELIST            :
        return D3DPT_LINELIST;
    case D3DDP2OP_TRIANGLELIST        :
    case D3DDP2OP_INDEXEDTRIANGLELIST :
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        return D3DPT_TRIANGLELIST;
    case D3DDP2OP_LINESTRIP           :
    case D3DDP2OP_INDEXEDLINESTRIP    :
        return D3DPT_LINESTRIP;
    case D3DDP2OP_TRIANGLESTRIP       :
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        return D3DPT_TRIANGLESTRIP;
    case D3DDP2OP_TRIANGLEFAN         :
    case D3DDP2OP_INDEXEDTRIANGLEFAN  :
    case D3DDP2OP_TRIANGLEFAN_IMM     :
        return D3DPT_TRIANGLEFAN;
    case D3DDP2OP_RENDERSTATE         :
    case D3DDP2OP_TEXTURESTAGESTATE   :
    case D3DDP2OP_VIEWPORTINFO        :
    case D3DDP2OP_WINFO               :
    default:
        DPFM(4, DRV, ("(RefRast)Non primitive operation operation in DrawPrimitives2"));
        return (D3DPRIMITIVETYPE)0;
    }
}



//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives2
//
// This is called by D3DIM for API DrawPrimitives2 to draw a set of primitives
// using a vertex buffer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data)
{
    HRESULT hr = D3D_OK;

    ReferenceRasterizer *pRefRast;
    DWORD dwStride;
    PUINT8 pVtData = NULL;

    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDPrim2Data);

    if( pDPrim2Data->lpVertices )
    {
        if (pDPrim2Data->dwFlags & D3DHALDP2_USERMEMVERTICES)
            pVtData = (PUINT8)pDPrim2Data->lpVertices + 
                pDPrim2Data->dwVertexOffset;
        else
            pVtData = (PUINT8)pDPrim2Data->lpDDVertex->lpGbl->fpVidMem + 
                pDPrim2Data->dwVertexOffset;
    }
    
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)
                                ((PUINT8)pDPrim2Data->lpDDCommands->lpGbl->fpVidMem +
                                 pDPrim2Data->dwCommandOffset);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd +
                               pDPrim2Data->dwCommandLength;


    // Unconditionally get the vertex stride, since it can not change
    if ((pDPrim2Data->ddrval = RRFVFCheckAndStride(
                        (DWORD)pDPrim2Data->dwVertexType, &dwStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pDPrim2Data->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    // Skip state check and texture lock if the first thing is state change
    //
    // WINFO is excluded here because it currently does not affect RGB/MMX
    // and refrast does not care if it changes between begin/endrendering.
    //
    // VIEWPORTINFO is excluded here because it is OK to change the viewport
    // between begin/endrendering on both RGB/MMX and Ref.
    //

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        LPDWORD lpdwRStates;
        if (pDPrim2Data->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            lpdwRStates = pDPrim2Data->lpdwRStates;
        else
            lpdwRStates = NULL;

        BOOL bWireframe = pRefRast->GetRenderState()[D3DRENDERSTATE_FILLMODE]
                        == D3DFILL_WIREFRAME;
        pDPrim2Data->ddrval = DoDrawPrimitives2(pRefRast,
                                                (UINT16)dwStride,
                                                (DWORD)pDPrim2Data->dwVertexType,
                                                pVtData,
                                                pDPrim2Data->dwVertexLength,
                                                &pCmd,
                                                lpdwRStates,
                                                bWireframe
                                                );
        if (pDPrim2Data->ddrval != D3D_OK)
        {
            if (pDPrim2Data->ddrval == D3DERR_COMMAND_UNPARSED)
            {
                pDPrim2Data->dwErrorOffset = (UINT32)((ULONG_PTR)pCmd -
                          (UINT_PTR)(pDPrim2Data->lpDDCommands->lpGbl->fpVidMem));
            }
            goto EH_Exit;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }

 EH_Exit:

    // As an optimization a check could be made here to see if it has
    // locked
    if (pRefRast->TexturesAreLocked())
    {
        hr = pRefRast->EndRendering();
        RefRastUnlockTexture(pRefRast);
        pRefRast->ClearTexturesLocked();
    }
    RefRastUnlockTarget(pRefRast);
    if (pDPrim2Data->ddrval == D3D_OK)
    {
        pDPrim2Data->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

HRESULT FASTCALL
DoDrawIndexedTriList2(ReferenceRasterizer *pCtx,
                  DWORD dwStride,
                  PUINT8 pVtx,
                  WORD cPrims,
                  D3DHAL_DP2INDEXEDTRIANGLELIST *pTriList)
{
    INT i;
    D3DHAL_DP2INDEXEDTRIANGLELIST *pTri = pTriList;

    for (i = 0; i < cPrims; i ++)
    {
        HRESULT hr;

        PUINT8 pVtx0, pVtx1, pVtx2;
        pVtx0 = pVtx + dwStride * pTri->wV1;
        pVtx1 = pVtx + dwStride * pTri->wV2;
        pVtx2 = pVtx + dwStride * pTri->wV3;
        pCtx->DrawTriangle(pVtx0, pVtx1, pVtx2, pTri->wFlags);
        pTri ++;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawPrimitives2
//
// It's called by RefRastDrawPrimitives2. .
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawPrimitives2(ReferenceRasterizer *pCtx,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  DWORD dwNumVertices,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe
                  )
{
    LPD3DHAL_DP2COMMAND pCmd = *ppCmd;
    HRESULT hr;

    DPFM(7, DRV, ("(RefRast)Read Ins: %08lx", *(LPDWORD)pCmd));

    //
    // Lock textures and setup the floating point state if the
    // command is a drawing command, only if it has not been locked before
    //
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_POINTS:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDLINELIST2:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        // If there is no vertex information, then we cannot draw, quit
        // with an error.
        if( NULL == pVtx )
            return DDERR_OUTOFMEMORY; // The most likely cause
        // Fall through
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:

        if (!pCtx->TexturesAreLocked())
        {
            HR_RET(RefRastLockTexture( pCtx ));
            HR_RET(pCtx->BeginRendering( dwFvf ));
            pCtx->SetTexturesLocked();
        }
    }

    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                hr = pCtx->BeginStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETEND    :
                hr = pCtx->EndStateSet();
                break;
            case D3DHAL_STATESETDELETE :
                hr = pCtx->DeleteStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETEXECUTE:
                hr = pCtx->ExecuteStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETCAPTURE:
                hr = pCtx->CaptureStateSet(pStateSetOp->dwParam);
                break;
            default :
                hr = DDERR_INVALIDPARAMS;
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetViewport(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetWRange(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetRenderStates(pCtx, dwFvf, pCmd, lpdwRStates));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2TextureStageState(pCtx, dwFvf, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    // This is a special case because it has edge flags. Other D3DDP2OP
    // can actually make use of DoDrawOneIndexedPrimitive/DoDrawOnePrimitive.
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDTRIANGLELIST" );

            WORD cPrims = pCmd->wPrimitiveCount;
            HR_RET(DoDrawIndexedTriList2(pCtx,
                                         dwStride,
                                         pVtx,
                                         cPrims,
                                         (D3DHAL_DP2INDEXEDTRIANGLELIST *)(pCmd + 1)));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                            sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDLINELIST" );

            HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                             dwStride,
                                             pVtx,
                                             (LPWORD)(pCmd + 1),
                                             D3DPT_LINELIST,
                                             pCmd->wPrimitiveCount * 2));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    // Following ops All use DoDrawOneIndexedPrimitive/DoDrawOnePrimitive.
    // There are some extra overheads introduced because those two functions
    // need to switch over the PrimTypes while we already know it here.
    // Striping out the code to add inline functions for each PrimType means
    // adding about twenty functions(considering the types of prim times types
    // of vertex). So I have used DoDrawOneIndexedPrimitive/DoDrawOnePrimitive
    // here anyway. We can later change it if necessary.
    case D3DDP2OP_POINTS:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            WORD i;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                for (i = 0; i < cPrims; i++)
                {
                    pCtx->SavePrimitiveData( dwFvf,
                                             (LPVOID) (pVtx +
                                                       pPt->wVStart * dwStride),
                                             pPt->wCount,
                                             D3DPT_POINTLIST );
                    HR_RET(pCtx->ProcessPrimitive( FALSE ));
                    pPt ++;
                }
            }
            else
            {
                for (i = 0; i < cPrims; i++)
                {
                    pCtx->SavePrimitiveData( dwFvf,
                                             (LPVOID) (pVtx +
                                                       pPt->wVStart * dwStride),
                                             pPt->wCount,
                                             D3DPT_POINTLIST );

                    HR_RET(DoDrawOnePrimitive(pCtx,
                                              dwStride,
                                              (PUINT8) (pVtx +
                                                        pPt->wVStart * dwStride),
                                              D3DPT_POINTLIST,
                                              pPt->wCount));
                    pPt ++;
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pLine->wVStart * dwStride),
                                     pCmd->wPrimitiveCount * 2,
                                     D3DPT_LINELIST );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pLine->wVStart * dwStride),
                                          D3DPT_LINELIST,
                                          pCmd->wPrimitiveCount * 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_LINELIST,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_LINELIST,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pLine->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 1,
                                     D3DPT_LINESTRIP );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pLine->wVStart * dwStride),
                                          D3DPT_LINESTRIP,
                                          pCmd->wPrimitiveCount + 1));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_LINESTRIP,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_LINESTRIP,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx + pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount * 3,
                                     D3DPT_TRIANGLELIST );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLELIST,
                                          pCmd->wPrimitiveCount * 3));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLELIST,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLELIST,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (pVtx + pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 2,
                                     D3DPT_TRIANGLESTRIP );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLESTRIP,
                                          pCmd->wPrimitiveCount + 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLESTRIP,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLESTRIP,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 2,
                                     D3DPT_TRIANGLEFAN );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLEFAN,
                                          pCmd->wPrimitiveCount + 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLEFAN,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLEFAN,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned:
            //                                             (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) +
                                       sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not. Only the dwFVF is interesting
            // so the rest of the stuff is NULL/0
            pCtx->SavePrimitiveData( dwFvf,
                                     NULL,
                                     0,
                                     D3DPT_TRIANGLEFAN,
                                     0,
                                     0 );


            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_TRIANGLEFAN_IMM" );

            if (bWireframe)
            {
                // Read edge flags
                UINT32 dwEdgeFlags =
                    ((LPD3DHAL_DP2TRIANGLEFAN_IMM)(pCmd + 1))->dwEdgeFlags;
                HR_RET(DoDrawOneEdgeFlagTriangleFan(pCtx,
                                                    dwStride,
                                                    pFanVtx,
                                                    vertexCount,
                                                    dwEdgeFlags));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          pFanVtx,
                                          D3DPT_TRIANGLEFAN,
                                          vertexCount));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not. Only the dwFVF is interesting
            // so the rest of the stuff is NULL/0
            pCtx->SavePrimitiveData( dwFvf,
                                     NULL,
                                     0,
                                     D3DPT_LINELIST,
                                     0,
                                     0 );



            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_LINELIST_IMM" );

            HR_RET(DoDrawOnePrimitive(pCtx,
                                      dwStride,
                                      pLineVtx,
                                      D3DPT_LINELIST,
                                      vertexCount));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetZRange(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetMaterial(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            DWORD dwSLStride = 0;
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetLight(pCtx, pCmd,
                                                          &dwSLStride));
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCmd  + dwSLStride);
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2CreateLight(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetTransform(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetExtention(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            HR_RET(pCtx->Dp2SetRenderTarget(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            HR_RET(pCtx->Clear(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetClipPlane(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    default :
        hr = D3DParseUnknownCommand((LPVOID)pCmd, (LPVOID*)ppCmd);
        break;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\util\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(ReferenceRasterizer *pCtx,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            pCtx->DrawPoint(pVtx);
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pCtx->DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pCtx->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                pCtx->DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            pCtx->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                pCtx->DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            pCtx->DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(ReferenceRasterizer *pCtx,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pCtx->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            pCtx->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                pCtx->DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(ReferenceRasterizer *pCtx,
                             UINT16 FvfStride,
                             PUINT8 pVtx,
                             UINT cVertices,
                             UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);
        return D3D_OK;
    }
    pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            pCtx->DrawTriangle(pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1);
        }
        else
        {
            pCtx->DrawTriangle(pV0, pV1, pV2, 0);
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);

    return D3D_OK;
}

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(ReferenceRasterizer *pCtx,
             LPD3DINSTRUCTION pIns,
             LPD3DTLVERTEX pVtx,
             LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            pCtx->DrawPoint((PUINT8)pV);
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(ReferenceRasterizer *pCtx,
            LPD3DINSTRUCTION pIns,
            LPD3DTLVERTEX pVtx,
            LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        pCtx->DrawLine((PUINT8)pV0, (PUINT8)pV1);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(ReferenceRasterizer *pCtx,
                LPD3DINSTRUCTION pIns,
                LPD3DTLVERTEX pVtx,
                LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        pCtx->DrawTriangle((PUINT8)pV0, (PUINT8)pV1, 
                           (PUINT8)pV2, pTri->wFlags);
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>

#include <ddraw.h>
#include <ddrawi.h>

#include <d3d.h>
#include "d3dhal.h"
#include "halprov.h"

#include "d3dref.h"
#include "refrast.hpp"     
//@@BEGIN_MSINTERNAL
#if 0
//@@END_MSINTERNAL
#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT
#include "EdgeFunc.hpp"     // edge function processing
#include "AttrFunc.hpp"     // attribute function processing
#include "refrasti.hpp"     // private interfaces
#include "clipping.hpp"
typedef unsigned long UINT_PTR, *PUINT_PTR; 
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "refprov.hpp"
#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\primfns.cpp ===
//----------------------------------------------------------------------------
//
// primfns.cpp
//
// Primitive functions for RAMP/RGB/REF.
//
// Copyright (C) Microsoft Corporation, 1998.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
extern void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
extern HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
extern void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

HRESULT WrapDp2SetViewport( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetViewport(pCmd);
}

HRESULT WrapDp2SetWRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetWRange(pCmd);
}

HRESULT WrapDp2SetZRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetZRange(pCmd);
}

HRESULT WrapDp2SetRenderStates( ReferenceRasterizer *pRefRast,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefRast->Dp2SetRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2SetTextureStageState( ReferenceRasterizer *pRefRast, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2SetMaterial ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetMaterial(pCmd);
}

HRESULT WrapDp2SetLight( ReferenceRasterizer *pRefRast,
                         LPD3DHAL_DP2COMMAND pCmd,
                         LPDWORD pdwStride )
{
    return pRefRast->Dp2SetLight(pCmd, pdwStride);
}

HRESULT WrapDp2CreateLight ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2CreateLight(pCmd);
}

HRESULT WrapDp2SetTransform( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetTransform(pCmd);
}

HRESULT WrapDp2SetExtention( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetExtention(pCmd);
}

HRESULT WrapDp2SetClipPlane( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetClipPlane(pCmd);
}

HRESULT WrapDp2RecViewport( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecViewport(pCmd);
}

HRESULT WrapDp2RecWRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecWRange(pCmd);
}

HRESULT WrapDp2RecZRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecZRange(pCmd);
}

HRESULT WrapDp2RecRenderStates( ReferenceRasterizer *pRefRast,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefRast->Dp2RecRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2RecTextureStageState( ReferenceRasterizer *pRefRast, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2RecMaterial ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecMaterial(pCmd);
}

HRESULT WrapDp2RecSetLight ( ReferenceRasterizer *pRefRast,
                             LPD3DHAL_DP2COMMAND pCmd,
                             LPDWORD pdwStride)
{
    return pRefRast->Dp2RecSetLight(pCmd, pdwStride);
}

HRESULT WrapDp2RecCreateLight( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecCreateLight(pCmd);
}

HRESULT WrapDp2RecTransform( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecTransform(pCmd);
}

HRESULT WrapDp2RecExtention( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecExtention(pCmd);
}

HRESULT WrapDp2RecClipPlane( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecClipPlane(pCmd);
}

static REF_STATESETFUNCTIONTBL StateRecFunctions =
{
    sizeof(REF_STATESETFUNCTIONTBL),
    WrapDp2RecRenderStates,
    WrapDp2RecTextureStageState,
    WrapDp2RecViewport,
    WrapDp2RecWRange,
    WrapDp2RecMaterial,
    WrapDp2RecZRange,
    WrapDp2RecSetLight,
    WrapDp2RecCreateLight,
    WrapDp2RecTransform,
    WrapDp2RecExtention,
    WrapDp2RecClipPlane
};

static REF_STATESETFUNCTIONTBL StateSetFunctions =
{
    sizeof(REF_STATESETFUNCTIONTBL),
    WrapDp2SetRenderStates,
    WrapDp2SetTextureStageState,
    WrapDp2SetViewport,
    WrapDp2SetWRange,
    WrapDp2SetMaterial,
    WrapDp2SetZRange,
    WrapDp2SetLight,
    WrapDp2CreateLight,
    WrapDp2SetTransform,
    WrapDp2SetExtention,
    WrapDp2SetClipPlane
};


void
ReferenceRasterizer::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        m_LastState = GetRenderState()[D3DRENDERSTATE_LASTPIXEL];
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, 0);
    }
    else
    {
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, m_LastState);
    }
}

void
ReferenceRasterizer::SetRecStateFunctions(void)
{
    pStateSetFuncTbl = &StateRecFunctions;
}

void
ReferenceRasterizer::SetSetStateFunctions(void)
{
    pStateSetFuncTbl = &StateSetFunctions;
}

HRESULT
ReferenceRasterizer::Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if (IS_OVERRIDE(type))
        {
            UINT32 override = GET_OVERRIDE(type);

            if (pRenderState->dwState)
                STATESET_SET(m_renderstate_override, override);
            else
                STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if (STATESET_ISSET(m_renderstate_override, type))
            continue;


        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

        // Set the state
        this->SetRenderState(pRenderState->RenderState,
                                 pRenderState->dwState);
    }

    return hr;
}

HRESULT
ReferenceRasterizer::Dp2SetTextureStageState(DWORD dwFvf,
                                          LPD3DHAL_DP2COMMAND pCmd )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2TEXTURESTAGESTATE  *pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);

    //
    // The textures are already locked, unlock them
    //
    if (TexturesAreLocked())
    {
        RefRastUnlockTexture(this);
    }

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        this->SetTextureStageState(pTexStageState->wStage,
                                   pTexStageState->TSState,
                                   pTexStageState->dwValue);
    }

    //
    // We didnt unset this bool, hence lock the textures back again
    //
    if (TexturesAreLocked())
    {
        HR_RET(RefRastLockTexture(this));
    }

    return hr;
}

HRESULT
ReferenceRasterizer::Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2VIEWPORTINFO pVpt;

    // Keep only the last viewport notification
    pVpt = (D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    m_Viewport.dwX = pVpt->dwX;
    m_Viewport.dwY = pVpt->dwY;
    m_Viewport.dwWidth = pVpt->dwWidth;
    m_Viewport.dwHeight = pVpt->dwHeight;
    m_dwDirtyFlags |= RRPV_DIRTY_VIEWRECT;

    // get render target; update it; put it back
    RRRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_Clip.left   = pVpt->dwX;
    pRendTgt->m_Clip.top    = pVpt->dwY;
    pRendTgt->m_Clip.right  = pVpt->dwX + pVpt->dwWidth - 1;
    pRendTgt->m_Clip.bottom = pVpt->dwY + pVpt->dwHeight - 1;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2WINFO pWInfo;

    // Keep only the last viewport notification
    pWInfo = (D3DHAL_DP2WINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // get render target; update it; put it back
    RRRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_fWRange[0]  = pWInfo->dvWNear;
    pRendTgt->m_fWRange[1]  = pWInfo->dvWFar;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    m_Viewport.dvMinZ = pZRange->dvMinZ;
    m_Viewport.dvMaxZ = pZRange->dvMaxZ;
    m_dwDirtyFlags |= RRPV_DIRTY_ZRANGE;

    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + (pCmd->wStateCount - 1);

    m_Material = *(D3DMATERIAL7 *)pSetMat;
    m_dwDirtyFlags |= RRPV_DIRTY_MATERIAL;

    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumCreateLight = pCmd->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)(pCmd + 1);
    HRESULT hr = D3D_OK;

    for (int i = 0; i < wNumCreateLight; i++, pCreateLight++)
    {
        // If the index is not already allocated, grow the light array
        // by REF_LIGHTARRAY_GROWTH_SIZE
        if (pCreateLight->dwIndex >= m_dwLightArraySize)
        {
            HR_RET(GrowLightArray(pCreateLight->dwIndex));
        }
    }

    return hr;
}

#define ARRAYGROW_DELTA     32 // Should be a power of 2

HRESULT
ReferenceRasterizer::GrowLightArray(const DWORD dwIndex)
{
    // Allocate a few extra in anticipation of more light being used in the
    // future
    DWORD dwNewArraySize = dwIndex+16;
    RRLight *pTmpActiveLights = NULL;
    RRLight *pTmpLightArray = new RRLight[dwNewArraySize];
    if (pTmpLightArray == NULL)
        return DDERR_OUTOFMEMORY;

    // Save all the created lights
    for (DWORD i=0; i<m_dwLightArraySize; i++)
    {
        // If it is a valid, i.e. a light that has been set,
        // then save it in the new array
        pTmpLightArray[i] = m_pLightArray[i];

        // If the light is enabled, update the ActiveList pointer
        if (m_pLightArray[i].IsEnabled())
        {
            pTmpLightArray[i].m_Next = pTmpActiveLights;
            pTmpActiveLights = &pTmpLightArray[i];
        }
    }
    delete m_pLightArray;
    m_lighting.pActiveLights = pTmpActiveLights;
    m_pLightArray = pTmpLightArray;
    m_dwLightArraySize = dwNewArraySize;
    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd,
                                 LPDWORD pdwStride)
{

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT( pdwStride != NULL, "pdwStride is Null" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);
    D3DLIGHT7 *pLightData = NULL;

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        _ASSERTf(dwIndex < m_dwLightArraySize,
                ( "Create was not called prior to the SetLight for light %d",
                 dwIndex ));

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            m_pLightArray[dwIndex].Enable(&m_lighting.pActiveLights);
            m_dwDirtyFlags |= RRPV_DIRTY_SETLIGHT;
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            m_pLightArray[dwIndex].Disable(&m_lighting.pActiveLights);
            break;
        case D3DHAL_SETLIGHT_DATA:
            pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
            dwStride += sizeof(D3DLIGHT7);
            HR_RET(m_pLightArray[pSetLight->dwIndex].SetLight(pLightData));
            m_dwDirtyFlags |= RRPV_DIRTY_SETLIGHT;
            break;
        default:
            DPFM(0,TNL,("Unknown SetLight command"));
            hr = DDERR_INVALIDPARAMS;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return hr;
}


HRESULT
ReferenceRasterizer::Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2SETTRANSFORM *pSetXfrm = (D3DHAL_DP2SETTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        this->SetXfrm( pSetXfrm->xfrmType, &pSetXfrm->matrix);
    }

    return D3D_OK;
}

static D3DMATRIX matIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

void
ReferenceRasterizer::SetXfrm(D3DTRANSFORMSTATETYPE xfrmType, D3DMATRIX *pMat)
{
    // ATTENTION is there a define for 0x80000000?
    BOOL bSetIdentity = (xfrmType & 0x80000000) != 0;
    DWORD dwxfrmType = (DWORD)xfrmType & (~0x80000000);
    switch (dwxfrmType)
    {
    case D3DTRANSFORMSTATE_WORLD:
        memcpy(&(m_xfmWorld[0]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLDXFM;
        break;
    case D3DTRANSFORMSTATE_VIEW:
        memcpy(&m_xfmView, pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_VIEWXFM;
        break;
    case D3DTRANSFORMSTATE_PROJECTION:
        memcpy(&m_xfmProj, pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_PROJXFM;
        break;
    case D3DTRANSFORMSTATE_WORLD1:
        memcpy(&(m_xfmWorld[1]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD1XFM;
        break;
    case D3DTRANSFORMSTATE_WORLD2:
        memcpy(&(m_xfmWorld[2]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD2XFM;
        break;
    case D3DTRANSFORMSTATE_WORLD3:
        memcpy(&(m_xfmWorld[3]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD3XFM;
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        {
            DWORD dwStage = xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
            if (bSetIdentity)
            {
                memcpy(&m_TextureStageState[dwStage].m_dwVal[D3DTSSI_MATRIX], &matIdent, sizeof(D3DMATRIX));
            }
            else
            {
                memcpy(&m_TextureStageState[dwStage].m_dwVal[D3DTSSI_MATRIX], pMat, sizeof(D3DMATRIX));
            }
        }
        break;
    default:
        DPFM(0,TNL,("Ignoring unknown transform type"));
    }
}


HRESULT
ReferenceRasterizer::Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumClipPlanes = pCmd->wStateCount;
    LPD3DHAL_DP2SETCLIPPLANE pSetClipPlane =
        (LPD3DHAL_DP2SETCLIPPLANE)(pCmd + 1);

    for (int i = 0; i < (int) wNumClipPlanes; i++, pSetClipPlane++)
    {
        _ASSERTf( pSetClipPlane->dwIndex < RRMAX_USER_CLIPPLANES,
                 ("Refrast does not support %d clip planes",
                  pSetClipPlane->dwIndex ) );

        memcpy( &m_userClipPlanes[pSetClipPlane->dwIndex],
                pSetClipPlane->plane, sizeof(RRVECTOR4) );
    }
    m_dwDirtyFlags |= RRPV_DIRTY_CLIPPLANES;

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecTextureStageState(DWORD dwFvf,
                                          LPD3DHAL_DP2COMMAND pCmd )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2VIEWPORTINFO));
}

HRESULT
ReferenceRasterizer::Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2WINFO));
}

HRESULT
ReferenceRasterizer::Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2ZRANGE));
}


HRESULT
ReferenceRasterizer::Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2SETMATERIAL));
}


HRESULT
ReferenceRasterizer::Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2CREATELIGHT);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd,
                                    LPDWORD pdwStride)
{
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT(pdwStride != NULL, "pdwStride is NULL" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            break;
        case D3DHAL_SETLIGHT_DATA:
            dwStride += sizeof(D3DLIGHT7);
            break;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return RecordStates((PUINT8)pCmd, *pdwStride);
}


HRESULT
ReferenceRasterizer::Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
ReferenceRasterizer::Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);

    return RecordStates((PUINT8)pCmd, dwSize);
}


//-----------------------------------------------------------------------------
//
// RecordStates - This function copies the state data into the internal stateset
// buffer. It assumes that the current state set has already been properly set
// up in BeginStateSet().
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::RecordStates(PUINT8 pData, DWORD dwSize)
{
    HRESULT ret;
    LPStateSetData pCurStateSets = m_pStateSets.CurrentItem();
    DWORD dwCurIdx = pCurStateSets->CurrentIndex();

    // Check if the buffer has enough space
    if ((ret = pCurStateSets->CheckAndGrow(dwCurIdx + dwSize,
                                            REF_STATESET_GROWDELTA)) != D3D_OK)
    {
        return ret;
    }
    // Copy the data and update the ptr.
    PUINT8 pDest = (PUINT8)&((*pCurStateSets)[dwCurIdx]);
    memcpy(pDest, pData, dwSize);
    pCurStateSets->SetCurrentIndex(dwCurIdx + dwSize);

    return D3D_OK;
}

HRESULT ReferenceRasterizer::RecordLastState(LPD3DHAL_DP2COMMAND pCmd,
                                             DWORD dwUnitSize)
{
    _ASSERT(pCmd->wStateCount != 0, "Number of states to record is zero" );
    if (pCmd->wStateCount == 1)
    {
        return RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND) + dwUnitSize);
    }
    else
    {
        HRESULT ret;
        WORD wCount = pCmd->wStateCount;
        pCmd->wStateCount = 1;
        ret = RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if (ret != D3D_OK)
        {
            return ret;
        }
        ret = RecordStates((PUINT8)(pCmd + 1) + dwUnitSize * (wCount - 1),
                            dwUnitSize);
        if (ret != D3D_OK)
        {
            return ret;
        }
        pCmd->wStateCount = wCount;
        return D3D_OK;
    }
}

HRESULT
ReferenceRasterizer::BeginStateSet(DWORD dwHandle)
{
    HRESULT ret;

    // Grow the array if no more space left
    if ((ret = m_pStateSets.CheckAndGrow(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    _ASSERT(m_pStateSets[dwHandle] == NULL, "pStateSets array is NULL" );

    // Create the new StateSet
    LPStateSetData pNewStateSet = new StateSetData;
    if (pNewStateSet == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }

    m_pStateSets.SetCurrentIndex(dwHandle);
    m_pStateSets.SetCurrentItem(pNewStateSet);

    // Switch to record mode
    SetRecStateFunctions();

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::EndStateSet(void)
{
    // Switch to execute mode
    SetSetStateFunctions();

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::ExecuteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if (pStateSet == NULL)
    {
        return DDERR_INVALIDPARAMS;
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)&((*pStateSet)[0]);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd + pStateSet->CurrentIndex();

    // Loop through the data, update render states
    for (;;)
    {
        ret = DoDrawPrimitives2(this,
                                (UINT16)0,
                                (DWORD)0,
                                NULL,
                                0,
                                &pCmd,
                                NULL,
                                0);
        if (ret != D3D_OK)
        {
            return ret;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::DeleteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    if (m_pStateSets[dwHandle] != NULL)
    {
        delete m_pStateSets[dwHandle];
        m_pStateSets[dwHandle] = NULL;
    }

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::CaptureStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if (pStateSet == NULL)
    {
        return DDERR_INVALIDPARAMS;
    }

    BYTE *p = &((*pStateSet)[0]);
    UINT_PTR pEnd = (UINT_PTR)(p + pStateSet->CurrentIndex());

    while((UINT_PTR)p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)p;
        p += sizeof(D3DHAL_DP2COMMAND);
        switch(pCmd->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2RENDERSTATE pData = (LPD3DHAL_DP2RENDERSTATE)p;
                    pData->dwState = GetRenderState()[pData->RenderState];
                    p += sizeof(D3DHAL_DP2RENDERSTATE);
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p += sizeof(D3DHAL_DP2SETLIGHT);
                    if(pData->dwIndex >= m_dwLightArraySize)
                    {
                        return D3DERR_LIGHT_SET_FAILED;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!m_pLightArray[pData->dwIndex].IsEnabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(m_pLightArray[pData->dwIndex].IsEnabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        m_pLightArray[pData->dwIndex].GetLight((LPD3DLIGHT7)p);
                        p += sizeof(D3DLIGHT7);
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = m_Material;
                    p += sizeof(D3DHAL_DP2SETMATERIAL);
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_WORLD:
                        pData->matrix = m_xfmWorld[0];
                        break;
                    case D3DTRANSFORMSTATE_WORLD1:
                        pData->matrix = m_xfmWorld[1];
                        break;
                    case D3DTRANSFORMSTATE_WORLD2:
                        pData->matrix = m_xfmWorld[2];
                        break;
                    case D3DTRANSFORMSTATE_WORLD3:
                        pData->matrix = m_xfmWorld[3];
                        break;
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = m_xfmView;
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = m_xfmProj;
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                    case D3DTRANSFORMSTATE_TEXTURE1:
                    case D3DTRANSFORMSTATE_TEXTURE2:
                    case D3DTRANSFORMSTATE_TEXTURE3:
                    case D3DTRANSFORMSTATE_TEXTURE4:
                    case D3DTRANSFORMSTATE_TEXTURE5:
                    case D3DTRANSFORMSTATE_TEXTURE6:
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&m_TextureStageState[pData->xfrmType - D3DTRANSFORMSTATE_TEXTURE0].m_dwVal[D3DTSSI_MATRIX]);
                        break;
                    }
                    p += sizeof(D3DHAL_DP2SETTRANSFORM);
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = m_TextureStageState[pData->wStage].m_dwVal[pData->TSState];
                    p += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    D3DVIEWPORT7 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = m_Viewport.dwX;
                    lpVwpData->dwY      = m_Viewport.dwY;
                    lpVwpData->dwWidth  = m_Viewport.dwWidth;
                    lpVwpData->dwHeight = m_Viewport.dwHeight;
                    p += sizeof(D3DHAL_DP2VIEWPORTINFO);
                }
                break;
            }
        case D3DDP2OP_ZRANGE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = m_Viewport.dvMinZ;
                    pData->dvMaxZ = m_Viewport.dvMaxZ;
                    p += sizeof(D3DHAL_DP2ZRANGE);
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPRRVECTOR4)pData->plane) = m_userClipPlanes[pData->dwIndex];
                    p += sizeof(D3DHAL_DP2SETCLIPPLANE);
                }
                break;
            }
        default:
            _ASSERT(FALSE, "Ununderstood DP2 command in Capture");
        }
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// SetRenderState -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetRenderState( DWORD dwState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwState >= D3DHAL_MAX_RSTATES )
    {
        return;
    }

    // set value in internal object
    m_dwRenderState[dwState] = dwValue;

    // do special validation work for some render states
    switch ( dwState )
    {

    case D3DRENDERSTATE_ANTIALIAS:
        m_bFragmentProcessingEnabled =
            ( D3DANTIALIAS_SORTINDEPENDENT == dwValue );
        break;
    case D3DRENDERSTATE_LIGHTING:
        if (dwValue)
            m_dwTLState |= RRPV_DOLIGHTING;
        else
            m_dwTLState &= ~RRPV_DOLIGHTING;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (dwValue)
            m_dwTLState |=  RRPV_DOCLIPPING;
        else
            m_dwTLState &=  ~RRPV_DOCLIPPING;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        {
            if (dwValue)
                m_dwTLState |=  RRPV_NORMALIZENORMALS;
            else
                m_dwTLState &=  ~RRPV_NORMALIZENORMALS;
        }
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        {
            if (dwValue)
                m_dwTLState |=  RRPV_LOCALVIEWER;
            else
                m_dwTLState &=  ~RRPV_LOCALVIEWER;
        }
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        {
            if (dwValue)
                m_dwTLState |= RRPV_DOSPECULAR;
            else
                m_dwTLState &= ~RRPV_DOSPECULAR;
        }
        break;
    case D3DRENDERSTATE_COLORVERTEX:
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
            m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
        break;
    case D3DRENDERSTATE_FOGCOLOR:
        {
            m_lighting.fog_color = (D3DCOLOR) dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLESTART:
        {
            m_lighting.fog_start = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEEND:
        {
            m_lighting.fog_end = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        {
            m_lighting.fog_density = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        {
            m_lighting.fog_mode = (int) dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            m_lighting.ambient_red   = D3DVAL(RGBA_GETRED(dwValue))/D3DVALUE(255);
            m_lighting.ambient_green = D3DVAL(RGBA_GETGREEN(dwValue))/D3DVALUE(255);
            m_lighting.ambient_blue  = D3DVAL(RGBA_GETBLUE(dwValue))/D3DVALUE(255);
            m_lighting.ambient_save  = dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_MATERIAL;
        }
        break;
    //
    // map legacy texture to multi-texture stage 0
    //
    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESS] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPMAPLODBIAS] = dwValue;
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_TextureStageState[0].m_dwVal[D3DTSS_BORDERCOLOR] = dwValue;
        break;
    case D3DRENDERSTATE_ANISOTROPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAXANISOTROPY] = dwValue;
        // fall thru to update filter state
    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        // map thru to set handle for first stage
        SetTextureStageState( 0, D3DTSS_TEXTUREMAP, dwValue );
        break;

    //
    // map legacy WRAPU/V state through to controls for tex coord 0
    //
    case D3DRENDERSTATE_WRAPU:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_U : 0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_V : 0);
        break;

    //
    // Scene Capture
    //
    case D3DRENDERSTATE_SCENECAPTURE:
        if (dwValue)
            SceneCapture(D3DHAL_SCENE_CAPTURE_START);
        else
            SceneCapture(D3DHAL_SCENE_CAPTURE_END);
        break;

    case D3DRENDERSTATE_CLIPPLANEENABLE:
        m_dwDirtyFlags |= RRPV_DIRTY_CLIPPLANES;
        break;

#ifdef __POINTSPRITES
    case D3DRENDERSTATE_POINTSIZE:
        m_fPointSize = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_A:
        m_fPointAttA = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_B:
        m_fPointAttB = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_C:
        m_fPointAttC = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTSIZEMIN:
        m_fPointSizeMin = m_fRenderState[dwState];
        break;
#endif //__POINTSPRITES
    }
}

extern DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

HRESULT ReferenceRasterizer::Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd)
{
    D3DHAL_SETRENDERTARGETDATA SRTDataOld;
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    BOOL bIsNew = FALSE;
    HRESULT hr;

    // Get new data by ignoring all but the last structure
    pSRTData = (D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Fill SRTDataOld with the info from the last SRTData struct
    // in the command
    DWORD handle = pSRTData->hRenderTarget;
    SRTDataOld.dwhContext = (ULONG_PTR)this;
    SRTDataOld.lpDDSLcl = GetDDSurfaceLocal(m_pDDLcl, handle, &bIsNew);
    if( SRTDataOld.lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        if (handle >= m_dwTexArrayLength)
        {
            HR_RET(GrowTexArray( handle ));
        }
        if (m_ppTextureArray[handle] == NULL)
        {
            if (TextureCreate(handle, &m_ppTextureArray[handle])
                == FALSE)
            {
                return DDERR_OUTOFMEMORY;
            }
            
            HR_RET(m_ppTextureArray[handle]->Initialize( 
                SRTDataOld.lpDDSLcl ));
        }
        else if( bIsNew )
        {
            HR_RET(m_ppTextureArray[handle]->Initialize( 
                SRTDataOld.lpDDSLcl ));
        }
    }
    
    if( pSRTData->hZBuffer )
    {
        bIsNew = FALSE;
        handle = pSRTData->hZBuffer;
        SRTDataOld.lpDDSZLcl = GetDDSurfaceLocal(m_pDDLcl, pSRTData->hZBuffer,
                                                 &bIsNew);
        if( SRTDataOld.lpDDSZLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        {
            if (handle >= m_dwTexArrayLength)
            {
                HR_RET(GrowTexArray( handle ));
            }
            if (m_ppTextureArray[handle] == NULL)
            {
                if (TextureCreate(handle, &m_ppTextureArray[handle])
                    == FALSE)
                {
                    return DDERR_OUTOFMEMORY;
                }
                
                HR_RET(m_ppTextureArray[handle]->Initialize( 
                    SRTDataOld.lpDDSZLcl ));
            }
            else if( bIsNew )
            {
                HR_RET(m_ppTextureArray[handle]->Initialize( 
                    SRTDataOld.lpDDSZLcl ));
            }
        }
    }
    else
        SRTDataOld.lpDDSZLcl = NULL;

    // Need to unlock the current target, first
    RefRastUnlockTarget(this);

    // Call the old function
    if ((hr = RefRastSetRenderTarget(&SRTDataOld)) != DDHAL_DRIVER_HANDLED)
        return hr;

    // Lock the new render target
    RefRastLockTarget(this);

    return SRTDataOld.ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\primfns.hpp ===
//-----------------------------------------------------------------------------
//
// Primitive functions for REFRast.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------
#ifndef __PRIMFNS_HPP_
#define __PRIMFNS_HPP_

#endif //__PRIMFNS_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\refif.hpp ===
//----------------------------------------------------------------------------
//
// refif.hpp
//
// Refrast front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFIF_HPP_
#define _REFIF_HPP_

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32


// Lock surfaces before rendering
inline HRESULT LockSurface(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, LPVOID *ppData)
{
    if (pDDSLcl)
    {
        if (!VIDEO_MEMORY(pDDSLcl))
        {
            if (SURFACE_LOCKED(pDDSLcl))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDSLcl);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                ddrval = DDInternalLock(pDDSLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    if (pDDSLcl && VIDEO_MEMORY(pDDSLcl))
    {
        DDInternalUnlock(pDDSLcl);
    }
}

HRESULT FASTCALL
DoRendPoints(ReferenceRasterizer * pCtx,
             LPD3DINSTRUCTION pIns,
             LPD3DTLVERTEX pVtx,
             LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(ReferenceRasterizer * pCtx,
            LPD3DINSTRUCTION pIns,
            LPD3DTLVERTEX pVtx,
            LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(ReferenceRasterizer *pCtx,
                LPD3DINSTRUCTION pIns,
                LPD3DTLVERTEX pVtx,
                LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(ReferenceRasterizer *pCtx,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  DWORD dwNumVertices,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
    );



// Macros to check if a pointer is valid
#if DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        DPFM(0, DRV, ("in %s, data pointer = NULL", (caller_name)));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        DPFM(0, DRV, ("in %s, dwhContext = NULL", (caller_name)));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  RRSurfaceType *pFmt);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

// DXT block size array
extern int g_DXTBlkSize[];

#endif // #ifndef _REFIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\rralloc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrmem.cpp
//
// Direct3D Reference Implementation - Memory functions
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//
// RRAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RRAlloc::operator new(size_t s)
{
    void* pMem = MEMALLOC( s );
    _ASSERTa( NULL != pMem, "malloc failure", return NULL; );
    return pMem;
}

void 
RRAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
}


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\refif.cpp ===
//----------------------------------------------------------------------------
//
// refrastfn.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// Primitive functions
#include "primfns.hpp"

#define MAX_CLIPPING_PLANES     12
#define MAX_CLIP_VERTICES       (( 2 * MAX_CLIPPING_PLANES ) + 3 )
#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

//----------------------------------------------------------------------------
//
// Stiches together device descs
//
//----------------------------------------------------------------------------
void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if(lpV1!=NULL)
    {
        lpOut->dwDevCaps = lpV1->dwDevCaps;
        lpOut->dpcLineCaps = lpV1->dpcLineCaps;
        lpOut->dpcTriCaps = lpV1->dpcTriCaps;
        lpOut->dwDeviceRenderBitDepth = lpV1->dwDeviceRenderBitDepth;
        lpOut->dwDeviceZBufferBitDepth = lpV1->dwDeviceZBufferBitDepth;
    }

    if (lpExt)
    {
        // DX5
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;

        // DX7
        lpOut->dwMaxActiveLights = lpExt->dwMaxActiveLights;
        lpOut->dvMaxVertexW = lpExt->dvMaxVertexW;
        lpOut->wMaxUserClipPlanes = lpExt->wMaxUserClipPlanes;
        lpOut->wMaxVertexBlendMatrices = lpExt->wMaxVertexBlendMatrices;
        lpOut->dwVertexProcessingCaps = lpExt->dwVertexProcessingCaps;
        lpOut->dwReserved1 = lpExt->dwReserved1;
        lpOut->dwReserved2 = lpExt->dwReserved2;
        lpOut->dwReserved3 = lpExt->dwReserved3;
        lpOut->dwReserved4 = lpExt->dwReserved4;
    }
}

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to RRSurfaceType.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt, RRSurfaceType *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = RR_STYPE_Z16S0; break;
        case 0xFFFFFF00:
            if (pDdPixFmt->dwStencilBitMask == 0x000000FF)
            {
                *pFmt = RR_STYPE_Z24S8;
            }
            else
            {
                *pFmt = RR_STYPE_Z24S4;
            }
            break;
        case 0x00FFFFFF:
            if (pDdPixFmt->dwStencilBitMask == 0xFF000000)
            {
                *pFmt = RR_STYPE_S8Z24;
            }
            else
            {
                *pFmt = RR_STYPE_S4Z24;
            }
            break;
        case 0x0000FFFE: *pFmt = RR_STYPE_Z15S1; break;
        case 0x00007FFF: *pFmt = RR_STYPE_S1Z15; break;
        case 0xFFFFFFFF: *pFmt = RR_STYPE_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = RR_STYPE_U8V8L8;
                break;
            case 16:
                *pFmt = RR_STYPE_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = RR_STYPE_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = RR_STYPE_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = RR_STYPE_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = RR_STYPE_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = RR_STYPE_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = RR_STYPE_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = RR_STYPE_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = RR_STYPE_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = RR_STYPE_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = RR_STYPE_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RR_STYPE_B8G8R8X8;
                break;
            case 24:
                *pFmt = RR_STYPE_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = RR_STYPE_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RR_STYPE_B5G5R5A1;
            }
            else
            {
                *pFmt = RR_STYPE_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = RR_STYPE_B5G5R5;
            break;
        case 0xff0:
            *pFmt = RR_STYPE_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = RR_STYPE_B4G4R4A4;
            break;
        case 0xff:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RR_STYPE_L4A4;
            }
            else
            {
                *pFmt = RR_STYPE_L8;
            }
            break;
        case 0xffff:
            *pFmt = RR_STYPE_L8A8;
            break;
        case 0xfc:
            *pFmt = RR_STYPE_B2G3R3;
            break;
        case 0xfffc:
            *pFmt = RR_STYPE_B2G3R3A8;
            break;
        default:
            *pFmt = RR_STYPE_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// RefRastLockTarget
//
// Lock current RenderTarget.
//
//----------------------------------------------------------------------------
HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast)
{
    HRESULT hr;
    RRRenderTarget *pRrTarget;

    pRrTarget = pRefRast->GetRenderTarget();

    HR_RET(LockSurface(pRrTarget->m_pDDSLcl, (LPVOID*)&(pRrTarget->m_pColorBufBits)));
    if (pRrTarget->m_pDDSZLcl)
    {
        HR_RET(LockSurface(pRrTarget->m_pDDSZLcl,
                         (LPVOID*)&(pRrTarget->m_pDepthBufBits)));
    }
    else
    {
        pRrTarget->m_pDepthBufBits = NULL;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastUnlockTexture
//
// Unlock current RenderTarget.
//
//----------------------------------------------------------------------------
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast)
{
    RRRenderTarget *pRrTarget;

    pRrTarget = pRefRast->GetRenderTarget();

    UnlockSurface(pRrTarget->m_pDDSLcl);
    if (pRrTarget->m_pDDSZLcl)
    {
        UnlockSurface(pRrTarget->m_pDDSZLcl);
    }
}


//----------------------------------------------------------------------------
//
// RRTextureMapSetSizes
//
// Sets sizes, pitches, etc, based on the current iFirstSurf.
//
//----------------------------------------------------------------------------
static HRESULT RRTextureMapSetSizes( RRTexture *pRRTex, INT iFirstSurf, INT cEnvMap )
{
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = pRRTex->m_pDDSLcl[iFirstSurf];
    RRSurfaceType SurfType = pRRTex->m_SurfType;
    INT i, j;

    // Init texturemap.
    pRRTex->m_iWidth = DDSurf_Width( pDDSLcl );
    pRRTex->m_iHeight = DDSurf_Height( pDDSLcl );

    for ( j = 0; j < cEnvMap; j++ )
    {
        if ((SurfType == RR_STYPE_DXT1) ||
            (SurfType == RR_STYPE_DXT2) ||
            (SurfType == RR_STYPE_DXT3) ||
            (SurfType == RR_STYPE_DXT4) ||
            (SurfType == RR_STYPE_DXT5))
        {
            // Note, here is the assumption that:
            // 1) width and height are reported correctly by the driver that
            //    created the surface
            // 2) The allocation of the memory is contiguous (as done by hel)
                pRRTex->m_iPitch[j] = ((pRRTex->m_iWidth+3)>>2) *
                g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
        }
        else
        {
                pRRTex->m_iPitch[j] = DDSurf_Pitch( pDDSLcl );
        }
    }

    // Check if the texture size is power of 2
    if (!ValidTextureSize((INT16)pRRTex->m_iWidth, (INT16)IntLog2(pRRTex->m_iWidth),
                          (INT16)pRRTex->m_iHeight, (INT16)IntLog2(pRRTex->m_iHeight)))
    {
        return DDERR_INVALIDPARAMS;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = (INT16)pRRTex->m_iWidth, iPreSizeV = (INT16)pRRTex->m_iHeight;
    for ( i = iFirstSurf + cEnvMap; i <= pRRTex->m_cLOD*cEnvMap; i += cEnvMap)
    {
        for ( j = 0; j < cEnvMap; j++ )
        {
            pDDSLcl = pRRTex->m_pDDSLcl[i+j];
            if (NULL == pDDSLcl) continue;
            if ((SurfType == RR_STYPE_DXT1) ||
                (SurfType == RR_STYPE_DXT2) ||
                (SurfType == RR_STYPE_DXT3) ||
                (SurfType == RR_STYPE_DXT4) ||
                (SurfType == RR_STYPE_DXT5))
            {
                // Note, here is the assumption that:
                // 1) width and height are reported correctly by the driver that
                //    created the surface
                // 2) The allocation of the memory is contiguous (as done by hel)
                pRRTex->m_iPitch[i-iFirstSurf+j] =
                    ((DDSurf_Width( pDDSLcl )+3)>>2) *
                    g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
            }
            else
            {
                    pRRTex->m_iPitch[i-iFirstSurf+j] = DDSurf_Pitch( pDDSLcl );
            }

            if (j == 0)
            {
                // Check for invalid mipmap texture size
                if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width( pDDSLcl )) ||
                    !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height( pDDSLcl )))
                {
                    return DDERR_INVALIDPARAMS;
                }
            }
            iPreSizeU = (INT16)DDSurf_Width( pDDSLcl );
            iPreSizeV = (INT16)DDSurf_Height( pDDSLcl );
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastLockTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast)
{
    INT i, j, k;
    RRTexture* pRRTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    HRESULT hr;
    int cActTex;

    if ((cActTex = pRefRast->GetCurrentTextureMaps(phTex, pRRTex)) == 0)
    {
        return D3D_OK;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        // Don't lock anything that is currently locked
        if ((pRRTex[j]->m_uFlags & RR_TEXTURE_LOCKED) == 0)
        {
            INT32 iMaxMipLevels = 0;
            if ( NULL != pRRTex[j]->m_pStageState )
            {
                iMaxMipLevels = pRRTex[j]->m_pStageState->m_dwVal[D3DTSS_MAXMIPLEVEL];
            }
            INT iFirstSurf = min(iMaxMipLevels, pRRTex[j]->m_cLODDDS);
            INT cEnvMap = (pRRTex[j]->m_uFlags & RR_TEXTURE_ENVMAP) ? (6) : (1);
            iFirstSurf *= cEnvMap;

            HR_RET(RRTextureMapSetSizes(pRRTex[j], iFirstSurf, cEnvMap));

            for (i = iFirstSurf; i <= pRRTex[j]->m_cLODDDS*cEnvMap; i += cEnvMap)
            {
                for ( k = 0; k < cEnvMap; k++ )
                {
                    hr = LockSurface(pRRTex[j]->m_pDDSLcl[i+k],
                                     (LPVOID*)&(pRRTex[j]->m_pTextureBits[i-iFirstSurf+k]));

                    if (hr != D3D_OK)
                    {
                        // Unlock any partial mipmap locks we've taken, as
                        // RastUnlock can only handle entire textures being
                        // locked or unlocked.
                            while (--i + k >= 0)
                        {
                                UnlockSurface(pRRTex[j]->m_pDDSLcl[i+k]);
                        }

                        // Make sure that i is signed and that the above
                        // loop exited properly.
                            _ASSERT(i+k < 0,
                                    "Unlock of partial mipmap locks failed" );

                        goto EH_Unlock;
                    }
                }
            }

            // Set the transparent bit and the transparent color with pDDS[0]
            LPDDRAWI_DDRAWSURFACE_LCL pLcl;
            pLcl = pRRTex[j]->m_pDDSLcl[0];
            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                pRRTex[j]->m_uFlags |= RR_TEXTURE_HAS_CK;
                pRRTex[j]->m_dwColorKey = pLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
            }
            else
            {
                pRRTex[j]->m_uFlags &= ~RR_TEXTURE_HAS_CK;
            }

            // set the empty face color with pDDS[0]
            // note that ddckCKDestOverlay is unioned with dwEmptyFaceColor, but
            // not in the internal structure
            pRRTex[j]->m_dwEmptyFaceColor = pLcl->ddckCKDestOverlay.dwColorSpaceLowValue;

            // Update palette
            if (pRRTex[j]->m_SurfType == RR_STYPE_PALETTE8 ||
                pRRTex[j]->m_SurfType == RR_STYPE_PALETTE4)
            {
                if (pLcl->lpDDPalette)
                {
                    LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                    pRRTex[j]->m_pPalette = (DWORD*)pPal->lpColorTable;
                    if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                    {
                        pRRTex[j]->m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
                    }
                }
            }

            pRRTex[j]->m_uFlags |= RR_TEXTURE_LOCKED;
        }
    }

    // validate texture internals
    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        if ( !(pRRTex[j]->Validate()) )
        {
            hr = DDERR_INVALIDPARAMS;
            goto EH_Unlock;
        }
    }

    return D3D_OK;

EH_Unlock:
    // Unlock complete textures we've already locked.
    // RastUnlock will check the flags to figure
    // out which ones to unlock.
    RefRastUnlockTexture(pRefRast);

    return hr;
}

//----------------------------------------------------------------------------
//
// RefRastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
//
//----------------------------------------------------------------------------
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast)
{
    INT i, j, k;
    RRTexture* pRRTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    int cActTex;

    if ((cActTex = pRefRast->GetCurrentTextureMaps(phTex, pRRTex)) == 0)
    {
        return ;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pRRTex[j]->m_uFlags & RR_TEXTURE_LOCKED)
        {
            INT32 iMaxMipLevels = 0;
            if ( NULL != pRRTex[j]->m_pStageState )
            {
                iMaxMipLevels = pRRTex[j]->m_pStageState->m_dwVal[D3DTSS_MAXMIPLEVEL];
            }
            INT iFirstSurf = min(iMaxMipLevels, pRRTex[j]->m_cLODDDS);
            INT cEnvMap = (pRRTex[j]->m_uFlags & RR_TEXTURE_ENVMAP) ? (6) : (1);
            iFirstSurf *= cEnvMap;

            for (i = iFirstSurf; i <= pRRTex[j]->m_cLODDDS*cEnvMap; i += cEnvMap)
            {
                for ( k = 0; k < cEnvMap; k++ )
                {
                    UnlockSurface(pRRTex[j]->m_pDDSLcl[i+k]);
                    pRRTex[j]->m_pTextureBits[i-iFirstSurf+k] = NULL;
                }
            }

            // Reset the flags
            pRRTex[j]->m_uFlags &= ~RR_TEXTURE_LOCKED;
            pRRTex[j]->m_uFlags &= ~RR_TEXTURE_HAS_CK;

            pRRTex[j]->Validate();
        }
    }
}

//----------------------------------------------------------------------------
//
// FillRRRenderTarget
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
FillRRRenderTarget(LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                   LPDDRAWI_DDRAWSURFACE_LCL pLclZ,
                   RRRenderTarget *pRrTarget)
{
    HRESULT hr;
    RRSurfaceType ColorFmt;
    RRSurfaceType ZFmt = RR_STYPE_NULL;

    // Release objects we hold pointers to
    if (pRrTarget->m_pDDSLcl)
    {
        pRrTarget->m_pDDSLcl = NULL;
    }
    if (pRrTarget->m_pDDSZLcl)
    {
        pRrTarget->m_pDDSZLcl = NULL;
    }

    HR_RET(FindOutSurfFormat(&DDSurf_PixFmt(pLclColor), &ColorFmt));

    if (NULL != pLclZ)
    {
        HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLclZ)), &ZFmt));
        pRrTarget->m_pDepthBufBits = (char *)SURFACE_MEMORY(pLclZ);
        pRrTarget->m_iDepthBufPitch = DDSurf_Pitch(pLclZ);
        pRrTarget->m_pDDSZLcl = pLclZ;
    }
    else
    {
        pRrTarget->m_pDepthBufBits = NULL;
        pRrTarget->m_iDepthBufPitch = 0;
        pRrTarget->m_pDDSZLcl = NULL;
    }

    pRrTarget->m_Clip.left = 0;
    pRrTarget->m_Clip.top = 0;
    pRrTarget->m_Clip.bottom = DDSurf_Height(pLclColor) - 1;
    pRrTarget->m_Clip.right = DDSurf_Width(pLclColor) - 1;
    pRrTarget->m_iWidth = DDSurf_Width(pLclColor);
    pRrTarget->m_iHeight = DDSurf_Height(pLclColor);
    pRrTarget->m_pColorBufBits = (char *)SURFACE_MEMORY(pLclColor);
    pRrTarget->m_iColorBufPitch = DDSurf_Pitch(pLclColor);
    pRrTarget->m_ColorSType = (RRSurfaceType)ColorFmt;
    pRrTarget->m_DepthSType = (RRSurfaceType)ZFmt;
    pRrTarget->m_pDDSLcl = pLclColor;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastContextCreate
//
// Creates a ReferenceRasterizer and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    ReferenceRasterizer *pRefRast;
    RRRenderTarget *pRendTgt;
    INT i;
    RRDEVICETYPE dwDriverType;

    // Surface7 pointers for QI
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    DPFM(0, DRV, ("In the new RefRast Dll\n"));

    // this only needs to be called once, but once per context won't hurt
    RefRastSetMemif(&malloc, &free, &realloc);

    if ((pRendTgt = new RRRenderTarget()) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    // If it is expected to be a DX7+ driver
    if (pCtxData->ddrval < (DWORD)RRTYPE_DX7HAL)
    {
        if (pCtxData->lpDDS)
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDS))->lpLcl;
        if (pCtxData->lpDDSZ)
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDSZ))->lpLcl;
    }
    else
    {
        pColorLcl = pCtxData->lpDDSLcl;
        pZLcl     = pCtxData->lpDDSZLcl;
    }

    // save the ddrval that is being sent down to communicate the driver
    // type that the runtime expects it to be.
    dwDriverType = (RRDEVICETYPE) pCtxData->ddrval;

    // Collect surface information where the failures are easy to handle.
    pCtxData->ddrval = FillRRRenderTarget(pColorLcl, pZLcl, pRendTgt);
    if (pCtxData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Note (Hacks):
    // dwhContext is used by the runtime to inform the driver, which
    // d3d interface is calling the driver.
    // ddrval is used by the runtime to inform the driver the DriverStyle
    // value it read. This is a RefRast specific hack.
    if ((pRefRast = new ReferenceRasterizer( pCtxData->lpDDLcl,
                                             (DWORD)(pCtxData->dwhContext),
                                             dwDriverType)) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pRefRast->SetRenderTarget(pRendTgt);

    //  return RR object pointer as context handle
    pCtxData->dwhContext = (ULONG_PTR)pRefRast;

    pCtxData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastContextDestroy
//
// Destroy a ReferenceRasterizer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastContextDestroy", pCtxDestroyData);

    // Clean up override bits

    RRRenderTarget *pRendTgt = pRefRast->GetRenderTarget();
    if ( NULL != pRendTgt ) { delete pRendTgt; }

    delete pRefRast;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSceneCapture
//
// Pass scene capture callback to ref rast.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastSceneCapture", pData);

    pRefRast->SceneCapture( pData->dwFlag );

    pData->ddrval = D3D_OK;        // Should this be changed to a QI ?

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSetRenderTarget
//
// Update a RefRast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    ReferenceRasterizer *pRefRast;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastSetRenderTarget", pTgtData);

    RRRenderTarget *pRendTgt = pRefRast->GetRenderTarget();
    if ( NULL == pRendTgt ) { return DDHAL_DRIVER_HANDLED; }


    if (pRefRast->IsInterfaceDX6AndBefore() ||
        pRefRast->IsDriverDX6AndBefore())
    {
        if( pTgtData->lpDDS )
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDS))->lpLcl;
        if( pTgtData->lpDDSZ )
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDSZ))->lpLcl;
    }
    else
    {
        pColorLcl = pTgtData->lpDDSLcl;
        pZLcl = pTgtData->lpDDSZLcl;
    }

    // Collect surface information.
    pTgtData->ddrval = FillRRRenderTarget(pColorLcl, pZLcl, pRendTgt);
    if (pTgtData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pRefRast->SetRenderTarget(pRendTgt);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastValidateTextureStageState
//
// Validate current blend operations.  RefRast does everything.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                               pOneIdxPrimData)
{
    ReferenceRasterizer *pRefRast;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawOneIndexedPrimitive",
                             pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval=RRFVFCheckAndStride(pOneIdxPrimData->dwFVFControl, &dwVStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval= RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
    {
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval=
         pRefRast->BeginRendering((DWORD)pOneIdxPrimData->dwFVFControl)) != D3D_OK)
    {
        RefRastUnlockTexture(pRefRast);
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
    DoDrawOneIndexedPrimitive(pRefRast,
                              (UINT16)dwVStride,
                              (PUINT8)pOneIdxPrimData->lpvVertices,
                              pOneIdxPrimData->lpwIndices,
                              pOneIdxPrimData->PrimitiveType,
                              pOneIdxPrimData->dwNumIndices);
    hr = pRefRast->EndRendering();
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    ReferenceRasterizer *pRefRast;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval=RRFVFCheckAndStride(pOnePrimData->dwFVFControl, &dwVStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
    {
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=
         pRefRast->BeginRendering(pOnePrimData->dwFVFControl)) != D3D_OK)
    {
        RefRastUnlockTexture(pRefRast);
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    pOnePrimData->ddrval =
        DoDrawOnePrimitive(pRefRast,
                           (UINT16)dwVStride,
                           (PUINT8)pOnePrimData->lpvVertices,
                           pOnePrimData->PrimitiveType,
                           pOnePrimData->dwNumVertices);
    hr = pRefRast->EndRendering();
    // Unlock texture/rendertarget
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    ReferenceRasterizer *pRefRast;
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
    // Check for FVF only if there is something to be drawn
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        // Unconditionally get the vertex stride, since it can not change
        if ((pDrawPrimData->ddrval =
             RRFVFCheckAndStride(pDrawPrimData->dwFVFControl, &dwVStride)) != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if ((pDrawPrimData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Skip BeginRendering & RefRastLockTexture if first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges <= 0)
    {
        if ((pDrawPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
        {
            RefRastUnlockTarget(pRefRast);
            return DDHAL_DRIVER_HANDLED;
        }
        if ((pDrawPrimData->ddrval =
             pRefRast->BeginRendering(pDrawPrimData->dwFVFControl)) != D3D_OK)
        {
            RefRastUnlockTexture(pRefRast);
            RefRastUnlockTarget(pRefRast);
            return DDHAL_DRIVER_HANDLED;
        }
    }
    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Update render states
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            UINT32 StateType,StateValue;
            LPDWORD pStateChange = (LPDWORD)pData;
            INT i;
            for (i = 0; i < pDrawPrimitiveCounts->wNumStateChanges; i++)
            {
                StateType = *pStateChange;
                pStateChange ++;
                StateValue = *pStateChange;
                pStateChange ++;
                pRefRast->SetRenderState(StateType, StateValue);
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                     sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
                ((ULONG_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // The texture might changed
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            RefRastUnlockTexture(pRefRast);
            if ((pDrawPrimData->ddrval=pRefRast->EndRendering()) != D3D_OK)
            {
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
            if ((pDrawPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
            {
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
            if ((pDrawPrimData->ddrval =
                 pRefRast->BeginRendering(pDrawPrimData->dwFVFControl)) != D3D_OK)
            {
                RefRastUnlockTexture(pRefRast);
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
        }

        // Draw primitives
        pDrawPrimData->ddrval =
            DoDrawOnePrimitive(pRefRast,
                               (UINT16)dwVStride,
                               (PUINT8)pData,
                               (D3DPRIMITIVETYPE)
                               pDrawPrimitiveCounts->wPrimitiveType,
                               pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * dwVStride;
    }

    EH_exit:
    hr = pRefRast->EndRendering();
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}



//----------------------------------------------------------------------------
//
// RefRastTextureCreate
//
// Creates a RefRast texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    ReferenceRasterizer *pRefRast;
    RRTexture* pRRTex;
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;

    if (pTexData->lpDDS)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pTexData->lpDDS)->lpLcl;
    }

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureCreate", pTexData);

    // Runtime shouldnt be calling TextureCreate for DX7 and newer
    // driver models
    if ((pRefRast->IsInterfaceDX6AndBefore() == FALSE) &&
        (pRefRast->IsDriverDX6AndBefore() == FALSE))
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // assume OKness
    pTexData->ddrval = D3D_OK;

    // Allocate RRTexture
    if ( !(pRefRast->TextureCreate(
        (LPD3DTEXTUREHANDLE)&(pTexData->dwHandle), &pRRTex ) ) )
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // Init texturemap.
    hr = pRRTex->Initialize( pLcl );
    if (hr != D3D_OK)
    {
        pTexData->ddrval = hr;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureDestroy
//
// Destroy a RefRast texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureDestroy", pTexDestroyData);

    // Runtime shouldnt be Calling TextureCreate for DX7 and newer
    // driver models
    if ((pRefRast->IsInterfaceDX6AndBefore() == FALSE) &&
        (pRefRast->IsDriverDX6AndBefore() == FALSE))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    if (!(pRefRast->TextureDestroy(pTexDestroyData->dwHandle)))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
    }
    else
    {
        pTexDestroyData->ddrval = D3D_OK;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureGetSurf", pTexGetSurf);

    pTexGetSurf->lpDDS = pRefRast->TextureGetSurf(pTexGetSurf->dwHandle);
    pTexGetSurf->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    ReferenceRasterizer *pRefRast;
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastRenderPrimitive", pRenderData);

    if (pRefRast->GetRenderState()[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(((LPDDRAWI_DDRAWSURFACE_INT)
                      (pRenderData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)((PUINT8)((LPDDRAWI_DDRAWSURFACE_INT)
                                    (pRenderData->lpTLBuf))->lpLcl->lpGbl->fpVidMem +
                           pRenderData->dwTLOffset);

    if ( (pRenderData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ( (pRenderData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ( (pRenderData->ddrval=pRefRast->BeginRendering(D3DFVF_TLVERTEX)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pRenderData->ddrval = DoRendPoints(pRefRast,
                                           pIns, pVtx,
                                           (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pRenderData->ddrval = DoRendLines(pRefRast,
                                          pIns, pVtx,
                                          (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pRenderData->ddrval = DoRendTriangles(pRefRast,
                                              pIns, pVtx,
                                              (LPD3DTRIANGLE)pPrim);
        break;
    default:
        DPFM(0, DRV, ("(RefRast) Wrong Opcode passed to the new rasterizer."));
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr = pRefRast->EndRendering();
    RefRastUnlockTarget(pRefRast);
    RefRastUnlockTexture(pRefRast);
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastRenderState
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastRenderState", pStateData);

    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
                       (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);

    // Updates states
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
        i < (INT)pStateData->dwCount;
        i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Set the state
        pRefRast->SetRenderState(type, pState->dwArg[0]);
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastGetDriverState
//
// Called by the runtime to get any kind of driver information
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGDSData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
#if DBG
    if ((pGDSData) == NULL)
    {
        DPFM(0, DRV, ("in %s, data pointer = NULL", "RefRastGetDriverState"));
        return DDHAL_DRIVER_HANDLED;
    }
    pRefRast = (ReferenceRasterizer *)((pGDSData)->dwhContext);
    if (!pRefRast)
    {
        DPFM(0, DRV, ("in %s, dwhContext = NULL", "RefRastGetDriverState"));
        pGDSData->ddRVal = D3DHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }
#else // !DBG
    pRefRast = (ReferenceRasterizer *)((pGDSData)->dwhContext);
#endif // !DBG

    //
    // No implementation yet, so nothing is understood yet
    //
    pGDSData->ddRVal = S_FALSE;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastHalProvider::GetCaps/GetInterface
//
// Returns the reference rasterizer's HAL interface.
//
//----------------------------------------------------------------------------

extern D3DDEVICEDESC7 g_nullDevDesc;

static D3DHAL_CALLBACKS Callbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    RefRastContextCreate,
    RefRastContextDestroy,
    NULL,
    RefRastSceneCapture,
    NULL,
    NULL,
    RefRastRenderState,
    RefRastRenderPrimitive,
    NULL,
    RefRastTextureCreate,
    RefRastTextureDestroy,
    NULL,
    RefRastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 Callbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
    D3DHAL2_CB32_DRAWONEPRIMITIVE |
    D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
    D3DHAL2_CB32_DRAWPRIMITIVES,
    RefRastSetRenderTarget,
    NULL,
    RefRastDrawOnePrimitive,
    RefRastDrawOneIndexedPrimitive,
    RefRastDrawPrimitives
};

static D3DHAL_CALLBACKS3 Callbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    RefRastValidateTextureStageState,
    RefRastDrawPrimitives2,  // DrawVB
};

static D3DDEVICEDESC7 RefDevDesc = { 0 };
static D3DHAL_D3DEXTENDEDCAPS RefExtCaps;

static void
FillOutDeviceCaps( BOOL bIsNullDevice )
{
    //
    //  set device description
    //
    RefDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_DRAWPRIMITIVES2EX    |
        D3DDEVCAPS_HWTRANSFORMANDLIGHT  ;

    RefDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    RefDevDesc.dpcTriCaps.dwMiscCaps =
    D3DPMISCCAPS_MASKZ    |
    D3DPMISCCAPS_CULLNONE |
    D3DPMISCCAPS_CULLCW   |
    D3DPMISCCAPS_CULLCCW  ;
    RefDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG |
        D3DPRASTERCAPS_ZFOG;
    RefDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    RefDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    RefDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    RefDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    RefDevDesc.dpcTriCaps.dwZCmpCaps;
    RefDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    RefDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TRANSPARENCY             |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_BORDER                   |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_COLORKEYBLEND;
    RefDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MINFANISOTROPIC  |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       |
        D3DPTFILTERCAPS_MAGFANISOTROPIC  ;
    RefDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    RefDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    RefDevDesc.dpcTriCaps.dwStippleWidth = 0;
    RefDevDesc.dpcTriCaps.dwStippleHeight = 0;

    //  line caps - copy tricaps and modify
    memcpy( &RefDevDesc.dpcLineCaps, &RefDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    //  disable antialias cap
    RefDevDesc.dpcLineCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
//        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
//        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG;

    RefDevDesc.dwDeviceRenderBitDepth = DDBD_16 | DDBD_24 | DDBD_32;
    RefDevDesc.dwDeviceZBufferBitDepth = DDBD_16 | DDBD_32;

    // DX5 stuff (should be in sync with the extended caps reported below)
    RefDevDesc.dwMinTextureWidth = 1;
    RefDevDesc.dwMaxTextureWidth = 4096;
    RefDevDesc.dwMinTextureHeight = 1;
    RefDevDesc.dwMaxTextureHeight = 4096;

    //
    //  set extended caps
    //
    RefExtCaps.dwSize = sizeof(RefExtCaps);

    RefExtCaps.dwMinTextureWidth = 1;
    RefExtCaps.dwMaxTextureWidth = 4096;
    RefExtCaps.dwMinTextureHeight = 1;
    RefExtCaps.dwMaxTextureHeight = 4096;
    RefExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    RefExtCaps.dwMaxStippleWidth = 0;
    RefExtCaps.dwMinStippleHeight = 0;
    RefExtCaps.dwMaxStippleHeight = 0;

    RefExtCaps.dwMaxTextureRepeat = 32768;
    RefExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    RefExtCaps.dwMaxAnisotropy = 16;

    RefExtCaps.dvGuardBandLeft   = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandTop    = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandRight  = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvGuardBandBottom = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    RefExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    RefExtCaps.dwFVFCaps = 8;   // max number of tex coord sets
    RefExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               ;
    RefExtCaps.wMaxTextureBlendStages = 8;
    RefExtCaps.wMaxSimultaneousTextures = 8;
    RefExtCaps.dwMaxActiveLights = 0xffffffff;
    RefExtCaps.dvMaxVertexW = 1.0e10;

    RefExtCaps.wMaxUserClipPlanes = RRMAX_USER_CLIPPLANES;
    RefExtCaps.wMaxVertexBlendMatrices = RRMAX_WORLD_MATRICES;

    RefExtCaps.dwVertexProcessingCaps = (D3DVTXPCAPS_TEXGEN            |
                                         D3DVTXPCAPS_MATERIALSOURCE7   |
                                         D3DVTXPCAPS_VERTEXFOG         |
                                         D3DVTXPCAPS_DIRECTIONALLIGHTS |
                                         D3DVTXPCAPS_POSITIONALLIGHTS  |
                                         D3DVTXPCAPS_LOCALVIEWER);
    RefExtCaps.dwReserved1 = 0;
    RefExtCaps.dwReserved2 = 0;
    RefExtCaps.dwReserved3 = 0;
    RefExtCaps.dwReserved4 = 0;
}


static D3DHAL_GLOBALDRIVERDATA RefDriverData;

static void DevDesc7ToDevDescV1( D3DDEVICEDESC_V1 *pOut, D3DDEVICEDESC7 *pIn )
{

    // These fields are not available in D3DDEVICEDESC7.
    // Zeroing them out, the front-end should not be using them
    //     DWORD            dwFlags
    //     D3DCOLORMODEL    dcmColorModel
    //     D3DTRANSFORMCAPS dtcTransformCaps
    //     BOOL             bClipping
    //     D3DLIGHTINGCAPS  dlcLightingCaps
    //     DWORD            dwMaxBufferSize
    //     DWORD            dwMaxVertexCount
    //     DWORD            dwMinStippleWidth, dwMaxStippleWidth
    //     DWORD            dwMinStippleHeight, dwMaxStippleHeight;
    //
    ZeroMemory( pOut, sizeof( D3DDEVICEDESC_V1 ) );
    pOut->dwSize = sizeof( D3DDEVICEDESC_V1 );

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
}

static void DevDesc7ToDevDesc( D3DDEVICEDESC *pOut, D3DDEVICEDESC7 *pIn )
{

    pOut->dwSize = sizeof( D3DDEVICEDESC );

    // These fields are not available in D3DDEVICEDESC7.
    // Setting them to some sensible values

    pOut->dwFlags =
        D3DDD_COLORMODEL            |
        D3DDD_DEVCAPS               |
        D3DDD_TRANSFORMCAPS         |
        D3DDD_LIGHTINGCAPS          |
        D3DDD_BCLIPPING             |
        D3DDD_LINECAPS              |
        D3DDD_TRICAPS               |
        D3DDD_DEVICERENDERBITDEPTH  |
        D3DDD_DEVICEZBUFFERBITDEPTH |
        D3DDD_MAXBUFFERSIZE         |
        D3DDD_MAXVERTEXCOUNT        ;
    pOut->dcmColorModel = D3DCOLOR_RGB;
    pOut->dtcTransformCaps.dwSize = sizeof(D3DTRANSFORMCAPS);
    pOut->dtcTransformCaps.dwCaps = D3DTRANSFORMCAPS_CLIP;
    pOut->bClipping = TRUE;
    pOut->dlcLightingCaps.dwSize = sizeof(D3DLIGHTINGCAPS);
    pOut->dlcLightingCaps.dwCaps =
        D3DLIGHTCAPS_POINT         |
        D3DLIGHTCAPS_SPOT          |
        D3DLIGHTCAPS_DIRECTIONAL   ;
    pOut->dlcLightingCaps.dwLightingModel = D3DLIGHTINGMODEL_RGB;
    pOut->dlcLightingCaps.dwNumLights = 0;
    pOut->dwMaxBufferSize = 0;
    pOut->dwMaxVertexCount = BASE_VERTEX_COUNT;
    pOut->dwMinStippleWidth  = 0;
    pOut->dwMaxStippleWidth  = 0;
    pOut->dwMinStippleHeight = 0;
    pOut->dwMaxStippleHeight = 0;

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
    pOut->dwMinTextureWidth = pIn->dwMinTextureWidth;
    pOut->dwMinTextureHeight = pIn->dwMinTextureHeight;
    pOut->dwMaxTextureWidth = pIn->dwMaxTextureWidth;
    pOut->dwMaxTextureHeight = pIn->dwMaxTextureHeight;
    pOut->dwMaxTextureRepeat = pIn->dwMaxTextureRepeat;
    pOut->dwMaxTextureAspectRatio = pIn->dwMaxTextureAspectRatio;
    pOut->dwMaxAnisotropy = pIn->dwMaxAnisotropy;
    pOut->dvGuardBandLeft = pIn->dvGuardBandLeft;
    pOut->dvGuardBandTop = pIn->dvGuardBandTop;
    pOut->dvGuardBandRight = pIn->dvGuardBandRight;
    pOut->dvGuardBandBottom = pIn->dvGuardBandBottom;
    pOut->dvExtentsAdjust = pIn->dvExtentsAdjust;
    pOut->dwStencilCaps = pIn->dwStencilCaps;
    pOut->dwFVFCaps = pIn->dwFVFCaps;
    pOut->dwTextureOpCaps = pIn->dwTextureOpCaps;
    pOut->wMaxTextureBlendStages = pIn->wMaxTextureBlendStages;
    pOut->wMaxSimultaneousTextures = pIn->wMaxSimultaneousTextures;
}

STDMETHODIMP
RefRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(FALSE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //  fill out GLOBALDRIVERDATA (initially zero)
    RefDriverData.dwSize = sizeof(RefDriverData);

    //
    // Need to fix up RefDriverData.hwCaps (D3DDEVICEDESC) from
    // rgbDevDesc (D3DDEVICEDESC7)
    //
    DevDesc7ToDevDescV1( &RefDriverData.hwCaps, &RefDevDesc );

    RefDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    RefDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    RefDriverData.dwNumTextureFormats =
        GetRefTextureFormats(IID_IDirect3DRefDevice,
                             &RefDriverData.lpTextureFormats, dwVersion);

    //  set interface data for return
    pInterfaceData->pGlobalData = &RefDriverData;
    pInterfaceData->pExtCaps = &RefExtCaps;
    pInterfaceData->pCallbacks = &Callbacks;
    pInterfaceData->pCallbacks2 = &Callbacks2;
    pInterfaceData->pCallbacks3 = &Callbacks3;

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if( dwVersion >= 4 )
    {
        pInterfaceData->pfnGetDriverState = RefRastGetDriverState;
    }

    return S_OK;
}

STDMETHODIMP
RefRastHalProvider::GetCaps(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DDEVICEDESC7 pHwDesc,
                            LPD3DDEVICEDESC7 pHelDesc,
                            DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(FALSE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if (dwVersion < 4)
    {
        ZeroMemory( pHwDesc, sizeof( D3DDEVICEDESC ));
        ((D3DDEVICEDESC *)pHwDesc)->dwSize = sizeof( D3DDEVICEDESC );
        DevDesc7ToDevDesc( (D3DDEVICEDESC *)pHelDesc, &RefDevDesc );
    }
    else
    {
        memcpy(pHwDesc, &g_nullDevDesc, sizeof(D3DDEVICEDESC7));
        memcpy(pHelDesc, &RefDevDesc, sizeof(D3DDEVICEDESC7));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// Null Device implementation section
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// NullDeviceContextCreate
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceContextCreate(LPD3DHAL_CONTEXTCREATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceContextDestroy
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceSceneCapture
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceSetRenderTarget
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawOneIndexedPrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawOnePrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawPrimitives
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawPrimitives2
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureCreate
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureCreate(LPD3DHAL_TEXTURECREATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureDestroy
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureGetSurf
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceRenderPrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceRenderState
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceRenderState(LPD3DHAL_RENDERSTATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
// NullDeviceValidateTextureStageState
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider::GetCaps/GetInterface
//
// Returns the null device's HAL interface.
// RefRast's caps are reflected by this device. Only the actual callbacks
// are different.
//----------------------------------------------------------------------------

static D3DHAL_CALLBACKS NullCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    NullDeviceContextCreate,
    NullDeviceContextDestroy,
    NULL,
    NullDeviceSceneCapture,
    NULL,
    NULL,
    NullDeviceRenderState,
    NullDeviceRenderPrimitive,
    NULL,
    NullDeviceTextureCreate,
    NullDeviceTextureDestroy,
    NULL,
    NullDeviceTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 NullCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
    D3DHAL2_CB32_DRAWONEPRIMITIVE |
    D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
    D3DHAL2_CB32_DRAWPRIMITIVES,
    NullDeviceSetRenderTarget,
    NULL,
    NullDeviceDrawOnePrimitive,
    NullDeviceDrawOneIndexedPrimitive,
    NullDeviceDrawPrimitives
};

static D3DHAL_CALLBACKS3 NullCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    NullDeviceValidateTextureStageState,
    NullDeviceDrawPrimitives2,
};

STDMETHODIMP
NullDeviceHalProvider::GetInterface(THIS_
                                    LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                    LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                    DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(TRUE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //  fill out GLOBALDRIVERDATA (initially zero)
    RefDriverData.dwSize = sizeof(RefDriverData);

    DevDesc7ToDevDescV1( &RefDriverData.hwCaps, &RefDevDesc );

    RefDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    RefDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    RefDriverData.dwNumTextureFormats =
        GetRefTextureFormats(IID_IDirect3DNullDevice,
                             &RefDriverData.lpTextureFormats, dwVersion);

    //  set interface data for return
    pInterfaceData->pGlobalData = &RefDriverData;
    pInterfaceData->pExtCaps = &RefExtCaps;
    pInterfaceData->pCallbacks = &NullCallbacks;
    pInterfaceData->pCallbacks2 = &NullCallbacks2;
    pInterfaceData->pCallbacks3 = &NullCallbacks3;

    return S_OK;
}

STDMETHODIMP
NullDeviceHalProvider::GetCaps(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DDEVICEDESC7 pHwDesc,
                               LPD3DDEVICEDESC7 pHelDesc,
                               DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    //  fill out device description & extended caps
    FillOutDeviceCaps(TRUE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if (dwVersion < 4)
    {
        ZeroMemory( pHwDesc, sizeof( D3DDEVICEDESC ));
        ((D3DDEVICEDESC *)pHwDesc)->dwSize = sizeof( D3DDEVICEDESC );
        DevDesc7ToDevDesc( (D3DDEVICEDESC *)pHelDesc, &RefDevDesc );
    }
    else
    {
        memcpy(pHwDesc, &g_nullDevDesc, sizeof(D3DDEVICEDESC7));
        memcpy(pHelDesc, &RefDevDesc, sizeof(D3DDEVICEDESC7));
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\refprov.hpp ===
//----------------------------------------------------------------------------
//
// refprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFPROV_HPP_
#define _REFPROV_HPP_

//----------------------------------------------------------------------------
//
// RefHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class RefHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _REFPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\sources.inc ===
TARGETNAME=refdrv
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES =             \
    ..\refprov.cpp    \
    ..\refif.cpp      \
    ..\dprim2.cpp     \
    ..\primfns.cpp    \
    ..\drawprim.cpp   \
    ..\rralloc.cpp    \
    ..\init.c

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\drv\refprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC7 g_nullDevDesc =
{
    0,                          /* dwDevCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwMaxBufferSize */
    0,                          /* dwMaxVertexCount */
    0, 0,
    0, 0,
};


//----------------------------------------------------------------------------
//
// RefHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP RefHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// RefHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) RefHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// RefHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) RefHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// GetRefHALProvider
//
// Returns the appropriate reference software HAL provider based on the given
// GUID.
//
//----------------------------------------------------------------------------

static RefRastHalProvider g_RefRastHalProvider;
static NullDeviceHalProvider g_NullDeviceHalProvider;

STDAPI GetRefHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRefDevice))
    {
        *ppHalProvider = &g_RefRastHalProvider;
    }
    else if (IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        *ppHalProvider = &g_NullDeviceHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   28

STDAPI
GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd,
                     DWORD dwVersion)
{
    int i = 0;

    static DDSURFACEDESC ddsd_RefNull_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RefNull_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (dwVersion >= 3)
    {
        ddsd = ddsd_RefNull_Dev3;
    }
    else
    {
        ddsd = ddsd_RefNull_Dev2;
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    /* 1555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    // A formats for PC98 consistency
    // 4444 ARGB (it is already supported by S3 Virge)
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
    ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
    ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
    ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

    i++;

    if (dwVersion >= 2)
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        // A couple of formats for PC98 consistency
        // UYVY
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('U', 'Y', 'V', 'Y');

        i++;

            // YVY2
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'U', 'Y', '2');

        i++;

        // S3 compressed texture format 1
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '1');

        i++;

        // S3 compressed texture format 2
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '2');

        i++;

        // S3 compressed texture format 3
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '3');

        i++;

        // S3 compressed texture format 4
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '4');

        i++;

        // S3 compressed texture format 5
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '5');

        i++;

        // Add a few bump map formats
        // U8V8
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x00ff;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0x0;

        i++;

        // U5V5L6
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
            DDPF_BUMPLUMINANCE;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x001f;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xfc00;

        i++;

        // U8V8L8
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
            DDPF_BUMPLUMINANCE;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 24;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x0000ff;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x00ff00;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xff0000;

        i++;

        /* 8 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask =  0xf0;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0x0f;

        i++;

        // 8332 16-bit ARGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x00e0;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x001c;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x0003;

        i++;

#if 0
// for Shadow Buffer prototype API

        // Z16S0 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 16;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 0;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffff;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x0000;

        i++;

        // Z24S8 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 32;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 8;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffffff00;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x000000ff;

        i++;

        // Z15S1 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 16;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 1;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xfffe;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x0001;

        i++;

        // Z32S0 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 32;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 0;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffffffff;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x00000000;

        i++;
#endif

    }

    *lplpddsd = ddsd;

    return i;
}

#define NUM_SUPPORTED_ZBUFFER_FORMATS   8


//----------------------------------------------------------------------------
//
// GetRefZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

STDAPI
GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    /* 15 bit Z; 1 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 1;
    DDPF[i].dwZBitMask = 0xfffe;
    DDPF[i].dwStencilBitMask = 0x0001;

    i++;

    /* 32bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffffffff;
    DDPF[i].dwStencilBitMask = 0x00000000;

    i++;

    /* 8 bit stencil; 24 bit Z  */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0x00ffffff;
    DDPF[i].dwStencilBitMask = 0xff000000;

    i++;

    /* 1 bit stencil; 15 bit Z */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 1;
    DDPF[i].dwZBitMask = 0x7fff;
    DDPF[i].dwStencilBitMask = 0x8000;

    i++;

    /* 24 bit Z; 4 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 4;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x0000000f;

    i++;

    /* 4 bit stencil; 24 bit Z  */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 4;
    DDPF[i].dwZBitMask = 0x00ffffff;
    DDPF[i].dwStencilBitMask = 0x0f000000;

    i++;

    *ppDDPF = DDPF;

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\d3dref.h ===
//----------------------------------------------------------------------------
//
// d3dref.h
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DREF_H_
#define _D3DREF_H_


STDAPI GetRefHalProvider(REFCLSID riid,
                         IHalProvider **ppHalProvider, HINSTANCE *phDll);
STDAPI GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

typedef HRESULT (STDAPICALLTYPE* PFNGETREFHALPROVIDER)(REFCLSID,IHalProvider**,HINSTANCE*);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFZBUFFERFORMATS)(REFCLSID, DDPIXELFORMAT**);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFTEXTUREFORMATS)(REFCLSID, LPDDSURFACEDESC*, DWORD);

inline FARPROC LoadReferenceDeviceProc( char* szProc )
{
    HINSTANCE hRefDLL;
    if (NULL == (hRefDLL = LoadLibrary("d3dref.dll")) )
    {
        return NULL;
    }
    return GetProcAddress(hRefDLL, szProc);
}

#endif // #ifndef _D3DREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\refutil.h ===
//----------------------------------------------------------------------------
//
// refutil.h
//
// Umbrella header file for the reference implementation
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFUTIL_H_
#define _REFUTIL_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3dref.h>
#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>
#include <d3dflt.h>

#endif // #ifndef _REFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\refrast.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrast.hpp
//
// Direct3D Reference Rasterizer - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRAST_HPP
#define  _REFRAST_HPP

// Leave this defined so various all the code compiles.  However,
// it will never be set, since it is a part of D3DFVF_RESERVED2 until
// DX8.
#define D3DFVF_S                0x1000
#include <rrutil.hpp>
#include <reftnl.hpp>

#include <templarr.hpp>

//-----------------------------------------------------------------------------
//
// Uncomment this to enable point sprites in the reference rasterizer
//
//-----------------------------------------------------------------------------
//#define __POINTSPRITES 1

//-----------------------------------------------------------------------------
//
// Uncomment this to enable shadowbuffer in the reference rasterizer
//
//-----------------------------------------------------------------------------
//#define __SHADOWBUFFER 1

//-----------------------------------------------------------------------------
//
// RefRastSetMemif - Routine to set memory allocation interface for reference
// rasterizer - takes pointers to functions to use for malloc, free, and realloc.
//
// These must be set prior to new'ing any ReferenceRasterizer objects.  These are
// used for allocating rasterizer objects, and for allocation of the fragment
// pointer array and fragment records used for sort-independent antialiasing and
// transluscency.
//
//-----------------------------------------------------------------------------
void
RefRastSetMemif(
    LPVOID( _cdecl* pfnMemAlloc )( size_t ),
    void( _cdecl* pfnMemFree )( PVOID ),
    LPVOID( _cdecl* pfnMemReAlloc )( PVOID, size_t ) );

//-----------------------------------------------------------------------------
//
// Surface types for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RRSurfaceType
{
    RR_STYPE_NULL     = 0,
    RR_STYPE_B8G8R8   = 1,
    RR_STYPE_B8G8R8A8 = 2,
    RR_STYPE_B8G8R8X8 = 3,
    RR_STYPE_B5G6R5   = 4,
    RR_STYPE_B5G5R5   = 5,
    RR_STYPE_PALETTE4 = 6,
    RR_STYPE_PALETTE8 = 7,
    RR_STYPE_B5G5R5A1 = 8,
    RR_STYPE_B4G4R4   = 9,
    RR_STYPE_B4G4R4A4 =10,
    RR_STYPE_L8       =11,          // 8 bit luminance-only
    RR_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RR_STYPE_U8V8     =13,          // 16 bit bump map format
    RR_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RR_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RR_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RR_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RR_STYPE_DXT1     =18,          // S3 texture compression technique 1
    RR_STYPE_DXT2     =19,          // S3 texture compression technique 2
    RR_STYPE_DXT3     =20,          // S3 texture compression technique 3
    RR_STYPE_DXT4     =21,          // S3 texture compression technique 4
    RR_STYPE_DXT5     =22,          // S3 texture compression technique 5
    RR_STYPE_B2G3R3   =23,          // 8 bit RGB texture format
    RR_STYPE_L4A4     =24,          // 8 bit alpha-luminance
    RR_STYPE_B2G3R3A8 =25,          // 16 bit alpha-rgb

    RR_STYPE_Z16S0    =32,
    RR_STYPE_Z24S8    =33,
    RR_STYPE_Z15S1    =34,
    RR_STYPE_Z32S0    =35,
    RR_STYPE_S1Z15    =36,
    RR_STYPE_S8Z24    =37,
    RR_STYPE_Z24S4    =38,
    RR_STYPE_S4Z24    =39,

} RRSurfaceType;

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
#define SPRITETEXCOORDMAX (4095.75f/4096.0f)

//-----------------------------------------------------------------------------
//
// forward declarations, mostly from refrasti.hpp
//
//-----------------------------------------------------------------------------
class RRColorComp;
class RRColor;
class RRDepth;
class RRPixel;
class RRTexture;
class RRTextureCoord;
class RREnvTextureCoord;
class RRFVFExtractor;

typedef UINT16 RRCvgMask;
typedef struct _RRFRAGMENT RRFRAGMENT;
typedef struct _RRSCANCNVSTATE RRSCANCNVSTATE;
typedef struct _RRSTATS RRSTATS;

//-----------------------------------------------------------------------------
//
// RRRenderTarget - Class which encompasses all informatio about rendering
// target, including size, type/pointer/stride for color and depth/stencil
// buffers, guard band clip info, W range info.
//
// Usage is to instantiate, fill out public members, and install into a
// ReferenceRasterizer object via ReferenceRasterizer::SetRenderTarget.
//
//-----------------------------------------------------------------------------
class RRRenderTarget
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RRRenderTarget( void );
    ~RRRenderTarget( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );
//
// these need to be filled in by the user before installing in a
// ReferenceRasterizer object
//
    int     m_iWidth;       // size of target surfaces (color & depth/stencil
    int     m_iHeight;      // must be same size

    RECT    m_Clip;
    FLOAT   m_fWRange[2];   // range of device W (W at near and far clip planes)

    RRSurfaceType m_ColorSType;
    char*   m_pColorBufBits;
    int     m_iColorBufPitch;

    RRSurfaceType m_DepthSType;
    char*   m_pDepthBufBits;
    int     m_iDepthBufPitch;

//
// these are used only to facilitate the way refrast is used in the D3D runtime
// and are not referenced within the refrast core
//
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl;
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSZLcl;

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    friend class ReferenceRasterizer;

    void ReadPixelColor   ( INT32 iX, INT32 iY, RRColor& Color );
    void WritePixelColor  ( INT32 iX, INT32 iY, const RRColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, const RRDepth& Depth );
    void ReadPixelDepth   ( INT32 iX, INT32 iY, RRDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT8 uStencil );
    void ReadPixelStencil ( INT32 iX, INT32 iY, UINT8& uStencil );
    void Clear            ( RRColor fillColor, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepth       ( RRDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd );
    void ClearStencil     ( UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepthStencil( RRDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
};

//-----------------------------------------------------------------------------
//
// RRTextureStageState - This holds the per-stage state for texture mapping.
// An array of these are instanced in the ReferenceRasterizer object.
//
// Store texture matrix at the end of the texture stage state.
//
//-----------------------------------------------------------------------------
#define D3DTSSI_MATRIX (D3DTSS_MAX)
class RRTextureStageState
{
public:
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX+16]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX+16];  // state array (float)
    };
    RRTexture* m_pTexture;
};

//-----------------------------------------------------------------------------
//
// RRTexture - Class instanced once per texture which encompasses information
// about a chain of surfaces used as a texture map.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Also includes pointer to palette, and colorkey value (legacy support only).
//
// Usage is to create RRTexture (and associated handle) with call to
// ReferenceRasterizer::TextureCreate and install in ReferenceRasterizer
// by passing handle into ReferenceRasterizer::SetRenderState.
//
//-----------------------------------------------------------------------------
#define RRTEX_MAXCLOD   12*6     // supports base texture up to 4kx4k
                                 // for 6 envmaps

class RRTexture
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RRTexture( void );
    ~RRTexture( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );

//
// this needs to be called after changing any of the public state to validate
// internal (private) state
//
    BOOL Validate( void );

//
// these need to be filled in by the user before installing in a
// ReferenceRasterizer object
//
    DWORD           m_uFlags;       // RR_TEXTURE_* bitdefs
// bit definitions for RRTexture::uFlags
#define RR_TEXTURE_HAS_CK           (1L<< 0)    // set if texture has colorkey
#define RR_TEXTURE_LOCKED           (1L<< 1)    // set if DD surface is locked (external use only)
#define RR_TEXTURE_ALPHAINPALETTE   (1L<< 2)    // set if alpha channel in palette
#define RR_TEXTURE_ENVMAP           (1L<< 3)    // set if texture is envmap with 6 times
                                                // the usual number of surfaces
#define RR_TEXTURE_SHADOWMAP        (1L<< 4)    // set if the texture is a ZBuffer

    // basic info
    RRSurfaceType   m_SurfType;                     // format of pixel
    int             m_iWidth;                       // size of largest map
    int             m_iHeight;
    char*           m_pTextureBits[RRTEX_MAXCLOD];  // pointer to surface bits
    int             m_iPitch[RRTEX_MAXCLOD];        // pitch in bytes
    int             m_cLOD;     // 0..(n-1) count of LODs currently available

    DWORD           m_dwColorKey;   // D3DCOLOR colorkey value

    DWORD           m_dwEmptyFaceColor;     // D3DCOLOR empty cubemap empty face value

    DWORD*          m_pPalette;     // pointer to D3DCOLOR palette (may be NULL)

//
// these are used only to facilitate the way refrast is used in the D3D runtime
// and are not referenced within the refrast core
//
    // DD surface pointers for locking/unlocking and GetSurf callback
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl[RRTEX_MAXCLOD];
    int             m_cLODDDS;  // 0..(n-1) count of LODs actually in the pDDS array

//
// may be useful to other users to have this public
//
    D3DTEXTUREHANDLE    m_hTex; // texture handle

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    friend class ReferenceRasterizer;

    // pointer to head of texture stage states, &m_TextureStageState[0]
    RRTextureStageState*    m_pStageState;

// texture.cpp - main interface methods used by ReferenceRasterizer object methods
    void DoLookupAndFilter( INT32 iStage, RRTextureCoord, RRColor& TextureColor );
    void DoBumpMapping( INT32 iStage, RRTextureCoord TCoord,
        FLOAT& fBumpMapUDelta, FLOAT& fBumpMapVDelta, RRColor& BumpMapModulate );
    void DoShadow(INT32 iStage, FLOAT* pfCoord, RRColor& OutputColor);
    // environment mapping versions
    void DoEnvProcessNormal( INT32 iStage, RREnvTextureCoord, RRColor& TextureColor );
    void DoEnvLookupAndFilter(INT32 iStage, INT16 iFace, FLOAT fMajor, FLOAT fDMDX, FLOAT fDMDY, RRTextureCoord TCoord, RRColor& TextureColor);
    void DoEnvReMap(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD, RRColor &Texel,
                    BOOL &bColorKeyMatched);
    void DoTableInterp(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD,
                         UINT8 uUSign, UINT8 uVSign, RRColor &Texel, BOOL &bColorKeyMatched);


    BOOL            m_bMipMapEnable;    // TRUE if mipmapping is enabled for this texture

    INT16           m_iTexSize[2];      // LOD 0 size
    INT16           m_iTexShift[2];     // LOD 0 log2 size (valid for power-of-2 size only)
    UINT16          m_uTexMask[2];      // LOD 0 (1<<log2(size))-1

    BOOL            m_bHasAlpha;        // TRUE if texture has an alpha channel
    BOOL            m_bDoColorKeyKill;  // TRUE is colorkey enabled for this texture and should kill pixel
    BOOL            m_bDoColorKeyZero;  // TRUE is colorkey enabled for this texture and should zero pixel
    BOOL            m_bColorKeyMatched; // TRUE if colorkey matched on one or more contributing samples

// texture.cpp
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    RRColor DoMapLookupLerp(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD);
    RRColor DoMapLookupNearest(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD, BOOL &bColorKeyMatched);
    RRColor DoLookup(INT32 iStage, float U, float V, INT16 iLOD, BOOL bNearest);
    void DoMagnify ( INT32 iStage, RRTextureCoord& TCoord, RRColor& Texel );
    void DoMinify  ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel );
    void DoTrilerp ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel );
    void DoAniso   ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, FLOAT fRatio, FLOAT fDelta[], RRColor& Texel );
    // environment mapping versions
    RRColor DoEnvLookup(INT32 iStage, RRTextureCoord TCoord, INT16 iFace, INT16 iLOD, BOOL bNearest);
    void DoEnvMagnify ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, RRColor& Texel );
    void DoEnvMinify  ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel );
    void DoEnvTrilerp ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel );
    void DoTextureTransform( INT32 iStage, BOOL bAlreadyXfmd, FLOAT* pfC, FLOAT* pfO, FLOAT* pfQ );

// texmap.cpp
    void ReadColor(
        INT32 iX, INT32 iY, INT32 iLOD,
        RRColor& Texel, BOOL &bColorKeyMatched );
};

#define REF_STATESET_GROWDELTA      1

#define RRSTATEOVERRIDE_DWORD_BITS      32
#define RRSTATEOVERRIDE_DWORD_SHIFT     5

typedef TemplArray<UINT8> StateSetData;
typedef StateSetData *LPStateSetData;

class ReferenceRasterizer;

typedef HRESULT (*PFN_DP2REFOPERATION)(ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETRENDERSTATES)(ReferenceRasterizer *pRefRast,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2REFTEXTURESTAGESTATE)(ReferenceRasterizer *pRefRast,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETLIGHT)(ReferenceRasterizer *pRefRast,
                                      LPD3DHAL_DP2COMMAND pCmd,
                                      LPDWORD pdwStride);
typedef struct _REF_STATESETFUNCTIONTBL
{
    DWORD                       dwSize;                 // size of struct
    PFN_DP2REFSETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2REFTEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2REFOPERATION pfnDp2SetViewport;
    PFN_DP2REFOPERATION pfnDp2SetWRange;
    PFN_DP2REFOPERATION pfnDp2SetMaterial;
    PFN_DP2REFOPERATION pfnDp2SetZRange;
    PFN_DP2REFSETLIGHT  pfnDp2SetLight;
    PFN_DP2REFOPERATION pfnDp2CreateLight;
    PFN_DP2REFOPERATION pfnDp2SetTransform;
    PFN_DP2REFOPERATION pfnDp2SetExtention;
    PFN_DP2REFOPERATION pfnDp2SetClipPlane;
} REF_STATESETFUNCTIONTBL, *LPREF_STATESETFUNCTIONTBL;

//
// The device type that the RefRast should emulate
//
typedef enum {
    RRTYPE_OLDHAL = 1,
    RRTYPE_DPHAL,
    RRTYPE_DP2HAL,          // DX6 HAL
    RRTYPE_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    RRTYPE_DX7TLHAL
} RRDEVICETYPE;

typedef struct _RRSTATEOVERRIDES
{
    DWORD    bits[D3DSTATE_OVERRIDE_BIAS >> RRSTATEOVERRIDE_DWORD_SHIFT];
} RRSTATEOVERRIDES;

//-----------------------------------------------------------------------------
//
// ReferenceRasterizer - Primary object for reference rasterizer.  Each instance
// of this corresponds to a D3D device.
//
// Usage is to instantiate, install RRRenderTarget (and optional RRTexture's),
// and set state and draw primitives.
//
//-----------------------------------------------------------------------------
class ReferenceRasterizer : public RRProcessVertices
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    ReferenceRasterizer( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                         DWORD dwInterfaceType,
                         RRDEVICETYPE dwDriverType
                         );
    ~ReferenceRasterizer( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );

    // Dp2 token handling functions
    HRESULT Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd, LPDWORD pdwStride);
    HRESULT Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd);

    HRESULT Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2SetTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd, PDWORD pdwStride);
    HRESULT Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd);

    // StateSet related functions
    void SetRecStateFunctions(void);
    void SetSetStateFunctions(void);
    HRESULT BeginStateSet(DWORD dwHandle);
    HRESULT EndStateSet(void);
    HRESULT ExecuteStateSet(DWORD dwHandle);
    HRESULT DeleteStateSet(DWORD dwHandle);
    HRESULT CaptureStateSet(DWORD dwHandle);

    HRESULT RecordStates(PUINT8 pData, DWORD dwSize);
    HRESULT RecordLastState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize);

    LPREF_STATESETFUNCTIONTBL pStateSetFuncTbl;

    // Interface style
    BOOL IsInterfaceDX6AndBefore() {return (m_dwInterfaceType <= 2);}
    // DriverStyle
    BOOL IsDriverDX6AndBefore()
    {
        return ((m_dwDriverType <= RRTYPE_DP2HAL) && (m_dwDriverType > 0));
    }

    // Last State hack
    void StoreLastPixelState(BOOL bStore);

    // state management functions
    void SetRenderTarget( RRRenderTarget* pRenderTarget );
    RRRenderTarget* GetRenderTarget( void );
    void SetRenderState( DWORD dwState, DWORD dwValue );
    DWORD* GetRenderState( void );
    DWORD* GetTextureStageState(DWORD dwStage);
    void SetTextureStageState( DWORD dwStage, DWORD dwStageState, DWORD dwValue );
    void SceneCapture( DWORD dwFlags );

    // texture management functions
    BOOL TextureCreate  ( LPD3DTEXTUREHANDLE phTex, RRTexture** ppTexture );
    BOOL TextureCreate  ( DWORD dwHandle, RRTexture** ppTex );

    BOOL TextureDestroy ( D3DTEXTUREHANDLE hTex );

    DWORD TextureGetSurf( D3DTEXTUREHANDLE hTex );

    // rendering functions
    HRESULT Clear(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT BeginRendering( DWORD dwFVFControl );
    HRESULT EndRendering( void  );

    BOOL DoAreaCalcs(FLOAT* pfDet, RRFVFExtractor* pVtx0,
                     RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2);
    void DoTexCoordCalcs(INT32 iStage, RRFVFExtractor* pVtx0,
                         RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2);
    void DrawTriangle( void* pvV0, void* pvV1, void* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );
    void DrawLine( void* pvV0, void* pvV1, void* pvVFlat = NULL );
    void DrawPoint( void* pvV0, void* pvVFlat = NULL );

    void DrawClippedTriangle( void* pvV0, RRCLIPCODE c0,
                              void* pvV1, RRCLIPCODE c1,
                              void* pvV2, RRCLIPCODE c2,
                              WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );
    void DrawClippedLine( void* pvV0, RRCLIPCODE c0,
                          void* pvV1, RRCLIPCODE c1,
                          void* pvVFlat = NULL );
    void DrawClippedPoint( void* pvV0, RRCLIPCODE c0,
                           void* pvVFlat = NULL );

//
// these are used to facilitate the way refrast is used in the D3D runtime
//
    // functions to manipulate current set of texture
    int GetCurrentTextureMaps( D3DTEXTUREHANDLE* phTex, RRTexture** pTex );
    BOOL SetTextureMap( D3DTEXTUREHANDLE hTex, RRTexture* pTex );

//
// T&L Hal specific functions
//
    // For Non-Indexed Primitives
    void SavePrimitiveData( DWORD dwFVFIn, LPVOID pVtx,
                            UINT cVertices,
                            D3DPRIMITIVETYPE PrimType );
    // For Indexed Primitives
    void SavePrimitiveData( DWORD dwFVFIn, LPVOID pVtx, UINT cVertices,
                            D3DPRIMITIVETYPE PrimType,
                            LPWORD pIndices, UINT cIndices);
    HRESULT ProcessPrimitive( BOOL bIndexedPrim );
    HRESULT UpdateTLState();
    int ClipSingleLine( RRCLIPTRIANGLE *line );
    int ClipSingleTriangle(RRCLIPTRIANGLE *tri,
                           RRCLIPVTX ***clipVertexPointer);

//
// Texture locking and Unlocking control
//
    inline BOOL TexturesAreLocked()   {return m_bTexturesAreLocked;};
    inline void SetTexturesLocked()   {m_bTexturesAreLocked = TRUE;};
    inline void ClearTexturesLocked() {m_bTexturesAreLocked = FALSE;};
private:
    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    //-------------------------------------------------------------------------
    // state
    //-------------------------------------------------------------------------
    // DDraw Local, needed for the new texture handles from DX7 onwards
    LPDDRAWI_DIRECTDRAW_LCL m_pDDLcl;

    // This is obtained from CONTEXTCREATE->ddrval, indicates
    // what kind of emulation (DX3, DX5, DX6 or DX7) the driver should do.
    RRDEVICETYPE    m_dwDriverType;

    // This is obtained from CONTEXTCREATE->dwhContext, indicates
    // which D3D Device interface called the driver.
    DWORD           m_dwInterfaceType;

    // save area for floating point unit control
    WORD            m_wSaveFP;

    // TRUE if in begin/end primitive sequence
    BOOL            m_bInBegin;

    // TRUE if in rendering point sprite triangles
    BOOL            m_bPointSprite;

    // current Flexible Vertex Format control word
    UINT64          m_qwFVFControl;


    // render target (color & Z buffer)
    RRRenderTarget* m_pRenderTarget;
    FLOAT           m_fWBufferNorm[2]; // { Wnear, 1/(Wfar-Wnear) } to normalize W buffer value

    // fragment buffer
    RRFRAGMENT**    m_ppFragBuf;
    INT             m_iFragBufWidth;
    INT             m_iFragBufHeight;
    BOOL            m_bFragmentProcessingEnabled;

    // D3D renderstate
    union
    {
        DWORD       m_dwRenderState[D3DHAL_MAX_RSTATES];
        FLOAT       m_fRenderState[D3DHAL_MAX_RSTATES];
    };

    // State Override flags
    RRSTATEOVERRIDES m_renderstate_override;

    // texture state - per-stage state and pointer to associated texture
    int                 m_cActiveTextureStages; // count of active texture stages (range 0..D3DHAL_TSS_MAXSTAGES)
    RRTextureStageState m_TextureStageState[D3DHAL_TSS_MAXSTAGES];
    RRTexture*          m_pTexture[D3DHAL_TSS_MAXSTAGES];  //  texture maps associated with texture stages

    // DX7 style texture objects, where the handle is specified by the
    // runtime. It is basically an index into an array.
    // This array is dynamically allocated and grown very much like the light
    // array.
    RRTexture**         m_ppTextureArray;
    DWORD               m_dwTexArrayLength;

    // scan converter state
    RRSCANCNVSTATE* m_pSCS;

    // statistics
    RRSTATS*        m_pStt;

    // Last state
    DWORD m_LastState;

    // Array of StateSets, which are in turn implemented with TemplArray as
    // TemplArray<UINT8> StateSetData
    TemplArray<LPStateSetData> m_pStateSets;

    // This bool indicates that the textures are already locked
    BOOL m_bTexturesAreLocked;

    //-------------------------------------------------------------------------
    // methods
    //-------------------------------------------------------------------------

// refrasti.cpp
    HRESULT GrowTexArray( DWORD dwHandle );
    HRESULT SetTextureHandle( int iStage, DWORD dwHandle );
    void MapTextureHandleToDevice( int iStage );
    void UpdateActiveTexStageCount( void );
    RRTexture* MapHandleToTexture( D3DTEXTUREHANDLE hTex );

// MapLegcy.cpp
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

// setup.cpp
    void SetPrimitiveAttributeFunctions(
        const RRFVFExtractor& Vtx0,
        const RRFVFExtractor& Vtx1,
        const RRFVFExtractor& Vtx2,
        const RRFVFExtractor& VtxFlat );

// scancnv.cpp
    FLOAT ComputePixelAttrib( int iAttrib );
    FLOAT ComputePixelAttribClamp( int iAttrib );
    FLOAT ComputePixelAttribTex( int iTex, int iCrd );
    void ComputeFogIntensity( RRPixel& Pixel );
    void DoScanCnvGenPixel( RRCvgMask CvgMask, BOOL bTri );
    void DoScanCnvTri( int iEdgeCount );
    void DoScanCnvLine( void );

// texstage.cpp
    void DoTexture( const RRPixel& Pixel, RRColor& OutputColor);
    void ComputeTextureBlendArg(
        DWORD dwArgCtl, BOOL bAlphaOnly,
        const RRColor& DiffuseColor,
        const RRColor& SpecularColor,
        const RRColor& CurrentColor,
        const RRColor& TextureColor,
        RRColor& BlendArg);
    void DoTextureBlendStage(
        int iStage,
        const RRColor& DiffuseColor,
        const RRColor& SpecularColor,
        const RRColor& CurrentColor,
        const RRColor& TextureColor,
        RRColor& OutputColor);

// pixproc.cpp
    BOOL DepthCloser( const RRDepth& DepthVal, const RRDepth& DepthBuf );
    BOOL AlphaTest( const RRColorComp& Alpha );
    BOOL DoStencil( UINT8 uStncBuf, BOOL bDepthTest, RRSurfaceType DepthSType, UINT8& uStncRet );
    void DoAlphaBlend( const RRColor& SrcColor, const RRColor& DstColor,
                       RRColor& ResColor );
    void DoPixel( RRPixel& Pixel );

// fragproc.cpp
    BOOL DoFragmentGenerationProcessing( RRPixel& Pixel );
    void DoFragmentBufferFixup( const RRPixel& Pixel );
    RRFRAGMENT*     FragAlloc( void );
    void            FragFree( RRFRAGMENT* pFrag );

// fragrslv.cpp
    void DoBufferResolve( void);
    void DoFragResolve(
        RRColor& ResolvedColor, RRDepth& ResolvedDepth,
        RRFRAGMENT* pFragList,
        const RRColor& PixelColor );

// PixRef.cpp
    void WritePixel(
        INT32 iX, INT32 iY,
        const RRColor& Color, const RRDepth& Depth);

// primfns.cpp
    void SetXfrm( D3DTRANSFORMSTATETYPE xfrmType, D3DMATRIX *pMat );
    HRESULT GrowLightArray(const DWORD dwIndex);
};

//-----------------------------------------------------------------------------
//
// RRFVFExtractor - Encases Flexible Vertex Format pointer and control to get
// vertex data.
//
//-----------------------------------------------------------------------------
#ifndef D3DFVF_GETTEXCOORDSIZE
#define D3DFVF_GETTEXCOORDSIZE(FVF, CoordIndex) ((FVF >> (CoordIndex*2 + 16)) & 0x3)
#endif
class RRFVFExtractor
{
private:
    void* m_pvData;
    UINT64 m_qwControl;
    BOOL  m_bPerspectiveEnable;
    int   m_iXYZ;
    int   m_iDiffuse;
    int   m_iSpecular;
    int   m_iTexCrd[D3DHAL_TSS_MAXSTAGES+1];
    int   m_iS;
    int   m_iEyeNormal;
    int   m_iEyeXYZ;
public:
    // constructor
    RRFVFExtractor( void* pvData, UINT64 qwControl, BOOL bPerspectiveEnable )
    {
        m_pvData = pvData;
        m_qwControl = qwControl;
        m_bPerspectiveEnable = bPerspectiveEnable;

        // compute offsets to fields within FVF
        m_iXYZ = 0 +
            ( m_qwControl & D3DFVF_RESERVED0 ? 1 : 0 );
        m_iDiffuse = m_iXYZ +
            ( m_qwControl & D3DFVF_XYZ       ? 3 : 0 ) +
            ( m_qwControl & D3DFVF_XYZRHW    ? 4 : 0 ) +
            ( m_qwControl & D3DFVF_NORMAL    ? 3 : 0 ) +
            ( m_qwControl & D3DFVF_RESERVED1 ? 1 : 0 );
        m_iSpecular = m_iDiffuse +
            ( m_qwControl & D3DFVF_DIFFUSE   ? 1 : 0 );
        m_iTexCrd[0] = m_iSpecular +
            ( m_qwControl & D3DFVF_SPECULAR  ? 1 : 0 );
        m_iS = m_iTexCrd[0];
        for(int i = 0; i < TexCrdCount(); i++)
        {
            int iTexND;
            switch (D3DFVF_GETTEXCOORDSIZE(m_qwControl, i))
            {
            case D3DFVF_TEXTUREFORMAT2:  iTexND = 2; break;
            case D3DFVF_TEXTUREFORMAT3:  iTexND = 3; break;
            case D3DFVF_TEXTUREFORMAT4:  iTexND = 4; break;
            case D3DFVF_TEXTUREFORMAT1:  iTexND = 1; break;
            }
            m_iTexCrd[i+1] = m_iTexCrd[i] + iTexND;
            m_iS = m_iTexCrd[i+1];      // generate one more iTexCrd pointer than
                                        // needed, and use it for size
        }
        m_iEyeNormal = m_iS +
            ( m_qwControl & D3DFVF_S  ? 1 : 0 );
        m_iEyeXYZ = m_iEyeNormal +
            ( m_qwControl & D3DFVFP_EYENORMAL  ? 3 : 0 );
    }

    // coordinate access methods
    FLOAT* GetPtrXYZ( void ) const { return (FLOAT*)m_pvData + m_iXYZ; }
    FLOAT GetX( void ) const  { return *( GetPtrXYZ() + 0 ); }
    FLOAT GetY( void ) const  { return *( GetPtrXYZ() + 1 ); }
    FLOAT GetZ( void ) const  { return *( GetPtrXYZ() + 2 ); }
    FLOAT GetRHW( void ) const
    {
        // return 1. if perspective not enabled
        if ( !m_bPerspectiveEnable ) return 1.f;
        // return 1/W if available else default value 1.0
        return ( m_qwControl & D3DFVF_XYZRHW )
            ? *( GetPtrXYZ() + 3 )
            : 1.f ;
    }

    // color access methods
    DWORD GetDiffuse( void ) const
    {
        // return color if available else white (default)
        return ( m_qwControl & D3DFVF_DIFFUSE )
            ? *( (DWORD*)m_pvData + m_iDiffuse )
            : 0xffffffff;
    }
    DWORD GetSpecular( void ) const
    {
        // return color if available else black and zero vertex fog (default)
        return ( m_qwControl & D3DFVF_SPECULAR )
            ? *( (DWORD*)m_pvData + m_iSpecular )
            : 0x00000000;
    }

    // texture coordinate access methods
    int TexCrdCount( void ) const
    {
        return (int)(( m_qwControl & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT);
    }
    FLOAT GetTexCrd( int iCrd, int iCrdSet ) const
    {
        return ( (TexCrdCount() > iCrdSet) && (iCrd < 4) )
            ? *( (FLOAT*)m_pvData + m_iTexCrd[iCrdSet] + iCrd )
            : 0.f;
    }
    FLOAT* GetPtrTexCrd( int iCrd, int iCrdSet ) const
    {
        return (FLOAT*)m_pvData + m_iTexCrd[iCrdSet] + iCrd;
    }
    FLOAT GetS( void ) const
    {
        return ( m_qwControl & D3DFVF_S )
            ? *( (FLOAT*)m_pvData + m_iS )
            : 1.0f;
    }
    FLOAT* GetPtrS( void ) const { return (FLOAT*)m_pvData + m_iS; }
    FLOAT GetEyeNormal( int iCrd ) const
    {
        return (m_qwControl & D3DFVFP_EYENORMAL)
            ? *( (FLOAT*)m_pvData + m_iEyeNormal + iCrd)
            : 0.f;
    }
    FLOAT* GetPtrEyeNormal( void ) const { return (FLOAT*)m_pvData + m_iEyeNormal; }
    FLOAT GetEyeXYZ( int iCrd ) const
    {
        return (m_qwControl & D3DFVFP_EYEXYZ)
            ? *( (FLOAT*)m_pvData + m_iEyeXYZ + iCrd)
            : 0.f;
    }
    FLOAT* GetPtrEyeXYZ( void ) const { return (FLOAT*)m_pvData + m_iEyeXYZ; }
};

//-------------------------------------------------------------------------
// S3 compressed texture formats
//-------------------------------------------------------------------------
// number of s3 compression formats
#define NUM_DXT_FORMATS    5
// number of pixels in block
#define DXT_BLOCK_PIXELS   16

typedef struct  {
    BYTE    rgba[4];
} DXT_COLOR;

typedef WORD        RGB565;     // packed color
typedef DWORD       PIXBM;      // 2 BPP bitmap


typedef struct  {
    RGB565      rgb0;       // color for index 0
    RGB565      rgb1;       // color for index 1
    PIXBM       pixbm;      // pixel bitmap
} DXTBlockRGB;

typedef struct  {
    WORD        alphabm[4]; // alpha bitmap at 4 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha4;

typedef struct  {
    BYTE        alpha0;     // alpha for index 0
    BYTE        alpha1;     // alpha for index 1
    BYTE        alphabm[6]; // alpha bitmap at 3 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha3;

void DecodeBlockRGB (DXTBlockRGB *pblockSrc,
                     DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);

///////////////////////////////////////////////////////////////////////////////
#endif // _REFRAST_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\templarr.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// temparr.hpp
//
// Template class used by Direct3D ReferenceRasterizer for stateset and so on.
//
// The following error codes should be defined before included this file:
// DDERR_OUTOFMEMORY
// D3D_OK
// DDERR_INVALIDPARAMS
///////////////////////////////////////////////////////////////////////////////
#ifndef  _TEMPLARR_HPP
#define  _TEMPLARR_HPP


template <class T> class TemplArray 
{
public:
    TemplArray( void );
    ~TemplArray( void );

    // It is the user of this operator who makes sure 0<=iIndex<m_dwArraySize.
    T& operator []( int iIndex );

    HRESULT CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta = 16 );
    HRESULT CheckRange ( DWORD iIndex );

    // The user needs to make sure 0<=m_dwCurrent<m_dwArraySize.
    inline T CurrentItem(void) { return m_pArray[m_dwCurrent];};
    inline void SetCurrentItem(T item) { m_pArray[m_dwCurrent] = item;};
    inline DWORD CurrentIndex(void) { return m_dwCurrent;};
    inline void SetCurrentIndex(DWORD dwIdx) {m_dwCurrent = dwIdx;};

    inline DWORD ArraySize(void) { return m_dwArraySize;};

private:
    T *m_pArray;
    DWORD m_dwArraySize;
    // Index to the current item or the size of data stored in the array
    DWORD m_dwCurrent;
};


template <class T> 
TemplArray< T >::TemplArray( void )
{
    m_pArray = NULL;
    m_dwArraySize = 0;
    m_dwCurrent = 0;
}

template <class T> 
TemplArray< T >::~TemplArray( void )
{
    if (m_pArray != NULL)
        delete m_pArray;
    m_dwArraySize = 0;
}

template <class T> T& 
TemplArray< T >::operator[]( int iIndex )
{
    return m_pArray[iIndex];
}

template <class T> HRESULT
TemplArray< T >::CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta )
{
    if (iIndex >= m_dwArraySize)
    {
        DWORD dwNewArraySize = m_dwArraySize + dwGrowDelta;
        while (iIndex >= dwNewArraySize)
            dwNewArraySize += dwGrowDelta;

        T *pTmpArray = new T[dwNewArraySize];
        if (pTmpArray == NULL)
            return DDERR_OUTOFMEMORY;
        memset(pTmpArray, 0, sizeof(T) * dwNewArraySize);

        if (m_pArray != NULL)
        {
            _ASSERT(m_dwArraySize != 0, 
                    "CheckAndGrow: Array size cannot be NULL" );

            // Copy existing stuff into new array
            memcpy(pTmpArray, m_pArray, m_dwArraySize * sizeof(T));

            // Free up existing array
            delete m_pArray;
        }

        
        // Assign new array
        m_pArray = pTmpArray;
        m_dwArraySize = dwNewArraySize;
    }
    return D3D_OK;
}

template <class T> HRESULT
TemplArray< T >::CheckRange( DWORD iIndex )
{
    if (iIndex >= m_dwArraySize)
    {
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

#endif _TEMPLARR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\reftnl.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.hpp
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFTNL_HPP
#define  _REFTNL_HPP

#define MAX_REFERENCE_LIGHTS          128
// Default color values that should be used when ther is no lighting and
// color in vertices provided
#define RR_DEFAULT_DIFFUSE  0xFFFFFFFF;
#define RR_DEFAULT_SPECULAR 0;

#define REF_GB_LEFT   -32768.f
#define REF_GB_TOP    -32768.f
#define REF_GB_RIGHT   32767.f
#define REF_GB_BOTTOM  32767.f

//----------------------------------------------------------------------------
// FVF related macros
//----------------------------------------------------------------------------
const DWORD RRMAX_FVF_TEXCOORD = 8;

//-----------------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------------
// Number of clipping planes
#define RRMAX_USER_CLIPPLANES 6

// Number of clipping planes
#define RRMAX_CLIPPING_PLANES (6+RRMAX_USER_CLIPPLANES)

// Number of world matrices
#define RRMAX_WORLD_MATRICES 4

// Space for vertices generated/copied while clipping one triangle
#define RRMAX_CLIP_VERTICES   (( 2 * RRMAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles
#define RRMAX_CLIP_TRIANGLES  ( RRMAX_CLIP_VERTICES - 2 )

// make smaller than guard band for easier clipping
#define RRMAX_POINT_SIZE  ( REF_GB_RIGHT )

typedef DWORD RRCLIPCODE;

typedef struct _RRCLIPVTX
{
    D3DVALUE    hx;
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    DWORD       clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    _RRCLIPVTX  *next;
    D3DVALUE    tex[RRMAX_FVF_TEXCOORD*4];
    D3DVALUE    s;
    D3DVALUE    eyenx;
    D3DVALUE    eyeny;
    D3DVALUE    eyenz;
    D3DVALUE    eyex;
    D3DVALUE    eyey;
    D3DVALUE    eyez;
} RRCLIPVTX;

typedef struct _RRCLIPTRIANGLE
{
    RRCLIPVTX  *v[3];
} RRCLIPTRIANGLE;

typedef struct _RRUSERCLIPPLANE
{
    RRVECTOR4       plane;
    BOOL             bActive;
} RRUSERCLIPPLANE, *LPRRUSERCLIPPLANE;

//-----------------------------------------------------------------------------
//
// forward declarations, mostly from reftnli.hpp
//
//-----------------------------------------------------------------------------
class RRMaterial;
class RRLight;
class RRTransform;


//-----------------------------------------------------------------------------
//
// Base class for all RefTnL classes to use common allocation functions
//
//-----------------------------------------------------------------------------
class RRAlloc
{
public:
    void* operator new(size_t s);
    void operator delete(void* p, size_t);
};

//-----------------------------------------------------------------------------
//
// RRVECTORH - Homogeneous vector
//
//-----------------------------------------------------------------------------
typedef struct tagRRVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} RRVECTORH, *PRRVECTORH;
//-----------------------------------------------------------------------------
//
// RRMATRIX - Matrix data-structure
//
//-----------------------------------------------------------------------------
typedef enum tagRRMATRIXTYPE
{
    RRMatrixIdentity,
    RRMatrixTranslate,
    RRMatrixRotateTranslate,
    RRMatrixAffine,
    RRMatrixGeneral
} RRMATRIXTYPE;


typedef D3DMATRIX RRMATRIX;

//-----------------------------------------------------------------------------
//
// RRTRANSFORMDATA - Transformation data used by Refrence T&L implementation
// to transform vertices.
//
//-----------------------------------------------------------------------------
typedef struct tagRRTRANSFORMDATA
{
    RRMATRIX      m_PS;         // Mproj * Mshift
    RRMATRIX      m_VPS;        // Mview * PS
    RRMATRIX      m_VPSInv;     // Inverse( Mview * PS )
    RRMATRIX      m_CTMI;       // Inverse current transformation matrix
    RRVECTORH     m_frustum[6]; // Normalized plane equations for viewing
                                // frustum in the model space
    DWORD          m_dwFlags;
} RRTRANSFORMDATA, *PRRTRANSFORMDATA;

//---------------------------------------------------------------------
// RRLIGHTING
// All the lighting related state clubbed together
//---------------------------------------------------------------------
typedef struct {D3DVALUE r,g,b;} RRCOLOR;

typedef struct _RRLIGHTING
{
    // Active Light list
    RRLight           *pActiveLights;

    // Temporary data used when computing lighting

    D3DVECTOR       eye_in_eye;         // eye position in eye space
                                        // It is (0, 0, 0)

    // Ma * La + Me (Ambient and Emissive) ------
    RRCOLOR           ambEmiss;

    // ColorVertex stuff ------------------------
    RRCOLOR *pAmbientSrc;
    RRCOLOR *pDiffuseSrc;
    RRCOLOR *pSpecularSrc;
    RRCOLOR *pEmissiveSrc;

    // Diffuse ----------------------------------
    RRCOLOR           vertexDiffuse; // Provided with a vertex, used if
                                     // COLORVERTEX is enabled and a diffuse
                                     // color is provided in the vertex
    RRCOLOR           diffuse;       // Diffuse accumulates here
    DWORD             outDiffuse;    // Diffuse color result of lighting


    // Specular --------------------------------
    RRCOLOR           vertexSpecular;// Provided with a vertex, used if
                                     // COLORVERTEX is enabled and a specular
                                     // color is provided in the vertex
    RRCOLOR           specular;      // Specular accumulates here
    DWORD             outSpecular;   // Specular color result of lighting

    D3DVALUE          specThreshold;  // If the dot product is less than this
                                      // value, specular factor is zero
    // End of temporary data

    // RENDERSTATEAMBIENT --------------------------------------

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // They are all scaled to 0 - 1
    D3DVALUE          ambient_red;
    D3DVALUE          ambient_green;
    D3DVALUE          ambient_blue;
    DWORD             ambient_save;       // Original unscaled color

    // Fog -----------------------------------------------------

    int               fog_mode;
    D3DCOLOR          fog_color;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)

    D3DCOLORMODEL     color_model;

    // Material ------------------------------------------------

    // For color material
    LPDWORD           pDiffuseAlphaSrc;
    LPDWORD           pSpecularAlphaSrc;

    DWORD               materialDiffAlpha;  // Current material diffuse
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               materialSpecAlpha;  // Current material specular
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               vertexDiffAlpha;    // Current material diffuse
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               vertexSpecAlpha;    // Current material specular
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    D3DMATERIAL7      material;           // Cached material data
    RRCOLOR           matAmb;
    RRCOLOR           matDiff;
    RRCOLOR           matSpec;
    RRCOLOR           matEmis;
} RRLIGHTING;

//-----------------------------------------------------------------------------
//
// RRLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------
typedef struct _RRLIGHTI
{
    DWORD           flags;

    D3DVECTOR       position_in_eye;  // In the eye space
    D3DVECTOR       direction_in_eye; // In the eye space

    //
    // Saved light colors scaled from 0 - 255, needed for COLORVERTEX
    //
    D3DCOLORVALUE   La;         //  light ambient
    D3DCOLORVALUE   Ld;         //  light diffuse
    D3DCOLORVALUE   Ls;         //  light specular

    //
    // Precomputed colors scaled from 0 - 255,
    //
    D3DCOLORVALUE   Ma_La;         // Material ambient times light ambient
    D3DCOLORVALUE   Md_Ld;         // Material diffuse times light diffuse
    D3DCOLORVALUE   Ms_Ls;         // Material specular times light specular


    D3DVECTOR       halfway;

    // Stuff for SpotLights
    D3DVALUE        range_squared;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVALUE        inv_theta_minus_phi;

} RRLIGHTI;


//-----------------------------------------------------------------------------
// Function pointer to the functions that light a vertex
//-----------------------------------------------------------------------------
typedef void (*RRLIGHTVERTEXFN)( RRLIGHTING& LData, D3DLIGHT7 *pLight,
                                 RRLIGHTI *pLightI, D3DLIGHTINGELEMENT *in,
                                 DWORD dwFlags, DWORD dwFVFIn );

//-----------------------------------------------------------------------------
// Functions to compute lighting
//-----------------------------------------------------------------------------
typedef struct _RRLIGHTVERTEX_FUNC_TABLE
{
    RRLIGHTVERTEXFN   pfnDirectional;
    RRLIGHTVERTEXFN   pfnParallelPoint;
    RRLIGHTVERTEXFN   pfnSpot;
    RRLIGHTVERTEXFN   pfnPoint;
} RRLIGHTVERTEX_FUNC_TABLE;

//-----------------------------------------------------------------------------
//
// RRLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------
#define RRLIGHT_ENABLED              0x00000001  // Is the light active
#define RRLIGHT_NEEDSPROCESSING      0x00000002  // Is the light data processed

class RRLight : public RRAlloc
{
public:
    RRLight();
    BOOL IsEnabled() {return (m_dwFlags & RRLIGHT_ENABLED);}
    BOOL NeedsProcessing() {return (m_dwFlags & RRLIGHT_NEEDSPROCESSING);}
    HRESULT SetLight(LPD3DLIGHT7 pLight);
    HRESULT GetLight( LPD3DLIGHT7 pLight );
    void ProcessLight( D3DMATERIAL7 *mat, RRLIGHTVERTEX_FUNC_TABLE *pTbl);
    void XformLight( D3DMATRIX* mV );
    void Enable( RRLight **ppRoot );
    void Disable( RRLight **ppRoot );

private:

    // Flags
    DWORD m_dwFlags;

    // Active List next element
    RRLight *m_Next;

    // Specific function to light the vertex
    RRLIGHTVERTEXFN   m_pfnLightVertex;

    // Light data set by the runtime
    D3DLIGHT7 m_Light;

    // Light data computed by the driver
    RRLIGHTI  m_LightI;

    friend class ReferenceRasterizer;
    friend class RRProcessVertices;
};

//-----------------------------------------------------------------------------
//
// RRMaterial - Class for materials data used for lighting by the driver
//
//-----------------------------------------------------------------------------
class RRMaterial : public RRAlloc
{
public:
    RRMaterial();
    ~RRMaterial();
    HRESULT SetMaterial(LPD3DMATERIAL7);
    HRESULT GetMaterial(LPD3DMATERIAL7);

private:
    // Data describing material
    D3DMATERIAL7         dmMaterial;
};


//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//---------------------------------------------------------------------

class RefAlignedBuffer32
{
public:
    RefAlignedBuffer32()  {m_size = 0; m_allocatedBuf = 0; m_alignedBuf = 0;}
    ~RefAlignedBuffer32() {if (m_allocatedBuf) free(m_allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return m_alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return m_size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > m_size)
            return Grow(dwSize + 1024);
        else
            return S_OK;
    }
protected:
    LPVOID m_allocatedBuf;
    LPVOID m_alignedBuf;
    DWORD  m_size;
};

//---------------------------------------------------------------------
// Digested Viewport information
// calculated from viewport settings
//---------------------------------------------------------------------
typedef struct _RR_VIEWPORTDATA
{

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE scaleZ;            // (Viewport->dvMaxZ - Viewport->dvMinZ)
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
    D3DVALUE offsetZ;           // Viewport->dvMinZ

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ

    // Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY

    // Min and max window values with guard band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;

    // Coefficients to transform a vertex to perform the guard band clipping
    // x*gb11 + w*gb41
    // y*gb22 + w*gb42
    //
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;

    // Coefficients to apply clipping rules for the guard band clipping
    // They are used by clipping routins
    // w*Kgbx1 < x < w*Kgbx2
    // w*Kgby1 < y < w*Kgby2
    //
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;
} RRVIEWPORTDATA;


//---------------------------------------------------------------------
// RRCLIPPING
// Cached clipping data
//---------------------------------------------------------------------
typedef struct __RRCLIPPING
{
    RefAlignedBuffer32    ClipBuf;
    RRCLIPVTX  *clip_vbuf1[RRMAX_CLIP_VERTICES];
    RRCLIPVTX  *clip_vbuf2[RRMAX_CLIP_VERTICES];
    RRCLIPVTX **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    RRCLIPVTX   clip_vertices[RRMAX_CLIP_VERTICES];
    DWORD       dwInterpolate;
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
} RRCLIPPING;


// RRProcessVertices::m_dwTLState flags
#define RRPV_DOLIGHTING                0x00000001
#define RRPV_DOCLIPPING                0x00000002
#define RRPV_GUARDBAND                 0x00000004
#define RRPV_DOFOG                     0x00000008
#define RRPV_DOSPECULAR                0x00000010
#define RRPV_RANGEFOG                  0x00000020
#define RRPV_NORMALIZENORMALS          0x00000040
#define RRPV_LOCALVIEWER               0x00000080
#define RRPV_DOCOMPUTEPOINTSIZE        0x00000100
#define RRPV_DOPASSEYENORMAL           0x00000200
#define RRPV_DOPASSEYEXYZ              0x00000400

// ColorVertexFlags
#define RRPV_VERTEXDIFFUSENEEDED       0x00000800
#define RRPV_VERTEXSPECULARNEEDED      0x00001000
#define RRPV_COLORVERTEXAMB            0x00002000
#define RRPV_COLORVERTEXDIFF           0x00004000
#define RRPV_COLORVERTEXSPEC           0x00008000
#define RRPV_COLORVERTEXEMIS           0x00010000
#define RRPV_COLORVERTEXFLAGS     (RRPV_VERTEXDIFFUSENEEDED       | \
                                   RRPV_VERTEXSPECULARNEEDED      | \
                                   RRPV_COLORVERTEXAMB            | \
                                   RRPV_COLORVERTEXDIFF           | \
                                   RRPV_COLORVERTEXSPEC           | \
                                   RRPV_COLORVERTEXEMIS )


// RRProcessVertices::m_dwDirtyFlags flags
#define RRPV_DIRTY_PROJXFM     0x00000001
#define RRPV_DIRTY_VIEWXFM     0x00000002
#define RRPV_DIRTY_WORLDXFM    0x00000004
#define RRPV_DIRTY_WORLD1XFM   0x00000008
#define RRPV_DIRTY_WORLD2XFM   0x00000010
#define RRPV_DIRTY_WORLD3XFM   0x00000020
#define RRPV_DIRTY_VIEWRECT    0x00000040
#define RRPV_DIRTY_ZRANGE      0x00000080
#define RRPV_DIRTY_XFORM       (RRPV_DIRTY_PROJXFM   | \
                                RRPV_DIRTY_VIEWXFM   | \
                                RRPV_DIRTY_VIEWRECT  | \
                                RRPV_DIRTY_WORLDXFM  | \
                                RRPV_DIRTY_WORLD1XFM | \
                                RRPV_DIRTY_WORLD2XFM | \
                                RRPV_DIRTY_WORLD3XFM | \
                                RRPV_DIRTY_ZRANGE)
#define RRPV_DIRTY_MATERIAL        0x00000100
#define RRPV_DIRTY_SETLIGHT        0x00000200
#define RRPV_DIRTY_NEEDXFMLIGHT    0x00000400
#define RRPV_DIRTY_COLORVTX        0x00000800
#define RRPV_DIRTY_LIGHTING    (RRPV_DIRTY_MATERIAL     | \
                                RRPV_DIRTY_SETLIGHT     | \
                                RRPV_DIRTY_NEEDXFMLIGHT | \
                                RRPV_DIRTY_COLORVTX)
#define RRPV_DIRTY_FOG              0x00010000
#define RRPV_DIRTY_CLIPPLANES       0x00020000
#define RRPV_DIRTY_INVERSEWORLDVIEW 0x00040000

//---------------------------------------------------------------------
// Transform & Lighting related data is encapsulated here
//---------------------------------------------------------------------
class RRProcessVertices
{
protected:

    //-------------------------------------------------------------------------
    // Unprocessed state set by the DDI
    //-------------------------------------------------------------------------
    // Growable Light array
    RRLight  *m_pLightArray;
    // RRLight  *m_pLightArray;
    DWORD    m_dwLightArraySize;        // Size of the light array allocated

    // Current material to use for lighting
    D3DMATERIAL7 m_Material;

    // Vertex components
    // Note: position is used to store the vertex buffer in the non-strided
    // driver emulation mode
    D3DDP_PTRSTRIDE m_position;
    D3DDP_PTRSTRIDE m_normal;
    D3DDP_PTRSTRIDE m_specular;
    D3DDP_PTRSTRIDE m_diffuse;
    D3DDP_PTRSTRIDE m_tex0;
    D3DDP_PTRSTRIDE m_tex1;
    D3DDP_PTRSTRIDE m_tex2;
    D3DDP_PTRSTRIDE m_tex3;
    D3DDP_PTRSTRIDE m_tex4;
    D3DDP_PTRSTRIDE m_tex5;
    D3DDP_PTRSTRIDE m_tex6;
    D3DDP_PTRSTRIDE m_tex7;

    // Transformation state stored by the reference implementation
    RRMATRIX      m_xfmProj;
    RRMATRIX      m_xfmView;
    RRMATRIX      m_xfmWorld[RRMAX_WORLD_MATRICES];

    // Viewport data
    D3DVIEWPORT7 m_Viewport;

    // User defined clipping planes
    RRVECTOR4 m_userClipPlanes[RRMAX_USER_CLIPPLANES];

    //-------------------------------------------------------------------------
    // Cached T&L related render-state info
    //-------------------------------------------------------------------------
    DWORD m_dwTLState;           // RenderState related flags
    DWORD m_dwDirtyFlags;        // Dirty flags

    //-------------------------------------------------------------------------
    // Transformation data
    //-------------------------------------------------------------------------
    // Buffer to store clip flags
    RefAlignedBuffer32    m_ClipFlagBuf;
    RRCLIPCODE *m_pClipBuf;

    // Buffer to store transformed vertices
    RefAlignedBuffer32    m_TLVBuf;
    LPVOID m_pvOut;

    // Current transformation matrix
    RRMATRIX m_xfmCurrent[RRMAX_WORLD_MATRICES];  // using WORLDi matrix
    RRMATRIX m_xfmToEye[RRMAX_WORLD_MATRICES];    // Transforms to camera
                                                  // space (Mworld*Mview)
    RRMATRIX m_xfmToEyeInv[RRMAX_WORLD_MATRICES]; // and its Inverse

    D3DPRIMITIVETYPE m_primType;  // Current primitive being drawn
    DWORD m_dwNumVertices;        // Number of vertices to process

    DWORD m_dwNumIndices;         // Number of indices for Indexed Prims
    LPWORD m_pIndices;

    DWORD m_dwFVFIn;              // FVF of the input vertices
    UINT64 m_qwFVFOut;             // Desired FVF for the output vertices
    DWORD m_dwOutputVtxSize;      // Size of the output vertex
    DWORD m_dwNumTexCoords;       // Number of the texture coordinate sets
    DWORD m_dwTexCoordSize[D3DDP_MAXTEXCOORD]; // Size of each one of them in
                                               // bytes
    DWORD m_dwTextureCoordSizeTotal;    // In Bytes

    DWORD   m_dwTexOffset;        // Offsets in the input FVF vertex.
    DWORD   m_dwDiffuseOffset;    // Recomputed when FVF is changed.
    DWORD   m_dwSpecularOffset;
    DWORD   m_dwNormalOffset;

    int     m_numVertexBlends;
    RRTRANSFORMDATA m_TransformData;
    RRVIEWPORTDATA m_ViewData;   // Computed Viewport dependent info.

    FLOAT m_fPointSize;
    FLOAT m_fPointAttA;
    FLOAT m_fPointAttB;
    FLOAT m_fPointAttC;
    FLOAT m_fPointSizeMin;

    //-------------------------------------------------------------------------
    // Lighting data
    //-------------------------------------------------------------------------
    RRLIGHTVERTEX_FUNC_TABLE    m_LightVertexTable;
    RRLIGHTING                  m_lighting;   // Lighting state

    //-------------------------------------------------------------------------
    // Clipping data
    //-------------------------------------------------------------------------
    // Clipping related
    RRCLIPCODE m_clipUnion;            // OR of all vertex clip flags
    RRCLIPCODE m_clipIntersection;     // AND of all vertex clip flags
    RRCLIPPING m_clipping;
    // User clip planes transformed
    RRUSERCLIPPLANE m_xfmUserClipPlanes[RRMAX_USER_CLIPPLANES];


    ///////////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////////
    HRESULT UpdateXformData();
    HRESULT UpdateLightingData();
    HRESULT UpdateFogData();
    HRESULT UpdateClippingData( DWORD dwClipPlanesEnable );

    RRCLIPCODE
    ComputeClipCodes(RRCLIPCODE* pclipIntersection, RRCLIPCODE* pclipUnion,
        FLOAT x_clip, FLOAT y_clip, FLOAT z_clip, FLOAT w_clip, FLOAT fPointSize);
    RRCLIPCODE ProcessVertices();
    HRESULT DoIPrim();
    HRESULT DoNIPrim();

    void SetupFVFData(BOOL bFogEnabled, BOOL bSpecularEnable);

    void LightVertex( D3DLIGHTINGELEMENT *le );
    void FogVertex  ( D3DVECTOR &v, D3DLIGHTINGELEMENT *le,
                      int numVertexBlends,
                      float *pBlendFactors,
                      BOOL bVertexInEyeSpace );

    void InitTLData();

    // DrawClippedPrimitive
    HRESULT DrawOneClippedIndexedPrimitive();
    HRESULT DrawOneClippedPrimitive();


    // Clipping Related
    void Interpolate(RRCLIPVTX *out, RRCLIPVTX *p1, RRCLIPVTX *p2,
                     int code, D3DVALUE num, D3DVALUE denom);

    int ClipLeft( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipRight( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipTop( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBottom( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipFront( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBack( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipLeftGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipRightGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipTopGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBottomGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);

    int ClipLineLeft( RRCLIPTRIANGLE *inv);
    int ClipLineRight( RRCLIPTRIANGLE *inv);
    int ClipLineTop( RRCLIPTRIANGLE *inv);
    int ClipLineBottom( RRCLIPTRIANGLE *inv);
    int ClipLineFront( RRCLIPTRIANGLE *inv);
    int ClipLineBack( RRCLIPTRIANGLE *inv);
    int ClipLineLeftGB( RRCLIPTRIANGLE *inv);
    int ClipLineRightGB( RRCLIPTRIANGLE *inv);
    int ClipLineTopGB( RRCLIPTRIANGLE *inv);
    int ClipLineBottomGB( RRCLIPTRIANGLE *inv);

    int ClipByPlane( RRCLIPVTX **inv, RRCLIPVTX **outv, RRVECTOR4 *plane,
                     DWORD dwClipFlag, int count );
    int ClipLineByPlane( RRCLIPTRIANGLE *line, RRVECTOR4 *plane,
                         DWORD dwClipBit);
};

// Vertex Lighting functions
void RRLV_Directional( RRLIGHTING&, D3DLIGHT7 *, RRLIGHTI *,
                       D3DLIGHTINGELEMENT *, DWORD, DWORD );
void RRLV_PointAndSpot( RRLIGHTING&, D3DLIGHT7 *, RRLIGHTI *,
                        D3DLIGHTINGELEMENT *, DWORD, DWORD );

// For TL Refrast
// Following primitive functions are shared by REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(ReferenceRasterizer * pCtx,
                          UINT16 FvfStride,
                          PUINT8 pVtx,
                          LPWORD puIndices,
                          D3DPRIMITIVETYPE PrimType,
                          UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(ReferenceRasterizer * pCtx,
                   UINT16 FvfStride,
                   PUINT8 pVtx,
                   D3DPRIMITIVETYPE PrimType,
                   UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(ReferenceRasterizer * pCtx,
                             UINT16 FvfStride,
                             PUINT8 pVtx,
                             UINT cVertices,
                             UINT32 dwEdgeFlags);

//---------------------------------------------------------------------
// ComputeTextureCoordSize:
// Computes the following device data
//  - bTextureCoordSizeTotal
//  - bTextureCoordSize[] array, based on the input FVF id
//---------------------------------------------------------------------
__inline void ComputeTextureCoordSize(DWORD dwFVF,
                                      LPDWORD pdwTexCoordSizeArray,
                                      LPDWORD pdwTexCoordSizeTotal)
{
    // Texture formats size  00   01   10   11
    static BYTE bTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        *pdwTexCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
            pdwTexCoordSizeArray[i] = 4*2;
    }
    else
    {
        *pdwTexCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = bTextureSize[dwTextureFormats & 3];
            pdwTexCoordSizeArray[i] = dwSize;
            *pdwTexCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
#endif // _REFTNL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\link\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dref
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

!if "$(BUILD_MSREF)" != ""

!ifdef SD_BUILD

REFLIBPATH = $(PROJECT_LIB_PATH)

!else

TARGETPATHLIB=$(BASEDIR)\public\sdk\lib\$(ALT_PROJECT_TARGET)
REFLIBPATH = $(BASEDIR)\public\sdk\lib\*

!endif

DDRAWLIB = ddrawp

!else

REFLIBPATH = $(DDK_LIB_PATH)
DDRAWLIB = ddraw

!endif

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\user32.lib   \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\uuid.lib     \
        $(SDK_LIB_PATH)\kernel32.lib \
    	$(REFLIBPATH)\$(DDRAWLIB).lib                


LINKLIBS = \
        ..\..\rast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib  \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\reftnl.lib    \
        ..\..\drv\$(PLAT_DIR)\$(_OBJ_DIR)\*\refdrv.lib 

DLLENTRY = _DllMainCRTStartup

SOURCES = \
    ..\d3dref.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\attrfunc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// AttrFunc.cpp
//
// Direct3D Reference Rasterizer - Attribute Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// WrapDiff - returns the difference (B-A) as defined under the D3D WRAPU/V
// rules which is the shortest path between the two assuming a coincident
// position at 1. and 0.  The fA and fB input range is 0. to 1.
//
//-----------------------------------------------------------------------------
static FLOAT
WrapDiff( FLOAT fB, FLOAT fA )
{
    // compute straight distance
    FLOAT fDist1 = fB - fA;
    // compute distance 'warping' between 0. and 1.
    FLOAT fDist2 = ( fDist1 < 0 ) ? ( fDist1+1 ) : ( fDist1-1 );

    // return minimum of these
    return ( fabs( fDist1) < fabs( fDist2) ) ? ( fDist1) : ( fDist2 );
}


///////////////////////////////////////////////////////////////////////////////
//
// RRAttribFuncStatic - Attribute function data which is shared by all
// attributes and contains per-primitive and per-pixel data.  Cannot use static
// data members in RRAttribFunc class because there can be multiple instances
// of rasterizer object.
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetPerTriangleData - Called once per triangle during setup to set per-triangle
// data used to compute attribute functions.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerTriangleData(
    FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
    FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
    FLOAT fX2, FLOAT fY2, FLOAT fRHW2,
    INT32 cTextureStages,
    FLOAT* pfRHQW,
    FLOAT fDet )
{
    m_PrimType = RR_TRIANGLE;

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    INT32 iX0 = AS_INT32( (DOUBLE)fX0 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)fY0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)fX1 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)fY1 + DOUBLE_4_SNAP );
    INT32 iX2 = AS_INT32( (DOUBLE)fX2 + DOUBLE_4_SNAP );
    INT32 iY2 = AS_INT32( (DOUBLE)fY2 + DOUBLE_4_SNAP );
    fX0 = (FLOAT)iX0 * 1.0F/16.0F;
    fY0 = (FLOAT)iY0 * 1.0F/16.0F;
    fX1 = (FLOAT)iX1 * 1.0F/16.0F;
    fY1 = (FLOAT)iY1 * 1.0F/16.0F;
    fX2 = (FLOAT)iX2 * 1.0F/16.0F;
    fY2 = (FLOAT)iY2 * 1.0F/16.0F;

    m_fX0 = fX0;
    m_fY0 = fY0;
    m_cTextureStages = cTextureStages;

    m_fRHW0 = fRHW0;
    m_fRHW1 = fRHW1;
    m_fRHW2 = fRHW2;

    m_fDelX10 = fX1 - fX0;
    m_fDelX02 = fX0 - fX2;
    m_fDelY01 = fY0 - fY1;
    m_fDelY20 = fY2 - fY0;

    // compute inverse determinant
    m_fTriOODet = 1.f/fDet;

    // compute linear function for 1/W (for perspective correction)

    // compute linear deltas along two edges
    FLOAT fDelAttrib10 = m_fRHW1 - m_fRHW0;
    FLOAT fDelAttrib20 = m_fRHW2 - m_fRHW0;

    // compute A & B terms (dVdX and dVdY)
    m_fRHWA = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
    m_fRHWB = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

    // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        m_fRHQW0[i] = pfRHQW[0];
        m_fRHQW1[i] = pfRHQW[1];
        m_fRHQW2[i] = pfRHQW[2];
        pfRHQW += 3;

        // compute linear function for Q/W (for transformed, projected, perspective corrected texture)
        fDelAttrib10 = m_fRHQW1[i] - m_fRHQW0[i];
        fDelAttrib20 = m_fRHQW2[i] - m_fRHQW0[i];

        // compute A & B terms (dVdX and dVdY)
        m_fRHQWA[i] = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
        m_fRHQWB[i] = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fRHQWC[i] = m_fRHQW0[i] - ( m_fRHQWA[i] * m_fX0 ) - ( m_fRHQWB[i] * m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// SetPerLineData - Called once per line during setup to set per-line
// data used to compute attribute functions.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerLineData(
    FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
    FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
    INT32 cTextureStages,
    FLOAT* pfRHQW,
    FLOAT fMajorExtent, BOOL bXMajor )
{
    m_PrimType = RR_LINE;

    m_fLineMajorLength = fMajorExtent;
    m_bLineXMajor = bXMajor;

    m_fX0 = fX0;
    m_fY0 = fY0;
    m_cTextureStages = cTextureStages;

    m_fRHW0 = fRHW0;
    m_fRHW1 = fRHW1;

    // compute linear function for 1/W (for perspective correction)
    FLOAT fDelta = ( m_fRHW1 - m_fRHW0 ) / m_fLineMajorLength;
    m_fRHWA = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
    m_fRHWB = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
    m_fRHWC = fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );
    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        m_fRHQW0[i] = pfRHQW[0];
        m_fRHQW1[i] = pfRHQW[1];
        pfRHQW += 3;

        // compute linear function for Q/W (for transformed, projected, perspective corrected texture)
        FLOAT fDelta = ( m_fRHQW1[i] - m_fRHQW0[i] ) / m_fLineMajorLength;
        m_fRHQWA[i] = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
        m_fRHQWB[i] = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
        m_fRHQWC[i] = m_fRHQW0[i] - ( m_fRHQWA[i] * m_fX0 ) - ( m_fRHQWB[i] * m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// SetPixel - Called once per pixel to do preparation for per-pixel attribute
// evaluations.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerPixelData( INT16 iX, INT16 iY )
{
    m_iX = iX;
    m_iY = iY;

    // evalute 1/W function
    FLOAT fPixelRHW =
        ( m_fRHWA * (FLOAT)m_iX ) + ( m_fRHWB * (FLOAT)m_iY ) + m_fRHWC;
    m_fPixelW = ( 0. != fPixelRHW ) ? ( 1./fPixelRHW ) : ( 0. );
    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        FLOAT fPixelRHQW =
            ( m_fRHQWA[i] * (FLOAT)m_iX ) + ( m_fRHQWB[i] * (FLOAT)m_iY ) + m_fRHQWC[i];
        m_fPixelQW[i] = ( 0. != fPixelRHQW ) ? ( 1./fPixelRHQW ) : ( 0. );
    }
}

//-----------------------------------------------------------------------------
//
// GetPixelW,GetPixelQW,GetRhwXGradient,GetRhwYGradient,
// GetRhqwXGradient,GetRhqwYGradient - Functions to get static
// data members.
//
//-----------------------------------------------------------------------------
FLOAT RRAttribFuncStatic::GetPixelW( void ) { return m_fPixelW; }
FLOAT RRAttribFuncStatic::GetPixelQW( INT32 iStage ) { return m_fPixelQW[iStage]; }
FLOAT RRAttribFuncStatic::GetRhqwXGradient( INT32 iStage ) { return m_fRHQWA[iStage]; }
FLOAT RRAttribFuncStatic::GetRhqwYGradient( INT32 iStage ) { return m_fRHQWB[iStage]; }


///////////////////////////////////////////////////////////////////////////////
//
// RRAttribFunc - methods
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetConstant - Sets function to evaluate to constant value.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetConstant(
    FLOAT fC )
{
    m_bIsPerspective = FALSE;
    m_fA = 0.; m_fB = 0.; m_fC = fC;
}

//-----------------------------------------------------------------------------
//
// SetLinearFunc - Computes linear function for scalar attribute specified at
// triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetLinearFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 )
{
    m_bIsPerspective = FALSE;

    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // compute A,B,C for triangle function

            // compute linear deltas along two edges
            FLOAT fDelAttrib10 = fVal1 - fVal0;
            FLOAT fDelAttrib20 = fVal2 - fVal0;

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = fVal0 - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );
        }
        break;

    case RR_LINE:
        {
            // compute A,B,C for line function - delta is normalized difference
            // in major direction; C is computed from knowing the function value
            // at the vertices (vertex 0 is always used here)
            FLOAT fDelta = ( fVal1 - fVal0 ) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = fVal0 - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        break;
    }

}

//-----------------------------------------------------------------------------
//
// SetPerspFunc - Computes perspective corrected function for scalar attribute
// specified at triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetPerspFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 )
{
    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // triangle function

            // compute adjusted values for vertices 1,2 based on wrap flag
            FLOAT fVal1P = (fVal1);
            FLOAT fVal2P = (fVal2);

            // compute perspective corrected linear deltas along two edges
            FLOAT fDelAttrib10 = ( fVal1P * m_pSD->m_fRHW1 ) - ( fVal0 * m_pSD->m_fRHW0 );
            FLOAT fDelAttrib20 = ( fVal2P * m_pSD->m_fRHW2 ) - ( fVal0 * m_pSD->m_fRHW0 );

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* m_pSD->m_fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_LINE:
        {
            // line function

            FLOAT fVal1P = (fVal1);
            FLOAT fDelta =
                ( fVal1P*m_pSD->m_fRHW1 - fVal0*m_pSD->m_fRHW0) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* m_pSD->m_fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        // don't correct constant functions
        m_bIsPerspective = FALSE;

        break;
    }
}

//-----------------------------------------------------------------------------
//
// Eval - Evaluates function at pixel position set in RRAttribFunc::SetPerPixelData.
// Functions know if they are perspective corrected or not, and if so then do
// the multiply through by the 1/(1/w) term to normalize.
//
//-----------------------------------------------------------------------------
FLOAT
RRAttribFunc::Eval( void )
{
    FLOAT fRet =
        ( m_fA * (FLOAT)m_pSD->m_iX ) + ( m_fB * (FLOAT)m_pSD->m_iY ) + m_fC;
    if ( m_bIsPerspective ) { fRet *= m_pSD->m_fPixelW; }
    return fRet;
}

//-----------------------------------------------------------------------------
//
// SetPerspFunc - Computes perspective corrected function for scalar attribute
// specified at triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetPerspFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2,
    BOOL bWrap, BOOL bIsShadowMap )
{
    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // triangle function
            FLOAT fRHW0 = m_pSD->m_fRHW0;
            FLOAT fRHW1 = m_pSD->m_fRHW1;
            FLOAT fRHW2 = m_pSD->m_fRHW2;
            if (bIsShadowMap)
            {
                fRHW0 = 1.0f;
                fRHW1 = 1.0f;
                fRHW2 = 1.0f;
            }

            // compute adjusted values for vertices 1,2 based on wrap flag
            FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
            FLOAT fVal2P = bWrap ? ( fVal0 + WrapDiff(fVal2,fVal0) ) : (fVal2);

            // compute perspective corrected linear deltas along two edges
            FLOAT fDelAttrib10 = ( fVal1P * fRHW1 ) - ( fVal0 * fRHW0 );
            FLOAT fDelAttrib20 = ( fVal2P * fRHW2 ) - ( fVal0 * fRHW0 );

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0 * fRHW0 )
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_LINE:
        {
            // line function

            FLOAT fRHW0 = m_pSD->m_fRHW0;
            FLOAT fRHW1 = m_pSD->m_fRHW1;
            if (bIsShadowMap)
            {
                fRHW0 = 1.0f;
                fRHW1 = 1.0f;
            }

            FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
            FLOAT fDelta =
                ( fVal1P*fRHW1 - fVal0*fRHW0) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        // don't correct constant functions
        m_bIsPerspective = FALSE;

        break;
    }
}

//-----------------------------------------------------------------------------
//
// Eval - Evaluates function at pixel position set in RRAttribFunc::SetPerPixelData.
// Functions know if they are perspective corrected or not, and if so then do
// the multiply through by the 1/(q/w) term to normalize.
//
//-----------------------------------------------------------------------------
FLOAT
RRAttribFunc::Eval( INT32 iStage )
{
    FLOAT fRet =
        ( m_fA * (FLOAT)m_pSD->m_iX ) + ( m_fB * (FLOAT)m_pSD->m_iY ) + m_fC;
    // m_bIsPerspective will always be set since persp function is always
    // used for texture coords
    if ( m_bIsPerspective ) { fRet *= m_pSD->m_fPixelQW[iStage]; }
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\attrfunc.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// AttrFunc.hpp
//
// Direct3D Reference Rasterizer - Attribute Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _ATTRFUNC_HPP
#define _ATTRFUNC_HPP

enum RRPrimType { RR_POINT, RR_LINE, RR_TRIANGLE };

//-----------------------------------------------------------------------------
//
// RRAttribFuncStatic - static data for attribute functions.  This is
// per-primitive data (as opposed to per-attribute data which is in arrays of
// RRAttribFunc objects).  This would be more elegantly done as static
// data in the RRAttribFunc class, but we need to be able to multiply instance
// the ReferenceRasterizer object and cannot have variable global state.
//
//-----------------------------------------------------------------------------
class RRAttribFuncStatic
{
private:
    RRPrimType m_PrimType;

// per-primitive data
    FLOAT m_fX0, m_fY0;         // first vertex (for initial evaluation)
    FLOAT m_fRHW0, m_fRHW1, m_fRHW2;   // 1/W data for perspective correction
    FLOAT m_fRHQW0[D3DHAL_TSS_MAXSTAGES]; // Q/W data for texture perspective correction
    FLOAT m_fRHQW1[D3DHAL_TSS_MAXSTAGES];
    FLOAT m_fRHQW2[D3DHAL_TSS_MAXSTAGES];

    FLOAT m_fDelX10, m_fDelX02; // x,y deltas
    FLOAT m_fDelY01, m_fDelY20; //

    FLOAT m_fTriOODet;          // 1/determinant for triangle function normalization

    FLOAT m_fLineMajorLength;   // major length for line function
    BOOL  m_bLineXMajor;        // TRUE if X major for line function

    FLOAT m_fRHWA, m_fRHWB, m_fRHWC;    // linear function for 1/W
    INT32 m_cTextureStages;
    FLOAT m_fRHQWA[D3DHAL_TSS_MAXSTAGES];    // linear function for texture Q/W
    FLOAT m_fRHQWB[D3DHAL_TSS_MAXSTAGES];
    FLOAT m_fRHQWC[D3DHAL_TSS_MAXSTAGES];

// per-pixel data
    INT16 m_iX, m_iY;
    FLOAT m_fPixelW;
    FLOAT m_fPixelQW[D3DHAL_TSS_MAXSTAGES];

    friend class RRAttribFunc;

public:

// Set/Get Per-primitive Data
    void SetPerTriangleData(
        FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
        FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
        FLOAT fX2, FLOAT fY2, FLOAT fRHW2,
        INT32 cTextureStages,
        FLOAT* pfRHQW,
        FLOAT fDet );
    void SetPerLineData(
        FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
        FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
        INT32 cTextureStages,
        FLOAT* pfRHQW,
        FLOAT fMajorExtent, BOOL bXMajor );

    void SetPerPixelData( INT16 iX, INT16 iY );

    FLOAT GetPixelW( void );
    FLOAT GetPixelQW( INT32 iStage );
    FLOAT GetRhqwXGradient( INT32 iStage );
    FLOAT GetRhqwYGradient( INT32 iStage );
};

//-----------------------------------------------------------------------------
//
// Primitive attribute function - Stores linear function of form
// `F = A*x + B*y + C'  computed during setup and used to compute primitive
// attributes at each pixel location.  One of these is used per scalar vertex
// attribute (i.e. one per Red,Green,Blue,Alpha,Z, ...)
//
//-----------------------------------------------------------------------------
class RRAttribFunc
{
private:

// pointer to static data structure
    RRAttribFuncStatic* m_pSD;

// attribute function
    FLOAT m_fA;
    FLOAT m_fB;
    FLOAT m_fC;

// flags
    BOOL  m_bIsPerspective;

public:
    void SetStaticDataPointer( RRAttribFuncStatic* pSD ) { m_pSD = pSD; }

// DEFINE
    void SetConstant( FLOAT fVal );
    void SetLinearFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 );
    void SetPerspFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 );
    void SetPerspFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2, BOOL bWrap, BOOL bIsShadowMap );

    FLOAT GetXGradient( void ) { return m_fA; }
    FLOAT GetYGradient( void ) { return m_fB; }

// EVALUATE
    FLOAT Eval( void );
    FLOAT Eval( INT32 iStage );
};

//////////////////////////////////////////////////////////////////////////////
#endif  // _ATTRFUNC_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\inc\rrutil.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrutil.hpp
//
// Direct3D Reference Rasterizer - Utilities
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _RRUTIL_HPP
#define  _RRUTIL_HPP

#include <math.h>

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// memory allocation callbacks
extern LPVOID (__cdecl *g_pfnMemAlloc)( size_t size );
extern void   (__cdecl *g_pfnMemFree)( LPVOID lptr );
extern LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size );

// debug print controls
extern int g_iDPFLevel;
extern unsigned long g_uDPFMask;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Typedefs                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

// width-specific typedefs for basic types
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;
typedef int                     BOOL;


typedef struct _RRVECTOR4
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} RRVECTOR4, *LPRRVECTOR4;

//-----------------------------------------------------------------------------
//
// Private FVF flags for texgen.
//
//-----------------------------------------------------------------------------
#define D3DFVFP_EYENORMAL     ((UINT64)1<<32)
#define D3DFVFP_EYEXYZ        ((UINT64)1<<33)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
#define ABS(a) (((a) < 0) ? (-(a)) : (a))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                         \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}


//-----------------------------------------------------------------------------
//
// macros for accessing floating point data as 32 bit integers and vice versa
//
// This is used primarily to do floating point to fixed point conversion with
// the unbiased nearest-even rounding that IEEE floating point does internally
// between operations.  Adding a big number slides the mantissa down to where
// the fixed point equivalent is aligned to the LSB.  IEEE applies a nearest-
// even round to the bits it lops off before storing.  The mantissa can then
// be grabbed by the AS_INT* operations.  Note that the sign and exponent are
// still there, so the easiest thing is to do it with doubles and grab the low
// 32 bits.
//
// The snap values (i.e. the "big number") is the sum of 2**n and 2**(n-1),
// which makes the trick return signed numbers (at least within the mantissa).
//
//-----------------------------------------------------------------------------

#if 0
// NOTE: vc5 optimizing compiler bug breaks this pointer casting technique
#define AS_FLOAT(i) ( *(FLOAT*)&(i) )
#define AS_INT32(f) ( *(INT32*)&(f) )
#define AS_INT16(f) ( *(INT16*)&(f) )
#define AS_UINT32(f) ( *(UINT32*)&(f) )

#else

// workaround using union
typedef union { float f; UINT32 u; INT32 i; } VAL32;
typedef union { double d; UINT64 u; INT64 i; } VAL64;
inline FLOAT AS_FLOAT( long int iVal ) { VAL32 v; v.i = iVal; return v.f; }
inline FLOAT AS_FLOAT( unsigned long int uVal ) { VAL32 v; v.u = uVal; return v.f; }
inline INT32 AS_INT32(  FLOAT fVal ) { VAL32 v; v.f = fVal; return v.i; }
inline INT32 AS_INT32( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT32)(v.u & 0xffffffff); }
inline INT16 AS_INT16(  FLOAT fVal ) { VAL32 v; v.f = fVal; return (INT16)(v.u & 0xffff); }
inline INT16 AS_INT16( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT16)(v.u & 0xffff); }
inline INT32 AS_UINT32( FLOAT fVal ) { VAL32 v; v.f = fVal; return v.u; }

#endif

//-----------------------------------------------------------------------------
//
// Some common FP values as constants
// point values
//
//-----------------------------------------------------------------------------
#define g_fZero                 (0.0f)
#define g_fOne                  (1.0f)

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

//-----------------------------------------------------------------------------
//
// these are handy to form 'magic' constants to snap real values to fixed
// point values
//
//-----------------------------------------------------------------------------
#define C2POW0 1
#define C2POW1 2
#define C2POW2 4
#define C2POW3 8
#define C2POW4 16
#define C2POW5 32
#define C2POW6 64
#define C2POW7 128
#define C2POW8 256
#define C2POW9 512
#define C2POW10 1024
#define C2POW11 2048
#define C2POW12 4096
#define C2POW13 8192
#define C2POW14 16384
#define C2POW15 32768
#define C2POW16 65536
#define C2POW17 131072
#define C2POW18 262144
#define C2POW19 524288
#define C2POW20 1048576
#define C2POW21 2097152
#define C2POW22 4194304
#define C2POW23 8388608
#define C2POW24 16777216
#define C2POW25 33554432
#define C2POW26 67108864
#define C2POW27 134217728
#define C2POW28 268435456
#define C2POW29 536870912
#define C2POW30 1073741824
#define C2POW31 2147483648
#define C2POW32 4294967296
#define C2POW33 8589934592
#define C2POW34 17179869184
#define C2POW35 34359738368
#define C2POW36 68719476736
#define C2POW37 137438953472
#define C2POW38 274877906944
#define C2POW39 549755813888
#define C2POW40 1099511627776
#define C2POW41 2199023255552
#define C2POW42 4398046511104
#define C2POW43 8796093022208
#define C2POW44 17592186044416
#define C2POW45 35184372088832
#define C2POW46 70368744177664
#define C2POW47 140737488355328
#define C2POW48 281474976710656
#define C2POW49 562949953421312
#define C2POW50 1125899906842624
#define C2POW51 2251799813685248
#define C2POW52 4503599627370496

#define FLOAT_0_SNAP    (FLOAT)(C2POW23+C2POW22)
#define FLOAT_4_SNAP    (FLOAT)(C2POW19+C2POW18)
#define FLOAT_5_SNAP    (FLOAT)(C2POW18+C2POW17)
#define FLOAT_8_SNAP    (FLOAT)(C2POW15+C2POW14)
#define FLOAT_17_SNAP   (FLOAT)(C2POW6 +C2POW5 )
#define FLOAT_18_SNAP   (FLOAT)(C2POW5 +C2POW4 )

#define DOUBLE_0_SNAP   (DOUBLE)(C2POW52+C2POW51)
#define DOUBLE_4_SNAP   (DOUBLE)(C2POW48+C2POW47)
#define DOUBLE_5_SNAP   (DOUBLE)(C2POW47+C2POW46)
#define DOUBLE_8_SNAP   (DOUBLE)(C2POW44+C2POW43)
#define DOUBLE_17_SNAP  (DOUBLE)(C2POW35+C2POW34)
#define DOUBLE_18_SNAP  (DOUBLE)(C2POW34+C2POW33)

//-----------------------------------------------------------------------------
//
// Floating point related macros
//
//-----------------------------------------------------------------------------
#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

#ifdef _X86_
#define FLOAT_CMP_POS(fa, op, fb)       (AS_INT32(fa) op AS_INT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (AS_INT32(flt) op INT32_FLOAT_ONE)

__inline int FLOAT_GTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define FTOI(f)                 ((INT)(f))

#endif // _X86_



//-----------------------------------------------------------------------------
//
// macro wrappers for memory allocation - wrapped around global function ptrs
// set by RefRastSetMemif
//
//-----------------------------------------------------------------------------
#define MEMALLOC(_size)         ((*g_pfnMemAlloc)(_size))
#define MEMFREE(_ptr)           { if (NULL != (_ptr)) { ((*g_pfnMemFree)(_ptr)); } }
#define MEMREALLOC(_ptr,_size)  ((*g_pfnMemReAlloc)((_ptr),(_size)))


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// Utility Functions                                                            //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// debug printf support
//
//-----------------------------------------------------------------------------

void RRDebugPrintfL( int iLevel, const char* pszFormat, ... );
void RRDebugPrintf( const char* pszFormat, ... );

#define _DPF_IF     0x0001
#define _DPF_INPUT  0x0002
#define _DPF_SETUP  0x0004
#define _DPF_RAST   0x0008
#define _DPF_TEX    0x0010
#define _DPF_PIX    0x0020
#define _DPF_FRAG   0x0040
#define _DPF_STATS  0x0080
#define _DPF_DRV    0x0100
#define _DPF_TNL    0x0200
#define _DPF_ANY    0xffff
#define _DPF_TEMP   0x8000

#ifdef DBG
    #define DPFRR RRDebugPrintfL
    #define DPFM( _level, _mask, _message) \
        if ((g_iDPFLevel >= (_level)) && (g_uDPFMask & (_DPF_##_mask))) { \
            RRDebugPrintf ## _message; \
        }
#else
    #pragma warning(disable:4002)
    #define DPFRR()
    #define DPFM( _level, _mask, _message)
#endif


//-----------------------------------------------------------------------------
//
// assert macros and reporting functions
//
//-----------------------------------------------------------------------------

// ASSERT with simple string
#undef _ASSERT
#define _ASSERT( value, string )                  \
if ( !(value) ) {                                 \
    RRAssertReport( string, __FILE__, __LINE__ ); \
}
// ASSERT with formatted string - note extra parenthesis on report
// usage: _ASSERTf(foo,("foo is %d",foo))
#undef _ASSERTf
#define _ASSERTf(value,report)                      \
if (!(value)) {                                     \
    char __sz__FILE__[] = __FILE__;                 \
    RRAssertReportPrefix(__sz__FILE__,__LINE__);   \
    RRAssertReportMessage ## report;               \
}
// ASSERT with action field
#undef _ASSERTa
#define _ASSERTa(value,string,action)       \
if (!(value)) {                             \
    RRAssertReport(string,__FILE__,__LINE__); \
    action                                  \
}
// ASSERTf with action field
#undef _ASSERTfa
#define _ASSERTfa(value,report,action)     \
if (!(value)) {                            \
    RRAssertReportPrefix(__FILE__,__LINE__); \
    RRAssertReportMessage ## report;         \
    action                                 \
}

extern void RRAssertReport( const char* pszString, const char* pszFile, int iLine );
extern void RRAssertReportPrefix( const char* pszFile, int iLine );
extern void RRAssertReportMessage( const char* pszFormat, ... );


//-----------------------------------------------------------------------------
//
// bit twiddling utilities
//
//-----------------------------------------------------------------------------

extern INT32 CountSetBits( UINT32 uVal, INT32 nBits );
extern INT32 FindFirstSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindMostSignificantSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindLastSetBit( UINT32 uVal, INT32 nBits );

// TRUE if integer is a power of 2
inline BOOL IsPowerOf2( INT32 i )
{
    if ( i <= 0 ) return 0;
    return ( 0x0 == ( i & (i-1) ) );
}


//-----------------------------------------------------------------------------
//
// multiply/add routines & macros for unsigned 8 bit values, signed 16 bit values
//
// These are not currently used, but the Mult8x8Scl is an interesting routine
// for hardware designers to look at.  This does a 8x8 multiply combined with
// a 256/255 scale which accurately solves the "0xff * value = value" issue.
// There are refinements on this (involving half-adders) which are not easily
// representable in C.  Credits to Steve Gabriel and Jim Blinn.
//
//-----------------------------------------------------------------------------

// straight 8x8 unsigned multiply returning 8 bits, tossing fractional
// bits (no rounding)
inline UINT8 Mult8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 unsigned multiply with ff*val = val scale adjustment (scale by (256/255))
inline UINT8 Mult8x8Scl( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    uRes16 += 0x0080;
    uRes16 += (uRes16>>8);
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 saturated addition - result > 0xff returns 0xff
inline UINT8 SatAdd8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16+uB16;
    UINT8  uRes8 = (uRes16 > 0xff) ? (0xff) : ((UINT8)uRes16);
    return uRes8;
}

//----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//----------------------------------------------------------------------------
inline UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//////////////////////////////////////////////////////////////////////////////
// FVF related macros
//////////////////////////////////////////////////////////////////////////////
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)


//////////////////////////////////////////////////////////////////////////////
// State Override Macros
//////////////////////////////////////////////////////////////////////////////
#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> RRSTATEOVERRIDE_DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (RRSTATEOVERRIDE_DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------
// GetFVFVertexSize:
//     Computes total vertex size in bytes for given fvf
//     including the texture coordinates
//---------------------------------------------------------------------
__inline DWORD
GetFVFVertexSize( UINT64 qwFVF )
{
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwSize = 3 << 2;
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZRHW: dwSize += 4;      break;
    case D3DFVF_XYZB1:  dwSize += 1*4;    break;
    case D3DFVF_XYZB2:  dwSize += 2*4;    break;
    case D3DFVF_XYZB3:  dwSize += 3*4;    break;
    case D3DFVF_XYZB4:  dwSize += 4*4;    break;
    case D3DFVF_XYZB5:  dwSize += 5*4;    break;
    }
    if (qwFVF & D3DFVF_NORMAL)
        dwSize += 3*4;
    if (qwFVF & D3DFVF_RESERVED1)
        dwSize += 4;

    if (qwFVF & D3DFVF_DIFFUSE)
        dwSize += 4;
    if (qwFVF & D3DFVF_SPECULAR)
        dwSize += 4;

    // Texture coordinates
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)qwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwSize += dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwSize += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    if (qwFVF & D3DFVF_S)
        dwSize += 4;

    if (qwFVF & D3DFVFP_EYENORMAL)
        dwSize += 3*4;

    if (qwFVF & D3DFVFP_EYEXYZ)
        dwSize += 3*4;

    return dwSize;
}

HRESULT
RRFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride );

///////////////////////////////////////////////////////////////////////////////
// Matrix and Vector routines
///////////////////////////////////////////////////////////////////////////////

inline void
ReverseVector(const D3DVECTOR &in, D3DVECTOR &out)
{
    out.x = -in.x;
    out.y = -in.y;
    out.z = -in.z;
}

inline void
AddVector(const D3DVECTOR &v1, const D3DVECTOR &v2, D3DVECTOR &out)
{
    out.x = v1.x + v2.x;
    out.y = v1.y + v2.y;
    out.z = v1.z + v2.z;
}

inline void
SubtractVector(const D3DVECTOR &v1, const D3DVECTOR &v2, D3DVECTOR &out)
{
    out.x = v1.x - v2.x;
    out.y = v1.y - v2.y;
    out.z = v1.z - v2.z;
}

inline void
SetIdentity(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 1.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
SetNull(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 0.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
CopyMatrix(D3DMATRIX &s, D3DMATRIX &d)
{
    d._11 = s._11;
    d._12 = s._12;
    d._13 = s._13;
    d._14 = s._14;
    d._21 = s._21;
    d._22 = s._22;
    d._23 = s._23;
    d._24 = s._24;
    d._31 = s._31;
    d._32 = s._32;
    d._33 = s._33;
    d._34 = s._34;
    d._41 = s._41;
    d._42 = s._42;
    d._43 = s._43;
    d._44 = s._44;
}

inline D3DVALUE
SquareMagnitude (const D3DVECTOR& v)
{
    return v.x*v.x + v.y*v.y + v.z*v.z;
}


inline D3DVALUE
Magnitude (const D3DVECTOR& v)
{
    return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVECTOR
Normalize (const D3DVECTOR& v)
{
    D3DVECTOR nv = {0.0f, 0.0f, 0.0f};
    D3DVALUE mag = Magnitude(v);

    nv.x = v.x/mag;
    nv.y = v.y/mag;
    nv.z = v.z/mag;

    return nv;
}

inline void
Normalize (D3DVECTOR& v)
{
    D3DVALUE mag = Magnitude(v);

    v.x = v.x/mag;
    v.y = v.y/mag;
    v.z = v.z/mag;

    return;
}

inline D3DVECTOR
CrossProduct (const D3DVECTOR& v1, const D3DVECTOR& v2)
{
        D3DVECTOR result;

        result.x = v1.y*v2.z - v1.z*v2.y;
        result.y = v1.z*v2.x - v1.x*v2.z;
        result.z = v1.x*v2.y - v1.y*v2.x;

        return result;
}

inline D3DVALUE
DotProduct (const D3DVECTOR& v1, const D3DVECTOR& v2)
{
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
}

//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by a 4x4 matrix transposed,
// producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4Transposed(RRVECTOR4 *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4(RRVECTOR4 *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + v->w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + v->w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + v->w*m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x4(D3DVECTOR *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
Xform3VecBy3x3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//---------------------------------------------------------------------
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);


////////////////////////////////////////////////////////////////////////
//
// Macros used to access DDRAW surface info.
//
////////////////////////////////////////////////////////////////////////
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDSLcl) \
    (!((pDDSLcl)->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDSLcl) \
    ((pDDSLcl)->lpGbl->dwUsageCount > 0)
#define SURFACE_MEMORY(surfLcl) \
(LPVOID)((surfLcl)->lpGbl->fpVidMem)

//---------------------------------------------------------------------
// DDraw extern functions
//---------------------------------------------------------------------
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

extern "C" HRESULT WINAPI DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl);
extern "C" LPDDRAWI_DDRAWSURFACE_LCL WINAPI
GetDDSurfaceLocal( LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew );


///////////////////////////////////////////////////////////////////////////////
#endif  // _RRUTIL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\cvgmask.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// cvgmask.cpp
//
// Direct3D Reference Rasterizer - Antialiasing Coverage Mask Generation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop



#if 0

// from edgefunc.hpp
    // Normalization factor for antialising is stored in floating point.  This is
    // computed during the setup and applied per-pixel after the (non-normalized)
    // edge distance is evaluated.
    //
    DOUBLE  m_dNorm;
    INT16   m_iEdgeYGradBits;   // 1.8 fixed point

// from edgefunc.cpp ::Set
    if ( bFragProcEnable )
    {
        // compute normalization factor for antialiasing - normalizes for 'square'
        // distance (a.k.a 'manhatten' distance) such that an equidistant point
        // sweep of a distance of 0.5 is a square 1.0 pixel area.
        m_dNorm = 1.0 / ( fabs( fY0-fY1 ) + fabs( fX1-fX0 ) );

        // compute rounded fixed point Y gradient bits for generation of
        // antialiasing coverage mask
        m_iEdgeYGradBits = AS_INT16( ((fY0-fY1)*m_dNorm) + DOUBLE_8_SNAP );
    }

// from ::AATest
    // The edge evaluation is done exactly the same as the point sample case, then
    // it is converted to double precision floating point for the normalization and
    // rounding.  Using doubles makes it very easy to carry adequate precision in
    // the normalization factor and to convert to 32 bit signed integer (holding
    // the n.5 fixed point distance) with round to nearest even.
    //

    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)(iX<<4) ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)(iY<<4) ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                        // n.8

    // convert to double (adjust for n.8 fixed point) for normalization
    // and rounding
    DOUBLE dEdgeDist = (DOUBLE)iEdgeDist * (1./(DOUBLE)(1<<8));

    // normalize edge distance
    dEdgeDist *= m_dNorm;

    // convert distance to fixed point with nearest-even round;
    // keep 5 fractional bits for antialiasing
    INT32 iEdgeDistRnd = AS_INT32( dEdgeDist + DOUBLE_5_SNAP );

    // pixel is fully outside of edge if out by +.5 or more
    if ( iEdgeDistRnd >= +(1<<4) ) return 0x0000;

    // pixel is fully inside of edge if in by -.5 or more
    if ( iEdgeDistRnd <= -(1<<4) ) return 0xFFFF;

    // here when pixel is within 1/2 (square distance) of edge
    // compute coverage mask for this edge
    return ComputeCoverageMask( m_iEdgeYGradBits, m_bAPos, m_bBPos, iEdgeDistRnd );

#endif


//-----------------------------------------------------------------------------
//
// Tables used in computation of coverage mask
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// These are the ranges of the x gradient (the 'A' of F=Ax+By+c) for one
// octant into which the edge slopes are binned.
//-----------------------------------------------------------------------------
#define A_RANGES 4
static UINT16 uARanges[A_RANGES] = {
    // 0.0.8 values
    0x00,  // 0.00
    0x40,  // 0.25
    0x55,  // 0.33
    0x66,  // 0.40
};

//-----------------------------------------------------------------------------
// These are the 16 bit coverage masks for each of the A ranges.  The
// 15 values within each range define the order in which the coverage
// mask bits are enabled, thus the least-significant index is the number
// of coverage mask bits that need to be enabled.
//-----------------------------------------------------------------------------
static UINT16 CvgMasks[A_RANGES][15] = {
    { // 0.000 .. 0.250
        0x1,
        0x3,
        0x7,
        0xF,
        0x1F,
        0x3F,
        0x7F,
        0xFF,
        0x1FF,
        0x3FF,
        0x7FF,
        0xFFF,
        0x1FFF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.250 .. 0.333
        0x1,
        0x3,
        0x7,
        0x17,
        0x1F,
        0x3F,
        0x7F,
        0x17F,
        0x1FF,
        0x3FF,
        0x7FF,
        0x17FF,
        0x1FFF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.333 .. 0.400
        0x1,
        0x3,
        0x13,
        0x17,
        0x37,
        0x3F,
        0x13F,
        0x17F,
        0x37F,
        0x3FF,
        0x13FF,
        0x17FF,
        0x37FF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.400 .. 0.500
        0x1,
        0x3,
        0x13,
        0x17,
        0x37,
        0x137,
        0x13F,
        0x17F,
        0x37F,
        0x137F,
        0x13FF,
        0x17FF,
        0x37FF,
        0x3FFF,
        0x7FFF,
    },
};

//-----------------------------------------------------------------------------
// This table is used for a rough area approximation.  The [16] index
// is the top 4 bits of the edge distance (i.e. the distance from the
// edge to the center of the pixel).  The [4] index is the top two bits
// of the A gradient term.  The return is the number of bits that should
// be set in the coverage mask, which is a function of the area covered.
//-----------------------------------------------------------------------------
static INT16 nBitsA = 2;
static INT16 nBitsE = 4;
static INT16 nBitsToEnable[4][16] = {
    {   // A: 0.000; B: 1.000
         8,  9,  9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16,
    },
    {   // A: 0.125; B: 0.875
         8,  9,  9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 16,
    },
    {   // A: 0.250; B: 0.750
         8,  9,  9, 10, 11, 11, 12, 13, 13, 14, 15, 15, 15, 16, 16, 16,
    },
    {   // A: 0.375; B: 0.625
         8,  9, 10, 10, 11, 12, 13, 13, 14, 14, 15, 15, 15, 16, 16, 16,
    },
};

//-----------------------------------------------------------------------------
//
// Mask manipulation functions - these are needed because coverage mask
// table (indexed by angle) is for one octant only and need to be
// munged in various ways for other octants
//
//-----------------------------------------------------------------------------
static void
doCvgMaskTBFlip(UINT16 &CvgMask)
{
    UINT16 CvgMaskT = CvgMask;
    CvgMask = 0;
    CvgMask |= (((CvgMaskT >>  0) & 0x1) << 12);
    CvgMask |= (((CvgMaskT >>  1) & 0x1) << 13);
    CvgMask |= (((CvgMaskT >>  2) & 0x1) << 14);
    CvgMask |= (((CvgMaskT >>  3) & 0x1) << 15);
    CvgMask |= (((CvgMaskT >>  4) & 0x1) <<  8);
    CvgMask |= (((CvgMaskT >>  5) & 0x1) <<  9);
    CvgMask |= (((CvgMaskT >>  6) & 0x1) << 10);
    CvgMask |= (((CvgMaskT >>  7) & 0x1) << 11);
    CvgMask |= (((CvgMaskT >>  8) & 0x1) <<  4);
    CvgMask |= (((CvgMaskT >>  9) & 0x1) <<  5);
    CvgMask |= (((CvgMaskT >> 10) & 0x1) <<  6);
    CvgMask |= (((CvgMaskT >> 11) & 0x1) <<  7);
    CvgMask |= (((CvgMaskT >> 12) & 0x1) <<  0);
    CvgMask |= (((CvgMaskT >> 13) & 0x1) <<  1);
    CvgMask |= (((CvgMaskT >> 14) & 0x1) <<  2);
    CvgMask |= (((CvgMaskT >> 15) & 0x1) <<  3);
}
//-----------------------------------------------------------------------------
static void
doCvgMaskSFlip(UINT16 &CvgMask)
{
    UINT16 CvgMaskT = CvgMask;
    CvgMask = 0;
    CvgMask |= (((CvgMaskT >>  0) & 0x1) <<  0);
    CvgMask |= (((CvgMaskT >>  1) & 0x1) <<  4);
    CvgMask |= (((CvgMaskT >>  2) & 0x1) <<  8);
    CvgMask |= (((CvgMaskT >>  3) & 0x1) << 12);
    CvgMask |= (((CvgMaskT >>  4) & 0x1) <<  1);
    CvgMask |= (((CvgMaskT >>  5) & 0x1) <<  5);
    CvgMask |= (((CvgMaskT >>  6) & 0x1) <<  9);
    CvgMask |= (((CvgMaskT >>  7) & 0x1) << 13);
    CvgMask |= (((CvgMaskT >>  8) & 0x1) <<  2);
    CvgMask |= (((CvgMaskT >>  9) & 0x1) <<  6);
    CvgMask |= (((CvgMaskT >> 10) & 0x1) << 10);
    CvgMask |= (((CvgMaskT >> 11) & 0x1) << 14);
    CvgMask |= (((CvgMaskT >> 12) & 0x1) <<  3);
    CvgMask |= (((CvgMaskT >> 13) & 0x1) <<  7);
    CvgMask |= (((CvgMaskT >> 14) & 0x1) << 11);
    CvgMask |= (((CvgMaskT >> 15) & 0x1) << 15);
}

//-----------------------------------------------------------------------------
//
// ComputeCoverageMask - Computes the 16 bit coverage mask.  Called once per
// pixel per crossing edge (i.e. up to 3 times per pixel).
//
// This is doing the algorithm described in Schilling's Siggraph paper, with
// modifications to perform the operation for a single virtual octant and
// then munging the result for the actual octant.
//
// Note that the A and B signs for the edges must be computed very carefully
// to guarantee that shared edges will always result in full complimentary
// coverage of pixels on the shared edge.
//
//-----------------------------------------------------------------------------
RRCvgMask
ComputeCoverageMask(
    INT16 iABits,           // 1.8 value
    BOOL bAPos, BOOL bBPos,
    INT16 iEBits)           // 1.5.5 value, but ranges from -.5 to +.5 here
{
    RRCvgMask CvgMask;    // return value

    // grab already rounded 8 bit value and take absolute value
    UINT16 uMagA = (iABits < 0) ? ((UINT16)-iABits) : ((UINT16)iABits);
    UINT16 uABits = uMagA & 0x1ff;

    // compute booleans for manipulating masks
    BOOL bMaskInvert = TRUE;
    BOOL bMaskRFlip = !(bAPos ^ bBPos);
    if (!bAPos) {
        iEBits = -iEBits;
        bMaskInvert = FALSE;
    }

    //
    // compute A offset from x or y axis
    //
    // mirror around 45 degree axis - keep track of this because
    // the 45 degree mirroring requires a side-to-side mask flip
    BOOL bMaskSFlip = (uABits > 0x80);  // > 0.5F ?
    if (bMaskSFlip)  { uABits = 0x100 - uABits; }

    // uABits is now a 0.0.8 value in the range 0x00 to 0x80

    //
    // determine number of bits to enable in mask based on the area covered
    //
    // extract bits from A for area lookup
    UINT16 uAAreaBits = (uABits == 0x80)
        ? ((1<<nBitsA)-1) : (uABits >> (7-nBitsA));

    // grab distance bits for area lookup - take absolute value and clamp
    UINT16 uEBits = (iEBits < 0) ? ((UINT16)-iEBits) : ((UINT16)iEBits);
    uEBits = MIN(uEBits,(UINT16)(((1<<nBitsE)-1))); // clamp

    // look up area in table - returns number of bits to enable
    INT16 iNumCvgBits =  nBitsToEnable[uAAreaBits][uEBits];

    // flip for negative distance
    if (iEBits < 0) { iNumCvgBits = 16 - iNumCvgBits; }

    //
    // compute slope range index and look up coverage mask
    //
    INT16 iARange = 3;
    for (INT16 i=0; i<(A_RANGES-1); i++) {
        if ((uARanges[i] <= uABits) && (uABits < uARanges[i+1])) {
            iARange = i; break;
        }
    }

    // check for zero/full coverage else look up coverage mask
    if (0 == iNumCvgBits) {
        CvgMask = 0x0000;
    } else if (16 == iNumCvgBits) {
        CvgMask = 0xffff;
    } else {
        CvgMask = CvgMasks[iARange][iNumCvgBits-1];
    }

    //
    // adjust mask for different quadrants and directions
    //
    // first to side-to-side mask flip for 45 degree mirroring
    if (bMaskSFlip)  { doCvgMaskSFlip(CvgMask); }
    // invert for 'backwards' line directions
    if (bMaskInvert) { CvgMask ^= 0xffff; }
    // flip for same sign quadrants
    if (bMaskRFlip) { doCvgMaskTBFlip(CvgMask); }

    return CvgMask;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\fragproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// fragproc.cpp
//
// Direct3D Reference Rasterizer - Fragment Processing Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//
// Fragments are managed by a separate 'surface' of fragment pointers which
// form an (initially empty) linked list of fragment structures for each pixel.
//
// The fragment management consists of generating fragments for partially
// covered pixels (either due to coverage mask or non-opaque alpha), and
// freeing fragments which are obscurred by a fully covered pixel in
// front of them.
//
// The fragment generation occurs when a new pixel is partially covered.
// If the pixel location already has at least one fragment, then a fragment
// merge is attempted.  This merge is attempted with the fragment most recently
// added to the pixel (at the front of the linked list), which has the best
// chance of merging since it is most likely to be from the same object.
// The merge tests the Z and color values, and if they are within a threshold
// then the new fragmented pixel's contribution is OR'd into the existing
// fragment instead of generating a new fragment.  The depth merge criteria is
// an absolute value compare.  The color merge criteria is done with a bitmask
// (because ripping apart the color into channels for the value compare is too
// expensive).  Set bits in bitmask FRAGMERGE_COLORDIFF_MASK are bits for which
// the two colors must match.  This actually works pretty well...
//
// If the merge fails, then a new fragment is allocated, filled out, and added
// to the linked list for this pixel location.
//
// If the merge results in a fully covered pixel, then the fragment is freed
// and the fragment's color and depth are written to the color/depth buffers.
//

//
// controls for fragment merging
//

// TODO - not sure that merge works correctly right now...
//#define DO_FRAGMERGE

// mask for crude (but fast) color differencing - this is not so fast now
// that colors are stored as floats...
#define FRAGMERGE_COLORDIFF_MASK 0xe0c0e0c0

// depth difference must be less than this for merge to occur
FLOAT g_fFragMergeDepthThreshold = 1.F/(FLOAT)(1<<16);

//-----------------------------------------------------------------------------
//
// DoFragmentGenerationProcessing - Does initial work of generating a fragment
// buffer entry (if appropriate) and filling it out.  Also attempts fragment
// merge.
//
// Returns TRUE if processing for this pixel is complete.
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DoFragmentGenerationProcessing( RRPixel& Pixel )
{
    // TRUE if pixel is geometrically partially covered
    BOOL bDoFragCvg = ( TL_CVGFULL != Pixel.CvgMask );
    // TRUE if pixel is partially covered due to transparency
    BOOL bDoFragTransp = FALSE;
    if ( m_dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] )
    {
        // only generate fragments for transparency if
        // D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT is enabled and the
        // alpha is less than the threshold
        bDoFragTransp = ( UINT8(Pixel.Color.A) < g_uTransparencyAlphaThreshold );
    }
    else
    {
        // so we won't use alpha for determining transparency in fragment resolve
        Pixel.Color.A = 1.0F;
    }

    // get pointer to fragment list for this pixel location - may be NULL due to
    // deferred allocation of fragment buffer
    RRFRAGMENT** ppFrag = (NULL == m_ppFragBuf) ? (NULL)
        : (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);

    if ( bDoFragCvg || bDoFragTransp )
    {
        // get pointer to pointer to first fragment in linked list for this pixel
        if (NULL == m_ppFragBuf)
        {
            // do (deferred) allocation of fragment pointer buffer - clear this
            // initially and it will always be cleared during the fragment resolve process
            size_t cbBuf = sizeof(RRFRAGMENT*)*m_pRenderTarget->m_iWidth*m_pRenderTarget->m_iHeight;
            // allocate fragment pointer buffer for rendering core - clear initially
            m_ppFragBuf = (RRFRAGMENT**)MEMALLOC( cbBuf );
            _ASSERTa( NULL != m_ppFragBuf, "malloc failure on RRFRAGMENT pointer buffer",
                return FALSE; );
            memset( m_ppFragBuf, 0x0, cbBuf );
            // ppFrag only not set if (NULL == m_ppFragBuf)
            ppFrag = (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);
        }


#ifdef  DO_FRAGMERGE
        // try to do fragment merge
        if ( NULL != (*ppFrag) )
        {
            // check if new depth is close enough to depth of first frag in list
            FLOAT fDepthDiff = fabs( FLOAT((*ppFrag)->Depth) - FLOAT(Pixel.Depth) );
            BOOL bDepthClose = ( fDepthDiff < g_fFragMergeDepthThreshold );

            // check if new color is close enough to color of first frag in list
            UINT32 uARGBSame = ~( UINT32(Pixel.Color) ^ UINT32((*ppFrag)->Color) );
            BOOL bColorClose = ( FRAGMERGE_COLORDIFF_MASK == ( uARGBSame & FRAGMERGE_COLORDIFF_MASK ) );

            if ( bDepthClose && bColorClose )
            {
                m_pStt->cFragsMerged++;

                // here to do merge
                CVGMASK FirstFragCvgMask =  (*ppFrag)->CvgMask;
                CVGMASK MergedCvgMask = FirstFragCvgMask | Pixel.CvgMask;

                // check for merge to full coverage
                if ( ( TL_CVGFULL == MergedCvgMask ) && !bDoFragTransp )
                {
                    m_pStt->cFragsMergedToFull++;
                    // free first fragment
                    RRFRAGMENT* pFragFree = (*ppFrag);    // keep ptr to frag to free
                    (*ppFrag) = (RRFRAGMENT*)(*ppFrag)->pNext;  // set buffer to point to next
                    FragFree( pFragFree);

                    // now need to write this pixel into pixel buffer, so return
                    // FALSE so pixel processing will continue
                    return FALSE;
                }
                else
                {
                    // mask not full, so update first frag's cm and done
                    (*ppFrag)->CvgMask = MergedCvgMask;
                    // done with this pixel
                    return TRUE;
                }
            }
            // else fall into allocating new frag
        }
#endif
        // allocate and fill fragment
        RRFRAGMENT* pFragNew = FragAlloc();
        if ( NULL == pFragNew ) { return FALSE; }
        pFragNew->Color = Pixel.Color;
        pFragNew->Depth = Pixel.Depth;
        pFragNew->CvgMask = Pixel.CvgMask;
        // insert at front of list (before fragment we're looking at)
        pFragNew->pNext = (void*)(*ppFrag);
        (*ppFrag) = pFragNew;

        // done with this pixel
        return TRUE;
    }

    // not done with this pixel
    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DoFragmentBufferFixup - Routine to free fragments which are behind
// fully covered sample just written into the pixel buffer.  This minimizes
// the total number of fragment needed for a scene.  This step involves walking
// the linked list and freeing fragments behind the pixel about to be written.
// This also simplifies the fragment resolve since the Z buffer is not needed
// (all fragments are known to be in front of the fully-covered sample in the
// color/Z buffer).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoFragmentBufferFixup( const RRPixel& Pixel )
{
    // get pointer to fragment list for this pixel location - may be NULL due to
    // deferred allocation of fragment buffer
    RRFRAGMENT** ppFrag = (NULL == m_ppFragBuf)
        ? (NULL)
        : (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);

    //
    // walk fragment array to free fragments behind covered sample
    //
    if ( NULL != ppFrag )
    {
        while ( NULL != (*ppFrag) )
        {
            if ( DepthCloser( Pixel.Depth, (*ppFrag)->Depth ) )
            {
                // covered sample is closer than fragment, so free the frag
                RRFRAGMENT* pFragFree = (*ppFrag);    // keep ptr to frag to free
                (*ppFrag) = (RRFRAGMENT*)(*ppFrag)->pNext;   // remove from list
                // ppFrag now points to a pointer to the next frag
                FragFree( pFragFree );
            }
            else
            {
                // advance pointer to point to pointer to next frag
                ppFrag = (RRFRAGMENT **)&((*ppFrag)->pNext);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Fragment Allocation Methods                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// These methods are used by the pixel engine and fragment resolver to
// allocate and free fragments.
//

//-----------------------------------------------------------------------------
//
// Allocates a single fragment record, returning pointer
//
//-----------------------------------------------------------------------------
RRFRAGMENT*
ReferenceRasterizer::FragAlloc( void )
{
    RRFRAGMENT* pFrag = (RRFRAGMENT*)MEMALLOC( sizeof(RRFRAGMENT) );
    _ASSERTa( NULL != pFrag, "malloc failed on RRFRAGMENT", return NULL; );

    // update stats
    m_pStt->cFragsAllocd++;
    if (m_pStt->cFragsAllocd > m_pStt->cMaxFragsAllocd ) { m_pStt->cMaxFragsAllocd = m_pStt->cFragsAllocd; }

    return pFrag;
}

//-----------------------------------------------------------------------------
//
// Frees a single fragment record
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::FragFree( RRFRAGMENT* pFrag )
{
    MEMFREE( pFrag );

    // update stats
    m_pStt->cFragsAllocd--;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\edgefunc.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// EdgeFunc.hpp
//
// Direct3D Reference Rasterizer - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _EDGEFUNC_HPP
#define _EDGEFUNC_HPP

//-----------------------------------------------------------------------------
//
// Utility to compute determinant - must be computed in manner consistent with
// other edge function processing.
//
//-----------------------------------------------------------------------------
FLOAT
ComputeDeterminant(
    FLOAT fX0, FLOAT fY0,
    FLOAT fX1, FLOAT fY1,
    FLOAT fX2, FLOAT fY2 );

//-----------------------------------------------------------------------------
//
// Primitive edge function - Computes, stores, and evaluates linear function
// for edges.  Basic function is stored in fixed point.  Gradient sign terms
// are computed and stored separately to adhere to fill rules.
//
//-----------------------------------------------------------------------------
class RREdgeFunc
{
private:
    INT32   m_iA;       // n.4 fixed point
    INT32   m_iB;       // n.4 fixed point
    INT64   m_iC;       // n.8 fixed point
    BOOL    m_bAPos;    // carefully computed signs of A,B
    BOOL    m_bBPos;

public:
// DEFINE
    void Set(
        FLOAT fX0, FLOAT fY0, FLOAT fX1, FLOAT fY1,
        FLOAT fDet, BOOL bFragProcEnable );

// Point Sampling Test
// returns 0000=outside,  FFFF=inside
    RRCvgMask PSTest( INT16 iX, INT16 iY );

// Anti Alias test
// returns coverage mask (0000=outside, FFFF=completely inside, partial otherwise)
    RRCvgMask AATest( INT16 iX, INT16 iY );
};

//////////////////////////////////////////////////////////////////////////////
#endif  // _EDGEFUNC_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\maplegcy.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// MapLegcy.cpp
//
// Direct3D Reference Rasterizer - Mapping Legacy Modes to Current Functionality
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter - Map filter state from renderstate to per-stage state.
// This is invoked when a texture is bound via the TEXTUREHANDLE renderstate,
// indicating that we are in 'legacy' texture mode.  The rasterizer always
// refers to per-stage filtering control state, so in legacy mode the filtering
// controls in the renderstate are mapped into the filtering controls associated
// with the texture object bound to D3DRS_TEXTUREHANDLE.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapLegacyTextureFilter( void )
{
    // first check if anisotropic filtering is enabled (indicated by the
    // limit value being set to > 1) - if so then aniso filter will be used
    // for linear mag filter or 'linear within map' min filter
    BOOL bAnisoEnabled = ( m_dwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1 );

    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] =
            bAnisoEnabled ? D3DTFG_ANISOTROPIC : D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    }
}


//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_TextureStageState[1].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        // a special legacy alpha operation is called for that depends
        // on the format of the texture
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_LEGACY_ALPHAOVR;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include <ddraw.h>
#include <ddrawi.h>

#include <d3d.h>
#include <d3dhal.h>
#include "halprov.h"
#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include "refrast.hpp"      // public interfaces

#include "EdgeFunc.hpp"     // edge function processing
#include "AttrFunc.hpp"     // attribute function processing
#include "refrasti.hpp"     // private interfaces
#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\edgefunc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// EdgeFunc.cpp
//
// Direct3D Reference Rasterizer - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// ComputeDeterminant - Computes triangle determinant for later use in edge
// functions.  Computed in fixed point but returned as single precision
// floating point number.
//
//-----------------------------------------------------------------------------
FLOAT
ComputeDeterminant(
    FLOAT fX0, FLOAT fY0,
    FLOAT fX1, FLOAT fY1,
    FLOAT fX2, FLOAT fY2 )
{
    // compute determinant with integer coordinates snapped to n.4 grid
    INT32 iDelX10 =
        AS_INT32( (DOUBLE)(fX1) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fX0) + DOUBLE_4_SNAP );
    INT32 iDelX02 =
        AS_INT32( (DOUBLE)(fX0) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fX2) + DOUBLE_4_SNAP );
    INT32 iDelY01 =
        AS_INT32( (DOUBLE)(fY0) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fY1) + DOUBLE_4_SNAP );
    INT32 iDelY20 =
        AS_INT32( (DOUBLE)(fY2) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fY0) + DOUBLE_4_SNAP );

    // iDet is n.8 fixed point value (n.4 * n.4 = n.8)
    INT64 iDet =
        ( (INT64)iDelX10 * (INT64)iDelY20 ) -
        ( (INT64)iDelX02 * (INT64)iDelY01 );

    // convert to float for return
    FLOAT fDet = (1./(FLOAT)(1<<8)) * (FLOAT)iDet;

    return fDet;
}

//-----------------------------------------------------------------------------
//
// Set - Computes edge function and associated information.
//
// Fragment processing boolean is passed to enable use of better techniques
// than the simple but not particularly good subpixel point sample done here.
//
//-----------------------------------------------------------------------------
void
RREdgeFunc::Set(
    FLOAT fX0, FLOAT fY0, FLOAT fX1, FLOAT fY1,
    FLOAT fDet, BOOL bFragProcEnable )
{
    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    INT32 iX0 = AS_INT32( (DOUBLE)fX0 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)fY0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)fX1 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)fY1 + DOUBLE_4_SNAP );

    // compute A,B (gradient) terms - these are n.4 fixed point
    m_iA = iY0 - iY1;
    m_iB = iX1 - iX0;

    // flip gradient signs if backfacing so functions are consistently
    // greater than zero outside of primitive
    if ( fDet > 0. ) { m_iA = -m_iA; m_iB = -m_iB; }

    // compute C term
    //
    // function is by definition zero at the vertices, so:
    //     0 = A*Xv + B*Yv + C  =>  C = - A*Xv - B*Yv
    //
    // A*Xv & B*Yv are n.4 * n.4 = n.8, so C is n.8 fixed point
    m_iC = - ( (INT64)iX0 * (INT64)m_iA ) - ( (INT64)iY0 * (INT64)m_iB );

    // compute edge function sign flags - must be done consistently for vertical
    // and horizontal cases to adhere to point sample fill rules and avoid
    // under- and over-coverage for antialiasing
    BOOL bEdgeAEQZero = ( m_iA == 0. );
    BOOL bEdgeBEQZero = ( m_iB == 0. );
    BOOL bEdgeAGTZero = ( m_iA > 0. );
    BOOL bEdgeBGTZero = ( m_iB > 0. );
    m_bAPos = bEdgeAEQZero ? bEdgeBGTZero : bEdgeAGTZero;
    m_bBPos = bEdgeBEQZero ? bEdgeAGTZero : bEdgeBGTZero;
}

//-----------------------------------------------------------------------------
//
// PSTest - Point sampling test, returns coverage mask of all zero's if point
// is outside the edge, all 1's if point is inside.  Supports the Direct3D
// left-top fill rule.
//
//-----------------------------------------------------------------------------
RRCvgMask
RREdgeFunc::PSTest( INT16 iX, INT16 iY )
{
    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)(iX<<4) ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)(iY<<4) ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                        // n.8

    // pixel sample position is outside edge if distance is > zero
    //
    // This implements the D3D left-top fill rule
    //
    // For exactly-on-edge case (distance == zero), the sign of the Y gradient
    // is used to determine if the pixel is to be considered inside or outside
    // of the edge. For the non-horizontal case, the m_bAPos bit is based
    // simply on the sign of the Y slope.  This implements the 'left' part of
    // the 'left-top' rule.
    //
    // For the horizontal case,  the sign of the B gradient (X slope) is taken
    // into account in the computation of the m_bAPos bit when the A gradient
    // is exactly zero, which forces a pixel exactly on a 'top' edge to be
    // considered in and a pixel exactly on a 'bottom' edge to be considered out.
    //
    if ( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) )
    {
        // pixel is out
        return 0x0000;
    }
    // pixel is in
    return 0xFFFF;
}

//-----------------------------------------------------------------------------
//
// AATest - Anti alias edge test, returns coverage mask of all zero's if point
// is outside the edge, all 1's if point is inside, and partial if point is on
// or near the edge.
//
//-----------------------------------------------------------------------------
RRCvgMask
RREdgeFunc::AATest( INT16 iX, INT16 iY )
{
    RRCvgMask Mask = 0;

    // n.4 integer representation of pixel center
    INT64 iX64Center = (INT64)(iX<<4);
    INT64 iY64Center = (INT64)(iY<<4);

    // step across 4x4 subpixel sample points and point sample 16 locations
    // to form coverage mask; area is split into eights to center samples
    // around pixel center (for example, the two inner sample positions are
    // each 1/8 of a pixel distance from the pixel center, and thus 1/4 of
    // a pixel distance apart)
    INT32 iYSub, iYEightths, iXSub, iXEightths;
    for (iYSub = 0, iYEightths = -3; iYSub < 4; iYSub++, iYEightths += 2)
    {
        for (iXSub = 0, iXEightths = -3; iXSub < 4; iXSub++, iXEightths += 2)
        {
            // compute sample location, which is some n/8 offset from the
            // pixel center (+/- 3/8 or 1/8)
            INT64 iX64 = iX64Center + (iXEightths<<1);
            INT64 iY64 = iY64Center + (iYEightths<<1);
            INT64 iEdgeDist =
                ( (INT64)m_iA * iX64 ) +    // n.4 * n.4 = n.8
                ( (INT64)m_iB * iY64 ) +    // n.4 * n.4 = n.8
                (INT64)m_iC;                // n.8

            // if the center is in (same left-top rule as in point sample)
            if (!( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) ))
            {
                // pixel is in
                Mask |= 1 << (iXSub + iYSub*4);
            }
        }
    }

    return Mask;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\pixproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pixproc.cpp
//
// Direct3D Reference Rasterizer - Pixel Processor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// DoPixel - Invoked for each pixel by the scan converter, applies texture,
// specular, fog, alpha blend, and writes result to surface.  Also implements
// depth, alpha, and stencil tests.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoPixel( RRPixel& Pixel )
{

    // apply texture (includes lookup&filter and blending)
    if ( m_cActiveTextureStages > 0 )
    {
        RRColor TexturedColor = Pixel.Color;
        DoTexture( Pixel, TexturedColor );
        Pixel.Color = TexturedColor;

        // check colorkey
        for (INT32 i = 0; i < m_cActiveTextureStages; i++)
        {
            if ( NULL != m_pTexture[i] )
            {
                // kill pixel if colorkey killing and any samples matched
                if ( m_pTexture[i]->m_bDoColorKeyKill &&
                     m_pTexture[i]->m_bColorKeyMatched )
                {
                    return;
                }
            }
        }
    }


    // do alpha test - bail out if failed
    if ( m_dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] &&
         !AlphaTest( Pixel.Color.A ) )
    {
        return;
    }

    // add specular and saturate
    if ( m_dwRenderState[D3DRENDERSTATE_SPECULARENABLE] )
    {
        Pixel.Color.R += Pixel.Specular.R;
        Pixel.Color.G += Pixel.Specular.G;
        Pixel.Color.B += Pixel.Specular.B;
        Pixel.Color.R = minimum( 1.f, Pixel.Color.R );
        Pixel.Color.G = minimum( 1.f, Pixel.Color.G );
        Pixel.Color.B = minimum( 1.f, Pixel.Color.B );
    }

    // apply fog
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] )
    {
        // get RRColor version of fog color
        RRColor FogColor = m_dwRenderState[D3DRENDERSTATE_FOGCOLOR];

        // do fog blend
        // (TODO: account for pre-multiplied alpha here??)
        RRColorComp ObjColorFrac = Pixel.FogIntensity;  // f
        RRColorComp FogColorFrac = ~Pixel.FogIntensity; // 1. - f
        Pixel.Color.R = (ObjColorFrac * Pixel.Color.R) + (FogColorFrac * FogColor.R);
        Pixel.Color.G = (ObjColorFrac * Pixel.Color.G) + (FogColorFrac * FogColor.G);
        Pixel.Color.B = (ObjColorFrac * Pixel.Color.B) + (FogColorFrac * FogColor.B);

        // NOTE: this can be done with a single (signed) multiply as
        //   (f)*Cp + (1-f)*Cf = f*(Cp-Cf) + Cf
    }

    //
    // read current depth for this pixel and do depth test - cannot
    // bail out if failed because stencil may need to be updated
    //
    RRDepth BufferDepth(Pixel.Depth.GetSType());
    BOOL bDepthTestPassed = TRUE;
    if ( m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
    {
        m_pRenderTarget->ReadPixelDepth( Pixel.iX, Pixel.iY, BufferDepth );
        bDepthTestPassed = DepthCloser( Pixel.Depth, BufferDepth );
    }

    //
    // do stencil operation
    //
    BOOL bStencilTestPassed = TRUE;
    if ( m_dwRenderState[D3DRENDERSTATE_STENCILENABLE] )
    {
        // read stencil buffer and do stencil operation
        UINT8 uStncBuf = 0x0;
        m_pRenderTarget->ReadPixelStencil( Pixel.iX, Pixel.iY, uStncBuf );
        UINT8 uStncNew;
        bStencilTestPassed = DoStencil( uStncBuf, bDepthTestPassed, Pixel.Depth.GetSType(), uStncNew );

        // update stencil only if changed
        if ( uStncNew != uStncBuf )
        {
            // compute new buffer value based on write mask
            UINT8 uStncWMask = m_dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK];
            UINT8 uStncBufNew = (uStncBuf & ~uStncWMask) | (uStncNew & uStncWMask);
            m_pRenderTarget->WritePixelStencil( Pixel.iX, Pixel.iY, uStncBufNew );
        }
    }

    if ( !(bDepthTestPassed && bStencilTestPassed) )
    {
        return;
    }

    //
    // do fragment generation processing - this is done prior to alpha blend
    // somewhat arbitrarily because fragment generation and incremental alpha
    // blending are mutually exclusive (blending of fragments requires multipass
    // and fragment matching to get the correct result - fragment matching is
    // not implemented here yet)  (TODO: fragment matching)
    //
    // this may or may not complete the processing of this pixel
    //
    if ( m_bFragmentProcessingEnabled )
    {
        if ( DoFragmentGenerationProcessing( Pixel ) ) { return; }
    }

    //
    // do alpha blend
    //
    if ( m_dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] )
    {
        RRColor BufferColor;
        m_pRenderTarget->ReadPixelColor( Pixel.iX, Pixel.iY, BufferColor );
        DoAlphaBlend( Pixel.Color, BufferColor, Pixel.Color );
    }

    //
    // update color and depth buffers
    //
    WritePixel( Pixel.iX, Pixel.iY, Pixel.Color, Pixel.Depth );

    // additional fragment processing associated with buffer write
    if ( m_bFragmentProcessingEnabled ) { DoFragmentBufferFixup( Pixel ); }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Processing Utility Functions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Depth compare method used for Z buffering and fragment processing.
//
// Returns TRUE if DepthVal is closer than DepthBuf.  DepthA is the generated
// value and DepthB
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DepthCloser(
    const RRDepth& DepthVal,
    const RRDepth& DepthBuf )
{
    if ( !m_dwRenderState[D3DRENDERSTATE_ZENABLE] ) { return TRUE; }


    switch ( m_dwRenderState[D3DRENDERSTATE_ZFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return ( DOUBLE(DepthVal) <  DOUBLE(DepthBuf) );
    case D3DCMP_EQUAL:        return ( DOUBLE(DepthVal) == DOUBLE(DepthBuf) );
    case D3DCMP_LESSEQUAL:    return ( DOUBLE(DepthVal) <= DOUBLE(DepthBuf) );
    case D3DCMP_GREATER:      return ( DOUBLE(DepthVal) >  DOUBLE(DepthBuf) );
    case D3DCMP_NOTEQUAL:     return ( DOUBLE(DepthVal) != DOUBLE(DepthBuf) );
    case D3DCMP_GREATEREQUAL: return ( DOUBLE(DepthVal) >= DOUBLE(DepthBuf) );
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// Alpha test method for pixel processing.
//
// Returns TRUE if alpha test passes.
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::AlphaTest( const RRColorComp& Alpha )
{
    // grab 8 bit unsigned alpha value
    UINT8 uAlpha = UINT8( Alpha );

    // form 8 bit alpha reference value
    UINT8 uAlphaRef8 = m_dwRenderState[D3DRENDERSTATE_ALPHAREF];

    // do alpha test and either return directly or pass through
    switch ( m_dwRenderState[D3DRENDERSTATE_ALPHAFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return (uAlpha <  uAlphaRef8);
    case D3DCMP_EQUAL:        return (uAlpha == uAlphaRef8);
    case D3DCMP_LESSEQUAL:    return (uAlpha <= uAlphaRef8);
    case D3DCMP_GREATER:      return (uAlpha >  uAlphaRef8);
    case D3DCMP_NOTEQUAL:     return (uAlpha != uAlphaRef8);
    case D3DCMP_GREATEREQUAL: return (uAlpha >= uAlphaRef8);
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoStencil - Performs stencil test.  Returns TRUE if stencil test passed.
// Also computes stencil result value (to be written back to stencil planes
// if test passes, subject to stencil write mask).
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DoStencil(
    UINT8 uStncBuf,     // in: stencil buffer value
    BOOL bDepthTest,    // in: boolean result of depth test
    RRSurfaceType DepthSType,   // in: surface type of Z buffer
    UINT8& uStncRet)    // out: stencil value result
{
    // support 8 bit stencil only, so do everything as UINT8's

    // get reference from renderstate
    UINT8 uStncRef = (UINT8)(m_dwRenderState[D3DRENDERSTATE_STENCILREF]);

    // form masked values for test
    UINT8 uStncMask = (UINT8)(m_dwRenderState[D3DRENDERSTATE_STENCILMASK]);
    UINT8 uStncBufM = uStncBuf & uStncMask;
    UINT8 uStncRefM = uStncRef & uStncMask;
    // max value for saturation ops
    UINT8 uStncMax;
    switch(DepthSType)
    {
    case RR_STYPE_Z24S8:
    case RR_STYPE_S8Z24: uStncMax = 0xff; break;
    case RR_STYPE_Z15S1:
    case RR_STYPE_S1Z15: uStncMax = 0x1;  break;
    case RR_STYPE_Z24S4:
    case RR_STYPE_S4Z24: uStncMax = 0xf;  break;
    default:             uStncMax = 0;    break;  // don't let stencil become non 0
    }

    // do stencil compare function
    BOOL bStncTest = FALSE;
    switch ( m_dwRenderState[D3DRENDERSTATE_STENCILFUNC] )
    {
    case D3DCMP_NEVER:        bStncTest = FALSE; break;
    case D3DCMP_LESS:         bStncTest = (uStncRefM <  uStncBufM); break;
    case D3DCMP_EQUAL:        bStncTest = (uStncRefM == uStncBufM); break;
    case D3DCMP_LESSEQUAL:    bStncTest = (uStncRefM <= uStncBufM); break;
    case D3DCMP_GREATER:      bStncTest = (uStncRefM >  uStncBufM); break;
    case D3DCMP_NOTEQUAL:     bStncTest = (uStncRefM != uStncBufM); break;
    case D3DCMP_GREATEREQUAL: bStncTest = (uStncRefM >= uStncBufM); break;
    case D3DCMP_ALWAYS:       bStncTest = TRUE; break;
    }

    // determine which stencil operation to perform
    DWORD dwStencilOp;
    if ( !bStncTest )
    {
        // stencil test failed - depth test does not matter
        dwStencilOp = m_dwRenderState[D3DRENDERSTATE_STENCILFAIL];
    }
    else
    {
        // stencil test passed - select based on depth pass/fail
        dwStencilOp = ( !bDepthTest )
            ? ( m_dwRenderState[D3DRENDERSTATE_STENCILZFAIL] )
            : ( m_dwRenderState[D3DRENDERSTATE_STENCILPASS] );
    }

    uStncRet = 0x0;
    switch ( dwStencilOp )
    {
    case D3DSTENCILOP_KEEP:    uStncRet = uStncBuf; break;
    case D3DSTENCILOP_ZERO:    uStncRet = 0x00; break;
    case D3DSTENCILOP_REPLACE: uStncRet = uStncRef; break;
    case D3DSTENCILOP_INCRSAT:
        uStncRet = (uStncBuf==uStncMax)?(uStncMax):(uStncBuf+1); break;
    case D3DSTENCILOP_DECRSAT:
        uStncRet = (uStncBuf==0x00)?(0x00):(uStncBuf-1); break;
    case D3DSTENCILOP_INVERT:  uStncRet = ~uStncBuf; break;
    case D3DSTENCILOP_INCR:    uStncRet = uStncBuf+1; break;
    case D3DSTENCILOP_DECR:    uStncRet = uStncBuf-1; break;
    }

    return bStncTest;
}

//-----------------------------------------------------------------------------
//
// DoAlphaBlend - Performs color blending of source and destination colors
// producing a result color.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoAlphaBlend(
    const RRColor& SrcColor,    // in: source pixel color
    const RRColor& DstColor,    // in: destination (buffer) color
    RRColor& ResColor)          // out: result (blended) color
{
    RRColor SrcColorFactor;
    RRColor DstColorFactor;
    BOOL bDestBlendOverride = FALSE;

    // compute source blend factors
    switch ( m_dwRenderState[D3DRENDERSTATE_SRCBLEND] )
    {

    default:
    case D3DBLEND_ZERO:
        SrcColorFactor.SetAllChannels( 0.F );
        break;

    case D3DBLEND_ONE:
        SrcColorFactor.SetAllChannels( 1.F );
        break;

    case D3DBLEND_SRCCOLOR:
        SrcColorFactor.R = SrcColor.R;
        SrcColorFactor.G = SrcColor.G;
        SrcColorFactor.B = SrcColor.B;
        SrcColorFactor.A = SrcColor.A;
        break;

    case D3DBLEND_INVSRCCOLOR:
        SrcColorFactor.R = ~SrcColor.R;
        SrcColorFactor.G = ~SrcColor.G;
        SrcColorFactor.B = ~SrcColor.B;
        SrcColorFactor.A = ~SrcColor.A;
        break;

    case D3DBLEND_SRCALPHA:
        SrcColorFactor.SetAllChannels( SrcColor.A );
        break;

    case D3DBLEND_INVSRCALPHA:
        SrcColorFactor.SetAllChannels( ~SrcColor.A );
        break;

    case D3DBLEND_DESTALPHA:
        SrcColorFactor.SetAllChannels( DstColor.A );
        break;

    case D3DBLEND_INVDESTALPHA:
        SrcColorFactor.SetAllChannels( ~DstColor.A );
        break;

    case D3DBLEND_DESTCOLOR:
        SrcColorFactor.R = DstColor.R;
        SrcColorFactor.G = DstColor.G;
        SrcColorFactor.B = DstColor.B;
        SrcColorFactor.A = DstColor.A;
        break;

    case D3DBLEND_INVDESTCOLOR:
        SrcColorFactor.R = ~DstColor.R;
        SrcColorFactor.G = ~DstColor.G;
        SrcColorFactor.B = ~DstColor.B;
        SrcColorFactor.A = ~DstColor.A;
        break;

    case D3DBLEND_SRCALPHASAT:
        {
            RRColorComp F = minimum( SrcColor.A, ~DstColor.A );
            SrcColorFactor.R = F;
            SrcColorFactor.G = F;
            SrcColorFactor.B = F;
        }
        SrcColorFactor.A = 1.F;
        break;

    // these are for SRCBLEND only and override DESTBLEND
    case D3DBLEND_BOTHSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( SrcColor.A );
        DstColorFactor.SetAllChannels( ~SrcColor.A );
        break;

    case D3DBLEND_BOTHINVSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( ~SrcColor.A );
        DstColorFactor.SetAllChannels( SrcColor.A );
        break;
    }

    // compute destination blend factors
    if ( !bDestBlendOverride )
    {
        switch ( m_dwRenderState[D3DRENDERSTATE_DESTBLEND] )
        {

        default:
        case D3DBLEND_ZERO:
            DstColorFactor.SetAllChannels( 0.F );
            break;

        case D3DBLEND_ONE:
            DstColorFactor.SetAllChannels( 1.F );
            break;

        case D3DBLEND_SRCCOLOR:
            DstColorFactor.R = SrcColor.R;
            DstColorFactor.G = SrcColor.G;
            DstColorFactor.B = SrcColor.B;
            DstColorFactor.A = SrcColor.A;
            break;

        case D3DBLEND_INVSRCCOLOR:
            DstColorFactor.R = ~SrcColor.R;
            DstColorFactor.G = ~SrcColor.G;
            DstColorFactor.B = ~SrcColor.B;
            DstColorFactor.A = ~SrcColor.A;
            break;

        case D3DBLEND_SRCALPHA:
            DstColorFactor.SetAllChannels( SrcColor.A );
            break;

        case D3DBLEND_INVSRCALPHA:
            DstColorFactor.SetAllChannels( ~SrcColor.A );
            break;

        case D3DBLEND_DESTALPHA:
            DstColorFactor.SetAllChannels( DstColor.A );
            break;

        case D3DBLEND_INVDESTALPHA:
            DstColorFactor.SetAllChannels( ~DstColor.A );
            break;

        case D3DBLEND_DESTCOLOR:
            DstColorFactor.R = DstColor.R;
            DstColorFactor.G = DstColor.G;
            DstColorFactor.B = DstColor.B;
            DstColorFactor.A = DstColor.A;
            break;

        case D3DBLEND_INVDESTCOLOR:
            DstColorFactor.R = ~DstColor.R;
            DstColorFactor.G = ~DstColor.G;
            DstColorFactor.B = ~DstColor.B;
            DstColorFactor.A = ~DstColor.A;
            break;

        case D3DBLEND_SRCALPHASAT:
            {
                RRColorComp F = minimum( SrcColor.A, ~DstColor.A );
                DstColorFactor.R = F;
                DstColorFactor.G = F;
                DstColorFactor.B = F;
            }
            DstColorFactor.A = 1.F;
            break;
        }
    }

    // apply blend factors to update pixel color
    ResColor.R = (SrcColorFactor.R * SrcColor.R) + (DstColorFactor.R * DstColor.R);
    ResColor.G = (SrcColorFactor.G * SrcColor.G) + (DstColorFactor.G * DstColor.G);
    ResColor.B = (SrcColorFactor.B * SrcColor.B) + (DstColorFactor.B * DstColor.B);
    ResColor.A = (SrcColorFactor.A * SrcColor.A) + (DstColorFactor.A * DstColor.A);

    // clamp result
    ResColor.R = minimum( 1.f, maximum( 0.f, ResColor.R ) );
    ResColor.G = minimum( 1.f, maximum( 0.f, ResColor.G ) );
    ResColor.B = minimum( 1.f, maximum( 0.f, ResColor.B ) );
    ResColor.A = minimum( 1.f, maximum( 0.f, ResColor.A ) );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\fragrslv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// fragrslv.cpp
//
// Direct3D Reference Rasterizer - Fragment Resolve Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// fragment resolution controls - need to expose these somehow (maybe...)
static BOOL g_bPreMultAlpha = TRUE;
static BOOL g_bDoCoverageOnly = FALSE;

//-----------------------------------------------------------------------------
//
// CountFrags - Utility to count fragments in a linked list.
//
//-----------------------------------------------------------------------------
int
CountFrags(RRFRAGMENT* pFrag)
{
    if (g_iDPFLevel < 4) { return 0; }
    int iRet = 0;
    while ( NULL != pFrag ) { pFrag = (RRFRAGMENT* )pFrag->pNext; iRet++; }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// DPFFrags - Utility to debug-print fragment list.
//
//-----------------------------------------------------------------------------
void
DPFFrags(RRFRAGMENT* pFrag)
{
    if (g_iDPFLevel < 7) { return; }
    while (NULL != pFrag)
    {
        DPFM(7,FRAG,("    (%06x,%06x) %08x %f %04x\n",
            pFrag,pFrag->pNext,UINT32(pFrag->Color),FLOAT(pFrag->Depth),pFrag->CvgMask))
        pFrag = (RRFRAGMENT *)pFrag->pNext;
    }
}

//-----------------------------------------------------------------------------
//
// DoFragResolve - Invoked during the buffer-resolve for each pixel which
// has fragments.  Takes a pointer to a linked list of fragments and returns
// the resolved color.
//
// This constists of two steps: fragment sorting; and fragment resolve
// accumulation.  The fragments are sorted by stepping through the original
// linked list and moving the fragments into a new linked list (using the
// same link pointers) which is sorted in Z.
//
// The fragment resolve occurs in one of two ways depending on if any non-opaque
// fragments exist in the list (this is determined during the sort).  If there
// are only opaque fragments, then the resolve accumulation depends only on
// the coverage masks and is thus simplified.  For cases with fragments due
// to transparency, and more complex (and slower) resolve accumulation is
// performed.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoFragResolve(
    RRColor& ResolvedColor,         // out: final color for pixel
    RRDepth& ResolvedDepth,         // out: final depth for pixel
    RRFRAGMENT* pFrag,              // in: pointer to frag list for pixel
    const RRColor& CoveredColor )   // out: color of frontmost fully covered sample
{
    DPFM(7,FRAG,("    presort\n"))  DPFFrags(pFrag);
    //
    // reform fragments into sorted (front-to-back) linked list
    //
    // put first fragment into sortlist
    RRFRAGMENT* pFragSort = pFrag;
    pFrag = (RRFRAGMENT *)pFrag->pNext;
    pFragSort->pNext = NULL;
    // track if any non-opaque alphas (used to select resolve routine)
    //     init value by checking the first one (already in sort list)
    BOOL bAnyNonOpaque = ( UINT8(pFragSort->Color.A) < 0xff );
    // step thru fragment list and move each fragment into sort list
    while ( NULL != pFrag )
    {
        // check for non-opaque alpha
        if ( UINT8(pFrag->Color.A) < 0xff ) { bAnyNonOpaque = TRUE; }

        // get ptr to next here so it can be overwritten
        RRFRAGMENT* pFragNext = (RRFRAGMENT *)pFrag->pNext;

        // use this to step thru sort list and insert
        RRFRAGMENT **ppFragSortT = &pFragSort;
        while ( NULL != *ppFragSortT )
        {
            if ( DepthCloser( pFrag->Depth, (*ppFragSortT)->Depth ) )
            {
                // current frag is closer than sort list entry, so
                // before this sort entry
                pFrag->pNext = *ppFragSortT;
                *ppFragSortT = pFrag;
                break;
            }
            else if ( NULL == (*ppFragSortT)->pNext )
            {
                // if last, then insert after this sort list entry
                (*ppFragSortT)->pNext = pFrag;
                pFrag->pNext = NULL;
                break;
            }
            ppFragSortT = (RRFRAGMENT **)&((*ppFragSortT)->pNext);
        }
        // advance input frag list
        pFrag = pFragNext;
    }
    // all fragments have now been passed to sort list in front-to-back order
    DPFM(7,FRAG,("    postsort\n"))  DPFFrags(pFragSort);


    // return first sorted fragment (this is the closest, which is as good
    // as anything to put into the depth buffer for the resolved pixels...)
    ResolvedDepth = pFragSort->Depth;

    //
    // now step thru sorted list and accumulate color
    //
    if ( bAnyNonOpaque )
    {

        // here for fragment resolve accumulation which also does
        // full transparency computations - use this only if any
        // non-opaque fragments

        // instantiate and reset fragment resolve accumulator
        FragResolveAccum ResAccum;
        ResAccum.Reset();

        // per frag
        pFrag = pFragSort;
        BOOL bCovered = FALSE;
        while ( NULL != pFrag )
        {
            bCovered = ResAccum.Accum( pFrag->CvgMask, pFrag->Color );
            if (bCovered) { break; }    // fully covered, so don't do rest of frags (or background)
            pFrag = (RRFRAGMENT *)pFrag->pNext;
        }
        // add in background color (last)
        if ( !bCovered && ( UINT8(CoveredColor.A) > 0 ) )
        {
            ResAccum.Accum( TL_CVGFULL, CoveredColor );
        }

        // unload accumulator
        ResAccum.GetColor( ResolvedColor );
    }
    else
    {
        //
        // here for fragment resolve of all fully opaque fragments
        //

        //
        //     accumulated coverage and color
        //
        CVGMASK CvgMaskAccum = 0x0;
        FLOAT fRAcc = 0.F;  // these 0. to 1. range
        FLOAT fGAcc = 0.F;
        FLOAT fBAcc = 0.F;
        FLOAT fWeightAccum = 0.F;

        // per frag
        pFrag = pFragSort;
        while ( NULL != pFrag )
        {
            // compute this fragment's contribution
            CVGMASK CvgMaskContrib = pFrag->CvgMask & ~(CvgMaskAccum);
            FLOAT fWeight = (1.f/16.f) * (FLOAT)CountSetBits(CvgMaskContrib, 16);
            // accumulate rgb
            fRAcc += fWeight * FLOAT(pFrag->Color.R);
            fGAcc += fWeight * FLOAT(pFrag->Color.G);
            fBAcc += fWeight * FLOAT(pFrag->Color.B);
            // accumulate total coverage and weight
            CvgMaskAccum |= CvgMaskContrib;
            fWeightAccum += fWeight;
            // bail out early if fully covered
            if ( TL_CVGFULL == CvgMaskAccum ) { goto DoneAccumulating; }
            // next
            pFrag = (RRFRAGMENT *)pFrag->pNext;
        }

        // blend with background color/alpha
        if ( (fWeightAccum < 1.f) && ( UINT8(CoveredColor.A) > 0 ) )
        {
            // blend in remaining weight of background color
            FLOAT fWeightBg = 1.F - fWeightAccum;
            fRAcc += fWeightBg * FLOAT(CoveredColor.R);
            fGAcc += fWeightBg * FLOAT(CoveredColor.G);
            fBAcc += fWeightBg * FLOAT(CoveredColor.B);

            //  fix accumulated weight - pixel is fully covered now
            fWeightAccum = 1.f;
        }

DoneAccumulating:
        // clamp accumulators
        if ( fWeightAccum > 1.F ) { fWeightAccum = 1.F; }
        if ( fRAcc > 1.F ) { fRAcc = 1.F; }
        if ( fGAcc > 1.F ) { fGAcc = 1.F; }
        if ( fBAcc > 1.F ) { fBAcc = 1.F; }

        // set in color return
        ResolvedColor.A = fWeightAccum;
        ResolvedColor.R = fRAcc;
        ResolvedColor.G = fGAcc;
        ResolvedColor.B = fBAcc;
    }


    // free this pixel's fragments
    pFrag = pFragSort;
    while ( NULL != pFrag )
    {
        RRFRAGMENT* pFragFree = pFrag;
        pFrag = (RRFRAGMENT*)pFrag->pNext;
        FragFree( pFragFree );
    }
    return;
}

//-----------------------------------------------------------------------------
//
// DoBufferResolve - Invoked at EndScene to resolve fragments into single
// color for each pixel location.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoBufferResolve(void)
{
    DPFM(2,FRAG,("  DoBufferResolve (%d,%d)\n",m_pRenderTarget->m_iWidth,m_pRenderTarget->m_iHeight))

    // buffer may not be allocated if there were no fragments
    if (NULL == m_ppFragBuf) { return; }

    for ( int iY=0; iY < m_pRenderTarget->m_iHeight; iY++ )
    {
        for ( int iX=0; iX < m_pRenderTarget->m_iWidth; iX++ )
        {
            RRFRAGMENT* pFrag = *(m_ppFragBuf + (m_pRenderTarget->m_iWidth*iY) + iX);
            if ( NULL != pFrag )
            {
                DPFM(5,FRAG,("  DoResolve(%d,%d) %d\n",iX,iY,CountFrags(pFrag)))
                // read buffer color for background blend
                RRColor PixelColor; m_pRenderTarget->ReadPixelColor( iX,iY, PixelColor);

                // do resolve
                RRColor ResolvedColor;
                RRDepth ResolvedDepth(pFrag->Depth.GetSType());
                DoFragResolve( ResolvedColor, ResolvedDepth, pFrag, PixelColor );

                // write color back to buffer; write frontmost depth back to
                // pixel buffer (it's at least a little better than the backmost
                // opaque sample...)
                WritePixel( iX,iY, ResolvedColor, ResolvedDepth );
                // show frags freed (free happens during resolve)
                *(m_ppFragBuf + (m_pRenderTarget->m_iWidth*iY) + iX) = NULL;
            }
        }
    }
    DPFM(3,FRAG,("  DoBufferResolve - done\n"))
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Fragment Resolve Accumulator                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// FragResolveAccum - This object is the fragment resolver used when
// non-opaque fragments are present.  This has the effect of resolving
// each of the 16 subpixel locations independently to produce the fully
// correct result.  Several optimizations are used to minimize the actual
// number of accumulation computations that need to occur.
//

//-----------------------------------------------------------------------------
//
// Reset - Called prior to resolving a list of fragments to initialize the
// internal state.
//
//-----------------------------------------------------------------------------
void
FragResolveAccum::Reset(void)
{
    DPFM(5, FRAG, ("  FragResolveAccum: reset\n"))
    m_ArrayUsageMask = 0x0001;  // use first array entry only (at first)
    m_CvgArray[0].Mask = TL_CVGFULL;
    m_CvgArray[0].fAlpha = 1.;
    m_fA = 0.;
    m_fR = 0.;
    m_fG = 0.;
    m_fB = 0.;
    m_CvgOpaqueMask = 0x0000;
}

//-----------------------------------------------------------------------------
//
// Accum - Called for each fragment.  Fragments must be accumulated in front-
// to-back order (sort is done prior to accumulation).
//
// Returns TRUE if full coverage has been achieved and thus subsequent
// fragments will have no further contribution to the final pixel color and
// opacity.
//
//-----------------------------------------------------------------------------
BOOL
FragResolveAccum::Accum(
    const CVGMASK CvgMask,
    const RRColor& ColorFrag)
{
    DPFM(6, FRAG, ("  FragResolveAccum: accum %04x %08x\n",
        CvgMask, UINT32(ColorFrag) ) )

    FLOAT fAlphaFrag = FLOAT(ColorFrag.A);

    // exit (don't accum) if all covered
    if (TL_CVGFULL == m_CvgOpaqueMask)  { return TRUE; }

    // controls for doing (up to) 4 accumulations at a time
    INT32 iAccumsDeferred = 0;  // the current number of deferred accumulations
    FLOAT fColorScaleAccum;     // the accumulated color scale for the deferred accums

    // compute ArrayCheck - each set bit indicates a coverage mask
    // bit for which an accumulation needs to be done (indicated by
    // a valid entry in the coverage array which is not opaque and
    // for which the corresponding bit is set in this fragment's
    // coverage mask)
    CVGMASK ArrayCheck = 0x0;
    for (INT32 i=0; i<16; i++)
    {
        if  (m_CvgArray[i].Mask & CvgMask)
        {
            ArrayCheck |= ((0x1 << i) & ~(m_CvgOpaqueMask));
        }
    }

    INT32 iIdx;
    CVGMASK ArrayMaskT = m_ArrayUsageMask;
    while (0x0 != ArrayMaskT)
    {
        // track from MSB to LSB of usage mask
        iIdx = FindLastSetBit(ArrayMaskT,TL_CVGBITS);
        ArrayMaskT &= ~(0x1 << iIdx);

        // compute masks for overlapped coverage (requiring
        // accumulation) and non-overlapped area (which may
        // require an updated coverage/alpha entry)
        CVGMASK AccumCvgMask = m_CvgArray[iIdx].Mask & CvgMask;
        CVGMASK UpdateCvgMask = m_CvgArray[iIdx].Mask & ~CvgMask;

        // remove bits in the overlapped coverage mask for subsamples
        // which already have opaque alphas
        AccumCvgMask &= ~(m_CvgOpaqueMask);

        // read alpha old here - the location that this is stored
        // may be changed in the accumulate step but needs to be
        // remembered for the update (non-covered area) step
        FLOAT fAlphaOld = m_CvgArray[iIdx].fAlpha;

        // compute alpha scale value - this is used to scale color
        // for accumulation and to compute updated alpha for overlap
        FLOAT fAlphaScale = fAlphaOld * fAlphaFrag;

        // new alpha for overlapped area (this cannot go negative
        // since 0 < AlphaScale < AlphaOld)
        // AlphaNext = AlphaOld(1 - Alpha) = AlphaOld - AlphaOld*Alpha =
        FLOAT fAlphaNext = fAlphaOld - fAlphaScale;

        if (0x0 != AccumCvgMask)
        {
            // contribution to accumulate - this is the portion
            // the previous mask starting at the uIdx bit location
            // which is covered by the new fragment, so accumulate
            // this coverage and update the mask and alpha
            UINT32 iIdxT = FindFirstSetBit(AccumCvgMask,TL_CVGBITS);
            m_ArrayUsageMask |= (0x1 << iIdxT);
            m_CvgArray[iIdxT].Mask = AccumCvgMask;

            // set the alpha of the overlapped area
            m_CvgArray[iIdxT].fAlpha = fAlphaNext;

            // compute scale for color channels - depends on if
            // we want pre-multiplied alphas or not...
            //
            // base for scale is either array value alone or product
            // of array value and Afrag (AlphaScale)
            FLOAT fColorScaleBase = (g_bPreMultAlpha) ? (fAlphaOld) : (fAlphaScale);

            // do either multiply or bypass for full coverage
            FLOAT fColorScale = fColorScaleBase;
            if ( TL_CVGFULL != AccumCvgMask )
            {
                FLOAT fCvgFraction =
                    (FLOAT)(CountSetBits(AccumCvgMask, TL_CVGBITS)) * (1./TL_CVGBITS);
                fColorScale *= fCvgFraction;
            }

            // accumulate up to four accumulations to do at once - the accumulated
            // value is the color scale to be applied to the multiple locations

            // update color scale accum - either set (1st deferral) or
            // accumulate (subsequent deferrals)
            fColorScaleAccum = (0 == iAccumsDeferred) ?
                (fColorScale) : (fColorScale + fColorScaleAccum);

            // track number of deferrals and bypass accumulation if not
            // up to 4 (or if this is the last one)
            if ( (++iAccumsDeferred != 4) &&
                 (0x0 != (ArrayMaskT & ArrayCheck)) )
            {
                goto _update_CvgMask_Location;
            }

            // start over on deferral
            iAccumsDeferred = 0;

            // clamp color scale to max before accumulation
            fColorScale = MIN( fColorScaleAccum, 1. );

            // do accumulation and write back to accumulator

            // decide what to use for alpha accumulate - if we are using
            // pre-multiplied alphas, then AFrag is not incorporated into
            // color scale, thus mult by AFrag
            FLOAT fAPartial = fColorScale * ( (g_bPreMultAlpha) ? (fAlphaFrag) : (1.) );
            FLOAT fRPartial = fColorScale * FLOAT(ColorFrag.R);
            FLOAT fGPartial = fColorScale * FLOAT(ColorFrag.G);
            FLOAT fBPartial = fColorScale * FLOAT(ColorFrag.B);

            m_fA += fAPartial;
            m_fR += fRPartial;
            m_fG += fGPartial;
            m_fB += fBPartial;
        }

_update_CvgMask_Location:

        if (0x0 != UpdateCvgMask)
        {
            // mask to update - this is the portion of the
            // previous mask starting at the uIdx bit location
            // which is still visible, so update the coverage
            // (the alpha stays the same)
            UINT32 iIdxT = FindFirstSetBit(UpdateCvgMask,TL_CVGBITS);
            m_ArrayUsageMask |= (0x1 << iIdxT);
            m_CvgArray[iIdxT].Mask = UpdateCvgMask;
            m_CvgArray[iIdxT].fAlpha = fAlphaOld;
        }
    }

    // determine if this new fragment is has an opaque alpha
    // if so then update opaque mask - this must be done after
    // the accumulations because the opaque mask refers to the
    // current state of the coverage array and should apply only to
    // accumulations of subsequent fragments
    //
    // g_bDoCoverageOnly overrides this to always act as if fragments'
    // alphas are opaque for the purposes of generating antialiased
    // shadow attenuation surfaces
    {
        if ((fAlphaFrag >= 1.) || (g_bDoCoverageOnly))
            { m_CvgOpaqueMask |= CvgMask; }
    }

    // check opaque mask for return boolean - returns TRUE if we
    // are done
    return (TL_CVGFULL == m_CvgOpaqueMask) ? (TRUE) : (FALSE);
}

//-----------------------------------------------------------------------------
//
// GetColor - Called after accumulating a series of fragments to get the final
// pixel color and alpha.
//
//-----------------------------------------------------------------------------
void
FragResolveAccum::GetColor( RRColor& Color )
{
    // clamp and assign for return
    Color.A = (FLOAT)MIN( m_fA, 1. );
    Color.R = (FLOAT)MIN( m_fR, 1. );
    Color.G = (FLOAT)MIN( m_fG, 1. );
    Color.B = (FLOAT)MIN( m_fB, 1. );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\refs3tc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refs3tc.cpp
//
// Direct3D Reference Rasterizer - S3 texture compression functions
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"

// Primary color components (use DirextX byte ordering)
#undef RED
#define RED   0
#undef GRN
#define GRN   1
#undef BLU
#define BLU   2
#undef ALFA
#define ALFA 3

typedef struct  {
        float           rgba[4];
} FCOLOR;       // internal color format

//
// Processing all primaries is such a common idiom
// that we define a macro for this action.
// Any self-respecting C compiler should easily optimize
// this by unrolling the loop!
//
#define ForAllPrimaries         for( primary = 0; primary < NUM_PRIMARIES; ++primary)

// Similarly, processing all pixels in a block is a common idiom.
#define ForAllPixels            for(pixel=0; pixel < DXT_BLOCK_PIXELS; ++pixel)

#define NUM_PRIMARIES   3
#define NUM_COMPONENTS  4
//
// Quantization constants for RGB565
//
#define PRIMARY_BITS    8

#define RED_BITS        5
#define GRN_BITS        6
#define BLU_BITS        5

#define RED_SHIFT       (PRIMARY_BITS-RED_BITS)
#define GRN_SHIFT       (PRIMARY_BITS-GRN_BITS)
#define BLU_SHIFT       (PRIMARY_BITS-BLU_BITS)

#if 0
#define RED_MASK        0xf8
#define GRN_MASK        0xfc
#define BLU_MASK        0xf8
#endif

// Weighting for each primary based on NTSC luminance
static  float   wtPrimary[NUM_PRIMARIES] = {
        0.0820f,        // blue
        0.6094f,        // green
        0.3086f         // red
};

//-----------------------------------------------------------------------------
// unpack a fixed point color
//-----------------------------------------------------------------------------
static  void    RGBToColor (RGB565 *prgb, DXT_COLOR *pcolor)
{
        WORD    rgb;
        DXT_COLOR      color;

        rgb = *((WORD *)prgb);

        // pick off bits in groups of 5, 6, and 5
        color.rgba[BLU] = (unsigned char) rgb;
        rgb >>= BLU_BITS;
        color.rgba[GRN] = (unsigned char) rgb;
        rgb >>= GRN_BITS;
        color.rgba[RED] = (unsigned char) rgb;

        // shift primaries into the appropriate LSBs
        color.rgba[BLU] <<= BLU_SHIFT;
        color.rgba[GRN] <<= GRN_SHIFT;
        color.rgba[RED] <<= RED_SHIFT;

        // replicate primaries MSBs into LSBs
        color.rgba[BLU] |= color.rgba[BLU] >> BLU_BITS;
        color.rgba[GRN] |= color.rgba[GRN] >> GRN_BITS;
        color.rgba[RED] |= color.rgba[RED] >> RED_BITS;

        *pcolor = color;
}

//-----------------------------------------------------------------------------
// DecodeBlockRGB - decompress a color block
//-----------------------------------------------------------------------------
void DecodeBlockRGB (DXTBlockRGB *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     lev;
        DXT_COLOR      clut[4];
        PIXBM   pixbm;
        int     pixel;
        int     primary;

        // if source block is invalid, ...
        if (pblockSrc == NULL)
                return;

        // determine the number of color levels in the block
        lev = (pblockSrc->rgb0 <= pblockSrc->rgb1) ? 2 : 3;

        // Fill extrema values into pixel code lookup table.
        RGBToColor(&pblockSrc->rgb0, &clut[0]);
        RGBToColor(&pblockSrc->rgb1, &clut[1]);

        clut[0].rgba[ALFA] =
        clut[1].rgba[ALFA] =
        clut[2].rgba[ALFA] = 255;

        if (lev == 3) { // No transparency info present, all color info.
                ForAllPrimaries {
                        WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
                        WORD temp1 = clut[1].rgba[primary];
                        clut[2].rgba[primary] = (BYTE)((2*temp0 + temp1 + 1)/3);
                        clut[3].rgba[primary] = (BYTE)((temp0 + 2*temp1 + 1)/3);
                }
                clut[3].rgba[ALFA] = 255;
        }
        else {  // transparency info.
                ForAllPrimaries {
                        WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
                        WORD temp1 = clut[1].rgba[primary];
                        clut[2].rgba[primary] = (BYTE)((temp0 + temp1)/2);
                        clut[3].rgba[primary] = 0;     // jvanaken added this
                }
                clut[3].rgba[ALFA] = 0;
        }

        // munge a local copy
        pixbm = pblockSrc->pixbm;

        // Look up the actual pixel color in the table.
        ForAllPixels {
                // lookup color from pixel bitmap
                ForAllPrimaries
                        colorDst[pixel].rgba[primary] = clut[pixbm & 3].rgba[primary];

                colorDst[pixel].rgba[ALFA] = clut[pixbm & 3].rgba[ALFA];

                // prepare to extract next index
                pixbm >>= 2;
        }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha4 - decompress a block with alpha at 4 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     row, col;
        WORD    alpha;

        DecodeBlockRGB(&pblockSrc->rgb, colorDst);

        for (row = 0; row < 4; ++row) {
                alpha = pblockSrc->alphabm[row];

                for (col = 0; col < 4; ++col) {
                        colorDst[4 * row + col].rgba[ALFA] =
                                  ((alpha & 0xf) << 4)
                                | (alpha & 0xf);
                        alpha >>= 4;
                }
        }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha3 - decompress a block with alpha at 3 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     pixel;
        int     alpha[8];       // alpha lookup table
        DWORD   dwBM = 0;       // alpha bitmap in DWORD cache

        DecodeBlockRGB(&pblockSrc->rgb, colorDst);

        alpha[0] = pblockSrc->alpha0;
        alpha[1] = pblockSrc->alpha1;

        // if 8 alpha ramp, ...
        if (alpha[0] > alpha[1]) {
                // interpolate intermediate colors
                alpha[2] = (6 * alpha[0] + 1 * alpha[1]) / 7;
                alpha[3] = (5 * alpha[0] + 2 * alpha[1]) / 7;
                alpha[4] = (4 * alpha[0] + 3 * alpha[1]) / 7;
                alpha[5] = (3 * alpha[0] + 4 * alpha[1]) / 7;
                alpha[6] = (2 * alpha[0] + 5 * alpha[1]) / 7;
                alpha[7] = (1 * alpha[0] + 6 * alpha[1]) / 7;
        }
        else { // else 6 alpha ramp with 0 and 255
                // interpolate intermediate colors
                alpha[2] = (4 * alpha[0] + 1 * alpha[1]) / 5;
                alpha[3] = (3 * alpha[0] + 2 * alpha[1]) / 5;
                alpha[4] = (2 * alpha[0] + 3 * alpha[1]) / 5;
                alpha[5] = (1 * alpha[0] + 4 * alpha[1]) / 5;
                alpha[6] = 0;
                alpha[7] = 255;
        }

        ForAllPixels {
                // reload bitmap dword cache every 8 pixels
                if ((pixel & 7) == 0) {
                        if (pixel == 0) {
                                // pack 3 bytes into dword
                                dwBM  = pblockSrc->alphabm[2];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[1];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[0];
                        }
                        else {  // pixel == 8
                                // pack 3 bytes into dword
                                dwBM  = pblockSrc->alphabm[5];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[4];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[3];
                        }
                }

                // unpack bitmap dword 3 bits at a time
                colorDst[pixel].rgba[ALFA] = (BYTE)alpha[(dwBM & 7)];
                dwBM >>= 3;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\refrast.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrast.cpp
//
// Direct3D Reference Rasterizer - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// This is a global static array of the block sizes in bytes for the
// various S3 compression formats
int g_DXTBlkSize[NUM_DXT_FORMATS] =
{
    sizeof(DXTBlockRGB),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha3),
    sizeof(DXTBlockAlpha3),
};

//-----------------------------------------------------------------------------
//
// Memory management function installation
//
//-----------------------------------------------------------------------------

//  global pointers to memory allocation functions (used through MEM* macros)
LPVOID (__cdecl *g_pfnMemAlloc)( size_t size ) = NULL;
void   (__cdecl *g_pfnMemFree)( LPVOID lptr ) = NULL;
LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size ) = NULL;

// install memory management functions - must be called before instancing
// rasterizer object
void RefRastSetMemif(
    LPVOID(__cdecl *pfnMemAlloc)(size_t),
    void(__cdecl *pfnMemFree)(LPVOID),
    LPVOID(__cdecl *pfnMemReAlloc)(LPVOID,size_t))
{
    DPFRR(1, "RefRastSetMemif %08x %08x %08x\n",
        pfnMemAlloc,pfnMemFree,pfnMemReAlloc);
    g_pfnMemAlloc = pfnMemAlloc;
    g_pfnMemFree = pfnMemFree;
    g_pfnMemReAlloc = pfnMemReAlloc;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Interface Methods                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetRenderTarget -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetRenderTarget( RRRenderTarget* pRenderTarget )
{
    m_pRenderTarget = pRenderTarget;

    // update the W scaling values for mapping interpolated W's into buffer range
    m_fWBufferNorm[0] = pRenderTarget->m_fWRange[0];
    FLOAT fWRange = pRenderTarget->m_fWRange[1] - pRenderTarget->m_fWRange[0];
    m_fWBufferNorm[1] = ( 0. != fWRange ) ? ( 1./fWRange ) : ( 1. );

    // free fragment buffer array - will reallocate with new size when needed
    if (pRenderTarget->m_iWidth != m_iFragBufWidth ||
        pRenderTarget->m_iHeight != m_iFragBufHeight)
    {
        MEMFREE( m_ppFragBuf ); m_ppFragBuf = NULL;
        m_iFragBufWidth = pRenderTarget->m_iWidth;
        m_iFragBufHeight = pRenderTarget->m_iHeight;
    }
}

//-----------------------------------------------------------------------------
//
// SetTextureStageState -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetTextureStageState(
    DWORD dwStage, DWORD dwStageState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwStage >= D3DHAL_TSS_MAXSTAGES )
    {
        return;
    }
    if ( dwStageState > D3DTSS_MAX )
    {
        return;
    }

    // set in internal per-stage state
    m_TextureStageState[dwStage].m_dwVal[dwStageState] = dwValue;

    switch ( dwStageState )
    {

    case D3DTSS_TEXTUREMAP:

        // bind texture indicated by handle to m_pTexture array
        if (IsDriverDX6AndBefore() || IsInterfaceDX6AndBefore())
        {
            // This is the legacy behavior (prev. to DX7)
            MapTextureHandleToDevice( dwStage );
        }
        else
        {
            // This is the new behavior (DX7 and beyond)
            SetTextureHandle( dwStage, dwValue );
        }
        break;

    case D3DTSS_COLOROP:
        // may need to recompute count of active textures based on COLOROP change
        UpdateActiveTexStageCount();
        break;

    case D3DTSS_ADDRESS:
        // map single set ADDRESS to both U and V controls
        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
    }
}

//-----------------------------------------------------------------------------
//
// TextureCreate - Instantiates new RRTexture object, computes texture handle
// to associate with it, and returns both to caller.  Note that texture handle
// is a pointer and can be used to get at the corresponding texture object.
//
// TODO: this is not 64 bit clean
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureCreate(
    LPD3DTEXTUREHANDLE phTex, RRTexture** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RRTexture( );
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // use separately allocated pointer for handle
    RRTexture** ppTexForHandle = (RRTexture**)MEMALLOC( sizeof(RRTexture*) );
    _ASSERTa( NULL != ppTexForHandle, "malloc failure on texture create", return FALSE; );
    *ppTexForHandle = *ppTex;

    // return texture handle
    (*ppTex)->m_hTex = (ULONG_PTR)ppTexForHandle;
    *phTex = (*ppTex)->m_hTex;

    return TRUE;
}
//-----------------------------------------------------------------------------
//
// TextureCreate -
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureCreate(
    DWORD dwHandle, RRTexture** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RRTexture( );
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // assign texture handle
    (*ppTex)->m_hTex = dwHandle;

    return TRUE;
}
//-----------------------------------------------------------------------------
//
// TextureDestroy -
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureDestroy( D3DTEXTUREHANDLE hTex )
{
    // first check if texture about to be destroyed is mapped - if so then
    // unmap it
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( hTex == m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] )
        {
            SetTextureStageState( iStage, D3DTSS_TEXTUREMAP, 0x0 );
        }
    }

    // resolve handle to RRTexture pointer
    RRTexture* pTex = MapHandleToTexture( hTex );
    if ( NULL == pTex ) { return FALSE; }

    // free the handle pointer
    RRTexture** ppTex = (RRTexture**)ULongToPtr(hTex);
    if ( NULL != ppTex) { MEMFREE( ppTex ); }

    // free the RRTexture
    delete pTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureGetSurf -
//
//-----------------------------------------------------------------------------
DWORD
ReferenceRasterizer::TextureGetSurf( D3DTEXTUREHANDLE hTex )
{
    RRTexture* pTex = MapHandleToTexture(hTex);
    if ( NULL == pTex ) { return 0x0; }
    return (ULONG_PTR)( pTex->m_pDDSLcl[0] );
}

//-----------------------------------------------------------------------------
//
// GetCurrentTextureMaps - This function fills in a passed array texture handles
// and pointers.  The array should be sized by D3DHAL_TSS_MAXSTAGES.
//
// This is used to facilitate external locking/unlocking of surfaces used for
// textures.
//
//-----------------------------------------------------------------------------
int
ReferenceRasterizer::GetCurrentTextureMaps(
    D3DTEXTUREHANDLE *phTex, RRTexture** pTex)
{
    UpdateActiveTexStageCount();

    for ( int i=0; i<m_cActiveTextureStages; i++ )
    {
        if ( NULL == m_pTexture[i] )
        {
            phTex[i] = 0x0;
            pTex[i] = NULL;
        }
        else
        {
            phTex[i] = m_pTexture[i]->m_hTex;
            pTex[i] = m_pTexture[i];
        }
    }
    return m_cActiveTextureStages;
}


//-----------------------------------------------------------------------------
//
// SceneCapture - Used to trigger fragment buffer resolve.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SceneCapture( DWORD dwFlags )
{
    switch (dwFlags)
    {
    case D3DHAL_SCENE_CAPTURE_START:
        break;
    case D3DHAL_SCENE_CAPTURE_END:
        DoBufferResolve();
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Query functions to get pointer to current render target and render state.
//
//-----------------------------------------------------------------------------
RRRenderTarget*
ReferenceRasterizer::GetRenderTarget(void)
{
    return m_pRenderTarget;
}
//-----------------------------------------------------------------------------
DWORD*
ReferenceRasterizer::GetRenderState(void)
{
    return &(m_dwRenderState[0]);
}
//-----------------------------------------------------------------------------
DWORD*
ReferenceRasterizer::GetTextureStageState(DWORD dwStage)
{
    return &(m_TextureStageState[dwStage].m_dwVal[0]);
}

//-----------------------------------------------------------------------------
//
// Begin/End bracket functions - Called before/after a list of primitives are
// rendered.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::BeginRendering( DWORD dwFVFControl )
{
    // set FVF control word - this specifies the vertex types for this
    // begin/end sequence
    if ( dwFVFControl )
    {
        m_qwFVFControl = dwFVFControl;
    }
    else
    {
        // Legacy TLVERTEX's
        m_qwFVFControl = D3DFVF_TLVERTEX;
    }

    // set colorkey enable
    for (INT32 i = 0; i < m_cActiveTextureStages; i++)
    {
        if ( m_pTexture[i] != NULL )
        {
            m_pTexture[i]->m_bDoColorKeyKill = FALSE;
            m_pTexture[i]->m_bDoColorKeyZero = FALSE;
            if ( m_pTexture[i]->m_uFlags & RR_TEXTURE_HAS_CK)
            {
                if ( m_dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE] )
                {
                    m_pTexture[i]->m_bDoColorKeyZero = TRUE;
                }
                else
                {
                    if ( m_dwRenderState[D3DRENDERSTATE_COLORKEYENABLE] )
                    {
                        m_pTexture[i]->m_bDoColorKeyKill = TRUE;
                    }
                }
            }
        }
    }

#ifdef _X86_
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP = wSave;
    }
#endif

    m_bInBegin = TRUE;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::EndRendering( void )
{
    if ( m_bInBegin )
    {

#ifdef _X86_
        // restore floating point mode
        {
            WORD wSave = m_wSaveFP;
            __asm {fldcw   wSave}
        }
#endif

        m_bInBegin = FALSE;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
HRESULT ReferenceRasterizer::Clear(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    WORD i;
    INT32 x,y;
    RRColor fillColor(pData->dwFillColor);
    RRDepth fillDepth(m_pRenderTarget->m_DepthSType);

    fillDepth = pData->dvFillDepth;

#ifdef _X86_
    // Float to integer conversion routines for 24+ bit buffers work
    // only with extended FPU mode.
    //
    WORD wSaveFP;
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSaveFP
            mov ax, wSaveFP
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

    if(pData->dwFlags & D3DCLEAR_TARGET)
    {
        if (m_dwRenderState[D3DRENDERSTATE_DITHERENABLE] == FALSE)
        {
            m_pRenderTarget->Clear(fillColor, pCmd);
        }
        else
        {
            for (i = 0; i < pCmd->wStateCount; i++)
            {
                for (y = pData->Rects[i].top; y < pData->Rects[i].bottom; ++y)
                {
                    for (x = pData->Rects[i].left; x < pData->Rects[i].right; ++x)
                    {
                        m_pRenderTarget->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }


    switch (pData->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))
    {
    case (D3DCLEAR_ZBUFFER):
        m_pRenderTarget->ClearDepth(fillDepth, pCmd);
        break;
    case (D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearStencil(pData->dwFillStencil, pCmd);
        break;
    case (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearDepthStencil(fillDepth, pData->dwFillStencil, pCmd);
        break;
    }

#ifdef _X86_
    // restore floating point mode
    {
        __asm {fldcw   wSaveFP}
    }
#endif
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::Clear(RRColor fillColor, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    UINT32 dwColor = 0;
    fillColor.ConvertTo( m_ColorSType, 0.5f, (char*)&dwColor);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
        switch ( m_ColorSType )
        {
        case RR_STYPE_B8G8R8A8:
        case RR_STYPE_B8G8R8X8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B8G8R8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = ((UINT8*)&dwColor)[0];
                        *p++ = ((UINT8*)&dwColor)[1];
                        *p++ = ((UINT8*)&dwColor)[2];
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B4G4R4A4:
        case RR_STYPE_B5G6R5:
        case RR_STYPE_B5G5R5A1:
        case RR_STYPE_B5G5R5:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT16)dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B2G3R3:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT8)dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearDepth(RRDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z16S0:
            {
                UINT16 Depth = UINT16(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z24S8:
        case RR_STYPE_Z24S4:
            {
                UINT32 Depth = UINT32(fillDepth) << 8;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xffffff00)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S8Z24:
        case RR_STYPE_S4Z24:
            {
                UINT32 Depth = UINT32(fillDepth) & 0x00ffffff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x00ffffff)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
            {
                UINT16 Depth = UINT16(fillDepth) << 1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xfffe)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S1Z15:
            {
                UINT16 Depth = UINT16(fillDepth) & 0x7fff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x7fff)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z32S0:
            {
                UINT32 Depth = UINT32(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the stencil buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearStencil(UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z24S8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S8Z24:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)&pSurface[3];
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z24S4:
            {
                UINT32 stencil = uStencil & 0xf;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x000000ff)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S4Z24:
            {
                UINT32 stencil = (uStencil & 0xf) << 24;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0xff000000)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
            {
                UINT16 stencil = uStencil & 0x1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x0001)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S1Z15:
            {
                UINT16 stencil = uStencil << 15;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x8000)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z16S0:
        case RR_STYPE_Z32S0:
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth and stencil buffers
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearDepthStencil(RRDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z16S0:
        case RR_STYPE_Z32S0:
            break;
        case RR_STYPE_Z24S8:
        case RR_STYPE_S8Z24:
        case RR_STYPE_Z24S4:
        case RR_STYPE_S4Z24:
            {
                UINT32 v;
                switch (m_DepthSType)
                {
                case RR_STYPE_Z24S8: v = (UINT32(fillDepth) << 8) + uStencil;    break;
                case RR_STYPE_S8Z24: v = (UINT32(fillDepth)  & 0x00ffffff) + (uStencil << 24); break;
                case RR_STYPE_Z24S4: v = (UINT32(fillDepth) << 8) + (uStencil & 0xf);  break;
                case RR_STYPE_S4Z24: v = (UINT32(fillDepth) & 0x00ffffff) + ((uStencil & 0xf) << 24); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
        case RR_STYPE_S1Z15:
            {
                UINT16 v;
                switch (m_DepthSType)
                {
                case RR_STYPE_Z15S1:    v = (UINT16(fillDepth) << 1) + (uStencil & 0x1); break;
                case RR_STYPE_S1Z15:    v = (UINT16(fillDepth) & 0x7fff) + (uStencil << 15); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\rrutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrutil.cpp
//
// Direct3D Reference Rasterizer - Utilities
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// DPF support                                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// control globals
int g_iDPFLevel = 0;
unsigned long g_uDPFMask = 0x0;

//-----------------------------------------------------------------------------
//
// RRDebugPrintf(L) - Utilities to print varargs-formatted strings of debugging
// info.  The 'L' version takes a level into account in deciding to print or
// not.
//
//-----------------------------------------------------------------------------
void
RRDebugPrintf( const char* pszFormat, ... )
{
    char tmp[1024];
    _snprintf( (LPSTR) tmp, 1024, "D3DRR: ");
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
    OutputDebugString(tmp);
    printf(tmp);
}
void
RRDebugPrintfL( int iLevel, const char* pszFormat, ... )
{
    if ( (iLevel <= g_iDPFLevel) )
    {
        char tmp[1024];
        _snprintf( (LPSTR) tmp, 1024, "D3DRR: ");
        va_list marker;
        va_start(marker, pszFormat);
        _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
        OutputDebugString(tmp);
        printf(tmp);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Assert Reporting
//
///////////////////////////////////////////////////////////////////////////////

// little-bit-o-state to track file and line number reporting - this is makes
// this code non-reentrant and non-threadsafe...  oh well...
static const char* _pszLastReportFile = NULL;
static int _iLastReportLine = -1;

//-----------------------------------------------------------------------------
void
RRAssertReport( const char* pszString, const char* pszFile, int iLine )
{
    char szTmp[1024];
    _snprintf( szTmp, 1024, "D3DRR ASSERT: <%d,%s> %s",
               iLine, pszFile, pszString );
    OutputDebugString( szTmp );
}
//-----------------------------------------------------------------------------
void
RRAssertReportPrefix( const char* pszFile, int iLine )
{
    _pszLastReportFile = pszFile;
    _iLastReportLine = iLine;
}
//-----------------------------------------------------------------------------
void
RRAssertReportMessage( const char* pszFormat, ... )
{
    char szTmp[1024];
    va_list marker;
    va_start( marker, pszFormat );
    _vsnprintf( szTmp, 1024, pszFormat, marker );
    RRAssertReport( szTmp, _pszLastReportFile, _iLastReportLine );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Generic bit twiddling utilities                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CountSetBits - Returns number of set bits in a multibit value (up to
// 32 bits).
//
//-----------------------------------------------------------------------------
INT32
CountSetBits( UINT32 uVal, INT32 nBits )
{
    INT32 iRet = 0;
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { iRet++; }
    }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// FindFirstSetBit - Returns index of first set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindFirstSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { return i; }
    }
    return -1;
}

//-----------------------------------------------------------------------------
//
// FindMostSignificantSetBit - Returns index of first set bit in a
// multibit value (up to 32 bits) or 0 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindMostSignificantSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=nBits; i>=0; i--) {
        if (uVal & (0x1<<i)) { return i+1; }
    }
    return 0;
}

//-----------------------------------------------------------------------------
//
// FindLastSetBit - Returns index of last set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindLastSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<(nBits-i-1))) { return (nBits-i-1); }
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Arithmetic utilities                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// LerpColor - Performs a linear interpolation between two RRColors
//
// uT is in 1.5 format (1<<5 represents a unit value)
//
//-----------------------------------------------------------------------------
void
LerpColor(
    RRColor& Color,
    const RRColor& Color0, const RRColor& Color1, UINT8 uT )
{
    FLOAT fT = (1./(FLOAT)(1<<5))*(FLOAT)uT;
    Color.A = Color0.A + (Color1.A - Color0.A)*fT;
    Color.R = Color0.R + (Color1.R - Color0.R)*fT;
    Color.G = Color0.G + (Color1.G - Color0.G)*fT;
    Color.B = Color0.B + (Color1.B - Color0.B)*fT;
}

//-----------------------------------------------------------------------------
//
// Bilerp - Performs bilinear interpolation of 4 RRColors returning one RRColor.
//
//-----------------------------------------------------------------------------
void
BiLerpColor(
    RRColor& OutColor,
    const RRColor& Color00, const RRColor& Color01,
    const RRColor& Color10, const RRColor& Color11,
    UINT8 uA, UINT8 uB )
{
    RRColor Color0, Color1;
    LerpColor( Color0, Color00, Color01, uA);
    LerpColor( Color1, Color10, Color11, uA);
    LerpColor( OutColor, Color0, Color1, uB);
}

///////////////////////////////////////////////////////////////////////////////
//
// RRAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RRAlloc::operator new(size_t s)
{
    void* pMem = (void*)MEMALLOC( s );
    _ASSERTa( NULL != pMem, "malloc failure", return NULL; );
    return pMem;
}

void 
RRAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
};


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\refrasti.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrasti.hpp
//
// Direct3D Reference Rasterizer - Main Internal Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRASTI_HPP
#define  _REFRASTI_HPP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Component Classes                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Color Component Class - Class used for color channel (alpha & rgb)
// processing.
//
// Internal format is single precision floating point.  The 1.0 value maps
// to 0xff for 8 bit color.
//
//-----------------------------------------------------------------------------
class RRColorComp
{
    FLOAT m_fVal;

public:

    // default, UINT8, & FLOAT assignment constructor
    RRColorComp(void)       : m_fVal(0.F)               {;}
    RRColorComp(UINT8 uVal) : m_fVal((FLOAT)uVal/255.F) {;}
    RRColorComp(FLOAT fVal) : m_fVal(fVal)              {;}

    // copy and assignment operators
    RRColorComp& operator=(const RRColorComp& A) { m_fVal = A.m_fVal; return *this; }
    RRColorComp& operator=(UINT8 uVal) { m_fVal = (1.f/255.f)*(FLOAT)uVal; return *this; }
    RRColorComp& operator=(FLOAT fVal) { m_fVal = fVal; return *this; }
    // round for integer get operations
    operator UINT8() const { return (UINT8)( ( (255.f)*m_fVal) + .5f); }
    operator unsigned() const { return (unsigned)( ( (255.f)*m_fVal ) + .5f); }
    operator FLOAT() const { return m_fVal; }

    // fixed point get function - specify number of integral and fractional bits
    INT32 GetFixed( int iIntBits, int iFracBits ) const
    {
        // float value is in 0. to 1. range, so scale up by the total number of
        // bits (the '-1' does the mapping such that (2**n)-1 is the max representable
        // value, for example 0xff is max for 8 integral bits (not 0x100))
        return (INT32)( ( m_fVal * (FLOAT)((1<<(iIntBits+iFracBits))-1) ) + .5f);
    }

    //
    // overloaded arithmetic operators - not much going on here for floating
    // point (would be much more interesting if internal representation was
    // fixed point)
    //

    // use compliment operator for component inverse (1. - value)
    friend RRColorComp operator~(const RRColorComp& A)
    {
        return RRColorComp( 1.F - A.m_fVal );
    }

    friend RRColorComp operator+(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal + B.m_fVal );
    }
    RRColorComp& operator+=(const RRColorComp& A)
    {
        m_fVal += A.m_fVal; return *this;
    }

    friend RRColorComp operator-(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal - B.m_fVal );
    }
    friend RRColorComp operator-(const RRColorComp& A, FLOAT fB)
    {
        return RRColorComp( A.m_fVal - fB );
    }

    friend RRColorComp operator*(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal * B.m_fVal );
    }
    friend RRColorComp operator*(const RRColorComp& A, FLOAT fB)
    {
        return RRColorComp( A.m_fVal * fB );
    }
    RRColorComp& operator*=(const RRColorComp& A)
    {
        m_fVal *= A.m_fVal; return *this;
    }
    RRColorComp& operator*=(const UINT8 uA)
    {
        m_fVal *= ((1./255.)*(FLOAT)uA); return *this;
    }

    friend RRColorComp minimum(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( min( A.m_fVal, B.m_fVal ) );
    }
    friend RRColorComp maximum(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( max( A.m_fVal, B.m_fVal ) );
    }
};

//-----------------------------------------------------------------------------
//
// Color Value Class - Holds an Alpha,Red,Green,Blue color value consisting of
// four RRColorComp objects.
//
//-----------------------------------------------------------------------------
class RRColor
{
public:
    RRColorComp A;
    RRColorComp R;
    RRColorComp G;
    RRColorComp B;

    // default and UINT32 assignment constructor
    RRColor( void ) : A(0.F), R(0.F), G(0.F), B(0.F) {;}
    RRColor( UINT32 uVal ) :
        A (UINT8( RGBA_GETALPHA( uVal ) )),
        R (UINT8( RGBA_GETRED(   uVal ) )),
        G (UINT8( RGBA_GETGREEN( uVal ) )),
        B (UINT8( RGBA_GETBLUE(  uVal ) ))  {;}
    RRColor( FLOAT fR, FLOAT fG, FLOAT fB, FLOAT fA ) :
        R(fR), G(fG), B(fB), A(fA) {;}

    // UINT32 copy operator
    void operator=(const UINT32 uVal) // TODO: implement proper assignment operator?
    {
        A = UINT8( RGBA_GETALPHA( uVal ) );
        R = UINT8( RGBA_GETRED(   uVal ) );
        G = UINT8( RGBA_GETGREEN( uVal ) );
        B = UINT8( RGBA_GETBLUE(  uVal ) );
    }
    // casting operator
    operator UINT32() const
    {
        return D3DRGBA( FLOAT(R), FLOAT(G), FLOAT(B), FLOAT(A) );
    }

    // methods to set all channels
    void SetAllChannels( const RRColorComp& Val )
    {
        A = Val; R = Val; G = Val; B = Val;
    }
    void SetAllChannels( FLOAT fVal )
    {
        A = fVal; R = fVal; G = fVal; B = fVal;
    }

    //
    // conversions between surface format and RRColor - these define the
    // correct way to map between resolutions
    //

    // convert from surface type format to RRColor
    void ConvertFrom( RRSurfaceType Type, const char* pSurfaceBits )
    {
        UINT16 u16BITS;

        switch (Type)
        {
        default:
        case RR_STYPE_NULL: return;
        case RR_STYPE_B8G8R8A8: *this = *((UINT32*)pSurfaceBits); break;
        case RR_STYPE_B8G8R8X8: *this = *((UINT32*)pSurfaceBits); A = 1.F; break;

        case RR_STYPE_B5G6R5:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(6+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x003F)/63.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = 1.F;
            break;

        case RR_STYPE_B5G5R5:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x001F)/31.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = 1.F;
            break;

        case RR_STYPE_B5G5R5A1:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x001F)/31.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = ( u16BITS & 0x8000 ) ? 1.f : 0.f;
            break;

        case RR_STYPE_B4G4R4A4:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(4+4)) & 0x000F)/15.f;
            G = ((u16BITS>>   4) & 0x000F)/15.f;
            B = ((u16BITS      ) & 0x000F)/15.f;
            A = ((u16BITS>>(4+4+4)) & 0x000F)/15.f;
            break;

        case RR_STYPE_B8G8R8:
            R = *((UINT8*)pSurfaceBits+2);
            G = *((UINT8*)pSurfaceBits+1);
            B = *((UINT8*)pSurfaceBits+0);
            A = 1.F;
            break;

        case RR_STYPE_L8:
            R = G = B = *((UINT8*)pSurfaceBits);
            A = 1.F;
            break;

        case RR_STYPE_L8A8:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = G = B = (UINT8)(0xff & u16BITS);
            A = (UINT8)(0xff & (u16BITS >> 8));
            break;

        case RR_STYPE_B2G3R3:
            u16BITS = *((UINT8*)pSurfaceBits);
            R = ((u16BITS>>(3+2)) & 0x07)/7.f;
            G = ((u16BITS>>   2) & 0x07)/7.f;
            B = ((u16BITS      ) & 0x03)/3.f;
            A = 1.F;
            break;

        case RR_STYPE_L4A4:
            u16BITS = *((UINT8*)pSurfaceBits);
            R = G = B = (u16BITS & 0x0f)/15.f;
            A =    ((u16BITS>>4) & 0x0f)/15.f;
            break;

        case RR_STYPE_B2G3R3A8:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(3+2)) & 0x07)/7.f;
            G = ((u16BITS>>   2) & 0x07)/7.f;
            B = ((u16BITS      ) & 0x03)/3.f;
            A = (UINT8)(0xff & (u16BITS >> 8));
            break;

        case RR_STYPE_U8V8:
            {
                INT8 iDU = *(( INT8*)pSurfaceBits+0);
                INT8 iDV = *(( INT8*)pSurfaceBits+1);
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/128.0F);     // fDU
                G = (FLOAT)iDV * (1.0F/128.0F);     // fDV
                B = 1.0F;                           // fL
            }
            break;

        case RR_STYPE_U5V5L6:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                INT8 iDU = (INT8)(u16BITS & 0x1f);
                INT8 iDV = (INT8)((u16BITS>>5) & 0x1f);
                UINT8 uL = (UINT8)(u16BITS >> 10);
                iDU <<= 3; iDU >>= 3;   // sign extension
                iDV <<= 3; iDV >>= 3;
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/16.0F);      // fDU
                G = (FLOAT)iDV * (1.0F/16.0F);      // fDV
                // the unsigned uL is normalized with 2^N - 1, since this is the
                // largest representable value
                B = (FLOAT)uL * (1.0F/63.0F);       // fL
            }
            break;

        case RR_STYPE_U8V8L8:
            {
                INT8 iDU = *(( INT8*)pSurfaceBits+0);
                INT8 iDV = *(( INT8*)pSurfaceBits+1);
                UINT8 uL  = *((UINT8*)pSurfaceBits+2);
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/128.0F);     // fDU
                G = (FLOAT)iDV * (1.0F/128.0F);     // fDV
                // the unsigned uL is normalized with 2^N - 1, since this is the
                // largest representable value
                B = (FLOAT)uL * (1.0F/255.0F);      // fL
            }
            break;

        // shadow map texture formats (read only, not needed for ConvertTo)
        case RR_STYPE_Z16S0:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)u16BITS * (1.0F/(FLOAT)0xffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z24S8:
        case RR_STYPE_Z24S4:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u32BITS>>8) * (1.0F/(FLOAT)0xffffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_S8Z24:
        case RR_STYPE_S4Z24:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u32BITS&0x00ffffff) * (1.0F/(FLOAT)0xffffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z15S1:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u16BITS>>1) * (1.0F/(FLOAT)0x7fff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_S1Z15:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u16BITS&0x7fff) * (1.0F/(FLOAT)0x7fff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z32S0:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)u32BITS * (1.0F/(FLOAT)0xffffffff);
                B = 0.0F;
            }
            break;
        }
    }

    // Convert surface type format to RRColor
    void ConvertTo( RRSurfaceType Type, float fRoundOffset, char* pSurfaceBits ) const
    {
        int iR, iG, iB, iA;

        switch (Type)
        {
        case RR_STYPE_B8G8R8A8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
            break;

        case RR_STYPE_B8G8R8X8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+3) = 0x00;
            break;

        case RR_STYPE_B8G8R8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            break;

        case RR_STYPE_B4G4R4A4:
            iA = (FLOAT)A * 15. + fRoundOffset;
            iR = (FLOAT)R * 15. + fRoundOffset;
            iG = (FLOAT)G * 15. + fRoundOffset;
            iB = (FLOAT)B * 15. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iA<<12) | (iR<<8) | (iG<<4) | iB;
            break;

        case RR_STYPE_B5G6R5:
            iR = (FLOAT)R * 31. + fRoundOffset; // apply rounding bias then truncate
            iG = (FLOAT)G * 63. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) =            (iR<<11) | (iG<<5) | iB;
            break;

        case RR_STYPE_B5G5R5A1:
            iA = (FLOAT)A *  1. + fRoundOffset;
            iR = (FLOAT)R * 31. + fRoundOffset;
            iG = (FLOAT)G * 31. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iA<<15) | (iR<<10) | (iG<<5) | iB;
            break;

        case RR_STYPE_B5G5R5:
            iR = (FLOAT)R * 31. + fRoundOffset;
            iG = (FLOAT)G * 31. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iR<<10) | (iG<<5) | iB;
            break;

        case RR_STYPE_B2G3R3:
            iR = (FLOAT)R * 7. + fRoundOffset;
            iG = (FLOAT)G * 7. + fRoundOffset;
            iB = (FLOAT)B * 3. + fRoundOffset;
            *((UINT8*)pSurfaceBits) = (iR<<5) | (iG<<2) | iB;
            break;
        }
    }
};

//-----------------------------------------------------------------------------
//
// RRDepth - Class for storing and manipulating pixel depth values.  Underlying
// storage is a double precision floating point, which has sufficient precision
// and range to support 16 and 32 bit fixed point and 32 bit floating point.
//
// The UINT32 methods receive a 24 or 32 bit value, and the UINT16
// methods receive a 15 or 16 bit value.
//
//-----------------------------------------------------------------------------
class RRDepth
{
    DOUBLE m_dVal;
    RRSurfaceType m_DepthSType;
    DOUBLE dGetValClamped(void) const { return min(1.,max(0.,m_dVal)); }
    DOUBLE dGetCnvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RR_STYPE_Z16S0:
            return DOUBLE((1<<16)-1);
        case RR_STYPE_Z24S8:
        case RR_STYPE_S8Z24:
        case RR_STYPE_Z24S4:
        case RR_STYPE_S4Z24:
            return DOUBLE((1<<24)-1);
        case RR_STYPE_Z15S1:
        case RR_STYPE_S1Z15:
            return DOUBLE((1<<15)-1);
        case RR_STYPE_Z32S0:
            return DOUBLE(0xffffffff);  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RRDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
public:
    // default and UINT16/32 assignment constructor
    // default only for Pixel class, and requires that SetSType be called later
    RRDepth()                                : m_dVal(0.F), m_DepthSType(RR_STYPE_NULL)                 {;}
    RRDepth(RRSurfaceType SType)             : m_dVal(0.F), m_DepthSType(SType)                         {;}
    RRDepth(UINT16 uVal, RRSurfaceType SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal/dGetCnvScale()) {;}
    RRDepth(UINT32 uVal, RRSurfaceType SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal/dGetCnvScale()) {;}

    // copy and assignment operators
    RRDepth& operator=(const RRDepth& A) { m_dVal = A.m_dVal; m_DepthSType = A.m_DepthSType; return *this; }
    RRDepth& operator=(UINT16 uVal) { m_dVal = (DOUBLE)uVal/dGetCnvScale(); return *this; }
    RRDepth& operator=(UINT32 uVal) { m_dVal = (DOUBLE)uVal/dGetCnvScale(); return *this; }
    RRDepth& operator=(FLOAT fVal) { m_dVal = (DOUBLE)fVal; return *this; }

    // round for integer get operations
    operator UINT16() const { return (UINT16)( (dGetValClamped()*dGetCnvScale()) + .5); }
    operator UINT32() const { return (UINT32)( (dGetValClamped()*dGetCnvScale()) + .5); }

    operator DOUBLE() const { return dGetValClamped(); }
    operator FLOAT()  const { return (FLOAT)dGetValClamped(); }
    void SetSType(RRSurfaceType SType)  { m_DepthSType = SType; }
    RRSurfaceType GetSType(void) const { return m_DepthSType; }
};

//-----------------------------------------------------------------------------
//
// RRPixel - Class for encapsulation of all pixel information passed from
// scan conversion to pixel and fragment processing.
//
//-----------------------------------------------------------------------------
class RRPixel
{
public:
    INT16 iX;                   // pixel location
    INT16 iY;                   //
    RRColor Color;              // pixel diffuse color
    RRColor Specular;           // pixel specular color (rgb only - alpha unused)
    RRDepth Depth;              // pixel depth
    FLOAT fW;                   // pixel W value (unnormalized)
    RRColorComp FogIntensity;   // fog intensity (scalar)
    RRCvgMask CvgMask;          // coverage mask
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Setup & Scan Convert                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Scan Converter State - Holds input and current state of scan converter.
// Filled in by setup.
//
//-----------------------------------------------------------------------------
struct _RRSCANCNVSTATE
{
    // primitive vertex data
    FLOAT fX0, fY0, fRHW0;
    FLOAT fX1, fY1, fRHW1;
    FLOAT fX2, fY2, fRHW2;
    // primitive transformed texture coord data
    FLOAT fTexCoord[D3DHAL_TSS_MAXSTAGES][3][4];
    FLOAT fRHQW[D3DHAL_TSS_MAXSTAGES][3];
    BOOL  bWrap[D3DHAL_TSS_MAXSTAGES][4];

    // x,y deltas
    FLOAT fDelX10, fDelX02, fDelX21;
    FLOAT fDelY01, fDelY20, fDelY12;

    // triangle edge functions and gradient data
    RREdgeFunc  EdgeFuncs[4];   // A,B,C values and A,B sign bits for 4 edges
                                // the fourth edge is only used to scan convert points

    // triangle bounding box
    INT16 iXMin, iXMax;
    INT16 iYMin, iYMax;

    // line drawing data
    INT64  iLineEdgeFunc[3];    // line function: Pminor = ([0]*Pmajor + [1])/[2]
    BOOL   bXMajor;             // TRUE if X major; else Y major
    INT16  iLineMin, iLineMax;  // min and max pixel extent in major direction
    INT16  iLineStep;           // +1 or -1 depending on line major direction

    // depth range for primitive (for clamp when sampling outside primitive area)
    // may be Z or W
    FLOAT fDepthMin, fDepthMax;

    //
    // attribute functions - static (per-primitive) data, non-texture,
    // and texture functions
    //
    RRAttribFuncStatic  AttribFuncStatic;

#define ATTRFUNC_R          0
#define ATTRFUNC_G          1
#define ATTRFUNC_B          2
#define ATTRFUNC_A          3
#define ATTRFUNC_SR         4
#define ATTRFUNC_SG         5
#define ATTRFUNC_SB         6
#define ATTRFUNC_SA         7
#define ATTRFUNC_F          8
#define ATTRFUNC_Z          9
#define RR_N_ATTRIBS        10
    RRAttribFunc AttribFuncs[RR_N_ATTRIBS];

#define TEXFUNC_0           0
#define TEXFUNC_1           1
#define TEXFUNC_2           2
#define TEXFUNC_3           3
#define RR_N_TEX_ATTRIBS    4
    RRAttribFunc TextureFuncs[D3DHAL_TSS_MAXSTAGES][RR_N_TEX_ATTRIBS];


    //
    // per-pixel data
    //

    // current position
    INT16 iX,iY;

};


//-----------------------------------------------------------------------------
//
// Texture
//
//-----------------------------------------------------------------------------

//
// structure containing texture coordinate and gradient information
// for lookup and filtering
//
class RRTextureCoord
{
public:
    FLOAT fU;       // texture coordinate
    FLOAT fV;
    FLOAT fDUDX;    // texture gradient dU/dX
    FLOAT fDUDY;    // texture gradient dU/dY
    FLOAT fDVDX;    // texture gradient dV/dX
    FLOAT fDVDY;    // texture gradient dV/dY
};

//
// structure containing normal and gradient information
// for environment map lookup and filtering
//
class RREnvTextureCoord
{
public:
    FLOAT fNX;       // normal or reflection normal
    FLOAT fNY;
    FLOAT fNZ;
//    FLOAT fENX;      // eye normal
//    FLOAT fENY;
//    FLOAT fENZ;
    FLOAT fDNXDX;    // normal gradient dNX/dX
    FLOAT fDNXDY;    // normal gradient dNX/dY
    FLOAT fDNYDX;    // normal gradient dNY/dX
    FLOAT fDNYDY;    // normal gradient dNY/dY
    FLOAT fDNZDX;    // normal gradient dNZ/dX
    FLOAT fDNZDY;    // normal gradient dNZ/dY
};

//
// routines to compute level of detail (texel->pixel coverage)
//
// (texfilt.cpp)
void
ComputeSimpleLevelOfDetail(
    const RRTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeEnvMapLevelOfDetail(
    const RRTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeAnisotropicLevelOfDetail(
    const RRTextureCoord& TCoord, FLOAT fMaxAniso,  //  inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );   //  outputs


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Engine                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// coverage mask values
#define TL_CVGFULL 0xffff
#define TL_CVGZERO 0x0000
#define TL_CVGBITS 16
#define TL_CVGBITSm 4

typedef UINT16 CVGMASK;

// fragment - fragmented pixels have linked lists of these
struct _RRFRAGMENT
{
    RRColor Color;
    RRDepth Depth;
    CVGMASK CvgMask;
    void* pNext;
};

int CountFrags(RRFRAGMENT* pFrag);
void DPFFrags(RRFRAGMENT* pFrag);

//-----------------------------------------------------------------------------
//
// Fragment Resolution Accumulator - accumulates fragments presented in
// front-to-back order; does fully correct transparency computations for
// non-opaque fragments
//
//-----------------------------------------------------------------------------
class FragResolveAccum
{
public:
    // coverage accumulation array - holds up to CVGBITS different
    // alpha values and associated coverage masks; UsageMask indicates
    // which entries are currently in use - each set bit in Usage mask
    // indicates that the array entry corresponding to the index of the
    // that bit holds a valid mask and alpha;
    //
    // the general idea here is that, in cases in which there are few
    // fragments, numerous sample locations (within the pixel) will have
    // the same alpha value, and thus can be grouped for the accumulation
    struct {
        CVGMASK Mask;
        FLOAT fAlpha;
    } m_CvgArray[TL_CVGBITS];
    CVGMASK m_ArrayUsageMask;

    // accumulated color and alpha value
    FLOAT m_fA, m_fR, m_fG, m_fB;

    // mask where set bit indicates a subpixel with opaque alpha
    CVGMASK m_CvgOpaqueMask;

    // reset before each use...
    void Reset( void );

    // accumulate new fragment (front to back) - returns TRUE if
    // full coverage achieved, FALSE otherwise
    BOOL Accum( const CVGMASK CvgMask, const RRColor& Color );

    // get RRColor from accumulator
    void GetColor( RRColor& Color );
};


//-----------------------------------------------------------------------------
//
// statistics
//
//-----------------------------------------------------------------------------
struct _RRSTATS
{
    INT32 cFragsAllocd;
    INT32 cMaxFragsAllocd;
    INT32 cFragsMerged;
    INT32 cFragsMergedToFull;
};


//-----------------------------------------------------------------------------
//
// utilities
//
//-----------------------------------------------------------------------------

// compute pixel address from base, pitch, and surface type
char*
PixelAddress( int iX, int iY, char* pBits, int iYPitch, RRSurfaceType SType );


//-----------------------------------------------------------------------------
//
// color interpolation utilities
//
//-----------------------------------------------------------------------------
void LerpColor(RRColor& Color,
    const RRColor& Color0, const RRColor& Color1, UINT8 uT);
void BiLerpColor( RRColor& OutColor,
    const RRColor& Color00, const RRColor& Color01,
    const RRColor& Color10, const RRColor& Color11,
    UINT8 uA, UINT8 uB);

//-----------------------------------------------------------------------------
//
// Globals
//
//-----------------------------------------------------------------------------

// something to experiment with sometime - this sets the threshold at which
// pixel samples are considered opaque (and thus don't generate fragment
// buffer entries when doing D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT);
// no need to have all those 0xfe's generate fragments...
extern UINT8 g_uTransparencyAlphaThreshold;

//-----------------------------------------------------------------------------
//
// One special legacy texture op we can't easily map into the new texture
// ops.
//
//-----------------------------------------------------------------------------

#define D3DTOP_LEGACY_ALPHAOVR  (0x7fffffff)

///////////////////////////////////////////////////////////////////////////////
#endif  // _REFRASTI_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\pixref.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// PixRef.cpp
//
// Direct3D Reference Rasterizer - Pixel Buffer Referencing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

extern int g_DXTBlkSize[];

//-----------------------------------------------------------------------------
//
// PixelAddress - Form character address of locations within buffers using base
// pointer, pitch and type.
//
//-----------------------------------------------------------------------------
char*
PixelAddress( int iX, int iY, char* pBits, int iYPitch, RRSurfaceType SType )
{
    // initialize return value to start of scan line (pitch is always in bytes)
    char* pPixAddr = pBits + iY*iYPitch;

    // bump along scan line depending on surface type to point to pixel data
    switch ( SType )
    {
    default:
        _ASSERTa(0, "Unknown RRSurfaceType value", return NULL;);
    case RR_STYPE_NULL:
        break;

    case RR_STYPE_B8G8R8A8:
    case RR_STYPE_B8G8R8X8:
    case RR_STYPE_Z24S8:
    case RR_STYPE_S8Z24:
    case RR_STYPE_Z24S4:
    case RR_STYPE_S4Z24:
    case RR_STYPE_Z32S0:
        pPixAddr += iX*4;
        break;

    case RR_STYPE_B5G6R5:
    case RR_STYPE_B5G5R5:
    case RR_STYPE_B5G5R5A1:
    case RR_STYPE_L8A8:
    case RR_STYPE_U8V8:
    case RR_STYPE_U5V5L6:
    case RR_STYPE_Z16S0:
    case RR_STYPE_Z15S1:
    case RR_STYPE_S1Z15:
    case RR_STYPE_B4G4R4A4:
    case RR_STYPE_YUY2:
    case RR_STYPE_UYVY:
    case RR_STYPE_B2G3R3A8:
        pPixAddr += iX*2;
        break;

    case RR_STYPE_B8G8R8:
    case RR_STYPE_U8V8L8:
        pPixAddr += iX*3;
        break;

    case RR_STYPE_PALETTE8:
    case RR_STYPE_L8:
    case RR_STYPE_B2G3R3:
    case RR_STYPE_L4A4:
        pPixAddr += iX;
        break;

    case RR_STYPE_PALETTE4:
        pPixAddr += (iX>>1);
        break;

    // For the DXT texture formats, obtain the address of the
    // block from whih to decompress the texel from
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        pPixAddr = pBits + (iY >> 2)*iYPitch + (iX>>2) *
            g_DXTBlkSize[(int)SType - (int)RR_STYPE_DXT1];
        break;
    }
    return pPixAddr;
}

//-----------------------------------------------------------------------------
//
// WritePixel - Writes pixel and (maybe) depth to current render target.
//
//  called by ReferenceRasterizer::DoPixel
//        and ReferenceRasterizer::DoBufferResolve
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::WritePixel(
    INT32 iX, INT32 iY,
    const RRColor& Color, const RRDepth& Depth)
{
    m_pRenderTarget->WritePixelColor( iX, iY, Color,
        m_dwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    // don't write if Z buffering disabled or Z write disabled
    if ( !( m_dwRenderState[D3DRENDERSTATE_ZENABLE     ] ) ||
         !( m_dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ) ) { return; }

    m_pRenderTarget->WritePixelDepth( iX, iY, Depth );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\refrasti.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrasti.cpp
//
// Direct3D Reference Rasterizer - Main Internal Object Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// global controls                                                              //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// alpha needs to be less than this for a pixel  to be considered non-opaque
UINT8 g_uTransparencyAlphaThreshold = 0xff;


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// ReferenceRasterizer Methods                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Overload new & delete for core object so that it can be allocated from
// caller-controlled pool
//
//-----------------------------------------------------------------------------
void*
ReferenceRasterizer::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(ReferenceRasterizer) );
    _ASSERTa( NULL != pMem, "malloc failure on RR object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor for renderer core object.
//
//-----------------------------------------------------------------------------
ReferenceRasterizer::ReferenceRasterizer( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                                          DWORD dwInterfaceType,
                                          RRDEVICETYPE dwDriverType )
{
    memset( this, 0, sizeof(*this) );

    // allocate scan converter state and statistics
    m_pSCS = (RRSCANCNVSTATE*)MEMALLOC( sizeof( *m_pSCS ) );
    m_pStt = (RRSTATS*)MEMALLOC( sizeof( *m_pStt ) );

    _ASSERTa( ( NULL != m_pSCS ) && ( NULL != m_pStt),
        "malloc failure on ReferenceRasterizer object", return; );

    // associate the (single) static attribute data structure with each attribute
    // function instance
    int i, j;
    for ( i = 0; i < RR_N_ATTRIBS; i++ )
    {
        m_pSCS->AttribFuncs[i].SetStaticDataPointer( &(m_pSCS->AttribFuncStatic) );
    }
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( j = 0; j < RR_N_TEX_ATTRIBS; j++)
        {
            m_pSCS->TextureFuncs[i][j].SetStaticDataPointer( &(m_pSCS->AttribFuncStatic) );
        }
    }

    // this is zero'ed above, so just set the 1.0 elements
    // of the identity matrices
    //
    //  0  1  2  3
    //  4  5  6  7
    //  8  9 10 11
    // 12 13 14 15
    //
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+0] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+5] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+10] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+15] = 1.0f;
    }

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    m_dwInterfaceType = dwInterfaceType;
    m_dwDriverType = dwDriverType;
    m_pDDLcl = pDDLcl;

    // defer allocating and clearing of fragment pointer buffer until fragments
    // are actually generated
    m_ppFragBuf = NULL;

    // Texture handles
    m_ppTextureArray = NULL;
    m_dwTexArrayLength = 0;

    // StateOverride initialize
    STATESET_INIT( m_renderstate_override );

    // Initialize TL state and Data
    InitTLData();

    SetSetStateFunctions();

    ClearTexturesLocked();
}
//-----------------------------------------------------------------------------
ReferenceRasterizer::~ReferenceRasterizer( void )
{
    MEMFREE( m_ppFragBuf );
    MEMFREE( m_pSCS);
    MEMFREE( m_pStt);

    // Clean up statesets
    for (DWORD i = 0; i < m_pStateSets.ArraySize(); i++)
    {
        if (m_pStateSets[i] != NULL)
            delete m_pStateSets[i];
    }

    // Free the Light Array
    if (m_pLightArray) delete m_pLightArray;

    // Free the Texture Array
    for (i = 0; i<m_dwTexArrayLength; i++)
    {
        RRTexture* pTex = m_ppTextureArray[i];
        if (pTex) delete pTex;
    }
    if (m_ppTextureArray) delete m_ppTextureArray;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// State Management Utilities                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// MapTextureHandleToDevice - This is called when texture handles change or
// when leaving legacy texture mode.  This maps the texture handle embedded
// in the per-stage state to texture object pointers.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapTextureHandleToDevice( int iStage )
{
    // map one
    m_pTexture[iStage] =
        MapHandleToTexture( m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] );

    // initialize m_pStageState pointer in texture
    if (m_pTexture[iStage])
    {
        m_pTexture[iStage]->m_pStageState = &m_TextureStageState[0];
    }

    // update num active stages
    UpdateActiveTexStageCount();
}


//-----------------------------------------------------------------------------
//
// GrowTexArray - On DX7.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::GrowTexArray( DWORD dwTexHandle )
{
    DWORD dwNewArraySize = dwTexHandle+16;
    RRTexture **ppTmpTexArray =
        (RRTexture **)MEMALLOC( dwNewArraySize*sizeof(RRTexture*) );
    if (ppTmpTexArray == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    memset( ppTmpTexArray, 0, dwNewArraySize*sizeof(RRTexture*) );

    // Save all the textures
    for (DWORD i=0; i<m_dwTexArrayLength; i++)
    {
        ppTmpTexArray[i] = m_ppTextureArray[i];
    }

    if (m_ppTextureArray)
    {
        delete m_ppTextureArray;
    }
    m_ppTextureArray = ppTmpTexArray;
    m_dwTexArrayLength = dwNewArraySize;
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// SetTextureHandle - On DX7, this is called when a texture handle is set.
// This maps the texture handle embedded in the per-stage state to texture
// object pointers.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::SetTextureHandle( int iStage, DWORD dwTexHandle )
{
    HRESULT hr = D3D_OK;

    // Special case, if texture handle == 0, then unmap the texture from the TSS
    if (dwTexHandle == 0)
    {
        m_pTexture[iStage] = NULL;

        // update num active stages
        UpdateActiveTexStageCount();
        return D3D_OK;
    }

    //
    // If the texture handle is greater than the length of the array,
    // the array needs to be grown.
    //
    if (dwTexHandle >= m_dwTexArrayLength)
    {
        HR_RET(GrowTexArray( dwTexHandle ));
    }

    // Ask DDraw to decipher what this particular handle meant wrt. to the
    // the DDraw_Local associated with this instance of the Refrast
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = NULL;
    BOOL bIsNew = FALSE;
    pDDSLcl = GetDDSurfaceLocal(m_pDDLcl, dwTexHandle, &bIsNew);

    //
    // If the particular array element is NULL it means that the
    // texture has not yet been created.
    //
    if (m_ppTextureArray[dwTexHandle] == NULL)
    {
        if (TextureCreate(dwTexHandle, &m_ppTextureArray[dwTexHandle])
            == FALSE)
        {
            return DDERR_OUTOFMEMORY;
        }

        HR_RET(m_ppTextureArray[dwTexHandle]->Initialize( pDDSLcl ));
    }
    // This means that the texture bound to the dwHandle is not the
    // same as what Refrast thinks it is, hence revalidate everything
    else if (bIsNew)
    {
        HR_RET(m_ppTextureArray[dwTexHandle]->Initialize( pDDSLcl ));
    }

    // map one
    m_pTexture[iStage] = m_ppTextureArray[dwTexHandle];

    // initialize m_pStageState pointer in texture
    if (m_pTexture[iStage])
    {
#if DBG
        int iTexCount = 0;
        for (int i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            if (m_pTexture[iStage] == m_pTexture[i])
            {
                iTexCount ++;
            }
        }
        if (iTexCount > 1)
        {
            DPFM(0,RAST,("Same texture handle was used more than once.\n"))
        }
#endif
        m_pTexture[iStage]->m_pStageState = &m_TextureStageState[0];
    }

    // update num active stages
    UpdateActiveTexStageCount();
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is always one.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::UpdateActiveTexStageCount( void )
{
    // always one active texture stage for legacy texture mode
    if ( NULL != m_dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
    {
        m_cActiveTextureStages = 1; return;
    }

    // count number of contiguous-from-zero active texture blend stages
    m_cActiveTextureStages = 0;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        // check fir disabled stage (subsequent are thus inactive)
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        // check for incorrectly enabled stage (may be legacy)
        if ( ( m_pTexture[iStage] == NULL ) &&
             ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1] == D3DTA_TEXTURE ) )
        {
            break;
        }

        // stage is active
        m_cActiveTextureStages++;
    }
}

//-----------------------------------------------------------------------------
//
// MapHandleToTexture - Map handle to RRTexture pointer.  Handle is a ppTex,
// so test it and reference it.
//
//-----------------------------------------------------------------------------
RRTexture*
ReferenceRasterizer::MapHandleToTexture( D3DTEXTUREHANDLE hTex )
{
    if ( 0x0 == hTex ) { return NULL; }
    return ( *(RRTexture**)ULongToPtr(hTex) );
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\rtarget.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rtarget.hpp
//
// Direct3D Reference Rasterizer - Render Target Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// overload new & delete so that it can be allocated from caller-controlled
// pool
//
//-----------------------------------------------------------------------------
void*
RRRenderTarget::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(RRRenderTarget) );
    _ASSERTa( NULL != pMem, "malloc failure on render target object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
RRRenderTarget::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RRRenderTarget::RRRenderTarget( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RRRenderTarget::~RRRenderTarget( void )
{
    // Release nothing because we didnt take any ref-counts,
    // simply return
    return;
}

//-----------------------------------------------------------------------------
//
// ReadPixelColor - Reads color buffer bits and expands out into an RRColor
// value.  Buffer types without alpha return a 1.0 value for alpha.  Low
// bits of <8 bit colors are returned as zero.
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelColor(
    INT32 iX, INT32 iY,
    RRColor& Color)
{
    if ( NULL == m_pColorBufBits ) return;

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
    Color.ConvertFrom( m_ColorSType, pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// WritePixelColor - Takes an RRColor value, formats it for the color buffer
// format, and writes the value into buffer.
//
// Dithering is applied here, when enabled, for <8 bits/channel surfaces.
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY,
    const RRColor& Color, BOOL bDither)
{
    if ( NULL == m_pColorBufBits ) return;

    // default to round to nearest
    FLOAT fRoundOffset = .5F;
    if ( bDither )
    {
        static  FLOAT fDitherTable[16] =
        {
            .0000f,  .5000f,  .1250f,  .6750f,
            .7500f,  .2500f,  .8750f,  .3750f,
            .1875f,  .6875f,  .0625f,  .5625f,
            .9375f,  .4375f,  .8125f,  .3125f
        };

        // form 4 bit offset into dither table (2 LSB's of x and y) and get offset
        unsigned uDitherOffset = ( ( iX << 2) & 0xc ) | (iY & 0x3 );
        fRoundOffset = fDitherTable[uDitherOffset];
    }

    char* pSurfaceBits = PixelAddress( iX, iY, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
    Color.ConvertTo( m_ColorSType, fRoundOffset, pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelDepth - Read/write depth buffer
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY,
    const RRDepth& Depth )
{
    // don't write if no Z buffer
    if ( NULL == m_pDepthBufBits ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch (m_DepthSType)
    {
    case RR_STYPE_Z16S0:
        *((UINT16*)pSurfaceBits) = UINT16(Depth);
        break;
    case RR_STYPE_Z24S8:
    case RR_STYPE_Z24S4:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xffffff00);
            uBufferBits |= (UINT32(Depth) << 8);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S8Z24:
    case RR_STYPE_S4Z24:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x00ffffff);
            uBufferBits |= (UINT32(Depth) & 0x00ffffff);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z15S1:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0xfffe);
            uBufferBits |= (UINT16(Depth) << 1);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S1Z15:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x7fff);
            uBufferBits |= (UINT16(Depth) & 0x7fff);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z32S0:
        *((UINT32*)pSurfaceBits) = UINT32(Depth);
        break;
    }
}
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelDepth(
    INT32 iX, INT32 iY,
    RRDepth& Depth )
{
    // don't read if no Z buffer
    if ( NULL == m_pDepthBufBits ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch (m_DepthSType)
    {
    case RR_STYPE_Z16S0:
        Depth = *((UINT16*)pSurfaceBits);
        break;
    case RR_STYPE_Z24S8:
    case RR_STYPE_Z24S4:
        // take upper 24 bits aligned to LSB
        Depth = ( *((UINT32*)pSurfaceBits) ) >> 8;
        break;
    case RR_STYPE_S8Z24:
    case RR_STYPE_S4Z24:
        // take lower 24 bits
        Depth = ( *((UINT32*)pSurfaceBits) ) & 0x00ffffff;
        break;
    case RR_STYPE_Z15S1:
        // take upper 15 bits aligned to LSB
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) >> 1);
        break;
    case RR_STYPE_S1Z15:
        // take lower 15 bits
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) & 0x7fff);
        break;
    case RR_STYPE_Z32S0:
        Depth = *((UINT32*)pSurfaceBits);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelStencil - Read/Write of stencil bits within depth buffer
// surface; write is done with read-modify-write so depth bits are not disturbed;
// stencil mask is applied outside
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY,
    UINT8 uStencil)
{
    // don't write if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepthBufBits) ||
        ((RR_STYPE_Z24S8 != m_DepthSType) &&
         (RR_STYPE_S8Z24 != m_DepthSType) &&
         (RR_STYPE_S1Z15 != m_DepthSType) &&
         (RR_STYPE_Z15S1 != m_DepthSType) &&
         (RR_STYPE_Z24S4 != m_DepthSType) &&
         (RR_STYPE_S4Z24 != m_DepthSType)) ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    // need to do read-modify-write to not step on Z
    switch(m_DepthSType)
    {
    case RR_STYPE_Z24S8:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= uStencil;
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S8Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= (uStencil << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z24S4:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= (uStencil & 0xf);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S4Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= ((uStencil & 0xf) << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z15S1:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x0001);
            uBufferBits |= uStencil & 0x1;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S1Z15:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x8000);
            uBufferBits |= uStencil << 15;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    }

}
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelStencil(
    INT32 iX, INT32 iY,
    UINT8& uStencil)
{
    // don't read if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepthBufBits) ||
        ((RR_STYPE_Z24S8 != m_DepthSType) &&
         (RR_STYPE_S8Z24 != m_DepthSType) &&
         (RR_STYPE_S1Z15 != m_DepthSType) &&
         (RR_STYPE_Z15S1 != m_DepthSType) &&
         (RR_STYPE_Z24S4 != m_DepthSType) &&
         (RR_STYPE_S4Z24 != m_DepthSType) ) ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch(m_DepthSType)
    {
    case RR_STYPE_Z24S8:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xff );
        break;
    case RR_STYPE_S8Z24:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) >> 24 );
        break;
    case RR_STYPE_Z15S1:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) & 0x1 );
        break;
    case RR_STYPE_S1Z15:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) >> 15 );
        break;
    case RR_STYPE_Z24S4:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xf );
        break;
    case RR_STYPE_S4Z24:
        uStencil = (UINT8)( ( ( *((UINT32*)pSurfaceBits) ) >> 24 ) & 0xf);
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\scancnv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// scancnv.cpp
//
// Direct3D Reference Rasterizer - Primitive Scan Conversion
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Scan Conversion Utilities                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ComputePixelAttrib(Clamp/Tex) - Evaluates given linear function at current
// scan conversion position (m_SCCS.iX,iY).  Return is FLOAT value.
//
// Clamp version clamps result to 0. to 1. range.
//
// Tex version does texture coordinate function (unclamped).
//
//-----------------------------------------------------------------------------
FLOAT
ReferenceRasterizer::ComputePixelAttrib( int iAttrib )
{
    return m_pSCS->AttribFuncs[iAttrib].Eval();
}
FLOAT
ReferenceRasterizer::ComputePixelAttribClamp( int iAttrib )
{
    FLOAT fValue = ComputePixelAttrib( iAttrib );
    fValue = MAX( MIN( fValue, 1. ), 0. );
    return fValue;
}
//
// iStage specifies set of transformed texture coordinates
// iCrd specifies which value within coord
FLOAT
ReferenceRasterizer::ComputePixelAttribTex( int iStage, int iCrd )
{
    return m_pSCS->TextureFuncs[iStage][iCrd].Eval(iStage);
}

//-----------------------------------------------------------------------------
//
// ComputeFogIntensity - Computes scalar fog intensity value and writes it to
// the RRPixel.FogIntensity value.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::ComputeFogIntensity( RRPixel& Pixel )
{
    FLOAT fFogDensity, fPow;
    FLOAT fFogStart, fFogEnd;

    // select fog index - this is either Z or W depending on the W range
    //
    // use Z if projection matrix is set to an affine projection, else use W
    // (both for perspective projection and an unset projection matrix - the
    // latter is preferred for legacy content which uses TLVERTEX)
    //
    FLOAT fFogIndex =
        ( ( 1.f == m_pRenderTarget->m_fWRange[0] ) &&
          ( 1.f == m_pRenderTarget->m_fWRange[1] ) )
        ? ( MAX( MIN( ComputePixelAttribClamp( ATTRFUNC_Z ),
                m_pSCS->fDepthMax ), m_pSCS->fDepthMin ) )  // use clamped Z for affine projection
        : ( Pixel.fW );                                     // use W for non-affine projection

    // compute fog intensity
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] )
    {
        // select between vertex and table fog - vertex fog is selected if
        // fog is enabled but the renderstate fog table mode is disabled
        switch ( m_dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] )
        {
        default:
        case D3DFOG_NONE:
            // table fog disabled, so use interpolated vertex fog value for fog intensity
            Pixel.FogIntensity = ComputePixelAttribClamp( ATTRFUNC_F );
            break;

        case D3DFOG_EXP:
            fFogDensity = m_fRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
            fPow = fFogDensity * fFogIndex;
            // note that exp(-x) returns a result in the range (0.0, 1.0]
            // for x >= 0
            Pixel.FogIntensity = (float)exp( -fPow );
            break;

        case D3DFOG_EXP2:
            fFogDensity = m_fRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
            fPow = fFogDensity * fFogIndex;
            Pixel.FogIntensity = (float)exp( -(fPow*fPow) );
            break;

        case D3DFOG_LINEAR:
            fFogStart = m_fRenderState[D3DRENDERSTATE_FOGTABLESTART];
            fFogEnd   = m_fRenderState[D3DRENDERSTATE_FOGTABLEEND];
            if (fFogIndex >= fFogEnd)
            {
                Pixel.FogIntensity = 0.0f;
            }
            else if (fFogIndex <= fFogStart)
            {
                Pixel.FogIntensity = 1.0f;
            }
            else
            {
                Pixel.FogIntensity = ( fFogEnd - fFogIndex ) / ( fFogEnd - fFogStart );
            }
            break;
        }
    }
}


//-----------------------------------------------------------------------------
//
// DoScanCnvGenPixel - This is called for each generated pixel, and extracts and
// processes attributes from the interpolator state, and passes the pixels on to
// the pixel processing module.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvGenPixel( RRCvgMask CvgMask, BOOL bTri )
{
    // set per-pixel state for attribute evaluators
    m_pSCS->AttribFuncStatic.SetPerPixelData( m_pSCS->iX, m_pSCS->iY );

    // instantiate and fill out pixel struct
    RRPixel Pixel;
    memset(&Pixel, 0, sizeof(Pixel));
    Pixel.iX = m_pSCS->iX;
    Pixel.iY = m_pSCS->iY;
    Pixel.fW = m_pSCS->AttribFuncStatic.GetPixelW();
    Pixel.CvgMask = CvgMask;
    Pixel.Depth.SetSType(m_pRenderTarget->m_DepthSType);

    // get depth from clamp interpolator and clamp
    if ( m_dwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_dwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        if ( D3DZB_USEW == m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
        {
            // depth buffering with W value
            FLOAT fW = Pixel.fW;

            // clamp to primitive range (due to sampling outside primitive for antialiasing)
            // (triangles only)
            if ( bTri )
            {
                fW = MAX( MIN( fW, m_pSCS->fDepthMax ), m_pSCS->fDepthMin );
            }

            // apply normalization to get to 0. to 1. range
            fW = (fW - m_fWBufferNorm[0]) * m_fWBufferNorm[1];

            Pixel.Depth = fW;
        }
        else
        {
            // depth buffering with Z value
            FLOAT fZ = ComputePixelAttribClamp( ATTRFUNC_Z );

            // clamp to primitive range (due to sampling outside primitive for antialiasing)
            // (triangles only)
            if ( bTri )
            {
                fZ = MAX( MIN( fZ, m_pSCS->fDepthMax ), m_pSCS->fDepthMin );
            }

            Pixel.Depth = fZ;
        }

        // snap off extra bits by converting to/from buffer format
        //
        // this is mainly because of storing RRDepth values in the fragment buffer
        // and then comparing these (higher resolution) values to the buffer value
        // when forming the fragment lists at each pixel - cleanly snapping off the
        // extra bits here solves this problem
        //
        switch ( m_pRenderTarget->m_DepthSType)
        {
        case RR_STYPE_Z16S0: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_Z24S4:
        case RR_STYPE_Z24S8: Pixel.Depth = UINT32( Pixel.Depth ); break;
        case RR_STYPE_Z15S1: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_Z32S0: Pixel.Depth = UINT32( Pixel.Depth ); break;
        case RR_STYPE_S1Z15: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_S4Z24:
        case RR_STYPE_S8Z24: Pixel.Depth = UINT32( Pixel.Depth ); break;
        }
    }

    // set pixel diffuse color from clamped interpolator values
    Pixel.Color.A = ComputePixelAttribClamp( ATTRFUNC_A );
    Pixel.Color.R = ComputePixelAttribClamp( ATTRFUNC_R );
    Pixel.Color.G = ComputePixelAttribClamp( ATTRFUNC_G );
    Pixel.Color.B = ComputePixelAttribClamp( ATTRFUNC_B );

    // set pixel specular color from clamped interpolator values
    if ( m_qwFVFControl & D3DFVF_SPECULAR )
    {
        Pixel.Specular.A = ComputePixelAttribClamp( ATTRFUNC_SA );
        Pixel.Specular.R = ComputePixelAttribClamp( ATTRFUNC_SR );
        Pixel.Specular.G = ComputePixelAttribClamp( ATTRFUNC_SG );
        Pixel.Specular.B = ComputePixelAttribClamp( ATTRFUNC_SB );
    }

    // compute fog intensity
    ComputeFogIntensity( Pixel );

    // send to pixel processor
    DoPixel( Pixel );
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Scan Conversion                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoScanCnvTri - Scans the bounding box of the triangle and generates pixels.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvTri( int iEdgeCount )
{
    DPFM(3,RAST,("DoScanCnvTri:\n"))

    //
    // do simple scan of surface-intersected triangle bounding box
    //
    for ( m_pSCS->iY = m_pSCS->iYMin;
          m_pSCS->iY <= m_pSCS->iYMax;
          m_pSCS->iY++ )
    {
        for ( m_pSCS->iX = m_pSCS->iXMin;
              m_pSCS->iX <= m_pSCS->iXMax;
              m_pSCS->iX++ )
        {
            RRCvgMask CvgMask = 0xFFFF; // assume pixel is inside all edges

            for ( int iEdge=0; iEdge<iEdgeCount; iEdge++ )
            {
                if ( m_bFragmentProcessingEnabled )
                {
                    CvgMask &= m_pSCS->EdgeFuncs[iEdge].AATest( m_pSCS->iX, m_pSCS->iY) ;
                }
                else
                {
                    CvgMask &= m_pSCS->EdgeFuncs[iEdge].PSTest( m_pSCS->iX, m_pSCS->iY) ;
                }
            }

            if ( CvgMask != 0x0000 )
            {
                // pixel is not out, so process it
                DoScanCnvGenPixel( CvgMask, TRUE );
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Scan Conversion                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.  Always returns true if wRepeatFactor is 0, which
// means pattern is disabled.
//
//----------------------------------------------------------------------------

static BOOL LinePatternStateMachine(DWORD dwLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    union
    {
        D3DLINEPATTERN LPat;
        DWORD dwLPat;
    } LinePat;
    LinePat.dwLPat = dwLinePattern;

    if (LinePat.LPat.wRepeatFactor)
    {
        WORD wBit = (LinePat.LPat.wLinePattern >> wPatterni) & 1;
        if (++wRepeati >= LinePat.LPat.wRepeatFactor)
        {
            wRepeati = 0;
            wPatterni = (wPatterni+1) & 0xf;
        }
        return (BOOL)wBit;
    }
    else
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------------
//
// DivRoundDown(A,B) = ceiling(A/B - 1/2)
//
// ceiling(A/B - 1/2) == floor(A/B + 1/2 - epsilon)
// == floor( (A + (B/2 - epsilon))/B )
//
// Does correct thing for all sign combinations of A and B.
//
//-----------------------------------------------------------------------------
INT64 DivRoundDown(INT64 iA, INT32 iB)
{
    INT32 i = 0;
    static const INT32 iEps[3] =
    {
        1,      // iA > 0, iB > 0
        0,      // iA < 0, iB > 0  OR iA > 0, iB < 0
        1       // iA < 0, iB < 0
    };
    if (iA < 0)
    {
        i++;
        iA = -iA;
    }
    if (iB < 0)
    {
        i++;
        iB = -iB;
    }
    iA += (iB-iEps[i]) >> 1;
    iA /= iB;
    if (iEps[i] == 0)
        iA = -iA;
    return(iA);
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvLine( void )
{
    DPFM(3,RAST,("DoScanCnvLine:\n"))

    // step in major axis
    INT16 iMajorCoord = m_pSCS->iLineMin;
    int cSteps = abs( m_pSCS->iLineMax - m_pSCS->iLineMin );
    // state for line pattern state machine
    WORD wRepeati = 0;
    WORD wPatterni = 0;

    for ( int cStep = 0; cStep <= cSteps; cStep++ )
    {
        // evaluate line function to compute minor coord for this major
        INT64 iMinorCoord =
            ( ( m_pSCS->iLineEdgeFunc[0] * (INT64)(iMajorCoord<<4) ) + m_pSCS->iLineEdgeFunc[1] );
        iMinorCoord = DivRoundDown(iMinorCoord, m_pSCS->iLineEdgeFunc[2]<<4);

        m_pSCS->iX = m_pSCS->bXMajor ? iMajorCoord : iMinorCoord;
        m_pSCS->iY = m_pSCS->bXMajor ? iMinorCoord : iMajorCoord;

        // check if the point is inside the viewport
        if ( ( m_pSCS->iX >= m_pRenderTarget->m_Clip.left   ) &&
             ( m_pSCS->iX <= m_pRenderTarget->m_Clip.right  ) &&
             ( m_pSCS->iY >= m_pRenderTarget->m_Clip.top    ) &&
             ( m_pSCS->iY <= m_pRenderTarget->m_Clip.bottom ) )
        {
            // The line pattern should have been walked in from its origin, which may have been
            // offscreen, to be completely correct.
            if (LinePatternStateMachine(m_dwRenderState[D3DRENDERSTATE_LINEPATTERN], wRepeati, wPatterni))
            {
                DoScanCnvGenPixel( 0xFFFF, FALSE );
            }
        }

        iMajorCoord += m_pSCS->iLineStep;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\shadow.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1997.
//
// shadow.cpp
//
// Direct3D Reference Rasterizer - Shadow Mapping Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Fast but adequate 16 bit linear congruential random number generators
//
// fRand returns 0.0 to 1.0, fRand2 returns -1.0 to 1.0
//
//-----------------------------------------------------------------------------
static UINT16 _uRandDum = 123;
static FLOAT fRand(void)
{
//   Slower 32 bit LC random number generator
//   static long _uRandDum = 123;
//   idum = 1664525L*_uRandDum + 1013904223L;

    _uRandDum = 25173*_uRandDum + 13849;
    return ((FLOAT)_uRandDum/(FLOAT)0xffff);
}
//
static FLOAT fRand2(void)
{
    _uRandDum = 25173*_uRandDum + 13849;
    return ((FLOAT)_uRandDum/(FLOAT)0x8000) - 1.0F;
}

//-----------------------------------------------------------------------------
//
// DoShadow - Performs Shadow Z buffer Algorithm on a per-fragment basis.
//
//-----------------------------------------------------------------------------
void RRTexture::DoShadow(INT32 iStage, FLOAT* pfCoord, RRColor& OutputColor)
{
#ifdef __SHADOWBUFFER
    FLOAT fW = pfCoord[3];

    // set output color to white in case there is no attenuation
    OutputColor = 0xffffffff;

    // don't shadow behind the light
    if (fW > 0.0F)
    {
        // these are already multiplied by fW
        FLOAT fU = pfCoord[0];
        FLOAT fV = pfCoord[1];
        FLOAT fZ = pfCoord[2];

        /////////////////////////////////////////////////
        // Do shadow filter
        /////////////////////////////////////////////////
        fZ -= m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMIN];
        FLOAT fZRange = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMAX] -
            m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMIN];
        if (fZ >= 0.0F)
        {
            FLOAT fShad;
            FLOAT fAtten = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWATTENUATION];
            if (fZ > 1.0F)
            {
                // full shadow
                fShad = fAtten;
            }
            else
            {
                INT32 iFilterSize = m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] - D3DTFG_SHADOW_1 + 1;
                UINT32 uFilterArea = iFilterSize*iFilterSize;
                INT32 iMaskU = m_iWidth - 1;
                INT32 iMaskV = m_iHeight - 1;
                FLOAT fUCenter = (fU * m_iWidth/2) + m_iWidth/2;
                FLOAT fVCenter = (-fV * m_iHeight/2) + m_iHeight/2;
                INT32 u, v;
                UINT32 uShad = 0;

                for (v = -(iFilterSize-1)/2; v <= iFilterSize/2; v++)
                {
                    for (u = -(iFilterSize-1)/2; u <= iFilterSize/2; u++)
                    {

                        // Now, do U, V jitter
                        FLOAT fU = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWSIZE]*fRand2();
                        FLOAT fV = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWSIZE]*fRand2();

                        // add offset to center of sample
                        fU += fUCenter;
                        fV += fVCenter;

                        INT32 iU = u + (INT32)fU;
                        INT32 iV = v + (INT32)fV;

                        if (((iU & ~iMaskU) == 0) && ((iV & ~iMaskV) == 0)) {
                            FLOAT fZJit = fZRange*fRand();
                            RRColor Texel;
                            BOOL bColorKeyMatched;  // ignore this for shadow mapping
                            ReadColor( iU, iV, 0, Texel, bColorKeyMatched );
                            if ( fZ > (FLOAT(Texel.G) + fZJit) ) {
                                // in shadow
                                uShad++;
                            }
                        }
                    }
                }

                fShad = (FLOAT)(uFilterArea - uShad);
                fShad = (1.0F - fAtten)*fShad/(FLOAT)uFilterArea + fAtten;
                fShad = min(fShad, 1.0F);
            }

            if (fShad < 1.0F)
            {
                OutputColor.A = fShad;
                OutputColor.R = fShad;
                OutputColor.G = fShad;
                OutputColor.B = fShad;
            }
        }
    }
#endif //__SHADOWBUFFER
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\setup.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// setup.cpp
//
// Direct3D Reference Rasterizer - Primitive Setup
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// SetPrimitiveAttributeFunctions - Common routine to compute attribute
// functions used for triangles, lines, and points.  (This could be done more
// efficiently for lines and points...).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetPrimitiveAttributeFunctions(
    const RRFVFExtractor& Vtx0,
    const RRFVFExtractor& Vtx1,
    const RRFVFExtractor& Vtx2,
    const RRFVFExtractor& VtxFlat )
{

    // compute depth function
    m_pSCS->AttribFuncs[ATTRFUNC_Z].SetLinearFunc( Vtx0.GetZ(), Vtx1.GetZ(), Vtx2.GetZ() );

    // compute depth range for primitive (needed because we may sample slightly outside
    // the primitive when antialiasing which is generally OK for color and texture indices
    // but not for depth buffering)
    if ( D3DZB_USEW == m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
    {
        // using W for depth buffering
        FLOAT fW0 = 1./Vtx0.GetRHW();
        FLOAT fW1 = 1./Vtx1.GetRHW();
        FLOAT fW2 = 1./Vtx2.GetRHW();
        m_pSCS->fDepthMin = MIN( fW0, fW1 );
        m_pSCS->fDepthMin = MIN( m_pSCS->fDepthMin, fW2 );
        m_pSCS->fDepthMax = MAX( fW0, fW1 );
        m_pSCS->fDepthMax = MAX( m_pSCS->fDepthMax, fW2 );
    }
    else
    {
        // using Z for depth buffering
        m_pSCS->fDepthMin = MIN( Vtx0.GetZ(), Vtx1.GetZ() );
        m_pSCS->fDepthMin = MIN( m_pSCS->fDepthMin, Vtx2.GetZ() );
        m_pSCS->fDepthMax = MAX( Vtx0.GetZ(), Vtx1.GetZ() );
        m_pSCS->fDepthMax = MAX( m_pSCS->fDepthMax, Vtx2.GetZ() );
    }

    // compute diffuse color functions
    if ( D3DSHADE_FLAT != m_dwRenderState[D3DRENDERSTATE_SHADEMODE] )
    {
        RRColor VtxColor0( Vtx0.GetDiffuse() );
        RRColor VtxColor1( Vtx1.GetDiffuse() );
        RRColor VtxColor2( Vtx2.GetDiffuse() );
        m_pSCS->AttribFuncs[ATTRFUNC_R].SetPerspFunc( VtxColor0.R, VtxColor1.R, VtxColor2.R );
        m_pSCS->AttribFuncs[ATTRFUNC_G].SetPerspFunc( VtxColor0.G, VtxColor1.G, VtxColor2.G );
        m_pSCS->AttribFuncs[ATTRFUNC_B].SetPerspFunc( VtxColor0.B, VtxColor1.B, VtxColor2.B );
        m_pSCS->AttribFuncs[ATTRFUNC_A].SetPerspFunc( VtxColor0.A, VtxColor1.A, VtxColor2.A );
    }
    else
    {
        RRColor VtxColor0( VtxFlat.GetDiffuse() );
        m_pSCS->AttribFuncs[ATTRFUNC_R].SetConstant( VtxColor0.R );
        m_pSCS->AttribFuncs[ATTRFUNC_G].SetConstant( VtxColor0.G );
        m_pSCS->AttribFuncs[ATTRFUNC_B].SetConstant( VtxColor0.B );
        m_pSCS->AttribFuncs[ATTRFUNC_A].SetConstant( VtxColor0.A );
    }

    // compute specular functions
    if ( m_qwFVFControl & D3DFVF_SPECULAR  )
    {
        if ( D3DSHADE_FLAT != m_dwRenderState[D3DRENDERSTATE_SHADEMODE] )
        {
            RRColor VtxSpecular0( Vtx0.GetSpecular() );
            RRColor VtxSpecular1( Vtx1.GetSpecular() );
            RRColor VtxSpecular2( Vtx2.GetSpecular() );
            m_pSCS->AttribFuncs[ATTRFUNC_SR].SetPerspFunc( VtxSpecular0.R, VtxSpecular1.R, VtxSpecular2.R );
            m_pSCS->AttribFuncs[ATTRFUNC_SG].SetPerspFunc( VtxSpecular0.G, VtxSpecular1.G, VtxSpecular2.G );
            m_pSCS->AttribFuncs[ATTRFUNC_SB].SetPerspFunc( VtxSpecular0.B, VtxSpecular1.B, VtxSpecular2.B );
            m_pSCS->AttribFuncs[ATTRFUNC_SA].SetPerspFunc( VtxSpecular0.A, VtxSpecular1.A, VtxSpecular2.A );
        }
        else
        {
            RRColor VtxSpecular0( VtxFlat.GetSpecular() );
            m_pSCS->AttribFuncs[ATTRFUNC_SR].SetConstant( VtxSpecular0.R );
            m_pSCS->AttribFuncs[ATTRFUNC_SG].SetConstant( VtxSpecular0.G );
            m_pSCS->AttribFuncs[ATTRFUNC_SB].SetConstant( VtxSpecular0.B );
            m_pSCS->AttribFuncs[ATTRFUNC_SA].SetConstant( VtxSpecular0.A );
        }
    }

    // compute vertex fog function
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] &&
         ( m_dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] == D3DFOG_NONE ) )
    {
        FLOAT fF0 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx0.GetSpecular() );
        FLOAT fF1 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx1.GetSpecular() );
        FLOAT fF2 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx2.GetSpecular() );
        m_pSCS->AttribFuncs[ATTRFUNC_F].SetPerspFunc( fF0, fF1, fF2 );
    }

    // compute functions for all potential texture coordinates
    for(INT32 iStage = 0; iStage < m_cActiveTextureStages; iStage++)
    {
        for(INT32 i = 0; i < 4; i++)
        {
            if (m_pTexture[iStage])
            {
                m_pSCS->TextureFuncs[iStage][TEXFUNC_0 + i].SetPerspFunc(
                    m_pSCS->fTexCoord[iStage][0][i],
                    m_pSCS->fTexCoord[iStage][1][i],
                    m_pSCS->fTexCoord[iStage][2][i], m_pSCS->bWrap[iStage][i],
                    ((m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP) != 0));
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Drawing                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoAreaCalcs - Takes 3 vertices and does screen area computations.
// Saves x, y, w's in RRSCANCNVSTATE, computes determinant, and does
// screen bounding box calculations.  Returns TRUE if the triangle is visible,
// FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL ReferenceRasterizer::DoAreaCalcs(FLOAT* pfDet, RRFVFExtractor* pVtx0,
                                      RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2)
{
    // set vertex data
    m_pSCS->fX0   = pVtx0->GetX();
    m_pSCS->fY0   = pVtx0->GetY();
    m_pSCS->fRHW0 = pVtx0->GetRHW();
    m_pSCS->fX1   = pVtx1->GetX();
    m_pSCS->fY1   = pVtx1->GetY();
    m_pSCS->fRHW1 = pVtx1->GetRHW();
    m_pSCS->fX2   = pVtx2->GetX();
    m_pSCS->fY2   = pVtx2->GetY();
    m_pSCS->fRHW2 = pVtx2->GetRHW();

    // compute determinant
    *pfDet = ComputeDeterminant(
        m_pSCS->fX0, m_pSCS->fY0,
        m_pSCS->fX1, m_pSCS->fY1,
        m_pSCS->fX2, m_pSCS->fY2 );

    if ( 0. == *pfDet ) { return FALSE; } // bail out if degenerate (no area)

    //
    // compute bounding box for scan area
    //
    FLOAT fXMin = MIN( m_pSCS->fX0, MIN( m_pSCS->fX1, m_pSCS->fX2 ) );
    FLOAT fXMax = MAX( m_pSCS->fX0, MAX( m_pSCS->fX1, m_pSCS->fX2 ) );
    FLOAT fYMin = MIN( m_pSCS->fY0, MIN( m_pSCS->fY1, m_pSCS->fY2 ) );
    FLOAT fYMax = MAX( m_pSCS->fY0, MAX( m_pSCS->fY1, m_pSCS->fY2 ) );
    // convert to integer (round to +inf)
    m_pSCS->iXMin = (INT16)(fXMin+.5);
    m_pSCS->iXMax = (INT16)(fXMax+.5);
    m_pSCS->iYMin = (INT16)(fYMin+.5);
    m_pSCS->iYMax = (INT16)(fYMax+.5);

    // clip bbox to rendering surface
    m_pSCS->iXMin = MAX( m_pSCS->iXMin, m_pRenderTarget->m_Clip.left   );
    m_pSCS->iXMax = MIN( m_pSCS->iXMax, m_pRenderTarget->m_Clip.right  );
    m_pSCS->iYMin = MAX( m_pSCS->iYMin, m_pRenderTarget->m_Clip.top    );
    m_pSCS->iYMax = MIN( m_pSCS->iYMax, m_pRenderTarget->m_Clip.bottom );

    // reject if no coverage
    if ( ( m_pSCS->iXMin < m_pRenderTarget->m_Clip.left   ) ||
         ( m_pSCS->iXMax > m_pRenderTarget->m_Clip.right  ) ||
         ( m_pSCS->iYMin < m_pRenderTarget->m_Clip.top    ) ||
         ( m_pSCS->iYMax > m_pRenderTarget->m_Clip.bottom ) )
    {
        return FALSE;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoTexCoordCalcs - Takes 2 or 3 vertices and does texture coordinate setup.
// Sets up wrap flags, and conditionally does texture transform.
//
//-----------------------------------------------------------------------------
void ReferenceRasterizer::DoTexCoordCalcs(INT32 iStage, RRFVFExtractor* pVtx0,
                                      RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2)
{
    INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
    INT32 iTexGen = iCoordSet & 0xffff0000;
    iCoordSet &= 0xffff;

    // map per-coordinate set WRAP controls into per-stage WRAP controls
    m_pSCS->bWrap[iStage][0] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<0))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][1] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<1))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][2] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<2))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][3] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<3))?TRUE:FALSE;

    INT32 iNumCoords = 0;
    switch (D3DFVF_GETTEXCOORDSIZE(m_qwFVFControl, iCoordSet))
    {
    case D3DFVF_TEXTUREFORMAT1: iNumCoords = 1; break;
    case D3DFVF_TEXTUREFORMAT2: iNumCoords = 2; break;
    case D3DFVF_TEXTUREFORMAT3: iNumCoords = 3; break;
    case D3DFVF_TEXTUREFORMAT4: iNumCoords = 4; break;
    }

    FLOAT fTexGen[3][3];
    if (iTexGen != D3DTSS_TCI_PASSTHRU)
    {
        iNumCoords = 3;
        RRFVFExtractor* ppVtx[3] = { pVtx0, pVtx1, pVtx2 };

        for (INT32 i = 0; i < 3; i++)
        {
            if (ppVtx[i])
            {
                switch (iTexGen)
                {
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    fTexGen[i][0] = ppVtx[i]->GetEyeNormal(0);
                    fTexGen[i][1] = ppVtx[i]->GetEyeNormal(1);
                    fTexGen[i][2] = ppVtx[i]->GetEyeNormal(2);
                    break;

                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    fTexGen[i][0] = ppVtx[i]->GetEyeXYZ(0);
                    fTexGen[i][1] = ppVtx[i]->GetEyeXYZ(1);
                    fTexGen[i][2] = ppVtx[i]->GetEyeXYZ(2);
                    break;

                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                    {
                        FLOAT fNX = ppVtx[i]->GetEyeNormal(0);
                        FLOAT fNY = ppVtx[i]->GetEyeNormal(1);
                        FLOAT fNZ = ppVtx[i]->GetEyeNormal(2);

                        if( GetRenderState()[D3DRENDERSTATE_LOCALVIEWER] == TRUE )
                        {
                            FLOAT fX = ppVtx[i]->GetEyeXYZ(0);
                            FLOAT fY = ppVtx[i]->GetEyeXYZ(1);
                            FLOAT fZ = ppVtx[i]->GetEyeXYZ(2);

                            // have to normalize before we reflect,
                            // result will be normalized
                            FLOAT fNorm = 1.0f/(FLOAT)sqrt(fX*fX + fY*fY + fZ*fZ);
                            fX *= fNorm; fY *= fNorm; fZ *= fNorm;
                            FLOAT fDot2 = 2.0f*(fX*fNX + fY*fNY + fZ*fNZ);
                            fTexGen[i][0] = fX - fNX*fDot2;
                            fTexGen[i][1] = fY - fNY*fDot2;
                            fTexGen[i][2] = fZ - fNZ*fDot2;
                        }
                        else
                        {
                            FLOAT fDot2 = 2.0f*fNZ;
                            fTexGen[i][0] = -fNX*fDot2;
                            fTexGen[i][1] = -fNY*fDot2;
                            fTexGen[i][2] = 1.f - fNZ*fDot2;
                        }

                    }
                    break;
                }
            }
        }
    }

    FLOAT fC[3][4];
    for (INT32 i = 0; i < 4; i++)
    {
        if (i < iNumCoords)
        {
            if (iTexGen != D3DTSS_TCI_PASSTHRU)
            {
                fC[0][i] = fTexGen[0][i];
                fC[1][i] = fTexGen[1][i];
                fC[2][i] = fTexGen[2][i];
            }
            else
            {
                fC[0][i] = pVtx0->GetTexCrd(i, iCoordSet);
                fC[1][i] = pVtx1->GetTexCrd(i, iCoordSet);
                if (pVtx2)
                {
                    fC[2][i] = pVtx2->GetTexCrd(i, iCoordSet);
                }
            }
        }
        else
        {
            if (i == iNumCoords)
            {
                fC[0][i] = 1.0f;
                fC[1][i] = 1.0f;
                fC[2][i] = 1.0f;
            }
            else
            {
                fC[0][i] = 0.0f;
                fC[1][i] = 0.0f;
                fC[2][i] = 0.0f;
            }
        }
    }

        // Do texture transform only if the original
    // vertices passed to the refrast were untransformed
    BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );
    if (m_bPointSprite)
    {
        // disable texture transform if in point sprite mode
        bAlreadyXfmd = TRUE;
    }

    m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[0],
        m_pSCS->fTexCoord[iStage][0], &m_pSCS->fRHQW[iStage][0] );
    m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[1],
        m_pSCS->fTexCoord[iStage][1], &m_pSCS->fRHQW[iStage][1] );
    if (pVtx2)
    {
        m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[2],
            m_pSCS->fTexCoord[iStage][2], &m_pSCS->fRHQW[iStage][2] );
    }
    // shadow map interpolation must not envolve the W of the current
    // (viewing) perspective transform
    if ((m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP) == 0)
    {
        m_pSCS->fRHQW[iStage][0] *= m_pSCS->fRHW0;
        m_pSCS->fRHQW[iStage][1] *= m_pSCS->fRHW1;
        if (pVtx2)
        {
            m_pSCS->fRHQW[iStage][2] *= m_pSCS->fRHW2;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DrawTriangle - Takes three vertices and does triangle setup, setting the
// primitive structure which is input to the triangle scanner, then
// invokes the scan conversion.
//
// This computes the triangle determinant (for culling and normalization) and
// the normalized edge distance and attribute functions.
//
// wFlags - Edge (and other) flags.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DrawTriangle(
   void* pvV0, void* pvV1, void* pvV2, WORD wFlags )
{
    DPFM(3, SETUP, ("DrawTriangle:\n"));

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx2( pvV2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    FLOAT fDet;
    if (DoAreaCalcs(&fDet, &Vtx0, &Vtx1, &Vtx2) == FALSE)
    {
        return;
    }

    // do culling
    if (!m_bPointSprite)
    {
        switch ( m_dwRenderState[D3DRENDERSTATE_CULLMODE] )
        {
        case D3DCULL_NONE:  break;
        case D3DCULL_CW:    if ( fDet > 0. )  { return; }  break;
        case D3DCULL_CCW:   if ( fDet < 0. )  { return; }  break;
        }
    }

    //
    // process point and wireframe fill mode
    //
    if (!m_bPointSprite)
    {
        if ( m_dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT )
        {
            DrawPoint( pvV0, pvV0 );
            DrawPoint( pvV1, pvV0 );
            DrawPoint( pvV2, pvV0 );
            return;
        }
        else if ( m_dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME )
        {
            if ( wFlags & D3DTRIFLAG_EDGEENABLE1 ) { DrawLine( pvV0, pvV1, pvV0 ); }
            if ( wFlags & D3DTRIFLAG_EDGEENABLE2 ) { DrawLine( pvV1, pvV2, pvV0 ); }
            if ( wFlags & D3DTRIFLAG_EDGEENABLE3 ) { DrawLine( pvV2, pvV0, pvV0 ); }
            return;
        }
    }

    //
    // compute edge functions
    //
    m_pSCS->EdgeFuncs[0].Set( m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fX1, m_pSCS->fY1,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[1].Set( m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fX2, m_pSCS->fY2,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[2].Set( m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fX0, m_pSCS->fY0,
        fDet, m_bFragmentProcessingEnabled );

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, &Vtx2);
            }
        }
    }

    // set attribute function static data to values for this triangle
    m_pSCS->AttribFuncStatic.SetPerTriangleData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fRHW2,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fDet );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx2, Vtx0 );

    // not culled, so rasterize it
    DoScanCnvTri(3);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Drawing                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PointDiamondCheck - Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is pixel-relative
// test - this corresponds to an upper-left test for a vertex-relative position.
//
//-----------------------------------------------------------------------------
BOOL
PointDiamondCheck(
    INT32 iXFrac, INT32 iYFrac,
    BOOL bSlopeIsOne, BOOL bSlopeIsPosOne )
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf ) return TRUE;

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
        return TRUE;

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
        return TRUE;

    // return true if slope is one, vertex is on edge, and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
            return TRUE;

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
            return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DrawLine - Takes two vertices and draws a line.
//
// This implements the Grid Intersect Quanization (GIQ) convention (which is
// also used in Windows).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DrawLine(
   void* pvV0, void* pvV1, void* pvVFlat )
{
    DPFM(3, SETUP, ("DrawLine:\n"));

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor VtxFlat( ( ( NULL != pvVFlat ) ? pvVFlat : pvV0 ),
        m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    // set vertex data
    m_pSCS->fX0   = Vtx0.GetX();
    m_pSCS->fY0   = Vtx0.GetY();
    m_pSCS->fRHW0 = Vtx0.GetRHW();
    m_pSCS->fX1   = Vtx1.GetX();
    m_pSCS->fY1   = Vtx1.GetY();
    m_pSCS->fRHW1 = Vtx1.GetRHW();

    // compute n.4 fixed point vertex values
    INT32 iX0 = AS_INT32( (DOUBLE)m_pSCS->fX0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)m_pSCS->fX1 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)m_pSCS->fY0 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)m_pSCS->fY1 + DOUBLE_4_SNAP );

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // TODO: is this right???
    if ( ( iXSize == 0 ) && ( iYSize == 0 ) ) { return; }

    // determine major direction and compute line function
    FLOAT fLineMajorExtent; // signed extent from V0 to V1 in major direction
    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( labs( iXSize ) >= labs( iYSize )  )
    {
        // here for X major
        m_pSCS->bXMajor = TRUE;
        fLineMajorExtent = (FLOAT)iXSize * (1./16.);

        // line function: y = F(x) = ( [0]*x + [1] ) / [2]
        m_pSCS->iLineEdgeFunc[0] = iYSize;
        m_pSCS->iLineEdgeFunc[1] = (INT64)iY0*(INT64)iX1 - (INT64)iY1*(INT64)iX0;
        m_pSCS->iLineEdgeFunc[2] = iXSize;
    }
    else
    {
        // here for Y major
        m_pSCS->bXMajor = FALSE;
        fLineMajorExtent = (FLOAT)iYSize * (1./16.);

        // line function: x = F(y) = ( [0]*y + [1] ) / [2]
        m_pSCS->iLineEdgeFunc[0] = iXSize;
        m_pSCS->iLineEdgeFunc[1] = (INT64)iX0*(INT64)iY1 - (INT64)iX1*(INT64)iY0;
        m_pSCS->iLineEdgeFunc[2] = iYSize;
    }

    BOOL bSlopeIsOne = ( labs( iXSize ) == labs( iYSize ) );
    BOOL bSlopeIsPosOne =
        bSlopeIsOne &&
        ( ( (FLOAT)m_pSCS->iLineEdgeFunc[0]/(FLOAT)m_pSCS->iLineEdgeFunc[2] ) > 0. );

    // compute candidate pixel location for line endpoints
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for exception (slope == +1)
    // case else use nearest ceiling
    //
    // nearest ceiling of Y is ceil( Y - .5), and is done by converting to floor via:
    //
    //   ceil( A/B ) = floor( (A+B-1)/B )
    //
    // where A is coordinate - .5, and B is 0x10 (thus A/B is an n.4 fixed point number)
    //
    // A+B-1 = ( (Y - half) + B - 1 = ( (Y-0x8) + 0x10 - 0x1 = Y + 0x7
    // since B is 2**4, divide by B is right shift by 4
    //
    INT32 iPixX0 = ( iX0 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixX1 = ( iX1 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixY0 = ( iY0 + 0x7 ) >> 4;
    INT32 iPixY1 = ( iY1 + 0x7 ) >> 4;


    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0<<4), iY0 - (iPixY0<<4), bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1<<4), iY1 - (iPixY1<<4), bSlopeIsOne, bSlopeIsPosOne );

    // compute step value
    m_pSCS->iLineStep = ( fLineMajorExtent > 0 ) ? ( +1 ) : ( -1 );

    // compute float and integer major start (V0) and end (V1) positions
    INT32 iLineMajor0 = ( m_pSCS->bXMajor ) ? ( iX0 ) : ( iY0 );
    INT32 iLineMajor1 = ( m_pSCS->bXMajor ) ? ( iX1 ) : ( iY1 );
    m_pSCS->iLineMin = ( m_pSCS->bXMajor ) ? ( iPixX0 ) : ( iPixY0 );
    m_pSCS->iLineMax = ( m_pSCS->bXMajor ) ? ( iPixX1 ) : ( iPixY1 );

// need to do lots of compares which are flipped if major direction is negative
#define LINEDIR_CMP( _A, _B ) \
( ( fLineMajorExtent > 0 ) ? ( (_A) < (_B) ) : ( (_A) > (_B) ) )

    // do first pixel handling - keep first pixel if not in or behind diamond
    if ( !( bV0InDiamond || LINEDIR_CMP( iLineMajor0, (m_pSCS->iLineMin<<4) ) ) )
    {
        m_pSCS->iLineMin += m_pSCS->iLineStep;
    }

    // do last-pixel handling - keep last pixel if past diamond (in which case
    // the pixel is always filled) or if in diamond and rendering last pixel
    if ( !( ( !bV1InDiamond && LINEDIR_CMP( (m_pSCS->iLineMax<<4), iLineMajor1 ) ) ||
            ( bV1InDiamond && m_dwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) )
    {
        m_pSCS->iLineMax -= m_pSCS->iLineStep;
    }

    // return if no (major) extent (both before and after clamping to render buffer)
    if ( LINEDIR_CMP( m_pSCS->iLineMax, m_pSCS->iLineMin ) ) return;

    // snap major extent to render buffer
    INT16 iRendBufMajorMin = m_pSCS->bXMajor ? m_pRenderTarget->m_Clip.left  : m_pRenderTarget->m_Clip.top;
    INT16 iRendBufMajorMax = m_pSCS->bXMajor ? m_pRenderTarget->m_Clip.right : m_pRenderTarget->m_Clip.bottom;
    if ( ( ( m_pSCS->iLineMin < iRendBufMajorMin ) &&
           ( m_pSCS->iLineMax < iRendBufMajorMin ) ) ||
         ( ( m_pSCS->iLineMin > iRendBufMajorMax ) &&
           ( m_pSCS->iLineMax > iRendBufMajorMax ) ) )  { return; }
    m_pSCS->iLineMin = MAX( 0, MIN( iRendBufMajorMax, m_pSCS->iLineMin ) );
    m_pSCS->iLineMax = MAX( 0, MIN( iRendBufMajorMax, m_pSCS->iLineMax ) );

    // return if no (major) extent
    if ( LINEDIR_CMP( m_pSCS->iLineMax, m_pSCS->iLineMin ) ) return;


    // reject if line does not cross surface
    {
        // TODO
    }

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, NULL);
            }
        }
    }

    // set attribute function static data to values for this line
    m_pSCS->AttribFuncStatic.SetPerLineData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fLineMajorExtent, m_pSCS->bXMajor );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx1, VtxFlat );

    // rasterize it
    DoScanCnvLine();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Point Drawing                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

void
ReferenceRasterizer::DrawPoint(
   void* pvV0Public, void* pvVFlat )
{
    DPFM(3, SETUP, ("DrawPoint:\n"));

    DWORD dwStride = GetFVFVertexSize(m_qwFVFControl);
    void *pvV0 = MEMALLOC( dwStride );
    void *pvV1 = MEMALLOC( dwStride );
    void *pvV2 = MEMALLOC( dwStride );

    _ASSERTa( ( NULL != pvV0 ) && ( NULL != pvV1 ) && ( NULL != pvV2),
        "malloc failure on ReferenceRasterizer::DrawPoint", return; );

    memcpy(pvV0, pvV0Public, dwStride);
    memcpy(pvV1, pvV0Public, dwStride);
    memcpy(pvV2, pvV0Public, dwStride);

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx2( pvV2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    // use per vertex S if it exists, otherwise use D3DRENDERSTATE_POINTSIZE
    BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );

    FLOAT fS = 1.0f;
#ifdef __POINTSPRITES
    if (m_qwFVFControl & D3DFVF_S)
    {
        fS = Vtx0.GetS();
    }
    else if( m_dwDriverType > RRTYPE_DP2HAL )
    {
        fS = m_fRenderState[D3DRENDERSTATE_POINTSIZE];
    }
#endif

    // divide point size by 2 to get delta
    fS *= .5f;

    // Move points based on point size
    FLOAT *pXY = Vtx0.GetPtrXYZ();
    FLOAT fX3 = pXY[0] + fS;
    FLOAT fY3 = pXY[1] + fS;
    pXY[0] += -fS;
    pXY[1] += -fS;

    pXY = Vtx1.GetPtrXYZ();
    pXY[0] +=  fS;
    pXY[1] += -fS;

    pXY = Vtx2.GetPtrXYZ();
    pXY[0] += -fS;
    pXY[1] +=  fS;

    FLOAT fDet;
    if (DoAreaCalcs(&fDet, &Vtx0, &Vtx1, &Vtx2) == FALSE)
    {
        goto PointCleanupAndExit;
    }

    //
    // compute edge functions
    //
    m_pSCS->EdgeFuncs[0].Set( m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fX1, m_pSCS->fY1,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[1].Set( m_pSCS->fX1, m_pSCS->fY1, fX3, fY3,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[2].Set( fX3, fY3, m_pSCS->fX2, m_pSCS->fY2,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[3].Set( m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fX0, m_pSCS->fY0,
        fDet, m_bFragmentProcessingEnabled );

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, &Vtx2);

#ifdef __POINTSPRITES
                if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE])
                {
                    // vtx0
                    m_pSCS->fTexCoord[iStage][0][0] = 0.0f;
                    m_pSCS->fTexCoord[iStage][0][1] = 0.0f;
                    m_pSCS->fTexCoord[iStage][0][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][0][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][0] = m_pSCS->fRHW0;

                    // vtx1
                    m_pSCS->fTexCoord[iStage][1][0] = SPRITETEXCOORDMAX;
                    m_pSCS->fTexCoord[iStage][1][1] = 0.0f;
                    m_pSCS->fTexCoord[iStage][1][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][1][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][1] = m_pSCS->fRHW1;

                    // vtx2
                    m_pSCS->fTexCoord[iStage][2][0] = 0.0f;
                    m_pSCS->fTexCoord[iStage][2][1] = SPRITETEXCOORDMAX;
                    m_pSCS->fTexCoord[iStage][2][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][2][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][2] = m_pSCS->fRHW2;
                }
#endif //__POINTSPRITES
            }
        }
    }

    // set attribute function static data to values for this quad
    // (since slopes are constant for quad, any triangle can be used
    // to set them).
    m_pSCS->AttribFuncStatic.SetPerTriangleData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fRHW2,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fDet );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx2, Vtx0 );

    // not culled, so rasterize it
    DoScanCnvTri(4);

PointCleanupAndExit:
    MEMFREE(pvV0);
    MEMFREE(pvV1);
    MEMFREE(pvV2);
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\texmap.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texmap.cpp
//
// Direct3D Reference Rasterizer - Texture Map Access Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

inline UINT8 CLAMP_BYTE(double f)
{
    if (f > 255.0) return 255;
    if (f < 0.0) return 0;
    return (BYTE) f;
}

//-----------------------------------------------------------------------------
// TexelFromBlock - decompress a color block and obtain texel color
//-----------------------------------------------------------------------------
UINT32 TexelFromBlock(RRSurfaceType surfType, char *pblockSrc,
                      int x, int y)
{
    UINT32 index = ((y & 0x3)<<2) + (x & 0x3);
    DDRGBA colorDst[DXT_BLOCK_PIXELS];

    switch(surfType)
    {
    case RR_STYPE_DXT1:
        DecodeBlockRGB((DXTBlockRGB *)pblockSrc, (DXT_COLOR *)colorDst);
        break;
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
        DecodeBlockAlpha4((DXTBlockAlpha4 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        DecodeBlockAlpha3((DXTBlockAlpha3 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    }

    return RGBA_MAKE(colorDst[index].red,
                     colorDst[index].green,
                     colorDst[index].blue,
                     colorDst[index].alpha);
}

//-----------------------------------------------------------------------------
//
// ReadTexelColor - Reads texel from texture map at given LOD; converts to
// RRColor format, applying palette if necessary; also performs colorkey by
// zero-ing out alpha
//
//-----------------------------------------------------------------------------
void
RRTexture::ReadColor(
    INT32 iX, INT32 iY, INT32 iLOD,
    RRColor& Texel, BOOL &bColorKeyMatched )
{
    if ( (iLOD > m_cLOD) && !(m_uFlags & RR_TEXTURE_ENVMAP) )
    {
        return;
    }
    if ( NULL == m_pTextureBits[iLOD] ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pTextureBits[iLOD], m_iPitch[iLOD], m_SurfType );

    switch ( m_SurfType )
    {
    default:
        Texel.ConvertFrom( m_SurfType, pSurfaceBits );
        break;

    case RR_STYPE_PALETTE8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            UINT32 uTexel = *( (UINT32*)(m_pPalette) + uIndex );
            Texel = RGBA_MAKE(
                (uTexel>> 0) & 0xff,
                (uTexel>> 8) & 0xff,
                (uTexel>>16) & 0xff,
                (uTexel>>24) & 0xff);
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RR_STYPE_PALETTE4:
        {
            UINT8 uIndex = *((INT8*)pSurfaceBits);
            if ((iX & 1) == 0) { uIndex &= 0xf; }
            else               { uIndex >>= 4;  }
            UINT32 uTexel = *( (UINT32*)(m_pPalette) + uIndex );
            Texel = RGBA_MAKE(
                (uTexel>> 0) & 0xff,
                (uTexel>> 8) & 0xff,
                (uTexel>>16) & 0xff,
                (uTexel>>24) & 0xff);
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RR_STYPE_UYVY:
    case RR_STYPE_YUY2:
        // Converts a given YUV (8bits each) to RGB scaled between 0 and 255
        // These are using the YCrCb to RGB algorithms given on page 30
        // in "VIDEO DEMYSTIFIED" by Keith Jack
        // ISBN#: 1-878707-09-4
        // IN PC graphics, even though they call it YUV, it is really YCrCb
        // formats that are used by most framegrabbers etc. Hence the pixel
        // data we will obtain in these YUV surfaces will most likely be this
        // and not the original YUV which is actually used in PAL broadcast
        // only (NTSC uses YIQ). So really, U should be called Cb (Blue color
        // difference) and V should be called Cr (Red color difference)
        //
        // These equations are meant to handle the following ranges
        // (from the same book):
        // Y (16 to 235), U and V (16 to 240, 128 = zero)
        //          -----------
        //           Y   U   V
        //          -----------
        // White  : 180 128 128
        // Black  : 16  128 128
        // Red    : 65  100 212
        // Green  : 112 72  58
        // Blue   : 35  212 114
        // Yellow : 162 44  142
        // Cyan   : 131 156 44
        // Magenta: 84  184 198
        //          -----------
        // It is assumed that the gamma corrected RGB range is (0 - 255)
        //
        // UYVY: U0Y0 V0Y1 U2Y2 V2Y3 (low byte always has current Y)
        // If iX is even, hight-byte has current U (Cb)
        // If iX is odd, hight-byte has previous V (Cr)
        //
        // YUY2: Y0U0 Y1V0 Y2U2 Y3V2 (high byte always has current Y)
        //       (UYVY bytes flipped)
        //
        // In this algorithm, we use U and V values from two neighboring
        // pixels
        {
            UINT8 Y, U, V;
            UINT16 u16Curr = *((UINT16*)pSurfaceBits);
            UINT16 u16ForU = 0; // Extract U from this
            UINT16 u16ForV = 0; // Extract V from this

            // By default we assume YUY2. Change it later if it is UYVY
            int uvShift = 8;
            int yShift  = 0;

            if (m_SurfType == RR_STYPE_UYVY)
            {
                uvShift = 0;
                yShift  = 8;
            }

            if ((iX & 1) == 0)
            {
                // Current U available
                u16ForU = u16Curr;

                // Obtain V from the next pixel
                if ( (iX < (m_iWidth >> iLOD)) || (m_uFlags & RR_TEXTURE_ENVMAP) )
                {
                    u16ForV = *((UINT16*)PixelAddress( iX+1, iY,
                                                       m_pTextureBits[iLOD],
                                                       m_iPitch[iLOD],
                                                       m_SurfType ));
                }
                else
                {
                    // This case should not be hit because the texture
                    // width is even (actually, a power of two)
                    _ASSERTa(0, "iX exceeds width", u16ForV = u16Curr;)
                }

            }
            else
            {
                // Current V available
                u16ForV = u16Curr;

                // Obtain U from the previous pixel
                if (iX > 0)
                {
                    u16ForU = *((UINT16*)PixelAddress( iX-1, iY,
                                                       m_pTextureBits[iLOD],
                                                       m_iPitch[iLOD],
                                                       m_SurfType ));
                }
                else
                {
                    // This case should not be hit because the texture
                    // width is even (actually, a power of two)
                    _ASSERTa(0, "iX is negative", u16ForU = u16Curr;)
                }
            }

            Y = (u16Curr >> yShift) & 0xff;
            U = (u16ForU >> uvShift) & 0xff;
            V = (u16ForV >> uvShift) & 0xff;

            Texel = RGB_MAKE(
                CLAMP_BYTE(1.164*(Y-16) + 1.596*(V-128)),
                CLAMP_BYTE(1.164*(Y-16) - 0.813*(V-128) - 0.391*(U-128)),
                CLAMP_BYTE(1.164*(Y-16) + 2.018*(U-128))
                );
            Texel.A = 1.f;
        }
        break;

    // S3 compressed formats:
    // We have the address to the block, now extract the actual color
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        Texel = TexelFromBlock(m_SurfType, pSurfaceBits, iX, iY);
        break;
    }

    // colorkey (only supported for legacy behavior)
    if ( m_bDoColorKeyKill || m_bDoColorKeyZero )
    {
        DWORD dwBits;
        switch ( m_SurfType )
        {
        default:
        case RR_STYPE_NULL:
            return;     // don't colorkey unknown or null surfaces

        case RR_STYPE_PALETTE4:
            {
                UINT8 uIndex = *((INT8*)pSurfaceBits);
                if ((iX & 1) == 0) { uIndex &= 0xf; }
                else               { uIndex >>= 4;  }
                dwBits = (DWORD)uIndex;
                }
            break;

        case RR_STYPE_L8:
        case RR_STYPE_PALETTE8:
        case RR_STYPE_B2G3R3:
        case RR_STYPE_L4A4:
            {
                UINT8 uBits = *((UINT8*)pSurfaceBits);
                dwBits = (DWORD)uBits;
                }
            break;

        case RR_STYPE_B5G6R5:
        case RR_STYPE_B5G5R5:
        case RR_STYPE_B5G5R5A1:
        case RR_STYPE_B4G4R4A4:
        case RR_STYPE_L8A8:
        case RR_STYPE_B2G3R3A8:
            {
                UINT16 uBits = *((UINT16*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;

        case RR_STYPE_B8G8R8:
            {
                UINT32 uBits = 0;
                uBits |= ( *((UINT8*)pSurfaceBits+0) ) <<  0;
                uBits |= ( *((UINT8*)pSurfaceBits+1) ) <<  8;
                uBits |= ( *((UINT8*)pSurfaceBits+2) ) << 16;
                dwBits = (DWORD)uBits;
            }
            break;

        case RR_STYPE_B8G8R8A8:
        case RR_STYPE_B8G8R8X8:
            {
                UINT32 uBits = *((UINT32*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;
        }

        if ( dwBits == m_dwColorKey )
        {
            bColorKeyMatched = TRUE;
            if (m_bDoColorKeyZero)
            {
                Texel.A = 0.F;
                Texel.R = 0.F;
                Texel.G = 0.F;
                Texel.B = 0.F;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\texstage.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texstage.cpp
//
// Direct3D Reference Rasterizer - Texture Processing Stage Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// DoTexture - Does texture lookup, filter, and blend for a pixel.
//
// The basic sequence for texture mapping is to step through active texture
// stages and do the lookup and filtering of that stage's texel contribution
// followed by the blending.
//
// Bump map textures result in computing a set of coordinate deltas which are
// applied to the texture coordinates of the subsequent stage, and a set of
// modulation factors which are applied to the texel color of the subsequent
// stage prior to that stages' blend.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoTexture(
    const RRPixel& Pixel, RRColor& ResultColor)
{
    DPFM(5, TEX, ("DoTexture\n"));

    // TRUE if previous stage was a bump map, meaning that the current
    // stage has to apply U,V deltas and color modulation
    BOOL bPrevStageBump = FALSE;

    // Bump information must be remembered between iterations of the for loop
    // below.
    FLOAT   fBumpMapUVDelta[2] = { 0., 0. };
    RRColor BumpMapModulate;

    //
    // step through the set of active texture stages (must be contiguous
    // starting at stage 0)
    //

    // color after each blend stage, defaults to diffuse color for
    // first stage
    RRColor LastStageColor( Pixel.Color );
    for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
    {
        RRTextureCoord  TCoord;
        RREnvTextureCoord ECoord;
        FLOAT fShadCoord[4];

        // clear this at the beginning of processing for each pixel
        if (m_pTexture[iStage])
        {
            m_pTexture[iStage]->m_bColorKeyMatched = FALSE;
        }

        // check if stage is disabled - if so then texture mapping is done
        // and result of previous stage is returned
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            ResultColor = LastStageColor; // pass result of previous stage
            break;
        }


        BOOL bTextureIsBumpMap = FALSE;
        BOOL bTextureIsEnvMap  = FALSE;
        BOOL bTextureIsShadMap = FALSE;
        RRColor TextureColor = (UINT32)0x0;     // default value if no texture is read

        // compute texture coordinates (if necessary) - check renderstate to
        // see if texture map is attached to stage, then determine which
        // coordinate set from that texture's state
        //
        // note that it is possible for there to not be a texture map
        // associated with a stage (but blending still occurs)
        if ( m_pTexture[iStage] )
        {
            // need to know if this is a bump map texture
            bTextureIsBumpMap =
                ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP ) ||
                ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE );

            // need to know if this is an environment map texture
            bTextureIsEnvMap = m_pTexture[iStage]->m_uFlags & RR_TEXTURE_ENVMAP;

            // see if this is a shadow map texture
            bTextureIsShadMap = m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP;

            if (bTextureIsEnvMap)
            {
                // normal is always required
                ECoord.fNX = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                ECoord.fNY = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                ECoord.fNZ = ComputePixelAttribTex( iStage, TEXFUNC_2 );
//              if we add the eye normal iteration
//                if (m_dwFVFControl & D3DFVF_ENV_EYE_NORMAL)
//                {
//                    ECoord.fENX = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENX );
//                    ECoord.fENY = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENY );
//                    ECoord.fENZ = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENZ );
//                }
                FLOAT fW = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
                ECoord.fDNXDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetXGradient() -
                           ( ECoord.fNX * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNXDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetYGradient() -
                           ( ECoord.fNX * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                ECoord.fDNYDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetXGradient() -
                           ( ECoord.fNY * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNYDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetYGradient() -
                           ( ECoord.fNY * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                ECoord.fDNZDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_2].GetXGradient() -
                           ( ECoord.fNZ * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNZDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_2].GetYGradient() -
                           ( ECoord.fNZ * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
            }
            else if (bTextureIsShadMap)
            {
                fShadCoord[0] = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                fShadCoord[1] = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                fShadCoord[2] = ComputePixelAttribTex( iStage, TEXFUNC_2 );
                fShadCoord[3] = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
            }
            else
            {
                // compute coordinate and gradient data for texture index pair
                TCoord.fU = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                TCoord.fV = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                FLOAT fW = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
                TCoord.fDUDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetXGradient() -
                           ( TCoord.fU * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                TCoord.fDUDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetYGradient() -
                           ( TCoord.fU * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                TCoord.fDVDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetXGradient() -
                           ( TCoord.fV * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                TCoord.fDVDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetYGradient() -
                           ( TCoord.fV * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
            }

            // apply perturbation to texture coords (computed in previous stage)
            if ( bPrevStageBump )
            {
                TCoord.fU += fBumpMapUVDelta[0];
                TCoord.fV += fBumpMapUVDelta[1];
            }

            // do lookup and filtering of texture map to produce either texture
            // color or bump map delta&modulation
            if ( bTextureIsBumpMap)
            {
                // texture is bump map, so compute U,V deltas and color
                // modulation for next stage
                m_pTexture[iStage]->DoBumpMapping( iStage, TCoord,
                    fBumpMapUVDelta[0], fBumpMapUVDelta[1], BumpMapModulate);
                bPrevStageBump = TRUE;
            }
            else if (bTextureIsEnvMap)
            {
                // texture is environment map, pass normal to lookup
                m_pTexture[iStage]->DoEnvProcessNormal( iStage, ECoord, TextureColor );
            }
            else if (bTextureIsShadMap)
            {
                m_pTexture[iStage]->DoShadow( iStage, fShadCoord, TextureColor );
            }
            else
            {
                // normal texture
                m_pTexture[iStage]->DoLookupAndFilter( iStage, TCoord, TextureColor );
            }
        }

        // do per-stage blend (only if not bump map)
        if ( !bTextureIsBumpMap )
        {
            if ( bPrevStageBump )
            {
                // apply color modulation to texture color prior to this
                // stage's blending
                TextureColor.R *= BumpMapModulate.R;
                TextureColor.G *= BumpMapModulate.G;
                TextureColor.B *= BumpMapModulate.B;
            }

            DoTextureBlendStage( iStage, Pixel.Color, Pixel.Specular,
                LastStageColor, TextureColor, ResultColor );

            // set color for next stage
            LastStageColor = ResultColor;

            // this is not a bump map stage, so clear this for next time
            bPrevStageBump = FALSE;
        }
    }
}

//-----------------------------------------------------------------------------
//
// ComputeTextureBlendArg - Computes texture argument for blending, using the
// specified argument control (D3DTA_* fields).  This is called 4 times per
// texture processing stage: 2 arguments for color and 2 arguments for alpha.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::ComputeTextureBlendArg(
    DWORD dwArgCtl, BOOL bAlphaOnly,
    const RRColor& DiffuseColor,
    const RRColor& SpecularColor,
    const RRColor& CurrentColor,
    const RRColor& TextureColor,
    RRColor& BlendArg)
{
    // argument MUX
    switch ( dwArgCtl & D3DTA_SELECTMASK )
    {
    case D3DTA_DIFFUSE:  BlendArg = DiffuseColor; break;
    case D3DTA_CURRENT:  BlendArg = CurrentColor; break;
    case D3DTA_SPECULAR: BlendArg = SpecularColor; break;
    case D3DTA_TEXTURE:  BlendArg = TextureColor; break;
    case D3DTA_TFACTOR:
        BlendArg = m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]; break;
    }

    // take compliment of all channels
    if ( dwArgCtl & D3DTA_COMPLEMENT )
    {
        BlendArg.A = ~BlendArg.A;
        if ( !bAlphaOnly )
        {
            BlendArg.R = ~BlendArg.R;
            BlendArg.G = ~BlendArg.G;
            BlendArg.B = ~BlendArg.B;
        }
    }

    // replicate alpha to color (after compliment)
    if ( !bAlphaOnly && ( dwArgCtl & D3DTA_ALPHAREPLICATE ) )
    {
        BlendArg.R =
        BlendArg.G =
        BlendArg.B = BlendArg.A;
    }
}

//-----------------------------------------------------------------------------
//
// DoTextureBlendStage - Does texture blend for one texture processing stage,
// combining results from the texture processing with the interpolated color(s)
// and previous stage's color.
//
// Note: All color channel multiplies should be done in such a way that a unit
// value on one side passes the value on the other side.  Thus for 8 bit color
// channels, '0xff * value' should return value, and 0xff * 0xff = 0xff,
// not 0xfe(01).
//
// RRColorChannel performs these operations with floating point. 8 bit color
// values of 0x00 to 0xff are mapped into the 0. to 1. range.  Performing these
// multiplies in fixed point requires an adjustment to adhere to this rule.
//
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoTextureBlendStage(
    int iStage,
    const RRColor& DiffuseColor,
    const RRColor& SpecularColor,
    const RRColor& CurrentColor,
    const RRColor& TextureColor,
    RRColor& OutputColor)
{
    DPFM(5, TEX, ("DoTextureBlend\n"));

    if (iStage >= 1)
    {
        if (m_TextureStageState[iStage-1].m_dwVal[D3DTSS_COLOROP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            // cast away the const'ness, just for PREMODULATE
            ((RRColor&)CurrentColor).R = CurrentColor.R * TextureColor.R;
            ((RRColor&)CurrentColor).G = CurrentColor.G * TextureColor.G;
            ((RRColor&)CurrentColor).B = CurrentColor.B * TextureColor.B;
        }
        if (m_TextureStageState[iStage-1].m_dwVal[D3DTSS_ALPHAOP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            ((RRColor&)CurrentColor).A *= CurrentColor.A * TextureColor.A;
        }
    }

    // compute arg1,2 for color channel blend
    RRColor ColorArg1, ColorArg2;
    RRColor AlphaArg1, AlphaArg2;
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, ColorArg1 );
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG2], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, ColorArg2 );

    // do color channel blend
    FLOAT fModulateScale;
    RRColorComp BlendFactor;
    switch ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] )
    {

    case D3DTOP_SELECTARG1:
        OutputColor.R = ColorArg1.R;
        OutputColor.G = ColorArg1.G;
        OutputColor.B = ColorArg1.B;
        break;
    case D3DTOP_SELECTARG2:
        OutputColor.R = ColorArg2.R;
        OutputColor.G = ColorArg2.G;
        OutputColor.B = ColorArg2.B;
        break;

    case D3DTOP_ADD:
        OutputColor.R = ColorArg1.R + ColorArg2.R;
        OutputColor.G = ColorArg1.G + ColorArg2.G;
        OutputColor.B = ColorArg1.B + ColorArg2.B;
        break;
    case D3DTOP_ADDSIGNED:
        OutputColor.R = ColorArg1.R + ColorArg2.R - .5f;
        OutputColor.G = ColorArg1.G + ColorArg2.G - .5f;
        OutputColor.B = ColorArg1.B + ColorArg2.B - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        OutputColor.R = (ColorArg1.R + ColorArg2.R - .5f)*2.0f;
        OutputColor.G = (ColorArg1.G + ColorArg2.G - .5f)*2.0f;
        OutputColor.B = (ColorArg1.B + ColorArg2.B - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        OutputColor.R = ~((~ColorArg1.R) + ColorArg2.R);
        OutputColor.G = ~((~ColorArg1.G) + ColorArg2.G);
        OutputColor.B = ~((~ColorArg1.B) + ColorArg2.B);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        OutputColor.R = ColorArg1.R + (~ColorArg1.R)*ColorArg2.R;
        OutputColor.G = ColorArg1.G + (~ColorArg1.G)*ColorArg2.G;
        OutputColor.B = ColorArg1.B + (~ColorArg1.B)*ColorArg2.B;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateC;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateC;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateC;
_DoModulateC:
        OutputColor.R = ColorArg1.R * ColorArg2.R * fModulateScale;
        OutputColor.G = ColorArg1.G * ColorArg2.G * fModulateScale;
        OutputColor.B = ColorArg1.B * ColorArg2.B * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: BlendFactor = DiffuseColor.A; goto _DoBlendC;
    case D3DTOP_BLENDTEXTUREALPHA: BlendFactor = TextureColor.A; goto _DoBlendC;
    case D3DTOP_BLENDCURRENTALPHA: BlendFactor = CurrentColor.A; goto _DoBlendC;
    case D3DTOP_BLENDFACTORALPHA:
        BlendFactor = (UINT8)RGBA_GETALPHA( m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR] );
        goto _DoBlendC;
_DoBlendC:
        OutputColor.R = BlendFactor * (ColorArg1.R - ColorArg2.R) + ColorArg2.R;
        OutputColor.G = BlendFactor * (ColorArg1.G - ColorArg2.G) + ColorArg2.G;
        OutputColor.B = BlendFactor * (ColorArg1.B - ColorArg2.B) + ColorArg2.B;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        OutputColor.R = ColorArg1.R + ( (~TextureColor.A) * ColorArg2.R );
        OutputColor.G = ColorArg1.G + ( (~TextureColor.A) * ColorArg2.G );
        OutputColor.B = ColorArg1.B + ( (~TextureColor.A) * ColorArg2.B );
        break;

    case D3DTOP_PREMODULATE:
        // just copy ColorArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        OutputColor.R = ColorArg1.R;
        OutputColor.G = ColorArg1.G;
        OutputColor.B = ColorArg1.B;
        break;
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
        OutputColor.R = ColorArg1.R + ColorArg1.A*ColorArg2.R;
        OutputColor.G = ColorArg1.G + ColorArg1.A*ColorArg2.G;
        OutputColor.B = ColorArg1.B + ColorArg1.A*ColorArg2.B;
        break;
    case D3DTOP_MODULATECOLOR_ADDALPHA:
        OutputColor.R = ColorArg1.R*ColorArg2.R + ColorArg1.A;
        OutputColor.G = ColorArg1.G*ColorArg2.G + ColorArg1.A;
        OutputColor.B = ColorArg1.B*ColorArg2.B + ColorArg1.A;
        break;
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
        OutputColor.R = (~ColorArg1.A)*ColorArg2.R + ColorArg1.R;
        OutputColor.G = (~ColorArg1.A)*ColorArg2.G + ColorArg1.G;
        OutputColor.B = (~ColorArg1.A)*ColorArg2.B + ColorArg1.B;
        break;
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        OutputColor.R = (~ColorArg1.R)*ColorArg2.R + ColorArg1.A;
        OutputColor.G = (~ColorArg1.G)*ColorArg2.G + ColorArg1.A;
        OutputColor.B = (~ColorArg1.B)*ColorArg2.B + ColorArg1.A;
        break;

    case D3DTOP_DOTPRODUCT3:
        OutputColor.R = ((ColorArg1.R-0.5f)*2.0f*(ColorArg2.R-0.5f)*2.0f +
             (ColorArg1.G-0.5f)*2.0f*(ColorArg2.G-0.5f)*2.0f +
             (ColorArg1.B-0.5f)*2.0f*(ColorArg2.B-0.5f)*2.0f);
        OutputColor.G = OutputColor.R;
        OutputColor.B = OutputColor.R;
        OutputColor.A = OutputColor.R;
        goto _SkipAlphaChannelBlend;
        break;
    }


    // compute arg1,2 for alpha channel blend
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAARG1], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, AlphaArg1 );
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAARG2], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, AlphaArg2 );

    // do alpha channel blend
    switch ( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAOP] )
    {
    case D3DTOP_LEGACY_ALPHAOVR:
        if (m_pTexture[0])
        {
            OutputColor.A = ( m_pTexture[0]->m_bHasAlpha ) ? AlphaArg1.A : AlphaArg2.A;
        }
        else
        {
            OutputColor.A = AlphaArg1.A;
        }
        break;

    case D3DTOP_SELECTARG1:
        OutputColor.A = AlphaArg1.A;
        break;
    case D3DTOP_SELECTARG2:
        OutputColor.A = AlphaArg2.A;
        break;

    case D3DTOP_ADD:
        OutputColor.A = AlphaArg1.A + AlphaArg2.A;
        break;
    case D3DTOP_ADDSIGNED:
        OutputColor.A = AlphaArg1.A + AlphaArg2.A - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        OutputColor.A = (AlphaArg1.A + AlphaArg2.A - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        OutputColor.A = ~((~AlphaArg1.A) + AlphaArg2.A);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        OutputColor.A = AlphaArg1.A + (~AlphaArg1.A)*AlphaArg2.A;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateA;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateA;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateA;
_DoModulateA:
        OutputColor.A = AlphaArg1.A * AlphaArg2.A * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: BlendFactor = DiffuseColor.A; goto _DoBlendA;
    case D3DTOP_BLENDTEXTUREALPHA: BlendFactor = TextureColor.A; goto _DoBlendA;
    case D3DTOP_BLENDCURRENTALPHA: BlendFactor = CurrentColor.A; goto _DoBlendA;
    case D3DTOP_BLENDFACTORALPHA:
        BlendFactor = (UINT8)RGBA_GETALPHA( m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR] );
        goto _DoBlendA;
_DoBlendA:
        OutputColor.A = BlendFactor * (AlphaArg1.A - AlphaArg2.A) + AlphaArg2.A;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        OutputColor.A = AlphaArg1.A + ( (~TextureColor.A) * AlphaArg2.A );
        break;

    case D3DTOP_PREMODULATE:
        // just copy AlphaArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        OutputColor.A = AlphaArg1.A;
        break;

    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
    case D3DTOP_DOTPRODUCT3:
        // does nothing, not valid alpha op's
        break;
    }

_SkipAlphaChannelBlend:
    // clamp output color after each blend stage
    OutputColor.R = minimum( 1.f, maximum( 0.f, OutputColor.R ) );
    OutputColor.G = minimum( 1.f, maximum( 0.f, OutputColor.G ) );
    OutputColor.B = minimum( 1.f, maximum( 0.f, OutputColor.B ) );
    OutputColor.A = minimum( 1.f, maximum( 0.f, OutputColor.A ) );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\sources.inc ===
TARGETNAME = refrast
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
        ..\refrast.cpp\
        ..\refrasti.cpp\
        ..\rtarget.cpp\
        ..\MapLegcy.cpp\
        ..\setup.cpp\
        ..\EdgeFunc.cpp\
        ..\AttrFunc.cpp\
        ..\scancnv.cpp\
        ..\texture.cpp\
        ..\texmap.cpp\
        ..\texstage.cpp\
        ..\pixproc.cpp\
        ..\PixRef.cpp\
        ..\fragproc.cpp\
        ..\fragrslv.cpp\
        ..\rrutil.cpp\
        ..\refs3tc.cpp\
        ..\shadow.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\rast\texture.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texture.cpp
//
// Direct3D Reference Rasterizer - Texture Map Sampling & Filtering Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// overload new & delete so that it can be allocated from caller-controlled
// pool
//
//-----------------------------------------------------------------------------
void*
RRTexture::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(RRTexture) );
    _ASSERTa( NULL != pMem, "malloc failure on Tex object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
RRTexture::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RRTexture::RRTexture( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RRTexture::~RRTexture( void )
{
}


//-----------------------------------------------------------------------------
//
// Validate - Updates private data.  Must be called anytime public data is
// altered.
//
//-----------------------------------------------------------------------------
BOOL
RRTexture::Validate( void )
{
    // validate inputs
    BOOL bFail0 = ( m_cLOD >= RRTEX_MAXCLOD );  // too many LODs
    BOOL bFail1 = !( IsPowerOf2( m_iWidth ) );  // gotta be power of two
    BOOL bFail2 = !( IsPowerOf2( m_iHeight ) );
    if ( bFail0 || bFail1 || bFail2 )
    {
        DPFRR(1,"RRTexture::Validate failed (%d,%d,%d)", bFail0, bFail1, bFail2);
        return FALSE;
    }

    // set internal size reps
    m_iTexSize[0] = (INT16)m_iWidth;
    m_iTexSize[1] = (INT16)m_iHeight;

    // mask is size-1 because these have to be power-of-two
    m_uTexMask[0] = (UINT16)m_iTexSize[0]-1;
    m_uTexMask[1] = (UINT16)m_iTexSize[1]-1;
    // shift is log2 of size
    m_iTexShift[0] = (INT16)FindFirstSetBit( m_iTexSize[0], 16 );
    m_iTexShift[1] = (INT16)FindFirstSetBit( m_iTexSize[1], 16 );

    // compute the 'has alpha' flag
    m_bHasAlpha = FALSE;
    switch ( m_SurfType )
    {
    case RR_STYPE_B8G8R8A8:
    case RR_STYPE_B5G5R5A1:
    case RR_STYPE_B4G4R4A4:
    case RR_STYPE_L8A8:
    case RR_STYPE_L4A4:
    case RR_STYPE_B2G3R3A8:
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        m_bHasAlpha = TRUE;
        break;
    case RR_STYPE_PALETTE4:
    case RR_STYPE_PALETTE8:
        m_bHasAlpha = ( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) ? TRUE : FALSE;
        break;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoLookupAndFilter - Called once per active texture stage to compute
// coverage (level-of-detail) and invoke texel read and filtering routines.
// Returns filtered texel.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoLookupAndFilter(
    INT32 iStage,
    RRTextureCoord TCoord,      // local copy
    RRColor& TextureColor)
{
    // check for potential mip mapping
    BOOL bDoMipMap = ( m_cLOD > 0 ) && ( m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] > D3DTFP_NONE );

    // check for requirement to do level-of-detail (coverage) computation - either
    // for mipmap or per-pixel filter selection
    BOOL bComputeLOD = bDoMipMap ||
        ( m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] != m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] );

    // check for anisotropic filtering in either mag filter or in min filter
    BOOL bDoAniso =
        ( D3DTFG_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] ) ||
        ( bComputeLOD && (D3DTFN_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );

    if ( bDoMipMap || bDoAniso || bComputeLOD )
    {
        // here if doing mipmapping or anisotropic filtering, or just have a mismatch
        // between the min and mag filters, so compute level of detail (and maybe aniso
        // coverage)

        // scale gradients to texture LOD 0 size
        TCoord.fDUDX *= (FLOAT)m_iTexSize[0];
        TCoord.fDUDY *= (FLOAT)m_iTexSize[0];
        TCoord.fDVDX *= (FLOAT)m_iTexSize[1];
        TCoord.fDVDY *= (FLOAT)m_iTexSize[1];

        // compute level of detail (and maybe anisotropic controls)
        FLOAT fLOD, fAnisoRatio, fAnisoDelta[2];
        (bDoAniso)
            ? ComputeAnisotropicLevelOfDetail( TCoord, (FLOAT)m_pStageState[iStage].m_dwVal[D3DTSS_MAXANISOTROPY],
                                                       fLOD, fAnisoRatio,fAnisoDelta )
            : ComputeSimpleLevelOfDetail     ( TCoord, fLOD );

// Uncomment the line below to see the anisotropy by color.  White is 1:1, darker is more
// anisotropy.
//#define COLOR_BY_ANISOTROPY 1
#ifdef COLOR_BY_ANISOTROPY
static RRColor PseudoColors[16] =
{
    0xffffffff,
    0xffffff00,
    0xffff00ff,
    0xff00ffff,

    0xff888888,
    0xff0000ff,
    0xff00ff00,
    0xffff0000,

    0xff444444,
    0xff888800,
    0xff880088,
    0xff008888,

    0xff222222,
    0xff000088,
    0xff008800,
    0xff880000,
};
        INT32 iPseudoColor = (INT32)(fAnisoRatio - .5);     // round, and make 1.0F == index 0
        iPseudoColor = min(max(iPseudoColor, 0), 15);

        TextureColor = PseudoColors[iPseudoColor];
        return;
#endif

        // apply bias and compute integer (n.5) LOD
        INT16 iLOD = 0;
        if ( bComputeLOD )
        {
            // apply LOD offset
            fLOD += m_pStageState[iStage].m_fVal[D3DTSS_MIPMAPLODBIAS];
            // convert LOD to n.5 fixed point integer
            iLOD = AS_INT16( fLOD + FLOAT_5_SNAP );
        }

        // determine if magnifying or minifying
        BOOL bMagnify = ( iLOD <= 0 );

        // zero out LOD if not mipmapping
        if ( !bDoMipMap ) { iLOD = 0; }

        // do different filtering for magnify vs. minify
        if ( bMagnify )
        {
            // here for magnify - do either (non-anisotropic) magnify or
            // anisotropic filter
            if ( D3DTFG_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] )
            {
                DoAniso( iStage, TCoord, iLOD,fAnisoRatio,fAnisoDelta, TextureColor );
            }
            else
            {
                DoMagnify( iStage, TCoord, TextureColor );
            }
        }
        else
        {
            // here for minify -  do either simple minify, trilerp,
            // or anisotropic filter
            if ( D3DTFN_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] )
            {
                DoAniso( iStage, TCoord, iLOD,fAnisoRatio,fAnisoDelta, TextureColor );
            }
            else
            {
                if ( !bDoMipMap ||
                    ( bDoMipMap && ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] ) ) )
                {
                    DoMinify( iStage, TCoord, iLOD, TextureColor );
                }
                else
                {
                    DoTrilerp( iStage, TCoord, iLOD, TextureColor );
                }
            }
        }
    }
    else
    {
        // here for no mipmaps and matching (and non-aniso) min and mag filters,
        // so just apply mag filter
        DoMagnify( iStage, TCoord, TextureColor );
    }
}

//-----------------------------------------------------------------------------
//
// DoMapLookupLerp - Performs texture index ADDRESS processing followed by
// a lookup within a single DD surface (a single LOD within a chain of DD
// surfaces).  Dies BILINEAR filter operation for lookup.
//
// This is called once per pixel for BILINEAR, twice per pixel when
// doing mipmap trilinear interpolation.
//
// * texture index inputs are n.5 fixed point
// * LOD input is 0..n count where 0 indicates the largest LOD
//
//-----------------------------------------------------------------------------

RRColor RRTexture::DoMapLookupLerp(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD)
{
    // extract fraction bits
    UINT8 uUFrac = iU&0x1f;
    UINT8 uVFrac = iV&0x1f;

    // take floor for (0,0) sample coords
    INT16 iU0 = iU>>5;
    INT16 iV0 = iV>>5;
    // take ceiling for (1,1) sample coords
    INT16 iU1 = iU0+1;
    INT16 iV1 = iV0+1;

    BOOL bColorKeyMatched00 = FALSE;
    BOOL bColorKeyMatched01 = FALSE;
    BOOL bColorKeyMatched10 = FALSE;
    BOOL bColorKeyMatched11 = FALSE;

    // grab four adjacent samples (or border color)
    RRColor Texel00 = DoMapLookupNearest( iStage, iU0, iV0, iLOD, bColorKeyMatched00);
    RRColor Texel01 = DoMapLookupNearest( iStage, iU1, iV0, iLOD, bColorKeyMatched01);
    RRColor Texel10 = DoMapLookupNearest( iStage, iU0, iV1, iLOD, bColorKeyMatched10);
    RRColor Texel11 = DoMapLookupNearest( iStage, iU1, iV1, iLOD, bColorKeyMatched11);

    // only set 'colorkey matched' if at least one matched value has
    // a non-zero contribution (note that it is not possible for 00
    // to have no contribution)
    if (uUFrac == 0x00) {
        // 01 and 11 have zero weight if U fraction is zero
        bColorKeyMatched01 = bColorKeyMatched11 = FALSE;
    }
    if (uVFrac == 0x00) {
        // 10 and 11 have zero weight if V fraction is zero
        bColorKeyMatched10 = bColorKeyMatched11 = FALSE;
    }

    // merge colorkey match info from previous invocation
    m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched00 || bColorKeyMatched01 ||
        bColorKeyMatched10 || bColorKeyMatched11;

    // do bilinear filter
    RRColor Texel;
    BiLerpColor( Texel, Texel00,Texel01, Texel10,Texel11, uUFrac,uVFrac);
    return Texel;
}

//-----------------------------------------------------------------------------
//
// DoMapLookupNearest - Performs texture index ADDRESS processing followed by
// a lookup within a single DD surface (a single LOD within a chain of DD
// surfaces).  Does NEAREST operation for lookup.
//
// This is called once per pixel for NEAREST , twice per pixel when
// doing mipmap trilinear interpolation
//
// * texture index inputs are n.0 fixed point
// * LOD input is 0..n count where 0 indicates the largest LOD
// * texture index extend mode processing is also performed here - this works
//   for power-of-two texture sizes only.
//
//-----------------------------------------------------------------------------
RRColor RRTexture::DoMapLookupNearest(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD, BOOL &bColorKeyMatched)
{
    // LSB-aligned masks of index bits within current LOD
    INT16 iUMask = m_uTexMask[0] >> iLOD;
    INT16 iVMask = m_uTexMask[1] >> iLOD;

    // boolean for BORDER - if true then use border color for corresponding sample
    BOOL bUseBorder = FALSE;

    // not matched by default
    bColorKeyMatched = FALSE;

    // do texture ADDRESS processing for U axis
    switch ( m_pStageState[iStage].m_dwVal[D3DTSS_ADDRESSU] )
    {
    case D3DTADDRESS_WRAP:
        // just lop off non-fractional bits
        iU &= iUMask;
        break;
    case D3DTADDRESS_MIRROR:
        // lop off non-fractional bits + flip index if LSB (non-fraction) is set
        BOOL bFlip;
        bFlip = iU & (iUMask+1); iU &= iUMask; if (bFlip) {iU = iUMask - iU;}
        break;

    case D3DTADDRESS_BORDER:
        // compute booleans for which of 4 samples should use border color
        if ((iU < 0) || (iU > iUMask)) { bUseBorder = TRUE;}
        break;

    case D3DTADDRESS_CLAMP:
        // use texels on texture map edge
        iU = MAX( 0, MIN( iU, iUMask ) );
        break;
    }

    // do texture ADDRESS processing for V axis
    switch ( m_pStageState[iStage].m_dwVal[D3DTSS_ADDRESSV] )
    {
    case D3DTADDRESS_WRAP:
        iV &= iVMask;
        break;
    case D3DTADDRESS_MIRROR:
        BOOL bFlip;
        bFlip = iV & (iVMask+1); iV &= iVMask; if (bFlip) {iV = iVMask - iV;}
        break;

    case D3DTADDRESS_BORDER:
        if ((iV < 0) || (iV > iVMask)) { bUseBorder = TRUE; }
        break;

    case D3DTADDRESS_CLAMP:
        iV = MAX( 0, MIN( iV, iVMask ) );
        break;
    }

     // just lookup and return texel at (iU0,iV0)
    RRColor Texel;
    (bUseBorder)
            ? Texel = m_pStageState[iStage].m_dwVal[D3DTSS_BORDERCOLOR]
            : ReadColor( iU, iV, iLOD, Texel, bColorKeyMatched );
    return Texel;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Filtering Routines                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//-----------------------------------------------------------------------------
//
// DoLookup - Does a full lookup given floating point U, V and handles all
// nearest vs bilinear and LOD issues.
//
//-----------------------------------------------------------------------------

RRColor RRTexture::DoLookup(INT32 iStage, float U, float V, INT16 iLOD, BOOL bNearest)
{
    INT32 cUPixels = 1 << MAX(m_iTexShift[0]-iLOD,0);
    INT32 cVPixels = 1 << MAX(m_iTexShift[1]-iLOD,0);
    FLOAT fScaledU = ( U * (FLOAT)cUPixels ) -.5f;
    FLOAT fScaledV = ( V * (FLOAT)cVPixels ) -.5f;
    if(bNearest)
    {
        INT32 iU, iV;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if (U >= 0.0f)
        {
            iU = fScaledU + .5f;
        }
        else
        {
            iU = fScaledU - .5f;
        }
        if (V >= 0.0f)
        {
            iV = fScaledV + .5f;
        }
        else
        {
            iV = fScaledV - .5f;
        }
        BOOL bColorKeyMatched = FALSE;
        RRColor Texel = DoMapLookupNearest(iStage,iU,iV,iLOD,bColorKeyMatched);
        // merge colorkey match info from previous invocation
        m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched;
        return Texel;
    }
    else
    {
        INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
        INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );
        return DoMapLookupLerp(iStage,iU,iV,iLOD);
    }
}


//-----------------------------------------------------------------------------
//
// DoMagnify - This is used for all magnification filter modes except
// anisotropic.
//
// Currently only POINT and BILINEAR are supported.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoMagnify(INT32 iStage, RRTextureCoord& TCoord, RRColor& Texel )
{
    // do lookup, applying MAG filter
    Texel = DoLookup( iStage, TCoord.fU, TCoord.fV, 0,
                      (D3DTFG_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER]) );
}


//-----------------------------------------------------------------------------
//
// DoMinify - This is used for POINT and BILINEAR modes (non-trilinear)
// for minification, and also handles POINT mip filter (nearest LOD).
//
// iLOD is n.5 fixed point
//
//-----------------------------------------------------------------------------
void
RRTexture::DoMinify(INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel )
{
    // round and drop fraction from LOD (is n.5 fixed point)
    iLOD += 0x10; iLOD &= ~(0x1f);
    // convert to n.0
    iLOD >>= 5;
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, m_cLOD );

    // do lookup, applying MIN filter
    Texel = DoLookup( iStage, TCoord.fU, TCoord.fV, iLOD,
                      (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );
}

//-----------------------------------------------------------------------------
//
// DoTrilerp - Computes level of detail and invokes either: single-map
// lookup & filter for magnify; or trilinear lookup and filter for minify
//
//-----------------------------------------------------------------------------
void
RRTexture::DoTrilerp(INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel)
{
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, (m_cLOD)<<5 );
    // compute index for two adjacent LODs (with clamp)
    INT16 iLODHi = iLOD>>5;  // floor
    INT16 iLODLo = MIN(iLODHi+1,m_cLOD);

    // check for filter type for within LOD map
    BOOL bNearest = (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]);

    // trilerp - look up each map then lerp between them
    // important for colorkey to not include texels with no contribution
    if (0x00 != (iLOD&0x1f))
    {
    RRColor Texel0 = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODHi, bNearest);
    RRColor Texel1 = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODLo, bNearest);
    LerpColor( Texel, Texel0, Texel1, iLOD&0x1f );
    }
    else
    {
        Texel = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODHi, bNearest);
    }
}

//-----------------------------------------------------------------------------
//
// DoAniso - Handles anisotropic filtering of either magnified (single
// map lookup) or minified (two adjacent map lookup) samples.  The computation
// of level of detail and anisotropic coverage information (fRatio,fDelta[]) is
// done prior to this function.
//
// This performs only anisotropic filtering, and is called only for minification
// when the MINFILTER is set to ANISOTROPIC or for magnification when the
// MAGFILTER is set to ANISOTROPIC.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoAniso(INT32 iStage, RRTextureCoord& TCoord,
    INT16 iLOD, FLOAT fRatio, FLOAT fDelta[],
    RRColor& Texel)
{
    // set boolean if magnifying
    BOOL bMagnify = (iLOD <= 0);
    // clamp LOD to number of available levels
    iLOD = MIN( MAX( iLOD, 0 ), (m_cLOD)<<5 );

    // compute index for two adjacent LODs (with clamp)
    // 0 is the larger LOD, 1 is the smaller LOD
    INT16 iLODHi, iLODLo;
    if ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] )
    {
        // here for nearest MIP filter
        // round and drop fraction from LOD (is n.5 fixed point)
        iLOD += 0x10; iLOD &= ~(0x1f);
        // convert to n.0
        iLODHi = iLOD >> 5;
    }
    else
    {
        // here for linear MIP filter
        iLODHi = iLOD >> 5;  // floor for larger LOD
        if ( !bMagnify )
        {
            // ceiling+clamp for smaller LOD
            iLODLo = MIN( iLODHi+1, m_cLOD );
        }
    }

    // compute boolean true if only sampling one map - this is the case if
    // we are magnifying or if the MIPFILTER is set to NEAREST or if the
    // LOD fraction is zero
    BOOL bSingleMap =
        bMagnify ||
        (D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER]) ||
        (0x00 == (iLOD&0x1f));

    // working copy of texture coordinates
    FLOAT fU = TCoord.fU;
    FLOAT fV = TCoord.fV;

    // fDelta is in texels.  Compute correction factor for each LOD we care about
    FLOAT fUStepScaleHi = 1.0F/(FLOAT)MAX(m_iWidth >> iLODHi, 1);
    FLOAT fVStepScaleHi = 1.0F/(FLOAT)MAX(m_iHeight >> iLODHi, 1);
    FLOAT fUStepScaleLo = 0.F;
    FLOAT fVStepScaleLo = 0.F;

    if ( !bSingleMap )
    {
        fUStepScaleLo = 1.0F/(FLOAT)MAX(m_iWidth >> iLODLo, 1);
        fVStepScaleLo = 1.0F/(FLOAT)MAX(m_iHeight >> iLODLo, 1);
    }

    // colors for holding partial results during filtering
    RRColor TexelP, TexelP0, TexelP1;   // Plus side texels
    RRColor TexelM, TexelM0, TexelM1;   // Minus side texels

    //
    // key on ratio to either do single lookup, <2:1 processing (two lookups),
    // or full aniso walk
    //
    if (fRatio == 1.)
    {
        // here for no anisotropy - do single trilerp
        if ( bSingleMap )
        {
            // single map lookup for magnify
            Texel = DoLookup( iStage, fU, fV, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelP0 = DoLookup( iStage, fU, fV, iLODHi, FALSE);
            TexelP1 = DoLookup( iStage, fU, fV, iLODLo, FALSE);
            LerpColor( Texel, TexelP0, TexelP1, iLOD&0x1f );
        }
    }
    else if (fRatio <= 2.)
    {
        // here for 2:1 or less - do two lookups and average them

        // compute x,y steps from sample center
        FLOAT fStep = .5*(fRatio-1.);
        FLOAT fUStep = fDelta[0]*fStep;
        FLOAT fVStep = fDelta[1]*fStep;

        // do + side lookup
        if ( bSingleMap )
        {
            // single map lookup for magnify
            TexelP = DoLookup( iStage, fU+fUStep*fUStepScaleHi, fV+fVStep*fVStepScaleHi, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelP0 = DoLookup( iStage, fU+fUStep*fUStepScaleHi, fV+fVStep*fVStepScaleHi, iLODHi, FALSE);
            TexelP1 = DoLookup( iStage, fU+fUStep*fUStepScaleLo, fV+fVStep*fVStepScaleLo, iLODLo, FALSE);
            LerpColor( TexelP, TexelP0, TexelP1, iLOD&0x1f );
        }

        // do - side lookup
        if ( bSingleMap )
        {
            // single map lookup for magnify
            TexelM = DoLookup( iStage, fU-fUStep*fUStepScaleHi, fV-fVStep*fVStepScaleHi, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelM0 = DoLookup( iStage, fU-fUStep*fUStepScaleHi, fV-fVStep*fVStepScaleHi, iLODHi, FALSE);
            TexelM1 = DoLookup( iStage, fU-fUStep*fUStepScaleLo, fV-fVStep*fVStepScaleLo, iLODLo, FALSE);
            LerpColor( TexelM, TexelM0, TexelM1, iLOD&0x1f );
        }

        // take average for final texel
        LerpColor( Texel, TexelP, TexelM, 0x10 );
    }
    else
    {
        // here for > 2:1 - walk line of anisotropy; walks out from the center
        // sample point taking two sets of samples (outriggers) per loop, one
        // sample at a positive offset from the center (along the aniso line)
        // and the other at a negative offset from the center

        // this section does stepping for both LODs even though LOD[1] axis
        // is not used for magnify case (only the lookup and lerp(s) are skipped)

        // n.5 fixed point versions of step values
        FLOAT fUStep = fDelta[0];
        FLOAT fVStep = fDelta[1];

        // initialize + and - step parameters - first step is half distance
        FLOAT fUHiP = fU + fUStep*fUStepScaleHi*0.5F;
        FLOAT fVHiP = fV + fVStep*fVStepScaleHi*0.5F;
        FLOAT fULoP = fU + fUStep*fUStepScaleLo*0.5F;
        FLOAT fVLoP = fV + fVStep*fVStepScaleLo*0.5F;
        FLOAT fUHiM = fU - fUStep*fUStepScaleHi*0.5F;
        FLOAT fVHiM = fV - fVStep*fVStepScaleHi*0.5F;
        FLOAT fULoM = fU - fUStep*fUStepScaleLo*0.5F;
        FLOAT fVLoM = fV - fVStep*fVStepScaleLo*0.5F;

        // step and accumulate color channels
        FLOAT fTexelAcc[4] = { 0.f, 0.f, 0.f, 0.f };    // fp accumulation of texel color
        FLOAT fRatioRem = fRatio;
        FLOAT fInvRatio = 1./fRatio;
        BOOL  bDone = FALSE;
        while (1)
        {
            // do + side lookup
            if ( bSingleMap )
            {
                // single map lookup for magnify
                TexelP = DoLookup( iStage, fUHiP, fVHiP, iLODHi, FALSE );
            }
            else
            {
                // trilerp for minify
                TexelP0 = DoLookup( iStage, fUHiP, fVHiP, iLODHi, FALSE );
                TexelP1 = DoLookup( iStage, fULoP, fVLoP, iLODLo, FALSE );
                LerpColor( TexelP, TexelP0, TexelP1, iLOD&0x1f );
            }

            // do - side lookup
            if ( bSingleMap )
            {
                // single map lookup for magnify
                TexelM = DoLookup( iStage, fUHiM, fVHiM, iLODHi, FALSE );
            }
            else
            {
                // trilerp for minify
                TexelM0 = DoLookup( iStage, fUHiM, fVHiM, iLODHi, FALSE );
                TexelM1 = DoLookup( iStage, fULoM, fVLoM, iLODLo, FALSE );
                LerpColor( TexelM, TexelM0, TexelM1, iLOD&0x1f );
            }

            // compute scaling for these samples
            FLOAT fAccScale = fInvRatio;
            if ( fRatioRem < 2.f )
            {
                // scale for last outriggers is half of remainder (each)
                fAccScale = fRatioRem*.5f*fInvRatio;
                bDone = TRUE;
            }

            // do accumulations
            fTexelAcc[0] += fAccScale * FLOAT(TexelP.A);
            fTexelAcc[1] += fAccScale * FLOAT(TexelP.R);
            fTexelAcc[2] += fAccScale * FLOAT(TexelP.G);
            fTexelAcc[3] += fAccScale * FLOAT(TexelP.B);

            fTexelAcc[0] += fAccScale * FLOAT(TexelM.A);
            fTexelAcc[1] += fAccScale * FLOAT(TexelM.R);
            fTexelAcc[2] += fAccScale * FLOAT(TexelM.G);
            fTexelAcc[3] += fAccScale * FLOAT(TexelM.B);

            // bail from here if last outrigger
            if (bDone) { break; }

            // advance to next outriggers
            fUHiP += fUStep*fUStepScaleHi;
            fVHiP += fVStep*fVStepScaleHi;
            fULoP += fUStep*fUStepScaleLo;
            fVLoP += fVStep*fVStepScaleLo;
            fUHiM -= fUStep*fUStepScaleHi;
            fVHiM -= fVStep*fVStepScaleHi;
            fULoM -= fUStep*fUStepScaleLo;
            fVLoM -= fVStep*fVStepScaleLo;
            fRatioRem -= 2.f;
        }

        // clamp accumulator and copy into RRColor for return
        Texel.A = MIN( 1.f, fTexelAcc[0] );
        Texel.R = MIN( 1.f, fTexelAcc[1] );
        Texel.G = MIN( 1.f, fTexelAcc[2] );
        Texel.B = MIN( 1.f, fTexelAcc[3] );
    }
}

//-----------------------------------------------------------------------------
//
// DoBumpMapping - Called once per buxel to compute the bump map delta's
// and the bump map modulate factor to be used in the next texturing stage.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoBumpMapping(
    INT32 iStage,
    RRTextureCoord TCoord,
    FLOAT& fBumpMapUDelta, FLOAT& fBumpMapVDelta, RRColor& BumpMapModulate)
{
    // do full lookup using enabled filtering
    RRColor Buxel;
    DoLookupAndFilter(iStage, TCoord, Buxel);

    FLOAT fDU = Buxel.R;    // follows convention from read color routine
    FLOAT fDV = Buxel.G;
    FLOAT fL  = Buxel.B;

    // grab transform from renderstate
    FLOAT fM00    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT00];
    FLOAT fM01    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT01];
    FLOAT fM10    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT10];
    FLOAT fM11    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT11];

    // apply transforms to deltas from map to form delta return values
    fBumpMapUDelta = fM00 * fDU + fM10 * fDV;
    fBumpMapVDelta = fM01 * fDU + fM11 * fDV;

    // apply scale/bias/clamp to luminance and form RRColor for return
    if (m_pStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE)
    {
        FLOAT fLScale = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVLSCALE];
        FLOAT fLOff   = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVLOFFSET];
        fL = fL * fLScale + fLOff;
        fL = min(max(fL, 0.0f), 1.0F);
        BumpMapModulate.R = fL;
        BumpMapModulate.G = fL;
        BumpMapModulate.B = fL;
    }
    else
    {
        // if not BUMPENVMAPLUMINANCE, always return full intensity white
        BumpMapModulate.R = 1.0F;
        BumpMapModulate.G = 1.0F;
        BumpMapModulate.B = 1.0F;
    }
    BumpMapModulate.A = 1.0F;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Mapping Utility Functions                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// various approximations and tricks to speed up the texture map coverage
// computations
//
// these have not been really thoroughly tested, so use at your own risk...
//

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
#define FLOAT_OOEXPSCALE        ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

static inline FLOAT
RR_LOG2(FLOAT f)
{
    return (FLOAT)(AS_INT32(f) - INT32_FLOAT_ONE) * FLOAT_OOEXPSCALE;
}

static inline FLOAT
RR_ALOG2(FLOAT f)
{
    INT32 i = (INT32)(f * FLOAT_EXPSCALE) + INT32_FLOAT_ONE;
    return AS_FLOAT((long int)i);
}

static inline FLOAT
RR_ABSF(FLOAT f)
{
    UINT32 i = AS_UINT32(f) & 0x7fffffff;
    return AS_FLOAT((unsigned long int)i);
}

static inline FLOAT
RR_SQRT(FLOAT f)
{
    INT32 i = (AS_INT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return AS_FLOAT((long int)i);
}

//
// Steve Gabriel's version of an octagonal approximation euclidian distance -
// return is approximating sqrt(fX*fX + fY*fY)
//
static inline FLOAT
RR_LENGTH(FLOAT fX, FLOAT fY)
{
    fX = RR_ABSF(fX);
    fY = RR_ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for standard trilinear mipmapping, in which
// the four texture index gradients are consolidated into a single number
// to select level of detail.
//
// The basic approach is to compute the lengths of the pixel coverage for
// the X and Y extent of the approximate pixel coverage area.  These two
// lengths are then combined in one of several possible methods for the
// single LOD result.
//
// There are several other ways of doing this which are less computationally
// expensive but also produce less desirable results...
//
//-----------------------------------------------------------------------------
void
ComputeSimpleLevelOfDetail( const RRTextureCoord& TCoord, FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( TCoord.fDUDX, TCoord.fDVDX );
    FLOAT fLenY = RR_LENGTH( TCoord.fDUDY, TCoord.fDVDY );
    FLOAT fCoverage;

    switch ( 3 /* LOD computation type */ )
    {

    // this is probably the best of the lot
    case 1 /* AREA    */ : fCoverage = RR_SQRT(fLenX*fLenY); break;

    // we have not actually tried this one yet, but think it might
    // be pretty good
    case 2 /* AVERAGE */ : fCoverage = (fLenX+fLenY)/2; break;

    // these are fairly inexpensive, but MAX is a bit too fuzzy
    // and MIN is a bit too sharp
    case 3 /* MAX     */ : fCoverage = MAX( fLenX, fLenY ); break;
    case 4 /* MIN     */ : fCoverage = MIN( fLenX, fLenY ); break;

    // these are really inexpensive, but look terrible - you might as
    // well just point sample...
    case 5 /* MINGRAD */ : fCoverage = MIN( MIN( MIN( TCoord.fDUDX,
                                                      TCoord.fDVDX ),
                                                 TCoord.fDUDY ),
                                            TCoord.fDVDY ); break;
    case 6 /* MAXGRAD */ : fCoverage = MAX( MAX( MAX( TCoord.fDUDX,
                                                      TCoord.fDVDX ),
                                                 TCoord.fDUDY ),
                                            TCoord.fDVDY ); break;
    }

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail and other factors in preparation for anisotropic
// filtering.
//
//-----------------------------------------------------------------------------
void
ComputeAnisotropicLevelOfDetail(
    const RRTextureCoord& TCoord, FLOAT fMaxAniso, // inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] )   // outputs
{
    // compute axis lengths and determinant
    FLOAT fLenX2 = (TCoord.fDUDX*TCoord.fDUDX)+(TCoord.fDVDX*TCoord.fDVDX);
    FLOAT fLenY2 = (TCoord.fDUDY*TCoord.fDUDY)+(TCoord.fDVDY*TCoord.fDVDY);
    FLOAT fDet = RR_ABSF((TCoord.fDUDX*TCoord.fDVDY)-(TCoord.fDUDY*TCoord.fDVDX));

    // select major axis
    BOOL bXMajor = (fLenX2 > fLenY2);

    // TODO: can and probably should do this part in log2 domain

    // select and normalize steps; compute aniso ratio
    FLOAT fMaj2 = (bXMajor) ? (fLenX2) : (fLenY2);
    FLOAT fMaj = RR_SQRT(fMaj2);
    FLOAT fMajNorm = 1./fMaj;
    fDelta[0] = ( bXMajor ? TCoord.fDUDX : TCoord.fDUDY ) * fMajNorm;
    fDelta[1] = ( bXMajor ? TCoord.fDVDX : TCoord.fDVDY ) * fMajNorm;
    fRatio = (fDet != 0.F) ? (fMaj2/fDet) : (FLT_MAX);

    // clamp ratio and compute LOD
    FLOAT fMin;
    if ( fRatio > fMaxAniso )
    {
        // ratio is clamped - LOD is based on ratio (preserves area)
        fRatio = fMaxAniso;
        fMin = fMaj/fRatio;
    }
    else
    {
        // ratio not clamped - LOD is based on area
        fMin = fDet/fMaj;
    }

    // clamp to top LOD
    if (fMin < 1.0)
    {
        fRatio = MAX( 1.0, fRatio*fMin );
        fMin = 1.0;
    }

    // take log2 of minor for LOD
    fLOD = RR_LOG2(fMin);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Environment mapping routines                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Processes the environment mapping normal and converts to a standard
// U, V coord range for subsequent routines.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvProcessNormal(INT32 iStage,
                              RREnvTextureCoord ECoord,     // local copy
                              RRColor& TextureColor)
{
#define ENV_RIGHT   0
#define ENV_LEFT    1
#define ENV_TOP     2
#define ENV_BOTTOM  3
#define ENV_FRONT   4
#define ENV_BACK    5

#define POS_NX 1
#define POS_NY 2
#define POS_NZ 3
#define NEG_NORM 4
#define NEG_NX (NEG_NORM | POS_NX)
#define NEG_NY (NEG_NORM | POS_NY)
#define NEG_NZ (NEG_NORM | POS_NZ)

    // If we add per pixel normal reflection
//    FLOAT fENX = ECoord.fENX;
//    FLOAT fENY = ECoord.fENY;
//    FLOAT fENZ = ECoord.fENZ;
//
//    FLOAT fNDotE = ECoord.fNX*fENX + ECoord.fNY*fENY + ECoord.fNZ*fENZ;
//    FLOAT fNDotN = ECoord.fNX*ECoord.fNX + ECoord.fNY*ECoord.fNY + ECoord.fNZ*ECoord.fNZ;
//    fNDotE *= 2.0F;
//    ECoord.fNX = ECoord.fNX*fNDotE - fENX*fNDotN;
//    ECoord.fNY = ECoord.fNY*fNDotE - fENY*fNDotN;
//    ECoord.fNZ = ECoord.fNZ*fNDotE - fENZ*fNDotN;

    // determine which is the dominant normal
    UINT32 uMap;
    FLOAT fAbsNX = fabs(ECoord.fNX);
    FLOAT fAbsNY = fabs(ECoord.fNY);
    FLOAT fAbsNZ = fabs(ECoord.fNZ);

    if (fAbsNX > fAbsNY) {
        if (fAbsNX > fAbsNZ)
            // fNX
            uMap = POS_NX | ((ECoord.fNX < 0.0) ? (NEG_NORM) : 0);
        else
            // fNZ
            uMap = POS_NZ | ((ECoord.fNZ < 0.0) ? (NEG_NORM) : 0);
    } else {
        if (fAbsNY > fAbsNZ)
            // fNY
            uMap = POS_NY | ((ECoord.fNY < 0.0) ? (NEG_NORM) : 0);
        else
            // fNZ
            uMap = POS_NZ | ((ECoord.fNZ < 0.0) ? (NEG_NORM) : 0);
    }

    RRTextureCoord TCoord;

    switch (uMap) {
    case POS_NX:
        TCoord.fDUDX = -ECoord.fDNZDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY = -ECoord.fDNZDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU = -ECoord.fNZ;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_RIGHT, ECoord.fNX, ECoord.fDNXDX, ECoord.fDNXDY, TCoord, TextureColor);
        break;

    case POS_NY:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX =  ECoord.fDNZDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY =  ECoord.fDNZDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV =  ECoord.fNZ;
        DoEnvLookupAndFilter(iStage, ENV_TOP, ECoord.fNY, ECoord.fDNYDX, ECoord.fDNYDY, TCoord, TextureColor);
        break;

    case POS_NZ:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_FRONT, ECoord.fNZ, ECoord.fDNZDX, ECoord.fDNZDY, TCoord, TextureColor);
        break;

    case NEG_NX:
        TCoord.fDUDX =  ECoord.fDNZDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY =  ECoord.fDNZDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU =  ECoord.fNZ;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_LEFT, -ECoord.fNX, -ECoord.fDNXDX, -ECoord.fDNXDY, TCoord, TextureColor);
        break;

    case NEG_NY:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNZDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNZDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV = -ECoord.fNZ;
        DoEnvLookupAndFilter(iStage, ENV_BOTTOM, -ECoord.fNY, -ECoord.fDNYDX, -ECoord.fDNYDY, TCoord, TextureColor);
        break;

    case NEG_NZ:
        TCoord.fDUDX = -ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY = -ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU = -ECoord.fNX;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_BACK, -ECoord.fNZ, -ECoord.fDNZDX, -ECoord.fDNZDY, TCoord, TextureColor);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// DoEnvLookupAndFilter - Environment mapped version.
// Called once per active texture stage to compute
// coverage (level-of-detail) and invoke texel read and filtering routines.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvLookupAndFilter(INT32 iStage, INT16 iFace, FLOAT fMajor, FLOAT fDMDX, FLOAT fDMDY,
                                RRTextureCoord TCoord,      // local copy
                                RRColor& TextureColor)
{
    if (m_pDDSLcl[iFace])
    {
        // faces exist
        FLOAT fInvMajor = 1.0/fMajor;

        // compute d(U/Major)/dx, etc. using rule for differentiating quotients
        TCoord.fDUDX = (fMajor*TCoord.fDUDX - TCoord.fU*fDMDX)*fInvMajor*fInvMajor;
        TCoord.fDUDY = (fMajor*TCoord.fDUDY - TCoord.fU*fDMDY)*fInvMajor*fInvMajor;
        TCoord.fDVDX = (fMajor*TCoord.fDVDX - TCoord.fV*fDMDX)*fInvMajor*fInvMajor;
        TCoord.fDVDY = (fMajor*TCoord.fDVDY - TCoord.fV*fDMDY)*fInvMajor*fInvMajor;

        // convert to -1 to 1 range
        TCoord.fU *= fInvMajor;
        TCoord.fV *= fInvMajor;

        // convert to 0.0 to 1.0
        TCoord.fU = (TCoord.fU*.5 + .5);
        TCoord.fV = (TCoord.fV*.5 + .5);

        // check for potential mip mapping
        BOOL bDoMipMap = ( m_cLOD > 0 ) && ( m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] > D3DTFP_NONE );

        // check for requirement to do level-of-detail (coverage) computation - either
        // for mipmap or per-pixel filter selection
        BOOL bComputeLOD = bDoMipMap ||
            ( m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] != m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] );

        if ( bDoMipMap || bComputeLOD )
        {
            // here if doing mipmapping or anisotropic filtering, or just have a mismatch
            // between the min and mag filters, so compute level of detail (and maybe aniso
            // coverage)

            // scale gradients to texture LOD 0 size
            TCoord.fDUDX *= (FLOAT)m_iTexSize[0]*.5F;
            TCoord.fDUDY *= (FLOAT)m_iTexSize[0]*.5F;
            TCoord.fDVDX *= (FLOAT)m_iTexSize[1]*.5F;
            TCoord.fDVDY *= (FLOAT)m_iTexSize[1]*.5F;

            FLOAT fLOD;
            ComputeEnvMapLevelOfDetail(TCoord, fLOD);

            // apply bias and compute integer (n.5) LOD
            INT16 iLOD = 0;
            if ( bComputeLOD )
            {
                // apply LOD offset
                fLOD += m_pStageState[iStage].m_fVal[D3DTSS_MIPMAPLODBIAS];
                // convert LOD to n.5 fixed point integer
                iLOD = AS_INT16( fLOD + FLOAT_5_SNAP );
            }

            // determine if magnifying or minifying
            BOOL bMagnify = ( iLOD <= 0 );

            // zero out LOD if not mipmapping
            if ( !bDoMipMap ) { iLOD = 0; }

            // do different filtering for magnify vs. minify
            if ( bMagnify )
            {
                DoEnvMagnify( iStage, TCoord, iFace, TextureColor );
            }
            else
            {
                if ( !bDoMipMap ||
                    ( bDoMipMap && ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] ) ) )
                {
                    DoEnvMinify( iStage, TCoord, iFace, iLOD, TextureColor );
                }
                else
                {
                    DoEnvTrilerp( iStage, TCoord, iFace, iLOD, TextureColor );
                }
            }
        }
        else
        {
            // here for no mipmaps and matching (and non-aniso) min and mag filters,
            // so just apply mag filter
            DoEnvMagnify( iStage, TCoord, iFace, TextureColor );
        }
    }
    else
    {
        // face doesn't exit, return empty face color
        TextureColor = m_dwEmptyFaceColor;
    }
}

//-----------------------------------------------------------------------------
//
// TexelAvg4 - Averages 4 source texels into 1 destination texel for A, R, G,
// and B.
//
//-----------------------------------------------------------------------------
static void TexelAvg4(RRColor& Texel, RRColor Texel0, RRColor Texel1, RRColor Texel2, RRColor Texel3)
{
    Texel.A = Texel0.A + Texel1.A + Texel2.A + Texel3.A;
    Texel.R = Texel0.R + Texel1.R + Texel2.R + Texel3.R;
    Texel.G = Texel0.G + Texel1.G + Texel2.G + Texel3.G;
    Texel.B = Texel0.B + Texel1.B + Texel2.B + Texel3.B;
    Texel.A = Texel.A * 0.25f;
    Texel.R = Texel.R * 0.25f;
    Texel.G = Texel.G * 0.25f;
    Texel.B = Texel.B * 0.25f;
}

//-----------------------------------------------------------------------------
//
// DoEnvLookup - Does a full lookup given floating point U, V and handles all
// nearest vs bilinear and LOD issues.
//
//-----------------------------------------------------------------------------
RRColor RRTexture::DoEnvLookup(INT32 iStage, RRTextureCoord TCoord, INT16 iFace, INT16 iLOD, BOOL bNearest)
{
    FLOAT U = TCoord.fU;
    FLOAT V = TCoord.fV;
    RRColor Texel;
    INT32 cUPixels = 1 << MAX(m_iTexShift[0]-iLOD,0);
    INT32 cVPixels = 1 << MAX(m_iTexShift[1]-iLOD,0);
    FLOAT fScaledU = ( U * (FLOAT)cUPixels ) -.5f;
    FLOAT fScaledV = ( V * (FLOAT)cVPixels ) -.5f;

    // LSB-aligned masks of index bits within current LOD
    INT16 iUMask = m_uTexMask[0] >> iLOD;
    INT16 iVMask = m_uTexMask[1] >> iLOD;

    if(bNearest)
    {
        INT32 iU, iV;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if (U >= 0.0f)
        {
            iU = fScaledU + .5f;
        }
        else
        {
            iU = fScaledU - .5f;
        }
        if (V >= 0.0f)
        {
            iV = fScaledV + .5f;
        }
        else
        {
            iV = fScaledV - .5f;
        }

        // clamp
        iU = MAX( 0, MIN( iU, iUMask ) );
        iV = MAX( 0, MIN( iV, iVMask ) );

        BOOL bColorKeyMatched = FALSE;

        // "LOD" just used to access correct map
        ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);

        // merge colorkey match info from previous invocation
        m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched;
    }
    else
    {
        if ((m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] == D3DTFG_FLATCUBIC) ||
            (m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] == D3DTFG_GAUSSIANCUBIC))
        {
            // use wider 3x3 trapezoid filter

            //
            // For the top LOD, if we are interpolating beyond the edge of the
            // texture, correct the interpolation to minimize the artifacts seen in
            // small, diffuse environment maps which tend to emphasize the edges
            // of the cubemap.
            //
            if (iLOD == 0)
            {
                FLOAT fFracU = 0.0f;
                FLOAT fCorrectionU = 0.0f;
                FLOAT fCorrectionV = 0.0f;
                if ((fScaledU < 0.5f) || (fScaledU > ((FLOAT)iUMask-0.5f)))
                {
                    // U crosses a boundary, clamp fScaledV
                    if (fScaledU < 0.5f)
                    {
                        // make fFrac always positive
                        fFracU = 0.5f-fScaledU;
                    }
                    else
                    {
                        fFracU = fScaledU - ((FLOAT)iUMask-0.5f);
                    }
                    // 2.0/2.0 = 1.0 provides the perfect correction at the cube corner.
                    // This can be seen be looking at the derivative of the intersection
                    // of a cone and a cube at the cube corner.
                    //
                    // correction must be corrected for the filter width (hence the *0.5f)
                    fCorrectionV = -fFracU*(TCoord.fV-.5f)*0.5f;
                }
                if ((fScaledV < 0.5f) || (fScaledV > ((FLOAT)iVMask-0.5f)))
                {
                    // V crosses a boundary, clamp fScaledU
                    FLOAT fFracV;
                    if (fScaledV < 0.5f)
                    {
                        // make fFrac always positive
                        fFracV = 0.5f-fScaledV;
                    }
                    else
                    {
                        fFracV = fScaledV - ((FLOAT)iVMask-0.5f);
                    }
                    fCorrectionU = -fFracV*(TCoord.fU-.5f)*0.5f;
                    if (fFracU != 0.0f)
                    {
                        // At the corners of the cube, we need to blend away the
                        // edge correction so that it is 0 at exactly the corner
                        // center.  This linear function does fine.
                        fCorrectionU *= (1.0f - fFracU);
                        fCorrectionV *= (1.0f - fFracV);
                    }
                }
                fScaledU += fCorrectionU;
                fScaledV += fCorrectionV;
            }

            INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
            INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );

            // extract fraction bits
            UINT8 uUFrac = iU&0x1f;
            UINT8 uVFrac = iV&0x1f;

            // take floor
            INT16 iU0 = iU>>5;
            INT16 iV0 = iV>>5;

            // average to find the center texel
            INT32 iUC = (uUFrac >= 0x10) ? (iU0 + 1) : (iU0);
            INT32 iVC = (uVFrac >= 0x10) ? (iV0 + 1) : (iV0);

            // get 9 surrounding samples
            //           VU       VU       VU
            RRColor Texel00, Texel01, Texel02;
            RRColor Texel10, Texel11, Texel12;
            RRColor Texel20, Texel21, Texel22;
            BOOL bColorKeyMatchedT = FALSE;
            DoEnvReMap(iUC-1, iVC-1, iUMask, iVMask, iFace, iLOD, Texel00, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC-1, iUMask, iVMask, iFace, iLOD, Texel01, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC-1, iUMask, iVMask, iFace, iLOD, Texel02, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            DoEnvReMap(iUC-1, iVC+0, iUMask, iVMask, iFace, iLOD, Texel10, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC+0, iUMask, iVMask, iFace, iLOD, Texel11, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC+0, iUMask, iVMask, iFace, iLOD, Texel12, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            DoEnvReMap(iUC-1, iVC+1, iUMask, iVMask, iFace, iLOD, Texel20, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC+1, iUMask, iVMask, iFace, iLOD, Texel21, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC+1, iUMask, iVMask, iFace, iLOD, Texel22, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            // sum the samples into 4 areas
            RRColor TexelT00, TexelT01, TexelT10, TexelT11;
            TexelAvg4(TexelT00, Texel00, Texel01, Texel10, Texel11);
            TexelAvg4(TexelT01, Texel01, Texel02, Texel11, Texel12);
            TexelAvg4(TexelT10, Texel10, Texel11, Texel20, Texel21);
            TexelAvg4(TexelT11, Texel11, Texel12, Texel21, Texel22);

            // correct the fraction to be around the center sample
            uUFrac = (uUFrac + 0x10) & 0x1f;
            uVFrac = (uVFrac + 0x10) & 0x1f;

            // use a bilerp to get the final sample
            BiLerpColor( Texel, TexelT00,TexelT01, TexelT10,TexelT11, uUFrac,uVFrac);
        }
        else
        {
            // bilinear

            //
            // For the top LOD, if we are interpolating beyond the edge of the
            // texture, correct the interpolation to minimize the artifacts seen in
            // small, diffuse environment maps which tend to emphasize the edges
            // of the cubemap.
            //
            if (iLOD == 0)
            {
                FLOAT fFracU = 0.0f;
                FLOAT fCorrectionU = 0.0f;
                FLOAT fCorrectionV = 0.0f;
                if ((fScaledU < 0.0f) || (fScaledU > (FLOAT)iUMask))
                {
                    // U crosses a boundary, clamp fScaledV
                    if (fScaledU < 0.0f)
                    {
                        // make fFrac always positive
                        fFracU = -fScaledU;
                    }
                    else
                    {
                        fFracU = fScaledU - (FLOAT)iUMask;
                    }
                    // 2.0/2.0 = 1.0 provides the perfect correction at the cube corner.
                    // This can be seen be looking at the derivative of the intersection
                    // of a cone and a cube at the cube corner.
                    fCorrectionV = -fFracU*(TCoord.fV-.5f);
                }
                if ((fScaledV < 0.0f) || (fScaledV > (FLOAT)iVMask))
                {
                    // V crosses a boundary, clamp fScaledU
                    FLOAT fFracV;
                    if (fScaledV < 0.0f)
                    {
                        // make fFrac always positive
                        fFracV = -fScaledV;
                    }
                    else
                    {
                        fFracV = fScaledV - (FLOAT)iVMask;
                    }
                    fCorrectionU = -fFracV*(TCoord.fU-.5f);
                    if (fFracU != 0.0f)
                    {
                        // At the corners of the cube, we need to blend away the
                        // edge correction so that it is 0 at exactly the corner
                        // center.  This linear function does fine.
                        fCorrectionU *= 2.0f*(.5f - fFracU);
                        fCorrectionV *= 2.0f*(.5f - fFracV);
                    }
                }
                fScaledU += fCorrectionU;
                fScaledV += fCorrectionV;
            }

            INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
            INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );

            // extract fraction bits
            UINT8 uUFrac = iU&0x1f;
            UINT8 uVFrac = iV&0x1f;

            // take floor for (0,0) sample coords
            INT16 iU0 = iU>>5;
            INT16 iV0 = iV>>5;
            // take ceiling for (1,1) sample coords
            INT16 iU1 = iU0+1;
            INT16 iV1 = iV0+1;

            // grab four adjacent samples
            RRColor Texel00, Texel01, Texel10, Texel11;
            BOOL bColorKeyMatched00 = FALSE;
            BOOL bColorKeyMatched01 = FALSE;
            BOOL bColorKeyMatched10 = FALSE;
            BOOL bColorKeyMatched11 = FALSE;

            DoEnvReMap(iU0, iV0, iUMask, iVMask, iFace, iLOD, Texel00, bColorKeyMatched00);
            DoEnvReMap(iU1, iV0, iUMask, iVMask, iFace, iLOD, Texel01, bColorKeyMatched01);
            DoEnvReMap(iU0, iV1, iUMask, iVMask, iFace, iLOD, Texel10, bColorKeyMatched10);
            DoEnvReMap(iU1, iV1, iUMask, iVMask, iFace, iLOD, Texel11, bColorKeyMatched11);

            // only set 'colorkey matched' if at least one matched value has
            // a non-zero contribution (note that it is not possible for 00
            // to have no contribution)
            if (uUFrac == 0x00) {
                // 01 and 11 have zero weight if U fraction is zero
                bColorKeyMatched01 = bColorKeyMatched11 = FALSE;
            }
            if (uVFrac == 0x00) {
                // 10 and 11 have zero weight if V fraction is zero
                bColorKeyMatched10 = bColorKeyMatched11 = FALSE;
            }

            // merge colorkey match info from previous invocation
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched00 || bColorKeyMatched01 ||
                bColorKeyMatched10 || bColorKeyMatched11;

            // do bilinear filter
            BiLerpColor( Texel, Texel00,Texel01, Texel10,Texel11, uUFrac,uVFrac);
        }
    }
    return Texel;
}

//-----------------------------------------------------------------------------
//
// DoEnvMagnify - This is used for all magnification filter modes except
// anisotropic.
//
// Currently only POINT and BILINEAR are supported.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvMagnify(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, RRColor& Texel )
{
    // do lookup, applying MAG filter
    Texel = DoEnvLookup( iStage, TCoord, iFace, 0,
                      (D3DTFG_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER]) );
}


//-----------------------------------------------------------------------------
//
// DoEnvMinify - This is used for POINT and BILINEAR modes (non-trilinear)
// for minification, and also handles POINT mip filter (nearest LOD).
//
// iLOD is n.5 fixed point
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvMinify(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel )
{
    // round and drop fraction from LOD (is n.5 fixed point)
    iLOD += 0x10; iLOD &= ~(0x1f);
    // convert to n.0
    iLOD >>= 5;
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, m_cLOD );

    // do lookup, applying MIN filter
    Texel = DoEnvLookup( iStage, TCoord, iFace, iLOD,
                      (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );
}

//-----------------------------------------------------------------------------
//
// DoEnvTrilerp - Does trilinear environment map filtering.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvTrilerp(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel)
{
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, (m_cLOD)<<5 );
    // compute index for two adjacent LODs (with clamp)
    INT16 iLODHi = iLOD>>5;  // floor
    INT16 iLODLo = MIN(iLODHi+1,m_cLOD);

    // check for filter type for within LOD map
    BOOL bNearest = (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]);

    // trilerp - look up each map then lerp between them
    // important for colorkey to not include texels with no contribution
    if (0x00 != (iLOD&0x1f))
    {
        // trilerp - look up each map then lerp between them
    RRColor Texel0 = DoEnvLookup(iStage, TCoord, iFace, iLODHi, bNearest);
    RRColor Texel1 = DoEnvLookup(iStage, TCoord, iFace, iLODLo, bNearest);
    LerpColor( Texel, Texel0, Texel1, iLOD&0x1f );
}
    else
    {
        Texel = DoEnvLookup(iStage, TCoord, iFace, iLODHi, bNearest);
    }
}

//
// uEnvEdgeTable
//
// This table looks up how to map a given U and V that are out of range
// on their primary face.  The first index to the table is the current
// face.  The second index is 0 if V is in range, 1 if V is negative
// and 2 if V is larger than the texture.  Likewise, the last index is 0
// if U is in range, 1 if U is negative, and 2 if U is larger than
// than the texture.
//
// For the underdefined cases where 2 coordinates are out at the same time,
// we do the U wrap but not V.

//
// defines for the actions returned by the uEnvEdgeTable
//
#define EET_FACEMASK 0x07    // new face
#define EET_FU       0x10    // flip U on the texture map
#define EET_FV       0x20    // flip V on the texture map
#define EET_SUV      0x40    // swap U and V

//
// When both U and V are out, it is arbitrary which other
// face you pick.  However, picking any one face other than the base
// face biases the result in visually disturbing ways.  Therefore,
// take them both and average them.
//
static UINT8 uEnvEdgeTable[6][3][3] =
{
    {   // U0 NU PU                             // face 0
        {0xff, 4, 5},                           // V in range
        {EET_FU|EET_SUV|2,  0xff, 0xff},        // V Neg
        {EET_FV|EET_SUV|3,  0xff, 0xff},        // V too large
    },
    {                                           // face 1
        {0xff, 5, 4},
        {EET_FV|EET_SUV|2,  0xff, 0xff},
        {EET_FU|EET_SUV|3,  0xff, 0xff},
    },
    {                                           // face 2
        {0xff, EET_FU|EET_SUV|1, EET_FV|EET_SUV|0},
        {EET_FU|EET_FV|5,   0xff, 0xff},
        {4,                 0xff, 0xff},
    },
    {                                           // face 3
        {0xff, EET_FV|EET_SUV|1, EET_FU|EET_SUV|0},
        {4,                 0xff, 0xff},
        {EET_FU|EET_FV|5,   0xff, 0xff},
    },
    {                                           // face 4
        {0xff, 1, 0},
        {2,                 0xff, 0xff},
        {3,                 0xff, 0xff},
    },
    {                                           // face 5
        {0xff, 0, 1},
        {EET_FU|EET_FV|2,   0xff, 0xff},
        {EET_FU|EET_FV|3,   0xff, 0xff},
    },
};

//-----------------------------------------------------------------------------
//
// DoTableInterp - Environment mapping utility.
// Interprets the edge table and does a lookup
//
//-----------------------------------------------------------------------------
void
RRTexture::DoTableInterp(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD,
                         UINT8 uUSign, UINT8 uVSign, RRColor &Texel, BOOL &bColorKeyMatched)
{
    UINT8 uTable = uEnvEdgeTable[iFace][uVSign][uUSign];
    _ASSERT( uTable != 0xff, "Illegal environment map lookup" );
    if (uTable & EET_FU)
    {
        iU = iUMask - iU;
    }
    if (uTable & EET_FV)
    {
        iV = iVMask - iV;
    }
    if (uTable & EET_SUV)
    {
        INT16 iT = iU;
        iU = iV;
        iV = iT;
    }
    iFace = uTable & EET_FACEMASK;
    ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);
}

//-----------------------------------------------------------------------------
//
// DoEnvReMap - Environment mapping utility.
// Determines if either of the texture coordinates are out of range, and
// remaps the coordinate to the correct coordinate on the proper face of the
// environment cube.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvReMap(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD, RRColor &Texel,
                      BOOL &bColorKeyMatched)
{
    UINT8 iUNeg = (UINT8)(iU < 0);
    UINT8 iUPos = (UINT8)(iU > iUMask);
    UINT8 iVNeg = (UINT8)(iV < 0);
    UINT8 iVPos = (UINT8)(iV > iVMask);

    if (!(iUNeg || iUPos || iVNeg || iVPos))
    {
        ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);
    }
    else
    {
        // put all U,V's in range with wrap function
        INT16 iUMasked = iU & iUMask;
        INT16 iVMasked = iV & iVMask;
        INT16 iUClampd = min(max(iU, 0), iUMask);
        INT16 iVClampd = min(max(iV, 0), iVMask);
        UINT8 uUSign = (iUNeg) | (iUPos<<1);
        UINT8 uVSign = (iVNeg) | (iVPos<<1);
        if ((uVSign != 0) && (uUSign != 0))
        {
            // off the edge of the map in two directions.  Go off each direction individually,
            // and average the result.
            RRColor Texel0, Texel1;
            DoTableInterp(iUClampd, iVMasked, iUMask, iVMask, iFace, iLOD, 0, uVSign, Texel0, bColorKeyMatched);
            DoTableInterp(iUMasked, iVClampd, iUMask, iVMask, iFace, iLOD, uUSign, 0, Texel1, bColorKeyMatched);
            LerpColor( Texel, Texel0, Texel1, 0x10 );
        }
        else
        {
            DoTableInterp(iUMasked, iVMasked, iUMask, iVMask, iFace, iLOD, uUSign, uVSign, Texel, bColorKeyMatched);
        }
    }
}

//-----------------------------------------------------------------------------
//
// RRTexture::Initialize()
//
//-----------------------------------------------------------------------------
HRESULT
RRTexture::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    HRESULT hr = D3D_OK;
    RRSurfaceType SurfType;
    DDSCAPS2 ddscaps;
    memset(&ddscaps, 0, sizeof(ddscaps));

    m_iWidth = DDSurf_Width(pLcl);
    m_iHeight = DDSurf_Height(pLcl);
    m_cLOD = 0;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &SurfType));

    if ((SurfType == RR_STYPE_DXT1) ||
        (SurfType == RR_STYPE_DXT2) ||
        (SurfType == RR_STYPE_DXT3) ||
        (SurfType == RR_STYPE_DXT4) ||
        (SurfType == RR_STYPE_DXT5))
    {
        // Note, here is the assumption that:
        // 1) width and height are reported correctly by the driver that
        //    created the surface
        // 2) The allocation of the memory is contiguous (as done by hel)
        m_iPitch[0] = ((m_iWidth+3)>>2) *
            g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
    }
    else
    {
        m_iPitch[0] = DDSurf_Pitch(pLcl);
    }
    m_SurfType = SurfType;

    if (SurfType == RR_STYPE_PALETTE8 ||
        SurfType == RR_STYPE_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            m_pPalette = (DWORD*)pPal->lpColorTable;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
    }

    if (!ValidTextureSize((INT16)m_iWidth, (INT16)IntLog2(m_iWidth),
                          (INT16)m_iHeight, (INT16)IntLog2(m_iHeight)))
    {
        return DDERR_INVALIDPARAMS;
    }

    if (pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        m_uFlags |= RR_TEXTURE_ENVMAP;

        LPDDRAWI_DDRAWSURFACE_LCL pDDSNextLcl;
        ddscaps.dwCaps = DDSCAPS_TEXTURE;

        if (!(pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX))
        {
            ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP|DDSCAPS2_CUBEMAP_POSITIVEX;

            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);

            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[0] = NULL;
            }
            else
            {
                // use POSITIVEX surface to query others, if it exists
                pLcl = pDDSNextLcl;
                m_pDDSLcl[0] = pLcl;
            }
        }
        else
        {
            m_pDDSLcl[0] = pLcl;
        }

        // get rest of top level surfaces, in order
        for (INT i = 1; i < 6; i++)
        {
            switch(i)
            {
            case 1: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }
            ddscaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);
            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[i] = NULL;
            }
            else
            {
                m_pDDSLcl[i] = pDDSNextLcl;
            }
        }

        for (i = 0; i < 6; i++)
        {
            pLcl = m_pDDSLcl[i];
            m_cLOD = 0;

            if (pLcl)
            {
                // Check for mipmap if any.
                LPDDRAWI_DDRAWSURFACE_LCL  pTmpSLcl;

                // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
                // mipmap. They are init'ed with the first texture size.
                INT16 iPreSizeU = (INT16)m_iWidth, iPreSizeV = (INT16)m_iHeight;
                for (;;)
                {
                    ddscaps.dwCaps = DDSCAPS_TEXTURE;
                    ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
                    hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
                    if (hr != D3D_OK && hr != DDERR_NOTFOUND)
                    {
                        return hr;
                    }
                    if (hr == DDERR_NOTFOUND)
                    {
                        break;
                    }
                    m_cLOD ++;
                    pLcl = pTmpSLcl;
                    m_pDDSLcl[m_cLOD*6 + i] = pLcl;
                    if ((SurfType == RR_STYPE_DXT1) ||
                        (SurfType == RR_STYPE_DXT2) ||
                        (SurfType == RR_STYPE_DXT3) ||
                        (SurfType == RR_STYPE_DXT4) ||
                        (SurfType == RR_STYPE_DXT5))
                    {
                        // Note, here is the assumption that:
                        // 1) width and height are reported correctly by the driver that
                        //    created the surface
                        // 2) The allocation of the memory is contiguous (as done by ddhel)
                        m_iPitch[m_cLOD] = (((m_iWidth>>m_cLOD)+3)>>2) *
                            g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
                    }
                    else
                    {
                        m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                    }
                    m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                    // Check for invalid mipmap texture size
                    if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                        !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
                    {
                        return DDERR_INVALIDPARAMS;
                    }
                    iPreSizeU = (INT16)DDSurf_Width(pLcl);
                    iPreSizeV = (INT16)DDSurf_Height(pLcl);
                }
            }
        }
    }
    else
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
        {
            m_uFlags |= RR_TEXTURE_SHADOWMAP;
        }

        m_pDDSLcl[0] = pLcl;
        // Check for mipmap if any.
        LPDDRAWI_DDRAWSURFACE_LCL pTmpSLcl;
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous
        // level mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = (INT16)m_iWidth, iPreSizeV = (INT16)m_iHeight;
        for (;;)
        {
            ddscaps.dwCaps = DDSCAPS_TEXTURE;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
            if (hr != D3D_OK && hr != DDERR_NOTFOUND)
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                break;
            }
            m_cLOD ++;
            pLcl = pTmpSLcl;
            m_pDDSLcl[m_cLOD] = pLcl;
            if ((SurfType == RR_STYPE_DXT1) ||
                (SurfType == RR_STYPE_DXT2) ||
                (SurfType == RR_STYPE_DXT3) ||
                (SurfType == RR_STYPE_DXT4) ||
                (SurfType == RR_STYPE_DXT5))
            {
                // Note, here is the assumption that:
                // 1) width and height are reported correctly by the driver that
                //    created the surface
                // 2) The allocation of the memory is contiguous (as done by ddhel)
                m_iPitch[m_cLOD] = (((m_iWidth>>m_cLOD)+3)>>2) *
                    g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
            }
            else
            {
                m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
            }
            m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                // Check for invalid mipmap texture size
                if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                    !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
                {
                    return DDERR_INVALIDPARAMS;
            }
            iPreSizeU = (INT16)DDSurf_Width(pLcl);
            iPreSizeV = (INT16)DDSurf_Height(pLcl);
        }
    }

    m_cLODDDS = m_cLOD;

    if ( !(Validate()) )
    {
        return DDERR_GENERIC;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for environment mapping, looks better if
// we err on the side of fuzziness.
//
//-----------------------------------------------------------------------------
void
ComputeEnvMapLevelOfDetail( const RRTextureCoord& TCoord, FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( TCoord.fDUDX, TCoord.fDVDX );
    FLOAT fLenY = RR_LENGTH( TCoord.fDUDY, TCoord.fDVDY );

    // take max
    FLOAT fCoverage = MAX(fLenX, fLenY);

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// RRTexture::DoTextureTransform - Performs the homogeneous texture transform.
//
//-----------------------------------------------------------------------------
void RRTexture::DoTextureTransform( INT32 iStage, BOOL bAlreadyXfmd,
                                    FLOAT* pfC, FLOAT* pfO, FLOAT* pfQ )
{
    LPD3DMATRIX pM = (LPD3DMATRIX)&m_pStageState[iStage].m_dwVal[D3DTSSI_MATRIX];
    DWORD dwFlags = m_pStageState[iStage].m_dwVal[D3DTSS_TEXTURETRANSFORMFLAGS];
    DWORD dwCount = dwFlags & (D3DTTFF_PROJECTED-1);
    pfO[0] = pfC[0];
    pfO[1] = pfC[1];
    pfO[2] = pfC[2];
    pfO[3] = pfC[3];
    *pfQ = 1.0f;
    if (dwCount != D3DTTFF_DISABLE)
    {
        if( bAlreadyXfmd == FALSE )
        {
            FLOAT x = pfC[0];
            FLOAT y = pfC[1];
            FLOAT z = pfC[2];
            FLOAT w = pfC[3];

            pfO[0] = x*pM->_11 + y*pM->_21 + z*pM->_31 + w*pM->_41;
            pfO[1] = x*pM->_12 + y*pM->_22 + z*pM->_32 + w*pM->_42;
            pfO[2] = x*pM->_13 + y*pM->_23 + z*pM->_33 + w*pM->_43;
            pfO[3] = x*pM->_14 + y*pM->_24 + z*pM->_34 + w*pM->_44;
        }

        if (dwFlags & D3DTTFF_PROJECTED)
        {
            DWORD dwQI = dwCount - 1;

            _ASSERT((dwQI >= 1)&&(dwQI <= 3), "Illegal D3DTTFF_COUNT with D3DTTFF_PROJECTED");

            *pfQ = pfO[dwQI];
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\clipping.hpp ===
#ifndef __CLIPPER_HPP_
#define __CLIPPER_HPP_

//----------------------------------------------------------------------------
// Clipping macros
//----------------------------------------------------------------------------
// Interpolation flags
#define RRCLIP_INTERPOLATE_COLOR       (1<< 0)
#define RRCLIP_INTERPOLATE_SPECULAR    (1<< 1)
#define RRCLIP_INTERPOLATE_TEXTURE     (1<< 2)
#define RRCLIP_INTERPOLATE_S           (1<< 3)
#define RRCLIP_INTERPOLATE_EYENORMAL   (1<< 4)
#define RRCLIP_INTERPOLATE_EYEXYZ      (1<< 5)

// Non guardband clipping bits
#define RRCLIP_LEFT   D3DCLIP_LEFT
#define RRCLIP_RIGHT  D3DCLIP_RIGHT
#define RRCLIP_TOP    D3DCLIP_TOP
#define RRCLIP_BOTTOM D3DCLIP_BOTTOM
#define RRCLIP_FRONT  D3DCLIP_FRONT
#define RRCLIP_BACK   D3DCLIP_BACK

//----------------------------------------------------------------------------
// User define clip plane bits.
// Each of these bits is set if the vertex is clipped by the associated
// clip plane.
//----------------------------------------------------------------------------
#define RRCLIP_USERCLIPPLANE0    D3DCLIP_GEN0
#define RRCLIP_USERCLIPPLANE1    D3DCLIP_GEN1
#define RRCLIP_USERCLIPPLANE2    D3DCLIP_GEN2
#define RRCLIP_USERCLIPPLANE3    D3DCLIP_GEN3
#define RRCLIP_USERCLIPPLANE4    D3DCLIP_GEN4
#define RRCLIP_USERCLIPPLANE5    D3DCLIP_GEN5
const DWORD RRCLIP_USERPLANES_ALL =  (RRCLIP_USERCLIPPLANE0 |
                                      RRCLIP_USERCLIPPLANE1 |
                                      RRCLIP_USERCLIPPLANE2 |
                                      RRCLIP_USERCLIPPLANE3 |
                                      RRCLIP_USERCLIPPLANE4 |
                                      RRCLIP_USERCLIPPLANE5 );

//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     RRCLIP_LEFT bit is set
// if x < -w*ax1           RRCLIPGB_LEFT bit is set
//---------------------------------------------------------------------

#define RRCLIPGB_LEFT    (RRCLIP_USERCLIPPLANE5 << 1)
#define RRCLIPGB_RIGHT   (RRCLIP_USERCLIPPLANE5 << 2)
#define RRCLIPGB_TOP     (RRCLIP_USERCLIPPLANE5 << 3)
#define RRCLIPGB_BOTTOM  (RRCLIP_USERCLIPPLANE5 << 4)




#define RRCLIP_ALL (RRCLIP_LEFT  | RRCLIP_RIGHT   |         \
                    RRCLIP_TOP   | RRCLIP_BOTTOM  |         \
                    RRCLIP_FRONT | RRCLIP_BACK    |         \
                    RRCLIP_USERPLANES_ALL)

#define RRCLIPGB_ALL (RRCLIPGB_LEFT | RRCLIPGB_RIGHT |      \
                      RRCLIPGB_TOP | RRCLIPGB_BOTTOM |      \
                      RRCLIP_FRONT | RRCLIP_BACK     |      \
                      RRCLIP_USERPLANES_ALL)

// If only these bits are set, then this point is inside the guard band
#define RRCLIP_INGUARDBAND (RRCLIP_LEFT | RRCLIP_RIGHT |    \
                            RRCLIP_TOP  | RRCLIP_BOTTOM)
//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define RRCLIP_LEFTBIT     1
#define RRCLIP_RIGHTBIT    2
#define RRCLIP_TOPBIT      3
#define RRCLIP_BOTTOMBIT   4
#define RRCLIP_FRONTBIT    5
#define RRCLIP_BACKBIT     6

#define RRCLIP_USERCLIPLANE0BIT     7
#define RRCLIP_USERCLIPLANE1BIT     8
#define RRCLIP_USERCLIPLANE2BIT     9
#define RRCLIP_USERCLIPLANE3BIT     10
#define RRCLIP_USERCLIPLANE4BIT     11
#define RRCLIP_USERCLIPLANE5BIT     12

#define RRCLIPGB_LEFTBIT   13
#define RRCLIPGB_RIGHTBIT  14
#define RRCLIPGB_TOPBIT    15
#define RRCLIPGB_BOTTOMBIT 16

#define CLIPPED_LEFT    (RRCLIP_USERCLIPPLANE5 << 1)
#define CLIPPED_RIGHT   (RRCLIP_USERCLIPPLANE5 << 2)
#define CLIPPED_TOP     (RRCLIP_USERCLIPPLANE5 << 3)
#define CLIPPED_BOTTOM  (RRCLIP_USERCLIPPLANE5 << 4)
#define CLIPPED_FRONT   (RRCLIP_USERCLIPPLANE5 << 5)
#define CLIPPED_BACK    (RRCLIP_USERCLIPPLANE5 << 6)

#define CLIPPED_ENABLE  (RRCLIP_USERCLIPPLANE5 << 7) // wireframe enable flag

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)

const DWORD CLIPPED_USERCLIPPLANE0 = RRCLIP_USERCLIPPLANE5 << 8;
const DWORD CLIPPED_USERCLIPPLANE1 = RRCLIP_USERCLIPPLANE5 << 9;
const DWORD CLIPPED_USERCLIPPLANE2 = RRCLIP_USERCLIPPLANE5 << 10;
const DWORD CLIPPED_USERCLIPPLANE3 = RRCLIP_USERCLIPPLANE5 << 11;
const DWORD CLIPPED_USERCLIPPLANE4 = RRCLIP_USERCLIPPLANE5 << 12;
const DWORD CLIPPED_USERCLIPPLANE5 = RRCLIP_USERCLIPPLANE5 << 13;


//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// cn    - clipVertex
// pVtx    - a TL vertex
// qwFVF - FVF of the input TL vertex
//---------------------------------------------------------------------
inline void
MakeClipVertexFromFVF( RRCLIPVTX& cv, LPVOID pVtx,
                       const RRVIEWPORTDATA& VData,
                       DWORD dwTexCoordSize,
                       UINT64 qwFVF, DWORD dwClipFlag,
                       DWORD dwClipMask)
{
    LPBYTE pv = (LPBYTE)pVtx;

    // If the clip flag for this vertex is set, that means that the
    // transformation loop has not computed the screen coordinates for
    // this vertex, it has simply stored the clip coordinates for this
    // vertex

#if 0
    float x = *(D3DVALUE *)&((DWORD *)pv)[0]
    float y = *(D3DVALUE *)&((DWORD *)pv)[1]
    float z = *(D3DVALUE *)&((DWORD *)pv)[2]
    float w = *(D3DVALUE *)&((DWORD *)pv)[3]
#endif

    if (dwClipFlag & dwClipMask)
    {
        // This is a clipped vertex, simply no screen coordinates
        cv.sx  = D3DVALUE(0);
        cv.sy  = D3DVALUE(0);
        cv.sz  = D3DVALUE(0);
        cv.rhw = D3DVALUE(0);

        // Since this vertex has been clipped, the transformation loop
        // has put in the clip coordinates instead
        cv.hx  = ((D3DVALUE*)pv)[0];
        cv.hy  = ((D3DVALUE*)pv)[1];
        cv.hz  = ((D3DVALUE*)pv)[2];
        cv.hw  = ((D3DVALUE*)pv)[3];
    }
    else
    {
        // This vertex is not clipped, so its screen coordinates have been
        // computed
        cv.sx  = ((D3DVALUE*)pv)[0];
        cv.sy  = ((D3DVALUE*)pv)[1];
        cv.sz  = ((D3DVALUE*)pv)[2];
        cv.rhw = ((D3DVALUE*)pv)[3];

        // Transform the screen coordinate back to the clipping space
        cv.hw  = 1.0f / cv.rhw;
        cv.hx  = (cv.sx - VData.offsetX) * cv.hw * VData.scaleXi;
        cv.hy  = (cv.sy - VData.offsetY) * cv.hw * VData.scaleYi;
        cv.hz  = (cv.sz - VData.offsetZ) * cv.hw * VData.scaleZi;

    }

    pv += sizeof(D3DVALUE) * 4;
    if (qwFVF & D3DFVF_DIFFUSE)
    {
        cv.color   = *(DWORD*)pv;
        pv += sizeof(D3DVALUE);

    }
    if (qwFVF & D3DFVF_SPECULAR)
    {
        cv.specular= *(DWORD*)pv;
        pv += sizeof(DWORD);
    }
    memcpy(cv.tex, pv, dwTexCoordSize);
    pv += dwTexCoordSize;
    if (qwFVF & D3DFVF_S)
    {
        cv.s= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYENORMAL)
    {
        cv.eyenx= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyeny= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyenz= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYEXYZ)
    {
        cv.eyex= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyey= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyez= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    cv.clip = dwClipFlag;
}

//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//---------------------------------------------------------------------
inline void
MakeFVFVertexFromClip(LPVOID out, RRCLIPVTX *cv,
                      UINT64 qwFVF, DWORD dwTexCoordSize)
{
    LPBYTE pv = (LPBYTE)out;
    ((D3DVALUE*)pv)[0] = cv->sx;
    ((D3DVALUE*)pv)[1] = cv->sy;
    ((D3DVALUE*)pv)[2] = cv->sz;
    ((D3DVALUE*)pv)[3] = D3DVAL(1)/cv->hw;
    pv += sizeof(D3DVALUE)*4;
    if (qwFVF & D3DFVF_DIFFUSE)
    {
        *(DWORD*)pv = cv->color;
        pv += sizeof(DWORD);
    }
    if (qwFVF & D3DFVF_SPECULAR)
    {
        *(DWORD*)pv = cv->specular;
        pv += sizeof(DWORD);
    }
    memcpy(pv, &cv->tex, dwTexCoordSize);
    pv += dwTexCoordSize;
    if (qwFVF & D3DFVF_S)
    {
        *(FLOAT*)pv = cv->s;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYENORMAL)
    {
        *(FLOAT*)pv = cv->eyenx;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyeny;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyenz;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYEXYZ)
    {
        *(FLOAT*)pv = cv->eyex;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyey;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyez;
        pv += sizeof(FLOAT);
    }
}

//---------------------------------------------------------------------
// Returns TRUE if clipping is needed
//---------------------------------------------------------------------
inline BOOL
NeedClipping(BOOL bUseGB, RRCLIPCODE clipUnion)
{
    if( bUseGB && (clipUnion & ~RRCLIP_INGUARDBAND) )
    {
        return  TRUE;
    }
    else if( clipUnion )
    {
        return  TRUE;
    }

    return FALSE;
}


#endif //__CLIPPER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include <d3d.h>
#include <d3dhal.h>

#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include "refrast.hpp"      // public interfaces
#include "clipping.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
RRProcessVertices::__CLIP_NAME(RRCLIPVTX **inv, 
                               RRCLIPVTX **outv,
                               int count)
{
    int i;
    int out_count = 0;
    RRCLIPVTX *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * m_ViewData.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * m_ViewData.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } 
        else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int 
RRProcessVertices::__CLIP_LINE_NAME(RRCLIPTRIANGLE *line) 
{
    D3DVALUE in1, in2;
    RRCLIPVTX outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * m_ViewData.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * m_ViewData.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(&outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(&outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\lighting.cpp ===
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
// Vertex Lighting function implementations
///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
void
RRLV_Directional(
    RRLIGHTING& LData,
    D3DLIGHT7 *pLight,
    RRLIGHTI *pLightI,
    D3DLIGHTINGELEMENT *in,
    DWORD dwFlags,
    DWORD dwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RRPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RRPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RRPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RRPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RRPV_COLORVERTEXSPEC;

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += pLightI->Ma_La.r;
        LData.diffuse.g += pLightI->Ma_La.g;
        LData.diffuse.b += pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += pLightI->La.b * LData.pAmbientSrc->b;
    }

    //
    // If no normals are present, bail out since we cannot perform the
    // normal-dependent computations
    //
    if( (dwFVFIn & D3DFVF_NORMAL) == 0 )
    {
        return;
    }

    D3DVALUE dot = DotProduct( pLightI->direction_in_eye, in->dvNormal );
    if (FLOAT_GTZ(dot))
    {
        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( pLightI->direction_in_eye, eye, h );

            // normalize
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_GTZ(dot))
            {
                if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
                {
                    D3DVALUE coeff = pow( dot, LData.material.power );
                    if (!bDoColVertexSpecular)
                    {
                        LData.specular.r += pLightI->Ms_Ls.r * coeff;
                        LData.specular.g += pLightI->Ms_Ls.g * coeff;
                        LData.specular.b += pLightI->Ms_Ls.b * coeff;
                    }
                    else
                    {
                        LData.specular.r += (pLightI->Ls.r *
                                             LData.pSpecularSrc->r * coeff);
                        LData.specular.g += (pLightI->Ls.g *
                                             LData.pSpecularSrc->g * coeff);
                        LData.specular.b += (pLightI->Ls.b *
                                             LData.pSpecularSrc->b * coeff);
                    }
                }
            }
        }
    }
    return;
}

void
RRLV_PointAndSpot(
    RRLIGHTING &LData,
    D3DLIGHT7 *pLight,
    RRLIGHTI *pLightI,
    D3DLIGHTINGELEMENT *in,
    DWORD dwFlags,
    DWORD dwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RRPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RRPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RRPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RRPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RRPV_COLORVERTEXSPEC;
    D3DVECTOR d;    // Direction to light
    D3DVALUE att;
    D3DVALUE dist;
    D3DVALUE dot;

    SubtractVector( pLightI->position_in_eye, in->dvPosition, d );

    // early out if out of range or exactly on the vertex
    D3DVALUE distSquared = SquareMagnitude( d );
    if (FLOAT_CMP_POS(distSquared, >=, pLightI->range_squared) ||
        FLOAT_EQZ(distSquared))
    {
        return;
    }

    //
    // Compute the attenuation
    //
    dist = SQRTF( distSquared );
    att = pLight->dvAttenuation0 + pLight->dvAttenuation1 * dist +
        pLight->dvAttenuation2 * distSquared;

    if (FLOAT_EQZ(att))
        att = FLT_MAX;
    else
        att = (D3DVALUE)1.0/att;

    dist = D3DVAL(1)/dist;

    //
    // If the light is a spotlight compute the spot-light factor
    //
    if (pLight->dltType == D3DLIGHT_SPOT)
    {
        // Calc dot product of direction to light with light direction to
        // be compared anganst the cone angles to see if we are in the
        // light.
        // Note that cone_dot is still scaled by dist
        D3DVALUE cone_dot = DotProduct(d, pLightI->direction_in_eye) * dist;

        if (FLOAT_CMP_POS(cone_dot, <=, pLightI->cos_phi_by_2))
        {
            return;
        }

        // modify att if in the region between phi and theta
        if (FLOAT_CMP_POS(cone_dot, <, pLightI->cos_theta_by_2))
        {
            D3DVALUE val = (cone_dot - pLightI->cos_phi_by_2) *
                pLightI->inv_theta_minus_phi;

            if (!FLOAT_EQZ( pLight->dvFalloff - 1.0 ))
            {
                val = POWF( val, pLight->dvFalloff );
            }
            att *= val;
        }
    }

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += att*pLightI->Ma_La.r;
        LData.diffuse.g += att*pLightI->Ma_La.g;
        LData.diffuse.b += att*pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += att*pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += att*pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += att*pLightI->La.b * LData.pAmbientSrc->b;
    }

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    if( (dwFVFIn & D3DFVF_NORMAL) == 0)
    {
        // If no normals are present, bail out since we cannot perform the
        // normal-dependent computations
        return;
    }
    else
    {
        dot = DotProduct( d, in->dvNormal );
    }

    if (FLOAT_GTZ( dot ))
    {
        dot *= dist*att;

        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye

            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( d, eye, h );
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
            {
                D3DVALUE coeff = pow( dot, LData.material.power ) * att;
                if (!bDoColVertexSpecular)
                {
                    LData.specular.r += pLightI->Ms_Ls.r * coeff;
                    LData.specular.g += pLightI->Ms_Ls.g * coeff;
                    LData.specular.b += pLightI->Ms_Ls.b * coeff;
                }
                else
                {
                    LData.specular.r += (pLightI->Ls.r *
                                         LData.pSpecularSrc->r * coeff);
                    LData.specular.g += (pLightI->Ls.g *
                                         LData.pSpecularSrc->g * coeff);
                    LData.specular.b += (pLightI->Ls.b *
                                         LData.pSpecularSrc->b * coeff);
                }
            }
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
// RRLight
///////////////////////////////////////////////////////////////////////////////
RRLight::RRLight()
{
    m_dwFlags = RRLIGHT_NEEDSPROCESSING;
    m_Next = NULL;

    ZeroMemory(&m_Light, sizeof(m_Light));
    ZeroMemory(&m_LightI, sizeof(m_LightI));

    // Initialize the light to some default values
    m_Light.dltType        = D3DLIGHT_DIRECTIONAL;

    m_Light.dcvDiffuse.r   = 1;
    m_Light.dcvDiffuse.g   = 1;
    m_Light.dcvDiffuse.b   = 1;
    m_Light.dcvDiffuse.a   = 0;

    m_Light.dvDirection.x  = 0;
    m_Light.dvDirection.y  = 0;
    m_Light.dvDirection.z  = 1;

    // m_Light.dcvSpecular = {0,0,0,0};
    // m_Light.dcvAmbient  = {0,0,0,0};
    // m_Light.dvPosition  = {0,0,0};

    // m_Light.dvRange        = 0;
    // m_Light.dvFalloff      = 0;
    // m_Light.dvAttenuation0 = 0;
    // m_Light.dvAttenuation1 = 0;
    // m_Light.dvAttenuation2 = 0;
    // m_Light.dvTheta        = 0;
    // m_Light.dvPhi          = 0;

    return;
}


HRESULT
RRLight::SetLight(LPD3DLIGHT7 pLight)
{

    // Validate the parameters passed
    switch (pLight->dltType)
    {
    case D3DLIGHT_POINT:
    case D3DLIGHT_SPOT:
    case D3DLIGHT_DIRECTIONAL:
        break;
    default:
        // No other light types are allowed
        DPFRR(0, "Invalid light type passed");
        return DDERR_INVALIDPARAMS;
    }
    if (pLight)
        m_Light = *pLight;

    // Mark it for processing later
    m_dwFlags |= RRLIGHT_NEEDSPROCESSING;
    return DD_OK;
}

HRESULT
RRLight::GetLight(LPD3DLIGHT7 pLight)
{
    if (pLight == NULL) return DDERR_GENERIC;
    *pLight = m_Light;
    return D3D_OK;
}

void
RRLight::ProcessLight(D3DMATERIAL7 *mat, RRLIGHTVERTEX_FUNC_TABLE *pTbl)
{
    //
    // If it is already processed, return
    //
    if (!NeedsProcessing()) return;

    //
    // Save the ambient light  (0-1)
    //
    m_LightI.La.r  = m_Light.dcvAmbient.r;
    m_LightI.La.g  = m_Light.dcvAmbient.g;
    m_LightI.La.b  = m_Light.dcvAmbient.b;

    //
    // Save the diffuse light  (0-1)
    //
    m_LightI.Ld.r  = m_Light.dcvDiffuse.r;
    m_LightI.Ld.g  = m_Light.dcvDiffuse.g;
    m_LightI.Ld.b  = m_Light.dcvDiffuse.b;

    //
    // Save the specular light (0-1)
    //
    m_LightI.Ls.r  = m_Light.dcvSpecular.r;
    m_LightI.Ls.g  = m_Light.dcvSpecular.g;
    m_LightI.Ls.b  = m_Light.dcvSpecular.b;

    //
    // Material Ambient times Light Ambient
    //
    m_LightI.Ma_La.r = m_LightI.La.r * mat->ambient.r * D3DVALUE(255.0);
    m_LightI.Ma_La.g = m_LightI.La.g * mat->ambient.g * D3DVALUE(255.0);
    m_LightI.Ma_La.b = m_LightI.La.b * mat->ambient.b * D3DVALUE(255.0);

    //
    // Material Diffuse times Light Diffuse
    //
    m_LightI.Md_Ld.r = m_LightI.Ld.r * mat->diffuse.r * D3DVALUE(255.0);
    m_LightI.Md_Ld.g = m_LightI.Ld.g * mat->diffuse.g * D3DVALUE(255.0);
    m_LightI.Md_Ld.b = m_LightI.Ld.b * mat->diffuse.b * D3DVALUE(255.0);

    //
    // Material Specular times Light Specular
    //
    m_LightI.Ms_Ls.r = m_LightI.Ls.r * mat->specular.r * D3DVALUE(255.0);
    m_LightI.Ms_Ls.g = m_LightI.Ls.g * mat->specular.g * D3DVALUE(255.0);
    m_LightI.Ms_Ls.b = m_LightI.Ls.b * mat->specular.b * D3DVALUE(255.0);


    //
    // Assign the actual lighting function pointer, in addition to
    // performing some precomputation of light-type specific data
    //
    m_pfnLightVertex = NULL;
    switch (m_Light.dltType)
    {
    case D3DLIGHT_DIRECTIONAL:
        m_pfnLightVertex = pTbl->pfnDirectional;
        break;
    case D3DLIGHT_POINT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.inv_theta_minus_phi = 1.0f;
        m_pfnLightVertex = pTbl->pfnPoint;
        break;
    case D3DLIGHT_SPOT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
        m_pfnLightVertex = pTbl->pfnSpot;
        break;
    default:
        DPFRR( 0, "Cannot process light of unknown type" );
        break;
    }

    // Mark it as been processed
    m_dwFlags &= ~RRLIGHT_NEEDSPROCESSING;
    return;
}

void
RRLight::Enable(RRLight **ppRoot)
{
    // Assert that it is not already enabled
    if (IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RRLight *pTmp = *ppRoot;
    *ppRoot = this;
    m_Next = pTmp;
    m_dwFlags |= RRLIGHT_ENABLED;

    return;
}

void
RRLight::Disable(RRLight **ppRoot)
{
    // Assert that the light is enabled
    if (!IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RRLight *pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == this)
    {
        *ppRoot = m_Next;
        m_dwFlags &= ~RRLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->m_Next != this)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->m_Next == NULL)
        {
            m_dwFlags &= ~RRLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->m_Next;
    }

    pLightPrev->m_Next = m_Next;
    m_dwFlags &= ~RRLIGHT_ENABLED;
    return;
}

void
RRLight::XformLight( RRMATRIX *mView )
{
    // If the light is not a directional light,
    // tranform its position to camera space
    if (m_Light.dltType != D3DLIGHT_DIRECTIONAL)
    {
        XformBy4x3(&m_Light.dvPosition, mView, &m_LightI.position_in_eye);
    }

    if (m_Light.dltType != D3DLIGHT_POINT)
    {
        // Transform light direction to the eye space
        Xform3VecBy3x3( &m_Light.dvDirection, mView,
                        &m_LightI.direction_in_eye );
        // Normalize it
        Normalize( m_LightI.direction_in_eye );

        // Reverse it such that the direction is to the light
        ReverseVector( m_LightI.direction_in_eye, m_LightI.direction_in_eye );
    }

    return;
}

//---------------------------------------------------------------------
// ScaleRGBColorTo255: Scales colors from 0-1 range to 0-255 range
//---------------------------------------------------------------------
void
ScaleRGBColorTo255( const D3DCOLORVALUE& src, RRCOLOR& dest )
{
    dest.r = D3DVALUE(255.0) * src.r;
    dest.g = D3DVALUE(255.0) * src.g;
    dest.b = D3DVALUE(255.0) * src.b;
}


//---------------------------------------------------------------------
// RRProcessVertices::UpdateLightingData
//             Updates lighting data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateLightingData()
{
    HRESULT hr = D3D_OK;
    RRLIGHTING& LData = m_lighting;
    RRLight *pLight = m_lighting.pActiveLights;
    D3DVECTOR   t;
    D3DMATERIAL7 *mat = &m_Material;

    //
    // Eye in eye space
    //
    LData.eye_in_eye.x = (D3DVALUE)0;
    LData.eye_in_eye.y = (D3DVALUE)0;
    LData.eye_in_eye.z = (D3DVALUE)0;

    // ATTENTION: Colorvertex may have changed the values of the
    // material alphas
    if (m_dwDirtyFlags & RRPV_DIRTY_MATERIAL)
    {
        //
        // Save the material to be used to light vertices
        //
        LData.material = *mat;
        ScaleRGBColorTo255( mat->ambient, LData.matAmb );
        ScaleRGBColorTo255( mat->diffuse, LData.matDiff );
        ScaleRGBColorTo255( mat->specular, LData.matSpec );
        ScaleRGBColorTo255( mat->emissive, LData.matEmis );

        //
        // Compute the Material Diffuse Alpha
        //
        LData.materialDiffAlpha = mat->diffuse.a * D3DVALUE(255);
        if (mat->diffuse.a < 0)
            LData.materialDiffAlpha = 0;
        else if (LData.materialDiffAlpha > 255)
            LData.materialDiffAlpha = 255 << 24;
        else LData.materialDiffAlpha <<= 24;

        //
        // Compute the Material Specular Alpha
        //
        LData.materialSpecAlpha = mat->specular.a * D3DVALUE(255);
        if (mat->specular.a < 0)
            LData.materialSpecAlpha = 0;
        else if (LData.materialSpecAlpha > 255)
            LData.materialSpecAlpha = 255 << 24;
        else LData.materialSpecAlpha <<= 24;

        //
        // Precompute the ambient and emissive components that are
        // not dependent on any contribution by the lights themselves
        //
        LData.ambEmiss.r = LData.ambient_red   * LData.matAmb.r +
            LData.matEmis.r;
        LData.ambEmiss.g = LData.ambient_green * LData.matAmb.g +
            LData.matEmis.g;
        LData.ambEmiss.b = LData.ambient_blue  * LData.matAmb.b +
            LData.matEmis.b;

        //
        // If the dot product is less than this
        // value, specular factor is zero
        //
        if (mat->power > D3DVAL(0.001))
        {
            LData.specThreshold = D3DVAL(pow(0.001, 1.0/mat->power));
        }
    }

    while (pLight)
    {
        if ((m_dwDirtyFlags & RRPV_DIRTY_MATERIAL) ||
            pLight->NeedsProcessing())
        {
            // If the material is dirty, light needs processing, regardless
            if (m_dwDirtyFlags & RRPV_DIRTY_MATERIAL)
            {
                pLight->m_dwFlags |= RRLIGHT_NEEDSPROCESSING;
            }

            // If the light has been set, or some material paramenters
            // changed, re-process the light.
            pLight->ProcessLight( &m_Material, &m_LightVertexTable );

            // Transform the light to Eye space
            // Lights are defined in world space, so simply apply the
            // Viewing transform
            pLight->XformLight( &m_xfmView );

        }
        else if (m_dwDirtyFlags & RRPV_DIRTY_NEEDXFMLIGHT)
        {
            pLight->XformLight( &m_xfmView );
        }

        pLight = pLight->m_Next;
    }

    // Clear Lighting dirty flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_LIGHTING;
    return hr;
}


//---------------------------------------------------------------------
// RRProcessVertices::UpdateFogData
//             Updates Fog data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateFogData()
{
    HRESULT hr = D3D_OK;

    if (m_lighting.fog_end == m_lighting.fog_start)
        m_lighting.fog_factor = D3DVAL(0.0);
    else
        m_lighting.fog_factor = D3DVAL(255) / (m_lighting.fog_end -
                                               m_lighting.fog_start);

    // Clear Fog dirty flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_FOG;
    return hr;
}

//---------------------------------------------------------------------
// RRProcessVertices::LightVertex
//           Actual lighting computation takes place here
//---------------------------------------------------------------------
void
RRProcessVertices::LightVertex(D3DLIGHTINGELEMENT *pLE)
{
    RRLIGHTING &LData = m_lighting;
    RRLight  *pLight;

    //
    // Initialize Diffuse color with the Ambient and Emissive component
    // independent of the light (Ma*La + Me)
    //

    if (m_dwTLState & (RRPV_COLORVERTEXEMIS | RRPV_COLORVERTEXAMB))
    {
        // If the material values need to be replaced, compute

        LData.diffuse.r = LData.ambient_red * LData.pAmbientSrc->r +
            LData.pEmissiveSrc->r;
        LData.diffuse.g = LData.ambient_green * LData.pAmbientSrc->g +
            LData.pEmissiveSrc->g;
        LData.diffuse.b = LData.ambient_blue  * LData.pAmbientSrc->b +
            LData.pEmissiveSrc->b;
    }
    else
    {
        // If none of the material values needs to be replaced

        LData.diffuse = LData.ambEmiss;
    }


    //
    // Initialize the Specular to Zero
    //
    LData.specular.r = D3DVAL(0);
    LData.specular.g = D3DVAL(0);
    LData.specular.b = D3DVAL(0);

    //
    // In a loop accumulate color from the activated lights
    //
    pLight = LData.pActiveLights;
    while (pLight)
    {
        if (pLight->m_pfnLightVertex)
            (*pLight->m_pfnLightVertex)(m_lighting,
                                        &pLight->m_Light,
                                        &pLight->m_LightI,
                                        pLE,
                                        m_dwTLState,
                                        m_dwFVFIn);
        pLight = pLight->m_Next;
    }

    //
    // Compute the diffuse color of the vertex
    //
    int r = FTOI(LData.diffuse.r);
    int g = FTOI(LData.diffuse.g);
    int b = FTOI(LData.diffuse.b);
    DWORD a = *LData.pDiffuseAlphaSrc;

    //
    // Clamp the r, g, b, components
    //
    if (r < 0) r = 0; else if (r > 255) r = 255;
    if (g < 0) g = 0; else if (g > 255) g = 255;
    if (b < 0) b = 0; else if (b > 255) b = 255;

    LData.outDiffuse =  a + (r<<16) + (g<<8) + b;


    //
    // Obtain the specular Alpha
    //
    a = *(LData.pSpecularAlphaSrc);

    //
    // Compute the RGB part of the specular color
    //
    if (m_dwTLState & RRPV_DOSPECULAR)
    {
        r = FTOI(LData.specular.r);
        g = FTOI(LData.specular.g);
        b = FTOI(LData.specular.b);

        //
        // Clamp the r, g, b, components
        //
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

    }
    //
    // If SPECULAR is not enabled but the specular color
    // had been provided in the input vertex, simply copy.
    //
    else if ( m_qwFVFOut & D3DFVF_SPECULAR )
    {
        r = FTOI(LData.vertexSpecular.r);
        g = FTOI(LData.vertexSpecular.g);
        b = FTOI(LData.vertexSpecular.b);
        a = LData.vertexSpecAlpha;
    }
    //
    // If SpecularColor is not enabled
    //
    else
    {
        r = g = b = 0;
    }

    LData.outSpecular =  a + (r<<16) + (g<<8) + b;

    return;
}

//---------------------------------------------------------------------
// RRProcessVertices::FogVertex
//           Vertex Fog computation
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//---------------------------------------------------------------------
#define RRPV_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
void
RRProcessVertices::FogVertex(D3DVECTOR &v,
                             D3DLIGHTINGELEMENT *pLE,
                             int numVertexBlends,
                             float *pBlendFactors,
                             BOOL bVertexInEyeSpace)
{
    D3DVALUE dist = 0.0f;

    //
    // Calculate the distance
    //
    if (bVertexInEyeSpace)
    {
        // Vertex is already transformed to the camera space
        if (m_dwTLState & RRPV_RANGEFOG)
        {
            dist = SQRTF(pLE->dvPosition.x*pLE->dvPosition.x +
                         pLE->dvPosition.y*pLE->dvPosition.y +
                         pLE->dvPosition.z*pLE->dvPosition.z);
        }
        else
        {
            dist = pLE->dvPosition.z;
        }
    }
    else if (m_dwTLState & RRPV_RANGEFOG)
    {
        D3DVALUE x = 0, y = 0, z = 0;
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
            }

            cumulBlend += pBlendFactors[j];

            x += (v.x*m_xfmToEye[j]._11 +
                  v.y*m_xfmToEye[j]._21 +
                  v.z*m_xfmToEye[j]._31 +
                  m_xfmToEye[j]._41) * blend;
            y += (v.x*m_xfmToEye[j]._12 +
                  v.y*m_xfmToEye[j]._22 +
                  v.z*m_xfmToEye[j]._32 +
                  m_xfmToEye[j]._42) * blend;
            z += (v.x*m_xfmToEye[j]._13 +
                  v.y*m_xfmToEye[j]._23 +
                  v.z*m_xfmToEye[j]._33 +
                  m_xfmToEye[j]._43) * blend;
        }

        dist = SQRTF(x*x + y*y + z*z);
    }
    else
    {
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
            }

            cumulBlend += pBlendFactors[j];

            dist += (v.x*m_xfmToEye[j]._13 +
                  v.y*m_xfmToEye[j]._23 +
                  v.z*m_xfmToEye[j]._33 +
                  m_xfmToEye[j]._43) * blend;
        }
    }

    if (m_lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < m_lighting.fog_start)
        {
            RRPV_SET_ALPHA(m_lighting.outSpecular, 255);
        }
        else if (dist >= m_lighting.fog_end)
        {
            RRPV_SET_ALPHA(m_lighting.outSpecular, 0);
        }
        else
        {
            D3DVALUE v = (m_lighting.fog_end - dist) * m_lighting.fog_factor;
            int f = FTOI(v);
            RRPV_SET_ALPHA(m_lighting.outSpecular, f);
        }
    }
    else
    {
        D3DVALUE tmp = dist * m_lighting.fog_density;
        if (m_lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        RRPV_SET_ALPHA( m_lighting.outSpecular, f )
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\clipping.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&m_clipping.clip_vertices[m_clipping.clip_vertices_used++];


//---------------------------------------------------------------------
inline void
InterpolateColor(RRCLIPVTX *out,
                 RRCLIPVTX *p1,
                 RRCLIPVTX *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    out->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                           (WORD)(g1 + (g2 - g1) * num_denom),
                           (WORD)(b1 + (b2 - b1) * num_denom),
                           (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
inline void
InterpolateSpecular(RRCLIPVTX *out,
                    RRCLIPVTX *p1,
                    RRCLIPVTX *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    out->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                              (WORD)(g1 + (g2 - g1) * num_denom),
                              (WORD)(b1 + (b2 - b1) * num_denom),
                              (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
// Inline texture coordinate difference.
__inline FLOAT
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//---------------------------------------------------------------------
inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
    {
        return ((t2 - t1) * num_denom + t1);
    }
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f) t -= 1.0f;
        return t;
    }
}
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int
RRProcessVertices::ClipByPlane( RRCLIPVTX **inv,
                                RRCLIPVTX **outv,
                                RRVECTOR4 *plane,
                                DWORD dwClipFlag,
                                int count )
{
    int i;
    int out_count = 0;
    RRCLIPVTX *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y +
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--)
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y +
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside))
        { // first point is outside
            if (FLOAT_GEZ(curr_inside))
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate( outv[out_count],
                             curr, prev,
                             (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                             curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside))
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate( outv[out_count],
                             prev, curr,
                             dwClipFlag,
                             prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int
RRProcessVertices::ClipLineByPlane(RRCLIPTRIANGLE *line,
                                   RRVECTOR4 *plane,
                                   DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    RRCLIPVTX outv;
    in1 = line->v[0]->hx * plane->x +
          line->v[0]->hy * plane->y +
          line->v[0]->hz * plane->z +
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x +
          line->v[1]->hy * plane->y +
          line->v[1]->hz * plane->z +
          line->v[1]->hw * plane->w;
    if (in1 < 0)
    {
        if (in2 < 0)
            return 1;
        Interpolate( &outv, line->v[0], line->v[1],
                     dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    }
    else
    {
        if (in2 < 0)
        {
            Interpolate( &outv, line->v[0], line->v[1],
                         dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void
ComputeScreenCoordinates(const RRVIEWPORTDATA& VData,
                         RRCLIPVTX **inv, int count)
{
    int i;

    for (i = 0; i < count; i++)
    {
        RRCLIPVTX *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VData.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VData.maxXgb; break;
            default:
                p->sx = p->hx * VData.scaleX * w + VData.offsetX;
                                if (p->sx < VData.minXgb)
                                        p->sx = VData.minXgb;
                                if (p->sx > VData.maxXgb)
                                        p->sx = VData.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VData.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VData.minYgb; break;
            default:
                p->sy = p->hy * VData.scaleY * w + VData.offsetY;
                                if (p->sy < VData.minYgb)
                                        p->sy = VData.minYgb;
                                if (p->sy > VData.maxYgb)
                                        p->sy = VData.maxYgb;
            }
            p->sz = p->hz * VData.scaleZ * w + VData.offsetZ;
            p->rhw = w;
        }
    }
}
//---------------------------------------------------------------------
void
RRProcessVertices::Interpolate(RRCLIPVTX *out,
                               RRCLIPVTX *p1,
                               RRCLIPVTX *p2,
                               int code,
                               D3DVALUE num,
                               D3DVALUE denom)
{
    DWORD dwInterpolate = m_clipping.dwInterpolate;
    D3DVALUE num_denom = num / denom;

    out->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    out->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    out->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    out->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    out->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    out->color = m_clipping.clip_color;
    out->specular = m_clipping.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (dwInterpolate & RRCLIP_INTERPOLATE_COLOR)
    {
        InterpolateColor(out, p1, p2, num_denom);
    }

    if (dwInterpolate & RRCLIP_INTERPOLATE_SPECULAR)
    {
        InterpolateSpecular(out, p1, p2, num_denom);
    }

    if (dwInterpolate & RRCLIP_INTERPOLATE_TEXTURE)
    {
        // Assume that D3DRENDERSTATE_WRAPi are sequential
        D3DVALUE *pTexture1 = p1->tex;
        D3DVALUE *pTexture2 = p2->tex;
        D3DVALUE *pTexture = out->tex;
        for (DWORD i = 0; i < m_dwNumTexCoords; i++)
        {
            DWORD wrapState = ((ReferenceRasterizer *)this)->GetRenderState()[D3DRENDERSTATE_WRAP0 + i];
            DWORD n = (DWORD)(m_dwTexCoordSize[i] >> 2);
            DWORD dwWrapBit = 1;
            for (DWORD j=0; j < n; j++)
            {
                *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                               num_denom,
                                               wrapState & dwWrapBit);
                dwWrapBit <<= 1;
                pTexture ++;
                pTexture1++;
                pTexture2++;
            }
        }
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_S)
    {
        out->s = p1->s + (p2->s - p1->s) * num_denom;
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_EYENORMAL)
    {
        out->eyenx = p1->eyenx + (p2->eyenx - p1->eyenx) * num_denom;
        out->eyeny = p1->eyeny + (p2->eyeny - p1->eyeny) * num_denom;
        out->eyenz = p1->eyenz + (p2->eyenz - p1->eyenz) * num_denom;
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_EYEXYZ)
    {
        out->eyex = p1->eyex + (p2->eyex - p1->eyex) * num_denom;
        out->eyey = p1->eyey + (p2->eyey - p1->eyey) * num_denom;
        out->eyez = p1->eyez + (p2->eyez - p1->eyez) * num_denom;
    }
}

//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND

//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes( RRUSERCLIPPLANE *UserPlanes,
                                        RRCLIPVTX *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = RRCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if( UserPlanes[j].bActive )
        {
            RRVECTOR4& plane = UserPlanes[j].plane;
            if( (p->hx*plane.x +
                 p->hy*plane.y +
                 p->hz*plane.z +
                 p->hw*plane.w) < 0 )
            {
                clip |= dwClipBit;
            }
        }
        dwClipBit <<= 1;
    }
    return clip;
}

//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(const RRVIEWPORTDATA& VData, 
                               RRUSERCLIPPLANE *UserPlanes, RRCLIPVTX *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * VData.Kgbx1)
        clip |= RRCLIPGB_LEFT;
    if (p->hx > p->hw * VData.Kgbx2)
        clip |= RRCLIPGB_RIGHT;
    if (p->hy < p->hw * VData.Kgby1)
        clip |= RRCLIPGB_BOTTOM;
    if (p->hy > p->hw * VData.Kgby2)
        clip |= RRCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= RRCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(UserPlanes, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(RRUSERCLIPPLANE *UserPlanes, RRCLIPVTX *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= RRCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= RRCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= RRCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= RRCLIP_TOP;
    if (p->hz > p->hw)
        clip |= RRCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(UserPlanes, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
// RRProcessVertices::UpdateClippingData
//             Updates clipping data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateClippingData( DWORD dwClipPlanesEnable )
{
    HRESULT hr = D3D_OK;

    // Update the user defined clip plane data
    for( DWORD i=0; i<RRMAX_USER_CLIPPLANES; i++ )
    {
        // Figure out if it is active
        m_xfmUserClipPlanes[i].bActive = (BOOL)(dwClipPlanesEnable & 0x1);
        dwClipPlanesEnable >>= 1;

        // If it is active, transform it into eye-space using the
        // view transform. The clip planes are defined in the
        // world space.
        if( m_xfmUserClipPlanes[i].bActive )
        {
            XformPlaneBy4x4Transposed( &m_userClipPlanes[i],
                                       &m_TransformData.m_VPSInv,
                                       &m_xfmUserClipPlanes[i].plane );
        }
    }
    m_dwDirtyFlags &= ~(RRPV_DIRTY_CLIPPLANES);
    return hr;
}

//----------------------------------------------------------------------------
//
// DrawOneClippedPrimitive
//
// Draw one clipped primitive.
//
//----------------------------------------------------------------------------
HRESULT
RRProcessVertices::DrawOneClippedPrimitive()
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;
    PUINT8 pVtx = (PUINT8) m_pvOut;
    RRCLIPCODE *pClip = m_pClipBuf;
    RRCLIPCODE c0, c1, c2;

    switch (m_primType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)m_dwNumVertices; i > 0; i--)
        {
            c0 = *pClip++;
            ((ReferenceRasterizer *)this)->DrawClippedPoint(pVtx, c0);
            pVtx += m_dwOutputVtxSize;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)m_dwNumVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c0 = *pClip++;
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                           pV1, c1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;
            c1 = *pClip;

            // Disable last-pixel setting for shared verties and store prestate.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)m_dwNumVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                c0 = c1;
                pVtx += m_dwOutputVtxSize;
                pV1 = pVtx;
                c1 = *(++pClip);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                               pV1, c1);
            }

            // Restore last-pixel setting.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + m_dwOutputVtxSize;
                c0 = *(++pClip);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV1, c1,
                                                               pV0, c0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)m_dwNumVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c0 = *pClip++;

            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;

            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;

            ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                               pV1, c1,
                                                               pV2, c2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;

            for (i = (INT)m_dwNumVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c2 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);

                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c2 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV2, c2,
                                                                   pV1, c1);
            }

            if (i > 0)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx; c2 = *pClip;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            RRCLIPCODE c0, c1, c2;

            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            for (i = (INT)m_dwNumVertices - 2; i > 0; i--)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c1 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DrawOneClippedIndexedPrimitive
//
// Draw one list of clipped indexed primitives.
//
//----------------------------------------------------------------------------
HRESULT
RRProcessVertices::DrawOneClippedIndexedPrimitive()
{
    INT i;
    PUINT8 pVtx = (PUINT8) m_pvOut;
    LPWORD puIndices = m_pIndices;
    PUINT8 pV0, pV1, pV2;
    RRCLIPCODE *pClip = m_pClipBuf;
    RRCLIPCODE c0, c1, c2;
    HRESULT hr;

    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)m_dwNumIndices; i > 0; i--)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedPoint(pV0, c0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)m_dwNumIndices / 2; i > 0; i--)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                           pV1, c1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(TRUE);
            // Initial pV1.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            for (i = (INT)m_dwNumIndices - 1; i > 1; i--)
            {
                c0 = c1;
                pV0 = pV1;
                c1 = pClip[*puIndices];
                pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                               pV1, c1);
            }
            // Restore last-pixel setting.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                c0 = pClip[*puIndices];
                pV0 = pVtx + m_dwOutputVtxSize * (*puIndices);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV1, c1,
                                                               pV0, c0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)m_dwNumIndices; i > 0; i -= 3)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                               pV1, c1,
                                                               pV2, c2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);

            for (i = (INT)m_dwNumIndices - 2; i > 1; i -= 2)
            {
                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);

                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV2, c2,
                                                                   pV1, c1);
            }

            if (i > 0)
            {
                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            // Preload initial pV0.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            for (i = (INT)m_dwNumIndices - 2; i > 0; i--)
            {
                c0 = c1; pV0 = pV1;
                c1 = pClip[*puIndices];
                pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneClippedIndexedPrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

void
ReferenceRasterizer::DrawClippedTriangle( void* pvV0, RRCLIPCODE c0,
                                          void* pvV1, RRCLIPCODE c1,
                                          void* pvV2, RRCLIPCODE c2,
                                          WORD wFlags )
{
    DWORD dwInter = (c0 & c1 & c2);
    DWORD dwUnion = (c0 | c1 | c2);
    DWORD dwMask = (m_dwTLState & RRPV_GUARDBAND) ? RRCLIPGB_ALL : RRCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if (dwInter)
    {
        return;
    }

    // If all the vertices are in, draw and return
    if ((dwUnion & dwMask) == 0)
    {
        DrawTriangle( pvV0, pvV1, pvV2, wFlags );
        return;
    }

    // Do Clipping
    RRCLIPTRIANGLE newtri;
    RRCLIPVTX cv[3];

    MakeClipVertexFromFVF( cv[0], pvV0, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c0,
                           dwMask);
    MakeClipVertexFromFVF( cv[1], pvV1, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c1,
                           dwMask);
    MakeClipVertexFromFVF( cv[2], pvV2, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c2,
                           dwMask);

    newtri.v[0] = &cv[0]; cv[0].next = &cv[1];
    newtri.v[1] = &cv[1]; cv[1].next = &cv[2];
    newtri.v[2] = &cv[2]; cv[2].next = NULL;

    int count;
    RRCLIPVTX **ver;
    cv[0].clip |= CLIPPED_ENABLE;
    cv[1].clip |= CLIPPED_ENABLE;
    cv[2].clip |= CLIPPED_ENABLE;

    if (count = ClipSingleTriangle( &newtri, &ver ))
    {
        int i;

        // Temporary Byte Array
        if (m_clipping.ClipBuf.GetSize() < m_dwOutputVtxSize*count)
        {
            m_clipping.ClipBuf.Grow( m_dwOutputVtxSize*count );
        }
        LPBYTE pTLV = (LPBYTE)m_clipping.ClipBuf.GetAddress();
        LPBYTE p = pTLV;

        for (i = 0; i < count; i++)
        {
            MakeFVFVertexFromClip( p, ver[i], m_qwFVFOut,
                                   m_dwTextureCoordSizeTotal);
            p += m_dwOutputVtxSize;
        }

        // If it is in wireframe mode, convert the clipper output to
        // a line list.
        if (!m_bPointSprite && (GetRenderState()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME))
        {
            DWORD dwEdgeFlags = 0;
            for (i = 0; i < count; i++)
            {
                if (ver[i]->clip & CLIPPED_ENABLE) dwEdgeFlags |= (1 << i);
                p += m_dwOutputVtxSize;
            }

            DoDrawOneEdgeFlagTriangleFan( this, m_dwOutputVtxSize,
                                          (PUINT8) pTLV, count,
                                          dwEdgeFlags );
        }
        else
        {
            DoDrawOnePrimitive( this, m_dwOutputVtxSize, (PUINT8) pTLV,
                                D3DPT_TRIANGLEFAN, count);
        }
    }
}

void
ReferenceRasterizer::DrawClippedLine( void* pvV0, RRCLIPCODE c0,
                                      void* pvV1, RRCLIPCODE c1,
                                      void* pvVFlat )
{
    DWORD dwInter = (c0 & c1);
    DWORD dwUnion = (c0 | c1);
    DWORD dwMask = (m_dwTLState & RRPV_GUARDBAND) ? RRCLIPGB_ALL : RRCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if (dwInter)
    {
        return;
    }

    // If all the vertices are in, draw and return
    if ((dwUnion & dwMask) == 0)
    {
        DrawLine( pvV0, pvV1, pvVFlat );
        return;
    }

    RRCLIPTRIANGLE newline;
    RRCLIPVTX cv[2];

    MakeClipVertexFromFVF( cv[0], pvV0, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c0,
                           dwMask);
    MakeClipVertexFromFVF( cv[1], pvV1, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c1,
                           dwMask);

    newline.v[0] = &cv[0];
    newline.v[1] = &cv[1];

    if (ClipSingleLine( &newline ))
    {
        // Temporary Byte Array
        if (m_clipping.ClipBuf.GetSize() < m_dwOutputVtxSize*2)
        {
            m_clipping.ClipBuf.Grow( m_dwOutputVtxSize*3 );
        }

        LPBYTE pTLV = (LPBYTE)m_clipping.ClipBuf.GetAddress();
        LPBYTE p = pTLV;
        MakeFVFVertexFromClip( p, newline.v[0], m_qwFVFOut,
                               m_dwTextureCoordSizeTotal);
        p += m_dwOutputVtxSize;
        MakeFVFVertexFromClip( p, newline.v[1], m_qwFVFOut,
                               m_dwTextureCoordSizeTotal);

        DrawLine( pTLV, p, pvVFlat );
    }
}

void
ReferenceRasterizer::DrawClippedPoint( void* pvV0, RRCLIPCODE c0,
                                       void* pvVFlat )
{
    // if definitely out
    if (c0 & (RRCLIP_FRONT | RRCLIP_BACK | (1<<RRCLIPGB_LEFTBIT) | (1<<RRCLIPGB_RIGHTBIT) |
        (1<<RRCLIPGB_TOPBIT) | (1<<RRCLIPGB_BOTTOMBIT)))
        return;

    // otherwise, could be in
    if (c0 == 0)
    {
        // is completely in, just draw it
        DrawPoint( pvV0, pvVFlat );
    }
    else
    {
        // use per vertex S if it exists, otherwise use D3DRENDERSTATE_POINTSIZE
        BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );
        RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

        FLOAT fS = 1.0f;
#ifdef __POINTSPRITES
        if (m_qwFVFControl & D3DFVF_S)
        {
            fS = Vtx0.GetS();
        }
        else if( m_dwDriverType > RRTYPE_DP2HAL )
        {
            fS = m_fRenderState[D3DRENDERSTATE_POINTSIZE];
        }
#endif

        if (fS <= 1.0f)
        {
            // too small and out
            return;
        }

#ifdef __POINTSPRITES
        if (c0 & (RRCLIP_USERCLIPPLANE0 | RRCLIP_USERCLIPPLANE1 | RRCLIP_USERCLIPPLANE2 |
            RRCLIP_USERCLIPPLANE3 | RRCLIP_USERCLIPPLANE4 | RRCLIP_USERCLIPPLANE5))
        {
            // large and potentially clipped, expand point sprite to quad and clip traditionally
            fS *= 0.5f;      // turn size into screen space offset to quad points from center
            FLOAT w_clip = Vtx0.GetRHW();   // not really the reciprocal
            FLOAT x_clip_size = fS*w_clip/m_ViewData.scaleX;
            FLOAT y_clip_size = fS*w_clip/m_ViewData.scaleY;

            UINT64 qwFVFControlSave = m_qwFVFControl;
            UINT64 qwFVFOutSave = m_qwFVFOut;
            DWORD dwOutputVtxSizeSave = m_dwOutputVtxSize;
            DWORD dwTextureCoordSizeTotalSave = m_dwTextureCoordSizeTotal;
            DWORD dwTexCoordSizeSave[D3DDP_MAXTEXCOORD];
            memcpy(dwTexCoordSizeSave, m_dwTexCoordSize, sizeof(DWORD)*D3DDP_MAXTEXCOORD);
            DWORD dwInterpolateSave = m_clipping.dwInterpolate;
            DWORD dwNumTexCoordsSave = m_dwNumTexCoords;

            INT32 iTexCount = 0;
            if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE] && m_cActiveTextureStages)
            {
                // look through texture stages to see how many texture indices are needed
                // since for POINTSPRITE mode, the input vertices don't even have to have any
                // texture coordinates.  Since this is an important advantage of using point
                // sprites, we have to deal with it.
                for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
                {
                    if (m_pTexture[iStage])
                    {
                        INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
                        iCoordSet &= 0xffff;
                        iTexCount = max(iCoordSet+1, iTexCount);
                        m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_TEXTURE;
                    }
                }
            }
            m_qwFVFOut &= ~(D3DFVF_TEXCOUNT_MASK | 0xffff0000);
            m_qwFVFOut |= (iTexCount << D3DFVF_TEXCOUNT_SHIFT) & D3DFVF_TEXCOUNT_MASK;
            m_qwFVFControl = m_qwFVFOut;
            m_dwNumTexCoords = FVF_TEXCOORD_NUMBER((DWORD)m_qwFVFOut);
            m_dwOutputVtxSize   = GetFVFVertexSize( m_qwFVFOut );
            m_dwTextureCoordSizeTotal = 0;
            ComputeTextureCoordSize((DWORD)m_qwFVFOut, m_dwTexCoordSize,
                                    &m_dwTextureCoordSizeTotal);

            void *pvVT0, *pvVT1, *pvVT2, *pvVT3;
            {
                pvVT0 = MEMALLOC( m_dwOutputVtxSize );
                pvVT1 = MEMALLOC( m_dwOutputVtxSize );
                pvVT2 = MEMALLOC( m_dwOutputVtxSize );
                pvVT3 = MEMALLOC( m_dwOutputVtxSize );

                _ASSERTa( ( NULL != pvVT0 ) && ( NULL != pvVT1 ) && ( NULL != pvVT2) && (NULL != pvVT2),
                    "malloc failure on ReferenceRasterizer::DrawClippedPoint", return; );

                // only copy as much data as we have
                DWORD dwStride = GetFVFVertexSize(qwFVFControlSave);
                memcpy(pvVT0, pvV0, dwStride);
                memcpy(pvVT1, pvV0, dwStride);
                memcpy(pvVT2, pvV0, dwStride);
                memcpy(pvVT3, pvV0, dwStride);
            }

            // encase FVF vertex pointer and control in class to extract fields
            RRFVFExtractor VtxT0( pvVT0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT1( pvVT1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT2( pvVT2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT3( pvVT3, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );


            FLOAT *pXY = VtxT0.GetPtrXYZ();
            pXY[0] += -x_clip_size;
            pXY[1] += -y_clip_size;

            pXY = VtxT1.GetPtrXYZ();
            pXY[0] +=  x_clip_size;
            pXY[1] += -y_clip_size;

            pXY = VtxT2.GetPtrXYZ();
            pXY[0] += -x_clip_size;
            pXY[1] +=  y_clip_size;

            pXY = VtxT3.GetPtrXYZ();
            pXY[0] +=  x_clip_size;
            pXY[1] +=  y_clip_size;

            if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE] && m_cActiveTextureStages)
            {
                // compute functions for texture coordinates
                if (m_cActiveTextureStages)
                {
                    for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
                    {
                        if (m_pTexture[iStage])
                        {
                            INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
                            iCoordSet &= 0xffff;
                            FLOAT *pUV = VtxT0.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = 0.0f;
                            pUV[1] = 0.0f;
                            pUV = VtxT1.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = SPRITETEXCOORDMAX;
                            pUV[1] = 0.0f;
                            pUV = VtxT2.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = 0.0f;
                            pUV[1] = SPRITETEXCOORDMAX;
                            pUV = VtxT3.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = SPRITETEXCOORDMAX;
                            pUV[1] = SPRITETEXCOORDMAX;
                        }
                    }
                }
            }
            RRCLIPCODE clipIntersection, clipUnion;
            RRCLIPCODE c[4];
            RRFVFExtractor* pVtxTs[4] = {&VtxT0, &VtxT1, &VtxT2, &VtxT3};
            for ( INT32 i= 0; i < 4; i++)
            {
                FLOAT x_clip = pVtxTs[i]->GetX();
                FLOAT y_clip = pVtxTs[i]->GetY();
                FLOAT z_clip = pVtxTs[i]->GetZ();
                FLOAT w_clip = pVtxTs[i]->GetRHW();
                c[i] = ComputeClipCodes(&clipIntersection, &clipUnion, x_clip, y_clip,
                                        z_clip, w_clip, 0.0f);
                if (c[i] == 0 || ((m_dwTLState & RRPV_GUARDBAND) && ((c[i] & ~RRCLIP_INGUARDBAND) == 0)))
                {
                    // need to compute screen coordinates
                    FLOAT inv_w_clip = 1.0f/w_clip;
                    FLOAT *pXYZW = pVtxTs[i]->GetPtrXYZ();
                    pXYZW[0] = x_clip * inv_w_clip * m_ViewData.scaleX +
                        m_ViewData.offsetX;
                    pXYZW[1] = y_clip * inv_w_clip * m_ViewData.scaleY +
                        m_ViewData.offsetY;
                    pXYZW[2] = z_clip * inv_w_clip * m_ViewData.scaleZ +
                        m_ViewData.offsetZ;
                    pXYZW[3] = inv_w_clip;
                }
            }
            // set point sprite mode in rasterizer
            m_bPointSprite = TRUE;

            DrawClippedTriangle(pvVT0, c[0], pvVT1, c[1], pvVT2, c[2], 0);
            DrawClippedTriangle(pvVT1, c[1], pvVT3, c[3], pvVT2, c[2], 0);

            // clear point sprite mode in rasterizer
            m_bPointSprite = FALSE;

            m_qwFVFControl = qwFVFControlSave;
            m_dwOutputVtxSize = dwOutputVtxSizeSave;
            m_qwFVFOut = qwFVFOutSave;
            m_dwTextureCoordSizeTotal = dwTextureCoordSizeTotalSave;
            memcpy(m_dwTexCoordSize, dwTexCoordSizeSave, sizeof(DWORD)*D3DDP_MAXTEXCOORD);
            m_clipping.dwInterpolate = dwInterpolateSave;
            m_dwNumTexCoords = dwNumTexCoordsSave;

            MEMFREE( pvVT0 );
            MEMFREE( pvVT1 );
            MEMFREE( pvVT2 );
            MEMFREE( pvVT3 );
        }
        else
        {
            // Just x y clipped.  Let bounding box handle it
            DrawPoint( pvV0, pvVFlat );
        }
#endif
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
////////////////////////////////////////////////////////////////////////////
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int
ReferenceRasterizer::ClipSingleTriangle(RRCLIPTRIANGLE *tri,
                                        RRCLIPVTX ***clipVertexPointer)
{
    int accept;
    int i, j;
    int count;
    RRCLIPVTX **inv;
    RRCLIPVTX **outv;
    RRCLIPVTX *p;
    ULONG_PTR swapv;
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    if (GetRenderState()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = tri->v[0]->color;
        D3DCOLOR specular = tri->v[0]->specular;

        //Save original colors
        diffuse1  = tri->v[1]->color;
        specular1 = tri->v[1]->specular;
        diffuse2  = tri->v[2]->color;
        specular2 = tri->v[2]->specular;

        // copy all but fog intensity
        tri->v[1]->color= diffuse;
        tri->v[1]->specular &= 0xFF000000; tri->v[1]->specular |= (0x00FFFFFF & specular);
        tri->v[2]->color = diffuse;
        tri->v[2]->specular &= 0xFF000000; tri->v[2]->specular |= (0x00FFFFFF & specular);
    }
    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;
    count = 3;
    outv = m_clipping.clip_vbuf1;
    m_clipping.clip_color = tri->v[0]->color;
    m_clipping.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)m_clipping.clip_vbuf1;
        tmp2 = (ULONG_PTR)m_clipping.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    m_clipping.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (RRCLIPVTX**) (swapv - (ULONG_PTR) outv)

    if (accept & RRCLIP_FRONT)
    {
        count = ClipFront( inv, outv, count );
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (m_dwTLState & RRPV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & RRCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RRCLIPVTX *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(m_ViewData, 
                                                m_xfmUserClipPlanes, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & RRCLIP_BACK)
        {
            count = ClipBack( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_LEFT)
        {
            count = ClipLeftGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_RIGHT)
        {
            count = ClipRightGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_BOTTOM)
        {
            count = ClipBottomGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_TOP)
        {
            count = ClipTopGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & RRCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RRCLIPVTX *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
                else
                    accept |= p->clip;
            }
        }
        if (accept & RRCLIP_BACK)
        {
            count = ClipBack( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_LEFT)
        {
            count = ClipLeft( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_RIGHT)
        {
            count = ClipRight( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_BOTTOM)
        {
            count = ClipBottom( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_TOP)
        {
            count = ClipTop( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

    dwClipBit = RRCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    // User Clip Planes
    for( j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if (accept & dwClipBit)
        {
            count = ClipByPlane( inv, outv, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

#undef SWAP

    ComputeScreenCoordinates( m_ViewData, inv, count );

    *clipVertexPointer = inv;
    m_clipping.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}

//-----------------------------------------------------------------------
//
int
ReferenceRasterizer::ClipSingleLine( RRCLIPTRIANGLE *line )
{
    int         accept;
    int         j;
    D3DVALUE    in1, in2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    accept = (line->v[0]->clip | line->v[1]->clip);

    m_clipping.clip_color = line->v[0]->color;
    m_clipping.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT)
        if (ClipLineFront(line))
            goto out_of_here;
    if (m_dwTLState & RRPV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            RRCLIPVTX * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(m_ViewData, m_xfmUserClipPlanes, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(m_ViewData, m_xfmUserClipPlanes, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_LEFT)
            if (ClipLineLeftGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_RIGHT)
            if (ClipLineRightGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_TOP)
            if (ClipLineTopGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_BOTTOM)
            if (ClipLineBottomGB( line ))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            RRCLIPVTX * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack( line ))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT)
            if (ClipLineLeft( line ))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT)
            if (ClipLineRight( line ))
                goto out_of_here;
        if (accept & D3DCLIP_TOP)
            if (ClipLineTop( line ))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM)
            if (ClipLineBottom( line ))
                goto out_of_here;
    }

    // User Clip Planes
    dwClipBit = RRCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    for( j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if (accept & dwClipBit)
        {
            if( ClipLineByPlane( line, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit ))
                goto out_of_here;
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

    ComputeScreenCoordinates(m_ViewData, line->v, 2);

    return 1;
out_of_here:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\procprim.cpp ===
#include "pch.cpp"
#pragma hdrstop

const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//---------------------------------------------------------------------
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
//---------------------------------------------------------------------
void UpdateComponentOffsets (DWORD dwFVFIn,
                             LPDWORD pNormalOffset,
                             LPDWORD pDiffOffset,
                             LPDWORD pSpecOffset,
                             LPDWORD pTexOffset)
{
    DWORD dwOffset = 0;

    switch( dwFVFIn & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZ:
        dwOffset = sizeof(D3DVECTOR);
        break;
    case D3DFVF_XYZB1:
        dwOffset = sizeof(D3DVECTOR) + sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB2:
        dwOffset = sizeof(D3DVECTOR) + 2*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB3:
        dwOffset = sizeof(D3DVECTOR) + 3*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB4:
        dwOffset = sizeof(D3DVECTOR) + 4*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB5:
        dwOffset = sizeof(D3DVECTOR) + 5*sizeof(D3DVALUE);
        break;
    default:
        DPFM(0,TNL,("Unable to compute offsets, strange FVF bits set"));
    }

    *pNormalOffset = dwOffset;

    if (dwFVFIn & D3DFVF_NORMAL)
        dwOffset += sizeof(D3DVECTOR);
    if (dwFVFIn & D3DFVF_RESERVED1)
        dwOffset += sizeof(D3DVALUE);

    // Offset to the diffuse color
    *pDiffOffset = dwOffset;

    if (dwFVFIn & D3DFVF_DIFFUSE)
        dwOffset += sizeof(DWORD);

    // Offset to the specular color
    *pSpecOffset = dwOffset;

    if (dwFVFIn & D3DFVF_SPECULAR)
        dwOffset += sizeof(DWORD);

    // Offset to the texture data
    *pTexOffset = dwOffset;
}

//---------------------------------------------------------------------
// SetupFVFData:
//             Compute Output FVF and the size of output vertices
//---------------------------------------------------------------------
void
RRProcessVertices::SetupFVFData(BOOL bFogEnabled, BOOL bSpecularEnabled)
{

    // Compute number of texture coordinates
    m_dwNumTexCoords = FVF_TEXCOORD_NUMBER(m_dwFVFIn);

    // Compute output FVF
    m_qwFVFOut = D3DFVF_XYZRHW;

    // If normal is present we have to compute specular and diffuse
    // Otherwise set these bits the same as input.
    // Not that normal should not be present for XYZRHW position type
    if (m_dwTLState & RRPV_DOLIGHTING)
    {
        m_qwFVFOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        m_qwFVFOut |= (m_dwFVFIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR));
    }

    // Always set specular flag if fog is enabled
    // if (this->rstates[D3DRENDERSTATE_FOGENABLE])
    if (bFogEnabled)
    {
        m_qwFVFOut |= D3DFVF_SPECULAR;
    }
    // Clear specular flag if specular disabled
    // else if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE])
    else if (!bSpecularEnabled && !(m_dwFVFIn & D3DFVF_SPECULAR))
    {
        m_qwFVFOut &= ~D3DFVF_SPECULAR;
    }

#ifdef __POINTSPRITES
    // Reserve space for point size, if needed
    if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
    {
        m_qwFVFOut |= D3DFVF_S;
    }
#endif

    // Reserve space for eye space info, if needed
    if (m_dwTLState & RRPV_DOPASSEYENORMAL)
    {
        m_qwFVFOut |= D3DFVFP_EYENORMAL;
    }
    if (m_dwTLState & RRPV_DOPASSEYEXYZ)
    {
        m_qwFVFOut |= D3DFVFP_EYEXYZ;
    }

    // Set up number of texture coordinates and copy texture formats
    m_qwFVFOut |= (m_dwNumTexCoords << D3DFVF_TEXCOUNT_SHIFT) |
                   (m_dwFVFIn & 0xFFFF0000);

    // Compute size of texture coordinates
    // This size is the same for input and output FVFs,
    // because for DX7 drivers they have number of texture and texture formats
    m_dwTextureCoordSizeTotal = 0;
    ComputeTextureCoordSize(m_dwFVFIn, m_dwTexCoordSize,
                            &m_dwTextureCoordSizeTotal);

    //  Compute output size
    m_dwOutputVtxSize   = GetFVFVertexSize( m_qwFVFOut );
    m_position.dwStride = GetFVFVertexSize( m_dwFVFIn );

    // Now compute the input FVF dependent offsets used by the Geometry loop
    UpdateComponentOffsets (m_dwFVFIn, &m_dwNormalOffset,
                            &m_dwDiffuseOffset, &m_dwSpecularOffset,
                            &m_dwTexOffset);
    return;
}

///////////////////////////////////////////////////////////////////////////////
// SavePrimitiveData
///////////////////////////////////////////////////////////////////////////////
void
ReferenceRasterizer::SavePrimitiveData(
    DWORD dwFVFIn,
    LPVOID pVtx,
    UINT cVertices,
    D3DPRIMITIVETYPE PrimType
    )
{
    //
    // 1) Save the incoming information
    //
    m_primType = PrimType;
    m_position.lpvData = pVtx;

    // Force some state changes if the FVF is different
    if( dwFVFIn != m_dwFVFIn )
    {
        m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
    }

    m_dwFVFIn = dwFVFIn;
    m_dwNumVertices = cVertices;

    // No indices to work with
    m_dwNumIndices = 0;
    m_pIndices = NULL;
}

void
ReferenceRasterizer::SavePrimitiveData(
    DWORD dwFVFIn,
    LPVOID pVtx,
    UINT cVertices,
    D3DPRIMITIVETYPE PrimType,
    LPWORD pIndices,
    UINT cIndices
    )
{
    //
    // 1) Save the incoming information
    //
    m_primType = PrimType;
    m_position.lpvData = pVtx;

    // Force some state changes if the FVF is different
    if( dwFVFIn != m_dwFVFIn )
    {
        m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
    }

    m_dwFVFIn = dwFVFIn;
    m_dwNumVertices = cVertices;

    m_dwNumIndices = cIndices;
    m_pIndices = pIndices;
}

///////////////////////////////////////////////////////////////////////////////
// Process primitives implementation:
// 1) Compute FVF info
// 2) Grow buffers to the requisite size
// 3) Initialize clipping state
// 4) Update T&L state
// 5) Transform, Light and compute clipping for vertices
// 6) Clip and Draw the primitives
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
ReferenceRasterizer::ProcessPrimitive(
    BOOL bIndexedPrim
    )
{
    HRESULT ret = D3D_OK;
    DWORD dwVertexPoolSize = 0;

    //
    // Update T&L state (must be before FVFData is set up)
    //

    // Update Lighting and related state and flags
    if ((ret = UpdateTLState()) != D3D_OK)
        return ret;

    //
    // Compute Output FVF and the size of output vertices
    //
    SetupFVFData(GetRenderState()[D3DRENDERSTATE_FOGENABLE],
                 GetRenderState()[D3DRENDERSTATE_SPECULARENABLE]);

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    if (m_dwTLState & RRPV_DOCLIPPING)
    {
        // Figure out which pieces need to be interpolated in new vertices.
        m_clipping.dwInterpolate = 0;
        if (GetRenderState()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_COLOR;
            
            if (m_qwFVFOut & D3DFVF_SPECULAR)
            {
                m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_SPECULAR;
            }
        }
        if (GetRenderState()[D3DRENDERSTATE_FOGENABLE])
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_SPECULAR;
        }

        if (FVF_TEXCOORD_NUMBER(m_dwFVFIn) != 0)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_TEXTURE;
        }

        if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_S;
        }

        if (m_dwTLState & RRPV_DOPASSEYENORMAL)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_EYENORMAL;
        }

        if (m_dwTLState & RRPV_DOPASSEYEXYZ)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_EYEXYZ;
        }

        // Clear clip union and intersection flags
        m_clipIntersection = 0;
        m_clipUnion = 0;

        HRESULT hr = S_OK;
        HR_RET( UpdateClippingData( GetRenderState()[D3DRENDERSTATE_CLIPPLANEENABLE] ));
    }

    // This needs to be updated bbecause the rasterizer part of
    // the Reference Driver uses it.
    m_qwFVFControl = m_qwFVFOut;

    //
    // Grow buffers to the requisite size
    //

    // Size of the buffer required to transform into
    dwVertexPoolSize = m_dwNumVertices * m_dwOutputVtxSize;

    // Grow TLVBuf if required
    if (dwVertexPoolSize > this->m_TLVBuf.GetSize())
    {
        if (this->m_TLVBuf.Grow(dwVertexPoolSize) != D3D_OK)
        {
            DPFM(0,TNL,("Could not grow TL vertex buffer"));
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
    }
    this->m_pvOut = this->m_TLVBuf.GetAddress();

    // Grow ClipFlagBuf if required
    if (GetRenderState()[D3DRENDERSTATE_CLIPPING])
    {
        DWORD size = m_dwNumVertices * sizeof(RRCLIPCODE);
        if (size > this->m_ClipFlagBuf.GetSize())
        {
            if (this->m_ClipFlagBuf.Grow(size) != D3D_OK)
            {
                DPFM(0,TNL,("Could not grow clip buffer"));
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->m_pClipBuf = (RRCLIPCODE *)this->m_ClipFlagBuf.GetAddress();
    }

    //
    // Transform, Light and compute clipping for vertices
    //
    if (ProcessVertices())
    {
        // If the entire primitive lies outside the view frustum, quit
        // without drawing
        return D3D_OK;
    }

    //
    // Clip and Draw the primitives
    //

    if (bIndexedPrim)
    {
        if (!NeedClipping((m_dwTLState & RRPV_GUARDBAND), m_clipUnion))
        {
            ret = DoDrawOneIndexedPrimitive( this,
                                             m_dwOutputVtxSize,
                                             (PUINT8) m_pvOut,
                                             m_pIndices,
                                             m_primType,
                                             m_dwNumIndices
                                             );
        }
        else
        {
            ret = DrawOneClippedIndexedPrimitive();
        }
    }
    else
    {
        if (!NeedClipping((m_dwTLState & RRPV_GUARDBAND), m_clipUnion))
        {
            ret = DoDrawOnePrimitive( this,
                                      m_dwOutputVtxSize,
                                      (PUINT8) m_pvOut,
                                      m_primType,
                                      m_dwNumVertices
                                      );
        }
        else
        {
            ret = DrawOneClippedPrimitive();
        }
    }

#if 0
    D3DFE_UpdateClipStatus(this);
#endif //0
    return ret;
}



//---------------------------------------------------------------------
// ReferenceRasterizer::UpdateTLState
//             Updates transform and lighting related state
//---------------------------------------------------------------------
HRESULT
ReferenceRasterizer::UpdateTLState()
{
    HRESULT hr = D3D_OK;

    //
    // Update Geometry Loop flags based on the current state set
    //

    // Need to compute the Min of what is in the FVF and the renderstate.
    m_numVertexBlends = min( GetRenderState()[D3DRENDERSTATE_VERTEXBLEND],
                             ((m_dwFVFIn & D3DFVF_POSITION_MASK) >> 1) - 2 );

#ifdef __POINTSPRITES
    //
    // Check prim type to see if point size computation is needed
    // Need to set this before the transform state is set
    //
    m_dwTLState &= ~RRPV_DOCOMPUTEPOINTSIZE;
    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        m_dwTLState |= RRPV_DOCOMPUTEPOINTSIZE;
        break;
    }
#endif

    m_dwTLState &= ~(RRPV_DOPASSEYENORMAL|RRPV_DOPASSEYEXYZ);
    for ( DWORD dwStage=0; dwStage<D3DHAL_TSS_MAXSTAGES; dwStage++ )
    {
        // check for disabled stage (subsequent are thus inactive)
        if ( GetTextureStageState(dwStage)[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        switch ( GetTextureStageState(dwStage)[D3DTSS_TEXCOORDINDEX] & 0xffff0000)
        {
        case D3DTSS_TCI_CAMERASPACENORMAL:
            m_dwTLState |= RRPV_DOPASSEYENORMAL;
            break;
        case D3DTSS_TCI_CAMERASPACEPOSITION:
            m_dwTLState |= RRPV_DOPASSEYEXYZ;
            break;
        case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
            m_dwTLState |= (RRPV_DOPASSEYENORMAL|RRPV_DOPASSEYEXYZ);
            break;
        }
    }

    // Fog or not:
    // Compute fog if: 1) Fogging is enabled
    //                 2) VertexFog mode is not FOG_NONE
    //                 3) TableFog mode is FOG_NONE
    // If both table and vertex fog are not FOG_NONE, table fog
    // is applied.
    if (GetRenderState()[D3DRENDERSTATE_FOGENABLE] &&
        GetRenderState()[D3DRENDERSTATE_FOGVERTEXMODE] &&
        !GetRenderState()[D3DRENDERSTATE_FOGTABLEMODE])
    {
        m_dwTLState |= RRPV_DOFOG;
        // Range Fog
        if (GetRenderState()[D3DRENDERSTATE_RANGEFOGENABLE])
        {
            m_dwTLState |= RRPV_RANGEFOG;
        }
        else
        {
            m_dwTLState &= ~RRPV_RANGEFOG;
        }
    }
    else
    {
        m_dwTLState &= ~(RRPV_DOFOG | RRPV_RANGEFOG);
    }

    // Something changed in the transformation state
    // Recompute digested transform state
    HR_RET(UpdateXformData());

    // Something changed in the lighting state
    if ((m_dwTLState & RRPV_DOLIGHTING) &&
        (m_dwDirtyFlags & RRPV_DIRTY_LIGHTING))
    {
        //
        // Compute Colorvertex flags only if the lighting is enabled
        //
        m_dwTLState &= ~RRPV_COLORVERTEXFLAGS;
        m_lighting.pAmbientSrc = &m_lighting.matAmb;
        m_lighting.pDiffuseSrc = &m_lighting.matDiff;
        m_lighting.pSpecularSrc = &m_lighting.matSpec;
        m_lighting.pEmissiveSrc = &m_lighting.matEmis;
        m_lighting.pDiffuseAlphaSrc = &m_lighting.materialDiffAlpha;
        m_lighting.pSpecularAlphaSrc = &m_lighting.materialSpecAlpha;
        if (GetRenderState()[D3DRENDERSTATE_COLORVERTEX])
        {
            switch( GetRenderState()[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXAMB);
                        m_lighting.pAmbientSrc = &m_lighting.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXAMB);
                        m_lighting.pAmbientSrc = &m_lighting.vertexSpecular;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXDIFF);
                        m_lighting.pDiffuseSrc = &m_lighting.vertexDiffuse;
                        m_lighting.pDiffuseAlphaSrc =
                            &m_lighting.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXDIFF);
                        m_lighting.pDiffuseSrc = &m_lighting.vertexSpecular;
                        m_lighting.pDiffuseAlphaSrc =
                            &m_lighting.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_SPECULARMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXSPEC);
                        m_lighting.pSpecularSrc = &m_lighting.vertexDiffuse;
                        m_lighting.pSpecularAlphaSrc =
                            &m_lighting.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXSPEC);
                        m_lighting.pSpecularSrc = &m_lighting.vertexSpecular;
                        m_lighting.pSpecularAlphaSrc =
                            &m_lighting.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXEMIS);
                        m_lighting.pEmissiveSrc = &m_lighting.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXEMIS);
                        m_lighting.pEmissiveSrc = &m_lighting.vertexSpecular;
                    }
                }
                break;
            }
        }

        // If specular is needed in the output and has been provided
        // in the input, force the copy of specular data
        if ((m_dwFVFIn & D3DFVF_SPECULAR) && 
            (GetRenderState()[D3DRENDERSTATE_SPECULARENABLE] == FALSE))
        {
            m_dwTLState |= RRPV_VERTEXSPECULARNEEDED;
        }

        //
        // Update the remaining light state
        //
        HR_RET(UpdateLightingData());
    }

    if ((m_dwTLState & RRPV_DOFOG) &&
        (m_dwDirtyFlags & RRPV_DIRTY_FOG))
    {
        HR_RET(UpdateFogData());
    }



    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// RRProcessVertices method implementations
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
inline void MakeRRCOLOR( RRCOLOR *out, DWORD inputColor )
{
    out->r = (D3DVALUE)RGBA_GETRED( inputColor );
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor );
    out->b = (D3DVALUE)RGBA_GETBLUE( inputColor );
}

//---------------------------------------------------------------------
// RRProcessVertices::ComputeClipCodes
//---------------------------------------------------------------------
RRCLIPCODE
RRProcessVertices::ComputeClipCodes(RRCLIPCODE* pclipIntersection, RRCLIPCODE* pclipUnion,
        FLOAT x_clip, FLOAT y_clip, FLOAT z_clip, FLOAT w_clip, FLOAT fPointSize)
{
    // if true, need to deal with point size for clipping
    BOOL bPointSize = (fPointSize > 1.0f);
    D3DVALUE xx = w_clip - x_clip;
    D3DVALUE yy = w_clip - y_clip;
    D3DVALUE zz = w_clip - z_clip;

    // if (x < 0)  clip |= RRCLIP_LEFTBIT;
    // if (x >= we) clip |= RRCLIP_RIGHTBIT;
    // if (y < 0)  clip |= RRCLIP_BOTTOMBIT;
    // if (y >= we) clip |= RRCLIP_TOPBIT;
    // if (z < 0)    clip |= RRCLIP_FRONTBIT;
    // if (z >= we) clip |= RRCLIP_BACKBIT;
    RRCLIPCODE clip = ((AS_INT32(x_clip)  & 0x80000000) >>  (32-RRCLIP_LEFTBIT))  |
           ((AS_INT32(y_clip)  & 0x80000000) >>  (32-RRCLIP_BOTTOMBIT))|
           ((AS_INT32(z_clip)  & 0x80000000) >>  (32-RRCLIP_FRONTBIT)) |
           ((AS_INT32(xx) & 0x80000000) >>  (32-RRCLIP_RIGHTBIT))  |
           ((AS_INT32(yy) & 0x80000000) >>  (32-RRCLIP_TOPBIT))    |
           ((AS_INT32(zz) & 0x80000000) >>  (32-RRCLIP_BACKBIT));

    RRCLIPCODE clipBit = RRCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if( m_xfmUserClipPlanes[j].bActive )
        {
            RRVECTOR4& plane = m_xfmUserClipPlanes[j].plane;
            FLOAT fComp = 0.0f;
            if (bPointSize)
            {
                // if clipping point sprites, take the sprite size into account
                // and set the user clip bit if the sprite might be clipped
                FLOAT x_clip_size = fPointSize*0.5f*w_clip/m_ViewData.scaleX;
                FLOAT y_clip_size = fPointSize*0.5f*w_clip/m_ViewData.scaleY;
                fComp = (FLOAT)sqrt(x_clip_size*x_clip_size + y_clip_size*y_clip_size);
            }
            if( (x_clip*plane.x +
                 y_clip*plane.y +
                 z_clip*plane.z +
                 w_clip*plane.w) < fComp )
            {
                clip |= clipBit;
            }
        }
        clipBit <<= 1;
    }

    if (clip == 0)
    {
        *pclipIntersection = 0;
        return clip;
    }
    else
    {
        if (m_dwTLState & RRPV_GUARDBAND)
        {
            // We do guardband check in the projection space, so
            // we transform X and Y of the vertex there
            D3DVALUE xnew = x_clip * m_ViewData.gb11 +
                            w_clip * m_ViewData.gb41;
            D3DVALUE ynew = y_clip * m_ViewData.gb22 +
                            w_clip * m_ViewData.gb42;
            D3DVALUE xx = w_clip - xnew;
            D3DVALUE yy = w_clip - ynew;
            clip |= ((AS_INT32(xnew) & 0x80000000) >> (32-RRCLIPGB_LEFTBIT))   |
                    ((AS_INT32(ynew) & 0x80000000) >> (32-RRCLIPGB_BOTTOMBIT)) |
                    ((AS_INT32(xx)   & 0x80000000) >> (32-RRCLIPGB_RIGHTBIT))  |
                    ((AS_INT32(yy)   & 0x80000000) >> (32-RRCLIPGB_TOPBIT));
        }
        if (bPointSize)
        {
            // point sprite could still be visible
            *pclipIntersection &= (clip & ~(RRCLIP_LEFT | RRCLIP_RIGHT | RRCLIP_TOP | RRCLIP_BOTTOM |
                                   RRCLIP_USERCLIPPLANE0 | RRCLIP_USERCLIPPLANE1 | RRCLIP_USERCLIPPLANE2 |
                                   RRCLIP_USERCLIPPLANE3 | RRCLIP_USERCLIPPLANE4 | RRCLIP_USERCLIPPLANE5));
        }
        else
        {
            *pclipIntersection &= clip;
        }
        *pclipUnion |= clip;
        return clip;
    }
}

//---------------------------------------------------------------------
// RRProcessVertices::ProcessVertices
//---------------------------------------------------------------------
RRCLIPCODE
RRProcessVertices::ProcessVertices()
{
    D3DVERTEX   *pin  = (D3DVERTEX*)m_position.lpvData;
    DWORD       in_size = m_position.dwStride;
    DWORD       inFVF = m_dwFVFIn;

    D3DTLVERTEX *pout  = (D3DTLVERTEX*)m_pvOut;
    DWORD       out_size =  m_dwOutputVtxSize;
    UINT64       outFVF = m_qwFVFOut;

    RRCLIPCODE *pclip = m_pClipBuf;
    DWORD       flags = m_dwTLState;
    RRCLIPCODE  clipIntersection = ~0;
    RRCLIPCODE  clipUnion = 0;
    DWORD       count = m_dwNumVertices;
    D3DLIGHTINGELEMENT le;
    BOOL bVertexInEyeSpace = FALSE;

    //
    // Number of vertices to blend. i.e number of blend-matrices to
    // use is numVertexBlends+1.
    //
    int numVertexBlends = m_numVertexBlends;
    m_lighting.outDiffuse = RR_DEFAULT_DIFFUSE;
    m_lighting.outSpecular = RR_DEFAULT_SPECULAR;

    //
    // The main transform loop
    //
    for (DWORD i = count; i; i--)
    {
        const D3DVECTOR *pNormal = (D3DVECTOR *)((LPBYTE)pin +
                                                 m_dwNormalOffset);

        float x_clip=0.0f, y_clip=0.0f, z_clip=0.0f, w_clip=0.0f;
        float inv_w_clip=0.0f;
        float *pBlendFactors = (float *)((LPBYTE)pin + sizeof( D3DVALUE )*3);
        float cumulBlend = 0; // Blend accumulated so far
        ZeroMemory( &le, sizeof(D3DLIGHTINGELEMENT) );

        //
        // Transform vertex to the clipping space, and position and normal
        // into eye space, if needed.
        //

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if (m_dwTLState & (RRPV_DOCOMPUTEPOINTSIZE|RRPV_DOPASSEYEXYZ|RRPV_DOLIGHTING))
            {
                le.dvPosition.x += (pin->x*m_xfmToEye[j]._11 +
                                    pin->y*m_xfmToEye[j]._21 +
                                    pin->z*m_xfmToEye[j]._31 +
                                    m_xfmToEye[j]._41) * blend;
                le.dvPosition.y += (pin->x*m_xfmToEye[j]._12 +
                                    pin->y*m_xfmToEye[j]._22 +
                                    pin->z*m_xfmToEye[j]._32 +
                                    m_xfmToEye[j]._42) * blend;
                le.dvPosition.z += (pin->x*m_xfmToEye[j]._13 +
                                    pin->y*m_xfmToEye[j]._23 +
                                    pin->z*m_xfmToEye[j]._33 +
                                    m_xfmToEye[j]._43) * blend;
            }

            if (m_dwTLState & (RRPV_DOPASSEYENORMAL|RRPV_DOLIGHTING))
            {
                // Transform vertex normal to the eye space
                // We use inverse transposed matrix
                le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[j]._11 +
                                  pNormal->y*m_xfmToEyeInv[j]._12 +
                                  pNormal->z*m_xfmToEyeInv[j]._13) * blend;
                le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[j]._21 +
                                  pNormal->y*m_xfmToEyeInv[j]._22 +
                                  pNormal->z*m_xfmToEyeInv[j]._23) * blend;
                le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[j]._31 +
                                  pNormal->y*m_xfmToEyeInv[j]._32 +
                                  pNormal->z*m_xfmToEyeInv[j]._33) * blend;
            }

            // Apply WORLDj
            x_clip += (pin->x*m_xfmCurrent[j]._11 +
                pin->y*m_xfmCurrent[j]._21 +
                pin->z*m_xfmCurrent[j]._31 +
                m_xfmCurrent[j]._41) * blend;
            y_clip += (pin->x*m_xfmCurrent[j]._12 +
                pin->y*m_xfmCurrent[j]._22 +
                pin->z*m_xfmCurrent[j]._32 +
                m_xfmCurrent[j]._42) * blend;
            z_clip += (pin->x*m_xfmCurrent[j]._13 +
                pin->y*m_xfmCurrent[j]._23 +
                pin->z*m_xfmCurrent[j]._33 +
                m_xfmCurrent[j]._43) * blend;
            w_clip += (pin->x*m_xfmCurrent[j]._14 +
                pin->y*m_xfmCurrent[j]._24 +
                pin->z*m_xfmCurrent[j]._34 +
                m_xfmCurrent[j]._44) * blend;
        }

        if ((flags & RRPV_NORMALIZENORMALS) && (m_dwTLState & (RRPV_DOPASSEYENORMAL|RRPV_DOLIGHTING)))
            Normalize(le.dvNormal);

        RRFVFExtractor VtxOut( pout, outFVF, FALSE );

        FLOAT fPointSize = 0.0f;
#ifdef __POINTSPRITES
        if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
        {
            FLOAT fDist = (FLOAT)sqrt(le.dvPosition.x*le.dvPosition.x + le.dvPosition.y*le.dvPosition.y +
                                      le.dvPosition.z*le.dvPosition.z);
            if (inFVF & D3DFVF_S)
            {
                RRFVFExtractor VtxIn( pin, inFVF, FALSE );
                fPointSize = VtxIn.GetS();
            }
            else
            {
                // from D3DRENDERSTATE_POINTSIZE
                fPointSize = m_fPointSize;
            }
            fPointSize = fPointSize*(FLOAT)sqrt(1.0f/
                       (m_fPointAttA + m_fPointAttB*fDist + m_fPointAttC*fDist*fDist));
            fPointSize = max(m_fPointSizeMin, fPointSize);
            fPointSize = min(RRMAX_POINT_SIZE, fPointSize);
            FLOAT *pfSOut = VtxOut.GetPtrS();
            *pfSOut = fPointSize;
        }
#endif

        if (m_dwTLState & RRPV_DOPASSEYENORMAL)
        {
            FLOAT *pfEye = VtxOut.GetPtrEyeNormal();
            pfEye[0] = le.dvNormal.x;
            pfEye[1] = le.dvNormal.y;
            pfEye[2] = le.dvNormal.z;
        }

        if (m_dwTLState & RRPV_DOPASSEYEXYZ)
        {
            FLOAT *pfEye = VtxOut.GetPtrEyeXYZ();
            pfEye[0] = le.dvPosition.x;
            pfEye[1] = le.dvPosition.y;
            pfEye[2] = le.dvPosition.z;
        }

        //
        // Compute clip codes if needed
        //
        if (m_dwTLState & RRPV_DOCLIPPING)
        {
            RRCLIPCODE clip = ComputeClipCodes(&clipIntersection, &clipUnion,
                                               x_clip, y_clip, z_clip, w_clip, fPointSize);
            if (clip == 0)
            {
                *pclip++ = 0;
                inv_w_clip = D3DVAL(1)/w_clip;
            }
            else
            {
                if (m_dwTLState & RRPV_GUARDBAND)
                {
                    if ((clip & ~RRCLIP_INGUARDBAND) == 0)
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = D3DVAL(1)/w_clip;
                        *pclip++ = (RRCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                *pclip++ = (RRCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates, hence store the clip coordinates
                pout->sx = x_clip;
                pout->sy = y_clip;
                pout->sz = z_clip;
                pout->rhw = w_clip;
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if (!FLOAT_EQZ(w_clip))
                inv_w_clip = D3DVAL(1)/w_clip;
            else
                inv_w_clip = __HUGE_PWR2;
        }

l_DoScreenCoord:

        pout->sx = x_clip * inv_w_clip * m_ViewData.scaleX +
            m_ViewData.offsetX;
        pout->sy = y_clip * inv_w_clip * m_ViewData.scaleY +
            m_ViewData.offsetY;
        pout->sz = z_clip * inv_w_clip * m_ViewData.scaleZ +
            m_ViewData.offsetZ;
        pout->rhw = inv_w_clip;

l_DoLighting:

        DWORD *pOut = (DWORD*)((char*)pout + 4*sizeof(D3DVALUE));


        if (flags & RRPV_DOLIGHTING)
        {
            bVertexInEyeSpace = TRUE;

            //
            // If Diffuse color is needed, extract it for color vertex.
            //
            if (flags & RRPV_VERTEXDIFFUSENEEDED)
            {
                const DWORD color = *(DWORD*)((char*)pin + m_dwDiffuseOffset);
                MakeRRCOLOR(&m_lighting.vertexDiffuse, color);
                m_lighting.vertexDiffAlpha = color & 0xff000000;
            }

            //
            // If Specular color is needed and provided
            // , extract it for color vertex.
            //
            if (flags & RRPV_VERTEXSPECULARNEEDED)
            {
                const DWORD color = *(DWORD*)((char*)pin + m_dwSpecularOffset);
                MakeRRCOLOR(&m_lighting.vertexSpecular, color);
                m_lighting.vertexSpecAlpha = color & 0xff000000;
            }

            //
            // Light the vertex
            //
            LightVertex( &le );
        }
        else if (inFVF & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
        {
            if (inFVF & D3DFVF_DIFFUSE)
                m_lighting.outDiffuse = *(DWORD*)((char*)pin + m_dwDiffuseOffset);
            if (inFVF & D3DFVF_SPECULAR)
                m_lighting.outSpecular = *(DWORD*)((char*)pin + m_dwSpecularOffset);
        }

        //
        // Compute Vertex Fog if needed
        //
        if (flags & RRPV_DOFOG)
        {
            FogVertex( *(D3DVECTOR*)(pin), &le,  numVertexBlends,
                       pBlendFactors, bVertexInEyeSpace );
        }

        if (outFVF & D3DFVF_DIFFUSE)
            *pOut++ = m_lighting.outDiffuse;
        if (outFVF & D3DFVF_SPECULAR)
            *pOut++ = m_lighting.outSpecular;;

        {
            memcpy(pOut, (char*)pin + m_dwTexOffset, m_dwTextureCoordSizeTotal);
        }
        pin = (D3DVERTEX*) ((char*) pin + in_size);
        pout = (D3DTLVERTEX*) ((char*) pout + out_size);
    }

    if (flags & RRPV_DOCLIPPING)
    {
        m_clipIntersection = clipIntersection;
        m_clipUnion = clipUnion;
    }
    else
    {
        m_clipIntersection = 0;
        m_clipUnion = 0;
    }

    // Returns whether all the vertices were off screen
    return m_clipIntersection;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\reftnl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.cpp
//
// Direct3D Reference Transformation and Lighting  - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RefAlignedBuffer32
///////////////////////////////////////////////////////////////////////////////
HRESULT RefAlignedBuffer32::Grow(DWORD growSize)
{
    if (m_allocatedBuf)
        free(m_allocatedBuf);
    m_size = growSize;
    if ((m_allocatedBuf = malloc(m_size + 31)) == NULL)
    {
        m_allocatedBuf = 0;
        m_alignedBuf = 0;
        m_size = 0;
        return DDERR_OUTOFMEMORY;
    }
    m_alignedBuf = (LPVOID)(((ULONG_PTR)m_allocatedBuf + 31 ) & ~31);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// RRProcessVertices::InitTL()
///////////////////////////////////////////////////////////////////////////////
void 
RRProcessVertices::InitTLData()
{
    m_LightVertexTable.pfnDirectional = RRLV_Directional;
    m_LightVertexTable.pfnParallelPoint = RRLV_Directional;
    m_LightVertexTable.pfnSpot = RRLV_PointAndSpot;
    m_LightVertexTable.pfnPoint = RRLV_PointAndSpot;
    
    //
    // Guardband parameters
    //

    // By default enable Guardband and set the extents equal 
    // to the default RefRast parameters
    m_dwTLState |= RRPV_GUARDBAND;
    m_ViewData.minXgb = (REF_GB_LEFT);
    m_ViewData.maxXgb = REF_GB_RIGHT;
    m_ViewData.minYgb = (REF_GB_TOP);
    m_ViewData.maxYgb = REF_GB_BOTTOM;
    
#if DBG
    DWORD v = 0;
    // Guardband parameters
    if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
        v != 0)
    {
        m_dwTLState &= ~RRPV_GUARDBAND;
    }
    // Try to get test values for the guard band
    char value[80];
    if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.minXgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.maxXgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.minYgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.maxYgb);
#endif // DBG
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\sources.inc ===
TARGETNAME = reftnl
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\xform.cpp    \
        ..\lighting.cpp \
        ..\clipping.cpp \
        ..\reftnl.cpp   \
        ..\procprim.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\ref\tnl\xform.cpp ===
#include "pch.cpp"
#pragma hdrstop


//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RRProcessVertices::UpdateXformData
//             Updates transform data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateXformData()
{
    HRESULT hr = D3D_OK;
    RRVIEWPORTDATA&  VData = m_ViewData;
    RRTRANSFORMDATA& TData = m_TransformData;


    // Update viewport information
    if (m_dwDirtyFlags & RRPV_DIRTY_ZRANGE)
    {
        VData.scaleZ  = m_Viewport.dvMaxZ - m_Viewport.dvMinZ;
        VData.offsetZ = m_Viewport.dvMinZ;
        // ATTENTION: This could be a Divide by Zero here if
        // the dvMaxZ == dvMinZ. Fix it later.
        VData.scaleZi = D3DVAL(1) / VData.scaleZ;
    }

    if (m_dwDirtyFlags & RRPV_DIRTY_VIEWRECT)
    {
        // Bail if we are going to cause any divide by zero exceptions.
        // The likely reason is that we have a bogus viewport set by
        // TLVertex execute buffer app.
        if(m_Viewport.dwWidth == 0 || m_Viewport.dwHeight == 0 )
            return DDERR_GENERIC;

        VData.dvX = D3DVAL(m_Viewport.dwX);
        VData.dvY = D3DVAL(m_Viewport.dwY);
        VData.dvWidth = D3DVAL(m_Viewport.dwWidth);
        VData.dvHeight = D3DVAL(m_Viewport.dwHeight);

        // Coefficients to compute screen coordinates from normalized window
        // coordinates
        VData.scaleX  = VData.dvWidth;
        VData.scaleY  = - VData.dvHeight;
        VData.offsetX = VData.dvX;
        VData.offsetY = VData.dvY + VData.dvHeight;

#if 0
        // Small offset is added to prevent generation of negative screen
        // coordinates (this could happen because of precision errors).
        // Not needed (or wanted) for devices which do guardband.
        VData.offsetX += SMALL_NUMBER;
        VData.offsetY += SMALL_NUMBER;
#endif

        VData.scaleXi = D3DVAL(1) / VData.scaleX;
        VData.scaleYi = D3DVAL(1) / VData.scaleY;

        VData.minX = VData.dvX;
        VData.maxX = VData.dvX + VData.dvWidth;
        VData.minY = VData.dvY;
        VData.maxY = VData.dvY + VData.dvHeight;

        if (m_dwTLState & RRPV_GUARDBAND)
        {
            // Because we clip by guard band window we have to use its extents
            D3DVALUE w = 2.0f / VData.dvWidth;
            D3DVALUE h = 2.0f / VData.dvHeight;
            D3DVALUE ax1 = -(VData.minXgb - VData.dvX) * w + 1.0f;
            D3DVALUE ax2 =  (VData.maxXgb - VData.dvX) * w - 1.0f;
            D3DVALUE ay1 =  (VData.maxYgb - VData.dvY) * h - 1.0f;
            D3DVALUE ay2 = -(VData.minYgb - VData.dvY) * h + 1.0f;
            VData.gb11 = 2.0f / (ax1 + ax2);
            VData.gb41 = VData.gb11 * (ax1 - 1.0f) * 0.5f;
            VData.gb22 = 2.0f / (ay1 + ay2);
            VData.gb42 = VData.gb22 * (ay1 - 1.0f) * 0.5f;

            VData.Kgbx1 = 0.5f * (1.0f - ax1);
            VData.Kgbx2 = 0.5f * (1.0f + ax2);
            VData.Kgby1 = 0.5f * (1.0f - ay1);
            VData.Kgby2 = 0.5f * (1.0f + ay2);
        }
        else
        {
            VData.minXgb = VData.minX;
            VData.maxXgb = VData.maxX;
            VData.minYgb = VData.minY;
            VData.maxYgb = VData.maxY;
        }
    }

    // Update Mproj*Mclip
    if( m_dwDirtyFlags &  RRPV_DIRTY_PROJXFM )
    {
        D3DMATRIX MShift;
        ZeroMemory (&MShift, sizeof(D3DMATRIX));
        MShift._11 = 0.5f;
        MShift._22 = 0.5f;
        MShift._41 = 0.5f;
        MShift._42 = 0.5f;
        MShift._44 = 1.0f;
        MShift._33 = 1.0f;

        MatrixProduct(&TData.m_PS, &m_xfmProj, &MShift);
    }

    // Update Mview*Mproj*Mclip
    if( m_dwDirtyFlags & (RRPV_DIRTY_VIEWXFM | RRPV_DIRTY_PROJXFM) )
    {
        MatrixProduct(&TData.m_VPS, &m_xfmView, &TData.m_PS);
        Inverse4x4( (D3DMATRIX *)&TData.m_VPS, (D3DMATRIX *)&TData.m_VPSInv );
    }

    for( DWORD i=0; i< RRMAX_WORLD_MATRICES; i++)
    {
        MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i],   &TData.m_VPS);
    }

    // Compute xfmToEye (world*view) matrix (needed for lighting and fog)
    // if needed
    if (m_dwDirtyFlags & (RRPV_DIRTY_VIEWXFM  |
                          RRPV_DIRTY_WORLDXFM |
                          RRPV_DIRTY_WORLD1XFM |
                          RRPV_DIRTY_WORLD2XFM |
                          RRPV_DIRTY_WORLD3XFM ))
    {
        m_dwDirtyFlags |= RRPV_DIRTY_INVERSEWORLDVIEW;
    }
        
    if (m_dwTLState & (RRPV_DOLIGHTING | RRPV_DOFOG | RRPV_DOCOMPUTEPOINTSIZE |
                       RRPV_DOPASSEYENORMAL | RRPV_DOPASSEYEXYZ) &&
        (m_dwDirtyFlags & RRPV_DIRTY_INVERSEWORLDVIEW))
    {
        for( i=0; i< RRMAX_WORLD_MATRICES; i++)
        {
            MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
            Inverse4x4((D3DMATRIX *)&m_xfmToEye[i],
                       (D3DMATRIX *)&m_xfmToEyeInv[i]);
            m_dwDirtyFlags |= RRPV_DIRTY_NEEDXFMLIGHT;
        }
        m_dwDirtyFlags &= ~RRPV_DIRTY_INVERSEWORLDVIEW;
    }

    // Clear the dirty transform flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_XFORM;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fe\ddi.inl ===
#ifndef __DDI_INL__
#define __DDI_INL__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddi.inl
 *  Content:    Contains inlines from CD3DDDI to avoid them being included
 *              by the fw directory (which doesn't like try-catch)
 *
 ***************************************************************************/

//-----------------------------------------------------------------------------
// Initializes command header in the DP2 command buffer,
// reserves space for the command data and returns pointer to the command
// data
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GetHalBufferPointer"

inline LPVOID
CD3DDDIDX6::GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + dwDataSize;

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        FlushStatesCmdBufReq(dwCommandSize);
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = op;
    bDP2CurrCmdOP = op;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    dwDP2CommandLength += dwCommandSize;
    return (LPVOID)(lpDP2CurrCommand + 1);
}

#endif //__RESOURCE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\bldlink.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8

TARGETPATH=obj
TARGETNAME=d3d8

TARGETTYPE=DYNLINK

!IF (!$(FREEBUILD))
PSGPSUFFIX=d
!ENDIF

!IFDEF D3DBBT
X3DLIB=x3dbbt.lib
KINTELLIB=ikpsgp8bbt.lib
WINTELLIB=iwpsgp8bbt.lib
!ELSE
X3DLIB=x3d$(PSGPSUFFIX).lib
KINTELLIB=ikpsgp800$(PSGPSUFFIX).lib
WINTELLIB=iwpsgp800$(PSGPSUFFIX).lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib\
        $(BASEDIR)\public\sdk\lib\*\version.lib

!IFNDEF USE_ICECAP4
!IFNDEF USE_ICECAP4_ICEPICK
!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           ..\..\lib\$(PLAT_DIR)\*\$(KINTELLIB) \
           ..\..\lib\$(PLAT_DIR)\*\$(WINTELLIB) \
           ..\..\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif
!ENDIF
!ENDIF

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS)
!endif

LINKLIBS = \
        ..\..\util\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib           \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dtnl.lib             \
        ..\..\fe\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfe.lib               \
        ..\..\fw\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfw.lib               \
        ..\..\shval\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dsv.