E *ppNode)
{
    HRESULT hr;
    HTREEITEM htiChild;

    htiChild = TreeView_GetChild(hwTreeCtl, hti);
    
    while(htiChild)
    {
        TV_ITEM tvi;
        
        tvi.hItem = htiChild;
        tvi.mask = TVIF_PARAM;
        tvi.lParam = 0;

        if(!TreeView_GetItem(hwTreeCtl, &tvi))
            return NULL;

        LPTVNODE pNode = (LPTVNODE) tvi.lParam;
        Assert(pNode);

        ULONG ulMatch = 0;
        hr = pCFDlg->Session()->CompareEntryIDs(cb, pbEID,
                            pNode->_pval[iEID].Value.bin.cb,
                            (LPENTRYID)pNode->_pval[iEID].Value.bin.lpb,
                            0, &ulMatch);
        if(SUCCEEDED(hr))
        {
            if(ulMatch)
            {
                *ppNode = pNode;
                return htiChild;
            }
        }

        htiChild = TreeView_GetNextSibling(hwTreeCtl, htiChild);
    }

    return htiChild;
}

//
//  CChsFldDlg::HrRestoreTreeState
//
HRESULT CChsFldDlg::HrRestoreTreeState(void)
{
    HRESULT hr = hrSuccess;
    LPBYTE pb;
    LPBYTE pbMax;
    CTIStack tiStack;
    HTREEITEM hti;
    LONG iLevel = 0;
    BOOL fNodeMissing = FALSE;

    if(!_pcbState  || *_pcbState == 0)
        return hrSuccess;

    //try //protect ourself from callers who mess with the state data
    //{
    Assert(_hwTreeCtl);

    Assert(_ppbState);
    pb = *_ppbState;

    pbMax = pb + *_pcbState;
    
    hti = TreeView_GetRoot(_hwTreeCtl);

    iLevel = GetLevel(&pb);
    Assert(iLevel == 0);

    TreeView_Expand(_hwTreeCtl, hti, TVE_EXPAND);
    
    while(hti)
    {
        if(pb >= pbMax)
            break; //done
            
        LONG iNewLevel = GetLevel(&pb);

        if(iNewLevel <= iLevel)
        {
            do
            {
                hti = tiStack.Pop();
                --iLevel;
            }while(iLevel >= iNewLevel);

            Assert(hti);
        }

        if(iNewLevel > iLevel)
        {
            if(!fNodeMissing)
                Assert(iNewLevel == iLevel + 1);

            ULONG cbEID = GetCb(&pb);
            LPENTRYID pbEID = (LPENTRYID)pb;
            pb += Align4(cbEID);

            if(iNewLevel != iLevel +1)
                continue;
                
            LPTVNODE pNodeChild = NULL;
            HTREEITEM htiChild = HtiFindChild(_hwTreeCtl, hti, cbEID, pbEID,
                                            this, &pNodeChild);
            if(htiChild)
            {
                fNodeMissing = FALSE;
                
                hr = pNodeChild->HrExpand(this);
                if(FAILED(hr))
                    goto err;

                TreeView_Expand(_hwTreeCtl, htiChild, TVE_EXPAND);
                
                tiStack.Push(hti);

                hti = htiChild;
                ++iLevel;

                continue;
            }
            else
            {
                //Assert(FALSE); //$ handle
                fNodeMissing = TRUE;
            }

        }
        /*else
        {
            do
            {
                hti = tiStack.Pop();
                --iLevel;
            }while(iLevel >= iNewLevel);
        }*/
    }
    //}

    //catch(...)
    //{
        //DebugTrace("chsfld: Exception caught in HrRestoreTreeState\n");
    //    hr = E_FAIL;
    //}
    
err:

    /*MAPIFreeBuffer(*_ppbState);
    *_ppbState = NULL;
    *_pcbState = 0;*/
    
    
    //DebugTraceResult(CChsFldDlg::HrRestoreTreeState, hr);
    return hr;
}


//////////////////////////////////////////////////////////////////////////
// CTVNodeFactory

//
//  CTVNodeFactory::CTVNodeFactory
//
inline CTVNodeFactory::CTVNodeFactory()
{
    _pHead = NULL;
}

//
//  CTVNodeFactory::~CTVNodeFactory
//
//  Destroy all created CTVNode s
CTVNodeFactory::~CTVNodeFactory()
{
    while(_pHead)
    {
        LPTVNODE ptemp = _pHead;

        _pHead = _pHead->_pNext;

        delete ptemp;
    }
}


//
//  CTVNodeFactory::HrCreateNode
//
// All instances of CTVNode are created through this method
//
HRESULT CTVNodeFactory::HrCreateNode(LPSPropValue pval, ULONG cVals, LPMDB pmdb,
                                        LPTVNODE * pptvNode)
{
    HRESULT hr = hrSuccess;

    LPTVNODE pNode = new CTVNode(pval, cVals, pmdb);
    
    if(!pNode)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }

    Insert(pNode);

    *pptvNode = pNode;
            
err:

    //DebugTraceResult(CTVNodeFactory::HrCreateNode, hr);
    return hr;
}


//
//  CTVNodeFactory::Insert
//
// Store all created CTVNode s so that we can destroy them when we are done
//
void CTVNodeFactory::Insert(LPTVNODE pNode)
{
    pNode->_pNext = _pHead;
    _pHead = pNode;
}


//
//  ChsFldDlgProc
//
// Dialog proc for the choose folder dialog
//
//  Controls:
//          IDOK        "OK"
//          IDCANCEL    "Cancel"
//          IDC_NEWFLD  "New Folder"
//
BOOL CALLBACK
ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    CChsFldDlg * pCDlg = NULL;
    HWND hwTreeCtl = NULL;
    int wmId;
    int wmEvent;
    HTREEITEM hti = NULL;
    TV_ITEM tvi;
        
    switch(msg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        pCDlg = (CChsFldDlg *)lParam;

        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW);
        Assert(hwTreeCtl);

        hr = pCDlg->HrInitTree(hDlg, hwTreeCtl);
        if(HR_FAILED(hr))
        {
            pCDlg->SetError(hr);
            EndDialog(hDlg, 1);
            break;
        }

        SetWindowLong(hDlg, DWL_USER, (LONG)pCDlg);

        break;

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);  
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW);
        Assert(hwTreeCtl);

        pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
        Assert(pCDlg);


        switch(wmId)
        {
        case IDOK:
            switch (wmEvent)
            {
            case BN_CLICKED:
                        
                hti = TreeView_GetSelection(hwTreeCtl);
                AssertSz(hti, "No Selection?");

                tvi.hItem = hti;
                tvi.mask = TVIF_PARAM;

                if(TreeView_GetItem(hwTreeCtl, &tvi))
                {
                    LPTVNODE pNode = (LPTVNODE)tvi.lParam;
                    Assert(pNode);

                    LPMAPIFOLDER pfld = NULL;
                    LPMDB pmdb = NULL;

                    hr = pNode->HrGetFolder(pCDlg, &pfld, &pmdb);
                    if(HR_SUCCEEDED(hr))
                    {
                        pCDlg->SetFolder(pfld, pmdb);
                        pfld->Release();
                        pmdb->Release();

                        hr = pCDlg->HrSaveTreeState();                  
                    }
                    else
                    {
                        pCDlg->SetError(hr);
                    }
                }
                else
                {
                    pCDlg->SetError(E_FAIL);
                }

                EndDialog(hDlg, TRUE);

                break;

            default:
                return FALSE;
            }
            break;

        case IDC_NEWFLD:
            switch(wmEvent)
            {
            case BN_CLICKED:
                
                hti = TreeView_GetSelection(hwTreeCtl);
                AssertSz(hti, "No Selection?");

                tvi.hItem = hti;
                tvi.mask = TVIF_PARAM;

                if(TreeView_GetItem(hwTreeCtl, &tvi))
                {
                    LPTVNODE pNode = (LPTVNODE)tvi.lParam;
                    Assert(pNode);
                    LPTSTR szName = NULL;
                    
                    do
                    {
                        hr = HrGetNewName(pCDlg->hInst(), hDlg, &szName);
                        if(HR_SUCCEEDED(hr))
                        {
                            hr = pNode->HrNewFolder(pCDlg, szName);
                        }
                    }while(hr == MAPI_E_COLLISION);

                    MAPIFreeBuffer(szName);
                    szName = NULL;

                }

                SetFocus(hwTreeCtl);

                break;

            default:
                return FALSE;
            }
            break;
    
        case IDCANCEL:
            switch(wmEvent)
            {
            case BN_CLICKED:

                pCDlg->SetError(MAPI_E_USER_CANCEL);

                EndDialog(hDlg, TRUE);
                break;

            default:
                return FALSE;
            }
            break;
        }
        break;
        
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code)
        {
        case TVN_ITEMEXPANDINGW:
        case TVN_ITEMEXPANDINGA:
            {
            Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            NM_TREEVIEW * ptntv = (NM_TREEVIEW *)lParam;

            if(ptntv->action != TVE_EXPAND)
                return FALSE;

            //
            // If the kids of this node are not loaded, load'em 
            LPTVNODE pNode = (LPTVNODE)ptntv->itemNew.lParam;
            Assert(pNode);

            hwTreeCtl = ((LPNMHDR)lParam)->hwndFrom;
            
            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
            //Assert(pCDlg);

            hr = pNode->HrExpand(pCDlg);  
            if(HR_FAILED(hr))
            {
                return TRUE;
            }
                return FALSE;
            }   
            break;
        case TVN_GETDISPINFOW:
        case TVN_GETDISPINFOA:
            {
            Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            //
            // we don't give folder names to the tree control (to save space)
            // when it wants to display an item, it asks us for the name
            //
            TV_DISPINFO * pdi = (TV_DISPINFO *)lParam;

            if(pdi->item.mask & TVIF_TEXT)
            {
                if (((LPNMHDR)lParam)->code == TVN_GETDISPINFOA)
                {
                    WideCharToMultiByte(CP_ACP, 0, ((LPTVNODE)pdi->item.lParam)->GetName(), -1, 
                                            (char*)pdi->item.pszText, pdi->item.cchTextMax, NULL, NULL);
                }
                else
                {
                    pdi->item.pszText = ((LPTVNODE)pdi->item.lParam)->GetName();
                }
                    
                return TRUE;
            }
            else
            {
                return FALSE;
            }
            }

            break;
            
        case TVN_SELCHANGEDW:
        case TVN_SELCHANGEDA:
            //
            //Enable "OK" and "New Folder" buttons only if it is not the 
            //root node
            //
            {Assert(((LPNMHDR)lParam)->idFrom == IDC_TREEVIEW);

            NM_TREEVIEW *ptntv = (NM_TREEVIEW *)lParam;

            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER);
            Assert(pCDlg);
    
            EnableWindow(GetDlgItem(hDlg, IDOK),
                        !pCDlg->IsTreeRoot(ptntv->itemNew.hItem));
            EnableWindow(GetDlgItem(hDlg, IDC_NEWFLD),
                        !pCDlg->IsTreeRoot(ptntv->itemNew.hItem));
            break;
            }
            
            break;
        }
        
        break;
        
    default:
        return FALSE;   
    }
    return TRUE;
}

//
//  AddOneItem
//
// Add a node to the tree control
//
HTREEITEM AddOneItem( HTREEITEM hParent, HTREEITEM hInsAfter, 
    int iImage, int iImageSel, HWND hwndTree, LPTVNODE pNode, int cKids)
{
    HTREEITEM hItem;
    TV_INSERTSTRUCT tvIns;

    tvIns.item.mask             = TVIF_CHILDREN | TVIF_PARAM |TVIF_TEXT |
                                    TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvIns.item.pszText          = LPSTR_TEXTCALLBACK;
    tvIns.item.cchTextMax       = 0;
    tvIns.item.lParam           = (LPARAM)pNode;
    tvIns.item.cChildren        = cKids;
    tvIns.item.iImage           = iImage;
    tvIns.item.iSelectedImage   = iImageSel;

    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;
    
    // Insert the item into the tree.
    hItem = TreeView_InsertItem(hwndTree, &tvIns);

    pNode->SetHandle(hItem);

    return (hItem);
}


//
//  HrGetNewName
//
//  Display dialog asking the user for a new folder name 
//
//  If *pszNewName is not NULL, it has to be a string allocated with
//  MAPIAllocateBuffer. It will be displayed in the dialog.
//  The returned string has to be freed with MAPIFreeBuffer.
//
HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPTSTR * pszNewName)
{
    Assert(pszNewName);
    
    int nRes = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_NEWNAME), hwParent,
                        NewNameDlgProc, (LPARAM)pszNewName);
    if(nRes == 1)
    {
        return hrSuccess;
    }
    else
    {
        //DebugTraceSc(HrGetNewName, E_FAIL);
        return E_FAIL;
    }
}


//
// NewNameDlgProc
//
// Dlg proc for the "New Name" dialog;
// If user chooses OK, return 1 from EndDialog.
//
BOOL CALLBACK
NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int wmId;
    int wmEvent;

    switch(msg)
    {
    case WM_INITDIALOG:
        {
        Assert(lParam);

        LPTSTR * pszName = (LPTSTR *)lParam;

        if(*pszName)
        {
            SetWindowText(GetDlgItem(hDlg, IDC_NAME), *pszName);
            MAPIFreeBuffer(*pszName);
            *pszName = NULL;

        }
        
        SetWindowLong(hDlg, DWL_USER, (LONG)lParam);
        SetFocus(GetDlgItem(hDlg, IDC_NAME));
        return FALSE;
        }

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);  
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch(wmId)
        {
        case IDOK:
            switch (wmEvent)
            {
            case BN_CLICKED:
                {
                HWND hwName = GetDlgItem(hDlg, IDC_NAME);
                
                int cb = Edit_GetTextLength(hwName);
                Assert(cb); //OK is disabled when edit control is empty

                LPTSTR szName = NULL;
                if(!MAPIAllocateBuffer(cb + 1, (LPVOID *)&szName))
                {
                    GetWindowText(hwName, szName, cb+1);

                    LPTSTR * pszName = (LPTSTR *)GetWindowLong(hDlg, DWL_USER);

                    *pszName = szName;

                    EndDialog(hDlg, 1);
                }
                else
                {
                    EndDialog(hDlg, FALSE);
                    break;
                }
                }
                break;

            default:
                return FALSE;
            }
            
            break;

        case IDCANCEL:
            switch (wmEvent)
            {
            case BN_CLICKED:
                EndDialog(hDlg, FALSE);
                break;

            default:
                return FALSE;
            }
            
            break;

        case IDC_NAME:
            switch(wmEvent)
            {
            case EN_CHANGE:
                Assert((HWND)lParam == GetDlgItem(hDlg, IDC_NAME));

                EnableWindow(GetDlgItem(hDlg, IDOK),
                            Edit_GetTextLength((HWND)lParam));

                break;

            default:
                return FALSE;
            }
                
            break;
        }
        break;
    
    default:
        return FALSE;
    }   
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\chsfld.h ===
////////////////////////////////////////////////////////////////////////////
//
//      CHSFLD.H
//
//      Prototype for HrPickFolder.
//      Displays a dialog box allowing user to choose a folder from message
//      stores in the current profile.
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

#ifndef _CHSFLD_H_
#define _CHSFLD_H_

// Parameters:
// 
// required:
//
// hInst    - [in] instance of the module containing resources for the dialog
//
// hWnd     - [in] handle of the parent window for the dialog 
//
// pses     - [in] pointer to MAPI session object
//
// ppfld    - [out] on success points to the variable where a pointer to the
//                  selected folder is stored
//
// ppmdb    - [out] on success points to the variable where a pointer to a
//                  message store object containing the selected folder is stored
//
// optional:
//
// pcb      - [in/out] size of the buffer pointed to by *ppb
//
// ppb      - [in/out] *ppb is a pointer to the buffer where expand/collapse
//                      state of the dialog is stored. (don't mess with it).
//                      The state is valid only within the same MAPI session.
//
// Return Values:
//
// S_OK     - The call succeeded and has returned the expected values
//
// E_INVALIDARG - One or more of the parameters passed into the function
//                  were not valid
//
// MAPI_E_USER_CANCEL   - User canceled the dialog

STDAPI HrPickFolder(HINSTANCE hInst, HWND hWnd, LPMAPISESSION pses,
                    LPMAPIFOLDER * ppfld, LPMDB * ppmdb,
                    ULONG *pcb, LPBYTE *ppb);
                        
typedef   HRESULT (STDAPICALLTYPE * HRPICKFOLDER)(HINSTANCE hInst, HWND hWnd,
                    LPMAPISESSION pses, LPMAPIFOLDER * ppfld, LPMDB * ppmdb,
                    ULONG *pcb, LPBYTE *ppb);

#endif /* _CHSFLD_H_ */
#endif /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\mapi.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       mapi.cxx
//
//  Contents:   Dynamic wrappers for URL monikers.
//
//----------------------------------------------------------------------------

#define _INTERNAL_WRAPPER_BYPASS
#include <padhead.hxx>

DYNLIB g_dynlibMAPI = { NULL, NULL, "MAPI32.DLL" };

#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAPIT_VOID(fn, a1, a2)\
VOID WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return;\
    (*(VOID (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        Assert(FALSE);\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_FASTCALL(fn, cbarg, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAPIT_FASTCALL_VOID(fn, cbarg, a1, a2)\
VOID WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return;\
    (*(VOID (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_FASTCALL_(type, fn, cbarg, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMAPI, #fn "@" #cbarg };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        Assert(FALSE);\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}




WRAPIT(MAPIInitialize,
    (LPVOID lpMapiInit),
    (lpMapiInit))

WRAPIT_VOID(MAPIUninitialize,
    (),
    ())

WRAPIT(MAPIAllocateBuffer,
    (ULONG cbSize, LPVOID FAR * lppBuffer),
    (cbSize, lppBuffer))

WRAPIT(MAPIAllocateMore,
    (ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer),
    (cbSize, lpObject, lppBuffer))

WRAPIT(MAPIOpenLocalFormContainer,
    (LPMAPIFORMCONTAINER FAR * ppfcnt),
    (ppfcnt))
   
WRAPIT_(ULONG,
    MAPIFreeBuffer,
    (LPVOID lpBuffer),
    (lpBuffer))

WRAPIT_VOID(FreeProws,
    (LPSRowSet prows),
    (prows))

WRAPIT_FASTCALL(HrQueryAllRows,
    24,
    (LPMAPITABLE ptable, LPSPropTagArray ptaga, LPSRestriction pres, 
     LPSSortOrderSet psos, LONG crowsMax, LPSRowSet FAR * pprows),
    (ptable, ptaga, pres, psos, crowsMax, pprows))

WRAPIT_FASTCALL(HrGetOneProp,
    12,
    (LPMAPIPROP pmp, ULONG ulPropTag, LPSPropValue FAR * ppprop),
    (pmp, ulPropTag, ppprop))

WRAPIT_FASTCALL_VOID(FreePadrlist,
     4,
    (LPADRLIST padrlist),
    (padrlist))

WRAPIT_FASTCALL_(FILETIME,
    FtAddFt,
    16,
    (FILETIME Addend1, FILETIME Addend2),
    (Addend1, Addend2))

WRAPIT_FASTCALL_(FILETIME, 
    FtSubFt,
    16,
    (FILETIME Addend1, FILETIME Addend2),
    (Addend1, Addend2))

WRAPIT(WrapCompressedRTFStream,
    (LPSTREAM lpCRTFS, ULONG ulFlags, LPSTREAM FAR * lpUncomp),
    (lpCRTFS, ulFlags, lpUncomp))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgaddr.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgaddr.cxx
//
//  Contents:   Address list manipulation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#define		cchUnresolvedMax	256

typedef struct _editstreamcookie
{
	HRESULT         hr;
	LPADRLIST *		ppal;
	ULONG			cRecipTypes;
	ULONG			iRecipType;
	ULONG *			rgulDestComps;
	HWND *			rghwndEdit;
	LONG *			piae;
	char			rgch[cchUnresolvedMax];
	ULONG			cchBuf;
	BOOL			fTruncated;
	INT				nBrackets;
} EDITSTREAMCOOKIE;


static HRESULT AddUnresolvedName(EDITSTREAMCOOKIE * pesc);

static HRESULT SpecialAdrlistScan(LPADRLIST * ppal, LONG * piae,
				ULONG cRecipTypes, ULONG * rgulDestComps, BOOL fAboutToAdd);

static HRESULT GrowAdrlist(LPADRLIST * ppal, UINT caeToAdd);

static DWORD CALLBACK UnresolvedStream(DWORD dwCookie, LPBYTE pbBuff,
				LONG cb, LONG *pcb);



/*
 *	CPadMessage::DoCheckNames
 *
 *	Purpose:
 *		Implement Check Names command
 */
void CPadMessage::DoCheckNames()
{
    HRESULT hr;

    hr = THR_NOTRACE(GetAndCheckRecipients(TRUE));

    if (hr && hr != MAPI_E_USER_CANCEL)
        ShowError();
}


/*
 *	CPadMessage::GetAndCheckRecipients
 *
 *	Purpose:
 *		Resolves names for the message and get them into the _padrlist
 *
 *	Arguments:
 *		BOOL		Update the recipient wells?
 *
 *	Returns:
 *      hr          MAPI_E_USER_CANCEL if user cancelled operation
 */
HRESULT CPadMessage::GetAndCheckRecipients(BOOL fUpdateWells)
{
	HRESULT hr = S_OK;
	LPSPropValue pval;
	BOOL    fFoundFrom = FALSE;
	ULONG   iae;

	// Capone 4545
	// Name from resend note From well wiped out on Check Names
	if(_rghwndEdit[0])
		SendMessage(_rghwndEdit[0], EM_SETMODIFY, TRUE, 0);

	// Get the names out of the controls and into the adrlist structure
	hr = THR(ParseRecipients(TRUE));
	if (hr || !_padrlist)
		goto Cleanup;

	// Check if there is more than one name in the From well
	for (iae = 0; iae < _padrlist->cEntries; iae++)
	{
		// Ignore empty ADRENTRY's
		if (!_padrlist->aEntries[iae].rgPropVals)
			continue;

		pval = PvalFind((LPSRow) &_padrlist->aEntries[iae], PR_RECIPIENT_TYPE);
		AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
		if (pval)
		{
			if (pval->Value.ul == MAPI_ORIG)
			{
				if (fFoundFrom)
				{
					break;	// Already one found so there is more than one!
				}
				else
				{
					fFoundFrom = TRUE;
				}
			}
		}
	}

	// Early exit from loop indicates more than one name in From well
	if (iae < _padrlist->cEntries)
	{
		hr = g_LastError.SetLastError(E_FAIL);
		goto Cleanup;
	}

    // Open address book (_pab)
    hr = OpenAddrBook();
    if (hr)
    {
        ShowError();
        if (FAILED(hr))
            goto Cleanup;
    }

    // Ignore warnings 
    if (hr == MAPI_W_ERRORS_RETURNED)
        hr = S_OK;

    // Resolve recipient names
	hr = THR(_pab->ResolveName((ULONG)_hwnd, MAPI_DIALOG, NULL, _padrlist));
	if (FAILED(hr) && hr != MAPI_E_USER_CANCEL)
	{
		hr = g_LastError.SetLastError(hr, _pab);
		goto Cleanup;
	}

	// Get the names out of the adrlist structure and into the controls
	if (hr == MAPI_E_USER_CANCEL || fUpdateWells)
    {
		IGNORE_HR(DisplayRecipients(TRUE));
    }

Cleanup:

	// Remove From well type from _rghwndEdit and _rgulRecipTypes arrays

	// Capone 4311
	// Remove the From well entry from the _padrlist

	// Capone 10812
	// No resolve on send optimization (fUpdateWells == FALSE) would leave
	// MAPI_ORIG in the DIAL(_padrlist) so it can be used in ScNoteWriteMessage.

	if (fFoundFrom && (fUpdateWells || hr))
	{
		for (iae = 0; iae < _padrlist->cEntries; iae++)
		{
			// Ignore empty ADRENTRY's

			if (!_padrlist->aEntries[iae].rgPropVals)
				continue;

			pval = PvalFind((LPSRow) &_padrlist->aEntries[iae], PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval && (pval->Value.ul == MAPI_ORIG))
			{
				_padrlist->aEntries[iae].cValues = 0;
				// Exchange 30065 Memory leak
				MAPIFreeBuffer(_padrlist->aEntries[iae].rgPropVals);
				_padrlist->aEntries[iae].rgPropVals = NULL;
			}
		}
	}

    RRETURN1(hr, MAPI_E_USER_CANCEL);
}

/*
 *	ParseRecipients
 *	
 *	Purpose:
 *		Parse wells and build list of recipients
 *	
 *	Parameters:
 *		ppal		    returns pointer to list of recipients
 *      fIncludeFrom    include from well or not
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::ParseRecipients(BOOL fIncludeFrom)
{
	int diRecipTypes = fIncludeFrom ? 0 : 1;

	RRETURN(THR(AddNamesToAdrlist(&_padrlist)));
}

/*
 *	DisplayRecipients
 *	
 *	Purpose:
 *		Display recipient list in the wells
 *	
 *	Parameters:
 *		pal				pointer to list of recipients
 *      fIncludeFrom    include from well or not
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::DisplayRecipients(BOOL fIncludeFrom)
{
	HRESULT hr = S_OK;
	int i;
	int diRecipTypes = fIncludeFrom ? 0 : 1;
	HCURSOR hcursor;

	if (_padrlist)
	{
		hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

		for (i = (INT)_cRecipTypes - 1; i >= diRecipTypes; --i)
		{
			if(_rghwndEdit[i])
				SetWindowTextA(_rghwndEdit[i], "");
		}

		hr = THR(AddRecipientsToWells(_padrlist));

		SetCursor(hcursor);
	}

    RRETURN(hr);
}

/*
 *	AddRecipientsToWells
 *	
 *	Purpose:
 *		This function adds all the recipients in an ADRLIST
 *		to the recipient wells.
 *	
 *	Parameters:
 *		pal				pointer to list of recipients
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddRecipientsToWells(LPADRLIST pal)
{
	HRESULT     	hr = S_OK;
	ULONG			iae;
	ULONG			i;
	LPSPropValue	pval;

	Assert(pal);
	Assert(_cRecipTypes > 0);

	for (iae = 0; iae < pal->cEntries; iae++)
	{
		// Ignore empty ADRENTRY's

		if (!pal->aEntries[iae].rgPropVals)
			continue;

		pval = PvalFind((LPSRow) &pal->aEntries[iae], PR_RECIPIENT_TYPE);
		AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
		if (pval)
		{
			for (i = 0; i < _cRecipTypes; ++i)
			{
				if (_rgulRecipTypes[i] == pval->Value.ul)
				{
					hr = THR(AddRecipientToWell(_rghwndEdit[i],
						 			&pal->aEntries[iae], TRUE, TRUE));
					if (hr != S_OK)
					{
						goto Cleanup;
					}

					break;
				}
			}
		}
	}

Cleanup:
	RRETURN(hr);
}


/*
 *	AddRecipientToWell
 *	
 *	Purpose:
 *		This function adds a recipient to a recipient well.
 *	
 *	Parameters:
 *		hwndEdit		hwnd of the recipient well to add the
 *						recipient to
 *		pae				pointer to an ADRENTRY
 *		fAddSemi		whether to add a semicolon between entries
 *		fCopyEntry		whether to copy the ADRENTRY or just use it
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddRecipientToWell(HWND hwndEdit, LPADRENTRY pae,
									BOOL fAddSemi, BOOL fCopyEntry)
{
	HRESULT			hr = S_OK;
	LPSPropValue	pval;
	BOOL			fResolved	= FALSE;
	LPRICHEDITOLE	preole		= NULL;
	CTriple *		ptriple     = NULL;
	INT				cch;
	SRow			rwCopy;
	REOBJECT		reobj		= { 0 };

	// Check if this is a resolved or unresolved name

	pval = PvalFind((LPSRow) pae, PR_ENTRYID);
	if (pval && pval->Value.bin.cb != 0)
	{
		// Its a resolved name
		fResolved = TRUE;

		// Initialize the object information structure
		reobj.cbStruct = sizeof(REOBJECT);
		reobj.cp = REO_CP_SELECTION;
		reobj.clsid = CLSID_CTriple;
		reobj.dwFlags = REO_BELOWBASELINE | REO_INVERTEDSELECT |
						REO_DYNAMICSIZE | REO_DONTNEEDPALETTE;
		reobj.dvaspect = DVASPECT_CONTENT;

		Verify(SendMessage(hwndEdit, EM_GETOLEINTERFACE, 
								  	(WPARAM) NULL, (LPARAM) &preole));

		hr = THR(preole->GetClientSite(&reobj.polesite));
		if (hr != S_OK)
		{
			if (!fCopyEntry)
			{
				MAPIFreeBuffer(pae->rgPropVals);
				pae->rgPropVals = NULL;
			}
			goto MemoryError;
		}

		if (fCopyEntry)
		{
			hr = THR(CopyRow(NULL, (LPSRow) pae, &rwCopy));
			pae = (LPADRENTRY) &rwCopy;
			if (hr != S_OK)
				goto MemoryError;
		}

		ptriple = new CTriple(this, (LPSRow) pae);
		if (!ptriple)
		{
			MAPIFreeBuffer(pae->rgPropVals);
			pae->rgPropVals = NULL;
			goto MemoryError;
		}

		// from this point on, the triple owns the properties
		pae->rgPropVals = NULL;
	}

	if (fAddSemi && (cch = GetWindowTextLength(hwndEdit)) != 0)
	{
		SendMessageA(hwndEdit, EM_SETSEL, cch, cch);
		SendMessageA(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM)"; ");
	}

	if (!fResolved)
	{
		// Its an unresolved name

		pval = PvalFind((LPSRow) pae, PR_DISPLAY_NAME_A);
		AssertSz(pval, "Recipient must have a Display Name");
		SendMessageA(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM)pval->Value.lpszA);
	}
	else
	{
		// Its a resolved name

		hr = THR(ptriple->QueryInterface(IID_IOleObject, (void**)&reobj.poleobj));
		ptriple->Release();
		if (hr)
			goto MemoryError;

		if (reobj.poleobj->SetClientSite(reobj.polesite))
			goto MemoryError;

		// Report errors if Richedit fails
		hr = THR(preole->InsertObject(&reobj));
		if (FAILED(hr))
		{
			hr = g_LastError.SetLastError(E_FAIL);
			goto Error;
		}
	}

	goto Cleanup;

MemoryError:
	hr = g_LastError.SetLastError(E_OUTOFMEMORY);

Error:
	//TraceError("ScAddRecipientToWell", hr);

Cleanup:
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(reobj.polesite);
	ReleaseInterface(preole);

	RRETURN(hr);
}

/*
 *	SpecialAdrlistScan
 *	
 *	Purpose:
 *		This function scans through the ADRLIST beginning at *piae.
 *		When this function finds an empty ADRENTRY, it returns.
 *	
 *		When an ADRENTRY is found with a recipient type contained
 *		in rgulDestComps, the data (if any) is removed and we have our
 *		empty ADRENTRY.
 *	
 *		If no empty ADRENTRY is found, the function allocates a new
 *		ADRLIST with room for some more ADRENTRY's.
 *	
 *		If fAboutToAdd is false, this function continues through
 *		the entire ADRLIST, emptying the remaining ADRENTRY's.
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST
 *		piae			pointer to ADRENTRY index
 *		cREcipTypes		count of recipients types in rgulDestComps
 *		rgulDestComps	recipient types to mark for removal
 *		fAboutToAdd		TRUE if a recipient is about to be added.
 *						FALSE when we're just finishing off the
 *						scan.
 *	
 *	Returns:
 *		sc
 */
static HRESULT SpecialAdrlistScan(LPADRLIST * ppal, LONG * piae,
				ULONG cRecipTypes, ULONG * rgulDestComps, BOOL fAboutToAdd)
{
	HRESULT			hr		= S_OK;
	ULONG			i;
	LPSPropValue	pval;
	LPADRLIST		pal		= *ppal;
	LPADRENTRY		pae;

	if (pal)
	{
		while (++(*piae) < (LONG) pal->cEntries)
		{
			pae = &pal->aEntries[*piae];

			if (!pae->rgPropVals)
			{
				if (!fAboutToAdd)
					continue;

				// found an empty ADRENTRY and ready to add to it
				goto Cleanup;
			}

			pval = PvalFind((LPSRow) pae, PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval)
			{
				// Check to see if this ADRENTRY corresponds to one of our
				// recipient wells (by checking for a match in rgulDestComps.

				for (i = 0; i < cRecipTypes; ++i)
				{
					if (pval->Value.ul == rgulDestComps[i])
					{
						MAPIFreeBuffer(pae->rgPropVals);
						pae->rgPropVals = NULL;
						pae->cValues = 0;

						if (!fAboutToAdd)
							break;

						// created an empty ADRENTRY and ready to add to it
						goto Cleanup;
					}
				}
			}
		}
	}
	else
		*piae = 0;

	if (fAboutToAdd)
	{
		// We couldn't find (or create) an empty ADRENTRY so we'll
		// have to grow the ADRLIST (or create one) so we will
		// be able to add to pal->aEntries[*piae] on exit.

		//$ REVIEW - I'm adding 5 at a time. Sound reasonable?

		hr = THR(GrowAdrlist(ppal, 5));
	}

Cleanup:
	RRETURN(hr);
}

/*
 *	AddNamesToAdrlist
 *	
 *	Purpose:
 *		This function will add all the resolved and unresolved
 *		names from the edit controls to the ADRLIST
 *	
 *	Parameters:
 *		ppal			pointer to pointer to ADRLIST
 *		cRecipTypes		number of recipients types (which corresponds
 *						to the number of hwndEdit's and ulDestComps'
 *		rghwndEdit		hwnd's of the recipient wells
 *		rgulDestComps	recipient types for each recipient well
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::AddNamesToAdrlist(LPADRLIST * ppal)
{
	ULONG				i;
	ULONG				iOb;
	ULONG				cOb;
	LPSPropValue		pval;
	LONG				iae		= -1;
	LPRICHEDITOLE		preole	= NULL;
	REOBJECT			reobj	= { 0 };
	EDITSTREAMCOOKIE	esc;
	const EDITSTREAM	es		= {(DWORD) &esc, 0, UnresolvedStream};

	reobj.cbStruct = sizeof(REOBJECT);

	esc.hr = S_OK;
	esc.ppal = ppal;
	esc.piae = &iae;
	esc.fTruncated = FALSE;
	esc.nBrackets = 0;

	// I only want to operate on the dirty edit controls

	esc.cRecipTypes = 0;
	esc.rgulDestComps = new ULONG[_cRecipTypes];
	esc.rghwndEdit = new HWND[_cRecipTypes];
	if (!esc.rgulDestComps || !esc.rghwndEdit)
		goto MemoryError;

	for (i = 0; i < _cRecipTypes; ++i)
	{
		if (_rghwndEdit[i] && SendMessage(_rghwndEdit[i], EM_GETMODIFY, 0, 0))
		{
			esc.rgulDestComps[esc.cRecipTypes] = _rgulRecipTypes[i];
			esc.rghwndEdit[esc.cRecipTypes++] = _rghwndEdit[i];
		}
	}

	for (i = 0; i < esc.cRecipTypes; ++i)
	{
        _fRecipientsDirty = TRUE;

		esc.iRecipType = i;

		// Add all the resolved names (stored as OLE objects) from
		// esc.rghwndEdit[i] to the ADRLIST

		Verify(SendMessage(esc.rghwndEdit[i], EM_GETOLEINTERFACE, 
										(WPARAM) NULL, (LPARAM) &preole));

		cOb = preole->GetObjectCount();

		for (iOb = 0; iOb < cOb; iOb++)
		{
			LPPERSIST	ppersist = NULL;

			if (preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ) != S_OK)
				goto MemoryError;

			esc.hr = SpecialAdrlistScan(ppal, &iae, esc.cRecipTypes,
											esc.rgulDestComps, TRUE);
			if (esc.hr != S_OK)
				goto Cleanup;

			// ISSUE: chirsf - Giant hack to get the ADRENTRY !!!
            esc.hr = CopyRow(NULL, &((CTriple*)reobj.poleobj)->_rw,
									(LPSRow) &(*ppal)->aEntries[iae]);
			if (esc.hr != S_OK)
				goto Cleanup;
			
            pval = PvalFind((LPSRow) &(*ppal)->aEntries[iae], PR_RECIPIENT_TYPE);
			AssertSz(pval, "ADRENTRY with no PR_RECIPIENT_TYPE found");
			if (pval)
				pval->Value.l = esc.rgulDestComps[i];

			ClearInterface(&reobj.poleobj);
		}

		ClearInterface(&preole);

		// Add all the unresolved names to the ADRLIST

		esc.cchBuf = 0;

		SendMessage(esc.rghwndEdit[i], EM_STREAMOUT, SF_TEXT, (LPARAM) &es);
		if (esc.hr == S_OK)
		{
			// Add whatever is left after the last semicolon

			// I can ignore the return value since it is als , m, m,m, m                                                                                             o
			// stuffed in esc.sc

			AddUnresolvedName(&esc);
		}

        Edit_SetModify(esc.rghwndEdit[i], FALSE);
	}

	SpecialAdrlistScan(ppal, &iae, esc.cRecipTypes, esc.rgulDestComps, FALSE);

Cleanup:
	if (esc.fTruncated)
		MessageBeep(MB_OK);

	delete esc.rgulDestComps;
	delete esc.rghwndEdit;
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(preole);
	RRETURN(esc.hr);

MemoryError:
	esc.hr = g_LastError.SetLastError(E_OUTOFMEMORY);
	goto Cleanup;
}



/*
 *	UnresolvedStream
 *	
 *	Purpose:
 *		this is the callback function handed to the edit control
 *		for outputing a stream of text.
 *	
 *	Parameters:
 *		dwCookie		cookie which contains a pointer to a
 *						EDITSTREAMCOOKIE structure
 *		pbBuff			a bunch of characters
 *		cb				count of bytes in pbBuff
 *		pcb				exit: count of bytes read (regardless of error)
 *	
 *	Returns:
 *		hr
 */
DWORD FAR CALLBACK UnresolvedStream(DWORD dwCookie, LPBYTE pbBuff, LONG cb,
						LONG *pcb)
{
	HRESULT hr = S_OK;
	EDITSTREAMCOOKIE *	pesc = (EDITSTREAMCOOKIE *) dwCookie;

	*pcb = cb;

	//$ BUG - broken for Unicode

	// The algorithm below will strip spaces off of the
	// beginning and end of each name

	while (cb)
	{
		cb--;

		if (*pbBuff == '[')
			++pesc->nBrackets;
		else if (*pbBuff == ']')
			pesc->nBrackets = max(0, pesc->nBrackets - 1);
		else if (*pbBuff == '\t')
			*pbBuff = ' ';

		if (!pesc->nBrackets && (*pbBuff == ';' || *pbBuff == '\r'))
		{
			hr = THR(AddUnresolvedName(pesc));
			if (hr != S_OK)
				goto err;
		}
		else if ((*pbBuff != ' ' && *pbBuff != '\n' && *pbBuff != '\r')
					|| pesc->cchBuf > 0)
		{
			if (pesc->cchBuf < cchUnresolvedMax - 1)
			{
				pesc->rgch[pesc->cchBuf++] = *pbBuff;
			}
			else
			{
				// Truncation has occurred so I want to beep
				pesc->fTruncated = TRUE;
			}
		}
		++pbBuff;
	}

err:
	*pcb -= cb;

	return (DWORD) hr;
}

/*
 *	AddUnresolvedName
 *	
 *	Purpose:
 *		This function adds an entry to the ADRLIST in pesc as a
 *		entry with only a PR_DISPLAY_NAME_A
 *	
 *	Parameters:
 *		pesc		ponter to EDITSTREAMCOOKIE data
 *	
 *	Returns:
 *		hr
 */
static HRESULT AddUnresolvedName(EDITSTREAMCOOKIE * pesc)
{
	HRESULT		hr;
	ADRENTRY	ae;

 	while (pesc->cchBuf > 0 && (pesc->rgch[pesc->cchBuf - 1] == ' '
								|| pesc->rgch[pesc->cchBuf - 1] == '\t'))
 		--pesc->cchBuf;

	if (pesc->cchBuf)
	{
		pesc->rgch[pesc->cchBuf] = '\0';
		ae.cValues = 2;
		hr = MAPIAllocateBuffer(2 * sizeof(SPropValue)
					+ pesc->cchBuf + 1, (void**)&ae.rgPropVals);
		if (hr != S_OK)
			goto Error;

		ae.rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
		ae.rgPropVals[0].Value.lpszA = (LPSTR) &ae.rgPropVals[2];
		ae.rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
		ae.rgPropVals[1].Value.l = pesc->rgulDestComps[pesc->iRecipType];

		lstrcpyA(ae.rgPropVals[0].Value.lpszA, pesc->rgch);

		hr = SpecialAdrlistScan(pesc->ppal, pesc->piae,
					pesc->cRecipTypes, pesc->rgulDestComps, TRUE);
		if (hr != S_OK)
			goto Error;

		(*pesc->ppal)->aEntries[*pesc->piae] = ae;

		pesc->cchBuf = 0;
	}

	return S_OK;

Error:
	pesc->hr = hr;
	RRETURN(hr);
}


/*
 *	GrowAdrlist
 *	
 *	Purpose:
 *		This function will grow an existing ADRLIST or create a new
 *		one. caeToAdd empty ADRENTRY's is our goal.
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST (could be pointer to
 *						NULL)
 *		caeToAdd		count of ADRENTRY's to add
 *	
 *	Returns:
 *		sc
 */
static HRESULT GrowAdrlist(LPADRLIST * ppal, UINT caeToAdd)
{
	HRESULT         hr = S_OK;
	ULONG			i;
	UINT			cb;
	LPADRLIST		pal		= *ppal;
	LPADRENTRY		pae;

	cb = sizeof(ADRLIST) + caeToAdd * sizeof(ADRENTRY);
	if (pal)
		cb += (UINT) pal->cEntries * sizeof(ADRENTRY);

	hr = THR(MAPIAllocateBuffer(cb, (void**)&pal));
	if (hr)
	{
        hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	if (*ppal)
	{
		CopyMemory(pal, *ppal,
			sizeof(ADRLIST) + (UINT) (*ppal)->cEntries * sizeof(ADRENTRY));
		MAPIFreeBuffer(*ppal);
	}
	else
		pal->cEntries = 0;

	*ppal = pal;

	// Mark new ADRENTRY's as empty

	for (i = 0; i < caeToAdd; i++)
	{
		pae = &pal->aEntries[pal->cEntries++];

		pae->cValues = 0;
		pae->rgPropVals = NULL;
	}

Cleanup:
	RRETURN(hr);
}

/*
 *	AddRecipientToAdrlist
 *	
 *	Purpose:
 *		This functions add a recipient to a (possibly NULL) adrlist
 *	
 *	Parameters:
 *		ppal			pointer to LPADRLIST
 *		pae				pointer to ADRENTRY
 *		pulIndex		pointer where index of recipient in adrlist will be returned
 *						- can be null if caller not interested
 *	
 *	Returns:
 *		sc
 */
HRESULT AddRecipientToAdrlist(LPADRLIST * ppal, LPADRENTRY pae, ULONG *pulIndex)
{
	HRESULT	        hr = S_OK;
	ULONG			iae		= 0;
	LPADRLIST		pal		= *ppal;

	if (pal)
	{
		while (iae < pal->cEntries)
		{
			if (!pal->aEntries[iae++].rgPropVals)
			{
				pal->aEntries[iae - 1] = *pae;
				if (pulIndex)
					*pulIndex = iae - 1;
				return S_OK;
			}
		}
	}

	// We couldn't find an empty ADRENTRY so we'll
	// have to grow the ADRLIST (or create one)

	hr = THR(GrowAdrlist(ppal, 1));
	if (hr)
		goto Cleanup;

	(*ppal)->aEntries[(*ppal)->cEntries - 1] = *pae;
	if (pulIndex)
		*pulIndex = (*ppal)->cEntries - 1;

Cleanup:
	RRETURN(hr);
}

/*
 *	ScBuildSelectionAdrlist
 *	
 *	Purpose:
 *		This function will add all the resolved and unresolved
 *		names from the selection in an edit control to an ADRLIST
 *	
 *	Parameters:
 *		ppal			pointer to pointer to ADRLIST
 *		hwndEdit		hwnd of the edit control
 *		pchrg			CHARRANGE of the selection
 *	
 *	Returns:
 *		hr
 */
HRESULT CPadMessage::BuildSelectionAdrlist(LPADRLIST * ppal, HWND hwndEdit,
								CHARRANGE * pchrg)
{
	HRESULT	        hr          = S_OK;
	ULONG			iOb;
	ULONG			cOb;
	ADRENTRY		ae;
	ULONG			iae			= 0;
	LPRICHEDITOLE	preole		= NULL;
	REOBJECT		reobj		= { 0 };
	ULONG			cb;
	char			rgch[cchUnresolvedMax];
	LPBYTE			pbStart;
	LPBYTE			pbSel;
	ULONG			cchBuf		= 0;
	INT				nBrackets	= 0;
	BOOL			fTruncated	= FALSE;
	const ULONG		cchSel = pchrg->cpMax - pchrg->cpMin;
	TEXTRANGEA		txtrg;

	reobj.cbStruct = sizeof(REOBJECT);
	pbStart = pbSel = new BYTE[cchSel + 1];
	if (!pbSel)
		goto MemoryError;

    memset(pbSel, 0, cchSel + 1);

	// Add all the resolved names (stored as OLE objects) from
	// hwndEdit to the ADRLIST

	Verify(SendMessage(hwndEdit, EM_GETOLEINTERFACE, 
									(WPARAM) NULL, (LPARAM) &preole));

	cOb = preole->GetObjectCount();
	hr = THR(GrowAdrlist(ppal, (UINT) min(cOb, cchSel)));
	if (hr != S_OK)
		goto Cleanup;

	for (iOb = 0; iOb < cOb; iOb++)
	{
		hr = THR(preole->GetObject(iOb, &reobj,	REO_GETOBJ_POLEOBJ));
		if (hr != S_OK)
			goto MemoryError;

		if (reobj.cp >= pchrg->cpMax)
			break;

		if (reobj.cp >= pchrg->cpMin)
		{
			hr = THR(CopyRow(NULL, &((CTriple*)reobj.poleobj)->_rw,
									(LPSRow) &(*ppal)->aEntries[iae++]));
			if (hr != S_OK)
				goto Cleanup;
		}

		ClearInterface(&reobj.poleobj);
	}

	// Add all the unresolved names to the ADRLIST

	// Exchange 4369: Need to use the actual CHARRANGE passed in. Don't assume
	//				  the current selection is correct.
	txtrg.chrg = *pchrg;
	txtrg.lpstrText = (char*)pbSel;
	cb = SendMessageA(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM) &txtrg) + 1;

	//$ BUG - broken for Unicode

	// The algorithm below will strip spaces off of the
	// beginning and end of each name

	while (cb--)
	{
		if (*pbSel == '[')
			++nBrackets;
		else if (*pbSel == ']')
			nBrackets = max(0, nBrackets - 1);
		else if (*pbSel == '\t')
			*pbSel = ' ';

		if (*pbSel == '\0' ||
			(!nBrackets && (*pbSel == ';' || *pbSel == '\r')))
		{
 			while (cchBuf > 0 && (rgch[cchBuf - 1] == ' '
										|| rgch[cchBuf - 1] == '\t'))
 				--cchBuf;

			if (cchBuf)
			{
				rgch[cchBuf] = '\0';
				ae.cValues = 2;
				hr = THR(MAPIAllocateBuffer(2 * sizeof(SPropValue)
								+ cchBuf + 1, (void**)&ae.rgPropVals));
				if (hr != S_OK)
					goto MemoryError;

				ae.rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_A;
				ae.rgPropVals[0].Value.lpszA = (LPSTR) &ae.rgPropVals[2];
				ae.rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
				ae.rgPropVals[1].Value.l = -1;

				lstrcpyA(ae.rgPropVals[0].Value.lpszA, rgch);

				if (iae == (*ppal)->cEntries)
				{
					hr = THR(GrowAdrlist(ppal, 5));
					if (hr != S_OK)
						goto Cleanup;
				}

				(*ppal)->aEntries[iae++] = ae;

				cchBuf = 0;
			}
		}
		else if (((*pbSel != ' ' && *pbSel != '\n' && *pbSel != '\r')
					|| cchBuf > 0) && !fTruncated)
		{
			if (cchBuf < cchUnresolvedMax - 1)
				rgch[cchBuf++] = *pbSel;
			else
				fTruncated = TRUE;
		}
		++pbSel;
	}

Cleanup:
	if (fTruncated)
		MessageBeep(MB_OK);

	if (*ppal)
		(*ppal)->cEntries = iae;

	delete pbStart;
	ReleaseInterface(reobj.poleobj);
	ReleaseInterface(preole);
	RRETURN(hr);

MemoryError:
	hr = g_LastError.SetLastError(hr);
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -  Definitions for controlling GUID initialization               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#error initguid: must include objbase.h first.
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef _WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed


// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
// DECLARE_ORDINAL_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
// DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
// DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
// DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
// DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
// DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
// DECLARE_PROCNAME_MAP(utildll)
// DECLARE_PROCNAME_MAP(uxtheme)
// DECLARE_PROCNAME_MAP(version)
DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
//     DLDENTRYB(comctl32)
//     DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
//     DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
//     DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
//     DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
//     DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
//     DLDENTRYP(utildll)
//     DLDENTRYP(uxtheme)
//     DLDENTRYP(version)
    DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgdoc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgdoc.cxx
//
//  Contents:   CPadMessage implementation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

__declspec(thread)  static BOOL      s_fModalUp = FALSE;
__declspec(thread)  static BOOL      s_fMBoxUp = FALSE;
__declspec(thread)  static HWND      s_hwndUp = NULL;

// ISSUE: chrisf - should this really be thread local ?
__declspec(thread)  static HINSTANCE s_hInstRichEd32 = NULL;

// ISSUE: the following should be thread local when we use different threads
// for each mail message
static BOOL         s_fMapiInitialized = FALSE;
CLastError *        g_pLastError = NULL;

TCHAR g_achFormName[] = SZ_APPLICATION_NAME TEXT(" Exchange Form");
TCHAR g_achWindowCaption[] = TEXT("Microsoft Trident Form");
char  g_achFormClassName[] = "IPM.Note.Trident";
char  g_achPlainTextHeader[] = "[This is an HTML message written with "
                         "Microsoft Trident " VER_PRODUCTVERSION_STR ". You are "
                         "reading a plain text version of the original HTML.]";

static HRESULT
CreateMessage(IUnknown **ppUnk)
{
    HRESULT hr = S_OK;

    // ISSUE -
    // Currently, messages are created on the main thread only.  If messages are
    // created on multiple threads then s_fMapiInitialized must b moved to thread
    // local storage and mapi must be initialized for each thread.

    if (!s_fMapiInitialized)
    {
        hr = THR(MAPIInitialize(NULL));
        if (hr)
            RRETURN(hr);

        s_fMapiInitialized = TRUE;

        Assert(!g_pLastError);

        g_pLastError = new CLastError();
        if (!g_pLastError)
        {
            hr= E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = g_pLastError->Init(g_achFormName);
        if (hr)
            goto Cleanup;
    }

    Assert(g_pLastError);
    
    if(!s_hInstRichEd32)
    {
        s_hInstRichEd32 = LoadLibraryEx(TEXT("RICHED32.DLL"), NULL, 0);
    }

    *ppUnk = (IMAPIForm *)new CPadMessage();

    if (!*ppUnk)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

void RevokeMsgFact()
{
    if (s_fMapiInitialized)
        MAPIUninitialize();

    if (g_pLastError)
        delete g_pLastError;
}


CPadFactory Factory(CLSID_CPadMessage, CreateMessage, RevokeMsgFact);

BOOL CALLBACK FormDlgProcSend(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FormDlgProcRead(HWND, UINT, WPARAM, LPARAM);

SizedSPropTagArray(cPropReadMsg, tagaRead) = {cPropReadMsg, {MESSAGE_TAGS}};

CPadMessage::CPadMessage()
{
    // FormBase
    _state = stateUninit;
}

CPadMessage::~CPadMessage()
{

    //formBase Release ()

    MAPIFreeBuffer(_pval);

    FreePadrlist(_padrlist);

    MAPIFreeBuffer(_lpbConvIdx);

    if (_hChsFldDll)
        FreeLibrary(_hChsFldDll);

    MAPIFreeBuffer(_pbCFDState);
}   

HRESULT
CPadMessage::QueryInterface(REFIID iid, void **ppvObj)
{
    if (CPadDoc::QueryInterface(iid, ppvObj) == E_NOINTERFACE)
    {
        if (iid == IID_IMAPIForm)
        {
            *ppvObj = (LPVOID) (IMAPIForm *) this;
        }
        else if (iid == IID_IPersistMessage)
        {
            *ppvObj = (LPVOID) (IPersistMessage *) this;
        }
        else if (iid == IID_IMAPIFormAdviseSink)
        {
            *ppvObj = (LPVOID) (IMAPIFormAdviseSink *) this;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }

        ((IUnknown *)*ppvObj)->AddRef();
    }

    return S_OK;
}

void
CPadMessage::Passivate()
{

    //
    //  Release the view context
    //

    if (_pviewctx != NULL)
    {
        _pviewctx->SetAdviseSink(NULL);
        _pviewctx->Release();
        _pviewctx = NULL;
    }

    //
    //  Release message objects if we have them
    //

    if (s_fModalUp)
        _pviewctxOverride = NULL;

    ReleaseInterface(_pmsg);
    _pmsg = NULL;

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    ReleaseInterface(_pab);
    _pab = NULL;

    ReleaseInterface(_pses);
    _pses = NULL;

    //
    //  Tell all objects to be closed and de-initialized, only IUnknown
    //          calls are legal after this.
    //

    Assert(_pmsg == NULL);
    Assert(_pmsgsite == NULL);
    Assert(_pviewctx == NULL);
    Assert(_pviewctxOverride == NULL);
    Assert(_pab == NULL);
    Assert(_pses == NULL);

    _state = stateDead;

    //
    //  Now deinit paddoc
    //

    CPadDoc::Passivate();

}

///////////////////////////////////////////////////////////////////////////////
//
//  IMAPIForm interface
//
///////////////////////////////////////////////////////////////////////////////


////    IMAPIForm::SetViewContext
//
//

STDMETHODIMP CPadMessage::SetViewContext(IN IMAPIViewContext * pvc)
{

    //
    //  If we currently have a view context, then release it
    //

    if (_pviewctx != NULL)
    {
        _pviewctx->SetAdviseSink(NULL);
        _pviewctx->Release();
    }

    //
    // Accept the new view context.
    //

    _pviewctx = pvc;

    //
    //  If the new view context is non-null, then save it away, setup
    //  the advise sink back to check for things and get the current set
    //  of status flags
    //

    _ulViewStatus = 0;
    if (pvc != NULL)
    {
        _pviewctx->AddRef ();
        _pviewctx->SetAdviseSink (this);
        _pviewctx->GetViewStatus(&_ulViewStatus);
    }

    ConfigWinMenu();

    return S_OK;
}


////    IMAPIForm::GetViewContext
//

STDMETHODIMP CPadMessage::GetViewContext(OUT IMAPIViewContext * FAR * ppvc)
{
    Assert(ppvc);

    *ppvc = _pviewctx;

    if (_pviewctx != NULL)
    {
        _pviewctx->AddRef();
        return S_OK;
    }
    else
        return ResultFromScode(S_FALSE);
}


////    IMAPIForm::ShutdownForm
//
//  Description:
//      This routine is called to shut down the form and if necessary
//      to cause save changes to the form.
//

STDMETHODIMP CPadMessage::ShutdownForm(DWORD dwSaveOptions)
{
    HRESULT hr;

    //
    //  Check for valid state to make the call
    //

    switch( _state )
    {
        default:
        case stateDead:
            _viewnotify.OnShutdown ();
            return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));

        case stateUninit:
        case stateNormal:
        case stateNoScribble:
        case stateHandsOffFromSave:
        case stateHandsOffFromNormal:
            break;
    }

    hr = THR(QuerySave(dwSaveOptions));

    if (hr == S_FALSE)
        return MAPI_E_USER_CANCEL;

    // Notify viewer that we are going down
    _viewnotify.OnShutdown ();

    // Hide the document to remove the user's reference count.
    this->ShowWindow(SW_HIDE);

    RRETURN(hr);
}


////    IMAPIForm::DoVerb
//

STDMETHODIMP CPadMessage::DoVerb(LONG iVerb, LPMAPIVIEWCONTEXT pviewctx,
                               ULONG hwndParent, LPCRECT lprcPosRect)
{
    HRESULT             hr;

    //
    //  If a view context was passed in, then we need to get the
    //  status bits from this view context.  Also we are going to save
    //  the current view context and use this view context for the
    //  duration of the verb execution.
    //

    if (pviewctx != NULL)
    {
        _pviewctxOverride = pviewctx;
        pviewctx->GetViewStatus(&_ulViewStatus);
    }

    //
    //   Execute the requested verb.  If we do not understand the verb
    //  or we do not support the verb then we return NO SUPPORT and let
    //  the viewer deal with this.
    //

    switch (iVerb)
    {

    case EXCHIVERB_OPEN:
        hr = THR(OpenForm((HWND) hwndParent, lprcPosRect, _ulViewStatus));
        break;

    case EXCHIVERB_REPLYTOSENDER:
        hr = THR(Reply(eREPLY, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_REPLYTOALL:
        hr = THR(Reply(eREPLY_ALL, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_FORWARD:
        hr = THR(Reply(eFORWARD, (HWND) hwndParent, lprcPosRect));
        if (HR_SUCCEEDED(hr))
        {
            _pviewctxOverride = NULL;
            ShutdownForm(SAVEOPTS_NOSAVE);
        }
        break;

    case EXCHIVERB_PRINT:
    case EXCHIVERB_SAVEAS:
    case EXCHIVERB_REPLYTOFOLDER:
        //the viewer should not call us here
        //(see Value in extensions section of smpfrm.cfg)
        Assert(FALSE);

    default:
        hr = THR(g_LastError.SetLastError(ResultFromScode(MAPI_E_NO_SUPPORT)));
        break;
    }

    //
    //  If we moved to a different view context, then switch back to
    //  the one we started with.
    //

    _pviewctxOverride = NULL;

    if (_pviewctx != NULL)
    {
        _ulViewStatus =0;
        _pviewctx->GetViewStatus(&_ulViewStatus);
        ConfigWinMenu();
    }

    RRETURN(hr);
}


////    IMAPIForm::Advise
//

STDMETHODIMP CPadMessage::Advise (IN IMAPIViewAdviseSink * pViewAdvise,
                                OUT ULONG FAR * pulConnection)
{
    HRESULT     hr;

    hr = THR(_viewnotify.Advise (pViewAdvise, pulConnection));
    if (FAILED(hr))
    {
        hr = THR(g_LastError.SetLastError(hr));
    }
    RRETURN(hr);
}


////    IMAPIForm::Unadvise
//

STDMETHODIMP CPadMessage::Unadvise(ULONG ulConnection)
{
    HRESULT     hr;

    hr = THR(_viewnotify.Unadvise(ulConnection));
    if (FAILED(hr))
    {
        hr = THR(g_LastError.SetLastError(hr));
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////////////////////
//
//  IPersistMessage interface
//
///////////////////////////////////////////////////////////////////////////////

////    IPersistMessage::GetClassID

STDMETHODIMP CPadMessage::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CPadMessage;
    return S_OK;
}


////  IPersistMessage::GetLastError
//
//  Description:  This routine is used to get back a string giving more
//              information about the last error in the form.
//

STDMETHODIMP CPadMessage::GetLastError(HRESULT hr, ULONG ulFlags,
                                     LPMAPIERROR FAR * lppMAPIError)
{
    return g_LastError.GetLastError(hr, ulFlags, lppMAPIError);
}


////    IPersistMessage::IsDirty
//

STDMETHODIMP CPadMessage::IsDirty ()
{
    IPersistFile *pPF = NULL;

    if (_fDirty)
        return ResultFromScode(S_OK);

    _fDirty = GetDirtyState();

    return ResultFromScode ((_fDirty ? S_OK : S_FALSE));
}

BOOL
CPadMessage::GetDirtyState()
{
    BOOL fDirty = FALSE;

    fDirty = CPadDoc::GetDirtyState();

    if (_hwndDialog && _eFormType == eformSend)
    {
        fDirty = fDirty ||
                 _fRecipientsDirty ||
                 Edit_GetModify(GetDlgItem(_hwndDialog, ID_SUBJECT)) ||
                 AreWellsDirty();
    }

    return fDirty;
}

BOOL 
CPadMessage::AreWellsDirty()
{
    BOOL fDirty = FALSE;

    if (_hwndDialog && _eFormType == eformSend)
    {
        fDirty = Edit_GetModify(GetDlgItem(_hwndDialog, ID_TO)) ||
                 Edit_GetModify(GetDlgItem(_hwndDialog, ID_CC));
    }

    return fDirty;
}


////  IPersistMessage::InitNew
//
//  Description: This function is called in the case of composing a new
//      message.  There is a small set of properties which are set by
//      the constructor of the message, however in general it can be
//      assumed the message is clean.
//

STDMETHODIMP CPadMessage::InitNew(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg)
{
    HRESULT hr = S_OK;

    //
    //  Ensure we are in a state where we can accept this call
    //

    switch(_state)
    {
    case stateUninit:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    //
    //  If we currently have a message site, then release it as we
    //  will no longer be using it.
    //

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    //
    //  Save away the pointers to the message and message site
    //

    _pmsgsite = pmsgsite;
    pmsgsite->AddRef();

    _ulSiteStatus = 0;
    _pmsgsite->GetSiteStatus(&_ulSiteStatus);

    _pmsg = pmsg;
    pmsg->AddRef();

    //
    //  Make an assumption on the message flags and status
    //

    _ulMsgStatus = 0;
    _ulMsgFlags = MSGFLAG_UNSENT;

    if (_hwnd)
    {
        hr = THR(DisplayMessage());
        if (hr)
            goto Cleanup;
    }

    //
    //  We succeeded in doing the InitNew so move to the normal state
    //

    _state = stateNormal;

    //
    //  Tell everybody who cares that we just loaded a new message
    //

    _viewnotify.OnNewMessage();

    _fNewMessage = TRUE;

Cleanup:
    RRETURN(hr);
}

//// IPersistMessage::Load
//
//  Description:  This routine is called as part of loading an existing
//      message into the form.
//

STDMETHODIMP CPadMessage::Load(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg,
                             ULONG ulMsgStatus, ULONG ulMsgFlags)
{
    HRESULT hr = S_OK;

    //
    //  Ensure we are in a state where we can accept this call
    //

    switch(_state)
    {
    case stateUninit:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    //
    //  If we currently have a message site, then release it as we
    //  will no longer be using it.
    //

    ReleaseInterface(_pmsgsite);
    _pmsgsite = NULL;

    ReleaseInterface(_pmsg);
    _pmsg = NULL;


    hr = THR(GetMsgDataFromMsg(pmsg, ulMsgFlags));
    if (FAILED(hr))
        goto err;

    //
    //  Save away the message and message site which are passed in.
    //

    _pmsg = pmsg;
    pmsg->AddRef();

    _pmsgsite = pmsgsite;
    pmsgsite->AddRef();

    //
    //  Get the site status flags for disabling buttons & menus
    //
    _ulSiteStatus = 0;
    _pmsgsite->GetSiteStatus(&_ulSiteStatus);

    //
    //  Save away these properties
    //

    _ulMsgStatus = ulMsgStatus;
    _ulMsgFlags = ulMsgFlags;

    //
    //  Put us into the normal state
    //

    _state = stateNormal;


    //
    //  if our form is up, display the message
    //
    if (_hwnd)
    {
        hr = THR(DisplayMessage());
        if (hr)
            goto err;
    }

    //
    //  Tell everybody who cares that we just loaded a new message
    //

    _viewnotify.OnNewMessage();

    _fNewMessage = FALSE;

err:
    RRETURN(hr);
}

////    IPersistMessage::Save
//
//  Description:
//      This function will be called whenever a save operation of the
//      information into the form should be done.  We should only make
//      modifications to the message in this function.
//

STDMETHODIMP CPadMessage::Save(IN LPMESSAGE pmsg, IN ULONG fSameAsLoad)
{
    HRESULT             hr;

    //
    //  Check that we are in a state where we are willing to accept
    //  this call.  Must have a message.
    //

    switch( _state )
    {
    default:
        Assert(FALSE);
    case stateDead:
    case stateUninit:
    case stateNoScribble:
    case stateHandsOffFromSave:
    case stateHandsOffFromNormal:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));

    case stateNormal:
        break;
    }

    if (fSameAsLoad)
    {
        //
        //  Its the same message interface as was loaded into us.  We can
        //      assume that the pmsg passed in is either NULL or an interface
        //      on the same object as the message we already have loaded
        //

        hr = THR(SaveInto(_pmsg));
    }
    else
    {
        //
        //  We need to copy everything into the new message as we are going
        //      to clone ourselves into it.
        //

        hr = THR(_pmsg->CopyTo(0, NULL, NULL, 0, NULL, &IID_IMessage, pmsg, 0, NULL));
        if (FAILED(hr))
        {
            g_LastError.SetLastError(hr, _pmsg);
            RRETURN(hr);
        }

        //
        //  Now make all of the incremental changes
        //

        hr = THR(SaveInto(pmsg));
    }

    if (hr)
        goto Cleanup;

    _state = stateNoScribble;
    _fSameAsLoaded = fSameAsLoad;
    _fNewMessage = FALSE;

Cleanup:
    RRETURN(hr);
}


////    IPersistMessage::SaveCompleted
//
//


STDMETHODIMP CPadMessage::SaveCompleted(IN LPMESSAGE pmsg)
{

    switch( _state )
    {
    case stateHandsOffFromNormal:
    case stateHandsOffFromSave:
    case stateNoScribble:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    if ((stateHandsOffFromNormal == _state ||
        stateHandsOffFromSave == _state)  && NULL == pmsg)
    {
        //DebugTrace("smpfrm: SaveCompleted called in handsOff state with pmsg==NULL\r\n");
        return  g_LastError.SetLastError(ResultFromScode(E_INVALIDARG));
    }

    ULONG ulOldState = _state;
    _state = stateNormal;

    //state == NoScribble , pmsg == NULL
    if (NULL == pmsg)
    {
        if (_fSameAsLoaded)
        {
            ClearDirty();
            _viewnotify.OnSaved();
        }

        return S_OK;
    }


    //state == handsOffFromNormal, pmsg != NULL
    if (stateHandsOffFromNormal == ulOldState)
    {
        ReleaseInterface(_pmsg);
        _pmsg = pmsg;
        pmsg->AddRef();

        return S_OK;
    }

    //state == handsOffFromSave || NoScribble, pmsg != NULL
    if (stateNoScribble == ulOldState ||
        stateHandsOffFromSave == ulOldState)
    {
        ReleaseInterface(_pmsg);
        _pmsg = pmsg;
        pmsg->AddRef();
    }

    _viewnotify.OnSaved();
    ClearDirty();

   return S_OK;
}


////  IPersistMessage::HandsOffMessage
//
//  Description: store, folder and message objects has to be released
//              in this method.
//
//

STDMETHODIMP CPadMessage::HandsOffMessage ()
{

    switch( _state )
    {
    case stateNormal:
    case stateNoScribble:
        break;

    default:
        return g_LastError.SetLastError(ResultFromScode(E_UNEXPECTED));
    }

    if (stateNormal == _state)
        _state = stateHandsOffFromNormal;
    else
        _state = stateHandsOffFromSave;

    //
    //  We must have a message
    //

    Assert(_pmsg != NULL);
    _pmsg->Release();
    _pmsg = NULL;


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
//  IMAPIFormAdviseSink interfaces
//
///////////////////////////////////////////////////////////////////////////////



////    IMAPIFormAdviseSink::OnChange
//
//  Description: called to notify about changes in viewctx status

STDMETHODIMP CPadMessage::OnChange(ULONG ulflag)
{
    if (_pviewctxOverride == NULL)
    {
        _ulViewStatus = ulflag;
        ConfigWinMenu();
    }

    return S_OK;
}

////    CPadMessage::OnActivateNext
//
//  Description:  We only say that we will handle the next message if
//              it is the exact same message class as the current message.
//              If the next message has the same "unsentness" will reuse the
//              current object, otherwise ask our ClassFactory for a new one.
//

STDMETHODIMP CPadMessage::OnActivateNext(LPCSTR lpszMessageClass, ULONG ulMessageStatus,
                                        ULONG ulMessageFlags,
                                       LPPERSISTMESSAGE FAR * ppPersistMessage)
{
    HRESULT hr;
    //TCHAR pwchMessageClass[128];

    *ppPersistMessage = NULL;

    Assert(_pval);

    //MultiByteToWideChar(CP_ACP, 0, lpszMessageClass, -1, pwchMessageClass, sizeof(pwchMessageClass));

    if (PR_MESSAGE_CLASS_A == _pval[irtClass].ulPropTag)
    {
        //the message class comparison has to be case insensitive
        if ((lstrcmpiA(_pval[irtClass].Value.lpszA, lpszMessageClass) != 0) &&
            lstrcmpiA(g_achFormClassName, lpszMessageClass) != 0)
        {
            return ResultFromScode(S_FALSE);
        }
    }
    else
    {
        if (lstrcmpiA(g_achFormClassName, lpszMessageClass) != 0)
        {
            return ResultFromScode(S_FALSE);
        }
    }


    if ((_ulMsgFlags & MSGFLAG_UNSENT) == (ulMessageFlags & MSGFLAG_UNSENT))
        //tell the viewer to reuse our object
        return ResultFromScode(S_OK);


    //Get a new object from our class factory
    hr = THR(Factory.CreateInstance(NULL, IID_IPersistMessage, (LPVOID FAR *)ppPersistMessage));
    if (hr)
        return ResultFromScode (S_FALSE);
    else
        return ResultFromScode(S_OK);
}


///////////////////////////////////////////////////////////////////////////////
//
//  Non-IMAPIinterface functions
//
///////////////////////////////////////////////////////////////////////////////


///     CPadMessage::GetMsgDataFromMsg
//
//      fills in _pval (for unsent msgs only)
//      with the info from pmsg
HRESULT CPadMessage::GetMsgDataFromMsg(LPMESSAGE pmsg, ULONG ulMsgFlags)
{
    Assert(pmsg);

    ULONG   cValues = 0;
    MAPIFreeBuffer(_pval);
    _pval = NULL;

    MAPIFreeBuffer(_lpbConvIdx);
    _lpbConvIdx = NULL;

    // Get properties from message

    HRESULT hr = THR(pmsg->GetProps((LPSPropTagArray) &tagaRead, 0,
                                    &cValues, &_pval));
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    Assert(cValues ==  cPropReadMsg);

    // Ignore errors on individual properties

    if (hr == MAPI_W_ERRORS_RETURNED)
    {
        hr = S_OK;
    }

    // Cache conversation index

    if (PR_CONVERSATION_INDEX == _pval[irtConvIdx].ulPropTag)
    {
        LPSPropValue pval = &_pval[irtConvIdx];

        _cbConvIdx = pval->Value.bin.cb;
        if (MAPIAllocateBuffer(_cbConvIdx, (LPVOID *)&_lpbConvIdx))
        {
            _lpbConvIdx = NULL;
            _cbConvIdx = 0;
        }
        else
        {
            CopyMemory(_lpbConvIdx, pval->Value.bin.lpb, _cbConvIdx);
        }
    }
    else
    {
        _lpbConvIdx = NULL;
        _cbConvIdx = 0;
    }

    _fConvTopicSet = (PR_CONVERSATION_TOPIC_A == _pval[irtConvTopic].ulPropTag);

    // If message yet unsent, cache recipient list so that user
    // can add or remove recipients

    if (ulMsgFlags & MSGFLAG_UNSENT)
    {
        hr = THR(GetMsgAdrlist(pmsg, (LPSRowSet *)&_padrlist, &g_LastError));
        if (FAILED(hr))
        {
            goto err;
        }
    }

    RRETURN(hr);

err:
    MAPIFreeBuffer(_pval);
    _pval = NULL;

    FreePadrlist(_padrlist);
    _padrlist = NULL;

    RRETURN(hr);
}

///         CPadMessage::ClearDirty
//
//      Clears dirty state
void CPadMessage::ClearDirty(void)
{
    _fDirty = FALSE;
    _fRecipientsDirty = FALSE;

    if (_eFormType == eformSend)
    {
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_SUBJECT), FALSE);
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_TO), FALSE);
        Edit_SetModify(GetDlgItem(_hwndDialog, ID_CC), FALSE);
    }
}


HRESULT CPadMessage::OpenAddrBook()
{
    HRESULT hr = S_OK;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            goto Cleanup;
        }
    }
    
    Assert(_pses != NULL);

    if (_pab == NULL)
    {
        hr = THR(_pses->OpenAddressBook((ULONG) _hwnd, NULL, 0, &_pab));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pses);
            if (FAILED(hr)) //if it's a real error (not a warning)
                goto Cleanup; 
        }
    }
    
    Assert(_pab != NULL);

Cleanup:
    RRETURN1(hr, MAPI_W_ERRORS_RETURNED);
}

////    CPadMessage::Address
//
//  Description:
//      This function is used to address the form.
//      The parameter determines which button in the address
//      dialog has the focus.
//

void CPadMessage::Address(int id)
{
    Assert( ID_TO_BUTTON == id || ID_CC_BUTTON == id);

    HRESULT hr;

    hr = THR(OpenAddrBook());
    if (hr)
    {
        ShowError();
        if (FAILED(hr))
            return;
    }

    // ISSUE: chrisf - total hack below casting char[] to LPSTR
    // Mapi seems to work only with Ansi though the header files
    // contain UNICODE declarations on UNICODE platform !!!
    ADRPARM adrparm = { 0, NULL, AB_RESOLVE | DIALOG_MODAL, NULL, 0L,
                        NULL, NULL, NULL, NULL, (LPTSTR)"Address Book", NULL,
                        (LPTSTR)"Send Note To", 2, (id == ID_TO_BUTTON ? 0:1),
                        NULL, NULL, NULL, NULL };

    ULONG   ulHwndAddr = (ULONG) _hwnd;

    hr = THR(_pab->Address(&ulHwndAddr, &adrparm, &_padrlist));
    if (!hr)
    {
        DisplayRecipients(TRUE);
    }
    else if (hr != MAPI_E_USER_CANCEL)
    {
        g_LastError.SetLastError(hr, _pab);
        ShowError();
    }

}

////  CPadMessage::OpenForm
//
//  Description:  This is the internal routine which is called from the
//      open/display verb.  It will cause UI to appear if there is none
//      and force the window to the foreground if there is already UI.
//

HRESULT CPadMessage::OpenForm(HWND hwndParent, LPCRECT lprcPosRect,
                              ULONG ulViewFlags)
{
    HRESULT hr = S_OK;

    if (lprcPosRect == NULL)
        return g_LastError.SetLastError(ResultFromScode(E_INVALIDARG));

    //
    //  If any modal forms are visible then do not do anything
    //

    Assert( s_fModalUp && s_hwndUp || !s_fModalUp && !s_hwndUp);
    if (s_fMBoxUp || (s_fModalUp && hwndParent != s_hwndUp))
        return g_LastError.SetLastError(
                               ResultFromScode(OLEOBJ_S_CANNOT_DOVERB_NOW));

   if (!(ulViewFlags & VCSTATUS_MODAL))
    {
        //  If we are not modal then don't do anything relative to the parent
        hwndParent = NULL;
    }

    //
    //  Check to see if we have a window up
    //

    if (_hwnd != 0)
    {
        ::MoveWindow(_hwnd, lprcPosRect->left, lprcPosRect->top,
                   lprcPosRect->right - lprcPosRect->left,
                   lprcPosRect->bottom - lprcPosRect->top,
                   TRUE);
    }
    else
    {

        hr = THR(RegisterPadWndClass());
        if (hr)
            return g_LastError.SetLastError(ResultFromScode(hr));

        _hwnd = CreateWindowEx(0,
                              SZ_PAD_WNDCLASS,
                              g_achWindowCaption,
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              lprcPosRect->left,
                              lprcPosRect->top,
                              lprcPosRect->right - lprcPosRect->left,
                              lprcPosRect->bottom - lprcPosRect->top,
                              hwndParent,
                              NULL,
                              g_hInstCore,
                              this);

        if (_hwnd == NULL)
        {
            return g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
        }

        //
        //  Create the dialog as a child of this window
        //

        if (_ulMsgFlags & MSGFLAG_UNSENT)
        {
            _eFormType = eformSend;
            _hwndDialog = CreateDialog(g_hInstCore, MAKEINTRESOURCE(IDR_SEND_FORM),
                                        _hwnd, &FormDlgProcSend);
            _HAccelTable = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_SEND_FORM));

            _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_SEND_FORM));

            _fUserMode = FALSE;
        }
        else
        {
            _eFormType = eformRead;

            InitReadToolbar();

            _hwndDialog = CreateDialog(g_hInstCore, MAKEINTRESOURCE(IDR_READ_FORM),
                                        _hwnd, &FormDlgProcRead);
            _HAccelTable = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_READ_FORM));

            _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_READ_FORM));

            _fUserMode = TRUE;
        }

        SetMenu(_hwnd, _hmenuMain);
    }

    //
    //  Stuff message into form
    //

    hr = THR(DisplayMessage());
    if (hr)
        goto Cleanup;

    //
    //  Position the window where it is supposed to be
    //

    this->ShowWindow(SW_SHOW);

    SetForegroundWindow(_hwnd);

    //
    //  If we are modal, then we loop until the form is closed
    //

    if (ulViewFlags & VCSTATUS_MODAL)
    {
        MSG         msg;

        BOOL fOldModalUp = s_fModalUp;
        HWND hwndOldUp = s_hwndUp;

        s_fModalUp = TRUE;
        s_hwndUp = _hwnd;

        while ((_hwnd != NULL) && (GetMessage(&msg, _hwnd, 0, 0)))
        {
            //first call our method and see if this message makes sense to us.
            //if not, let WIN API care about it.
            if (!_DocHost.TranslateAccelerator(&msg, &CGID_MSHTML, IDM_UNKNOWN))
            {
                ::TranslateMessage(&msg);
                ::DispatchMessage(&msg);
            }
        }

        s_fModalUp = fOldModalUp;
        s_hwndUp = hwndOldUp;
    }

Cleanup:
    RRETURN(hr);
}

////    CPadMessage::SaveInto
//
//  Description:
//    This routine gives one central location which save all modified
//      properties into a message.
//

HRESULT CPadMessage::SaveInto(LPMESSAGE pmsg)
{
    HRESULT             hr;
    ULONG               cval = 0;
    LONG                cb;
    LPSPropProblemArray pProblems = NULL;

    Assert(_eFormType == eformSend);

    if (_eFormType == eformRead)
        return S_OK;
    
    // Call IsDirty() to make sure  _fDirty is current

    if (!_fDirty)
        IsDirty();
    
    // If not dirty and we already have a cache, return

    if (!_fDirty && _pval != NULL) 
        return S_OK;

    // If wells have been touched, regenerate recipient list
    // but do not resolve names (user may save a message without 
    // resolving the names)

    if (AreWellsDirty())
    {
        hr = THR(ParseRecipients(TRUE));
        if (hr)
            goto Cleanup;                
    }

    //  Write out the recipient table to the message

    if (_padrlist && _fRecipientsDirty)
    {
        hr = THR(pmsg->ModifyRecipients(0, _padrlist));
        if (hr)
        {
            g_LastError.SetLastError(hr, pmsg);
            goto Cleanup;
        }
    }

    // Create new cache

    if (NULL != _pval)
    {
        MAPIFreeBuffer(_pval);
        _pval = NULL;
    }
    
    if (MAPIAllocateBuffer(sizeof(SPropValue) * cPropSendMsg, (LPVOID FAR *) &_pval))
    {
        hr = g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
        goto Cleanup;
    }
        
    ZeroMemory(_pval, sizeof(SPropValue) * cPropSendMsg);
        
    _pval[irtTime].ulPropTag = PR_NULL;
    _pval[irtSenderName].ulPropTag = PR_NULL;                     
    _pval[irtNormSubject].ulPropTag = PR_NULL;
    _pval[irtTo].ulPropTag = PR_NULL;
    _pval[irtCc].ulPropTag = PR_NULL;

    // Get subject into the cache

    cb = GetWindowTextLength(GetDlgItem(_hwndDialog, ID_SUBJECT));
    if (cb > 0)
    {
        if (MAPIAllocateBuffer(cb+1, (LPVOID FAR *)&_pval[irtSubject].Value.lpszA))
        {
            hr = g_LastError.SetLastError(ResultFromScode(E_OUTOFMEMORY));
            goto Cleanup;
        }

        GetWindowTextA(GetDlgItem(_hwndDialog, ID_SUBJECT), _pval[irtSubject].Value.lpszA, cb+1);
        _pval[irtSubject].ulPropTag = PR_SUBJECT_A;
    }
    else
    { //no subject

        _pval[irtSubject].ulPropTag = PR_NULL;
    }

    // Set form class

    _pval[irtClass].ulPropTag = PR_MESSAGE_CLASS_A;
    _pval[irtClass].Value.lpszA = g_achFormClassName;

    // If the message didn't have PR_CONVERSATION_TOPIC when we loaded it, we'll
    // set it every time we save the message. Otherwise we don't touch it

    if (!_fConvTopicSet)
    {
        _pval[irtConvTopic].ulPropTag = PR_CONVERSATION_TOPIC_A;
        if (PR_SUBJECT_A == _pval[irtSubject].ulPropTag)
        {
            _pval[irtConvTopic].Value.lpszA = _pval[irtSubject].Value.lpszA;
        }
        else
        {
            _pval[irtConvTopic].Value.lpszA = "";
        }
    }
    else
    {
        _pval[irtConvTopic].ulPropTag = PR_NULL;
    }

    // If the message doesn't have a PR_CONVERSATION_INDEX, create and set it

    if (_cbConvIdx == 0)
    {
        if (!ScAddConversationIndex(0, NULL, &_cbConvIdx,   &_lpbConvIdx))
        {
            _pval[irtConvIdx].ulPropTag = PR_CONVERSATION_INDEX;
            _pval[irtConvIdx].Value.bin.lpb = _lpbConvIdx;
            _pval[irtConvIdx].Value.bin.cb = _cbConvIdx;
        }
        else
        {
            _pval[irtConvIdx].ulPropTag = PR_NULL;
        }
    }
    else
    {
        _pval[irtConvIdx].ulPropTag = PR_NULL;
    }

    // For an unsent form, set the delivery time so that it shows up
    // at the right place in the folder

        if (_ulMsgFlags & MSGFLAG_UNSENT)
        {
                SYSTEMTIME                      st;

                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &_pval[irtTime].Value.ft);
                _pval[irtTime].ulPropTag = PR_MESSAGE_DELIVERY_TIME;
    }

    // Now set the message properties

    hr = THR(pmsg->SetProps(cPropSendMsg, _pval, &pProblems));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

    Assert(!pProblems);

    // Stream the down level body (plain text or RTF) 
    // out of trident into the message

    hr = THR(StreamOutTextBody(pmsg));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

    // Stream the HTML body out of Trident into the message

    hr = THR(StreamOutHtmlBody(pmsg));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

BOOL CPadMessage::OnTranslateAccelerator(MSG * pMsg)
{
    //
    // Check for TAB between subject and body
    //

    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB)
    {
        if (GetKeyState(VK_SHIFT) & 0x80000000)
        {
            if (_pInPlaceActiveObject)
            {
               UIDeactivateDoc();
               SetFocus(GetDlgItem(_hwndDialog, ID_SUBJECT));
               return TRUE;
            }
        }
        else
        {
            if (GetFocus() == GetDlgItem(_hwndDialog, ID_SUBJECT))
            {
                UIActivateDoc(pMsg);
                return TRUE;
            }
        }
    }

    //
    //  We translate accelerators before the dialog message so that we
    //  can get our accelerators to override the dialog's.
    //

    if (::TranslateAccelerator(_hwnd, _HAccelTable, pMsg))
        return TRUE;

    //
    // Now let Trident process accelerators
    //

    if(CPadDoc::OnTranslateAccelerator(pMsg))
        return TRUE;

    //
    // Finally process dialog accelerators
    //

    if ((_hwndDialog != NULL) && ::IsDialogMessage(_hwndDialog, pMsg))
        return TRUE;

    return FALSE;
}


///  CPadMessage::DisplayMessage
//
//  display the info from _pval in the dialog
HRESULT CPadMessage::DisplayMessage(void)
{
    HRESULT  hr = S_OK;
    TCHAR    awch[256];
    char     ach[256];

    Assert(_hwnd);
    Assert(_hwndDialog);

    if (NULL != _pval)
    {
        if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
        {
            SetDlgItemTextA(_hwndDialog, ID_SUBJECT, _pval[irtSubject].Value.lpszA);
            MultiByteToWideChar(CP_ACP, 0, _pval[irtSubject].Value.lpszA, -1,
                                awch, sizeof(awch));
            lstrcat(awch, TEXT(" - "));
            lstrcat(awch, g_achWindowCaption);
            SetWindowText(_hwnd, awch);
        }
        else
        {
            SetWindowText(_hwnd, g_achWindowCaption);
        }

        if (_eFormType == eformRead)
        {
            if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
            SetDlgItemTextA(_hwndDialog, ID_FROM, _pval[irtSenderName].Value.lpszA);

            if (_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME) {
                FormatTime(&_pval[irtTime].Value.ft, ach, sizeof(ach));
                SetDlgItemTextA(_hwndDialog, ID_SENT, ach);
            }

            if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
                SetDlgItemTextA(_hwndDialog, ID_TO, _pval[irtTo].Value.lpszA);

            if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
                SetDlgItemTextA(_hwndDialog, ID_CC, _pval[irtCc].Value.lpszA);
        }
        else if (_eFormType == eformSend)
        {
            DisplayRecipients(TRUE);
        }
        else
        {
            Assert(FALSE);
        }

        ClearDirty();
    }

    if (_pval && _pval[irtHtmlBody].ulPropTag == PR_HTML_BODY)
    {
        hr = THR(StreamInHtmlBody(_pval[irtHtmlBody].Value.lpszA));
        if (hr)
            goto err;   
    }    
    else
    {
        hr = THR(StreamInHtmlBody(_pmsg));
        if (hr)
            goto err;
    }

err:
    RRETURN(hr);
}


/// CPadMessage::IsAddressed
//
// Does _padrlist contain a recipient?
BOOL CPadMessage::IsAddressed(void)
{
    Assert(_eFormType == eformSend) ;

    if (NULL == _padrlist || _padrlist->cEntries == 0)
        return FALSE;

    for(LPADRENTRY pae = _padrlist->aEntries;
        pae < _padrlist->aEntries + _padrlist->cEntries; ++pae)
    {
        if (pae->rgPropVals)
            return TRUE;
    }

    return FALSE;
}

///     CPadMessage::ConfigMenu
//Enable/disable menu commands based on the values of _ulSiteStatus
// and _ulViewStatus
void CPadMessage::ConfigMenu(HMENU hMenu)
{
    if (_eFormType == eformRead)
    {
        EnableMenuItem(hMenu, IDM_MESSAGE_SAVE,
            MF_BYCOMMAND|((_ulSiteStatus & VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_DELETE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_COPY,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_MOVE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_VIEW_ITEMABOVE,
            MF_BYCOMMAND|(_ulViewStatus & VCSTATUS_PREV ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_VIEW_ITEMBELOW,
            MF_BYCOMMAND|(_ulViewStatus & VCSTATUS_NEXT ? MF_ENABLED:MF_GRAYED));
    }

    else
    {
        EnableMenuItem(hMenu, IDM_MESSAGE_SUBMIT,
            MF_BYCOMMAND|((_ulSiteStatus &VCSTATUS_SUBMIT) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_SAVE,
            MF_BYCOMMAND|((_ulSiteStatus & VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_DELETE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_COPY,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED));
        EnableMenuItem(hMenu, IDM_MESSAGE_MOVE,
            MF_BYCOMMAND| (!(_ulViewStatus & VCSTATUS_READONLY) &&
                            (_ulSiteStatus & VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED));

    }
}

HRESULT
CPadMessage::DoSave(BOOL fPrompt)
{
    HRESULT hr;

    if (fPrompt)
        return CPadDoc::DoSave(TRUE);

    hr = THR(_pmsgsite->SaveMessage());
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }

    RRETURN(hr);
}

///  CPadMessage::DoDelete
//
//  called only from our UI
void CPadMessage::DoDelete(void)
{
    HRESULT hr;
    RECT rect;

    GetWindowRect(_hwnd, &rect);

    hr = THR(_pmsgsite->DeleteMessage(_pviewctx, &rect));
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }
    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
}

///  CPadMessage::DoSubmit
//
//  called only from our UI
void CPadMessage::DoSubmit(void)
{
    HRESULT hr;

    // Get and check recipients from the UI

    hr = THR_NOTRACE(GetAndCheckRecipients(FALSE));
    
    if (hr == MAPI_E_USER_CANCEL)
        return;
    
    if (hr)
        goto Cleanup;

    // GeAndCheckRecipients is supposed to ensure that the addrlist
    // is in sync with the wells
    Assert (!AreWellsDirty());

    // Verify we have at least a recipient

    if (!IsAddressed())
    {
        ShowMessageBox(_hwndDialog, TEXT("No recipients"), g_achFormName, MB_OK);
        return;
    }

    hr = THR(_pmsgsite->SubmitMessage(0));

Cleanup:
    if (FAILED(hr))
    {
        Assert(hr != MAPI_E_USER_CANCEL);
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
    }
    else
    {
        _viewnotify.OnSubmitted();
    }
    if (_pmsg == NULL)
        ShutdownForm(SAVEOPTS_NOSAVE);
}

///  CPadMessage::DoNext
//
//  called only from our UI
void CPadMessage::DoNext(ULONG ulDir)
{
    Assert(VCDIR_NEXT == ulDir || VCDIR_PREV == ulDir);

    HRESULT hr;

    hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
    if (hr)
    {
        if (hr != S_FALSE)
            ShowError();
        return;
    }

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    hr = THR(ViewCtx()->ActivateNext(ulDir, &rect));
    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
}

///  CPadMessage::DoReply
//
//  called only from our UI
void CPadMessage::DoReply(eREPLYTYPE eType)
{
    HRESULT hr;

    hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
    if (hr)
    {
        if (hr != S_FALSE)
            ShowError();
        return;
    }

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    int iOffset = GetSystemMetrics(SM_CYCAPTION);
    OffsetRect(&rect, iOffset, iOffset);

    hr = THR(Reply(eType, _hwnd, &rect));
    if (!hr)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }
    else
    {
        ShowError();
    }
}

///  CPadMessage::DoCopy
//
//  called only from our UI
void CPadMessage::DoCopy(void)
{
    HRESULT         hr;
    LPMAPIFOLDER    pfld = NULL;
    LPMDB           pmdb = NULL;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            ShowError();
            return;
        }
    }

    BOOL fOldModalUp = s_fModalUp;

    s_fModalUp = TRUE;

    hr = THR(HrPickFolder(g_hInstCore, _hwnd, _pses, &pfld, &pmdb,
                                &_cbCFDState, &_pbCFDState));


    s_fModalUp = fOldModalUp;

    if (hr)
    {
        if (hr != MAPI_E_USER_CANCEL)
            ShowMessageBox(_hwnd, TEXT("Can't copy"), g_achFormName, MB_OK | MB_ICONSTOP);

        return;
    }

    Assert(_pmsgsite);
    Assert(pfld);
    Assert(pmdb);

    hr = THR(_pmsgsite->CopyMessage(pfld));
    pfld->Release();
    pmdb->Release();
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
        return;
    }

}


///  CPadMessage::DoMove
//
//  called only from our UI
void CPadMessage::DoMove(void)
{
    HRESULT         hr;
    LPMAPIFOLDER    pfld = NULL;
    LPMDB           pmdb = NULL;

    if (_pses == NULL)
    {
        hr = THR(_pmsgsite->GetSession(&_pses));
        if (hr)
        {
            g_LastError.SetLastError(hr, _pmsgsite);
            ShowError();
            return;
        }
    }


    BOOL fOldModalUp = s_fModalUp;

    s_fModalUp = TRUE;

    hr = THR(HrPickFolder(g_hInstCore, _hwnd, _pses, &pfld, &pmdb,
                                //&_cbCFDState, &_pbCFDState);
                                NULL, NULL));

    s_fModalUp = fOldModalUp;

    if (hr)
    {
        if (hr != MAPI_E_USER_CANCEL)
            ShowMessageBox(_hwnd, TEXT("Can't move"), g_achFormName, MB_OK | MB_ICONSTOP);

        return;
    }

    Assert(_pmsgsite);
    Assert(pfld);
    Assert(pmdb);

    RECT rect;
    GetWindowRect(_hwnd, &rect);

    hr = THR(_pmsgsite->MoveMessage(pfld, ViewCtx(), &rect));
    pfld->Release();
    pmdb->Release();
    if (FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        ShowError();
        return;
    }

    if (NULL == _pmsg)
    {
        ShutdownForm(SAVEOPTS_NOSAVE);
    }


}

//wraper for MessageBox()
int CPadMessage::ShowMessageBox(HWND hwnd, LPCTSTR lpszText, LPCTSTR lpszTitle, UINT uiStyle)
{
    int iret;
    BOOL fOldModalUp = s_fMBoxUp;

    s_fMBoxUp = TRUE;

    iret = MessageBox(hwnd, lpszText, lpszTitle, uiStyle);

    s_fMBoxUp = fOldModalUp;

    return iret;
}

//wraper for g_LastError.ShowError()
void CPadMessage::ShowError(void)
{
    int iret;
    BOOL fOldModalUp = s_fMBoxUp;

    s_fMBoxUp = TRUE;

    iret = g_LastError.ShowError(_hwnd);

    s_fMBoxUp = fOldModalUp;

}

HRESULT
CPadMessage::StreamInHtmlBody(LPMESSAGE pmsg)
{
    HRESULT hr;
    LPSTREAM pStm = NULL;

    if (!_fNewMessage)
    {
        hr = THR(pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                                STGM_READ, 0, (LPUNKNOWN FAR *) &pStm));
        if (hr)
            goto err;
    }

    hr = THR(Open(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamInHtmlBody(char * pch)
{
    HRESULT hr;
    LPSTREAM pStm = NULL;
    DWORD cb;
    DWORD cbWritten;
    LARGE_INTEGER i64Start = {0, 0};

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
    if (hr)
        goto err;

    cb = lstrlenA(pch);

    hr = THR(pStm->Write(pch, cb, &cbWritten));
    if (hr)
        goto err;

    hr = THR(pStm->Seek(i64Start, STREAM_SEEK_SET, NULL));
    if (hr)
        goto err;

    Assert (cbWritten == cb);

    hr = THR(Open(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamOutHtmlBody(LPMESSAGE pmsg)
{
    Assert(pmsg);

    HRESULT hr;
    LPSTREAM pStm = NULL;

    hr = THR(pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                            (LPUNKNOWN FAR *) &pStm));
    if (hr)
        goto err;

    hr = THR(CPadDoc::Save(pStm));

err:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

HRESULT
CPadMessage::StreamOutTextBody(LPMESSAGE pmsg)
{
    Assert(pmsg);

    HRESULT                 hr;
    LPSTREAM                pStm;
    LPSTREAM                pStmIn;
    FORMATETC               formatetc;
    STGMEDIUM               medium;
    IDataObject *           pDO;

    pStmIn = NULL;
    pStm = NULL;
    pDO = NULL;

    formatetc.cfFormat = RegisterClipboardFormat(_T("CF_RTF"));
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_ISTREAM;

    hr = THR(_pObject->QueryInterface(IID_IDataObject, (void**)&pDO));
    if (hr)
        goto err;

    hr = THR(pmsg->OpenProperty(PR_RTF_COMPRESSED, &IID_IStream,
            0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *) &pStmIn));
    if (hr)
        goto err;

    hr = THR(WrapCompressedRTFStream(pStmIn, MAPI_MODIFY, &pStm));
    if (hr)
        goto err;

    medium.tymed = TYMED_ISTREAM;
    medium.pstm = pStm;
    medium.pUnkForRelease = NULL;

    hr = THR(pDO->GetDataHere(&formatetc, &medium));
    if (hr)
    {
        //
        // RTF failed, try plain text
        //

        ReleaseInterface(pStm);

        formatetc.cfFormat = CF_TEXT;
        hr = THR(pmsg->OpenProperty(PR_BODY_A, &IID_IStream,
                    STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                    (LPUNKNOWN *) &pStm));
        if (hr)
            goto err;

        medium.pstm = pStm;

        hr = THR(pDO->GetDataHere(&formatetc, &medium));
        if (hr)
            goto err;

        hr = THR(pStm->Write(g_achPlainTextHeader, strlen(g_achPlainTextHeader), NULL));
        if (hr)
            goto err;

    }
    else
    {
        hr = THR(pStm->Commit(STGC_OVERWRITE));
        if (hr)
            goto err;
    }

err:
    ReleaseInterface(pStm);
    ReleaseInterface(pStmIn);
    ReleaseInterface(pDO);
    RRETURN(hr);
}

/*
 *  Formats a Win32 file time as a MAPI date/time string.
 *  NOTE: converts from GMT to local time.
 */
void FormatTime(FILETIME *pft, LPSTR szTime, DWORD cchTime)
{
    FILETIME        ft;
    SYSTEMTIME      systime;
    DWORD           dwLen;

    FileTimeToLocalFileTime(pft, &ft);
    FileTimeToSystemTime(&ft, &systime);

    dwLen = GetDateFormatA(
        LOCALE_USER_DEFAULT,
        DATE_LONGDATE,
        &systime,
        NULL,
        szTime,
        cchTime);

    Assert(cchTime - dwLen > 0);

    *(szTime + dwLen - 1) = ' '; // Replace terminating NULL with space

    GetTimeFormatA(
        LOCALE_USER_DEFAULT,
        TIME_NOSECONDS,
        &systime,
        NULL,
        szTime + dwLen,
        cchTime - dwLen);
}


void
CPadMessage::GetViewRect(RECT *prc, BOOL fIncludeObjectAdornments)
{
    RECT    rcDialog;
    RECT    rcFormat;
    RECT    rcToolbar;
    RECT    rcStatus;

    GetClientRect(_hwnd, prc);

    if (_hwndToolbar)
    {
        GetWindowRect(_hwndToolbar, &rcToolbar);
        SetWindowPos(_hwndToolbar, 0, 0, prc->top, prc->right - prc->left, rcFormat.bottom - rcFormat.top, SWP_NOZORDER | SWP_NOACTIVATE);
        prc->top += rcToolbar.bottom - rcToolbar.top;
    }

    if (_hwndTBFormat)
    {
        GetWindowRect(_hwndTBFormat, &rcFormat);
        SetWindowPos(_hwndTBFormat, 0, 0, prc->top, prc->right - prc->left, rcFormat.bottom - rcFormat.top, SWP_NOZORDER | SWP_NOACTIVATE);
        prc->top += rcFormat.bottom - rcFormat.top;
    }

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    // Reduce rectangle to leave space for address controls

    if (fIncludeObjectAdornments)
    {
        GetWindowRect (_hwndDialog,&rcDialog);
        SetWindowPos(_hwndDialog, 0, 0, prc->top, prc->right - prc->left, rcDialog.bottom - rcDialog.top, SWP_NOZORDER | SWP_NOACTIVATE);

        prc->top += rcDialog.bottom - rcDialog.top;
        if (prc->top > prc->bottom)
        {
            prc->top = prc->bottom;
        }
    }

    if (prc->bottom < prc->top)
        prc->bottom = prc->top;

    if (prc->right < prc->left)
        prc->right = prc->left;
}


LRESULT
CPadMessage::OnSize(WORD fwSizeType, WORD nWidth, WORD nHeight)
{
    RECT rc;
    GetViewRect(&rc, FALSE);
    if (_pInPlaceActiveObject)
    {
        THR_NOTRACE(_pInPlaceActiveObject->ResizeBorder(
                &rc,
                &_Frame,
                TRUE));
    }

    Resize();
    return 0;
}


HRESULT
CPadMessage::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    if (_eFormType == eformRead)
    {
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 0),
                TEXT("&File"));
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 1),
                TEXT("&View"));
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 2),
                TEXT("Co&mpose"));

        pmgw->width[0] = 1;
        pmgw->width[2] = 1;
        pmgw->width[4] = 1;
    }
    else if (_eFormType == eformSend)
    {
        AppendMenu(
                hmenuShared,
                MF_BYPOSITION | MF_POPUP,
                (UINT)GetSubMenu(_hmenuMain, 0),
                TEXT("&File"));

        pmgw->width[0] = 1;
        pmgw->width[2] = 0;
        pmgw->width[4] = 0;
    }
    else
    {
        Assert(FALSE);
    }

    _hmenuHelp = LoadMenu(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_PADHELPMENU));

    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT) (_hmenuHelp),
            TEXT("&Help"));

    _cMenuHelpItems = GetMenuItemCount(_hmenuHelp);

    pmgw->width[5] = 2;

    return S_OK;
}

void
CPadMessage::SetDocTitle(TCHAR * pchTitle)
{
    // don't do anything here since we set our own title
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgcidx.h ===
/*
 * MSGCIDX.H
 *
 * Prototype for ScAddConversationIndex
 *
 *  Copyright (c) 1995, Microsoft Corporation.
 *  All rights reserved.
 */

//#ifdef __cplusplus
//extern "C" {
//#endif

SCODE ScAddConversationIndex (ULONG cbParent, 
                              LPBYTE lpbParent,
                              ULONG FAR * lpcb,
                              LPBYTE FAR * lppb);

//#ifdef __cplusplus
//}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgcidx.cxx ===
/*
 *  MSGCIDX.CXX
 *  
 *  Create and extend PR_CONVERSATION_INDEX
 */

#include <padhead.hxx>

#define cbConvIndexHdr          22
#define cbConvIndexComponent    5
#define bConvIndexRes           (BYTE)1

/*
 *  ExtractLastFileTime()
 *  
 *  Purpose:
 *  
 *      Parses an existing covnersation index and extracts the last
 *      FILETIME value contained in the index.
 */
VOID
ExtractLastFileTime (LPBYTE lpb, ULONG cb, FILETIME FAR * lpft)
{
    FILETIME ft;
    FILETIME ftCur;
    LPBYTE lpbEnd;

    //  Lets do some verification on the key
    //
    Assert (!IsBadReadPtr (lpb, (UINT)cb));
    Assert (!IsBadWritePtr (lpft, sizeof(FILETIME)));
    Assert (*lpb == bConvIndexRes);
    Assert (cb >= cbConvIndexHdr);
    Assert (!((cb - cbConvIndexHdr) % cbConvIndexComponent));

    //  Rebuild the header time\date into FILETIME format
    //
    ft.dwHighDateTime = (((DWORD)(lpb[1])) << 16) |
                        (((DWORD)(lpb[2])) << 8) |
                        ((DWORD)(lpb[3]));

    ft.dwLowDateTime = (((DWORD)(lpb[4])) << 24) |
                       (((DWORD)(lpb[5])) << 16);

    //  See where the last child chunk ends
    //
    lpbEnd = lpb + cb;
    lpb += cbConvIndexHdr;

    //  Now go through the child chunks to compute
    //  for the last FILETIME using the delta
    //
    while (lpb < lpbEnd)
    {
        //  Convert the delta of the current child
        //  chunk into the FILETIME format.  Use the
        //  delta code in the first bit to get the
        //  real delta.
        //
        //  Delta code : 1 = mask 10000000 = 0x80
        //
        if ((*lpb & 0x80) == 0x80)
        {
            //  Mask out the first bit used for the delta code
            //  *lpb | 0x7F;
            //
            ftCur.dwHighDateTime = (((DWORD)(lpb[0] & 0x7F)) << 15) |
                                   (((DWORD)(lpb[1])) << 7) |
                                   (((DWORD)(lpb[2])) >> 1);

            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) << 31) |
                                  (((DWORD)(lpb[3])) << 23);

            ft = FtAddFt (ft, ftCur);
        }
        else
        {
            ftCur.dwHighDateTime = (((DWORD)(lpb[0] & 0x7F)) << 10) |
                                   (((DWORD)(lpb[1])) << 2) |
                                   (((DWORD)(lpb[2])) >> 6);

            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) << 26) |
                                  (((DWORD)(lpb[3])) << 18);

            ft = FtAddFt (ft, ftCur);
        }

        // Advance to next child
        //
        lpb += cbConvIndexComponent;
    }

    //  If all went well, we sould have ended up at
    //  lpbEnd
    //
    Assert (lpb == lpbEnd);
    *lpft = ft;
    return;
}

/*
 *  ScFillConvHeader()
 *  
 *  Purpose:
 *  
 *      Fills in the header of a conversation index.  This function is
 *      called when a new conversation index is created.
 *  
 *  Assumptions:
 *  
 *      The buffer passed in should be big enough to hold cbConvIndexHdr
 *      bytes (22 bytes).
 */
SCODE
ScFillConvHeader (LPBYTE rgb, ULONG cb)
{
    SCODE sc = S_OK;
    SYSTEMTIME st;
    FILETIME ft;
    GUID guid;

    Assert (cb >= cbConvIndexHdr);
    Assert (!IsBadWritePtr (rgb, cbConvIndexHdr));

    //  (Ha). Put the reserved byte
    //
    rgb[0] = bConvIndexRes;
        
    //  (Hb). Put the current time
    //
    GetSystemTime (&st);
    SystemTimeToFileTime (&st, &ft);

    //  Construct the date\time one byte at a time
    //
    rgb[1] = (BYTE) ((ft.dwHighDateTime & 0x00FF0000) >> 16);
    rgb[2] = (BYTE) ((ft.dwHighDateTime & 0x0000FF00) >> 8);
    rgb[3] = (BYTE) (ft.dwHighDateTime & 0x000000FF);

    //  Drop the rightmost least significant 2 bytes
    //
    rgb[4] = (BYTE) ((ft.dwLowDateTime & 0xFF000000) >> 24);
    rgb[5] = (BYTE) ((ft.dwLowDateTime & 0x00FF0000) >> 16);

    //  (Hc). Now put the GUID
    //      {
    //          DWORD Data1;
    //          WORD  Data2;
    //          WORD  Data3;
    //          BYTE  Data4[8];
    //      } GUID;
    //
    sc = GetScode (CoCreateGuid (&guid));
    if (!FAILED (sc))
    {       
        //  Again, lets do it one byte at a time
        //
        rgb[6] = (BYTE) ((guid.Data1 & 0xFF000000) >> 24);
        rgb[7] = (BYTE) ((guid.Data1 & 0x00FF0000) >> 16);
        rgb[8] = (BYTE) ((guid.Data1 & 0x0000FF00) >> 8);
        rgb[9] = (BYTE) ((guid.Data1 & 0x000000FF));
        rgb[10] = (BYTE) ((guid.Data2 & 0xFF00) >> 8);
        rgb[11] = (BYTE) ((guid.Data2 & 0x00FF));
        rgb[12] = (BYTE) ((guid.Data3 & 0xFF00) >> 8);
        rgb[13] = (BYTE) ((guid.Data3 & 0x00FF));
    }

    //  Slurp the rest across
    //
    CopyMemory (&rgb[14], &guid.Data4, 8);
    //DebugTraceSc (ScFillConvHeader(), sc);
    return sc;
}

/*
 *  ScAddConversationIndex()
 *  
 *  Purpose:
 *  
 *      Given the conversation index to a message, this function will
 *      create the conversation of a child message to the original.  If
 *      the no original is suplied, then an index is created that would
 *      signify the start of a new thread.
 */
SCODE
ScAddConversationIndex (ULONG cbParent,
    LPBYTE lpbParent,
    ULONG FAR * lpcb,
    LPBYTE FAR * lppb)
{
    SCODE sc;
    DWORD dwTemp;
    SYSTEMTIME st;
    FILETIME ft;
    FILETIME ftLast;
    FILETIME ftDelta;
    HMODULE hMAPIDll = NULL;
    typedef SCODE (STDAPICALLTYPE FAR *MAPICONVIDX)(ULONG, LPBYTE, ULONG FAR *, LPBYTE FAR *);
    MAPICONVIDX lpfnMAPIConvIdx = NULL;

#ifdef _WIN32
    #define szMAPIDll "mapi32.dll"
#else
    #define szMAPIDll "mapi.dll"
#endif

    /*
     * MAPI is going to export a function that is doing the same thing as this one.
     * So if the function is present we'll use it.
     */
    hMAPIDll = GetModuleHandleA(szMAPIDll);
    if(hMAPIDll)
    {
        lpfnMAPIConvIdx = (MAPICONVIDX)GetProcAddress(hMAPIDll,
                                            szScCreateConversationIndex);
        if(lpfnMAPIConvIdx)
        {
            return (*lpfnMAPIConvIdx)(cbParent, lpbParent, lpcb, lppb);
        }
    }
    //  Ensure that the parent is what we think
    //  it should be
    //
    if ((cbParent < cbConvIndexHdr) ||
        ((cbParent - cbConvIndexHdr) % cbConvIndexComponent) ||
        (lpbParent[0] != bConvIndexRes))
    {
        cbParent = 0;
        *lpcb = cbConvIndexHdr;
    }
    else
        *lpcb = cbParent + cbConvIndexComponent;

    sc = MAPIAllocateBuffer (*lpcb, (LPVOID FAR *)lppb);
    if (!FAILED (sc))
    {
        if (cbParent == 0)
        {
            //  This is a new key, so all it ever contains
            //  is a header.  Fill it in and we are done
            //
            sc = ScFillConvHeader (*lppb, *lpcb);
            if (FAILED (sc))
            {
                MAPIFreeBuffer (*lppb);
                *lppb = NULL;
            }
        }
        else
        {
            //  First copy the old key across
            //
            CopyMemory (*lppb, lpbParent, (UINT)cbParent);

            //  (Cb).  First get the current time (we'll then get
            //  the absolute distance between the current time and
            //  the time in the last chunk)
            //
            GetSystemTime (&st);
            SystemTimeToFileTime (&st, &ft);

            //  Now get the time of the last chunk
            //  
            ExtractLastFileTime (lpbParent, cbParent, &ftLast);

            //  Now mask out the bits we don't want from the
            //  current time
            //
            ft.dwHighDateTime &= 0x00FFFFFF;
            ft.dwLowDateTime &= 0xFFFF0000;

            //  This assert is here to catch how often the
            //  5-byte time can collide and under what scenario,
            //  to see if 5 bytes + the next byte suffices to
            //  make this child chunk unique.
            //  
            Assert (!((ftLast.dwHighDateTime == ft.dwHighDateTime) &&
                (ftLast.dwLowDateTime == ft.dwLowDateTime)));

            //  Get the change in time
            //
            if ((ft.dwHighDateTime > ftLast.dwHighDateTime) ||
                ((ft.dwHighDateTime == ftLast.dwHighDateTime) &&
                 (ft.dwLowDateTime > ftLast.dwLowDateTime)))
            {
                ftDelta = FtSubFt (ft, ftLast);
            }
            else
                ftDelta = FtSubFt (ftLast, ft);

            //  If the delta is less than 1.7 yrs, use 0
            //
            if (!(ftDelta.dwHighDateTime & 0x00FE0000))
            {
                //  Just mask out the 31 bits that we
                //  want from the ftDelta
                //
                dwTemp = ((DWORD)(ftDelta.dwHighDateTime & 0x0001FFFF)) << 14 |
                         ((DWORD)(ftDelta.dwLowDateTime & 0xFFFC0000)) >> 18;

                //  Only the first byte is different
                //
                (*lppb)[cbParent] = (BYTE)((dwTemp & 0xFF000000) >> 24 );
            }
            else
            {
                //  Just mask out the 31 bits that we
                //  want from the ftDelta
                //
                dwTemp = ((DWORD)(ftDelta.dwHighDateTime & 0x003FFFFF)) << 9 |
                         ((DWORD)(ftDelta.dwLowDateTime & 0xFF800000)) >> 23;

                // Only the first byte is different
                //
                (*lppb)[cbParent] = (BYTE)(HIBYTE(HIWORD(dwTemp)) | 0x080);
            }

            //  The remaining delta bytes are the same
            //
            (*lppb)[cbParent + 1] = (BYTE) ((dwTemp & 0x00FF0000) >> 16);
            (*lppb)[cbParent + 2] = (BYTE) ((dwTemp & 0x0000FF00) >> 8);
            (*lppb)[cbParent + 3] = (BYTE) ((dwTemp & 0x000000FF) );

            //  (Cc). Next get the random number
            //  (Cd). Next get the sequence count
            //  -- we are going to use part of the tick count
            //
            (*lppb)[cbParent + 4] = (BYTE) (GetTickCount() & 0x000000FF);
        }
    }

    //DebugTraceSc (ScAddConversationIndex(), sc);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgform.h ===
#ifndef MSGFORM_H
#define MSGFORM_H


/*
 *  E X C H F O R M . H
 *
 *  Declarations of interfaces and constants for forms that work with
 *  the Microsoft Exchange client.
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */


/*
 *  V e r b s
 */


// Interpersonal messaging verbs
#define EXCHIVERB_OPEN              0
#define EXCHIVERB_RESERVED_COMPOSE  100
#define EXCHIVERB_RESERVED_OPEN     101
#define EXCHIVERB_REPLYTOSENDER     102
#define EXCHIVERB_REPLYTOALL        103
#define EXCHIVERB_FORWARD           104
#define EXCHIVERB_PRINT             105
#define EXCHIVERB_SAVEAS            106
#define EXCHIVERB_RESERVED_DELIVERY 107
#define EXCHIVERB_REPLYTOFOLDER     108


/*
 *  G U I D s
 */


#define DEFINE_EXCHFORMGUID(name, b) \
    DEFINE_GUID(name, 0x00020D00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

#ifndef NOEXCHFORMGUIDS
DEFINE_EXCHFORMGUID(PS_EXCHFORM, 0x0C);
#endif // NOEXCHFORMGUIDS


/*
 *  E x t e n d e d   P r o p e r t i e s
 */


// Operation map property
#define psOpMap                     PS_EXCHFORM
#define ulKindOpMap                 MNID_ID
#define lidOpMap                    1
#define ptOpMap                     PT_STRING8

// Operation map indices
#define ichOpMapReservedCompose     0
#define ichOpMapOpen                1
#define ichOpMapReplyToSender       2
#define ichOpMapReplyToAll          3
#define ichOpMapForward             4
#define ichOpMapPrint               5
#define ichOpMapSaveAs              6
#define ichOpMapReservedDelivery    7
#define ichOpMapReplyToFolder       8

// Operation map values
#define chOpMapByClient             '0'
#define chOpMapByForm               '1'
#define chOpMapDisable              '2'


#endif // MSGFORM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgguid.h ===
// {88FFF551-B8C5-11ce-8DE0-00AA0060D242}
//The same as CLSID in smpfrm.cfg
DEFINE_GUID(CLSID_IPM_NOTE_SAMPLE, 
0x88fff551, 0xb8c5, 0x11ce, 0x8d, 0xe0, 0x00, 0xaa, 0x00, 0x60, 0xd2, 0x42);

//ClsId for recipient objects embedded in addressing fields
// {F8FB5730-EA86-11cf-8058-00AA003F40D0}
DEFINE_GUID(CLSID_CTriple, 
0xf8fb5730, 0xea86, 0x11cf, 0x80, 0x58, 0x0, 0xaa, 0x0, 0x3f, 0x40, 0xd0);

//string representation of our class ID
#define  szGUID TEXT ("{88FFF551-B8C5-11CE-8DE0-00AA0060D242}")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgerr.cxx ===
//
//  MSGERR.CPP
//
// implementation file for CLastError which implements the
// GetLastError helper
//
//  
//
// Copyright (C) 1995 Microsoft Corp.
//

//#define STRICT

#include "padhead.hxx"

#ifndef X_PAD_HXX_
#define X_PAD_HXX_
#include "pad.hxx"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

#ifndef X_MSGERR_HXX_
#define X_MSGERR_HXX_
#include "msgerr.hxx"
#endif

const int       CchMaxErrorMessage = 256;

extern const char  SzNull[] = "";
char szErrUnknown[] = "Error description is not available";

//
// some stuff to put a "Help" button on the error msgbox
//
#if defined(_WIN32)
char szHelpFile[_MAX_PATH];
VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo);
#endif //_WIN32

static int iFromHR(HRESULT hr)
{
    switch(GetScode(hr)) {
    case MAPI_E_NOT_ENOUGH_MEMORY:      return IDS_E_OUTOFMEMORY;
    case MAPI_E_INVALID_PARAMETER:      return IDS_INVALID_ARGUMENT;
    case MAPI_E_INVALID_OBJECT:         return IDS_INVALID_OBJECT;
    case MAPI_E_INTERFACE_NOT_SUPPORTED: return IDS_INTERFACE_NOT_SUPPORTED;
    case MAPI_E_NO_ACCESS:              return IDS_ACCESS_DENIED;
    case MAPI_E_NO_SUPPORT:             return IDS_NOT_SUPPORTED;
    case MAPI_E_BAD_CHARWIDTH:          return IDS_INVALID_CHARWIDTH;
    case MAPI_E_NOT_FOUND:              return IDS_NOT_FOUND;
    case MAPI_E_CALL_FAILED:            return IDS_CALL_FAILED;
    case MAPI_E_USER_CANCEL:            return IDS_USER_CANCEL;
    case MAPI_W_ERRORS_RETURNED:        return IDS_ERRORS_RETURNED;
    case MAPI_E_UNKNOWN_FLAGS:          return IDS_UNKNOWN_FLAGS;
    case E_UNEXPECTED:                  return IDS_UNEXPECTED;
    case OLEOBJ_S_CANNOT_DOVERB_NOW:    return IDS_CANTNOW;
    // if it's not in this list you need to add it.
    default:
        //DebugTrace(TEXT ("lasterr: bad arg to FORMScodeFromHR"));
        Assert(FALSE);
        return 0;
    }
}

HRESULT CLastError::Init(LPCTSTR szComponent)
{
    HRESULT hr;
    LONG cch;
    
    _eLastErr = eNoError;
    _hrLast = 0;
    _hrGLE = 0;
    _pmapierr = 0;
    _szComponent = NULL;

    cch = lstrlen(szComponent) + 1;

    hr = THR(MAPIAllocateBuffer(cch, (LPVOID *) &_szComponent));
    if(hr)
        goto Cleanup;

    WideCharToMultiByte(CP_ACP, 0, szComponent, cch, _szComponent, cch + 1, NULL, NULL);

Cleanup:
    RRETURN(hr);
}
    
CLastError::~CLastError()
{
    if (_pmapierr != NULL)
    {
        MAPIFreeBuffer(_pmapierr);
    }
    if(_szComponent != NULL)
    {
        MAPIFreeBuffer(_szComponent);
    }
}

HRESULT CLastError::SetLastError(HRESULT hr)
{
#if defined(DEBUG)
    //
    //  Ensure that the error string exists -- when we set it not when
    //  they ask for it.
    //

    (void) iFromHR(hr);
#endif

    //
    //  Release any previous error
    //

    if (_pmapierr != NULL) {
        MAPIFreeBuffer(_pmapierr);
        _pmapierr = NULL;
    }

    if (hr) {
        _eLastErr = eMAPI;
    }
    else {
        _eLastErr = eNoError;
    }

    return (_hrLast = hr);
}

HRESULT CLastError::SetLastError(HRESULT hr, IUnknown* punk)
{
    Assert(punk && hr);     // we have to have an object and an error.

    _eLastErr = eObject;
    _hrLast = hr;

    IMAPIProp* pmprp = (IMAPIProp*)punk;  // I hate this cast but c'est la vie.

    MAPIFreeBuffer(_pmapierr);     // clean up previous error.
    _pmapierr = NULL;

    _hrGLE = pmprp->GetLastError(hr, 0, &_pmapierr);
    if (_hrGLE == S_OK) {
        if (_pmapierr == NULL) {
            if (MAPIAllocateBuffer(sizeof(MAPIERROR), (void **) &_pmapierr)) {
                _hrGLE = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            }
            else {
                memset(_pmapierr, 0, sizeof(MAPIERROR));
                _pmapierr->ulVersion = MAPI_ERROR_VERSION;
                _pmapierr->lpszError = (LPTSTR)szErrUnknown;
                _pmapierr->lpszComponent =  (LPTSTR)SzNull;
            }
        }
        else if (_pmapierr->lpszError == NULL) {
            _pmapierr->lpszError = (LPTSTR)SzNull;
        }
        else if (_pmapierr->lpszComponent == NULL) {
            _pmapierr->lpszComponent = (LPTSTR)SzNull;
        }
    }
    else {
        if (_pmapierr != NULL) {
            MAPIFreeBuffer(_pmapierr);
            _pmapierr = NULL;
        }
    }
    return _hrLast;
}

HRESULT CLastError::GetLastError(HRESULT hr, DWORD dwFlags,
                                   LPMAPIERROR FAR * lppMAPIError)
{
    //
    //  Start with parameter validation
    //

    if (IsBadWritePtr(lppMAPIError, sizeof(LPMAPIERROR))) {
        return SetLastError(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (MAPI_UNICODE == (dwFlags & MAPI_UNICODE)) {
        return SetLastError(ResultFromScode(MAPI_E_BAD_CHARWIDTH));
    }

    //
    //  Is the error asked for the last error registered with us?
    //

    if (hr != _hrLast) {
        *lppMAPIError = NULL;
        return S_OK;
    }

    int         cch;
    int         cb;
    int         idsError;
    char*       szMessage = 0;
    char*       szComponent = 0;
    char        szErrorString[CchMaxErrorMessage];
    LPMAPIERROR pmapierr = NULL;

    //
    //  Based on the type of the last error, construct the appropriate
    //  return object
    //

    switch (_eLastErr) {
    case eMAPI:
        //
        //  The last error registered was a MAPI error code.  For mapi
        //      error codes we map the MAPI error code into a resource
        //      id and return the appropriate string.
        //
        // as to spec, we allocate a single buffer for message and
        //      component.  no one will notice that we aren't doing
        //      MAPIAllocateMore for component.
        //
        //   We make an assumption as to the maximum possible length
        //      of the two strings combined.
        //

        Assert(_pmapierr == NULL);
        if (MAPIAllocateBuffer(CchMaxErrorMessage + sizeof(MAPIERROR),
                               (void**)&pmapierr)) {
            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        }

        //
        //  Set the version number
        //

        pmapierr->ulVersion = MAPI_ERROR_VERSION;
        pmapierr->ulLowLevelError = 0;

        //
        //   do the maping from the MAPI error code into a FORM string
        //      value.  The FORM eror code code will be set as the low
        //      level error value.
        //

        idsError = iFromHR(_hrLast);
        pmapierr->ulContext = idsError;

        //
        //  Set the error string pointer to the appropriate location
        //      in the error buffer and load the error string.
        //

        pmapierr->lpszError = (LPTSTR) (sizeof(MAPIERROR) +
                                          (BYTE *) pmapierr);

        LoadStringA(g_hInstResource, idsError, szErrorString, 
                    CchMaxErrorMessage);
        
        lstrcpyA((LPSTR)pmapierr->lpszError, szErrorString);
        cch = lstrlenA(szErrorString);
       
        
        //
        // Set the componment string pointer to the appropriate location
        //      in the error buffer and load the component string.
        //

        pmapierr->lpszComponent = pmapierr->lpszError + cch + 1;
        cch = CchMaxErrorMessage - cch - 1;

        lstrcpyA((LPSTR)pmapierr->lpszComponent,
                        _szComponent ? _szComponent : SzNull);
        cch = lstrlen(pmapierr->lpszComponent);
        
        if (cch == 0) {
            *(pmapierr->lpszComponent) = 0;
        }

        break;


    case eObject:
        //
        //  The last regisered error message came from an object.  If we
        //      could not get the last error from the object, just return
        //      the error it returned and we are done.
        //

        if (_hrGLE != NOERROR) {
            Assert( _pmapierr == NULL );
            *lppMAPIError = NULL;
            return _hrGLE;
        }

    case eExtended:
        //
        //  The last error was an extended error.  The error is in the
        //      structure, we need to copy this structure and return
        //      it back to the user
        //

        Assert( _pmapierr != NULL );
        cb = (lstrlen(_pmapierr->lpszError) + lstrlen(_pmapierr->lpszComponent) + 2);

        if (MAPIAllocateBuffer(cb + sizeof(MAPIERROR),
                               (void **) &pmapierr)) {
            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        }

        *pmapierr = *_pmapierr;
        pmapierr->lpszError = (LPTSTR) (sizeof(MAPIERROR) + (BYTE *) pmapierr);
        lstrcpy(pmapierr->lpszError, _pmapierr->lpszError);
        pmapierr->lpszComponent = pmapierr->lpszError +
          lstrlen(pmapierr->lpszError) + 1;
        lstrcpy(pmapierr->lpszComponent, _pmapierr->lpszComponent);

        break;

    case eNoError:
        break;

    default:
        Assert(0);
        return NOERROR;
    }

    *lppMAPIError = pmapierr;
    return ResultFromScode(S_OK);
}



int CLastError::ShowError(HWND hWnd)
{
    char szMessage[512];
    char szbuf[256];

    if(_eLastErr != eObject || NULL == _pmapierr) return 0;

    wsprintfA(szMessage, "%s\n%s\nLowLevelError: 0x%08lx context: %ld ",
                        ((LPSTR)_pmapierr->lpszError ? (LPSTR)_pmapierr->lpszError : ""),
                        (LPSTR)_pmapierr->lpszComponent ? (LPSTR)_pmapierr->lpszComponent : "",
                        (LPSTR)_pmapierr->ulLowLevelError, (LPSTR)_pmapierr->ulContext);
   
    wsprintfA(szbuf, "\nReturn Code: 0x%08lx", SCODE(_hrLast));
    lstrcatA (szMessage, szbuf);
    
#if defined (_WIN32)
    *szHelpFile = '\0';

    int iret = 0;
    BOOL fCanHelp;

    if(_pmapierr->lpszError  &&  _pmapierr->ulContext)
        fCanHelp = TRUE;
    else
        fCanHelp = FALSE;
        
    if(fCanHelp)
    {
        DWORD dw = GetPrivateProfileStringA("Help File Mappings", (LPSTR)_pmapierr->lpszComponent,
                           "", szHelpFile, _MAX_PATH, "mapisvc.inf");
        if(0 == dw)
            fCanHelp = FALSE;

        if(fCanHelp)
        {
            MSGBOXPARAMSA mbp = {0};

            mbp.cbSize = sizeof(MSGBOXPARAMS);
            mbp.hwndOwner = hWnd;
            mbp.hInstance = NULL;
            mbp.lpszText = szMessage;
            mbp.lpszCaption = _szComponent ? _szComponent : "Error!";
            mbp.dwStyle = MB_ICONSTOP | MB_OK | MB_HELP;
            mbp.lpszIcon = NULL;
            mbp.dwContextHelpId = _pmapierr->ulContext;
            mbp.lpfnMsgBoxCallback = ErrorBoxCallBack;
            mbp.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

            iret = MessageBoxIndirectA(&mbp);
        }
        
    }

    
    if(!fCanHelp)
        iret = MessageBoxA (hWnd, szMessage,
                    _szComponent ? _szComponent : "Error!",
                        MB_ICONSTOP | MB_OK );

    *szHelpFile = '\0';

    return iret;

#else
    return MessageBox (hWnd, szMessage,
                     _szComponent ? _szComponent : "Error!",
                         MB_ICONSTOP | MB_OK );
#endif
}

#if defined(_WIN32)
VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo)
{
    Assert(*szHelpFile != '\0');

    WinHelpA(NULL, szHelpFile, HELP_CONTEXT,
            lpHelpInfo->dwContextId);
}
#endif //_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgguid.cxx ===
//////////////////////////////////////////////////////////////////////////////
//
//  FILE:           MSGGUID.CXX
//
//  
//
//  Copyright (c) 1986-1996, Microsoft Corporation.
//  All rights reserved.
//
//--

#include <padhead.hxx>

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include <initguid.h>
#endif

#define         USES_IID_IMAPIForm
#define         USES_IID_IMAPIFormAdviseSink
#define         USES_IID_IPersistMessage

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#ifndef X_MAPIGUID_H_
#define X_MAPIGUID_H_
#include "mapiguid.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msghost.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       msghost.cxx
//
//  Contents:   CPadMessage's implementation of IDocHostUIHandler and
//              IDocHostShowUI
//
//------------------------------------------------------------------------


#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#include "commctrl.h"
#endif

#define         MAXLABELLEN 32
#define         MAX_COMBO_VISUAL_ITEMS 20

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadMessageDocHost, CPadMessage, PadMessage, _DocHost);

STDMETHODIMP
CPadMessageDocHost::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *) this;
    }
    else if (iid == IID_IDocHostShowUI)
    {
        *ppv = (IDocHostShowUI *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//      Implementation of IDocHostUIHandler
//
//+---------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetHostInfo
//
//  Synopsis:   Fetch information and flags from the host.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
        return E_INVALIDARG;

    pInfo->dwFlags = 0;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowUI
//
//  Synopsis:   This method allows the host replace object's menu
//              and toolbars. It returns S_OK if host display
//              menu and toolbar, otherwise, returns S_FALSE.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowUI(
        DWORD dwID,
        IOleInPlaceActiveObject * pActiveObject,
        IOleCommandTarget * pCommandTarget,
        IOleInPlaceFrame * pFrame,
        IOleInPlaceUIWindow * pDoc)
{
    CPadMessage *   pPad = PadMessage();

    if (!pPad->_hwndToolbar)
        pPad->CreateToolbarUI();

    pPad->_fShowUI = TRUE;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::HideUI
//
//  Synopsis:   Remove menus and toolbars cretaed during the call
//              to ShowUI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::HideUI(void)
{
    CPadMessage *   pPad = PadMessage();

    pPad->_fShowUI = FALSE;
    // Do not hide menu/toolbar, just update status
    pPad->UpdateToolbarUI();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::UpdateUI
//
//  Synopsis:   Update the state of toolbar buttons.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::UpdateUI(void)
{
    CPadMessage *   pPad = PadMessage();
    pPad->UpdateToolbarUI();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::EnableModeless
//
//  Synopsis:   Enable or disable modless UI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::EnableModeless(BOOL fEnable)
{
    // TODO : To be implemented
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::OnDocWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::OnDocWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::OnFrameWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::OnFrameWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ResizeBorder
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ResizeBorder(
        LPCRECT prc,
        IOleInPlaceUIWindow * pUIWindow,
        BOOL fFrameWindow)
{
    CPadMessage *   pPad = PadMessage();
    BORDERWIDTHS bw;

    ::SetRect((LPRECT)&bw, 0, 0, 0, 0);
    pPad->_Frame.SetBorderSpace(&bw);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowContextMenu
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display any UI.
//              DOCHOST_E_UNKNOWN -- The menu ID is unknown..
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowContextMenu(
            DWORD dwID,
            POINT * pptPosition,
            IUnknown * pcmdtReserved,
            IDispatch * pDispatchObjectHit)
{
    HRESULT                 hr = S_FALSE;
    HMENU                   hmenu;
    HCURSOR                 hcursor;
    HCURSOR                 hcursorOld;
    HWND                    hwnd;
    CPadMessage *           pPad = PadMessage();

    if (!pPad->_pInPlaceObject)
        goto Cleanup;

    hr = THR(pPad->_pInPlaceObject->GetWindow(&hwnd));
    if (hr)
        goto Cleanup;

    hr = THR(pPad->GetContextMenu(&hmenu, dwID));
    if (hr)
        goto Cleanup;

    hcursor = LoadCursorA(NULL, (char *)IDC_ARROW);
    hcursorOld = ::SetCursor(hcursor);

    TrackPopupMenu(
            hmenu,
#ifndef _MAC
            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
#else
            0,
#endif
            pptPosition->x,
            pptPosition->y,
            0,
            hwnd,
            NULL);

    ::SetCursor(hcursorOld);

Cleanup:
    return !hr? S_OK: S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::TranslateAccelerator
//
//  Returns:    S_OK -- The mesage was translated successfully.
//              S_FALSE -- The message was not translated.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::TranslateAccelerator(
            LPMSG lpmsg,
            const GUID * pguidCmdGroup,
            DWORD nCmdID)
{
    CPadMessage *   pPad = PadMessage();

    // If a control on the toolbar has the focus
    if ((::GetFocus() == lpmsg->hwnd) &&
            ((GetParent(lpmsg->hwnd) == pPad->_hwndToolbar) ||
             (GetParent(lpmsg->hwnd) == pPad->_hwndTBFormat)))
    {
        // if the key pressed is arrow keys and combo box is not dropped down,
        // drop down the combo box.
        //
        if ((lpmsg->message == WM_KEYDOWN) &&
                (((short) lpmsg->wParam == VK_UP) ||
                        ((short) lpmsg->wParam == VK_DOWN)))
        {
            if (!SendMessage(lpmsg->hwnd, CB_GETDROPPEDSTATE, 0, 0))
            {
                SendMessage(lpmsg->hwnd, CB_SHOWDROPDOWN, TRUE, 0);
            }
        }
        return S_OK;
    }
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetOptionKeyPath
//
//  Synopsis:   Get the registry key where host stores its default
//              options.
//
//  Returns:    S_OK          -- Success.
//              E_OUTOFMEMORY -- Fail.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    HRESULT hr = E_INVALIDARG;

    if (dw == 0)
    {
        if (ppchKey)
        {
            *ppchKey = (LPOLESTR)CoTaskMemAlloc((_tcslen(_T("Software\\Microsoft\\Microsoft HTML Pad"))+1)*sizeof(TCHAR));
            if (*ppchKey)
                _tcscpy(*ppchKey, _T("Software\\Microsoft\\Microsoft HTML Pad"));
            hr = (*ppchKey) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::GetDropTarget
//
//  Returns:    S_OK -- Host will return its droptarget to overwrite given one.
//              S_FALSE -- Host does not want to overwrite droptarget
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::GetDropTarget(
        IDropTarget * pDropTarget,
        IDropTarget ** ppDropTarget)
{
    return S_FALSE;
}


STDMETHODIMP
CPadMessageDocHost::GetExternal(IDispatch** ppDisp)
{
    HRESULT     hr;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppDisp = NULL;
        hr = S_OK;
    }
   
    return hr;
}


STDMETHODIMP
CPadMessageDocHost::TranslateUrl(DWORD dwTranslate,
                                 OLECHAR *pchURLIn,
                                 OLECHAR **ppchURLOut)
{
    HRESULT     hr;

    if (!ppchURLOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }
   
    return hr;
}


STDMETHODIMP
CPadMessageDocHost::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    HRESULT     hr;

    if (!ppDORet)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppDORet = NULL;
        hr = S_OK;
    }
   
    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//      Implementation of IDocHostShowUI
//
////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowMessage
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display its own UI.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowMessage(
        HWND hwnd,
        LPOLESTR lpstrText,
        LPOLESTR lpstrCaption,
        DWORD dwType,
        LPOLESTR lpstrHelpFile,
        DWORD dwHelpContext,
        LRESULT * plResult)
{
    LRESULT     lResult;

    lResult = MessageBoxEx(hwnd, lpstrText, lpstrCaption, dwType, 0);
    if (plResult)
        *plResult = lResult;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadMessageDocHost::ShowHelp
//
//  Returns:    S_OK -- Host displayed its own help.
//              S_FALSE -- Host did not display its help.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadMessageDocHost::ShowHelp(
        HWND hwnd,
        LPOLESTR pszHelpFile,
        UINT uCommand,
        DWORD dwData,
        POINT ptMouse,
        IDispatch * pDispatchObjectHit)
{
    // ISSUE: Temporary fix for beta1 to append window style.
    // Append ">LangRef"
    _tcscat(pszHelpFile, _T(">LangRef"));
    WinHelp(hwnd, pszHelpFile, uCommand, dwData);

    return S_OK;
}


HRESULT
CPadMessage::QueryService(REFGUID sid, REFIID iid, void ** ppv)
{
    *ppv = NULL;
    RRETURN(E_NOINTERFACE);
}

////////////////////////////////////////////////////////////////////////
//
//      Helper functions
//
////////////////////////////////////////////////////////////////////////

HRESULT
CPadMessage::CreateToolbarUI()
{
    HRESULT     hr = S_OK;

    HWND *      pHwndCombo = NULL;
    HWND        hwndToolbar = NULL;
    HFONT       hFont;
    DWORD       cTBCombos;
    TEXTMETRIC  tm;
    HDC         hdc;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };

    static const ComboInfo tbCombos[] =
    {
        { IDM_BLOCKFMT,  IDR_HTMLPAD_TBFORMAT,       5, 100, 16,
                CBS_DROPDOWNLIST},
        { IDM_FONTNAME,    IDR_HTMLPAD_TBFORMAT,   110, 150, 43,
                CBS_SORT | CBS_DROPDOWNLIST},
        { IDM_FONTSIZE,    IDR_HTMLPAD_TBFORMAT,   265,  40,  8,
                CBS_DROPDOWNLIST},
        { IDM_FORECOLOR,   IDR_HTMLPAD_TBFORMAT,   384,  55, 12,
                CBS_DROPDOWNLIST},
        { 0, 0, 0, 0, 0}
    };

    static const TBBUTTON tbStdButton[] =
    {
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_NEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_OPEN, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 2, IDM_SAVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 3, IDM_CUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 4, IDM_COPY, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_PASTE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 6, IDM_UNDO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 7, IDM_REDO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 8, IDM_BOOKMARK, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 9, IDM_HYPERLINK, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {10, IDM_HORIZONTALLINE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_IMAGE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {12, IDM_TABLE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {13, IDM_SHOWHIDE_CODE, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {60, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {14, IDM_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {15, IDM_PAGEINFO, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {16, IDM_PAD_FONTINC, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {17, IDM_PAD_FONTDEC, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
   };

    static const TBBUTTON tbFmtButton[] =
    {
        // reserved space for HTML Markup Tag,FontName, and FontSize Comboboxes
        {110, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {155, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        { 45, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {0, IDM_BOLD,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {1, IDM_ITALIC,    TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {2, IDM_UNDERLINE, TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},

        // reserved space for BackGroundColor Combobox.
        { 65, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {3, IDM_JUSTIFYLEFT,   TBSTATE_CHECKED, TBSTYLE_CHECKGROUP, 0L, 0},
        {4, IDM_JUSTIFYCENTER, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {5, IDM_JUSTIFYRIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {6, IDM_ORDERLIST,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0L, 0},
        {7, IDM_UNORDERLIST, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {8, IDM_OUTDENT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {9, IDM_INDENT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
    };

    // Ensure that the common control DLL is loaded for status window.
    InitCommonControls();

    // Create toolbars.
    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_HTMLPAD_TBSTANDARD,
            18,
            g_hInstResource,
            IDB_HTMLPAD_TBSTANDARD,
            (LPCTBBUTTON) &tbStdButton,
            ARRAY_SIZE(tbStdButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!_hwndToolbar)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _hwndTBFormat = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_HTMLPAD_TBFORMAT,
            10,
            g_hInstResource,
            IDB_HTMLPAD_TBFORMAT,
            (LPCTBBUTTON) &tbFmtButton,
            ARRAY_SIZE(tbFmtButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!(_hwndTBFormat))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_BLOCKFMT:
            pHwndCombo = &_hwndComboTag;
            break;
        case IDM_FONTNAME:
            pHwndCombo = &_hwndComboFont;
            break;
        case IDM_FONTSIZE:
            pHwndCombo = &_hwndComboSize;
            break;
        case IDM_FORECOLOR:
            pHwndCombo = &_hwndComboColor;
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLPAD_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLPAD_TBFORMAT:
            hwndToolbar = _hwndTBFormat;
            break;
        }

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                _hwnd,
                (HMENU)tbCombos[cTBCombos].ComboIDM,
                g_hInstResource,
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(ANSI_VAR_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM) hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);

        EnableWindow(*pHwndCombo, TRUE);
        SetParent(*pHwndCombo, hwndToolbar);
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
    }

    LoadToolbarUI();
    ::ShowWindow(_hwndToolbar, SW_SHOW);
    ::ShowWindow(_hwndTBFormat, SW_SHOW);

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(LOGFONT FAR *    lplf,
             TEXTMETRIC FAR * lptm,
             int              iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const wchar_t *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);

    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}


//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------

struct ComboItem {
        TCHAR * pName;
        LONG   lData;
};

static const ComboItem ComboColorItems[] =
{
    {TEXT("Black"),      RGB(0, 0, 0)},
    {TEXT("Navy"),       RGB(0, 0, 128)},
    {TEXT("Blue"),       RGB(0, 0, 255)},
    {TEXT("Cyan"),       RGB(0, 255, 255)},
    {TEXT("Red"),        RGB(255, 0, 0)},
    {TEXT("Lime"),       RGB(0, 255, 0)},
    {TEXT("Gray"),       RGB(128, 128, 128)},
    {TEXT("Green"),      RGB(0, 128, 0)},
    {TEXT("Yellow"),     RGB(255, 255, 0)},
    {TEXT("Pink"),       RGB(255, 192, 203)},
    {TEXT("Violet"),     RGB(238, 130, 238)},
    {TEXT("White"),      RGB(255, 255, 255)},
    {NULL, 0L}
};


DWORD AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;

    while(pComboItems->pName)
    {
        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) pComboItems->pName);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}



void ConvColorrefToString(COLORREF crColor, LPTSTR szName)
{
    int     i;
    BOOL fFound = FALSE;

    for(i = 0; ComboColorItems[i].pName != NULL; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        _tcscpy(szName, ComboColorItems[i].pName);
    else
        szName[0] = 0;
}


//+-------------------------------------------------------------------
//
// Member:  CPadMessage::LoadToolbarUI
//
//--------------------------------------------------------------------

void
CPadMessage::LoadToolbarUI()
{
    HDC      hdc;
    HRESULT  hr;

    // load items into ComboTag, ComboZoom and ComboSize comboboxes
    static const UINT ComboLoad[] = {
            IDM_FONTSIZE,
            IDM_GETBLOCKFMTS,
            0
    };

    VARIANTARG varRange;
    LONG lLBound, lUBound, lIndex, lValue;
    BSTR  bstrBuf;
    TCHAR szBuf[64];
    SAFEARRAY * psa = NULL;
    HWND hwndCombobox = NULL;
    int i;
    IOleCommandTarget * pCommandTarget = NULL;

     if ( !_pInPlaceObject  ||
     _pInPlaceObject->QueryInterface(
        IID_IOleCommandTarget, (void **)&pCommandTarget) )
    {
        // FAIL
        return;
    }

    for (i = 0; ComboLoad[i]; i ++)
    {
        switch (ComboLoad[i])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            break;
        case IDM_GETBLOCKFMTS:
            hwndCombobox = _hwndComboTag;
            break;
        }
        varRange.vt = VT_ARRAY;
        varRange.parray = psa;

       hr = THR(pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                ComboLoad[i],
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &varRange));
        if (OK(hr))
        {
            psa = V_ARRAY(&varRange);
            SafeArrayGetLBound(psa, 1, &lLBound);
            SafeArrayGetUBound(psa, 1, &lUBound);
            for (lIndex = lLBound; lIndex <= lUBound; lIndex ++)
            {
                switch (ComboLoad[i])
                {
                case IDM_GETBLOCKFMTS:
                    SafeArrayGetElement(psa, &lIndex, &bstrBuf);
                    SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) bstrBuf);
                    SysFreeString(bstrBuf);
                    break;

                case IDM_FONTSIZE:
                    SafeArrayGetElement(psa, &lIndex, &lValue);
                    Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), lValue);
                    SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    break;
                }
            }
            SafeArrayDestroyData(psa);
            SafeArrayDestroy(psa);
        }
    }

    HWND hWndInPlace;

    if (_pInPlaceObject)
    {
        _pInPlaceObject->GetWindow(&hWndInPlace);
    }
    if (!hWndInPlace)
        hWndInPlace = _hwnd;

    // insert font facenames to Font combobox.
    hdc = ::GetDC(hWndInPlace);
    EnumFontFamilies(
            hdc,
            NULL,
            (FONTENUMPROC) FillFontProc,
            (LPARAM)_hwndComboFont);
    ::ReleaseDC(hWndInPlace, hdc);

    // load items into ComboColor combobox and set default selection.
    AddComboboxItems(_hwndComboColor, TRUE, ComboColorItems);
    SendMessage(_hwndComboColor, CB_SETCURSEL, 0, 0);

    ReleaseInterface(pCommandTarget);
}



LRESULT
CPadMessage::OnCommand(WORD wNotifyCode, WORD idm, HWND hwndCtl)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    VARIANTARG *        pvarIn  = NULL;
    VARIANTARG *        pvarOut = NULL;
    VARIANTARG          var;
    TCHAR               achBuffer[64];
    BOOL                fRestoreFocus = FALSE;
    DWORD               nCmdexecopt = MSOCMDEXECOPT_DONTPROMPTUSER;

    switch (idm)
    {
        case IDM_FONTSIZE:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboSize,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt   = VT_I4;
            var.lVal = _wtoi(achBuffer);
            pvarIn   = &var;
            break;

        case IDM_BLOCKFMT:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboTag,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt      = VT_BSTR;
            var.bstrVal = achBuffer;
            pvarIn      = &var;
            break;

        case IDM_FONTNAME:
            fRestoreFocus = TRUE;

            GetWindowText(
                    _hwndComboFont,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));
            var.vt      = VT_BSTR;
            var.bstrVal = achBuffer;
            pvarIn      = &var;
            break;

        case IDM_FORECOLOR:
            fRestoreFocus = TRUE;

            var.lVal = SendMessage(
                    _hwndComboColor,
                    CB_GETITEMDATA,
                    (WPARAM) SendMessage(_hwndComboColor, CB_GETCURSEL, 0, 0),
                    0);
            var.vt      = VT_I4;
            pvarIn      = &var;
            break;
    }

    switch(idm)
    {
        case IDM_MESSAGE_PRINT:
            idm = IDM_PRINT;
            // fall through

        case IDM_PRINTPREVIEW:
        case IDM_IMAGE:
        case IDM_HYPERLINK:
        case IDM_BOOKMARK:
        case IDM_FIND:
        case IDM_REPLACE:
        case IDM_PARAGRAPH:
        case IDM_GOTO:
        case IDM_FONT:
        case IDM_INSERTOBJECT:
            nCmdexecopt = 0;
            // fall through

        case IDM_CUT:
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_PASTEINSERT:
        case IDM_DELETE:
        case IDM_SELECTALL:

        case IDM_NEW:
        case IDM_OPEN:
        case IDM_SAVE:
        case IDM_PASTESPECIAL:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_HORIZONTALLINE:
        case IDM_SHOWHIDE_CODE:
        case IDM_PROPERTIES:
        case IDM_BOLD:
        case IDM_ITALIC:
        case IDM_UNDERLINE:
        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_ORDERLIST:
        case IDM_UNORDERLIST:
        case IDM_OUTDENT:
        case IDM_INDENT:
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
        case IDM_FONTSIZE:
        case IDM_FORECOLOR:

        case IDM_UNLINK:
        case IDM_UNBOOKMARK:
        case IDM_TOOLBARS:
        case IDM_STATUSBAR:
        case IDM_FORMATMARK:
        case IDM_TEXTONLY:
        case IDM_BASELINEFONT5:
        case IDM_BASELINEFONT4:
        case IDM_BASELINEFONT3:
        case IDM_BASELINEFONT2:
        case IDM_BASELINEFONT1:
        case IDM_PAD_REFRESH:
        case IDM_EDITSOURCE:
        case IDM_FOLLOWLINKC:
        case IDM_FOLLOWLINKN:
        case IDM_OPTIONS:
        case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_IFRAME:
        case IDM_1D:
        case IDM_TEXTBOX:
        case IDM_TEXTAREA:
#ifdef NEVER        
        case IDM_HTMLAREA:
#endif        
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:
        case IDM_FORM:
        case IDM_MARQUEE:
        case IDM_LIST:
        case IDM_PREFORMATTED:
        case IDM_ADDRESS:
        case IDM_BLINK:
        case IDM_DIV:
        case IDM_TABLEINSERT:
        case IDM_ROWINSERT:
        case IDM_COLUMNSELECT:
        case IDM_TABLESELECT:
        case IDM_CELLPROPERTIES:
        case IDM_TABLEPROPERTIES:
        case IDM_HELP_CONTENT:
        case IDM_HELP_ABOUT:

            if ( _pInPlaceObject &&
                 OK(_pInPlaceObject->QueryInterface(
                    IID_IOleCommandTarget, (void **)&pCommandTarget)) )
            {
                hr = pCommandTarget->Exec(
                        &CGID_MSHTML,
                        idm,
                        nCmdexecopt,
                        pvarIn,
                        pvarOut);
                // When the user selects a combo item, pop the focus pack into the document.
                if (fRestoreFocus)
                {

                    HWND    hWndInPlace;

                    _pInPlaceObject->GetWindow(&hWndInPlace);
                    if (hWndInPlace)
                    {
                        ::SetFocus (hWndInPlace);
                    }
                }
            }
            break;

        default:
            CPadDoc::OnCommand(wNotifyCode, idm, hwndCtl);
    }

    CheckError(_hwnd, hr);
    ReleaseInterface(pCommandTarget);
    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     CPadMessage::UpdateToolbarUI
//
//  Synopsis:
//
//--------------------------------------------------------------------

LRESULT
CPadMessage::UpdateToolbarUI()
{
    struct ButtonInfo {
        UINT ButtonIDM;
        UINT ToolbarIDR;
    };

    static const ButtonInfo tbButtons[] =
    {
        { IDM_NEW,              IDR_HTMLPAD_TBSTANDARD },
        { IDM_OPEN,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_SAVE,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_UNDO,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_REDO,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_TABLE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_BOOKMARK,         IDR_HTMLPAD_TBSTANDARD },
        { IDM_HYPERLINK,        IDR_HTMLPAD_TBSTANDARD },
        { IDM_HORIZONTALLINE,   IDR_HTMLPAD_TBSTANDARD },
        { IDM_IMAGE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_SHOWHIDE_CODE,    IDR_HTMLPAD_TBSTANDARD },
        { IDM_PROPERTIES,       IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAGEINFO,         IDR_HTMLPAD_TBSTANDARD },
        { IDM_CUT,              IDR_HTMLPAD_TBSTANDARD },
        { IDM_COPY,             IDR_HTMLPAD_TBSTANDARD },
        { IDM_PASTE,            IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAD_FONTINC,      IDR_HTMLPAD_TBSTANDARD },
        { IDM_PAD_FONTDEC,      IDR_HTMLPAD_TBSTANDARD },

        { IDM_BOLD,             IDR_HTMLPAD_TBFORMAT },
        { IDM_ITALIC,           IDR_HTMLPAD_TBFORMAT },
        { IDM_UNDERLINE,        IDR_HTMLPAD_TBFORMAT },
        { IDM_ORDERLIST,        IDR_HTMLPAD_TBFORMAT },
        { IDM_UNORDERLIST,      IDR_HTMLPAD_TBFORMAT },
        { IDM_INDENT,           IDR_HTMLPAD_TBFORMAT },
        { IDM_OUTDENT,          IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYLEFT,      IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYCENTER,    IDR_HTMLPAD_TBFORMAT },
        { IDM_JUSTIFYRIGHT,     IDR_HTMLPAD_TBFORMAT },
        { IDM_MULTIPLESELECTION,IDR_HTMLPAD_TBFORMAT },        
        { IDM_2D_POSITION,      IDR_HTMLPAD_TBFORMAT },
        { IDM_ABSOLUTE_POSITION,IDR_HTMLPAD_TBFORMAT },
        { IDM_LIVERESIZE,       IDR_HTMLPAD_TBFORMAT },
       { 0, 0}
    };

    UINT        cButtons;
    HWND        hwndToolbar = NULL;
    HRESULT     hr = S_OK;
    MSOCMD      msocmd;
    IOleCommandTarget * pCommandTarget = NULL;
    HWND  hwndCombobox = NULL;

    static const UINT ComboSet[] = {
            IDM_FONTNAME,
            IDM_FONTSIZE,
            IDM_BLOCKFMT,
            IDM_FORECOLOR,
            0 };

     if ( !_pInPlaceObject  ||
     _pInPlaceObject->QueryInterface(
        IID_IOleCommandTarget, (void **)&pCommandTarget) )
    {
        // FAIL
        goto Cleanup;
    }
    // update zoom combobox status

    VARIANTARG var;
    int j, iIndex, iCurrentIndex;
    TCHAR szBuf[128];

    for (j = 0; ComboSet[j]; j ++)
    {
        switch (ComboSet[j])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            var.vt   = VT_I4;
            var.lVal = 0;
            break;
        case IDM_BLOCKFMT:
            hwndCombobox = _hwndComboTag;
            var.vt      = VT_BSTR;
            var.bstrVal = NULL;
            break;
        case IDM_FONTNAME:
            hwndCombobox = _hwndComboFont;
            var.vt      = VT_BSTR;
            var.bstrVal = NULL;
            break;
        case IDM_FORECOLOR:
            hwndCombobox = _hwndComboColor;
            var.vt      = VT_I4;
            var.lVal = 0;
            break;
        }

        msocmd.cmdID = ComboSet[j];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fShowUI)
        {
            hr = THR(pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL));
        }
        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            EnableWindow(hwndCombobox, TRUE);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableWindow(hwndCombobox, FALSE);
            break;
        }

        // Only if object is active
        if (_fShowUI)
        {
            hr = THR_NOTRACE(pCommandTarget->Exec((GUID *)&CGID_MSHTML, ComboSet[j],
                    MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &var));
            if (FAILED(hr))
                continue;
        }

        switch (ComboSet[j])
        {
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            // It is legal for the returned bstr to be NULL.
            wcscpy(szBuf, var.bstrVal ? var.bstrVal : TEXT(""));
            break;

        case IDM_FORECOLOR:
            if(V_VT(&var) == VT_NULL)
                szBuf[0] = 0;
            else
                ConvColorrefToString(V_I4(&var), szBuf);
            break;

        case IDM_FONTSIZE:
            // If the font size is changing in the selection VT_NULL is returned
            if(V_VT(&var) == VT_NULL)
            {
                szBuf[0] = 0;
            }
            else
            {
                Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), var.lVal);
            }
            break;
        }

        iIndex = SendMessage(
                hwndCombobox,
                CB_FINDSTRINGEXACT,
                (WPARAM) -1,
                (LPARAM)(LPTSTR) szBuf);

        if (iIndex == CB_ERR)
        {
            // CB_FINDSTRINGEXACT cannot find the string in the combobox.
            //
            switch (ComboSet[j])
            {
            case IDM_BLOCKFMT:
                // GetBlockFormat returns something not in the BlockFormat
                // combobox, display empty string.
                //
                iIndex = -1;
                break;

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
                // Nothing is selected
                iIndex = -1;
                break;
            }
        }

        iCurrentIndex = SendMessage(hwndCombobox, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if ( iCurrentIndex != iIndex )
            SendMessage(hwndCombobox, CB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0);

        // If the return value was a string free it
        if(var.vt == VT_BSTR && var.bstrVal != NULL)
            SysFreeString(var.bstrVal);
    }

    // update buttons status
    BOOL fEnabled;
    BOOL fChecked;
    for (cButtons = 0; tbButtons[cButtons].ButtonIDM != 0; cButtons ++)
    {
        switch (tbButtons[cButtons].ToolbarIDR)
        {
        case IDR_HTMLPAD_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLPAD_TBFORMAT:
            hwndToolbar = _hwndTBFormat;
            break;
        }

        if (hwndToolbar)
        {
            msocmd.cmdID = tbButtons[cButtons].ButtonIDM;
            msocmd.cmdf  = 0;

            // Only if object is active
            if (_fActive)
            {
                hr = pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL);
            }

            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_DOWN:
            case MSOCMDSTATE_NINCHED:
                fEnabled = TRUE;
                fChecked = (msocmd.cmdf == MSOCMDSTATE_DOWN) ? TRUE : FALSE;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                fEnabled = FALSE;
                fChecked = FALSE;
                break;
            }
            SendMessage(
                    hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fEnabled, 0));
            SendMessage(
                    hwndToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fChecked, 0));
        }
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    return 0;
}


LRESULT
CPadMessage::OnInitMenuPopup(HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    HRESULT     hr = S_OK;
    int         cMenuItem;
    MSOCMD      msocmd;
    UINT        mf;
    IOleCommandTarget * pCommandTarget =NULL;

    UINT    MenuItem [] =  {
        IDM_UNDO,
        IDM_REDO,
        IDM_CUT,
        IDM_COPY,
        IDM_PASTE,
        IDM_PASTEINSERT,
        IDM_DELETE,
        IDM_SELECTALL,
        IDM_FIND,
        IDM_REPLACE,
        IDM_GOTO,
        IDM_BOOKMARK,
        IDM_HYPERLINK,
        IDM_UNLINK,
        IDM_UNBOOKMARK,
        IDM_TOOLBARS,
        IDM_STATUSBAR,
        IDM_FORMATMARK,
        IDM_TEXTONLY,
        IDM_BASELINEFONT5,
        IDM_BASELINEFONT4,
        IDM_BASELINEFONT3,
        IDM_BASELINEFONT2,
        IDM_BASELINEFONT1,
        IDM_PAD_REFRESH,
        IDM_EDITSOURCE,
        IDM_FOLLOWLINKC,
        IDM_FOLLOWLINKN,
        IDM_PROPERTIES,
        IDM_OPTIONS,
        IDM_HORIZONTALLINE,
        IDM_LINEBREAKNORMAL,
        IDM_LINEBREAKLEFT,
        IDM_LINEBREAKRIGHT,
        IDM_LINEBREAKBOTH,
        IDM_NONBREAK,
        IDM_SPECIALCHAR,
        IDM_HTMLSOURCE,
        IDM_IFRAME,
        IDM_1D,
        IDM_TEXTBOX,
        IDM_TEXTAREA,
        IDM_HTMLAREA,
        IDM_CHECKBOX,
        IDM_RADIOBUTTON,
        IDM_DROPDOWNBOX,
        IDM_LISTBOX,
        IDM_BUTTON,
        IDM_IMAGE,
        IDM_INSERTOBJECT,
        IDM_FONT,
        IDM_PARAGRAPH,
        IDM_FORM,
        IDM_MARQUEE,
        IDM_LIST,
        IDM_INDENT,
        IDM_OUTDENT,
        IDM_PREFORMATTED,
        IDM_ADDRESS,
        IDM_BLINK,
        IDM_DIV,
        IDM_TABLEINSERT,
        IDM_ROWINSERT,
        IDM_COLUMNINSERT,
        IDM_CELLINSERT,
        IDM_CAPTIONINSERT,
        IDM_CELLMERGE,
        IDM_CELLSPLIT,
        IDM_CELLSELECT,
        IDM_ROWSELECT,
        IDM_COLUMNSELECT,
        IDM_TABLESELECT,
        IDM_CELLPROPERTIES,
        IDM_TABLEPROPERTIES,
        IDM_HELP_CONTENT,
        IDM_HELP_ABOUT,
        0
    };

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    for (cMenuItem = 0; MenuItem[cMenuItem]; cMenuItem ++)
    {
        msocmd.cmdID = MenuItem[cMenuItem];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fActive)
        {
            hr = pCommandTarget->QueryStatus(
                    (GUID *)&CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
        }

        switch (msocmd.cmdf)
        {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
        }
        CheckMenuItem(hmenuPopup, msocmd.cmdID, mf);
        EnableMenuItem(hmenuPopup, msocmd.cmdID, mf);
    }

    CPadDoc::OnInitMenuPopup(hmenuPopup, uPos, fSystemMenu);

Cleanup:
    ReleaseInterface(pCommandTarget);
    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CPadMessage::GetContextMenu
//
//  Synopsis:   Returns the context menu based on the sub-menu id.
//
//-------------------------------------------------------------------------

HRESULT
CPadMessage::GetContextMenu(HMENU *phmenu, int id)
{
    if (!_hMenuCtx)
    {
        _hMenuCtx = LoadMenu(
                g_hInstResource,
                MAKEINTRESOURCE(IDR_HTMLPAD_CONTEXT_MENU));
        if (!_hMenuCtx)
            goto Error;
    }

    *phmenu = GetSubMenu(_hMenuCtx, id);
    if (!*phmenu)
        goto Error;

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       msgreg.cxx
//
//  Contents:   Stuff to register pad as an Exchange custom form
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_PADRC2_H_
#define X_PADRC2_H_
#include "padrc2.h"
#endif

HRESULT
RegisterOneClass(HKEY hkeyCLSID, TCHAR *pchFile, REFCLSID clsid, TCHAR *pchProgID, TCHAR *pchFriendly);


//+------------------------------------------------------------------------
//
// Function:    WriteFileResource
//
// Synopsis:    Write out a resource as a file in temp directory
//
//-------------------------------------------------------------------------

static HRESULT
WriteFileResource(DWORD dwResId, TCHAR * pchFilePath)
{
    HRESULT hr = E_FAIL;
    HRSRC hrsrc = 0;
    HGLOBAL hglbl = 0;
    void* pvRes;
    DWORD cbRes;
    DWORD cbWritten;
    HANDLE hFile =  INVALID_HANDLE_VALUE;

    hrsrc = FindResource(g_hInstResource, MAKEINTRESOURCE(dwResId), MAKEINTRESOURCE(FILERESOURCE));
    if(!hrsrc)
        goto Cleanup;

    cbRes = SizeofResource(g_hInstResource, hrsrc);
    Assert(cbRes > 0);

    hglbl = LoadResource(g_hInstResource, hrsrc);
    if(!hglbl)
        goto Cleanup;

    pvRes = LockResource(hglbl);
    if(!pvRes)
        goto Cleanup;

    hFile = CreateFile(
                pchFilePath,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    if(!WriteFile(
                hFile,
                pvRes,
                cbRes,
                &cbWritten,
                NULL))
        goto Cleanup;

    Assert(cbWritten == cbRes);

    hr = S_OK;

Cleanup:
    CloseHandle(hFile);
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
// Function:    RegisterMsgServer
//
// Synopsis:    Register PadMessage for this server.
//
//-------------------------------------------------------------------------

static HRESULT
RegisterMsgServer()
{
    HRESULT hr;
    HKEY    hkeyCLSID = 0;
    TCHAR   achExe[MAX_PATH];

    GetModuleFileName(0, achExe, ARRAY_SIZE(achExe));

    hr = THR(RegDbOpenCLSIDKey(&hkeyCLSID));
    if (hr)
        RRETURN(hr);

    hr = THR(RegisterOneClass(
            hkeyCLSID,
            achExe,
            CLSID_CPadMessage,
            _T("IPM.Note.Trident"),
            _T("Trident Message")));
    if (hr)
        goto Cleanup;

Cleanup:
    RegCloseKey(hkeyCLSID);
    RegFlushKey(HKEY_CLASSES_ROOT);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
// Function:    RegisterMsg
//
// Synopsis:    Register PadMessage as an Exchange custom form
//
//-------------------------------------------------------------------------

HRESULT
RegisterMsg(BOOL fDialog)
{
    HRESULT hr;
    LPMAPIFORMCONTAINER pFormContainer;
    TCHAR achFilePath[MAX_PATH];
    TCHAR * pchFileName;
    DWORD cchTempPath;
    char achBuf[MAX_PATH];

    hr = THR(RegisterMsgServer());
    if (hr)
        goto Cleanup;

    cchTempPath = GetTempPath(MAX_PATH, achFilePath);
    if(!cchTempPath)
        goto Cleanup;

    pchFileName = achFilePath + cchTempPath;

    wcscpy(pchFileName, _T("padicon.ico"));

    hr = THR(WriteFileResource(IDF_LARGE_ICON, achFilePath));
    if (hr)
        goto Cleanup;

    wcscpy(pchFileName, _T("padsmall.ico"));

    hr = THR(WriteFileResource(IDF_SMALL_ICON, achFilePath));
    if (hr)
        goto Cleanup;

    wcscpy(pchFileName, _T("msg.cfg"));

    hr = THR(WriteFileResource(IDF_CFG_FILE, achFilePath));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIInitialize(NULL));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIOpenLocalFormContainer(&pFormContainer));
    if (hr)
        goto Cleanup;

    // Mapi needs ANSI
    WideCharToMultiByte(CP_ACP, 0, achFilePath, -1,
                achBuf, sizeof(achBuf), NULL, NULL);

    hr = THR(pFormContainer->InstallForm(
                NULL,
                MAPIFORM_INSTALL_OVERWRITEONCONFLICT,
                (LPCTSTR)achBuf));
    if (hr)
        goto Cleanup;


Cleanup:
    ReleaseInterface(pFormContainer);
    MAPIUninitialize();

    if (fDialog)
    {
        if (!hr)
        {
            MessageBox(NULL,
                       _T("Trident has been installed as an Exchange Form"),
                       _T("Trident Exchange Mail"),
                       MB_OK);
        }
        else
        {
            char ach[300];

            wsprintfA(ach,
                      "Unable to register Trident as an Exchange Form (error %08x).",
                      hr);

            MessageBoxA(NULL,
                        ach,
                        "Trident Exchange Mail",
                        MB_OK);
        }
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
// Function:    UnregisterMsg
//
// Synopsis:    Unregister PadMessage as an Exchange custom form
//
//-------------------------------------------------------------------------

HRESULT
UnregisterMsg()
{
    HRESULT hr;
    LPMAPIFORMCONTAINER pFormContainer;

    hr = THR(MAPIInitialize(NULL));
    if (hr)
        goto Cleanup;

    hr = THR(MAPIOpenLocalFormContainer(&pFormContainer));
    if (hr)
        goto Cleanup;

    hr = THR(pFormContainer->RemoveForm(g_achFormClassName));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pFormContainer);
    MAPIUninitialize();
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgreply.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgreply.cxx
//
//  Contents:   Reply functionality for PadMessage.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGCIDX_H_
#define X_MSGCIDX_H_
#include "msgcidx.h"
#endif

//szRE_PREFIX and szFW_PREFIX have to have the same length
char szRE_PREFIX[] = "RE: ";
char szFW_PREFIX[] = "FW: ";


#define EXCLUDED_PROPS_ON_REPLY     33

SizedSPropTagArray (EXCLUDED_PROPS_ON_REPLY, sptExcludedProps) =
{
    EXCLUDED_PROPS_ON_REPLY,
    {
        PR_SENDER_NAME,
        PR_SENDER_ENTRYID,
        PR_SENDER_SEARCH_KEY,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SENDER_ADDRTYPE,

        PR_RECEIVED_BY_NAME,
        PR_RECEIVED_BY_ENTRYID,
        PR_RECEIVED_BY_SEARCH_KEY,

        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_ENTRYID,
        PR_SENT_REPRESENTING_SEARCH_KEY,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,

        PR_RCVD_REPRESENTING_NAME,
        PR_RCVD_REPRESENTING_ENTRYID,
        PR_RCVD_REPRESENTING_SEARCH_KEY,

        PR_MESSAGE_FLAGS,
        PR_MESSAGE_RECIPIENTS,

        PR_READ_RECEIPT_ENTRYID,
        PR_REPORT_ENTRYID,

        PR_REPLY_RECIPIENT_ENTRIES,
        PR_REPLY_RECIPIENT_NAMES,

        PR_PARENT_KEY,

        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED,

        PR_READ_RECEIPT_REQUESTED,

        PR_CLIENT_SUBMIT_TIME,
        PR_MESSAGE_DELIVERY_TIME,
        PR_MESSAGE_DOWNLOAD_TIME,

        PR_BODY,
        PR_SUBJECT,
        PR_SUBJECT_PREFIX,
        PR_MESSAGE_ATTACHMENTS,

        PR_HTML_BODY,
    }
};


//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::Reply
//
//  Synopsis:   Create a reply message and open a form on it
//
//----------------------------------------------------------------------------

HRESULT CPadMessage::Reply(eREPLYTYPE eReplyType, HWND hwndParent, LPCRECT prect)
{
    HRESULT             hr;
    LONG                cb;
    char *              szSubject = NULL;
    SPropValue          val[2] = {0};
    LPSPropProblemArray pProblems = NULL;
    LPMAPIFORM          pfrmReply = NULL;
    LPPERSISTMESSAGE    ppermsg = NULL;
    LPMAPIMESSAGESITE   pmsgsite = NULL;
    LPMAPIVIEWCONTEXT   pviewctx = NULL;
    LPMESSAGE           pmsg = NULL;
    ULONG               cbNewConvIdx = 0;
    LPBYTE              lpbNewConvIdx = NULL;
    IStream *           pStm;

    Assert(_pmsg);

    // Create new form

    hr = Factory.CreateInstance(NULL, IID_IMAPIForm, (LPVOID FAR *) &pfrmReply);
    if (hr)
    {
        g_LastError.SetLastError(E_OUTOFMEMORY);
        goto err;
    }

    hr = pfrmReply->QueryInterface(IID_IPersistMessage, (LPVOID *) &ppermsg);
    if (hr)
    {
        g_LastError.SetLastError(hr, pfrmReply);
        goto err;
    }

    // Create new message for reply

    hr = _pmsgsite->NewMessage(FALSE, NULL, ppermsg, &pmsg, &pmsgsite, &pviewctx);
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsgsite);
        goto err;
    }

    // Copy message to reply to into the new message

    hr = _pmsg->CopyTo(0, NULL, (LPSPropTagArray)&sptExcludedProps,
                        0, NULL, &IID_IMessage, pmsg, 0, &pProblems);
    if (hr)
    {
        g_LastError.SetLastError(hr, _pmsg);
        goto err;
    }

    if (pProblems)
    {
        //DebugTraceProblems("SmplForm: CopyTo returned ...", pProblems);
        //  if any of the errors is other than MAPI_E_COMPUTED, fail
        for(UINT ind = 0; ind < pProblems->cProblem; ++ind)
        {
            if (MAPI_E_COMPUTED != pProblems->aProblem[ind].scode)
            {
                hr = g_LastError.SetLastError(pProblems->aProblem[ind].scode);
                MAPIFreeBuffer(pProblems);
                pProblems = NULL;
                goto err;

            }
        }
        MAPIFreeBuffer(pProblems);
        pProblems = NULL;
    }

    // Compose reply / forward subject

    if (_pval && _pval[irtNormSubject].ulPropTag == PR_NORMALIZED_SUBJECT_A)
        cb = lstrlenA(_pval[irtNormSubject].Value.lpszA);
    else
        cb = 0;

    hr = MAPIAllocateBuffer(cb+lstrlenA(szRE_PREFIX)+1, (LPVOID FAR *) &szSubject);
    if (hr)
    {
        g_LastError.SetLastError(E_OUTOFMEMORY);
        goto err;
    }

    *szSubject = '\0';

    if (eREPLY == eReplyType || eREPLY_ALL == eReplyType)
    {
        lstrcatA(szSubject, szRE_PREFIX);
    }
    else
    {
        lstrcatA(szSubject, szFW_PREFIX);
    }

    if (cb > 0)
    {
        lstrcatA(szSubject, _pval[irtNormSubject].Value.lpszA);
    }

    val[0].Value.lpszA = szSubject;
    val[0].ulPropTag = PR_SUBJECT_A;

    // Compose reply / forward HTML body

    hr = pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READWRITE, MAPI_CREATE | MAPI_MODIFY,
                            (LPUNKNOWN FAR *) &pStm);
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    hr = ComposeReply(pStm);
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    /*
     * Create a conversation index for the reply msg based on that of ours
     *
     */
    if (!ScAddConversationIndex(_cbConvIdx, _lpbConvIdx,
                                &cbNewConvIdx, &lpbNewConvIdx))
    {
        val[1].ulPropTag = PR_CONVERSATION_INDEX;
        val[1].Value.bin.cb = cbNewConvIdx;
        val[1].Value.bin.lpb = lpbNewConvIdx;
    }
    else
    {
        val[1].ulPropTag = PR_NULL;
    }

    hr = pmsg->SetProps(2, val, &pProblems);

    MAPIFreeBuffer(lpbNewConvIdx);
    lpbNewConvIdx = NULL;

    MAPIFreeBuffer(szSubject);
    szSubject = NULL;

    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    Assert(!pProblems);

#ifdef NEVER
    // if it's a reply, set the addressee
    if (eREPLY == eReplyType || eREPLY_ALL == eReplyType)
    {
        LPADRLIST pal = NULL;

        hr = MAPIAllocateBuffer(CbNewADRLIST(1), (LPVOID FAR *)&pal);
        if (hr)
        {
            _lsterr.SetLastError(E_OUTOFMEMORY);
            goto err;
        }
        hr = _pmsg->GetProps((LPSPropTagArray) &sptSender, 0, &cVal, &pval);
        if (hr) //treat warnings as an error, 'cause the props we ask for are required
        {
            _lsterr.SetLastError(hr, _pmsg);
            MAPIFreeBuffer(pal);
            goto err;
        }

        Assert(cVal == eDim);

        pval[eRecipType].ulPropTag = PR_RECIPIENT_TYPE;
        pval[eRecipType].Value.l = MAPI_TO;

        Assert(pval[eName].ulPropTag == PR_SENDER_NAME_A);
        pval[eName].ulPropTag = PR_DISPLAY_NAME_A;

        Assert(pval[eAddrType].ulPropTag == PR_SENDER_ADDRTYPE);
        pval[eAddrType].ulPropTag = PR_ADDRTYPE;

        Assert(pval[eEID].ulPropTag == PR_SENDER_ENTRYID);
        pval[eEID].ulPropTag = PR_ENTRYID;

        pal->aEntries[0].rgPropVals = pval;

        pal->cEntries = 1;
        pal->aEntries[0].cValues = eDim;

        hr = pmsg->ModifyRecipients(0, pal);
        FreePadrlist(pal); //this will also free pval
        pal = NULL;
        pval = NULL;
        if (hr)
        {
            _lsterr.SetLastError(hr, pmsg);
            goto err;
        }

        if (eReplyType == eREPLY_ALL)
        {
            hr = THR(MungeRecipients(pmsg, TRUE));
            if (hr)
            {
                _lsterr.SetLastError(hr, pmsg);
                goto err;
            }
        }
    }
#endif

    // Set list of recipients

    hr = THR(SetReplyForwardRecipients(pmsg, eReplyType));
    if (hr)
    {
        g_LastError.SetLastError(hr, pmsg);
        goto err;
    }

    // Now load and open new message

    hr = ppermsg->Load(pmsgsite, pmsg, 0, MSGFLAG_UNSENT );
    if (hr)
    {
        g_LastError.SetLastError(hr, ppermsg);
        goto err;
    }

    hr = pfrmReply->DoVerb(EXCHIVERB_OPEN, pviewctx, (ULONG)hwndParent, prect);
    if (hr)
    {
        g_LastError.SetLastError(hr, pfrmReply);
        pfrmReply->ShutdownForm(SAVEOPTS_NOSAVE);
        goto err;
    }

err:
    ReleaseInterface(pfrmReply);
    ReleaseInterface(ppermsg);
    ReleaseInterface(pmsgsite);
    ReleaseInterface(pviewctx);
    ReleaseInterface(pmsg);
    ReleaseInterface(pStm);
    RRETURN(hr);
}


/*
 *  CPadMessage::ZapIfMatch
 *
 *  Purpose:
 *      Compare and optionally zap address entry
 *
 *  Arguments:
 *      pae             Address entry to be zapped
 *      fSearchKey      Whether to use search key to compare
 *      cbFrom          What to compare against
 *      pbFrom          What to compare against
 *      fZap            Whether to zap the entry if it matches
 *      pfMatch         If non-null, indicates if match found
 *
 *  Returns:
 *      SCODE           The status
 */
HRESULT
CPadMessage::ZapIfMatch(
    LPADRENTRY pae,
    BOOL fSearchKey,
    ULONG cbFrom,
    LPBYTE pbFrom,
    BOOL fZap,
    LPBOOL pfMatch)
{
    ULONG           ulResult = 0;
    LPSPropValue    pval;

    if (!pae->rgPropVals)
        return S_OK;

    if (fSearchKey)
    {
        // Get the search key from the address entry and check if this is From.
        // Handle MAPI providers that don't give us one....even though it's
        // a required property!
        pval = PvalFind((LPSRow) pae, PR_SEARCH_KEY);
        if (pval)
            ulResult = (cbFrom == pval->Value.bin.cb) &&
                       !memcmp(pbFrom, pval->Value.bin.lpb, (size_t) cbFrom);
    }
    else    // Entry id
    {
        // Get the entry ID from the address entry and check if this is From.
        // Handle MAPI providers that don't give us one....even though it's
        // a required property!
        pval = PvalFind((LPSRow) pae, PR_ENTRYID);
        if (pval)
            _pses->CompareEntryIDs(cbFrom, (LPENTRYID) pbFrom,
                pval->Value.bin.cb, (LPENTRYID) pval->Value.bin.lpb, 0, &ulResult);
    }

    // If this is the From:, don't add it if the caller so desires
    if (fZap && ulResult)
    {
        MAPIFreeBuffer(pae->rgPropVals);
        pae->cValues = 0;
        pae->rgPropVals = NULL;
    }

    if (pfMatch)
    {
        // Tell the caller if match was found
        *pfMatch = !!ulResult;
    }

    return S_OK;
}


/*
 *  CPadMessage::GetReplieeAdrEntry
 *
 *  Purpose:
 *      Gets the repliee's address entry.
 *
 *  Arguments:
 *      pae             The resulting address entry
 */
static INT  rgivalSender[] =
{
    irtSenderName,
    irtSenderAddrType,
    irtSenderEntryid,
    irtSenderEmailAddress,
    irtSenderSearchKey,
};

static ULONG rgulPropTagRepAdrEntry[] =
{
    PR_DISPLAY_NAME,
    PR_ADDRTYPE,
    PR_ENTRYID,
    PR_EMAIL_ADDRESS,
    PR_SEARCH_KEY
};

#define cvalReplieeAdrEntry (sizeof(rgulPropTagRepAdrEntry) / sizeof(rgulPropTagRepAdrEntry[0]))

HRESULT
CPadMessage::GetReplieeAdrEntry(LPADRENTRY pae)
{
    HRESULT     hr;
    INT         itaga;
    SPropValue  rgval[cvalReplieeAdrEntry + 1];
    ADRENTRY    ae;

    // Capone 11811 Forgot to include recipient type in cValues
    ae.cValues = cvalReplieeAdrEntry + 1;
    ae.rgPropVals = rgval;

    // Set the recipient type
    rgval[0].ulPropTag = PR_RECIPIENT_TYPE;
    rgval[0].Value.ul = MAPI_TO;

    // Copy the individual props to build an adrentry
    // Capone 11811 Skip the recipient type property
    for (itaga = 1; itaga < cvalReplieeAdrEntry + 1; ++itaga)
    {
        rgval[itaga] = _pval[rgivalSender[itaga - 1]];
        rgval[itaga].ulPropTag =
            PROP_TAG(PROP_TYPE(rgval[itaga].ulPropTag),
                        PROP_ID(rgulPropTagRepAdrEntry[itaga - 1]));
    }

    // Copy the adrentry to the real destination
    hr = CopyRow(NULL, (LPSRow) &ae, (LPSRow) pae);

    RRETURN(hr);
}


/*
 *  CPadMessage::SetReplieeEntryId
 *
 *  Purpose:
 *      Adds the address entry into the address list.
 *
 *  Arguments:
 *      pal             The address list
 *      cbEid           The entry id size
 *      peid            The entry id
 *      cch             The name size
 *      rgch            The name
 */
HRESULT
CPadMessage::SetReplieeEntryId(
    LPADRLIST * ppal,
    ULONG cbEid,
    LPENTRYID peid,
    LPSTR szName,
    ULONG * piRepliee)
{
    HRESULT         hr;
    ULONG           cchName;
    ULONG           cbRepliee;
    ADRENTRY        aeRepliee;
    LPSPropValue    rgval = NULL;
    LPBYTE          pbEid;
    char*           pbch;

    // Allocate memory for PropVal array of 3 and byte buffer
    // for the entry id and display name.
    cchName = lstrlenA(szName) + 1;
    cbRepliee = 3 * sizeof(SPropValue) + cbEid + cchName;
    hr = THR(MAPIAllocateBuffer(cbRepliee, (void**)&rgval));
    if (hr)
    {
        g_LastError.SetLastError(hr);
        goto Cleanup;
    }

    // Put entry id into address entry
    pbEid = (LPBYTE) &rgval[3];
    memcpy(pbEid, peid, (size_t) cbEid);
    rgval[0].ulPropTag = PR_ENTRYID;
    rgval[0].Value.bin.cb = cbEid;
    rgval[0].Value.bin.lpb = pbEid;

    // Put display name into address entry
    pbch = (char*)(pbEid + cbEid);
    lstrcpyA(pbch, szName);
    rgval[1].ulPropTag = PR_DISPLAY_NAME;
    rgval[1].Value.lpszA = pbch;

    // Put recipient type into address entry
    rgval[2].ulPropTag = PR_RECIPIENT_TYPE;
    rgval[2].Value.l = MAPI_TO;

    aeRepliee.cValues = 3;
    aeRepliee.rgPropVals = rgval;

    // Add the sender to the To: field
    hr = THR(AddRecipientToAdrlist(ppal, &aeRepliee, piRepliee));

    // I'm not supposed to free rgval here!

Cleanup:
    RRETURN(hr);
}


/*
 *  ScSetReplyForwardRecipients
 *
 *  Purpose:
 *      Sets up recipient list for a new message that is being replied to or
 *      forwarded.
 *
 *  Arguments:
 *      pmsgResend      reply message
 *
 *  Returns:
 *      SCODE           The status
 *
 *  Notes:
 *      Since the original recipient list was excluded when this reply
 *      message was created, we should only include things we want.
 *      Below, "Replier" means the user replying, and Replyee means the
 *      person to whom the reply is sent (normally From, but can be overrided).
 */
HRESULT
CPadMessage::SetReplyForwardRecipients(LPMESSAGE pmsgResend, eREPLYTYPE eReplyType)
{
    HRESULT         hr = S_OK;
    LPADRLIST       pal = NULL;
    LPSPropValue    pval = NULL;
    ULONG           iae = 0;
    LPADRENTRY      pae = NULL;
    LPSPropValue    pvalRepliee;
    LPSPropValue    pvalReplieeSearchKey = NULL;
    LPSPropValue    pvalReplier;

    LPFLATENTRYLIST pfel = NULL;
    LPFLATENTRY     pfe;
    LPBYTE          pbfe;
    ULONG           ife;

    INT             cRepliee = 0;
    ULONG *         rgiRepliee = NULL;
    INT             iRepliee;

    LPSPropValue    pvalRepRecNames;
    LPSTR           szRepRecNames = NULL;

    if (eReplyType == eREPLY_ALL)
    {
        // Reply all - Get recipient rows
        hr = THR(GetMsgAdrlist(_pmsg, (LPSRowSet*)&pal, &g_LastError));
        if (hr)
        {
            goto Cleanup;
        }

        Assert(pal);
    }

    // Get name(s) for To: field from PR_REPLY_RECIPIENT_ENTRIES (if present)

    // Find out who is (are) the repliee(s)
    pvalRepliee = &_pval[irtReplyRecipientEntries];
    if (pvalRepliee->ulPropTag != PR_REPLY_RECIPIENT_ENTRIES)
    {
        AssertSz(pvalRepliee->Value.err == MAPI_E_NOT_FOUND, "No reply_recipient_entries");

        // Use Sender_XXX

        if (_pval[irtSenderSearchKey].ulPropTag
                                            == PR_SENDER_SEARCH_KEY)
        {
            pvalReplieeSearchKey = &_pval[irtSenderSearchKey];
            cRepliee = 1;
        }
    }
    else
    {
        // We have Reply_Recipient_Entries

        pfel = (LPFLATENTRYLIST) pvalRepliee->Value.bin.lpb;
        Assert(pvalRepliee->Value.bin.cb == CbFLATENTRYLIST(pfel));
        cRepliee = (INT) pfel->cEntries;
    }

    // Exchange 29007
    // Expand fix for Exchange 10764 to Reply_Recipient_Entries.
    if (cRepliee)
    {
        rgiRepliee = (ULONG *) new ULONG[cRepliee];
        if (!rgiRepliee)
        {
            hr = _lsterr.SetLastError(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    pvalReplier = &_pval[irtReceivedBySearchKey];
    if (pvalReplier->ulPropTag != PR_RECEIVED_BY_SEARCH_KEY)
    {
        pvalReplier = NULL;
    }

    // Put the current Repliee (From) or the Reply_Recipient_Entries
    // into the To well for Reply and Reply All

    if (eReplyType != eFORWARD)
    {
        if (pfel)   // Reply_Recipient_Entries
        {
            char * pchName;     // Current name
            char * pchNext;     // Next name
#if DBG == 1
            char * pchFirst;    // First name
            ULONG cchTotal;     // Length of names string
#endif // DEBUG

            // Get the reply_recipient_names
            pvalRepRecNames = &_pval[irtReplyRecipientNames];
            if (pvalRepRecNames->ulPropTag != PR_REPLY_RECIPIENT_NAMES)
              //$ ISSUE -- Should this report an error?
                goto Cleanup;

            // Initialize vars
            szRepRecNames = new char(lstrlenA(pvalRepRecNames->Value.lpszA)+1);
            lstrcpyA(szRepRecNames, pvalRepRecNames->Value.lpszA);
            pchName = pchNext = szRepRecNames;
#if DBG == 1
            pchFirst = szRepRecNames;
            cchTotal = lstrlenA(szRepRecNames);
#endif // DEBUG

            // Loop through the reply_recipient_entries
            for (ife = 0, pbfe = pfel->abEntries;
                    ife < pfel->cEntries;
                    ife++,
                    pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
            {
                pfe = (LPFLATENTRY) pbfe;

                // Find the end of the current display name
                while (*pchNext != TEXT(';') && *pchNext != TEXT('\0'))
                {
#if DBG == 1
                    Assert((ULONG) (pchNext - pchFirst) < cchTotal);
#endif
                    pchNext++;
                }

                // Stringify the display name of the current entry id
                if (*pchNext == TEXT(';'))
                {
                    *pchNext = TEXT('\0');
                    pchNext++;
                }
#if DBG == 1
                else    // End of string; Last name for last entry
                {
                    Assert(ife + 1 == pfel->cEntries);
                }
#endif // DEBUG

                // Set the current entry id as a repliee
                hr = THR(SetReplieeEntryId(&pal, pfe->cb,
                        (LPENTRYID) pfe->abEntry, pchName, &rgiRepliee[ife]));
                if (hr)
                    goto Cleanup;

                // Start of next display name
                pchName = pchNext;
            }
        }
        else    // No Reply_Recipient_Entries
        {
            ADRENTRY        aeRepliee;

            // Pull out the values
            hr = THR(GetReplieeAdrEntry(&aeRepliee));
            if (hr)
                goto Cleanup;

            // Exchange 6756
            // Handle a reply or reply all message with an "empty" address
            // list because the original message did not have a sender.
            if (PvalFind((LPSRow) &aeRepliee, PR_ENTRYID) ||
                PvalFind((LPSRow) &aeRepliee, PR_DISPLAY_NAME))
            {
                hr = THR(AddRecipientToAdrlist(&pal, &aeRepliee, rgiRepliee));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                MAPIFreeBuffer(aeRepliee.rgPropVals);
            }
        }
    }

    // Remove Replier and Repliee from the wells. (Capone spec 1.12 8-42)

    if (eReplyType == eREPLY_ALL)
    {
        // Remove Replier (Me) from the To well.
        // Remove Replier (Me) and Repliee (From) from the Cc well.

        LPADRENTRY  paeMeInToList = NULL;
        ULONG       cEntriesInToList = 0;

        for (iae = 0, pae = pal->aEntries; iae < pal->cEntries; iae++, pae++)
        {
            // Can't let the store see a TRUE PR_RESPONSIBLITY here
            pval = PvalFind((LPSRow) pae, PR_RESPONSIBILITY);
            if (pval)
                pval->Value.b = FALSE;

            pval = PvalFind((LPSRow) pae, PR_RECIPIENT_TYPE);
            AssertSz(pval, "Address list entry w/o recipient type");
            // Capone 12398 Another missing required property!
            if (!pval)
            {
                // Kill and skip this entry
                MAPIFreeBuffer(pae->rgPropVals);
                pae->cValues = 0;
                pae->rgPropVals = NULL;
                continue;
            }

            switch (pval->Value.ul)
            {
            case MAPI_BCC:
                // Kill Bcc always
                MAPIFreeBuffer(pae->rgPropVals);
                pae->cValues = 0;
                pae->rgPropVals = NULL;
                break;

            case MAPI_CC:
                if (pfel)   // Reply_Recipient_Entries
                {
                    for (ife = 0, pbfe = pfel->abEntries;
                            ife < pfel->cEntries;
                            ife++,
                            pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
                    {
                        pfe = (LPFLATENTRY) pbfe;

                        // If this is the Repliee (From), have it removed
                        hr = THR(ZapIfMatch(pae, FALSE,
                                    pfe->cb, pfe->abEntry, TRUE, NULL));
                        if (hr)
                            goto Cleanup;
                    }
                }
                else if (pvalReplieeSearchKey)  // No Reply_Recipient_Entries
                {
                    // If this is the Repliee (From), have it removed
                    hr = THR(ZapIfMatch(pae, TRUE,
                            pvalReplieeSearchKey->Value.bin.cb,
                            pvalReplieeSearchKey->Value.bin.lpb, TRUE, NULL));
                    if (hr)
                        goto Cleanup;
                }

                // If this is the Replier (Me), have it removed
                if (pvalReplier)
                {
                    hr = THR(ZapIfMatch(pae, TRUE,
                        pvalReplier->Value.bin.cb, pvalReplier->Value.bin.lpb,
                        TRUE, NULL));
                    if (hr)
                        goto Cleanup;
                }
                break;

            case MAPI_TO:
                // If this is the Replier (Me), see if it needs to be
                // removed.
                // RAID 10764: Duplicate Repliees also need to be
                // removed from the To: list.
                // We know where the one we added is - we keep it

                // Exchange 29007
                // Expand fix for Exchange 10764 to Reply_Recipient_Entries.
                for (iRepliee = 0; iRepliee < cRepliee; iRepliee++)
                    if (iae == (ULONG) rgiRepliee[iRepliee])
                        break;

                if (cRepliee && (iRepliee == cRepliee))
                {
                    BOOL fMatch = FALSE;

                    if (pfel)   // Reply_Recipient_Entries
                    {
                        for (ife = 0, pbfe = pfel->abEntries;
                                ife < pfel->cEntries;
                                ife++,
                                pbfe += PAD4(CbFLATENTRY((LPFLATENTRY) pbfe)))
                        {
                            pfe = (LPFLATENTRY) pbfe;

                            // If this is the Repliee (From), have it removed
                            hr = THR(ZapIfMatch(pae, FALSE,
                                        pfe->cb, pfe->abEntry, TRUE, &fMatch));
                            if (hr)
                                goto Cleanup;
                        }
                    }
                    else if (pvalReplieeSearchKey)  // No Reply_Recipient_Entries
                    {
                        // If this is the Repliee (From), have it removed
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplieeSearchKey->Value.bin.cb,
                                pvalReplieeSearchKey->Value.bin.lpb, TRUE, &fMatch));
                        if (hr)
                            goto Cleanup;
                    }

                    // Current entry zapped so move on to the next one
                    if (fMatch)
                        break;
                }

                if (pvalReplier)
                {
                    BOOL fMatch;

                    if (paeMeInToList)
                    {
                        // We have found the replier in the To: well,
                        // if there are any more, they need to be zapped.
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplier->Value.bin.cb,
                                pvalReplier->Value.bin.lpb,
                                TRUE /*fZap*/, &fMatch));
                        if (hr)
                            goto Cleanup;

                        // If entry did not get zapped, bump the To: entry
                        // count.
                        if (!fMatch)
                            cEntriesInToList++;
                    }
                    else
                    {
                        // See if we have the replier here. If so,
                        // remember the entry, but don't zap it yet.
                        hr = THR(ZapIfMatch(pae, TRUE,
                                pvalReplier->Value.bin.cb,
                                pvalReplier->Value.bin.lpb,
                                FALSE, &fMatch));
                        if (hr)
                            goto Cleanup;

                        if (fMatch)
                            paeMeInToList = pae;

                        // Match or no match, the entry is still in the
                        // To list, so bump our To list count.
                        cEntriesInToList++;
                    }
                }

                break;
            }
        }

        // If Replier (Me) is in TO well, and there are others too,
        // remove the Replier. The only case the Replier does not get
        // removed is when it's the only one in the list.

        if (paeMeInToList && cEntriesInToList > 1)
        {
            // Kill Replier's entry in the list
            MAPIFreeBuffer(paeMeInToList->rgPropVals);
            paeMeInToList->cValues = 0;
            paeMeInToList->rgPropVals = NULL;
        }
    }

    // Set new list of recipients

    if (pal && pal->cEntries)
    {
        // Record changes in recipient table
        hr = THR(pmsgResend->ModifyRecipients(MODRECIP_ADD, pal));
        if (hr)
		{
			g_LastError.SetLastError(hr, pmsgResend);
			goto Cleanup;
		}
	}

Cleanup:
    delete rgiRepliee;
    delete szRepRecNames;
    RRETURN(hr);
}

///     GetMsgAdrlist
//    retrieves recipients adrlist of a message
HRESULT GetMsgAdrlist (LPMESSAGE pmsg, LPSRowSet * ppRowSet, CLastError * plasterror)
{
    *ppRowSet = NULL;

    LPMAPITABLE pTable = NULL;
    HRESULT hr;

    hr = pmsg->GetRecipientTable (0, &pTable);
    if (!hr)
    {
        hr = HrQueryAllRows(pTable, NULL, NULL, NULL, 0, ppRowSet);
        if (hr)
        {
            plasterror->SetLastError(hr, pTable);
        }
    }
    else
    {
        plasterror->SetLastError(hr, pmsg);
    }

    pTable->Release();

    return hr;
}

HRESULT CPadMessage::ComposeReply(IStream * pStm)
{
    char *     pch;
    char *     pchStartBody;
    char *     pchReplyHeader = NULL;
    char       achTime[256];

    int        cbToWrite;
    int        cb;
    HRESULT    hr = S_OK;
    BOOL       fDeletePch = FALSE;

    if(_pObject && _pObject)
    {
        hr = THR(SaveAsString(&pch));
        if (hr)
            goto Cleanup;

        fDeletePch = TRUE;
    }
    else if (_pval && _pval[irtHtmlBody].ulPropTag == PR_HTML_BODY)
    {
        pch = _pval[irtHtmlBody].Value.lpszA;
    }
    else
    {
        hr = THR(GetHtmlBodyFromMsg(&pch));
        if (hr)
            goto Cleanup;

        fDeletePch = TRUE;
    }

    pchStartBody = strstr( pch, "<BODY");
    if(pchStartBody)
    {
        pchStartBody = strchr(pchStartBody,'>');
        if( pchStartBody == NULL )
        {
            pchStartBody = strstr( pch, "<body");
            pchStartBody = strchr(pchStartBody,'>');
            Assert(pchStartBody);
        }
        pchStartBody++;
    }
    else
    {
        pchStartBody = pch;
    }

    cbToWrite = pchStartBody - pch;

    if(cbToWrite)
    {
        hr = pStm->Write(pch,(ULONG) cbToWrite, NULL);
        if(hr)
            goto Cleanup;
    }

    // TODO: chrisf - should properly define the length below instead of using 500
    // Need to be large enough to accomodate all litteral HTML below
    cb = 500;

    if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
         cb += lstrlenA(_pval[irtSenderName].Value.lpszA);

    if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
         cb += lstrlenA(_pval[irtTo].Value.lpszA);

    if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
         cb += lstrlenA(_pval[irtCc].Value.lpszA);

    if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
         cb += lstrlenA(_pval[irtSubject].Value.lpszA);

    if (_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME)
    {
        FormatTime(&_pval[irtTime].Value.ft, achTime, sizeof(achTime));
        cb += lstrlenA(achTime);
    }
    else
    {
        achTime[0] = '\0';
    }

    pchReplyHeader = new char[cb];
    if(!pchReplyHeader)
        goto Cleanup;

    strcpy(pchReplyHeader,"<P>&nbsp<P><HR ALIGN=LEFT><ADDRESS><STRONG>From: </STRONG>");
    if (_pval[irtSenderName].ulPropTag == PR_SENDER_NAME_A)
        strcat(pchReplyHeader,_pval[irtSenderName].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Sent: </STRONG>");
    strcat(pchReplyHeader,achTime);

    strcat(pchReplyHeader,"<BR><STRONG>To: </STRONG>");
    if (_pval[irtTo].ulPropTag == PR_DISPLAY_TO_A)
        strcat(pchReplyHeader,_pval[irtTo].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Cc: </STRONG>");
    if (_pval[irtCc].ulPropTag == PR_DISPLAY_CC_A)
        strcat(pchReplyHeader,_pval[irtCc].Value.lpszA);

    strcat(pchReplyHeader,"<BR><STRONG>Subject: </STRONG>");
    if (_pval[irtSubject].ulPropTag == PR_SUBJECT_A)
        strcat(pchReplyHeader,_pval[irtSubject].Value.lpszA);

    strcat(pchReplyHeader,"<BR>&nbsp</ADDRESS>");

    cb = strlen(pchReplyHeader);

    hr = pStm->Write(pchReplyHeader,(ULONG) cb, NULL);
    if(hr)
        goto Cleanup;

    cb = strlen(pch);
    cbToWrite = cb - cbToWrite;

    hr = pStm->Write(pchStartBody,(ULONG) cbToWrite, NULL);
    if(hr)
        goto Cleanup;

Cleanup:
    delete pchReplyHeader;
    if (fDeletePch)
        delete pch;
    RRETURN(hr);
}

HRESULT
CPadMessage::SaveAsString(char ** ppchBuffer)
{
    IStream *   pStm;
    STATSTG     StatStg;
    LONG        cStmLength;
    char *      pch = NULL;
    HRESULT     hr;
    LARGE_INTEGER i64Start = {0, 0};

    hr = CreateStreamOnHGlobal(NULL, NULL, &pStm);
    if (hr)
        goto err;

    hr = CPadDoc::Save(pStm);
    if (hr)
        goto err;

    Verify(pStm->Stat(&StatStg,NULL) == S_OK);

    cStmLength = StatStg.cbSize.LowPart;

    pch = new char[cStmLength+1];
    if(!pch)
        goto err;

    hr = pStm->Seek(i64Start, STREAM_SEEK_SET, NULL);
    if (hr)
        goto err;

    hr = pStm->Read(pch, cStmLength, NULL);
    if (hr)
        goto err;

    pch[cStmLength] = '\0';

    *ppchBuffer = pch;

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);

err:
    delete pch;
    goto Cleanup;
}

HRESULT
CPadMessage::GetHtmlBodyFromMsg(char ** ppchBuffer)
{
    HRESULT     hr;
    STATSTG     StatStg;
    IStream *   pStm;
    LONG        cStmLength;
    char *      pch = NULL;
    LARGE_INTEGER i64Start = {0, 0};

    Assert(_pmsg);

    hr = THR(_pmsg->OpenProperty(PR_HTML_BODY, &IID_IStream,
                            STGM_READ, 0, (LPUNKNOWN FAR *) &pStm));

    if (hr)
        goto Cleanup;

    Verify(pStm->Stat(&StatStg,NULL) == S_OK);

    cStmLength = StatStg.cbSize.LowPart;

    pch = new char[cStmLength+1];
    if(!pch)
        goto err;

    hr = pStm->Seek(i64Start, STREAM_SEEK_SET, NULL);
    if (hr)
        goto err;

    hr = pStm->Read(pch, cStmLength, NULL);
    if (hr)
        goto err;

    pch[cStmLength] = '\0';

    *ppchBuffer = pch;

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);

err:
    delete pch;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgutil.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddoc.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

/*
 *	PvalFind
 *	
 *	Purpose:
 *		Given the row prw, finds the first property whose tag is
 *		ulPropTag.
 *	
 *	Arguments:
 *		prw			The row to seek.
 *		ulPropTag	The property tag we're seeking.
 *	
 *	Returns:
 *		A pointer to the SPropValue with the desired property tag, or
 *		NULL if no such SPropValue was found.
 */
LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag)
{
	UINT			ival;
	LPSPropValue	pval;

	ival = (UINT) prw->cValues;
	pval = prw->lpProps;
	if (PROP_TYPE(ulPropTag) != PT_NULL)
	{
		while (ival--)
		{
			if (pval->ulPropTag == ulPropTag)
				return pval;
			++pval;
		}
	}
	else	// Ignore property type (error)
	{
		ULONG ulPropId = PROP_ID(ulPropTag);

		while (ival--)
		{
			if (PROP_ID(pval->ulPropTag) == ulPropId)
				return pval;
			++pval;
		}
	}
	return NULL;
}


/*
 *	FreeSRowSet
 *
 *	Purpose:
 *		Frees an SRowSet structure and the rows therein
 *
 *	Parameters:
 *		LPSRowSet		The row set to free
 */

VOID FreeSRowSet(LPSRowSet prws)
{
	ULONG irw;

	if (!prws)
		return;

	// Free each row
	for (irw = 0; irw < prws->cRows; irw++)
		MAPIFreeBuffer(prws->aRow[irw].lpProps);

	// Free the top level structure
	MAPIFreeBuffer(prws);
}


/*
 *	CopyRow
 *	
 *	Purpose:
 *		This function copies the properties of one row to another. If <pv> is
 *		NULL then MAPIAllocateBuffer is used to allocate the storage for
 *		<prwDst>. If <pv> is non NULL it is assumed to be a pointer to a
 *		MAPIAllocateBuffer(d) chunk of memory so MAPIAllocateMore is used to
 *		allocate the storage for <prwDst>.
 *	
 *	Parameters:
 *		pv			in		chunk of memory
 *		prwSrc		in		source row
 *		prwDst		out		destination row
 *	
 *	Returns:
 *		sc
 */
HRESULT CopyRow(LPVOID pv, LPSRow prwSrc, LPSRow prwDst)
{
	HRESULT	        hr = S_OK;
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	BYTE *			pb;
	ULONG			cb;

	if (prwSrc->cValues == 0)
	{
		// Handle the empty row case (Raid 3300)

		prwDst->cValues = 0;
		prwDst->lpProps = NULL;
		return S_OK;
	}

	// Compute the size needed to store the row in its entirety.

	pvalSrc = prwSrc->lpProps;
	for (iCol = prwSrc->cValues, cb = 0L; iCol > 0; ++pvalSrc, --iCol)
	{
		cb += PAD4(CbForPropValue(pvalSrc)) + sizeof (SPropValue);
	}

	// Allocate enough room for the new copy of the SPropValue.

	if (pv)
		hr = THR(MAPIAllocateMore(cb, pv, (void**)&prwDst->lpProps));
	else
		hr = THR(MAPIAllocateBuffer(cb, (void**)&prwDst->lpProps));

	if (hr)
		goto Cleanup;

	// Do the finicky copy of the items one-by-one.

	pvalDst = prwDst->lpProps;
	pvalSrc = prwSrc->lpProps;
	iCol = prwDst->cValues = prwSrc->cValues;
	pb = (BYTE *) (pvalDst + iCol);		// point past the rgSPropValue.

	while (iCol--)
	{
		pb = CopyPval(pvalSrc, pvalDst, pb, NULL, imodeCopy);
		++pvalSrc;
		++pvalDst;
	}
	
Cleanup:
    RRETURN(hr);
}


/*
 *	CbForPropValue
 *	
 *	Purpose:
 *		Determines how many bytes are needed for storage of the
 *		property pv, in addition to the space taken up by the SPropValue
 *		itself.
 *	Arguments:
 *		pv		The SPropValue of the property.
 *	Returns:
 *		A count of the bytes needed to store this thing
 */
ULONG CbForPropValue(LPSPropValue pval)
{
	ULONG	cb;
	
	switch (PROP_TYPE(pval->ulPropTag))
	{
		// Types whose values fit in the 64-bit Value of the property.
	  case PT_I2:
	  case PT_I8:
	  case PT_LONG:
	  case PT_R4:
	  case PT_DOUBLE:
	  case PT_CURRENCY:
	  case PT_ERROR:
	  case PT_BOOLEAN:
	  case PT_SYSTIME:
	  case PT_APPTIME:
	  case PT_NULL:
		return 0;
	  case PT_BINARY:
		cb = pval->Value.bin.cb;
		break;
	  case PT_STRING8:
		cb = (lstrlenA(pval->Value.lpszA) + 1) * sizeof (CHAR);
		break;
	  case PT_UNICODE:
		cb = (lstrlenW(pval->Value.lpszW) + 1) * sizeof (WCHAR);
		break;
	  case PT_CLSID:
		cb = sizeof (GUID);
		break;

		// Multi-valued properties.
	  case PT_MV_I2:
		cb = pval->Value.MVi.cValues * sizeof (short int);
		break;
	  case PT_MV_LONG:
		cb = pval->Value.MVl.cValues * sizeof (LONG);
		break;
	  case PT_MV_R4:
		cb = pval->Value.MVflt.cValues * sizeof (float);
		break;
	  case PT_MV_DOUBLE:
	  case PT_MV_APPTIME:
		cb = pval->Value.MVdbl.cValues * sizeof (double);
		break;
	  case PT_MV_CURRENCY:
		cb = pval->Value.MVcur.cValues * sizeof (CURRENCY);
		break;
	  case PT_MV_SYSTIME:
		cb = pval->Value.MVat.cValues * sizeof (FILETIME);
		break;
//$	case PT_MV_I8:
//		cb = pval->Value.MVli.cValues * sizeof (LARGE_INTEGER);
		break;
	  case PT_MV_BINARY:
		{
		//	Multi-valued binaries are copied in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, pb1 ... cbn, pbn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and pbn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus pb1 points
		//	to the b1,0, etc.

			SBinaryArray *	pbina = &pval->Value.MVbin;
			ULONG			uliValue;
			SBinary *		pbinSrc;

			cb = pbina->cValues * sizeof (SBinary);

			for (uliValue = 0, pbinSrc = pbina->lpbin;
					uliValue < pbina->cValues;
					uliValue++, pbinSrc++)
			{
				cb += pbinSrc->cb;
			}
			break;
		}
	  case PT_MV_STRING8:
		{
		//	Multi-valued STRING8 properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszA1, pszA2 ... | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where pszAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each pszAn points
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.

			SLPSTRArray *	pSLPSTRArray = &pval->Value.MVszA;
			ULONG			uliValue;
			LPSTR *			pszASrc;

			//	Figure out the size of the buffer we need

			cb = pSLPSTRArray->cValues * sizeof (LPSTR);

			for (uliValue = 0, pszASrc = pSLPSTRArray->lppszA;
					uliValue < pSLPSTRArray->cValues;
					uliValue++, pszASrc++)
			{
				cb += (lstrlenA(*pszASrc) + 1) * sizeof (CHAR);
			}
			break;
		}

	  case PT_MV_UNICODE:
		{
		//	Multi-valued UNICODE properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszW1, pszW2 ... | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPWSTR array   |     String data    |
		//
		//	Where pszWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each pszWn points
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.

			SWStringArray *	pSWStringArray = &pval->Value.MVszW;
			ULONG			uliValue;
			LPWSTR *		pszWSrc;

			//	Figure out the size of the buffer we need

			cb = pSWStringArray->cValues * sizeof (LPWSTR);

			for (uliValue = 0, pszWSrc = pSWStringArray->lppszW;
					uliValue < pSWStringArray->cValues;
					uliValue++, pszWSrc++)
			{
				cb += (lstrlenW(*pszWSrc) + 1) * sizeof (WCHAR);
			}
			break;
		}
	  case PT_UNSPECIFIED:
	  case PT_OBJECT:
	  default:
		cb = 0;
		break;
	}
	return cb;
}


/*
 *	CopyPropValue
 *	
 *	Purpose:
 *		Copies the property from pvSrc to pvDst. This is done by copying
 *		the LPSPropValue at pvSrc to pvDst, and copying any external data
 *		to pbIn.
 *	Arguments:
 *		pvSrc		Source property
 *		pvDst		Destination property
 *		pb			Pointer to buffer area for strings, binaries, &c.
 *		ppbDest		(for imodeUnflatten) pb for destination row
 *		imode		One of:
 *						imodeCopy		- straight row copy
 *						imodeFlatten	- flatten out row to buffer
 *						imodeUnflatten	- unflatten buffer to row
 *	
 *	Returns:
 *		The updated PB, which should be on an aligned boundary.
 */
LPBYTE CopyPval(LPSPropValue pvalSrc, LPSPropValue pvalDst,
			   LPBYTE pb, LPBYTE * ppbDest, UINT imode)
{
	ULONG			cb;
	LPBYTE			pbSrc;
	LPBYTE FAR *	ppbDst;

	*pvalDst = *pvalSrc;
	switch (PROP_TYPE(pvalDst->ulPropTag))
	{
		//	Types whose values fit in the 64-bit Value of the property
	  case PT_I2:
	  case PT_I8:
	  case PT_LONG:
	  case PT_R4:
	  case PT_DOUBLE:
	  case PT_CURRENCY:
	  case PT_ERROR:
	  case PT_BOOLEAN:
	  case PT_SYSTIME:
	  case PT_APPTIME:
	  case PT_NULL:
		return pb;
	}
	
	switch (PROP_TYPE(pvalDst->ulPropTag))
	{
	  case PT_BINARY:
		pbSrc	= pvalSrc->Value.bin.lpb;
		ppbDst	= &pvalDst->Value.bin.lpb;
		break;

	  case PT_STRING8:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpszA;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpszA;
		break;

	  case PT_UNICODE:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpszW;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpszW;
		break;

	  case PT_CLSID:
		pbSrc	= (LPBYTE) pvalSrc->Value.lpguid;
		ppbDst	= (LPBYTE *) &pvalDst->Value.lpguid;
		break;

	  case PT_MV_I2:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVi.lpi;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVi.lpi;
		break;

	  case PT_MV_LONG:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVl.lpl;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVl.lpl;
		break;

	  case PT_MV_R4:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVflt.lpflt;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVflt.lpflt;
		break;

	  case PT_MV_DOUBLE:
	  case PT_MV_APPTIME:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVdbl.lpdbl;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVdbl.lpdbl;
		break;

	  case PT_MV_CURRENCY:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVcur.lpcur;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVcur.lpcur;
		break;

	  case PT_MV_SYSTIME:
		pbSrc	= (LPBYTE) pvalSrc->Value.MVat.lpat;
		ppbDst	= (LPBYTE *) &pvalDst->Value.MVat.lpat;
		break;

//$	  case PT_MV_I8:
// 		pbSrc	= (LPBYTE) pvalSrc->Value.MVli.lpli;
// 		ppbDst	= (LPBYTE *) &pvalDst->Value.MVli.lpli;
// 		break;

	  case PT_MV_BINARY:
		{
		//	Multi-valued binaries are copied in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, pb1 ... cbn, pbn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and pbn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus pb1 points
		//	to the b1,0, etc.

		//	Multi-valued binaries are flattened in memory into a single
		//	allocated buffer in the following way:
		//
		//		cb1, ib1 ... cbn, ibn, b1,0, b1,1 ... b2,0 b2,1 ...
		//
		//	The cbn and ibn parameters form the SBinary array that
		//	will be pointed to by pvalDst->Value.MVbin.lpbin.
		//	The remainder of the allocation is used to store the binary
		//	data for each of the elements of the array.  Thus ib1 contains
		//	the offset from the beginning of the allocated buffer
		//	to the b1,0, etc.
		//	The pvalDst->Value.MVbin.lpbin contains the size of the allocated
		//	buffer.

			SBinaryArray *	pbina = &pvalSrc->Value.MVbin;
			ULONG			iVal;
			SBinary *		pbinSrc;
			SBinary *		pbinDst;

			if (imode == imodeCopy)
			{
				//	And copy it all in

				pbinDst = (LPSBinary) pb;
				pvalDst->Value.MVbin.lpbin = pbinDst;
				pb = (LPBYTE) (pbinDst + pbina->cValues);

				for (iVal = 0, pbinSrc = pbina->lpbin;
						iVal < pbina->cValues;
						iVal++, pbinSrc++, pbinDst++ )
				{
					pbinDst->cb = pbinSrc->cb;
					pbinDst->lpb = pb;
					CopyMemory(pb, pbinSrc->lpb, (UINT) pbinSrc->cb);
					pb += pbinSrc->cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the data into the buffer and set offsets
				//	to them in the SBinary array at the beginning of the buffer

				pbinDst = (LPSBinary) pb;
				pb = (LPBYTE) (pbinDst + pbina->cValues);
				ib = pbina->cValues * sizeof(SBinary);

				//	Copy the data into the buffer and set offsets
				//	to them in the SBinary array at the beginning of the buffer

				for (iVal = 0, pbinSrc = pbina->lpbin;
						iVal < pbina->cValues;
						iVal++, pbinSrc++, pbinDst++ )
				{
					pbinDst->cb = pbinSrc->cb;
					pbinDst->lpb = (LPBYTE) ib;
					CopyMemory(pb, pbinSrc->lpb, (UINT) pbinSrc->cb);
					pb += pbinSrc->cb;
					ib += pbinSrc->cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVbin.lpbin = (LPSBinary) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG 		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pbina->lpbin;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to data back into pointers to
					//	strings

					pvalDst->Value.MVbin.lpbin = pbinDst = (LPSBinary) *ppbDest;
					ulBase = (ULONG) pbinDst;
					for (iVal = 0;
							iVal < pbina->cValues;
							iVal++, pbinDst++)
					{
						pbinDst->lpb = (LPBYTE) (ulBase + (ULONG) pbinDst->lpb);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_MV_STRING8:
		{
		//	Multi-valued STRING8 properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszA1, pszA2 ... | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where pszAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each pszAn points
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.

		//	Multi-valued STRING8 properties are flattened into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| ibA1, ibA2 ...   | szA1[], szA2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where ibAn are the elements of the LPSTR array pointed
		//	to by pvalDst->Value.MVszA.  Each ibAn contains an offset
		//	the beginning of the allocated buffer
		//	to its corresponding string, szAn, stored later in the
		//	buffer.  The szAn are stored starting at the first byte
		//	past the end of the LPSTR array.
		//	The pvalDst->Value.MVszA contains the size of the allocated
		//	buffer.

			SLPSTRArray *	pSLPSTRArray = &pvalSrc->Value.MVszA;
			ULONG			iVal;
			LPSTR *			pszSrc;
			LPSTR *			pszDst;

			if (imode == imodeCopy)
			{
				//	Allocate the buffer to hold the strings

				pszDst = (LPSTR *) pb;
				pvalDst->Value.MVszA.lppszA = pszDst;
				pb = (LPBYTE) (pszDst + pSLPSTRArray->cValues);

				//	Copy the strings into the buffer and set pointers
				//	to them in the LPSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSLPSTRArray->lppszA;
						iVal < pSLPSTRArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenA(*pszSrc) + 1) * sizeof (CHAR);

					*pszDst = (LPSTR) pb;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPSTR array at the beginning of the buffer

				pszDst = (LPSTR *) pb;
				pb = (LPBYTE) (pszDst + pSLPSTRArray->cValues);
				ib = pSLPSTRArray->cValues * sizeof(LPSTR *);

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSLPSTRArray->lppszA;
						iVal < pSLPSTRArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenA(*pszSrc) + 1) * sizeof (CHAR);

					*pszDst = (LPSTR) ib;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
					ib += cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVszA.lppszA = (LPSTR *) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG 		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pSLPSTRArray->lppszA;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to strings back into pointers to
					//	strings

					pvalDst->Value.MVszA.lppszA = pszDst = (LPSTR *) *ppbDest;
					ulBase = (ULONG) pszDst;
					for (iVal = 0;
							iVal < pSLPSTRArray->cValues;
							iVal++, pszDst++)
					{
						*pszDst = (LPSTR) (ulBase + (ULONG) *pszDst);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_MV_UNICODE:
		{
		//	Multi-valued UNICODE properties are copied into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| pszW1, pszW2 ... | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPWSTR array   |     String data    |
		//
		//	Where pszWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each pszWn points
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.

		//	Multi-valued UNICODE properties are flattened into a single
		//	allocated block of memory in the following way:
		//
		//		|          Allocated buffer             |
		//		|---------------------------------------|
		//		| ibW1, ibW2 ...   | szW1[], szW2[] ... |
		//		|------------------|--------------------|
		//		|   LPSTR array    |     String data    |
		//
		//	Where ibWn are the elements of the LPWSTR array pointed
		//	to by pvalDst->Value.MVszW.  Each ibWn contains an offset
		//	the beginning of the allocated buffer
		//	to its corresponding string, szWn, stored later in the
		//	buffer.  The szWn are stored starting at the first byte
		//	past the end of the LPWSTR array.
		//	The pvalDst->Value.MVszW contains the size of the allocated
		//	buffer.

			SWStringArray *	pSWStringArray = &pvalSrc->Value.MVszW;
			ULONG			iVal;
			LPWSTR *		pszSrc;
			LPWSTR *		pszDst;

			if (imode == imodeCopy)
			{
				//	Allocate the buffer to hold the strings

				pszDst = (LPWSTR *) pb;
				pvalDst->Value.MVszW.lppszW = pszDst;
				pb = (LPBYTE) (pszDst + pSWStringArray->cValues);

				//	Copy the strings into the buffer and set pointers
				//	to them in the LPWSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSWStringArray->lppszW;
						iVal < pSWStringArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenW(*pszSrc) + 1) * sizeof (WCHAR);

					*pszDst = (LPWSTR) pb;
					CopyMemory(pb, (LPBYTE) *pszSrc, cb);
					pb += cb;
				}
			}
			else if (imode == imodeFlatten)
			{
				ULONG		ib;

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPWSTR array at the beginning of the buffer

				pszDst = (LPWSTR *) pb;
				pb = (LPBYTE) (pszDst + pSWStringArray->cValues);
				ib = pSWStringArray->cValues * sizeof(LPWSTR *);

				//	Copy the strings into the buffer and set offsets
				//	to them in the LPWSTR array at the beginning of the buffer

				for (iVal = 0, pszSrc = pSWStringArray->lppszW;
						iVal < pSWStringArray->cValues;
						iVal++, pszSrc++, pszDst++ )
				{
					cb = (lstrlenW(*pszSrc) + 1) * sizeof (WCHAR);

					*pszDst = (LPWSTR) ib;
					CopyMemory(pb, (LPBYTE) *pszSrc, (UINT) cb);
					pb += cb;
					ib += cb;
				}

				// Flattening loses pointers so we use the pointer value to
				// hold the total size.
				pvalDst->Value.MVszW.lppszW = (LPWSTR *) ib;
			}
			else
			{
				ULONG		cbTotal;
				ULONG		ulBase;

				// Pick up the size of the entire block and copy it over
				cbTotal = (ULONG) pSWStringArray->lppszW;
                if (cbTotal)
				{
					CopyMemory(*ppbDest, pb, cbTotal);

					//	Convert the offsets to strings back into pointers to
					//	strings

					pvalDst->Value.MVszW.lppszW = pszDst = (LPWSTR *) *ppbDest;
					ulBase = (ULONG) pszDst;
					for (iVal = 0;
							iVal < pSWStringArray->cValues;
							iVal++, pszDst++)
					{
						*pszDst = (LPWSTR) (ulBase + (ULONG) *pszDst);
					}

					//	Bump the source and destination pointers
					*ppbDest += cbTotal;
					pb += cbTotal;
				}
			}
			return pb;
		}

	  case PT_UNSPECIFIED:
	  case PT_OBJECT:
	  default:
		return pb;
	}

	if (imode == imodeUnflatten)
	{
		cb = pvalSrc->Value.bin.cb;
		*ppbDst = *ppbDest;
		CopyMemory(*ppbDest, pb, (size_t) cb);
		*ppbDest += cb;
	}
	else
	{
		cb = CbForPropValue(pvalSrc);
		if (imode == imodeFlatten)
		{
			pvalDst->Value.bin.cb = cb;
		}
		else
		{
			Assert(imode == imodeCopy);
			*ppbDst = pb;
		}

		CopyMemory(pb, pbSrc, (size_t) cb);
	}
	
	return pb + PAD4(cb);	// make sure next one will be dword-aligned
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgvwsnk.cxx ===
/* copyright (c) 1995 Microsoft Corporation -- All rights reserved */

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#pragma warning(disable:4514) // Unreferened inline function has been removed

CViewNotifier::CViewNotifier (void)
{
    Initialize();
}

CViewNotifier::~CViewNotifier ()
{
}

BOOL CViewNotifier::Initialize (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        m_aryAdviseSink [i] = NULL;
    }

    return TRUE;
}

HRESULT CViewNotifier::Advise(LPMAPIVIEWADVISESINK pAdvise,
                              ULONG * pulConnection)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL == m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] = pAdvise;
            m_aryAdviseSink [i] ->AddRef();
            *pulConnection = ++i;
            // connection == index + 1
            return S_OK;
        }
    }

    return ResultFromScode(E_OUTOFMEMORY);
}

HRESULT CViewNotifier::Unadvise (ULONG ulConnection)
{
    if (--ulConnection < MAXSINKS)
    {   // connection == index + 1
        m_aryAdviseSink [ulConnection] ->Release();
        m_aryAdviseSink [ulConnection] = NULL;
        return S_OK;
    }
    return ResultFromScode(E_INVALIDARG);
}

void CViewNotifier::OnShutdown (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] -> OnShutdown ();
        }
    }
}

void CViewNotifier::OnNewMessage (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            m_aryAdviseSink [i] ->OnNewMessage();
        }
    }
}

HRESULT CViewNotifier::OnPrint(ULONG ulPageNumber, HRESULT hrStatus)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i)
    {
        if (NULL != m_aryAdviseSink [i] )
        {
            if(MAPI_E_USER_CANCEL == GetScode(m_aryAdviseSink [i] ->OnPrint(ulPageNumber, hrStatus)))
                return MAPI_E_USER_CANCEL;
        }
    }
    
    return hrSuccess;
}

void CViewNotifier::OnSubmitted (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i) {
        if (NULL != m_aryAdviseSink [i] ) {
            m_aryAdviseSink [i] ->OnSubmitted();
        }
    }
}

void CViewNotifier::OnSaved (void)
{
    ULONG   i;

    for (i = 0; i < MAXSINKS; ++i) {
        if (NULL != m_aryAdviseSink [i] ) {
            m_aryAdviseSink [i] ->OnSaved();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgtripl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msgtripl.cxx
//
//  Contents:   Recipient object (CTriple) implementation
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_MSGGUID_H_
#define X_MSGGUID_H_
#include "msgguid.h"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

static HPEN hpenUnderline = 0;

#define	CTXCK_RecipOptions	1
#define CTXCK_AddToPAB		2

#ifdef DBCS
#define LangJpn	0x0411
#define LangKor	0x0412
#endif

#ifndef MAC
#ifdef WIN32
#define	RTEXPORT	WINAPI
#else
#define	RTEXPORT	_export __loadds
#endif
#else // MAC
#define RTEXPORT
#endif // MAC


// $MAC - Only supports 4 character format names
#ifndef MAC
#define CF_TRIPLE	TEXT("MsMail 4.0 Recipient")
#else
#define CF_TRIPLE	TEXT("XCGA")
#endif

TCHAR CTripData::s_szClipFormatTriple[] = CF_TRIPLE;

FORMATETC CTripData::s_rgformatetcTRIPOLE[] =
{
	{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
	{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
};

#define	iFormatTriple		0
#define	iFormatText			1

#define cformatetcTRIPOLE (sizeof(s_rgformatetcTRIPOLE) / sizeof(FORMATETC))


#ifdef WIN32
#define OleStdMalloc(_ul)			CoTaskMemAlloc(_ul)
#define OleStdFree(_pv)				CoTaskMemFree(_pv)
#define OleStdFreeString(_sz, _pm)	CoTaskMemFree(_sz)
#ifdef MAC
LPSTR OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
#endif
#else
LPVOID OleStdMalloc(ULONG ulSize);
void OleStdFree(LPVOID pmem);
ULONG OleStdGetSize(LPVOID pmem);
void OleStdFreeString(LPSTR lpsz, LPMALLOC lpMalloc);
LPSTR OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
#endif


#define	FreeAdrlist(_pal)		FreeSRowSet((LPSRowSet) _pal)


#if DBG == 1
	CTriple * g_pTripObject = NULL;
#endif


/*
 *	OpenPAB
 *	
 *	Purpose:
 *		This function opens up the default Personal Address Book.
 *		Note: it does an OpenEntry() w/ MAPI_DEFERRED_ERRORS for
 *		better performance.  Error handling code for the caller
 *		of this function needs to be correct.
 *	
 *	Parameters:
 *		pab			pointer to Address Book
 *		ppabc		pointer to pointer to AB container
 *	
 *	Returns:
 *		hr
 */
HRESULT OpenPAB(LPADRBOOK pab, LPABCONT * ppabc)
{
	HRESULT			hr;
	ULONG			cbEid;
	LPENTRYID		peid;
	ULONG			ul;

	hr = pab->GetPAB(&cbEid, &peid);
	if (hr != S_OK)
		goto Error;

	hr = pab->OpenEntry(cbEid, peid,
					NULL, MAPI_DEFERRED_ERRORS, &ul, (LPUNKNOWN *) ppabc);
	
    MAPIFreeBuffer(peid);
	if (hr != S_OK)
		goto Error;

	Assert(ul == MAPI_ABCONT);
	return S_OK;

Error:
	RRETURN(g_LastError.SetLastError(hr, pab));
}

/*
 *	CopyBufferToRow
 *	
 *	Purpose:
 *		This copies the properties from a flat buffer to a row.
 *
 *		NOTE - Multi Value propertis not supported right now
 *	
 *		NOTE - tripole.c relies on specific behaviour of this function
 *	
 *	Parameters:
 *		pb			pointer to the buffer
 *		prwDst		destination row (with lpProps already allocated)
 *	
 *	Returns:
 *		sc
 */
VOID CALLBACK CopyBufferToRow(LPBYTE pb, LPSRow prwDst)
{
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	LPBYTE			pbSrc;
	LPBYTE			pbDst;

	// Do the finicky copy of the items one-by-one.

	iCol = prwDst->cValues = *((ULONG *) pb);
	pvalSrc = (LPSPropValue) (pb + sizeof(ULONG));
	pvalDst = prwDst->lpProps;
	pbSrc = (LPBYTE) (pvalSrc + iCol);		// point past the rgSPropValue.
	pbDst = (LPBYTE) (pvalDst + iCol);		// point past the rgSPropValue.

	while (iCol--)
	{
		pbSrc = CopyPval(pvalSrc, pvalDst, pbSrc, &pbDst, imodeUnflatten);
		++pvalSrc;
		++pvalDst;
	}
}


// MLOLE: Reduced version used by TRIPCALL_GetNewStorage in mapidlg\tripole.c
//		  and by HrGetDataAttachFileContents in mapin\attole.c
/*
 *	StgCreateOnHglobal
 *
 *	Purpose:
 *		Smaller version of OleStdCreateStorageOnHGlobal for Capone use.
 *
 *	Arguments:
 *		None.
 *
 *	Returns:
 *		LPSTORAGE		Created storage, or NULL on error (E_OUTOFMEMORY).
 */
LPSTORAGE StgCreateOnHglobal(VOID)
{
	LPLOCKBYTES plb = NULL;
	LPSTORAGE pstg = NULL;

	// Create lockbytes on hglobal
	if (CreateILockBytesOnHGlobal(NULL, TRUE, &plb))
		return NULL;

	// Create storage on lockbytes
	StgCreateDocfileOnILockBytes(plb, STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE |
			STGM_CREATE | STGM_READWRITE, 0, &pstg);

	// Release our reference on the lockbytes and return the storage
	ReleaseInterface(plb);
	return pstg;
}


/*
 *	StuffRwsInHglobal
 *
 *	Purpose:
 *		Saves an LPSRowSet to a HGLOBAL
 *
 *	Parameters:
 *		prws			pointer to the row set
 *		pmedium			pmedium containing hglobal
 *
 *	Returns:
 *		hr
 */
HRESULT RTEXPORT StuffRwsInHglobal(LPSRowSet prws, LPSTGMEDIUM pmedium)
{
	ULONG			iRow;
	ULONG			cRows		= 0;
	ULONG			iCol;
	LPSPropValue	pvalSrc;
	LPSPropValue	pvalDst;
	LPBYTE			pb;
	LPBYTE			pbOld;
	ULONG			cb = 0;

	//TraceTag(tagTripole, "ScStuffRwsInHglobal");

	for (iRow = 0; iRow < prws->cRows; ++iRow)
	{
		pvalSrc = prws->aRow[iRow].lpProps;
		if (pvalSrc == NULL)
			continue;				// skip empty rows

		++cRows;
		cb += 2 * sizeof(ULONG);	// to store the size of buffer required
									// for each row and the number of props
		for (iCol = prws->aRow[iRow].cValues; iCol > 0; ++pvalSrc, --iCol)
		{
			cb += PAD4(CbForPropValue(pvalSrc)) + sizeof(SPropValue);
		}
	}

	pmedium->hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cb);
	if (!pmedium->hGlobal)
		return E_OUTOFMEMORY;
	pb = (BYTE *) GlobalLock(pmedium->hGlobal);
	Assert(pb);

	*((ULONG *) pb) = cRows;
	pb += sizeof(ULONG);

	for (iRow = 0; iRow < prws->cRows; ++iRow)
	{
		pvalSrc = prws->aRow[iRow].lpProps;
		if (pvalSrc == NULL)
			continue;				// skip empty rows

		pbOld = pb;
		pb += sizeof(ULONG);

		iCol = *((ULONG *) pb) = prws->aRow[iRow].cValues;
		pvalDst = (LPSPropValue) (pb + sizeof(ULONG));
		pb = (LPBYTE) (pvalDst + iCol);		// point past the rgSPropValue.

		while (iCol--)
		{
			pb = CopyPval(pvalSrc, pvalDst, pb, NULL, imodeFlatten);
			++pvalSrc;
			++pvalDst;
		}

		*((ULONG *) pbOld) = pb - pbOld - sizeof(ULONG);
	}

	GlobalUnlock(pmedium->hGlobal);
	return S_OK;
}



/*
 *	FindTripleProperties
 *	
 *	Purpose:
 *		This is some common code needed when creating a recipient
 *		in a TRIPLE object.
 *	
 *	Parameters:
 *		ptriple		pointer to triple object
 */
VOID CTriple::FindTripleProperties()
{
	ULONG			i;
	LPSPropValue	pval	= _rw.lpProps;

	_iName = LONG_MAX;
#ifdef	DEBUG
	_iEid = LONG_MAX;
#endif	
	_iType = LONG_MAX;			//$ REVIEW - Is it OK if this is missing?
	for (i = 0; i < _rw.cValues; i++)
	{
		if (pval[i].ulPropTag == PR_DISPLAY_NAME_A)
			_iName = i;
		else if (pval[i].ulPropTag == PR_ENTRYID)
			_iEid = i;
		else if (pval[i].ulPropTag == PR_DISPLAY_TYPE)
			_iType = i;
	}
	AssertSz(_iEid != LONG_MAX, "No EntryId in recipient");
}



/*
 *	T R I P P E R   I m p l e m e n t a t i o n
 */

/*
 *	GetClassID
 *
 *	Purpose:
 *		Returns an object's class identifier.
 *
 *	Parameters:
 *		ppersist		pointer to IPersist object
 *		pClassID		pointer to where to return the object's
 *						CLSID
 *
 *	Returns:
 *		hr
 */
HRESULT CTriple::GetClassID(LPCLSID pClassID)
{
	//TraceTag(tagTripole, "TRIPPER_GetClassID");

	*pClassID = CLSID_CTriple;

	return S_OK;
}


/*
 *	T R I P L E   I m p l e m e n t a t i o n
 */

/*
 *	Constructor CTriple
 *	
 *	Purpose:
 *		Creates a new class CTRIPLE.
 *	
 *	Parameters:
 *		prw			pointer to row respresenting an ADRENTRY
 *	
 *	Returns:
 *		CTriple *	The newly created CTriple.
 */
CTriple::CTriple(CPadMessage * pPad, LPSRow prw)
{
	//TraceTag(tagTripole, "TRIPLE_New");

	_cRef = 1;					// Start with one reference
	_pClientSite = NULL;
	_padvisesink = NULL;
	_pPad = pPad;
	if (prw)
	{
		_rw = *prw;
		FindTripleProperties();
	}

	_pstg = NULL;
	_fUnderline = TRUE;

	// Try to set up an OleAdviseHolder
	CreateOleAdviseHolder(&_poleadviseholder);

#if DBG == 1
	g_pTripObject = this;
#endif
}

/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Parameters:
 *		LPUNKNOWN *	 Object from which we want an interface.
 *		REFIID		 Interface we want.
 *		LPUNKNOWN *	 Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTriple::QueryInterface(REFIID riid,
								   LPVOID * ppvObj)
{
	//TraceTag(tagTripole, "TRIPLE_QueryInterface");

	if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleObject))
	{
		*ppvObj = (IOleObject*)this;
	}
	else if (IsEqualIID(riid, IID_IViewObject))
	{
		*ppvObj = (IViewObject*)this;
	}
	else if (IsEqualIID(riid, IID_IPersist))
    {
		*ppvObj = (IPersist*)this;
	}
    else
	{
		//TraceTag(tagTripole, "Don't know interface %lx", riid->Data1);
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

    (*(IUnknown**)ppvObj)->AddRef();

	return S_OK;
}

/*
 *	AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTriple::AddRef()
{
	//TraceTag(tagTripole, "TRIPLE_AddRef");

	return ++_cRef;
}

/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTriple::Release()
{
	ULONG cRef = --_cRef;

	//TraceTag(tagTripole, "TRIPLE_Release");

	if (!cRef)
	{
		//TraceTag(tagTripole, "TRIPLE_Release: freeing the triple");
#ifdef	DEBUG
		g_pTripObject = NULL;
#endif	
		MAPIFreeBuffer(_rw.lpProps);
		ReleaseInterface(_pClientSite);
		ReleaseInterface(_pstg);
		ReleaseInterface(_poleadviseholder);
		ReleaseInterface(_padvisesink);
		delete this;
	}

	AssertSz(cRef >= 0, "TRIPLE_Release: negative cRef");
	return cRef;
}



/*
 *	SetClientSite
 *	
 *	Purpose:
 *		Stores the IClientSite that this object is contained in.
 *	
 *	Parameters:
 *		pClientSite			the client site
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::SetClientSite(IOleClientSite * pClientSite)
{
	HRESULT			hr;
	CTripCall *		pTripCall;

	//TraceTag(tagTripole, "TRIPOBJECT_SetClientSite");

	if (_pClientSite)
	{
		ClearInterface(&_pClientSite);
	}

	if (!pClientSite)
		return S_OK;

	_pClientSite = pClientSite;
	_pClientSite->AddRef();

	hr = THR(pClientSite->QueryInterface(IID_IRichEditOleCallback, (void**)&pTripCall));

    if (hr == S_OK)
	{
		_fUnderline = pTripCall->GetUnderline();
		pTripCall->Release();
	}

	return S_OK;
}


/*
 *	GetClientSite
 *
 *	Purpose:
 *		Retrieves the IClientSite that this object is contained in.
 *
 *	Parameters:
 *		poleobject			this object
 *		ppClientSite		on return, a pointer to the client site
 *
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetClientSite(IOleClientSite ** ppClientSite)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetClientSite");

	*ppClientSite = _pClientSite;
    _pClientSite->AddRef();

	return S_OK;
}


/*
 *	SetHostNames
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
	//TraceTag(tagTripole, "TRIPOBJECT_SetHostNames");

	return S_OK;
}


/*
 *	Close
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Close(DWORD dwSaveOption)
{
	//TraceTag(tagTripole, "TRIPOBJECT_Close");

	return S_OK;
}


/*
 *	SetMoniker
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_SetMoniker: NYI");
	return E_NOTIMPL;
}


/*
 *	GetMoniker
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetMoniker");

	// I don't do Monikers

	return E_FAIL;
}


/*
 *	InitFromData
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_InitFromData: NYI");
	return E_NOTIMPL;
}


/*
 *	GetClipboardData
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject)
{
	HRESULT			hr;
	SCODE			sc;
	LPSRowSet		prws;
    CTripData *     pTripleData;

	//TraceTag(tagTripole, "TRIPOBJECT_GetClipboardData");

	sc = MAPIAllocateBuffer(CbNewSRowSet(1), (void**)&prws);
	if (sc != S_OK)
		goto MemoryError;

	prws->cRows = 1;
	sc = CopyRow(NULL, &_rw, prws->aRow);
	if (sc != S_OK)
	{
		MAPIFreeBuffer(prws);
		goto MemoryError;
	}
	
    pTripleData = new CTripData(prws);
	if (!pTripleData)
	{
		FreeSRowSet(prws);
		goto MemoryError;
	}

	// Need to do the QueryInterface() to get a wrapped object

	hr = pTripleData->QueryInterface(IID_IDataObject, (void**)ppDataObject);

	// QueryInterface() does an AddRef() so we're up to two,
	// but the object we return should only be at one
	pTripleData->Release();

	RRETURN(hr);

MemoryError:
	RRETURN(E_OUTOFMEMORY);
}


/*
 *	DoVerb
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::DoVerb(LONG iVerb,
				LPMSG lpmsg, IOleClientSite * pActivateSite,
				LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
#ifdef LATER
	HRESULT			hr;
	LPADRBOOK		pab;
	ULONG			ulUIParam	= UlFromHwnd(GetParent(hwndParent));
	static SPropTagArray	taga	= {8, {PR_DISPLAY_NAME_A, PR_DISPLAY_TYPE,
								PR_OBJECT_TYPE, PR_ADDRTYPE, PR_ENTRYID,
								PR_SEARCH_KEY, PR_EMAIL_ADDRESS, PR_NULL}};

	
	//TraceTag(tagTripole, "TRIPOBJECT_DoVerb");

    pab = _pab;
	if (!pab)
	{
		//$ NYI - Do what if no _pab
		return S_OK;
	}

	if (iVerb == 0)
	{
		ULONG			ul;
		LONG			lRecipType;
		LPSPropValue	pval;
		BOOL			fRecipientType	= FALSE;
		DETAILSDATA 	dtd = {0};
		LPMAPIERROR		pme = NULL;
		HRESULT			hr;
		ULONG			cbEid;
		LPENTRYID		peid;

		dtd.ppme = &pme;
		dtd.pab = pab;
		dtd.ulUIParam = ulUIParam;
		dtd.cbEid = _rw.lpProps[_iEid].Value.bin.cb;
		dtd.peid = (LPENTRYID) _rw.lpProps[_iEid].Value.bin.lpb;

		// Do we have a PAB?
		dtd.fShowAddToPAB			= FALSE;
		hr = pab->GetPAB(&cbEid, &peid);
		if (hr == S_OK && peid)
		{
			dtd.fShowAddToPAB		= TRUE;
			MAPIFreeBuffer(peid);
		}

		dtd.fWantPmpReturned = TRUE;
		dtd.lDisplayType = -1;
		Assert(dtd.hr == S_OK);
		Assert(dtd.fNextPrevVisible == FALSE);
		Assert(dtd.fNewEntryInvoked == FALSE);
		Assert(dtd.pabd == NULL);
		Assert(dtd.dtret == 0);
		Assert(dtd.pmp == NULL);
		Assert(dtd.szDisplayName == NULL);
		Assert(dtd.lpfndismiss == NULL);
		Assert(dtd.lpvDismissContext == NULL);
		Assert(dtd.lpfnCustom == NULL);
		Assert(dtd.lpvButtonContext == NULL);
		Assert(dtd.szCustomText == NULL);

		DisplayDetailsDialog(&dtd);
		if (dtd.hr != S_OK || !dtd.fChanged
				|| GetWindowLong(hwndParent, GWL_STYLE) & ES_READONLY)
		{
			if (!dtd.hr)
				dtd.pmp->(dtd.pmp);

			if (dtd.hr && dtd.hr != MAPI_E_USER_CANCEL)
			{
				//TraceError("TRIPOBJECT_DoVerb", GetScode(dtd.hr));
				DisplayTheError(dtd.hr, dtd.ppme);
			}
			goto Cleanup;
		}

		// The user might have changed some of the properties, or the
		// properties may have been changed in the Address Book. If the
		// user OK'd the details dialog, get the new values

		pval = PvalFind(&_rw, PR_RECIPIENT_TYPE);
		if (pval)
		{
			fRecipientType = TRUE;
			lRecipType = pval->Value.l;
		}

		ul = taga.cValues;
		hr = dtd.pmp->GetProps(&taga, 0, &ul, &pval);
		Assert(ul == taga.cValues);
		if (FAILED(hr))
		{
			//ScReportErrorHrPmunk(hr, (LPMAPIUNK) dtd.pmp);
			dtd.pmp->Release();
			goto Cleanup;
		}

		dtd.pmp->Release();
		MAPIFreeBuffer(_rw.lpProps);
		if (fRecipientType)
		{
			pval[ul - 1].ulPropTag = PR_RECIPIENT_TYPE;
			pval[ul - 1].Value.l = lRecipType;
		}

		_rw.cValues = ul;
		_rw.lpProps = pval;
		FindTripleProperties();

		Edit_SetModify(hwndParent, TRUE);
		_padvisesink->OnViewChange(DVASPECT_CONTENT, -1);
	}
	else if (iVerb == 1)
	{
		LPADRENTRY		pae	= (LPADRENTRY) &_rw;

		hr = pab->RecipOptions(ulUIParam, 0, pae);
		if (hr != S_OK)
		{
			//if (hr != MAPI_E_USER_CANCEL)
				//ScReportErrorHrPmunk(hr, (LPMAPIUNK) pabTriple);
			goto Cleanup;
		}
		Assert(pae == (LPADRENTRY) &_rw);
		FindTripleProperties();
		Edit_SetModify(hwndParent, TRUE);
	}
	else if (iVerb == 2)
	{
		LPABCONT		pabcPAB;
		ENTRYLIST		el;
		SBinary			bin;

		if (OpenPAB(pab, &pabcPAB) != S_OK)
		{
			ReportLastErrorNull();
			goto Cleanup;
		}

		el.cValues = 1;
		el.lpbin = &bin;
		bin.cb = _rw.lpProps[_iEid].Value.bin.cb;
		bin.lpb = _rw.lpProps[_iEid].Value.bin.lpb;

		hr = pabcPAB->CopyEntries(pabcPAB, &el, ulUIParam,
					NULL, CREATE_CHECK_DUP_STRICT);
		if (hr != S_OK)
		{
			TraceError("TRIPOBJECT_DoVerb", GetScode(hr));
			ScReportErrorHrPmunk(hr, (LPMAPIUNK) pabcPAB);
		}
		ReleaseInterface(pabcPAB);
	}
	else
	{
		return OLEOBJ_S_INVALIDVERB;
	}

Cleanup:
	return S_OK;
#else
    RRETURN(E_NOTIMPL);
#endif
}


#ifdef LATER
/*
 *	EnumVerbsCallback
 *
 *	Purpose:
 *		Support function for the EnumVerbs() which will allocate
 *		the value for each of the elements
 *
 *	Arguments:
 *		iel			The index of the element
 *		pbDst		Pointer to the data to be munged
 *
 *	Returns:
 *		BOOL		TRUE on success
 */
BOOL CTRIPLE::EnumVerbsCallback(ULONG iel, LPVOID pbDst)
{
	OLEVERB *	poleverb = (OLEVERB *) pbDst;
	CHAR		rgch[40];
	UsesMakeOLESTR;

	AssertSz(iel < 3, "Know only three verbs");
	LoadString(g_hInstResource, STR_TripoleVerb0 + (UINT) iel, rgch,
				sizeof(rgch) / sizeof(CHAR));
#if defined (WIN32) && !defined (MAC)
	poleverb->lpszVerbName = OleStdMalloc(40 * sizeof(OLECHAR));
	if (!poleverb->lpszVerbName)
		return FALSE;
	lstrcpyW(poleverb->lpszVerbName, MakeOLESTR(rgch));
	return TRUE;
#else
	return (poleverb->lpszVerbName = OleStdCopyString(rgch, NULL))
														? TRUE : FALSE;
#endif
}
#endif

/*
 *	EnumVerbs
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::EnumVerbs(IEnumOLEVERB ** ppenumOleVerb)
{
#ifdef LATER
	static OLEVERB	oleverb[]	= {
						{0, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU},
						{1, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU},
						{2, NULL, 0, OLEVERBATTRIB_NEVERDIRTIES
							| OLEVERBATTRIB_ONCONTAINERMENU}};

	//TraceTag(tagTripole, "TRIPOBJECT_EnumVerbs");

	*ppenumOleVerb = (LPENUMOLEVERB) ENUMUNK_New(
						(LPIID) &IID_IEnumOLEVERB,
						3, sizeof(OLEVERB), &oleverb,
						EnumVerbsCallback);
	if (!*ppenumOleVerb)
		return E_OUTOFMEMORY;

	return S_OK;
#else
    RRETURN(OLEOBJ_E_NOVERBS);
#endif
}


/*
 *	Update
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Update()
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_Update: NYI");
	return E_NOTIMPL;
}


/*
 *	IsUpToDate
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::IsUpToDate()
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_IsUpToDate: NYI");
	return E_NOTIMPL;
}


/*
 *	GetUserClassID
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetUserClassID(CLSID * pclsid)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetUserClassID");

	*pclsid = CLSID_CTriple;

	return S_OK;
}


/*
 *	GetUserType
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetUserType(DWORD dwFormOfType, LPOLESTR * lpszUserType)
{
	UINT	ids;
	INT		cch;
#if defined(WIN32) && !defined(MAC)
	TCHAR	szT[40];
#endif

	if (dwFormOfType == USERCLASSTYPE_APPNAME)
	{
		ids = IDS_ErrorCaptionMail;
		cch = 40;
	}
	else
	{
		ids = IDS_TripoleFullName;
		cch = 20;
	}

	*lpszUserType = (TCHAR *) OleStdMalloc(cch * sizeof(OLECHAR));
	if (*lpszUserType == NULL)
		return E_OUTOFMEMORY;

#if defined(WIN32) && !defined(MAC)
	LoadString(g_hInstResource, ids, szT, cch);
	lstrcpyW(*lpszUserType, szT);
#else	// !WIN32
	LoadString(g_hInstResource, ids, (char*)*lpszUserType, cch);
#endif	// !WIN32

	//TraceTag(tagTripole, "TRIPOBJECT_GetUserType");

	return S_OK;
}


/*
 *	SetExtent
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	//TraceTag(tagTripole, "TRIPOBJECT_SetExtent");

	// The object's size is fixed

	return E_FAIL;
}


/*
 *	GetExtent
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	HFONT			hfontOld;
	HDC				hdc;
	TEXTMETRIC		tm;
	LPSTR			szName;
	SIZE			size;
	SIZEL			sizel;

	//TraceTag(tagTripole, "TRIPOBJECT_GetExtent");

	hdc = GetWindowDC(NULL);
	Assert(hdc);

    hfontOld = SelectFont(hdc, GetStockObject(DEFAULT_GUI_FONT));

	if (_iName == LONG_MAX)
		szName = "";
	else
		szName = _rw.lpProps[_iName].Value.lpszA;

	GetTextExtentPointA(hdc, szName, lstrlenA(szName), &size);

	GetTextMetrics(hdc, &tm);

	sizel.cx = size.cx + 1;					// One pixel seems to be clipped
	sizel.cy = size.cy - tm.tmDescent;		// Same height as normal line (RAID 11516 was +1)



    lpsizel->cx = sizel.cx * 2540 / GetDeviceCaps(hdc, LOGPIXELSX);
    lpsizel->cy = sizel.cy * 2540 / GetDeviceCaps(hdc, LOGPIXELSY);

	SelectFont(hdc, hfontOld);
	ReleaseDC(NULL, hdc);
	return S_OK;
}


/*
 *	Advise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Advise(IAdviseSink * pAdvSink, DWORD * pdwConnection)
{
    if (_poleadviseholder)
		return _poleadviseholder->Advise(pAdvSink, pdwConnection);

	return OLE_E_ADVISENOTSUPPORTED;
}


/*
 *	Unadvise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::Unadvise(DWORD dwConnection)
{
	if (_poleadviseholder)
		return _poleadviseholder->Unadvise(dwConnection);

	return E_FAIL;
}


/*
 *	EnumAdvise
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::EnumAdvise(LPENUMSTATDATA * ppenumAdvise)
{
	if (_poleadviseholder)
		return _poleadviseholder->EnumAdvise(ppenumAdvise);

	return OLE_E_ADVISENOTSUPPORTED;
}


/*
 *	GetMiscStatus
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
	//TraceTag(tagTripole, "TRIPOBJECT_GetMiscStatus");

	*pdwStatus = 0;

	return S_OK;
}


/*
 *	SetColorScheme
 *
 *	Purpose:
 *
 *	Parameters:
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTriple::SetColorScheme(LPLOGPALETTE lpLogpal)
{
	//TraceTag(tagTripoleStub, "TRIPOBJECT_SetColorScheme: NYI");
	return E_NOTIMPL;
}


/*
 *	Draw
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Draw(DWORD dwDrawAspect,
                    LONG lindex,
                    void *pvAspect,
                    DVTARGETDEVICE *ptd,
                    HDC hdcTargetDev,
                    HDC hdcDraw,
                    LPCRECTL lprcBounds,
                    LPCRECTL lprcWBounds,
                    BOOL (STDMETHODCALLTYPE *pfnContinue)(DWORD dwContinue),
                    DWORD dwContinue)
{
	LPSTR			szName;
	TEXTMETRIC		tm;

	if (_iName == LONG_MAX)
		szName = "";
	else
   		szName = _rw.lpProps[_iName].Value.lpszA;

	SetTextAlign(hdcDraw, TA_BOTTOM);
	TextOutA(hdcDraw, lprcBounds->left, lprcBounds->bottom, szName, lstrlenA(szName));

	GetTextMetrics(hdcDraw, &tm);

	// Only draw the underline if we're told to
	if (_fUnderline)
	{
		if (!hpenUnderline)
		{
			hpenUnderline = CreatePen(PS_SOLID, 0,
									GetSysColor(COLOR_WINDOWTEXT));
			if (!hpenUnderline)
				return E_OUTOFMEMORY;
		}

		SelectPen(hdcDraw, hpenUnderline);
#ifndef DBCS
		MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom - tm.tmDescent + 1, NULL);
		LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom - tm.tmDescent + 1);
#else
		MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom-1 , NULL);
		LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom-1 );
#endif
	}

	return S_OK;
}


/*
 *	GetColorSet
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	xxc
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetColorSet(DWORD dwDrawAspect, LONG lindex, void FAR* pvAspect,
				DVTARGETDEVICE FAR * ptd, HDC hicTargetDev,
				LPLOGPALETTE FAR* ppColorSet)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_GetColorSet: NYI");
	return E_NOTIMPL;
}


/*
 *	Freeze
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Freeze(DWORD dwDrawAspect,
				LONG lindex, void FAR* pvAspect, DWORD FAR* pdwFreeze)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_Freeze: NYI");
	return E_NOTIMPL;
}


/*
 *	Unfreeze
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::Unfreeze(DWORD dwFreeze)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_Unfreeze: NYI");
	return E_NOTIMPL;
}


/*
 *	SetAdvise
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
	
	//TraceTag(tagTripole, "TRIPVIEW_SetAdvise");

	ReleaseInterface(_padvisesink);
	if (pAdvSink)
		pAdvSink->AddRef();
	_padvisesink = pAdvSink;

	return S_OK;
}


/*
 *	GetAdvise
 *	
 *	Purpose:
 *	
 *	Parameters:
 *	
 *	Returns:
 *		hresult
 */
HRESULT CTriple::GetAdvise(DWORD FAR* pAspects, DWORD FAR* pAdvf,
				LPADVISESINK FAR* ppAdvSink)
{
	//TraceTag(tagTripoleStub, "TRIPVIEW_GetAdvise: NYI");
	AssertSz(FALSE, "I'm easy to implement if I'm called");
	return E_NOTIMPL;
}


/*
 *	Constructor
 *	
 *	Purpose:
 *		Creates a new CTRIPDATA object.
 *	
 *	Parameters:
 *		prws		pointer to row set containing one or more objects
 *	
 *	Returns:
 *		TRIPDATA *	The newly created TRIPDATA.
 */
CTripData::CTripData(LPSRowSet prws)
{
	//TraceTag(tagTripole, "TRIPDATA_New");

	_cRef = 1;				// Start with one reference
	_prws = prws;

    if (s_rgformatetcTRIPOLE[iFormatText].cfFormat == 0)
    {
	    // Register our clipboard formats
	    s_rgformatetcTRIPOLE[iFormatText].cfFormat = CF_TEXT;
	    s_rgformatetcTRIPOLE[iFormatTriple].cfFormat =
					    RegisterClipboardFormat(s_szClipFormatTriple);
    }
}


/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Parameters:
 *		REFIID		 Interface we want.
 *		LPUNKNOWN *	 Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTripData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	//TraceTag(tagTripole, "TRIPDATA_QueryInterface");

	if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
	{
		*ppvObj = (IDataObject*)this;
        AddRef();
	}
	else
	{
		//TraceTag(tagTripole, "Don't know interface %lx", riid->Data1);
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

/*
 *  AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripData::AddRef()
{
	//TraceTag(tagTripole, "TRIPDATA_AddRef");

	return ++_cRef;
}


/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripData::Release()
{
	ULONG		cRef		= --_cRef;

	//TraceTag(tagTripole, "TRIPDATA_Release");

	if (!cRef)
	{
		//TraceTag(tagTripole, "TRIPDATA_Release: freeing the tripdata");
    	FreeSRowSet(_prws);
		delete this;
	}

	AssertSz(cRef >= 0, "TRIPDATA_Release: negative cRef");
	return cRef;
}


HRESULT CTripData::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	//TraceTag(tagTripole, "TRIPDATA_GetData");
//$BUG
//	Naughty, naughty, naughty.  You weren't following the OLE2 spec.
//
//	The call to GetDataHereOrThere assumes that pmedium is
//	pre-initialized.  This is fine and dandy for a IDataObject::GetDataHere
//	call, but the OLE2 spec says that the pmedium isn't initialized
//	for IDataObject::GetData.  This fix should probably be taken in
//	for all clients, not just the Mac.
#ifdef MAC
	pmedium->tymed = TYMED_NULL;
	pmedium->pUnkForRelease = NULL;
#endif	// MAC
	return this->GetDataHereOrThere(pformatetcIn, pmedium);
}

HRESULT CTripData::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
	//TraceTag(tagTripole, "TRIPDATA_GetDataHere");

	return this->GetDataHereOrThere(pformatetc, pmedium);
}

/*
 *	GetDataHereOrThere
 *	
 *	Purpose:
 *		Both TRIPDATA_GetData() and TRIPDATA_GetDataHere() do
 *		basically the same thing, so I have them each call this
 *		function.
 *	
 *	Parameters:
 *		pdataobject		an IDataObject
 *		pformatetcIn	the format to get the data
 *		pmedium			where and how to give the data
 *	
 *	Returns:
 *		hr
 */
HRESULT CTripData::GetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	HRESULT			hr			= S_OK;
	UINT			cbName;
	ULONG			i;
	LPSPropValue	pval;
	LPSTR			pDst;

//	TraceTag(tagTripole, "GetDataHereOrThere");

	if (pformatetcIn->cfFormat == s_rgformatetcTRIPOLE[iFormatTriple].cfFormat)
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->pUnkForRelease = NULL;
		return (StuffRwsInHglobal(_prws, pmedium));
	}
	else if (pformatetcIn->cfFormat != s_rgformatetcTRIPOLE[iFormatText].cfFormat)
	{
#ifdef DEBUG
		TCHAR	szT[50];

		if (!GetClipboardFormatName(pformatetcIn->cfFormat, szT, sizeof(szT)))
			wsprintf(szT, L"%d", pformatetcIn->cfFormat);
		//TraceTag(tagTripole, "Don't know Clipboard Format %s", szT);
#endif
		return DATA_E_FORMATETC;
	}

	for (i = 0, cbName = 0; i < _prws->cRows; ++i)
	{
		pval = PvalFind(&_prws->aRow[i], PR_DISPLAY_NAME_A);
		Assert(pval);
		cbName += (lstrlenA(pval->Value.lpszA) + 2) * sizeof(TCHAR);
	}

	if (pmedium->tymed == TYMED_NULL ||
			(pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal == NULL))
	{
		// This is easy, we can quit right after copying stuff
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cbName);
		pmedium->pUnkForRelease = NULL;
	}
	else if (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal != NULL)
	{
		// Caller wants us to fill his hGlobal
		// Realloc the destination to make sure there is enough room
        void *pTemp;
        pTemp = GlobalReAlloc(pmedium->hGlobal, cbName, 0);
        if (pTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
		pmedium->hGlobal = pTemp;
	}
	else
		goto Cleanup;

	if (!pmedium->hGlobal)
	{
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	pDst = (LPSTR)GlobalLock(pmedium->hGlobal);
	for (i = 0; i < _prws->cRows; ++i)
	{
		if (i > 0)
		{
			*((LPSTR) pDst) = ';';
			pDst ++;
			*((LPSTR) pDst) = ' ';
			pDst ++;
		}

		pval = PvalFind(&_prws->aRow[i], PR_DISPLAY_NAME_A);
		Assert(pval);
		cbName = (lstrlenA(pval->Value. lpszA) + 1);;
		CopyMemory(pDst, pval->Value.lpszA, cbName);
		pDst += cbName - 1;
	}
	GlobalUnlock(pmedium->hGlobal);

Cleanup:
	RRETURN(hr);
}


HRESULT CTripData::QueryGetData(LPFORMATETC pformatetc)
{
	LONG		iformatetc;
	LPFORMATETC	pformatetcT	= s_rgformatetcTRIPOLE;
	CLIPFORMAT	cfFormat	= pformatetc->cfFormat;
	DWORD		tymed		= pformatetc->tymed;

	//TraceTag(tagTripole, "TRIPDATA_QueryGetData");

	for (iformatetc = 0; iformatetc < cformatetcTRIPOLE;
								++iformatetc, ++pformatetcT)
	{
		// Stop searching if we have compatible formats and mediums
		if (pformatetcT->cfFormat == cfFormat &&
					(pformatetcT->tymed & tymed))
			return S_OK;
	}

	return S_FALSE;
}

HRESULT CTripData::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
	//TraceTag(tagTripole, "TRIPDATA_GetCanonicalFormatEtc");

	return DATA_S_SAMEFORMATETC;
}

HRESULT CTripData::SetData(LPFORMATETC pformatetc, LPSTGMEDIUM  pmedium, BOOL fRelease)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_SetData: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    RRETURN(THR(CreateFORMATETCEnum(s_rgformatetcTRIPOLE, cformatetcTRIPOLE, ppenumFormatEtc)));
}

HRESULT CTripData::DAdvise(LPFORMATETC pFormatetc, DWORD advf,
					LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_Advise: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::DUnadvise(DWORD dwConnection)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_Unadvise: NYI");

	return E_NOTIMPL;
}

HRESULT CTripData::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
	//TraceTag(tagTripoleStub, "TRIPDATA_EnumAdvise: NYI");

	return E_NOTIMPL;
}


/*
 *	T R I P C A L L   I m p l e m e n t a t i o n
 */


/*
 *	Constructor CTripCall
 *	
 *	Parameters:
 *		pPad			    pointer to CPadMessage this belongs to
 *		hwndEdit			hwnd of this edit control
 *		fUnderline			do we want to underline the triples
 *	
 *	Returns:
 *		TRIPCALL *	The newly created TRIPCALL.
 */
CTripCall::CTripCall(   CPadMessage * pPad,
                        HWND hwndEdit,
                        BOOL fUnderline)
{

	_cRef = 1;					// Start with one reference
	_pPad = pPad;				// Don't need to refcount
	_hwndEdit = hwndEdit;
	_fUnderline = fUnderline;
}


/*
 *	QueryInterface
 *
 *	Purpose:
 *		Returns a pointer to the specified site.
 *
 *	Arguments:
 *		REFIID			Interface we want.
 *		LPUNKNOWN *		Interface we return.
 *
 *	Returns:
 *		HRESULT		 Error status.
 */
HRESULT CTripCall::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
					IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		*ppvObj = (IRichEditOleCallback*)this;
        AddRef();
		return S_OK;
	}
    else
    {
	    *ppvObj = NULL;
	    return E_NOINTERFACE;
    }
}


/*
 *	AddRef
 *
 *	Purpose:
 *		Increments reference count on the specified site.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripCall::AddRef()
{
	return ++_cRef;
}


/*
 *	Release
 *
 *	Purpose:
 *		Decrements reference count on the specified site.  If count is
 *		decremented to zero, the object is freed.
 *
 *	Returns:
 *		ULONG			New value of reference count.
 */
ULONG CTripCall::Release()
{
	ULONG cRef = --_cRef;

	if (!cRef)
	{

		// Free memory allocated for us
		delete this;
		//TraceTag(tagTripole, "TRIPCALL_Release: freeing the tripcall");
	}

	AssertSz(cRef >= 0, "TRIPCALL_Release: negative cRef");
	return cRef;
}


/*
 *	GetNewStorage
 *
 *	Purpose:
 *		Gets storage for a new object.
 *
 *	Arguments:
 *		LPSTORAGE FAR *		Where to return storage.
 *
 *	Returns:
 *		HRESULT				Error status.
 */
HRESULT CTripCall::GetNewStorage(LPSTORAGE FAR * ppstg)
{
	*ppstg = StgCreateOnHglobal();
	if (!*ppstg)
		return E_OUTOFMEMORY;
	return S_OK;
}


/*
 *	GetInPlaceContext
 *
 *	Purpose:
 *		Gets context information for an in place object.
 *
 *	Arguments:
 *		LPOLEINPLACEFRAME *		Frame window object.
 *		LPOLEINPLACEUIWINDOW *	Document window object.
 *		LPOLEINPLACEFRAMEINFO	Frame window information.
 *
 *	Returns:
 *		HRESULT					Error status.
 */
HRESULT CTripCall::GetInPlaceContext(LPOLEINPLACEFRAME FAR * ppipframe,
    							   LPOLEINPLACEUIWINDOW FAR* ppipuiDoc,
	    						   LPOLEINPLACEFRAMEINFO pipfinfo)
{
	return E_NOTIMPL;
}


/*
 *	ShowContainerUI
 *
 *	Purpose:
 *		Displays or hides REITP's container UI.
 *
 *	Arguments:
 *		BOOL			
 *
 *	Returns:
 *		HRESULT			Error status.
 */
HRESULT CTripCall::ShowContainerUI(BOOL fShow)
{
	return E_NOTIMPL;
}


HRESULT CTripCall::QueryInsertObject(LPCLSID pclsid, LPSTORAGE pstg, LONG cp)
{
	if (IsEqualIID(*pclsid, CLSID_CTriple))
		return S_OK;
	else
		return E_FAIL;
}


HRESULT CTripCall::DeleteObject(LPOLEOBJECT poleobj)
{
	return S_OK;
}


HRESULT CTripCall::QueryAcceptData(LPDATAOBJECT pdataobj, CLIPFORMAT *pcfFormat,
                                    DWORD reco, BOOL fReally,
		                            HGLOBAL hMetaPict)
{
	HRESULT			hr;
	ULONG			cRows;
	ULONG			iRow;
	ULONG			cb;
	LPBYTE			pb;
	SRow			rw;
	STGMEDIUM		stgmedium;

	//TraceTag(tagTripole, "TRIPCALL_QueryAcceptData");

	if (!*pcfFormat)
	{
		// default to text
		*pcfFormat = CF_TEXT;

		if (pdataobj->QueryGetData(&CTripData::s_rgformatetcTRIPOLE[iFormatTriple]) == S_OK)
		{
			// Goody, goody, this data object support CF_TRIPLE
			*pcfFormat = CTripData::s_rgformatetcTRIPOLE[iFormatTriple].cfFormat;
		}
	}
	else
	{
		if (*pcfFormat != CTripData::s_rgformatetcTRIPOLE[iFormatTriple].cfFormat
				 && *pcfFormat != CTripData::s_rgformatetcTRIPOLE[iFormatText].cfFormat)
			return DATA_E_FORMATETC;
	}

	if (*pcfFormat == CF_TEXT)
	{
		// let the richedit take care of text
		return S_OK;
	}

	// If I'm read-only, return Success and Richedit won't do anything
	if (GetWindowLong(_hwndEdit, GWL_STYLE) & ES_READONLY)
		return S_OK;

	if (!fReally)
	{
		// return that we'll import it ourselves
 		return S_FALSE;
	}

	hr = pdataobj->GetData(&CTripData::s_rgformatetcTRIPOLE[iFormatTriple], &stgmedium);
	if (hr != S_OK)
		RRETURN(hr);

    // STGFIX: t-gpease 8-13-97
    Assert(stgmedium.tymed == TYMED_HGLOBAL);

	pb = (BYTE*)GlobalLock(stgmedium.hGlobal);
	cRows = *((ULONG *) pb);
	pb += sizeof(ULONG);

	for (iRow = 0; iRow < cRows; ++iRow)
	{
		cb = *((ULONG *) pb);
		pb += sizeof(ULONG);

		hr = THR(MAPIAllocateBuffer(cb, (void**)&rw.lpProps));
		if (hr)
			goto Cleanup;

		CopyBufferToRow(pb, &rw);
		pb += cb;

		if (iRow > 0)
			Edit_ReplaceSel(_hwndEdit, TEXT("; "));

		//$ REVIEW - if we fail, do I want to do anything?

		_pPad->AddRecipientToWell(_hwndEdit, (LPADRENTRY) &rw, FALSE, FALSE);

		MAPIFreeBuffer(rw.lpProps);
	}

	hr = S_FALSE;

Cleanup:
	GlobalUnlock(stgmedium.hGlobal);
	GlobalFree(stgmedium.hGlobal);
	return hr;
}


HRESULT CTripCall::ContextSensitiveHelp(BOOL fEnterMode)
{
	return S_OK;
}


HRESULT CTripCall::GetClipboardData(CHARRANGE * pchrg,
					DWORD reco, LPDATAOBJECT * ppdataobj)
{
	HRESULT     hr;
	LPADRLIST	pal = NULL;
	CTripData *	ptripdata;

	//$ REVIEW - possible optimization - return E_NOTIMPL if no objects
	//				in selection

	// Exchange 18403: Need to prevent cut on read only
	if (reco == RECO_CUT &&
		(GetWindowStyle(_hwndEdit) & ES_READONLY))
		return E_NOTIMPL;

	hr = THR(_pPad->BuildSelectionAdrlist(&pal, _hwndEdit, pchrg));
	if (hr)
		goto Error;

	// this will gobble up the pal so I don't want to free it
	ptripdata = new CTripData((LPSRowSet) pal);
	if (!ptripdata)
		goto Error;

	// steal the refcount of the ptripdata
	*ppdataobj = (LPDATAOBJECT) ptripdata;

	return S_OK;

Error:
	FreeAdrlist(pal);
	RRETURN(E_FAIL);
}


HRESULT CTripCall::GetDragDropEffect(BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
	if (fDrag)			// use the default
		return S_OK;

	if (GetWindowLong(_hwndEdit, GWL_STYLE) & ES_READONLY)
	{
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		if ((grfKeyState & MK_CONTROL) || !(*pdwEffect & DROPEFFECT_MOVE))
			*pdwEffect = DROPEFFECT_COPY;
		else
			*pdwEffect = DROPEFFECT_MOVE;
	}

	return S_OK;
}


HRESULT CTripCall::GetContextMenu(WORD seltype,	LPOLEOBJECT poleobj, CHARRANGE * pchrg,
                                    HMENU * phmenu)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\msgwnd.cxx ===
/***********************************************************************
 *
 *  FORMWND.CPP
 *
 *
 *  Copyright 1986-1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

#include "padhead.hxx"

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_MSGTRIPL_HXX_
#define X_MSGTRIPL_HXX_
#include "msgtripl.hxx"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#define  WM_DEFERCOMBOUPDATE        (WM_APP + 1)
const int cxMargin = 4;
const int cyMargin = 4;

LRESULT DlgChildWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WNDPROC pWndProc;
    LRESULT lResult;

    pWndProc = (WNDPROC)GetWindowLong(hwnd, GWL_USERDATA);

    switch ( msg )
    {
        case WM_LBUTTONUP:
        {
            CPadMessage * pPad;
            pPad = (CPadMessage *) GetWindowLong(GetParent(GetParent(hwnd)), GWL_USERDATA);

            // Hack: Need to do the default behavior before deactivating the pad so that the button
            // other the button has shifted underneath the mouse by the time the default processing
            // for WM_LBUTTONUP happens and it does not fire the WM_COMMAND
            lResult = CallWindowProc(pWndProc, hwnd, msg, wParam, lParam);

            pPad->OnDialogControlActivate(hwnd);

            return lResult;
        }
    }

    return CallWindowProc(pWndProc, hwnd, msg, wParam, lParam);
}


void
CPadMessage::HookControl(ULONG ulIdControl)
{
    WNDPROC pWndProc;
    HWND hwndControl;

    hwndControl = GetDlgItem(_hwndDialog, ulIdControl);
    pWndProc = (WNDPROC)SetWindowLong(hwndControl, GWL_WNDPROC, (LONG)DlgChildWndProc);
    SetWindowLong(hwndControl, GWL_USERDATA, (LONG)pWndProc);
}


void
CPadMessage::OnDialogControlActivate(HWND hwndControl)
{
    CPadDoc * pPad1;

    // Make sure the command has not deleted pPad
    for(pPad1 = g_pDocFirst; pPad1 != NULL; pPad1 = pPad1->_pDocNext)
    {
        if(pPad1 == this)
            break;
    }

    // If not, deactivate Trident DocObject
    if(pPad1)
    {
        Assert(pPad1 == this);
        IGNORE_HR(UIDeactivateDoc());
    }

    // ISSUE: chrisf - hack: apparently the focus goes away from the control
    // during UIdeactivateDoc
    SetFocus(hwndControl);
}


HWND
CPadMessage::CreateField(
    ULONG ulIdField,
    ULONG ulIdLabel,
    DWORD dwStyle,
    BOOL fCreateOleCallBack)
{
    RECT rc;
    HWND hwndField;
    DWORD dwEventMask;
    HFONT hFont;
    CTripCall * pTripCall = NULL;

    hwndField = GetDlgItem(_hwndDialog, ulIdLabel);
    GetWindowRect(hwndField, &rc);

    hwndField = CreateWindowEx(
            WS_EX_CLIENTEDGE,	// extended window style
            TEXT("RichEdit"),	// pointer to registered class name
            LPCTSTR (NULL),	    // pointer to window name
            dwStyle |
            WS_CHILD | WS_VISIBLE | ES_MULTILINE |
            ES_SUNKEN | ES_SAVESEL | WS_TABSTOP,	// window style
            rc.right - _rcDialog.left + cxMargin,
            rc.top - _rcDialog.top,
            _rcDialog.right - rc.right - cxMargin * 2,	
            rc.bottom - rc.top,
            _hwndDialog,    // handle to parent or owner window
            NULL,	        // handle to menu, or child-window identifier
            g_hInstCore,	// handle to application instance
            NULL         	// pointer to window-creation data
    );

    if (!hwndField)
        goto Cleanup;

    SetWindowLong(hwndField, GWL_ID, ulIdField);

    dwEventMask = SendMessage(hwndField, EM_GETEVENTMASK, 0, 0);
    SendMessage(hwndField, EM_SETEVENTMASK, 0,
                    dwEventMask | ENM_REQUESTRESIZE | ENM_MOUSEEVENTS);

    hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hwndField, WM_SETFONT, (WPARAM)hFont, 0);

    SendMessage(hwndField, EM_REQUESTRESIZE, 0, 0);

    if (dwStyle & ES_READONLY)
        SendMessage(hwndField, EM_SETBKGNDCOLOR, FALSE, GetSysColor(COLOR_BTNFACE));

    if (fCreateOleCallBack)
    {
        pTripCall = new CTripCall(this, hwndField, TRUE);
        if (!pTripCall)
        {
            hwndField = NULL;
            goto Cleanup;
        }

        Verify(SendMessage(hwndField, EM_SETOLECALLBACK, 0, (LPARAM)pTripCall));
    }

Cleanup:
    if (pTripCall)
        pTripCall->Release();

    return hwndField;
}

HDWP
CPadMessage::FieldRequestResize (
    HDWP    hdwp,
    RECT *  prcResize,
    ULONG   ulIdResize,
    ULONG   ulIdField,
    ULONG   ulIdLabel,
    RECT *  prcSubmitBtn,
    int *   pcyDialogHeight)
{
    HWND    hwndField;
    HWND    hwndLabel;
    RECT    rc;
    int     cyHeight;

    hwndField = GetDlgItem(_hwndDialog, ulIdField);
    if (!hwndField)
        return hdwp;

    GetWindowRect(hwndField, &rc);

    cyHeight = (ulIdResize == ulIdField) ?
                prcResize->bottom - prcResize->top + 1:
                rc.bottom - rc.top;

    if (*pcyDialogHeight == 0)
        *pcyDialogHeight = rc.top - _rcDialog.top;

    if (rc.top - _rcDialog.top >= prcResize->top)
    {
         hdwp = DeferWindowPos(hdwp, hwndField, NULL,
                rc.left - _rcDialog.left,
                *pcyDialogHeight,
                _rcDialog.right - rc.left -
                    (prcSubmitBtn &&
                        (*pcyDialogHeight + _rcDialog.top <= prcSubmitBtn->bottom) ?
                            prcSubmitBtn->right - prcSubmitBtn->left + cxMargin * 2 :
                            cxMargin),
                cyHeight,
                SWP_NOACTIVATE | SWP_NOZORDER);
          if(!hdwp)
                return NULL;

         // reposition Field Button
         hwndLabel = GetDlgItem(_hwndDialog, ulIdLabel);
         if (hwndLabel)
         {
             GetWindowRect(hwndLabel, &rc);
             hdwp = DeferWindowPos(hdwp, hwndLabel, NULL,
                          rc.left - _rcDialog.left,
                          *pcyDialogHeight,
                          0, 0,
                          SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
             if(!hdwp)
                 return NULL;
         }
     }

     *pcyDialogHeight += cyHeight + cyMargin;

     return hdwp;
}


//+---------------------------------------------------------------------------
//
//  Member:     FormDlgProcSend
//              CPadMessage::DlgProcSend
//
//  Synopsis:   Dialog procedure for field dialogs, Send form
//
//----------------------------------------------------------------------------

BOOL CALLBACK FormDlgProcSend(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadMessage *       pPad;

    pPad = (CPadMessage *) GetWindowLong(GetParent(hwnd), GWL_USERDATA);

    Assert(pPad);

    return pPad->DlgProcSend(hwnd, msg, wParam, lParam);
}

BOOL
CPadMessage::DlgProcSend(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT                rc;
    int                 wmId;
    int                 wmEvent;
    HBITMAP             hBitmap;
    HWND                hButton;

    switch ( msg )
    {
    case WM_INITDIALOG:
    {
        _hwndDialog = hwnd;

        GetWindowRect(hwnd, &_rcDialog);

        // Load bitmap in "Send" button
        hBitmap = LoadBitmap(g_hInstResource, MAKEINTRESOURCE(IDB_MESSAGE_SEND));
        hButton = GetDlgItem(hwnd, ID_SUBMIT);
        SendMessage(hButton, BM_SETIMAGE,0, (LONG) hBitmap);

        // Create TO, CC and SUBJECT fields
        _rghwndEdit[0] = NULL;
        _rgulRecipTypes[0] = MAPI_ORIG;

        _rghwndEdit[1] = CreateField(ID_TO, ID_TO_BUTTON, 0, TRUE);
        _rgulRecipTypes[1] = MAPI_TO;

        _rghwndEdit[2] = CreateField(ID_CC, ID_CC_BUTTON, 0, TRUE);
        _rgulRecipTypes[2] = MAPI_CC;

        _cRecipTypes = 3;

        CreateField(ID_SUBJECT, ID_SUBJECT_LABEL, 0, FALSE);

        // Hook TO and CC buttons to trap mouse up
        HookControl(ID_TO_BUTTON);
        HookControl(ID_CC_BUTTON);

        return TRUE;
    }
    case WM_WINDOWPOSCHANGED:
        {
            HWND        hwndItem;
            HWND        hwndIcon;
            RECT        rc;
            RECT        rcSubmitBtn;
            int         cxSubmitBtn;
            int         xSubmitBtn;
            int         cxDialogOld;
            int         cyDialogOld;

            Assert(_hwndDialog == hwnd);

            cxDialogOld = _rcDialog.right - _rcDialog.left;
            cyDialogOld = _rcDialog.bottom - _rcDialog.top;

            GetWindowRect(hwnd, &_rcDialog);

            if (cxDialogOld != _rcDialog.right - _rcDialog.left)
            {
                hwndIcon = GetDlgItem(hwnd, ID_SUBMIT);
                GetWindowRect(hwndIcon, &rcSubmitBtn);
                ScreenToClient(hwnd, (POINT*)&rcSubmitBtn.left);
                ScreenToClient(hwnd, (POINT*)&rcSubmitBtn.right);
                cxSubmitBtn = rcSubmitBtn.right - rcSubmitBtn.left;

                HDWP hdwp = BeginDeferWindowPos(4);
                if(NULL == hdwp)
                    break;

                hwndItem = GetDlgItem(hwnd, ID_TO);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxSubmitBtn - cxMargin * 2,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_CC);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxSubmitBtn - cxMargin * 2,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SUBJECT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                xSubmitBtn = _rcDialog.right - _rcDialog.left - cxSubmitBtn - cxMargin;
                if(NULL == DeferWindowPos(hdwp, hwndIcon, NULL, xSubmitBtn, rcSubmitBtn.top,
                            rcSubmitBtn.right - rcSubmitBtn.left, rcSubmitBtn.bottom - rcSubmitBtn.top,
                            SWP_NOACTIVATE | SWP_NOZORDER))
                {
                    break;
                }

                EndDeferWindowPos(hdwp);
            }

            if (cyDialogOld != _rcDialog.bottom - _rcDialog.top)
            {
                Resize();
            }
        }
        break;

    case WM_NOTIFY:
        wmId = wParam;
        wmEvent = ((NMHDR*)lParam)->code;

        Assert(_hwndDialog == hwnd);

        switch(wmEvent)
        {
        case EN_MSGFILTER:
            if (((MSGFILTER*)lParam)->msg == WM_LBUTTONUP)
            {
                OnDialogControlActivate(((MSGFILTER*)lParam)->nmhdr.hwndFrom);
            }
            break;

        case EN_REQUESTRESIZE:
            {
            int             cyDialogHeight = 0;
            HWND            hwndItem;
            REQRESIZE *     lpResize;
            HWND            hwndIcon;
            HDWP            hdwp;
            RECT            rcSubmitBtn;

            // Get new height for item requesting size change
            lpResize = (REQRESIZE *)(lParam);

            // Break out if no change in size
            hwndItem = GetDlgItem(hwnd, wmId);
            GetWindowRect(hwndItem, &rc);
            if(lpResize->rc.bottom - lpResize->rc.top + 1 == rc.bottom - rc.top)
                break;

            // Get Submit button width
            hwndIcon = GetDlgItem(hwnd, ID_SUBMIT);
            GetWindowRect(hwndIcon, &rcSubmitBtn);

            hdwp = BeginDeferWindowPos(6);
            if(!hdwp)
                break;

            // Reposition TO field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_TO, ID_TO_BUTTON,
                                    &rcSubmitBtn, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition CC field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_CC, ID_CC_BUTTON,
                                    &rcSubmitBtn, &cyDialogHeight);
            if(!hdwp)
                break;

            // Reposition Subject field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId, ID_SUBJECT, ID_SUBJECT_LABEL,
                                    &rcSubmitBtn, &cyDialogHeight);
            if(!hdwp)
                break;

            EndDeferWindowPos(hdwp);

            // Resize dialog as a whole
            SetWindowPos(hwnd, NULL, 0, 0, _rcDialog.right - _rcDialog.left,
                         cyDialogHeight, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch(wmId) {
        case ID_TO_BUTTON:
        case ID_CC_BUTTON:
            switch (wmEvent) {
            case BN_CLICKED:
                Address(wmId);
                break;

            default:
                return FALSE;
            }
            break;
        case ID_SUBJECT:
            if (wmEvent == EN_KILLFOCUS) {
                TCHAR    sz[250];

                if (Edit_GetText(GET_WM_COMMAND_HWND(wParam, lParam), sz, 200)) {
                    lstrcat(sz, TEXT (" - "));
                    lstrcat(sz, g_achWindowCaption);
                    SetWindowText(GetParent(hwnd), sz);
                }
                else
                    SetWindowText(GetParent(hwnd), g_achWindowCaption);

                break;
            }
            return FALSE;
        case ID_SUBMIT:
            if(wmEvent == BN_CLICKED)
            {
                SendMessage(GetParent(hwnd), WM_COMMAND, IDM_MESSAGE_SUBMIT, 0);
            }
            return TRUE;
        }
        return FALSE;

    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     FormDlgProcRead
//              CPadMessage::DlgProcRead
//
//  Synopsis:   Dialog procedure for field dialogs, Read form
//
//----------------------------------------------------------------------------

BOOL CALLBACK FormDlgProcRead(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadMessage *       pPad;

    pPad = (CPadMessage *) GetWindowLong(GetParent(hwnd), GWL_USERDATA);

    Assert(pPad);

    return pPad->DlgProcRead(hwnd, msg, wParam, lParam);
}

BOOL
CPadMessage::DlgProcRead(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT                rc;
    int                 wmId;
    int                 wmEvent;

    switch ( msg ) {
    case WM_INITDIALOG:
    {
        _hwndDialog = hwnd;

        GetWindowRect(hwnd, &_rcDialog);

        // Create TO, CC and SUBJECT fields
        CreateField(ID_FROM, ID_FROM_LABEL, ES_READONLY, FALSE);
        CreateField(ID_SENT, ID_SENT_LABEL, ES_READONLY, FALSE);
        CreateField(ID_TO, ID_TO_LABEL, ES_READONLY, FALSE);
        CreateField(ID_CC, ID_CC_LABEL, ES_READONLY, FALSE);
        CreateField(ID_SUBJECT, ID_SUBJECT_LABEL, ES_READONLY, FALSE);

        return TRUE;
    }

    case WM_NOTIFY:
        wmId = wParam;
        wmEvent = ((NMHDR*)lParam)->code;

        Assert(_hwndDialog == hwnd);

        switch(wmEvent)
        {
        case EN_MSGFILTER:
            if (((MSGFILTER*)lParam)->msg == WM_LBUTTONUP)
            {
                OnDialogControlActivate(((MSGFILTER*)lParam)->nmhdr.hwndFrom);
            }
            break;

        case EN_REQUESTRESIZE:
            {
            int             cyDialogHeight = 0;
            HWND            hwndItem;
            REQRESIZE *     lpResize;
            HDWP            hdwp;

            // Get new height for item requesting size change
            lpResize = (REQRESIZE *)(lParam);

            // Break out if no change in size
            hwndItem = GetDlgItem(hwnd, wmId);
            GetWindowRect(hwndItem, &rc);
            if(lpResize->rc.bottom - lpResize->rc.top + 1 == rc.bottom - rc.top)
                break;

            hdwp = BeginDeferWindowPos(10);
            if(!hdwp)
                break;

            // Reposition FROM field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_FROM, ID_FROM_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition SENT field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_SENT, ID_SENT_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition TO field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_TO, ID_TO_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition CC field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_CC, ID_CC_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            // Reposition SUBJECT field
            hdwp =  FieldRequestResize (hdwp, &lpResize->rc, wmId,
                        ID_SUBJECT, ID_SUBJECT_LABEL, NULL, &cyDialogHeight);

            if(!hdwp)
                break;

            EndDeferWindowPos(hdwp);

            // Resize dialog as a whole
            SetWindowPos(hwnd, NULL, 0, 0, _rcDialog.right - _rcDialog.left,
                         cyDialogHeight, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;


    case WM_WINDOWPOSCHANGED:
        {
            HWND        hwndItem;
            RECT        rc;
            int         cxDialogOld;
            int         cyDialogOld;

            Assert(_hwndDialog == hwnd);

            cxDialogOld = _rcDialog.right - _rcDialog.left;
            cyDialogOld = _rcDialog.bottom - _rcDialog.top;

            GetWindowRect(hwnd, &_rcDialog);

            if (cxDialogOld != _rcDialog.right - _rcDialog.left)
            {
                HDWP hdwp = BeginDeferWindowPos(5);
                if(NULL == hdwp)
                    break;

                hwndItem = GetDlgItem(hwnd, ID_FROM);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SENT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_TO);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_CC);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                hwndItem = GetDlgItem(hwnd, ID_SUBJECT);
                if (hwndItem)
                {
                    GetWindowRect(hwndItem, &rc);
                    if(NULL == DeferWindowPos(hdwp, hwndItem, NULL, 0, 0, _rcDialog.right - rc.left - cxMargin,
                                 rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOMOVE |
                                 SWP_NOZORDER))
                    {
                        break;
                    }
                }

                EndDeferWindowPos(hdwp);
        }

        if (cyDialogOld != _rcDialog.bottom - _rcDialog.top)
        {
           Resize();
        }
    }
        break;
    }
    return FALSE;
}


//
// Window proc for frame window of both the read and send form.
//
//  Send frame window does not receive IDC_VIEW_ITEMABOVE, IDC_VIEW_ITEMBELOW
// commands.
// Read frame window does not receive IDC_MESSAGE_SUBMIT command.
LRESULT
CPadMessage::PadWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    HRESULT             hr;
    HMENU               hMenu;
    int                 wmId;
    int                 wmEvent;

    switch( wm )
    {
    case WM_DESTROY:
        OnDestroy();
        break;

    case WM_DEFERCOMBOUPDATE:
        return OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_COMMAND:
        wmId = GET_WM_COMMAND_ID(wParam, lParam);
        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam);

        switch( wmId )
        {
        case IDM_MESSAGE_OPENHTM:
            hr = THR(PromptOpenFile(_hwnd, &CLSID_HTMLDocument));
            _fUserMode = 0;
            SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
            break;

        case IDM_MESSAGE_CLOSE:
            ShutdownForm(SAVEOPTS_PROMPTSAVE);
            break;

        case IDM_MESSAGE_SAVE:
            hr = THR(DoSave(FALSE));
            if ( hr == MSOCMDERR_E_CANCELED )
            {
                hr = S_OK;
            }
            break;

        case IDM_MESSAGE_SAVE_AS:
            hr = THR(DoSave(TRUE));
            if ( hr == MSOCMDERR_E_CANCELED )
            {
                hr = S_OK;
            }
            break;

        case IDM_VIEW_ITEMABOVE:
        case IDM_VIEW_ITEMBELOW:
            {
                ULONG ulDir = IDM_VIEW_ITEMABOVE == wmId ? VCDIR_PREV:VCDIR_NEXT;
                DoNext(ulDir);

                break;
            }

        case IDM_MESSAGE_DELETE:
            DoDelete();
            break;

        case IDM_MESSAGE_REPLY:
            DoReply(eREPLY);
            break;

        case IDM_MESSAGE_REPLY_ALL:
            DoReply(eREPLY_ALL);
            break;

        case IDM_MESSAGE_FORWARD:
            DoReply(eFORWARD);
            break;

        case IDM_MESSAGE_SUBMIT:
            DoSubmit();
            break;

        case IDM_MESSAGE_COPY:
            DoCopy();
            break;

        case IDM_MESSAGE_MOVE:
            DoMove();
            break;

        case IDM_MESSAGE_CHECK_NAMES:
            DoCheckNames();
            break;

        case IDM_FONTSIZE:
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
        case IDM_FORECOLOR:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                PostMessage(_hwnd, WM_DEFERCOMBOUPDATE, wParam, lParam);
            }
            break;

        default:
            return OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        }
        break;

        //
        //  Do all of the correct menu graying
        //

    case WM_INITMENU:
        hMenu = (HMENU) wParam;
        ConfigMenu(hMenu);
        break;

        //
        //  Deal with the System Close message
        //
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_CLOSE)
        {
            ShutdownForm(SAVEOPTS_PROMPTSAVE);
        }
        else
        {
            goto DoDefault;
        }
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndDialog);
        break;

    default:

DoDefault:
        return CPadDoc::PadWndProc(hwnd, wm, wParam, lParam);
    }

    return 0;
}



HRESULT
CPadMessage::InitReadToolbar ()
{
    static const TBBUTTON tbButton[] =
    {
        { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_MESSAGE_PRINT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_MESSAGE_MOVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 2, IDM_MESSAGE_DELETE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 3, IDM_MESSAGE_REPLY, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 4, IDM_MESSAGE_REPLY_ALL, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_MESSAGE_FORWARD, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        { 6, IDM_VIEW_ITEMABOVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 7, IDM_VIEW_ITEMBELOW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},


        { 8, IDM_PAD_ABOUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { 10, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

    };

    HRESULT     hr = S_OK;

    // Create the toolbar

    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
            IDR_MESSAGE_TOOLBAR,
            9,                             // number of bitmaps
            g_hInstResource,
            IDB_MESSAGE_TOOLBAR,
            (LPCTBBUTTON) &tbButton,
            ARRAY_SIZE(tbButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));
    if (!_hwndToolbar)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padauto.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padauto.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifdef USE_PERFORMANCE_DATA_HELPER
#include <pdh.h>
#endif

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include "platform.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_UNICWRAP_HXX
#define X_UNICWRAP_HXX
#include "unicwrap.hxx"
#endif

#ifndef X_MSHTMSVR_H_
#define X_MSHTMSVR_H_
#include "mshtmsvr.h"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_DIMM_HXX_
#define X_DIMM_HXX_
#include "dimm.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_PRIVACY_H_
#define X_PRIVACY_H_
#include "privacy.h"
#endif

#undef ASSERT

PerfTag(tagPerfScript, "Perf", "PerfLog from pad script")

DeclareTag(tagScriptLog, "ScriptLog", "script log");

DeclareTag(tagSnapGrid, "Snap to Grid", "Snap to Grid");
DeclareTag(tagShowMoveMouseTo,"Pad","Show MoveMouseTo Output");

extern DYNLIB g_dynlibMSHTML;

extern "C" const GUID SID_SHTMLEditServices;

DYNLIB g_dynlibOLEACC = { NULL, NULL, "OLEACC.DLL" };

#define FILEBUFFERSIZE 2048

#ifndef UNIX
#define PRINTDRT_FILE _T("c:\\printdrt.ps")  // CONSIDER: use GetTempFileName instead.
#define PRINTDRT_FILEA "c:\\printdrt.ps"
#else
#define PRINTDRT_FILE _T("printdrt.ps")  // CONSIDER: use GetTempFileName instead.
#define PRINTDRT_FILEA "printdrt.ps"
#endif
#define WM_UPDATEDEFAULTPRINTER WM_USER+338

#define MSHTML_WINDOW_CLASSNAME     _T("Internet Explorer_Server")
#define MSGNAME_WM_HTML_GETOBJECT   _T("WM_HTML_GETOBJECT")

TCHAR achScriptPath[MAX_PATH] = { 0 };
TCHAR achScriptStartDir[MAX_PATH] = { 0 };
TCHAR achDRTPath[MAX_PATH] = { 0 };
HWND  hwndInternetExplorerServer = 0;

//
// Array of keyboard layouts used for the IME testss.
// The Global IMEs that ship with US systems prior to NT 5.0 can
// be activated using the layouts in the first column.  NT 5.0
// systems activate the IMEs using the layouts on the second
// column.
//
#define KEYBOARD_LAYOUT_JPN     0
#define KEYBOARD_LAYOUT_KOR     1
#define KEYBOARD_LAYOUT_CHT     2
#define KEYBOARD_LAYOUT_CHS     3

#define KEYBOARD_LAYOUT_MAX     4

char *astrKeyboardLayouts[KEYBOARD_LAYOUT_MAX][2] =
        {
            {   "00000411", "E0010411"  },          // Japanese (Global IMEs) / NT 5.0
            {   "00000412", "E0010412"  },          // Korean
            {   "00000404", "E0010404"  },          // Traditional Chinese
            {   "00000804", "E00E0804"  }           // Simplified Chinese
        };


#ifdef UNIX
void SanitizePath( TCHAR *pszPath )
{
    if ( pszPath ) {
        TCHAR *pch = pszPath;

        while (*pch) {
            if (( *pch == L'/') ||
                ( *pch == L'\\')) {
                *pch = _T(FILENAME_SEPARATOR);
            }

            pch++;
        }
    }
}
#endif

void PrimeDRTPath()
{
    if (!achDRTPath[0])
    {
        char achDRTPathA[MAX_PATH] = "";

        GetPrivateProfileStringA("PadDirs","DRTScript","",achDRTPathA,MAX_PATH, "mshtmdbg.ini");

        if (achDRTPathA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achDRTPathA, MAX_PATH, achDRTPath, MAX_PATH);
        }

    }

    if (!achDRTPath[0])
    {
        TCHAR  *pch;

        // Prime file name with drt file directory.

        // Start with the directory containing this file.

        _tcscpy(achDRTPath, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achScriptPath.

        for (int i = 0; i < 4; i++)
        {
            pch = _tcsrchr(achDRTPath, _T(FILENAME_SEPARATOR));
            if (pch)
                *pch = 0;
        }

        // Glue on the name of the directory containing the test cases.

        _tcscat(achDRTPath, _T(FILENAME_SEPARATOR_STR)
                               _T("src")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("f3")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("drt")
                               _T(FILENAME_SEPARATOR_STR)
                               _T("0drt.js"));
    }
}

void PrimeScriptStartDir()
{
    // look in mshtmdbg.ini first
    if(!achScriptStartDir[0])
    {
        char achScriptPathA[MAX_PATH] = "";

        GetPrivateProfileStringA("PadDirs","ScriptDir","",achScriptPathA,MAX_PATH, "mshtmdbg.ini");

        if (achScriptPathA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achScriptPathA, MAX_PATH, achScriptStartDir, MAX_PATH);
        }
    }

    // cobble something up form where we were compiled
    if (!achScriptStartDir[0])
    {
        TCHAR  *pch;

        // Prime file name with drt file directory.

        // Start with the directory containing this file.

        _tcscpy(achScriptStartDir, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achScriptPath.

        for (int i = 0; i < 4; i++)
        {
            pch = _tcsrchr(achScriptStartDir, _T(FILENAME_SEPARATOR));
            if (pch)
                *pch = 0;
        }

        // Glue on the name of the directory containing the test cases.

        _tcscat(achScriptStartDir,  _T(FILENAME_SEPARATOR_STR)
                                    _T("src")
                                    _T(FILENAME_SEPARATOR_STR)
                                    _T("f3")
                                    _T(FILENAME_SEPARATOR_STR)
                                    _T("drt"));
    }
}

HRESULT
CPadDoc::ExecuteDRT()
{
    HRESULT hr = S_OK;

    PrimeDRTPath();

    hr = THR(ExecuteTopLevelScript(achDRTPath));

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
        hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        TCHAR achMsg[400];

        _tcscpy(achMsg, _T("Could not find the DRT script at "));
        _tcscat(achMsg, achDRTPath);
        _tcscat(achMsg, _T(".\nDo you wish to try and find the script yourself?"));

        if (MessageBox(_hwnd, achMsg, _T("Could not find DRT."), MB_YESNO) == IDYES)
        {
            hr = THR(PromptExecuteScript(TRUE));
        }
        else
        {
            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CPadDoc::PromptExecuteScript(BOOL fDRT)
{
    HRESULT         hr;
    OPENFILENAME    ofn;
    BOOL            f;
    TCHAR *         pchPath;
    TCHAR *         pchStartDir;

    if (fDRT)
    {
        // This should only be called from ExecuteDRT which
        // will already have called PrimeScriptPath.  We didn't
        // find the DRT start file so we open the dialog at
        // where we looked for it.
        Assert( *achDRTPath );
        pchPath = achDRTPath;
        pchStartDir = NULL;
    }
    else
    {
        if (!*achScriptStartDir)
        {
            PrimeScriptStartDir();
        }

        pchPath = achScriptPath;
        pchStartDir = *pchPath ? NULL : achScriptStartDir;
    }

    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = _hwnd;
    ofn.lpstrFilter = TEXT("All Scripts (*.js;*.vbs)\0*.js;*.vbs\0JavaScript (*.js)\0*.js\0VBScript (*.vbs)\0*.vbs\0All Files (*.*)\0*.*\0");
    ofn.lpstrFile = pchPath;
    ofn.lpstrDefExt = _T("js");
    ofn.lpstrInitialDir = pchStartDir;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    DbgMemoryTrackDisable(TRUE);
    f = GetOpenFileName(&ofn);
    DbgMemoryTrackDisable(FALSE);

    if (!f)
        return S_FALSE;

    hr = THR(ExecuteTopLevelScript(pchPath));

    RRETURN(hr);
}

HRESULT
CPadDoc::LoadTypeLibrary()
{
    HRESULT hr = S_OK;
    TCHAR achExe[MAX_PATH];

    if (!_pTypeLibPad)
    {
        GetModuleFileName(g_hInstCore, achExe, MAX_PATH);

        // ISSUE (carled) again the crt library shutdown causes oleaut32 to leak memory
        // which is allocated on the very first call to GetTypeLib. Remove this
        // block once the crt libraries are no longer linked in.

        DbgMemoryTrackDisable(TRUE);

        hr = THR(LoadTypeLib(achExe, &_pTypeLibPad));

        DbgMemoryTrackDisable(FALSE);

        if (hr)
            goto Cleanup;

        hr = THR(RegisterTypeLib(_pTypeLibPad, achExe, NULL));
        if (hr)
            goto Cleanup;
    }

    if (!_apTypeComp[0])
    {
        hr = THR(_pTypeLibPad->GetTypeComp(&_apTypeComp[0]));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoCPad)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(CLSID_Pad, &_pTypeInfoCPad));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoIPad)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_IPad, &_pTypeInfoIPad));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoILine)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_ILine, &_pTypeInfoILine));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoICascaded)
    {
        hr = THR(_pTypeLibPad->GetTypeInfoOfGuid(IID_ICascaded, &_pTypeInfoICascaded));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeLibDLL)
    {
        // If specified, load MSHTML from the system[32] directory
        // instead of the from the exe directory.
        if (g_fLoadSystemMSHTML)
        {
            UINT uRet = GetSystemDirectory(achExe, sizeof(achExe));
            Assert(uRet);
            achExe[uRet] = FILENAME_SEPARATOR;

            achExe[uRet + 1] = 0;
        }

        TCHAR * pchName = _tcsrchr(achExe, FILENAME_SEPARATOR);
        if (!pchName)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

#ifdef UNIX
        _tcscpy(achExe, _T("mshtml.tlb"));
#else
        _tcscpy(pchName + 1, _T("mshtml.tlb"));
#endif
        hr = THR(LoadTypeLib(achExe, &_pTypeLibDLL));

        if (hr)
        {
#ifdef UNIX
            _tcscpy(achExe, _T("mshtml.dll"));
#else
            _tcscpy(pchName + 1, _T("mshtml.dll"));
#endif

            hr = THR(LoadTypeLib(achExe, &_pTypeLibDLL));
            if (hr)
                goto Cleanup;
        }
    }

    if (!_apTypeComp[1])
    {
        hr = THR(_pTypeLibDLL->GetTypeComp(&_apTypeComp[1]));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PushScript
//
//  Create a new script site/engine and push it on the script stack
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PushScript(TCHAR *pchType)
{
    HRESULT hr;
    CPadScriptSite * pScriptSite;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    pScriptSite = new CPadScriptSite(this);
    if(!pScriptSite)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pScriptSite->Init(pchType);
    if (hr)
    {
        delete pScriptSite;
        pScriptSite = NULL;
        goto Cleanup;
    }

    pScriptSite->_pScriptSitePrev = _pScriptSite;
    _pScriptSite = pScriptSite;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PopScript
//
//  Pop last script site/engine off the script stack
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PopScript()
{
    CPadScriptSite * pScriptSite = _pScriptSite;

    if(!_pScriptSite)
        return S_FALSE;

    // Script about to unload fire unload.
    FireEvent(DISPID_PadEvents_Unload, 0, NULL);

    _pScriptSite = _pScriptSite->_pScriptSitePrev;

    pScriptSite->Close();
    delete pScriptSite;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CloseScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CloseScripts()
{
    while(PopScript() == S_OK)
        ;

    Assert(_pScriptSite == NULL);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteTopLevelScript
//
//  Close previous top level script engine then load and execute script
//  in a new top level script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteTopLevelScript(TCHAR * pchPath)
{
    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    // Getting read to close the scripts fire unload event.
    CloseScripts();

    hr = THR(PushScript(_tcsrchr(pchPath, _T('.'))));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->ExecuteScriptFile(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    FireEvent(DISPID_PadEvents_Load, 0, NULL);

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteScriptlet
//
//  Add a scriptlet to the current top level script engine and execute it
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteTopLevelScriptlet(TCHAR * pchScript)
{
    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    if(!_pScriptSite)
    {
        hr = THR(PushScript(NULL));
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pScriptSite->_pScriptSitePrev == NULL);
    }

    hr = THR(_pScriptSite->ExecuteScriptStr(pchScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, UINT carg, VARIANTARG *pvararg)
{
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;

    if (_pScriptSite && _pScriptSite->_pDispSink)
    {
        dp.rgvarg            = pvararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = carg;
        dp.cNamedArgs        = 0;

        _pScriptSite->_pDispSink->Invoke(
                dispid,
                IID_NULL,
                0,
                DISPATCH_METHOD,
                &dp,
                NULL,
                &ei,
                &uArgErr);
    }
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, LPCTSTR pch)
{
    VARIANT var;

    V_BSTR(&var) = SysAllocString(pch);
    V_VT(&var) = VT_BSTR;
    FireEvent(dispid, 1, &var);
    SysFreeString(V_BSTR(&var));
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FireEvent
//
//---------------------------------------------------------------------------

void
CPadDoc::FireEvent(DISPID dispid, BOOL fArg)
{
    VARIANT var;

    V_BOOL(&var) = fArg ? VARIANT_TRUE : VARIANT_FALSE;
    V_VT(&var) = VT_BOOL;
    FireEvent(dispid, 1, &var);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = _pTypeInfoIPad;
    (*pptinfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pTypeInfoIPad->GetIDsOfNames(rgszNames, cNames, rgdispid));

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pdispparams, VARIANT * pvarResult,EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pTypeInfoIPad->Invoke((IPad *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DoEvents, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DoEvents(VARIANT_BOOL fWait)
{
    PADTHREADSTATE * pts = GetThreadState();

    PerfLog1(tagPerfWatchPad, this, "+CPadDoc::DoEvents(fWait=%d)", fWait);

    pts->fEndEvents = FALSE;
    pts->cDoEvents += !!fWait;
    Run(!fWait);

    if (fWait && !pts->fEndEvents)
    {
        MessageBox(
            _hwnd,
            TEXT("Warning: DoEvents TRUE was not balanced by a call to EndEvents."),
            TEXT("EndEvents pad script error"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    if (pts->fEndEvents && !fWait)
    {
        MessageBox(
            _hwnd,
            TEXT("Warning: EndEvents called inside a DoEvents FALSE."),
            TEXT("EndEvents pad script error"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    pts->fEndEvents = FALSE;
    pts->cDoEvents -= !!fWait;

    PerfLog(tagPerfWatchPad, this, "-CPadDoc::DoEvents()");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EndEvents, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::EndEvents()
{
    PADTHREADSTATE * pts = GetThreadState();

    if (!pts->cDoEvents)
    {
        return S_OK;
    }

    pts->fEndEvents = TRUE;

    PerfLog(tagPerfWatchPad, this, "CPadDoc::EndEvents()");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::OpenFileStream, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::OpenFileStream(BSTR bstrPath)
{
    HRESULT hr = S_OK;
    IStream *pStream = NULL;

    if (_fUseShdocvw)
        return E_FAIL;

    if (bstrPath && !*bstrPath)
        bstrPath = NULL;

    if (!bstrPath)
    {
        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(CreateStreamOnFile(bstrPath, STGM_READ|STGM_SHARE_DENY_NONE, &pStream));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Open(pStream));

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::OpenFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::OpenFile(BSTR bstrPath, BSTR bstrProgID)
{
    HRESULT hr = S_OK;
    VARIANT vEmpty;
    BOOL fUseBindToObject = FALSE;

    PerfLog1(tagPerfWatchPad, this, "+CPadDoc::OpenFile(\"%ls\")", bstrPath);

    if (bstrPath && !*bstrPath)
        bstrPath = NULL;

    if (bstrPath && (*bstrPath == '*'))
    {
        fUseBindToObject = TRUE;
        bstrPath += 1;
    }

#ifdef UNIX
    SanitizePath( bstrPath );
#endif

    if (bstrProgID && *bstrProgID)
    {
        CLSID clsid;

        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if(hr)
            goto Cleanup;

        hr = THR(Open(clsid, bstrPath));
    }
    else if (bstrPath)
    {
        if (_fUseShdocvw)
        {
            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile GetBrowser");
            hr = THR(GetBrowser());
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile GetBrowser");
            if (hr)
            {
                goto Cleanup;
            }

            VariantInit(&vEmpty);

            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile _pBrowser::Navigate()");
            hr = THR(_pBrowser->Navigate(bstrPath, &vEmpty, &vEmpty, &vEmpty, &vEmpty));
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile _pBrowser::Navigate()");

            PerfLog(tagPerfWatchPad, this, "+CPadDoc::OpenFile UpdateToolbarUI");
            UpdateToolbarUI();
            PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile UpdateToolbarUI");
        }
        else if (fUseBindToObject)
        {
            TCHAR ach[MAX_PATH];
            BOOL IsUrlPrefix(const TCHAR * pchPath);

            if (!IsUrlPrefix(bstrPath))
            {
                _tcscpy(ach, _T("file://"));
                _tcscat(ach, bstrPath);
                bstrPath = ach;
            }

            hr = THR(Open(bstrPath));
        }
        else
        {
            hr = THR(Open(CLSID_HTMLDocument, bstrPath));
        }
    }
    else
    {
        hr = THR(Open(CLSID_HTMLDocument, NULL));
    }

Cleanup:
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::OpenFile()");
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SaveFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SaveFile(BSTR bstrPath)
{
    if(!bstrPath)
        return E_INVALIDARG;

    return Save(bstrPath);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CloseFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CloseFile()
{
    HRESULT hr;

    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    Welcome();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteCommand, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteCommand(LONG lCmdID, VARIANT * pvarParam, VARIANT *pIDocument)
{
    HRESULT hr = S_OK;;
    IOleCommandTarget * pCommandTarget = NULL;
    IDispatch         * pIDisp = NULL;

    if (!_pInPlaceObject)
        goto Cleanup;

    if ( pIDocument && V_VT( pIDocument ) == VT_DISPATCH )
    {
        //
        // If they passed a document interface
        //
        hr = THR_NOTRACE( V_DISPATCH( pIDocument )->QueryInterface( IID_IOleCommandTarget, (void **)&pCommandTarget ) );
        if( hr )
            goto Cleanup;
    }
    else
    {
        if (! g_hwndActiveWindow)
        {
            hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
                                    IID_IOleCommandTarget,
                                    (void **)&pCommandTarget));
            if(hr)
                goto Cleanup;
        }
        else
        {
            // Direct the command to the host application
            hr = GetMshtmlDoc( HandleToLong( g_hwndActiveWindow ), & pIDisp );
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pIDisp->QueryInterface(
                                    IID_IOleCommandTarget,
                                    (void **)&pCommandTarget));
            if(hr)
                goto Cleanup;
        }
    }

    if(!pvarParam || pvarParam->vt != VT_ERROR)
    {
        hr = pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                lCmdID,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                pvarParam,
                NULL);
    }
    else
    {
        hr = pCommandTarget->Exec(
                (GUID *)&CGID_MSHTML,
                lCmdID,
                0,
                NULL,
                NULL);
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pIDisp);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetCommandState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::QueryCommandStatus(LONG lCmdID, VARIANT * pvarState)
{
    HRESULT hr;
    IOleCommandTarget * pCommandTarget = NULL;

    if(!pvarState)
        return E_INVALIDARG;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
                            IID_IOleCommandTarget,
                            (void **)&pCommandTarget));
    if(hr)
        goto Cleanup;

    pvarState->vt = VT_NULL;

    switch(lCmdID)
    {
    case IDM_FONTSIZE:
        pvarState->vt   = VT_I4;
        pvarState->lVal = 0;
        goto QueryWithExec;
    case IDM_BLOCKFMT:
        pvarState->vt      = VT_BSTR;
        pvarState->bstrVal = NULL;
        goto QueryWithExec;
    case IDM_FONTNAME:
        pvarState->vt      = VT_BSTR;
        pvarState->bstrVal = NULL;
        goto QueryWithExec;
    case IDM_FORECOLOR:
        pvarState->vt      = VT_I4;
        pvarState->lVal    = 0;
        goto QueryWithExec;

QueryWithExec:
        hr = THR(pCommandTarget->Exec(
                    (GUID *)&CGID_MSHTML,
                    lCmdID,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    pvarState));
        break;


    default:
        MSOCMD rgCmds[1];

        rgCmds[0].cmdID = lCmdID;

        hr = pCommandTarget->QueryStatus(
                (GUID *)&CGID_MSHTML,
                1,
                rgCmds,
                NULL);
        if(hr)
            goto Cleanup;

        pvarState->vt = VT_I4;
        pvarState->lVal = rgCmds[0].cmdf;
        break;
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

HRESULT
CPadDoc::TransformXGlobal(int x, int* retX)
{
   int y = 0;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL) ;
   *retX = x ;
   return (hr);
}


HRESULT
CPadDoc::TransformYGlobal(int y, int* retY)
{
   int x = 0;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL) ;
   *retY = y ;
   return (hr) ;
}

HRESULT
CPadDoc::TransformXDocument(int x , int* retX)
{
   int y =  0 ;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT) ;
   *retX = x ;
   return (hr) ;
}


HRESULT
CPadDoc::TransformYDocument(int y, int* retY)
{
   int x =  0  ;
   HRESULT hr = TransformPoint(x, y, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT) ;
   *retY = y ;
   return (hr);
}

HRESULT
CPadDoc::TransformPoint(int& X, int& Y, COORD_SYSTEM eSource, COORD_SYSTEM eDestination)
{
    HRESULT            hr = S_OK ;
    IDispatch *        pDocDisp = NULL;
    IDisplayServices*  pDispServices = NULL ;
    IHTMLDocument2*    pIDoc = NULL ;
    IHTMLElement *     pIBodyElement = NULL;
    POINT              point ;

    point.x = X ;
    point.y = Y ;

    hr = THR( get_Document( & pDocDisp ) );
    if (hr)
        goto Cleanup;

    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pIDoc) );
    Assert (pIDoc != NULL) ;

    hr = THR( pIDoc->get_body( &pIBodyElement ) ) ;
    if (hr)
        goto Cleanup;

    Assert (pIBodyElement  != NULL) ;

    hr = THR( pDocDisp->QueryInterface( IID_IDisplayServices, (void **) & pDispServices) );
    if (hr)
        goto Cleanup;

    hr = THR(pDispServices->TransformPoint( & point, eSource, eDestination, pIBodyElement) );
    X = point.x ;
    Y = point.y ;

  Cleanup :
    ReleaseInterface(pDispServices) ;
    ReleaseInterface(pIBodyElement);
    ReleaseInterface(pIDoc);
    ReleaseInterface(pDocDisp);

    RRETURN (hr);
}



//+--------------------------------------------------------------------------
//
//  Member : MoveMouseTo
//
//  Synopsis : this exposes mouse control through the pad's OM so that
//      (like send keys) script files, and drt tests can verify mouse
//      events and behavior.  the mosue api's in t3ctrl.dll is used.
//      the X and Y parameters are assumed to be in client coordiantes.
//
//+--------------------------------------------------------------------------

HRESULT
CPadDoc::MoveMouseTo(int x, int y, VARIANT_BOOL fLeftButton, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    WPARAM  wParam=0;
    LPARAM  lParam=0;

    TraceTag( (tagShowMoveMouseTo, "MoveMouse To. %d,%d " , x, y ));

    // get the appropriate HWND for this event
    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            // use window from app hosting Trident
            hwnd = g_hwndActiveWindow;
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if ((hwnd = GetFocus()) != NULL)
    {
        // use focus window if we can get one
    }
    else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
    {
        // use inplace active object hwnd
    }
    else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
    {
        // use inplace object window
    }
    else
    {
        // use our window
        hwnd = _hwnd;
    }

    pt.x = x;
    pt.y = y;

    if (!ClientToScreen(hwnd, &pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // first move the mosue, but because the accompaning
    // mosemove msg is flaky, we want to send another
    // immediately
    if(!SetCursorPos(pt.x, pt.y))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // set up the LParam
    lParam = y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += x;         // set the LOWORD

    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    wParam |= (fLeftButton==VB_TRUE) ? MK_LBUTTON : 0;

    // SendMessage to make this happen now
    if (!SendMessage(hwnd, WM_MOUSEMOVE, wParam, lParam))
    {
        hr = GetLastError();
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member : DoMouseButtonAt
//
//  Synopsis: iniate a mouse button event
//
//---------------------------------------------------------------------------

//
// ISSUE - duplication between DoMouseButton and DoMouseButtonAt.
//
HRESULT
CPadDoc::DoMouseButtonAt(int x, int y, VARIANT_BOOL fLeftButton, BSTR bstrAction, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    UINT    uMsg=0;
    WPARAM  wParam=0;
    LPARAM  lParam=0;
    BYTE             abState[256];

    // get the appropriate HWND for this event
    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            // use window from app hosting Trident
            hwnd = g_hwndActiveWindow;
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if ((hwnd = GetFocus()) != NULL)
    {
        // use focus window if we can get one
    }
    else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
    {
        // use inplace active object hwnd
    }
    else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
    {
        // use inplace object window
    }
    else
    {
        // use our window
        hwnd = _hwnd;
    }
    pt.x = x;
    pt.y = y;

    // set up the LParam
    lParam = pt.y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += pt.x;         // set the LOWORD



    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    if (GetKeyboardState(abState))
    {
        abState[VK_SHIFT] = (keyState & 0x0002) ? 0x80 : 0;
        abState[VK_CONTROL] = (keyState & 0x0001) ? 0x80 : 0;
        SetKeyboardState(abState);
    }

    // set up the Msg and the wParam
    if (_tcsicmp(bstrAction, _T("down"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDOWN;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDOWN;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("up"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("click"))==0)
    {
        // down
        hr = THR_NOTRACE(DoMouseButtonAt(x, y, fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        // up
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if ((_tcsicmp(bstrAction, _T("doubleclick"))==0) ||
            (_tcsicmp(bstrAction, _T("double"))==0))
    {
        // oh oh gotta do some work, simulate by sending down, up, down, dbl
        hr = THR_NOTRACE(DoMouseButtonAt(x,y,fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButtonAt(x,y, fLeftButton, _T("up"), keyState));
        if (hr)
            goto Cleanup;

/*        hr = THR_NOTRACE(DoMouseButtonAt(x,y, fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;*/

        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDBLCLK;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDBLCLK;
            wParam |= MK_RBUTTON;
        }
    }

    if (!PostMessage(hwnd, uMsg, wParam, lParam))
        hr = GetLastError();

Cleanup:
    RRETURN ( hr );
}

//---------------------------------------------------------------------------
//
//  Member : DoMouseButton
//
//  Synopsis: iniate a mouse button event
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DoMouseButton(VARIANT_BOOL fLeftButton, BSTR bstrAction, int keyState)
{
    HRESULT hr = S_OK;
    POINT   pt;
    HWND    hwnd;
    UINT    uMsg=0;
    WPARAM  wParam=0;
    LPARAM  lParam=0;

    // get the cursor's position
    if (!GetCursorPos(&pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // and the window that is going to get the message

    hwnd = WindowFromPoint(pt);
    if (!hwnd)
        goto Cleanup;

    // adjust the point
    if (!ScreenToClient(hwnd, &pt))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    // set up the LParam
    lParam = pt.y;
    lParam = lParam << 16;  // make pt.y the HIWORD
    lParam += pt.x;         // set the LOWORD

    //set up the key part of the lParam
    if (keyState & 0x0001)
        wParam = MK_CONTROL;

    if (keyState & 0x0002)
        wParam |= MK_SHIFT;

    // set up the Msg and the wParam
    if (_tcsicmp(bstrAction, _T("down"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDOWN;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDOWN;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("up"))==0)
    {
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if (_tcsicmp(bstrAction, _T("click"))==0)
    {
        // down
        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        // up
        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONUP;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONUP;
            wParam |= MK_RBUTTON;
        }
    }
    else if ((_tcsicmp(bstrAction, _T("doubleclick"))==0) ||
            (_tcsicmp(bstrAction, _T("double"))==0))
    {
        // oh oh gotta do some work, simulate by sending down, up, down, dbl
        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("up"), keyState));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(DoMouseButton(fLeftButton, _T("down"), keyState));
        if (hr)
            goto Cleanup;

        if (fLeftButton==VB_TRUE)
        {
            uMsg = WM_LBUTTONDBLCLK;
            wParam |= MK_LBUTTON;
        }
        else
        {
            uMsg = WM_RBUTTONDBLCLK;
            wParam |= MK_RBUTTON;
        }
    }

    if (!PostMessage(hwnd, uMsg, wParam, lParam))
        hr = GetLastError();

Cleanup:
    RRETURN ( hr );
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintStatus, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintStatus(BSTR bstrMessage)
{
    SetStatusText(bstrMessage);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ScriptParam, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptParam(VARIANT *pvarScriptParam)
{
    HRESULT hr;

    if (_pScriptSite)
    {
        hr = THR(VariantCopy(pvarScriptParam, &_pScriptSite->_varParam));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ScriptObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptObject(IDispatch **ppDisp)
{
    HRESULT hr;

    if (_pScriptSite)
    {
        hr = THR(_pScriptSite->_pScript->GetScriptDispatch(_T("Pad"), ppDisp));
    }
    else
    {
        *ppDisp = NULL;
        hr = E_FAIL;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ExecuteScript, IPad
//
//  Load and execute script file in a brand new script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ExecuteScript(BSTR bstrPath, VARIANT *pvarScriptParam, VARIANT_BOOL fAsync)
{
    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    hr = THR(PushScript(_tcsrchr(bstrPath, _T('.'))));
    if(hr)
        goto Cleanup;

    SetWindowText(_hwnd, bstrPath);

    if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        hr = THR(VariantCopy(&_pScriptSite->_varParam, pvarScriptParam));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pScriptSite->ExecuteScriptFile(bstrPath));

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    if (fAsync)
    {
        PostMessage(_hwnd, WM_RUNSCRIPT, 0, 0);
    }
    else
    {
        FireEvent(DISPID_PadEvents_Load, 0, NULL);
        PopScript();
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::RegisterControl, IPad
//
//  Synopsis:   Register the control whose fully qualified name is passed
//              in Path.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::RegisterControl(BSTR Path)
{
#ifdef UNIX
    // Fix path in case we succeed but silently fail

    SanitizePath( Path );
    RegisterDLL( Path );

    return S_OK;
#else
    RRETURN(RegisterDLL(Path));
#endif
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IncludeScript, IPad
//
//  Load and execute script file in current script engine
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IncludeScript(BSTR bstrPath)
{
    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    hr = THR(_pScriptSite->ExecuteScriptFile(bstrPath));

    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetProperty, IPad
//
//  Sets a property for an object, given property name and value
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetProperty(IDispatch * pDisp, BSTR bstrProperty, VARIANT * pvar)
 {
    HRESULT     hr;
    DISPPARAMS  dp;
//    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    DISPID      dispidProp;
    DISPID      dispidPut = DISPID_PROPERTYPUT;

    if (!pvar)
    {
        return E_INVALIDARG;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &bstrProperty, 1, 0, &dispidProp);
    if (hr)
        goto Cleanup;

    dp.rgvarg            = pvar;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs             = 1;
    dp.cNamedArgs        = 1;

    hr = pDisp->Invoke(
                dispidProp,
                IID_NULL,
                0,
                DISPATCH_PROPERTYPUT,
                &dp,
                NULL,
                NULL,   // use excepinfo?
                &uArgErr);

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetProperty, IPad
//
//  Gets a property value for an object, given property name
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetProperty(IDispatch * pDisp, BSTR bstrProperty, VARIANT * pvar)
{
    HRESULT     hr;
    DISPPARAMS  dp;
//    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    DISPID      dispidProp;

    if (!pvar)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &bstrProperty, 1, 0, &dispidProp);
    if (hr)
        goto Cleanup;

    dp.rgvarg            = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs             = 0;
    dp.cNamedArgs        = 0;

    hr = pDisp->Invoke(
                dispidProp,
                IID_NULL,
                0,
                DISPATCH_PROPERTYGET,
                &dp,
                pvar,
                NULL,       // use excepinfo?
                &uArgErr);

Cleanup:
    if (hr)
    {
        pvar->vt = VT_NULL;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_Document, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_Document(IDispatch **ppDocDisp)
{
    HRESULT hr = S_OK;
    IHTMLDocument2 *pOmDoc;

    if(!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->get_Document(ppDocDisp));
    }
    else if (_pObject)
    {
        hr = THR(GetOmDocumentFromDoc (_pObject, &pOmDoc));
        if (OK(hr))
        {
            *ppDocDisp = pOmDoc;
        }
    }

Cleanup:
    RRETURN (hr);
}

HRESULT 
CPadDoc::get_Document_Early(IDispatch **ppDocDisp)
{
    HRESULT hr = S_OK;
    IHTMLDocument2 *pOmDoc;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pObjectHBI)
    {
        hr = THR(GetOmDocumentFromDoc(_pObjectHBI, &pOmDoc));
        if (OK(hr))
        {
            *ppDocDisp = pOmDoc;
        }
    }

Cleanup:
    RRETURN(hr);
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TempPath, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_TempPath(BSTR * pbstrPath)
{
    TCHAR achTempPath[MAX_PATH];
    int cch;

    if(!pbstrPath)
        return E_INVALIDARG;

    cch = GetTempPath(ARRAY_SIZE(achTempPath), achTempPath);

    if(cch == 0 || cch > ARRAY_SIZE(achTempPath))
        return E_FAIL;

    *pbstrPath = SysAllocString(achTempPath);

    if(!*pbstrPath)
        return E_OUTOFMEMORY;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TempFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetTempFileName(BSTR * pbstrName)
{
    HRESULT hr;
    BSTR bstrPath;
    TCHAR achTempFile[MAX_PATH];

    if(!pbstrName)
        return E_INVALIDARG;

    hr = get_TempPath(&bstrPath);
    if(hr)
        goto Cleanup;

    if(::GetTempFileName(bstrPath, _T("PAD"), 0, achTempFile) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pbstrName = SysAllocString(achTempFile);

    if(!*pbstrName)
        hr = E_OUTOFMEMORY;

Cleanup:
    SysFreeString(bstrPath);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CleanupTempFiles, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CleanupTempFiles()
{
    HRESULT          hr;
    BSTR             bstrPath;
    CHAR             achTempFile[MAX_PATH];
    HANDLE           hFiles;
    WIN32_FIND_DATAA fd;
    CHAR          *  pch;
    int              c;

    //
    // This is all done in ANSI because we don't have unicode wrappers for
    // FindFirstFile and etc.
    //
    hr = get_TempPath(&bstrPath);
    if (hr)
        goto Cleanup;

    c = WideCharToMultiByte(CP_ACP,
                            0,
                            bstrPath,
                            SysStringLen(bstrPath),
                            achTempFile,
                            MAX_PATH,
                            NULL,
                            NULL);

    pch = achTempFile + c;

    Assert(*(pch-1) == FILENAME_SEPARATOR);

    strcpy(pch, "PAD*.TMP");

    hFiles = FindFirstFileA(achTempFile, &fd);

    if (hFiles == INVALID_HANDLE_VALUE)
    {
        hr = S_OK;
        goto Cleanup;
    }

    do
    {
        if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            strcpy(pch, fd.cFileName);

            (void) DeleteFileA(achTempFile); // Ignore errors
        }
    } while (FindNextFileA(hFiles, &fd));

    FindClose(hFiles);

Cleanup:
    SysFreeString(bstrPath);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintLog, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintLog(BSTR bstrLine)
{
    DWORD  cchLen = SysStringLen(bstrLine);
    char * pchBuf = new char[cchLen+3];

    WideCharToMultiByte(CP_ACP, 0, bstrLine, cchLen, pchBuf, cchLen+1, NULL, NULL);
    pchBuf[cchLen] = '\0';

    TraceTagEx((tagScriptLog, TAG_NONAME, "%s", pchBuf));

    DWORD  cbWrite;

    //
    // Write to STDOUT. Used by the DRTDaemon process to relay information
    // back to the build machine. Ignore any errors.
    //
    strcat(pchBuf, "\r\n");

    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
              pchBuf,
              cchLen+2,
              &cbWrite,
              NULL);

    delete pchBuf;

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintLogFile, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintLogFile(BSTR bstrFileName)
{
    HANDLE hFile = CreateFile(bstrFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD err;

    if (hFile)
    {
        char  buffer[200];
        DWORD cbRead = 0;
        DWORD cbWrite = 0;
        int ichLimRead = 0;
        int ichLim = 0;

        // read from file while it lasts
        do
        {
            if (ichLim >= ichLimRead
                && ::ReadFile(hFile,
                              buffer + ichLimRead,
                              sizeof(buffer) - ichLimRead,
                              &cbRead,
                              NULL)
                && cbRead)
            {
                // if read something, write it to STDOUT
                WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
                          buffer + ichLimRead,
                          cbRead,
                          &cbWrite,
                          NULL);

                if (!cbWrite)
                    err = GetLastError();

                ichLimRead += cbRead;
            }

            // now break text in lines and send to debug output one at a time

            // Look for LF or full buffer
            while (ichLim < ichLimRead && buffer[ichLim] != '\n')
                ichLim++;

            if (ichLim < ichLimRead ||          // found LF
                ichLimRead == sizeof(buffer) || // full buffer
                cbRead == 0 && ichLimRead > 0)  // EOF
            {
                int cch = ichLim++; // skip LF

                // ignore CR
                if (cch && buffer[cch - 1] == '\r')
                    cch--;

                // write line to debug output
                TraceTagEx((tagScriptLog, TAG_NONAME, "%.*s", cch, buffer));

                // shift remainder of the buffer to the left
                int ichLimCopy;
                for (ichLimCopy = ichLimRead, ichLimRead = 0; ichLim < ichLimCopy;)
                    buffer[ichLimRead++] = buffer[ichLim++];
                ichLim = 0;
            }
        }
        while (cbRead);

        CloseHandle(hFile);
    }

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::PrintDebug, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::PrintDebug(BSTR bstrValue)
{
    if(!_pDebugWindow)
        ToggleDebugWindowVisibility();

    Assert(_pDebugWindow);

    RRETURN(THR(_pDebugWindow->Print(bstrValue)));
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DRTPrint, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DRTPrint(long Flags, VARIANT_BOOL * Success)
{
    HRESULT hr = E_FAIL;
    VARIANT varPrintFlags;
    VARIANT_BOOL fOutputFileExists;

    // 1. Print the current doc.

    V_VT(&varPrintFlags) = VT_I2;
    V_I2(&varPrintFlags) = (short) Flags;

    hr = THR( ExecuteCommand(IDM_PRINT, &varPrintFlags, NULL) );
    if (hr)
        goto Cleanup;

    // 2. Wait until the DRT output file exists.
    do
    {
        hr = THR( FileExists(PRINTDRT_FILE, &fOutputFileExists) );

        if (hr)
            goto Cleanup;
    }
    while (fOutputFileExists == VB_FALSE && MsgWaitForMultipleObjects(0, NULL, FALSE, 250, 0) == WAIT_TIMEOUT);

    #if (defined(_X86_))
    // 3. Fire up a postscript viewer.
    if (!(Flags & 128))
    {
        HINSTANCE hInstance = 0;
        HWND hwndDesktop = GetDesktopWindow();

        if (g_fUnicodePlatform)
        {
            hInstance = ShellExecuteW(hwndDesktop, NULL, _T("gs.bat"), PRINTDRT_FILE, NULL, SW_HIDE);
        }
        else
        {
            hInstance = ShellExecuteA(hwndDesktop, NULL, "gs.bat", PRINTDRT_FILEA, NULL, SW_HIDE);
        }

        Assert((LONG) hInstance > 32 && "Error bringing up a postscript viewer.  Verify C:\\PRINTDRT.PS manually by printing it.");
    }
    #endif

Cleanup:

    *Success = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetDefaultPrinter, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetDefaultPrinter(BSTR bstrNewDefaultPrinter, VARIANT_BOOL * Success)
{
    HRESULT hr= E_FAIL;
    *Success = VB_FALSE;;

#if (defined(_X86_))
    HWND hwndDesktopWindow = GetDesktopWindow();
    HWND hwndInternetExplorer = 0;

    if (g_fUnicodePlatform)
    {
       hr = WriteProfileStringW(_T("Windows"), _T("Device"), (const TCHAR *)bstrNewDefaultPrinter)
           ? S_OK : E_FAIL;


        if (!hr && hwndDesktopWindow)
        {
            // make sure the spooler knows about the new default printer
            // Cause MSHMTL.DLL to re-read registry settings
            do
            {
                hwndInternetExplorer = FindWindowExW(hwndDesktopWindow, hwndInternetExplorer, _T("Internet Explorer_Hidden"), NULL);


                if (hwndInternetExplorer)
                {
                    SendMessage(hwndInternetExplorer, WM_UPDATEDEFAULTPRINTER, 0, 0);
                }
            }
            while (hwndInternetExplorer);
        }
    }
    else
    {
        char strNewDefaultPrinter[100];
        DWORD cbNewDefaultPrinter = WideCharToMultiByte(
                CP_ACP, 0, bstrNewDefaultPrinter, -1, strNewDefaultPrinter, 100, NULL, NULL);

        hr = (cbNewDefaultPrinter && WriteProfileStringA("Windows", "Device", (const char *)strNewDefaultPrinter))
            ? S_OK : E_FAIL;

        if (!hr && hwndDesktopWindow)
        {
            // make sure the spooler knows about the new default printer
            // Cause MSHMTL.DLL to re-read registry settings
            do
            {
                hwndInternetExplorer = FindWindowExA(hwndDesktopWindow, hwndInternetExplorer, "Internet Explorer_Hidden", NULL);

                if (hwndInternetExplorer)
                {
                    SendMessage(hwndInternetExplorer, WM_UPDATEDEFAULTPRINTER, 0, 0);
                }
            }
            while (hwndInternetExplorer);
        }
    }

    *Success = hr ? VB_FALSE : VB_TRUE;

#endif // _X86_

    RRETURN1(hr, E_FAIL);
}

HRESULT
CPadDoc::SetPrintTemplate(IUnknown *pUnk, VARIANT_BOOL fTemplate)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pioct = NULL;
    VARIANT varIn;
    VariantInit(&varIn);

    if (!pUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = fTemplate;

    hr = pUnk->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    hr = pioct->Exec(&CGID_MSHTML, IDM_SETPRINTTEMPLATE, 0, &varIn, 0);

Cleanup:
    ReleaseInterface(pioct);
    return hr;
}

HRESULT
CPadDoc::IsPrintTemplate(IUnknown *pUnk, VARIANT_BOOL * pfTemplate)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pioct = NULL;
    VARIANT     varOut;
    VariantInit(&varOut);

    if (!pUnk || !pfTemplate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pUnk->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    hr = pioct->Exec(&CGID_MSHTML, IDM_GETPRINTTEMPLATE, 0, 0, &varOut);
    if (hr)
        goto Cleanup;

    if (V_VT(&varOut) != VT_BOOL)
        hr = E_FAIL;
    else
        *pfTemplate = V_BOOL(&varOut);

Cleanup:
    VariantClear(&varOut);
    ReleaseInterface(pioct);
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CompareFiles, IPad
//          and AreFilesSame helper fn()
//          and IsPostscript helper fn()
//          and ComparePostscriptFiles helper fn()
//
//---------------------------------------------------------------------------

BOOL
AreFilesSame(HANDLE hFile1, HANDLE hFile2)
{
    DWORD dwFile1Size, dwFile2Size, dwCurSize, dwActualRead;

    Assert(hFile1 != INVALID_HANDLE_VALUE && hFile2 != INVALID_HANDLE_VALUE);

    // get and compare the files
    dwFile1Size = GetFileSize(hFile1, NULL);
    dwFile2Size = GetFileSize(hFile2, NULL);

    if (dwFile1Size != dwFile2Size)
        return FALSE;

    dwCurSize = 0;

    while (dwCurSize < dwFile1Size)
    {
        DWORD dwRead;
        char Buf1[FILEBUFFERSIZE], Buf2[FILEBUFFERSIZE];
        dwCurSize += FILEBUFFERSIZE;

        // determine number of bytes to read
        if (dwCurSize <= dwFile1Size)
            dwRead = FILEBUFFERSIZE;
        else
            dwRead = dwFile1Size - (dwCurSize - FILEBUFFERSIZE);

        // read a portion of the first file
        if (!ReadFile(hFile1, Buf1, dwRead, &dwActualRead, NULL) ||
            !ReadFile(hFile2, Buf2, dwRead, &dwActualRead, NULL))
        {
            TraceTag((tagError, "ERROR reading one of the htm files."));
            return FALSE;
        }

        if (memcmp(Buf1, Buf2, dwActualRead) != 0)
            return FALSE;
    }
    return TRUE;
}

BOOL IsPostscript(BSTR bstrFile)
{
    if (!bstrFile)
        return FALSE;

    if (_tcslen(bstrFile) < 3)
        return FALSE;

    return (StrCmpIC(_T(".ps"), bstrFile+_tcslen(bstrFile)-3) == 0);
}

HRESULT
ReadNextPostscriptLine(HANDLE hFile, char *lpBuffer, LPDWORD pdwLineLength)
{
    char  * lpFirstNewLine;
    char  * lpFirstRandomIdentifier;
    int     cch;

    Assert(lpBuffer);

    do
    {
        // read a portion of the file
        if (!ReadFile(hFile, lpBuffer, FILEBUFFERSIZE, pdwLineLength, NULL))
        {
            TraceTag((tagError, "ERROR reading one of the postscript files."));
            return E_FAIL;
        }

        // end of file?
        if (*pdwLineLength == 0)
            return S_OK;

        // find the first new line in the buffer
        for (cch = *pdwLineLength, lpFirstNewLine = lpBuffer; cch > 0; --cch, ++lpFirstNewLine)
            if (*lpFirstNewLine == 10)
                break;
        if (*lpFirstNewLine != 10)
            lpFirstNewLine = NULL;

        // if we found a new line, reposition the file pointer
        if (lpFirstNewLine)
        {
            SetFilePointer(hFile, (lpFirstNewLine - lpBuffer + 1) - *pdwLineLength, NULL, FILE_CURRENT);

            *pdwLineLength = lpFirstNewLine - lpBuffer;
        }
    }
    while (lpBuffer[0] == '%' && lpBuffer[1] == '%');

    // before we return successfully, we have to NULL out all font identifiers starting with
    // MSTT followed by a 8-digit hexcode.

    lpBuffer[*pdwLineLength] = 0;
    lpFirstRandomIdentifier = lpBuffer;

    do
    {
        // Find first occurence of "MSTT"
        lpFirstRandomIdentifier = StrStrA(lpFirstRandomIdentifier, "MSTT");

        // If found, NULL out the random 8-digit hexcode following it.
        if (lpFirstRandomIdentifier)
        {
            int nPadding = *pdwLineLength - (lpFirstRandomIdentifier+4-lpBuffer); // chars left in line

            // Zero out at most 8 characters.
            if (nPadding > 8)
                nPadding = 8;

            memset( lpFirstRandomIdentifier+4, '0', nPadding );

            // prevent finding the same occurence again.
            lpFirstRandomIdentifier++;
        }
    }
    while (lpFirstRandomIdentifier);

    return S_OK;
}

BOOL
ComparePostscriptFiles(HANDLE hFile1, HANDLE hFile2)
{
    DWORD dwActualRead1, dwActualRead2;

    Assert(hFile1 != INVALID_HANDLE_VALUE && hFile2 != INVALID_HANDLE_VALUE);

    do
    {
        char Buf1[FILEBUFFERSIZE], Buf2[FILEBUFFERSIZE];
        HRESULT hr;

        hr = ReadNextPostscriptLine(hFile1, Buf1, &dwActualRead1);
        if (hr)
            return FALSE;

        hr = ReadNextPostscriptLine(hFile2, Buf2, &dwActualRead2);
        if (hr)
            return FALSE;

        if (dwActualRead1 && dwActualRead2)
        {
            // Compare lengths of lines.
            if (dwActualRead1 != dwActualRead2)
                return FALSE;

            // Compare lines.
            if (memcmp(Buf1, Buf2, dwActualRead1) != 0)
                return FALSE;
        }
    }
    // We compare until one of the files reaches its end.
    while (dwActualRead1 && dwActualRead2);

    return TRUE;
}

HRESULT
CPadDoc::CompareFiles(BSTR bstrFile1, BSTR bstrFile2, VARIANT_BOOL *pfMatch)
{
    HANDLE hFile1;
    HANDLE hFile2;
    BOOL fMatch = TRUE;

    hFile1 = CreateFile(bstrFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE)
        fMatch = FALSE;

    hFile2 = CreateFile(bstrFile2, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE)
        fMatch = FALSE;

    if (fMatch)
    {
        fMatch =
        // Are we comparing postscript files?
        (IsPostscript(bstrFile1) && IsPostscript(bstrFile2)) ?
            // Comparing postscript files requires dropping postscript
            // comments (%%) that contain irrelevant, but distinct information
            // such as the creation date, time, and environment.
            ComparePostscriptFiles(hFile1,hFile2) :
            // else do normal compare
            AreFilesSame(hFile1, hFile2);
    }
    if (hFile1 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile1);
    if (hFile2 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile2);

    *pfMatch = fMatch ? VB_TRUE : VB_FALSE;
    RRETURN(S_OK);
}

HRESULT
CPadDoc::CopyThisFile(BSTR bstrFile1, BSTR bstrFile2, VARIANT_BOOL *pfSuccess)
{
    *pfSuccess = CopyFile(bstrFile1, bstrFile2, FALSE) ? VB_TRUE : VB_FALSE;
    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::FileExists, IPad
//
//  Synopsis:  Return TRUE if file exists.
//---------------------------------------------------------------------------

HRESULT
CPadDoc::FileExists(BSTR bstrFile, VARIANT_BOOL *pfFileExists)
{
    DWORD dwReturn;
    LPTSTR pDummy;

    dwReturn = SearchPath(NULL, bstrFile, NULL, 0, NULL, &pDummy);
    *pfFileExists = (dwReturn > 0) ? VB_TRUE : VB_FALSE;

    if (*pfFileExists == VB_TRUE)
    {
        HANDLE hFile = CreateFile(bstrFile, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            *pfFileExists = VB_FALSE;
        else
            CloseHandle(hFile);
    }

    RRETURN(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DisableDialogs, IPad
//
//  Note: UnhandledExceptionHandler is the global exception handler that gets
//        called whenever an unhandled exception occurs in Pad. This is
//        installed when SetUnhandledExceptionFilter is called from
//        DisableDialogs.
//
//---------------------------------------------------------------------------

LONG UnhandledExceptionHandler(LPEXCEPTION_POINTERS lpexpExceptionInfo)
{
    HANDLE hProcess;

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
    if (hProcess)
    {
        char * pszExType = NULL;
        char   achBuf[200];

        switch (lpexpExceptionInfo->ExceptionRecord->ExceptionCode)
        {
        case EXCEPTION_ACCESS_VIOLATION:
            pszExType = "Access Violation";
            break;

        case EXCEPTION_BREAKPOINT:
            pszExType = "Breakpoint Hit";
            break;

        case EXCEPTION_STACK_OVERFLOW:
            pszExType = "Stack Overflow";
            break;

        default:
            pszExType = "Unhandled Exception";
            break;
        }

        wsprintfA(achBuf, "*** FATAL ERROR: %s at", pszExType);

        DbgExGetSymbolFromAddress(lpexpExceptionInfo->ExceptionRecord->ExceptionAddress,
                                  &achBuf[strlen(achBuf)], ARRAY_SIZE(achBuf) - strlen(achBuf) - 2);

        //
        // We explicitly turn off the assert stacktrace here because it only
        // gives the stacktrace of this UnhandledExceptionHandler, which means
        // nothing and just confuses people.
        //
        BOOL fStacktrace = DbgExEnableTag(tagAssertStacks, FALSE);

        AssertSz(FALSE, achBuf);

        DbgExEnableTag(tagAssertStacks, fStacktrace);

        TerminateProcess(hProcess, 1);
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

HRESULT
CPadDoc::DisableDialogs()
{
    SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOGPFAULTERRORBOX);
    SetUnhandledExceptionFilter(UnhandledExceptionHandler);
    EnableTag(tagAssertExit, TRUE);

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_DialogsDisabled, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_DialogsEnabled(VARIANT_BOOL *pfEnabled)
{
    *pfEnabled = IsTagEnabled(tagAssertExit) ? VB_FALSE : VB_TRUE;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::get_ScriptBase, IPad
//
//  Arguments:  i  - Number of levels back up the script path to return.
//                   0 returns directory containing script.
//                   1 returns parent of directory containing script
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ScriptPath(long i, BSTR * pbstrPath)
{
    TCHAR achPath[MAX_PATH];
    TCHAR *pch = NULL;

    *pbstrPath = NULL;
    if (_pScriptSite)
    {
        memcpy(achPath, _pScriptSite->_achPath, sizeof(achPath));
        for (; i >= 0; i--)
        {
            pch = _tcsrchr(achPath, _T(FILENAME_SEPARATOR));
            if (pch)
            {
                *pch = 0;
            }
            else
            {
                return E_FAIL;
            }
        }
        if (pch)
        {
            pch[0] = _T(FILENAME_SEPARATOR);
            pch[1] = 0;
        }
        *pbstrPath = SysAllocString(achPath);
    }

    return *pbstrPath ? S_OK : E_FAIL;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_TimerInterval, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_TimerInterval(long lInterval)
{
    KillTimer(_hwnd, 0);
    _lTimerInterval = lInterval;
    if (_lTimerInterval)
    {
        SetTimer(_hwnd, 0, _lTimerInterval, NULL);
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_TimerInterval, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_TimerInterval(long *plInterval)
{
    *plInterval = _lTimerInterval;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ResumeCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ResumeCAP()
{
    ::ResumeCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SuspendCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SuspendCAP()
{
    ::SuspendCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::StartCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::StartCAP()
{
    ::StartCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::StopCAP, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::StopCAP()
{
    ::StopCAPAll();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::TicStartAll, IPad
//  Member: CPadDoc::TicStopAll, IPad
//
//---------------------------------------------------------------------------

DYNLIB g_dynlibTimeLib = { NULL, NULL, "TimeLib.DLL" };
DYNPROC g_dynprocTicStartAll = { NULL, &g_dynlibTimeLib, "TicStartAll" };
DYNPROC g_dynprocTicStopAll = { NULL, &g_dynlibTimeLib, "TicStopAll" };

HRESULT
CPadDoc::TicStartAll()
{
    if (    g_dynprocTicStartAll.pfn != NULL
        ||  LoadProcedure(&g_dynprocTicStartAll) == S_OK)
    {
        ((HRESULT (STDAPICALLTYPE *)())g_dynprocTicStartAll.pfn)();
    }

    return(S_OK);
}

HRESULT
CPadDoc::TicStopAll()
{
    if (    g_dynprocTicStopAll.pfn != NULL
        ||  LoadProcedure(&g_dynprocTicStopAll) == S_OK)
    {
        ((HRESULT (STDAPICALLTYPE *)())g_dynprocTicStopAll.pfn)();
    }

    return(S_OK);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DumpMeterLog, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DumpMeterLog(BSTR bstrFileName)
{
    char ach[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, bstrFileName, -1, ach, sizeof(ach), NULL, NULL);
    DbgExMtLogDump(ach);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::LookupMeter, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LookupMeter(BSTR Meter, long* mt)
{
    char ach[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, Meter, -1, ach, sizeof(ach), NULL, NULL);

    *mt = (long)DbgExMtLookupMeter( ach );

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterName, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterName(long mt, BSTR* pbstrName)
{
    char * pchA = DbgExMtGetName( (PERFMETERTAG) mt );

    WCHAR  szBufW[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pchA, -1,
                        szBufW, sizeof(szBufW)/sizeof(TCHAR));

    *pbstrName = SysAllocString(szBufW);

    RRETURN(*pbstrName ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterDesc, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterDesc(long mt, BSTR* pbstrDesc)
{
    char * pchA = DbgExMtGetDesc( (PERFMETERTAG) mt );

    WCHAR  szBufW[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pchA, -1,
                        szBufW, sizeof(szBufW)/sizeof(TCHAR));

    *pbstrDesc = SysAllocString(szBufW);

    RRETURN(*pbstrDesc ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterCnt, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterCnt(long mt, VARIANT_BOOL fExcl, long* plCnt)
{
    *plCnt = DbgExMtGetMeterCnt( (PERFMETERTAG) mt, !!fExcl );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMeterVal, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetMeterVal(long mt, VARIANT_BOOL fExcl, long* plVal)
{
    *plVal = DbgExMtGetMeterVal( (PERFMETERTAG) mt, !!fExcl );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MeterAdd, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MeterAdd(long mt, long lCnt, long lVal)
{
    DbgExMtAdd( (PERFMETERTAG) mt, lCnt, lVal );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MeterSet, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MeterSet(long mt, long lCnt, long lVal)
{
    DbgExMtSet( (PERFMETERTAG) mt, lCnt, lVal );
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetSwitchTimers, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetSwitchTimers(VARIANT * pValue)
{
    TCHAR ach[256];

    ach[0] = 0;
    pValue->vt = VT_BSTR;
    pValue->bstrVal = NULL;

    IOleCommandTarget * pCommandTarget = NULL;

    _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

    if (pCommandTarget)
    {
        VARIANT v;
        v.vt = VT_BSTR;
        v.bstrVal = (BSTR)ach;
        pCommandTarget->Exec((GUID *)&CGID_MSHTML, IDM_GETSWITCHTIMERS, 0, NULL, &v);
        pCommandTarget->Release();
    }

    pValue->bstrVal = SysAllocString(ach);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GetObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GetObject(BSTR bstrFile, BSTR bstrProgID, IDispatch **ppDisp)
{
    HRESULT hr;
    CLSID clsid;
    IPersistFile *pPF = NULL;
    IUnknown *pUnk = NULL;
    IBindCtx *pBCtx = NULL;
    IMoniker *pMk = NULL;

    *ppDisp = NULL;

    if (bstrFile && !*bstrFile)
        bstrFile = NULL;

    if (bstrProgID && !*bstrProgID)
        bstrProgID = NULL;

    if (bstrProgID)
    {
        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if (hr)
            goto Cleanup;
    }

    if (bstrFile && bstrProgID)
    {
        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_SERVER,
                IID_IPersistFile, (void **)&pPF));
        if (hr)
            goto Cleanup;

        hr = THR(pPF->Load(bstrFile, 0));
        if (hr)
            goto Cleanup;

        hr = THR(pPF->QueryInterface(IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;
    }
    else if (bstrFile)
    {
        ULONG cEaten;

        hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
        if (hr)
            goto Cleanup;

        hr = THR(MkParseDisplayName(pBCtx, bstrFile, &cEaten, &pMk));
        if (hr)
            goto Cleanup;

        hr = THR(pMk->BindToObject(pBCtx, NULL, IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;

    }
    else if (bstrProgID)
    {
        hr = THR(GetActiveObject(clsid, NULL, &pUnk));
        if (hr)
            goto Cleanup;

        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)ppDisp));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_INVALIDARG;
    }


Cleanup:
    ReleaseInterface(pPF);
    ReleaseInterface(pBCtx);
    ReleaseInterface(pMk);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CreateObject, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CreateObject(BSTR bstrProgID, IDispatch **ppDisp)
{
    extern CPadFactory PadDocFactory;
    HRESULT hr;
    CLSID clsid;
    IUnknown *pUnk = NULL;

    if (StrCmpIC(bstrProgID, _T("TridentPad")) == 0)
    {

        // Short circuit our own object so we do not depend
        // on user registering this version of HTMLPad.

        CThreadProcParam tpp(FALSE, ACTION_NONE);
        hr = THR(CreatePadDoc(&tpp, &pUnk));
        if (hr)
            goto Cleanup;

        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)ppDisp));
    }
    else
    {
        hr = THR(CLSIDFromProgID(bstrProgID, &clsid));
        if (hr)
            goto Cleanup;

        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_SERVER,
                     IID_IDispatch, (void **)ppDisp));
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_CurrentTime, IPad
//
//---------------------------------------------------------------------------

#ifdef USE_PERFORMANCE_DATA_HELPER

static DYNLIB g_dynlibPdh = { NULL, NULL, "pdh.dll" };
static DYNPROC g_dynprocPdhOpenQuery = { NULL, &g_dynlibPdh, "PdhOpenQuery" };
static DYNPROC g_dynprocPdhAddCounterW = { NULL, &g_dynlibPdh, "PdhAddCounterW" };
static DYNPROC g_dynprocPdhCollectQueryData = { NULL, &g_dynlibPdh, "PdhCollectQueryData" };
static DYNPROC g_dynprocPdhSetCounterScaleFactor = { NULL, &g_dynlibPdh, "PdhSetCounterScaleFactor" };
static DYNPROC g_dynprocPdhGetFormattedCounterValue = { NULL, &g_dynlibPdh, "PdhGetFormattedCounterValue" };
static DYNPROC g_dynprocPdhCloseQuery = { NULL, &g_dynlibPdh, "PdhCloseQuery" };
typedef PDH_STATUS (WINAPI *PFN_PDHOPENQUERY)(LPVOID, DWORD_PTR, HQUERY);
typedef PDH_STATUS (WINAPI *PFN_PDHADDCOUNTER)(HQUERY, LPCWSTR, DWORD_PTR, HCOUNTER);
typedef PDH_STATUS (WINAPI *PFN_PDHCOLLECTQUERYDATA)(HQUERY);
typedef PDH_STATUS (WINAPI *PFN_PDHSETCOUNTERSCALEFACTOR)(HCOUNTER, LONG);
typedef PDH_STATUS (WINAPI *PFN_PDHGETFORMATTEDCOUNTERVALUE)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
typedef PDH_STATUS (WINAPI *PFN_PDHCLOSEQUERY)(HQUERY);

static BOOL g_fInitDone = FALSE;
static BOOL g_fInitSuccess = FALSE;

static BOOL EnsureInitPDH()
{
    if (g_fInitDone)
        return g_fInitSuccess;

    if (    LoadProcedure(&g_dynprocPdhOpenQuery) != S_OK
        ||  LoadProcedure(&g_dynprocPdhAddCounterW) != S_OK
        ||  LoadProcedure(&g_dynprocPdhCollectQueryData) != S_OK
        ||  LoadProcedure(&g_dynprocPdhSetCounterScaleFactor) != S_OK
        ||  LoadProcedure(&g_dynprocPdhGetFormattedCounterValue) != S_OK
        ||  LoadProcedure(&g_dynprocPdhCloseQuery) != S_OK )
    {
        g_fInitSuccess = FALSE;
    }
    else
    {
        g_fInitSuccess = TRUE;
    }

    g_fInitDone = TRUE;

    return g_fInitSuccess;
}
#endif

HRESULT
CPadDoc::get_CurrentTime(long *plTime)
{
    LONGLONG f;
    LONGLONG t;

    QueryPerformanceFrequency((LARGE_INTEGER *)&f);
    QueryPerformanceCounter((LARGE_INTEGER *)&t);

    *plTime = (long)((t * 1000) / f);

    PerfLog1(tagPerfWatchPad, this, "CPadDoc::CurrentTime(*plTime=%ld)", *plTime);

    return S_OK;

#ifdef USE_GETPROCESSTIMES
    FILETIME ftCreate;
    FILETIME ftExit;
    LONGLONG kt;
    LONGLONG ut;

    if (!GetProcessTimes( ::GetCurrentProcess(), &ftCreate, &ftExit, (LPFILETIME)&kt, (LPFILETIME)&ut) )
    {
        return E_FAIL;
    }

    *plTime = (long)(ut / 10000i64);

    return S_OK;
#endif

#ifdef USE_PERFORMANCE_DATA_HELPER
    PDH_STATUS  status;
    HQUERY      hQuery;
    HQUERY      hCounter;
    PDH_FMT_COUNTERVALUE value;

    if (!EnsureInitPDH())
    {
        return E_FAIL;
    }

    status = ((PFN_PDHOPENQUERY)g_dynprocPdhOpenQuery.pfn)(NULL, NULL, &hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHADDCOUNTER)g_dynprocPdhAddCounterW.pfn)(hQuery, _T("\\Process(MSHTMPAD)\\Elapsed Time"), NULL, &hCounter);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHSETCOUNTERSCALEFACTOR)g_dynprocPdhSetCounterScaleFactor.pfn)(hCounter, 3);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHCOLLECTQUERYDATA)g_dynprocPdhCollectQueryData.pfn)(hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHGETFORMATTEDCOUNTERVALUE)g_dynprocPdhGetFormattedCounterValue.pfn)(hCounter, PDH_FMT_LONG, NULL, &value);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    status = ((PFN_PDHCLOSEQUERY)g_dynprocPdhCloseQuery.pfn)(hQuery);
    if (status != ERROR_SUCCESS)
        goto Cleanup;

    *plTime = value.longValue;

Cleanup:
    return status == ERROR_SUCCESS ? S_OK : E_FAIL;
#endif
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Show, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ShowWindow(long lCmdShow)
{
    if (_hwnd)
    {
        ::ShowWindow(_hwnd, lCmdShow);
    }

    if (lCmdShow == SW_HIDE && _fVisible)
    {
        _fVisible = FALSE;
        Release();
    }
    else if (lCmdShow != SW_HIDE && !_fVisible)
    {
        _fVisible = TRUE;
        AddRef();
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::MoveWindow, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::MoveWindow(long x, long y, long cx, long cy)
{
    if (_hwnd)
    {
        ::MoveWindow(_hwnd, x, y, cx, cy, TRUE);
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Left/Top/Width/Height, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_WindowLeft(long *px)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *px = rc.left;
    }
    else
    {
        *px = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowTop(long *py)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *py = rc.top;
    }
    else
    {
        *py = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowWidth(long *pcx)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *pcx = rc.right - rc.left;
    }
    else
    {
        *pcx = 0;
    }
    return S_OK;
}

HRESULT
CPadDoc::get_WindowHeight(long *pcy)
{
    RECT rc;

    if (_hwnd)
    {
        GetWindowRect(_hwnd,  &rc);
        *pcy = rc.bottom - rc.top;
    }
    else
    {
        *pcy = 0;
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Assert, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ASSERT(VARIANT_BOOL fAssert, BSTR bstrMessage)
{
    if (!fAssert)
    {
        char ach[20000];

        // Add name of currently executing script to the assert message.

        if (!_pScriptSite || !_pScriptSite->_achPath[0])
        {
            ach[0] = 0;
        }
        else
        {
            // Try to chop of directory name.

            TCHAR * pchName = wcsrchr(_pScriptSite->_achPath, _T(FILENAME_SEPARATOR));
            if (pchName)
                pchName += 1;
            else
                pchName = _pScriptSite->_achPath;

            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchName,
                    -1,
                    ach,
                    MAX_PATH,
                    NULL,
                    NULL);

            strcat(ach, ": ");
        }

        // Add message to the assert.

        if (!bstrMessage || !*bstrMessage)
        {
            strcat(ach, "HTMLPad Script Assert");
        }
        else
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    bstrMessage,
                    -1,
                    &ach[strlen(ach)],
                    ARRAY_SIZE(ach) - MAX_PATH - 3,
                    NULL,
                    NULL);
        }

        PrintLog(bstrMessage);

        AssertSz(0, ach);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::WaitForRecalc, IPad
//
//  Synopsis: Wait for the document to finish recalcing
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::WaitForRecalc()
{
    IOleCommandTarget * pCommandTarget = NULL;

    _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

    if (pCommandTarget)
    {
        pCommandTarget->Exec((GUID *)&CGID_MSHTML, IDM_WAITFORRECALC, 0, NULL, NULL);
        pCommandTarget->Release();
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SetPerfCtl, IPad
//
//  Synopsis: Setup the HtmPerfCtl block
//
//---------------------------------------------------------------------------

HANDLE      g_hMapHtmPerfCtl = NULL;
HTMPERFCTL *g_pHtmPerfCtl = NULL;

void WINAPI PadDocCallback(DWORD dwArg1, void * pvArg2)
{
    ((CPadDoc *)g_pHtmPerfCtl->pvHost)->PerfCtlCallback(dwArg1, pvArg2);
}

void
DeletePerfCtl()
{
    if (g_pHtmPerfCtl)
        Verify(UnmapViewOfFile(g_pHtmPerfCtl));
    if (g_hMapHtmPerfCtl)
        Verify(CloseHandle(g_hMapHtmPerfCtl));
    g_pHtmPerfCtl = NULL;
    g_hMapHtmPerfCtl = NULL;
}

void
CreatePerfCtl(DWORD dwFlags, void * pvHost)
{
    char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
    wsprintfA(achName, "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

    if (g_hMapHtmPerfCtl == NULL)
        g_hMapHtmPerfCtl = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, achName);
    if (g_hMapHtmPerfCtl == NULL)
    {
        TraceTag((tagError, "CreateFileMappingA(\"%s\") failed (%ld)", achName, GetLastError()));
        return;
    }
#ifndef UNIX
    if (g_pHtmPerfCtl == NULL)
        g_pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);
#endif
    if (g_pHtmPerfCtl == NULL)
    {
        TraceTag((tagError, "MapViewOfFile() failed (%ld)", GetLastError()));
        return;
    }

    g_pHtmPerfCtl->dwSize  = sizeof(HTMPERFCTL);
    g_pHtmPerfCtl->dwFlags = dwFlags;
    g_pHtmPerfCtl->pfnCall = PadDocCallback;
    g_pHtmPerfCtl->pvHost  = pvHost;
}

void
CPadDoc::PerfCtlCallback(DWORD dwArg1, void * pvArg2)
{
    if (_fDisablePadEvents)
    {
        EndEvents();
    }
    else
    {
        VARIANT var;

        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = dwArg1;
        FireEvent(DISPID_PadEvents_PerfCtl, 1, &var);
    }
}

HRESULT
CPadDoc::SetPerfCtl(DWORD dwFlags)
{
    CreatePerfCtl(dwFlags, this);
    _fDisablePadEvents = !!(dwFlags & HTMPF_DISABLE_PADEVENTS);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::ClearDownloadCache, IPad
//
//  Synopsis: Flush WININET disk cache
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ClearDownloadCache()
{
    HANDLE  hEnumCache;
    DWORD   dw;

    struct
    {
        INTERNET_CACHE_ENTRY_INFOA info;
        BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    } info;

    dw = sizeof(info);
    hEnumCache = FindFirstUrlCacheEntryA("*.*", &info.info, &dw);
    if (hEnumCache == 0)
        return S_OK;

    do
    {
        DeleteUrlCacheEntryA(info.info.lpszSourceUrlName);
        dw = sizeof(info);
    } while (FindNextUrlCacheEntryA(hEnumCache, &info.info, &dw));

    FindCloseUrlCache(hEnumCache);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnablePainting, IPad
//
//  Synopsis: Enable painting.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LockWindowUpdate(VARIANT_BOOL fLock)
{
    _fPaintLocked = fLock != 0;

    if (!fLock && _fPaintOnUnlock && _hwnd)
    {
        RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE|RDW_ALLCHILDREN);
    }

    return S_OK;
}

#ifdef NEVER    // (srinib) - commenting this out, since it is not being used
                // causing maintenance problems and also forces text.lib to be linked
                // to pad.
extern HRESULT Lines(IDispatch * pObject, long *pl);
extern HRESULT Line(IDispatch * pObject, long l, IDispatch **ppLine, CPadDoc * pPadDoc);
extern HRESULT Cascaded(IDispatch * pObject, IDispatch **ppCascaded, CPadDoc * pPadDoc);
#endif

HRESULT CPadDoc::get_Lines(IDispatch * pObject, long *pl)
{
    return 0;
#ifdef NEVER
    return ::Lines(pObject, pl);
#endif
}

HRESULT CPadDoc::get_Line(IDispatch * pObject, long l, IDispatch **ppLine)
{
    return 0;
#ifdef NEVER
    return ::Line(pObject, l, ppLine, this);
#endif
}

HRESULT CPadDoc::get_Cascaded(IDispatch * pObject, IDispatch **ppCascaded)
{
    return 0;
#ifdef NEVER
    return ::Cascaded(pObject, ppCascaded, this);
#endif
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnableTraceTag, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::EnableTraceTag(BSTR bstrTag, BOOL fEnable)
{
    if (!bstrTag || !_tcslen(bstrTag))
        return S_FALSE;

    int     tag;
    int     ret;
    char    str[256];

    ret = WideCharToMultiByte(CP_ACP, 0, bstrTag, _tcslen(bstrTag), str, 256, NULL, NULL);
    if (!ret)
        return S_FALSE;

    str[ret] = '\0';

    tag = FindTag (str);
    if (tag)
    {
        EnableTag(tag, fEnable);
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::EnableSnapToGrid, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::EnableSnapToGrid(BOOL fEnable)
{
    // to snap the point to the grid
    BSTR bstrSnapGrid = SysAllocString(_T("Snap to Grid"));
    EnableTraceTag(bstrSnapGrid, fEnable);

    SysFreeString(bstrSnapGrid);

    return S_OK;
}

HRESULT
CPadDoc::GetRegValue(long hKeyIn, BSTR bstrSubkey, BSTR bstrValueName, VARIANT *pValue)
{
    HKEY hKey = (HKEY)(LONG_PTR)hKeyIn;
    HKEY hOpenedKey = 0;
    HRESULT hr;
    WCHAR buffer[128];                  // Buffer for RegQueryValueEx
    DWORD type;
    DWORD lType = sizeof(buffer);

    // Default key to HKEY_CURRENT_USER
    if (hKey==0)
    {
        hKey = HKEY_CURRENT_USER;
    }

    (*pValue).vt = VT_BSTR;                  // Initialize answer to empty BSTR
    (*pValue).bstrVal = NULL;

    hr = RegOpenKeyEx(hKey, bstrSubkey, 0, KEY_QUERY_VALUE, &hOpenedKey);
    if (hr)
        goto Cleanup;
    hr = RegQueryValueEx(hOpenedKey, bstrValueName, NULL, &type, (UCHAR *)buffer, &lType);
    if (hr)
        goto Cleanup;

    VariantClear(pValue);
    switch (type)
    {
        case REG_SZ:
            (*pValue).bstrVal = SysAllocString(buffer);
            if (!(*pValue).bstrVal)       // Alloc failed?
                goto Cleanup;
            (*pValue).vt = VT_BSTR;
            break;

        case REG_DWORD:
            (*pValue).vt = VT_I4;
            (*pValue).lVal = *(DWORD*)buffer;
            break;

        default:
            hr = E_NOTIMPL;
            goto Cleanup;
    }

Cleanup:
    if (hOpenedKey)
        (void) RegCloseKey(hOpenedKey);
    return S_OK;
}

HRESULT
CPadDoc::DeleteRegValue(long hkeyIn, BSTR bstrSubKey, BSTR bstrValueName)
{
    HKEY hkey = (HKEY)(LONG_PTR)hkeyIn;
    HKEY hOpenedKey;
    HRESULT hr = S_OK;

    // Default key to HKEY_CURRENT_USER
    if (hkey==0)
    {
        hkey = HKEY_CURRENT_USER;
    }

    hr = RegOpenKeyEx(hkey, bstrSubKey, 0, KEY_SET_VALUE, &hOpenedKey);

    if (ERROR_SUCCESS == hr)
    {
        RegDeleteValue(hOpenedKey, bstrValueName);
        (void)RegCloseKey(hOpenedKey);
    }

    return hr;
}

HRESULT
CPadDoc::SetRegValue(long hkeyIn, BSTR bstrSubKey, BSTR bstrValueName, VARIANT value)
{
    HKEY hkey = (HKEY)(LONG_PTR)hkeyIn;
    HKEY hOpenedKey;
    HRESULT hr = S_OK;
    DWORD dwDisposition;

    // Default key to HKEY_CURRENT_USER
    if (hkey==0)
    {
        hkey = HKEY_CURRENT_USER;
    }

    if (!RegCreateKeyEx(hkey, bstrSubKey, 0, 0, 0, KEY_SET_VALUE, 0,
                            &hOpenedKey, &dwDisposition))
    {
        long lval;
        switch V_VT(&value)
        {
        case VT_I4:
            lval = V_I4(&value);

            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_DWORD, (const BYTE *)(&lval), sizeof(DWORD)))
            {
                hr = E_FAIL;
            }
            break;

        case VT_I2:
            lval = V_I2(&value);

            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_DWORD, (const BYTE *)(&lval), sizeof(DWORD)))
            {
              hr = E_FAIL;
            }
            break;

        case VT_BSTR:
            if (RegSetValueEx(hOpenedKey, bstrValueName, 0, REG_SZ, (const BYTE *)(V_BSTR(&value)), SysStringLen(V_BSTR(&value))*2 + 2))
            {
              hr = E_FAIL;
            }
            break;

        default: hr = E_FAIL;
        }

        Verify(!RegCloseKey(hOpenedKey));

        // Cause MSHMTL.DLL to re-read registry settings
        if (_pInPlaceObject)
        {
            HWND hwndDoc;
            _pInPlaceObject->GetWindow(&hwndDoc);
            (void)SendMessage(hwndDoc, WM_WININICHANGE, 0, 0);
        }

    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT
CPadDoc::TrustProvider(BSTR bstrKeyname, BSTR bstrProvidername, VARIANT *pOldKey)
{
    HRESULT hr;
    VARIANT varProvider;

    VariantInit(pOldKey);            // assume there was no previous key

    VariantInit(&varProvider);          // GetRegValue wants a varaint

    // Get old key value
    hr = GetRegValue(0,
                     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                     bstrKeyname,
                     &varProvider);

    // Was there an existing key?
    if (VT_BSTR!=varProvider.vt || NULL==varProvider.bstrVal)
    {
        varProvider.vt = VT_BSTR;
        varProvider.bstrVal = SysAllocString(bstrProvidername);

        // No, then we set one
        hr = SetRegValue(0,
                         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                         bstrKeyname,
                         varProvider);

        // and return a copy of the keyname to indicate we set it
        // (this will be used by RevertTrustProvider to delete it).
        pOldKey->vt = VT_BSTR;
        pOldKey->bstrVal = SysAllocString(bstrKeyname);
    }

    VariantClear(&varProvider);

    return hr;
}

HRESULT
CPadDoc::RevertTrustProvider(BSTR keyname)
{
    HRESULT hr = S_OK;

    if (keyname && *keyname)
    {
        hr = DeleteRegValue(0,
                            _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0"),
                            keyname);
    }

    return hr;
}

HRESULT GetPadLineTypeInfo(CPadDoc * pPadDoc, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(pPadDoc->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = pPadDoc->_pTypeInfoILine;

Cleanup:
    RRETURN(hr);
}

HRESULT GetPadCascadedTypeInfo(CPadDoc * pPadDoc, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    hr = THR(pPadDoc->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    *pptinfo = pPadDoc->_pTypeInfoICascaded;

Cleanup:
    RRETURN(hr);
}

HRESULT
CPadDoc::ComputeCRC(BSTR bstrText, VARIANT * pCRC)
{
    const TCHAR* pch = bstrText;
    WORD         wHash = 0;

    if (pch)
    {
        for (;*pch; pch++)
        {
            wHash = wHash << 7 ^ wHash >> (16-7) ^ (*pch);
        }
    }

    V_VT(pCRC) = VT_I2;
    V_I2(pCRC) = wHash;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_Dbg, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_Dbg(long *plDbg)
{
#ifdef DBG
    *plDbg = DBG;
#else
    *plDbg = 0;
#endif
    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::get_ProcessorArchitecture, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_ProcessorArchitecture(BSTR * pbstrMachineType)
{
    *pbstrMachineType = SysAllocString(ProcessorArchitecture());

    RRETURN(*pbstrMachineType ? S_OK : E_OUTOFMEMORY);
}

TCHAR *
CPadDoc::ProcessorArchitecture()
{
    SYSTEM_INFO si;
    TCHAR *     pch;

    GetSystemInfo(&si);

    switch (si.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        pch = _T("x86");
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        pch = _T("amd64");
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        pch = _T("ia64");
        break;
    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        pch = _T("Unknown");
        break;
    }

    return pch;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::CoMemoryTrackDisable, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::CoMemoryTrackDisable(VARIANT_BOOL fDisable)
{
    DbgCoMemoryTrackDisable(fDisable);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_UseShdocvw, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_UseShdocvw(VARIANT_BOOL *pfHosted)
{
    *pfHosted = !!_fUseShdocvw;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_UseShdocvw, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_UseShdocvw(VARIANT_BOOL fHosted)
{
    _fUseShdocvw = fHosted;
    SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, (LPARAM)MAKELONG(_fUseShdocvw, 0));
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::get_DownloadNotifyMask, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::get_DownloadNotifyMask(ULONG *pulMask)
{
    *pulMask = _ulDownloadNotifyMask;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::put_DownloadNotifyMask, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::put_DownloadNotifyMask(ULONG ulMask)
{
    _ulDownloadNotifyMask = ulMask;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GoBack, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GoBack(VARIANT_BOOL *pfWentBack)
{
    HRESULT hr;
    *pfWentBack = FALSE;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->GoBack());
        *pfWentBack = (hr == S_OK);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::GoForward, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::GoForward(VARIANT_BOOL *pfWentForward)
{
    HRESULT hr;
    *pfWentForward = FALSE;

    if (_pBrowser)
    {
        hr = THR(_pBrowser->GoForward());
        *pfWentForward = (hr == S_OK);
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::TestExternal, IPad
//
//---------------------------------------------------------------------------

typedef HRESULT (TestExternal_Func)(VARIANT *pParam, long *plRetVal);

HRESULT
CPadDoc::TestExternal(
    BSTR bstrDLLName,
    BSTR bstrFunctionName,
    VARIANT *pParam,
    long *plRetVal)
{
    HRESULT hr = S_OK;
    HINSTANCE hInstDLL = NULL;
    TestExternal_Func *pfn = NULL;

    if (!plRetVal || !bstrDLLName || !bstrFunctionName)
        return E_POINTER;

    *plRetVal = -1;

    int cchLen = SysStringLen(bstrDLLName);
    char * pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrDLLName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        hInstDLL = LoadLibraryA(pchBuf);

        delete pchBuf;
    }

    if (NULL == hInstDLL)
    {
        TraceTagEx((tagScriptLog, TAG_NONAME, "TestExternal can't load external dll"));
        return S_FALSE;     // Can't return error codes or the script will abort
    }

    cchLen = SysStringLen(bstrFunctionName);
    pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrFunctionName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        pfn = (TestExternal_Func *)GetProcAddress(hInstDLL, pchBuf);

        delete pchBuf;
    }

    if (NULL == pfn)
    {
        TraceTagEx((tagScriptLog, TAG_NONAME, "TestExternal can't find external function"));
        hr = S_FALSE;
    }
    else
    {
        *plRetVal = 0;
        hr = (*pfn)(pParam, plRetVal);
    }

    FreeLibrary(hInstDLL);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::UnLoadDLL, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::UnLoadDLL()
{
    HRESULT hr;

    hr = THR(CloseFile());
    if (hr)
        goto Cleanup;

    UnregisterLocalCLSIDs();
    CoFreeUnusedLibraries();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member: CPadDoc::DeinitDynamicLibrary, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::DeinitDynamicLibrary(BSTR bstrDLLName)
{
    static DYNPROC s_dynprocDeinitDynamicLibrary = { NULL, &g_dynlibMSHTML, "DeinitDynamicLibrary" };

    if (    s_dynprocDeinitDynamicLibrary.pfn != NULL
        ||  LoadProcedure(&s_dynprocDeinitDynamicLibrary) == S_OK)
    {
        ((void (STDAPICALLTYPE *)(LPCTSTR))s_dynprocDeinitDynamicLibrary.pfn)(bstrDLLName);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IsDynamicLibraryLoaded, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IsDynamicLibraryLoaded(BSTR bstrDLLName, VARIANT_BOOL *pfLoaded)
{
    static DYNPROC s_dynprocIsDynamicLibraryLoaded = { NULL, &g_dynlibMSHTML, "IsDynamicLibraryLoaded" };
    if (    s_dynprocIsDynamicLibraryLoaded.pfn != NULL
        ||  LoadProcedure(&s_dynprocIsDynamicLibraryLoaded) == S_OK)
    {
        *pfLoaded = ((BOOL (STDAPICALLTYPE *)(LPCTSTR))s_dynprocIsDynamicLibraryLoaded.pfn)(bstrDLLName) ?
            VB_TRUE : VB_FALSE;
    }

    return S_OK;
}

HRESULT CPadDoc::get_ViewChangesFired(long *plCount)
{
    *plCount = _lViewChangesFired;
    _lViewChangesFired = 0; // reset count
    return S_OK;
}

HRESULT CPadDoc::get_DataChangesFired(long *plCount)
{
    *plCount = _lDataChangesFired;
    _lDataChangesFired = 0; // reset count
    return S_OK;
}



class CPadServerOM : public IDispatch
{
public:
    CPadServerOM(DWORD dwUA, TCHAR *pchUA, TCHAR *pchFile, TCHAR *pchQS);

    DECLARE_FORMS_STANDARD_IUNKNOWN(CPadServerOM)
    STDMETHOD(GetTypeInfo)(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
        { return E_NOTIMPL; }
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo)
        { return E_NOTIMPL; }
    STDMETHOD(GetIDsOfNames)(REFIID riid,
                             LPOLESTR * rgszNames,
                             UINT cNames,
                             LCID lcid,
                             DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr);

    //
    // Data
    //

    CStr    _cstrUA;
    CStr    _cstrFile;
    CStr    _cstrQS;
    DWORD   _dwUA;
};


CPadServerOM::CPadServerOM(DWORD dwUA, TCHAR *pchUA, TCHAR *pchFile, TCHAR *pchQS)
{
    _dwUA = dwUA;
    _cstrUA.Set(pchUA);
    _cstrFile.Set(pchFile);
    _cstrQS.Set(pchQS);
    _ulRefs = 0;
}


HRESULT
CPadServerOM::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDispatch)
    {
        *ppv = (IDispatch *)this;
        AddRef();
        return S_OK;
    }

    return E_NOTIMPL;
}


HRESULT
CPadServerOM::GetIDsOfNames(
    REFIID riid,
    LPOLESTR * rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID * rgdispid)
{
    DISPID  dispid = DISPID_UNKNOWN;

    if (_tcsequal(*rgszNames, _T("UserAgent")))
    {
        dispid = 1;
    }
    else if (_tcsequal(*rgszNames, _T("NormalizedUA")))
    {
        dispid = 2;
    }
    else if (_tcsequal(*rgszNames, _T("URL")))
    {
        dispid = 3;
    }
    else if (_tcsequal(*rgszNames, _T("Path")))
    {
        dispid = 4;
    }
    else if (_tcsequal(*rgszNames, _T("QueryString")))
    {
        dispid = 5;
    }

    *rgdispid = dispid;
    return dispid == DISPID_UNKNOWN ? DISP_E_UNKNOWNNAME : S_OK;
}


HRESULT
CPadServerOM::Invoke(
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS * pdispparams,
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo,
    UINT * puArgErr)
{
    if (!pvarResult)
        return S_OK;

    switch (dispidMember)
    {
    case 1:
        V_VT(pvarResult) = VT_BSTR;
        _cstrUA.AllocBSTR(&V_BSTR(pvarResult));
        break;

    case 2:
        V_VT(pvarResult) = VT_I4;
        V_I4(pvarResult) = _dwUA;
        break;

    case 3:
    case 4:
        V_VT(pvarResult) = VT_BSTR;
        _cstrFile.AllocBSTR(&V_BSTR(pvarResult));
        break;

    case 5:
        if (_cstrQS)
        {
            V_VT(pvarResult) = VT_BSTR;
            _cstrQS.AllocBSTR(&V_BSTR(pvarResult));
        }
        else
        {
            V_VT(pvarResult) = VT_NULL;
        }
        break;

    default:
        return DISP_E_MEMBERNOTFOUND;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Sleep, per IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::Sleep (int nTimeout)
{
    ::Sleep (nTimeout);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::IsWin95, per IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::IsWin95(long * pfWin95)
{
    OSVERSIONINFOA ovi;

    if (!pfWin95)
        return E_POINTER;

    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&ovi);

    *pfWin95 = (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetAccWindow, per IPad
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccWindow( IDispatch ** ppAccWindow )
{
    HWND                hwnd = NULL;
    HRESULT             hr = S_OK;
    HINSTANCE           hInstOleacc = 0;
    IDispatch *         pHTMLDoc = NULL;
    IServiceProvider *  pServProv = NULL;

    if ( !ppAccWindow )
        return E_POINTER;

    *ppAccWindow = NULL;

    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    hInstOleacc = LoadLibraryA( "OLEACC.DLL" );

    if ( hwnd && hInstOleacc )
    {
        // get the document
        hr = get_Document( &pHTMLDoc );
        if ( hr || !pHTMLDoc )
            goto Cleanup;

        // get the service provider interface
        hr = pHTMLDoc->QueryInterface( IID_IServiceProvider, (void **)&pServProv);
        if ( hr || !pServProv )
            goto Cleanup;


        // get the IAccessible interface
        hr = pServProv->QueryService( IID_IAccessible, IID_IAccessible, (void **)ppAccWindow);
        if ( hr || !ppAccWindow )
            goto Cleanup;

    }


//FerhanE:
//  Even if we can not find the OLEACC.DLL, return NULL as the out value and a success code.
//  This way, the script can skip over the code that requires this information.

Cleanup:
    if ( hInstOleacc)
        FreeLibrary( hInstOleacc );

    if ( pHTMLDoc )
        pHTMLDoc->Release();

    if ( pServProv )
        pServProv->Release();

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetAccObjAtPoint, per IPad
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccObjAtPoint( long x, long y, IDispatch ** ppAccObject )
{
    HRESULT         hr = S_OK;
    IAccessible *   pAcc = NULL;
    VARIANT         varChild;
    HWND            hwnd = NULL;
    RECT            rectPos;

    // check the parameters.
    if ( !ppAccObject )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset the return value.
    *ppAccObject = NULL;

    // get the window object for this
    hr = GetAccWindow((IDispatch **)&pAcc);
    if(hr)
        goto Cleanup;

    // get the window handle, so we can get the coordinates for
    // the window that contains us.
    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    ::GetWindowRect( hwnd, &rectPos );

    while (pAcc)
    {
        V_VT(&varChild) = VT_EMPTY;
        V_I4(&varChild) = 0;

        // get the object at the location given relative to
        // the top left of the Trident window
        hr = pAcc->accHitTest(rectPos.left+x, rectPos.top+y, &varChild);
        if (hr)
            goto Cleanup;

        if (V_VT(&varChild) == VT_I4)
        {
            // either the object itself, or a text child of that object
            // has been hit. Return the object's pointer.

            // This pointer is already addref'ed we don't have to addref again.
            *ppAccObject = pAcc;

            // clean the pointer variable to get out of the loop and return.
            pAcc = NULL;
        }
        else
        {
            // Release the object we have in hand, make the accessible
            // child that contains the hit the current accessible object.
            ReleaseInterface(pAcc);

            Assert(V_DISPATCH(&varChild));

            // no need to addref since it is already addref'ed for us.
            // we won't use it here, pass it out as it is.
            pAcc = (IAccessible *)V_DISPATCH(&varChild);
        }
    }

Cleanup:
    if (hr)
        ReleaseInterface(pAcc);

    return hr;
}


//----------------------------------------------------------------------------
//
//  Returns the child id of the text child that this object contains,
//  If the object itself received the hit but no child ( body with no text or
//  an empty area of the page) , it returns 0 (CHILDID_SELF) = *plChildId
//
//  If the child that is hit is actually another object, then it returns -1 = *plChildId
//  If the object that is hit is not this object, then it returns -1 = *plChildId.
//
//  This function is supposed to be used after getting the object that is hit using
//  the GetAccObjAtPoint function. This function will be only useful when the child
//  that is hit is a text child of a certain object.
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetAccChildIdAtPoint( IDispatch * pAccObj, long x, long y, long * plChildId )
{
    HRESULT     hr = S_OK;
    RECT        rectPos;
    HWND        hwnd = NULL;
    VARIANT     varChild;

    if (!plChildId)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plChildId = -1;        // prepare for the worst case.

    // adjust the coordinates to screen coordinates.
    if (_pInPlaceActiveObject )
            _pInPlaceActiveObject->GetWindow(&hwnd);

    if ( !hwnd && _pInPlaceObject )
            _pInPlaceObject->GetWindow(&hwnd);

    ::GetWindowRect( hwnd, &rectPos);

    // we have the accessible object, we can make the hittest call.
    //
    // casting here, since we are sure that this is an accessible pointer.
    // if this was mshtml.code, we would QI.
    hr = ((IAccessible *)pAccObj)->accHitTest(rectPos.left+x, rectPos.top+y, &varChild);
    if (hr)
        goto Cleanup;

    if (V_VT(&varChild) == VT_I4)
    {
        // set the return value.
        *plChildId = V_I4(&varChild);
    }
    else
    {
        // else just return with the return code we already have.
        // since it means that we hit another child object, or the object we have
        // did not get hit.

        // release the object we received not to leak it.
        if (V_VT(&varChild) == VT_DISPATCH)
            V_DISPATCH(&varChild)->Release();
    }


Cleanup:
    return hr;
}


//----------------------------------------------------------------------------
//
//  Callback function: FindTridentWindow()
//                     This callback function is used by FindMshtmlWindow() to
//                     find a child window whose class matches MSHTML_WINDOW_CLASSNAME
//
//----------------------------------------------------------------------------
static BOOL CALLBACK
FindTridentWindow ( HWND hwnd, LPARAM lparam)
{
    TCHAR pch[ 80 ];

    hwndInternetExplorerServer = 0;

    if ( ! GetClassName( hwnd, pch, 80 ) )
        goto Cleanup;

    if (! StrCmpC( MSHTML_WINDOW_CLASSNAME, pch ) )
    {
        hwndInternetExplorerServer = hwnd;
        return FALSE;
    }

Cleanup:
    return TRUE;
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::FindMshtmlWindow()
//          Finds the window that hosts Trident given the class name of an application
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::FindMshtmlWindow ( BSTR bstrClassName, long * plhwnd )
{
    HWND    hwndHostApplication;

    *plhwnd = 0;

    hwndHostApplication = FindWindow( bstrClassName, NULL );
    if (! hwndHostApplication)
        goto Cleanup;

    EnumChildWindows( hwndHostApplication, FindTridentWindow, 0 );

    *plhwnd = HandleToLong( hwndInternetExplorerServer );

Cleanup:
    return( *plhwnd ? S_OK : E_FAIL );
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::GetMshtmlDoc()
//          Uses active accessibility to fetch IHTMLDocument2 given a window handle
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::GetMshtmlDoc ( long lhwnd, IDispatch ** ppdispDocument )
{
    UINT        msgHtmlGetobject;
    LRESULT     lr;
    HRESULT     hr;
    HWND        hwndToUse = (HWND)(LongToPtr(lhwnd));

    static DYNPROC s_dynprocObjectFromLresult =
            { NULL, &g_dynlibOLEACC, "ObjectFromLresult" };

    *ppdispDocument = NULL;

    // Check the argument sanity
    if (! IsWindow( hwndToUse ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Register and send the getobject message
    msgHtmlGetobject = RegisterWindowMessage( MSGNAME_WM_HTML_GETOBJECT );
    if (! msgHtmlGetobject)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lr = SendMessage( hwndToUse, msgHtmlGetobject, 0, 0);
    if (! lr)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Load ObjectFromLresult() from OLEACC.DLL and call it
    hr = THR( LoadProcedure( & s_dynprocObjectFromLresult ) );
    if (hr)
    {
        goto Cleanup;
    }

    hr = (*(HRESULT (APIENTRY *)(LRESULT, REFIID, WPARAM, void**) )
            s_dynprocObjectFromLresult.pfn)(lr,
                                            IID_IDispatch,
                                            0,
                                            (void **) ppdispDocument);

Cleanup:
    return hr;
}


//----------------------------------------------------------------------------
//
//  Member: CPadDoc::SetActiveWindow()
//          After this function is called, mouse and keyboard actions are directed
//          to g_hwndActiveWindow rather than the pad.
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::SetActiveWindow (long lhwnd)
{
    HRESULT hr = S_OK;
    HWND    hwnd = (HWND)(LongToPtr(lhwnd));

    if (! IsWindow( hwnd ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    g_hwndActiveWindow = hwnd;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member : SetKeyboard
//
//  Synopsis: Change the keyboard layout for IME testing.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SetKeyboard( BSTR bstrKeyboard)
{
    int     nIndex = -1;
    int     nSystem;
    HKL     hkblyt;
    char    *pBuf = NULL;
    char    szBufA[KL_NAMELENGTH];

    //
    // Initialize the system index.  This is used to index the array of keyboard layouts
    // which indicates how to load the IME.  This differs for the GIMEs shipped with
    // non-native systems and NT 5.0.  See the comment for astrKeyboardLayouts at the
    // top of this file
    //
    nSystem = ( g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000 ) ? 1 : 0;

    if (bstrKeyboard)
    {
        if( StrCmpIC( bstrKeyboard, _T("jpn") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_JPN;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("kor") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_KOR;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("cht") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_CHT;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else if( StrCmpIC( bstrKeyboard, _T("chs") ) == 0 )
        {
            nIndex = KEYBOARD_LAYOUT_CHS;
            pBuf = astrKeyboardLayouts[nIndex][nSystem];
        }
        else
        {
            WideCharToMultiByte(CP_ACP, 0,
                                bstrKeyboard, SysStringLen(bstrKeyboard),
                                szBufA, sizeof(szBufA), NULL, NULL);
            szBufA[KL_NAMELENGTH-1] = (char)0;
            pBuf = szBufA;
        }

        //
        // Load the keyboard layout
        //
        hkblyt = LoadKeyboardLayoutA( pBuf, 0);
        if (hkblyt)
        {
            HKL     hkblytPrev;
            hkblytPrev = ActivateKeyboardLayout(hkblyt, KLF_SETFORPROCESS);
            if (hkblytPrev)
            {
                return S_OK;
            }
            else
                UnloadKeyboardLayout(hkblyt);
        }
    }

    return E_POINTER;
}

//---------------------------------------------------------------------------
//
//  Member : GetKeyboard
//
//  Synopsis: Change the keyboard layout for IME testing.
//
//---------------------------------------------------------------------------

HRESULT
   CPadDoc::GetKeyboard( VARIANT *pKeyboard)
{
    if (pKeyboard)
    {
        char szBufA[KL_NAMELENGTH];
        if (GetKeyboardLayoutNameA(szBufA))
        {
            TCHAR szBufW[KL_NAMELENGTH];
            MultiByteToWideChar(CP_ACP, 0, szBufA, sizeof(szBufA),
                                szBufW, sizeof(szBufW)/sizeof(TCHAR));
            szBufW[KL_NAMELENGTH-1] = (char)0;
            V_VT(pKeyboard) = VT_BSTR;
            V_BSTR(pKeyboard) = SysAllocString(szBufW);
            if (V_BSTR(pKeyboard))
                return (S_OK);
        }
    }

    return E_POINTER;
}
//---------------------------------------------------------------------------
//
//  Member : ToggleIMEMode
//
//  Synopsis: Change the IME mode.
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::ToggleIMEMode( BSTR bstrIME)
{
    HRESULT             hr = S_OK;
    IDispatch           *pHTMLDoc = NULL;
    IIMEServices        *pIMEServices = NULL;
    IActiveIMMApp       *pIMEApp = NULL;
    DWORD               dwConversion;
    DWORD               dwSentence;
    HIMC                hIMC = NULL;
    HWND                hWnd;
    IOleWindow          *pIOleWindow = NULL;
    BOOL                fSuccess;

    //
    // Get the IActiveIMMApp interface pointer
    //
    IFC( get_Document( &pHTMLDoc ) );
    IFC( pHTMLDoc->QueryInterface(IID_IOleWindow, (void **)&pIOleWindow));
    IFC( pIOleWindow->GetWindow( &hWnd ) );

    IFC( pHTMLDoc->QueryInterface( IID_IIMEServices, (void **)&pIMEServices ) );
    IFC( pIMEServices->GetActiveIMM(&pIMEApp) );

    //
    // If we have an IActiveIMMApp pointer, use that to change
    // the IME properties, otherwise, just use plain IMM32 calls.
    if( pIMEApp )
    {
        IFC( pIMEApp->GetContext( hWnd, &hIMC ) );
    }
    else
    {
        hIMC = ImmGetContext( hWnd );
        if( !hIMC )
            goto Cleanup;
    }

    if( pIMEApp )
    {
        IFC( pIMEApp->GetConversionStatus( hIMC, &dwConversion, &dwSentence ) );
    }
    else
    {
        if( !ImmGetConversionStatus( hIMC, &dwConversion, &dwSentence ) )
            goto Cleanup;
    }

    dwConversion &= ~IME_CMODE_NOCONVERSION;
    dwConversion &= ~IME_CMODE_SYMBOL;

    if( StrCmpIC(bstrIME, _T("KOR") ) == 0 )
        dwConversion |= IME_CMODE_NATIVE;


    if( pIMEApp )
    {
        IFC( pIMEApp->SetConversionStatus( hIMC, dwConversion, dwSentence ) );
    }
    else
    {
        if( !ImmSetConversionStatus( hIMC, dwConversion, dwSentence ) )
            goto Cleanup;
    }

    if (StrCmpIC(bstrIME, _T("JPN")) == 0)
    {
        if( pIMEApp )
        {
            IFC( pIMEApp->SetOpenStatus( hIMC, TRUE ) );
        }
        else
        {
            if( !ImmSetOpenStatus( hIMC, TRUE ) )
                goto Cleanup;
        }
    }


Cleanup:

    ReleaseInterface( pIOleWindow );
    ReleaseInterface( pIMEServices );
    ReleaseInterface( pIMEApp );
    ReleaseInterface( pHTMLDoc );

    RRETURN(hr);
}
//---------------------------------------------------------------------------
//
//  Member : SendIMEKeys
//
//  Synopsis: Send keyboard events from the given string
//            so that the IME will be able to trap them.
//
//---------------------------------------------------------------------------

// For just one key at a time.
TCHAR *
   CPadDoc::SendIMEKey(TCHAR *pch, DWORD dwFlags)
{
    BYTE ch;
    switch (*pch)
    {
        default:
            ch = (BYTE)*pch;
            if (ch >= 'a' && ch <= 'z')
                ch -= 'a' - 'A';
            keybd_event(ch, (BYTE)MapVirtualKey(ch, 0), 0, 0);
            keybd_event(ch, (BYTE)MapVirtualKey(ch, 0), KEYEVENTF_KEYUP, 0);
            pch++;
            break;

        case _T('+'):
            keybd_event(VK_SHIFT, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags);
            keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('^'):
            keybd_event(VK_CONTROL, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags);
            keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('%'):
            keybd_event(VK_MENU, 0, 0, 0);
            pch++;
            pch = SendIMEKey(pch, dwFlags | (KF_ALTDOWN << 16));
            keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
            break;

        case _T('{'):
            pch++;
            pch = SendIMESpecial(pch, 0);
            break;
    }
    return pch;
}
HRESULT
   CPadDoc::SendIMEKeys( BSTR bstrKeys )
{
    if (bstrKeys)
    {
        TCHAR *pch = bstrKeys;

        // Put in all the keystrokes.
        while (*pch != 0)
        {
            pch = SendIMEKey(pch, 0);
        }
        return (S_OK);
    }

    return E_POINTER;
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::RemoveElement
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::RemoveElement ( IDispatch * pIDispatch )
{
    HRESULT            hr = S_OK;
    IDispatch *        pDocDisp = NULL;
    IMarkupServices *  pMarkupServices = NULL;
    IHTMLElement *     pIElement = NULL;

    if (!pIDispatch)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( pIDispatch->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );

    if (hr)
        goto Cleanup;

    hr = THR( get_Document( & pDocDisp ) );

    if (hr)
        goto Cleanup;

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupServices, (void **) & pMarkupServices ) );

    if (hr)
        goto Cleanup;

    hr = THR( pMarkupServices->RemoveElement( pIElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (pDocDisp)
        pDocDisp->Release();

    if (pIElement)
        pIElement->Release();

    if (pMarkupServices)
        pMarkupServices->Release();

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//
//  Member: CPadDoc::Markup
//
//----------------------------------------------------------------------------

static IMarkupServices *  g_MS = NULL;
static IMarkupContainer * g_PM = NULL;

static HRESULT
FindElementByTagId ( ELEMENT_TAG_ID tagIdFindThis, IHTMLElement * * ppIElement )
{
    HRESULT          hr = S_OK;
    IMarkupPointer * pIPointer = NULL;

    Assert( ppIElement );

    *ppIElement = NULL;

    hr = THR( g_MS->CreateMarkupPointer( & pIPointer ) );

    if (hr)
        goto Cleanup;

    hr = THR( pIPointer->MoveToContainer( g_PM, TRUE ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;

        hr = THR( pIPointer->Right( TRUE, & ct, ppIElement, NULL, NULL ) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            ELEMENT_TAG_ID tagId;

            hr = THR( g_MS->GetElementTagId( *ppIElement, & tagId ) );

            if (hr)
                goto Cleanup;

            if (tagId == tagIdFindThis)
                break;

        }
        if (*ppIElement)
            (*ppIElement)->Release();
    }

Cleanup:

    if (pIPointer)
        pIPointer->Release();

    RRETURN( hr );
}

static HRESULT
MangleRemoveBody ( )
{
    HRESULT        hr = S_OK;
    IHTMLElement * pIElement = NULL;

    hr = THR( FindElementByTagId( TAGID_BODY, & pIElement ) );

    if (hr)
        goto Cleanup;

    if (!pIElement)
        goto Cleanup;

    hr = THR( g_MS->RemoveElement( pIElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (pIElement)
        pIElement->Release();

    RRETURN( hr );
}

static HRESULT
MangleRemoveTables ( )
{
    HRESULT        hr = S_OK;
    IHTMLElement * pIElement = NULL;

    for ( ; ; )
    {
        hr = THR( FindElementByTagId( TAGID_TABLE, & pIElement ) );

        if (hr)
            goto Cleanup;

        if (!pIElement)
            goto Cleanup;

        hr = THR( g_MS->RemoveElement( pIElement ) );

        if (hr)
            goto Cleanup;

        pIElement->Release();
        pIElement = NULL;
    }

Cleanup:

    if (pIElement)
        pIElement->Release();

    RRETURN( hr );
}

IMarkupPointer *
CPadDoc::FindPadPointer ( long id )
{
    for ( int i = 0 ; i < _aryPadPointers.Size() ; i++ )
        if (_aryPadPointers[i]._id == id)
            return _aryPadPointers[i]._pPointer;

    return NULL;
}

IMarkupPointer *
CPadDoc::FindPadPointer ( VARIANT * pvar )
{
    if (!pvar || V_VT( pvar ) != VT_I4)
        return NULL;

    return FindPadPointer( V_I4( pvar ) );
}

IMarkupContainer *
CPadDoc::FindPadContainer ( long id )
{
    for ( int i = 0 ; i < _aryPadContainers.Size() ; i++ )
        if (_aryPadContainers[i]._id == id)
            return _aryPadContainers[i]._pContainer;

    return NULL;
}

IMarkupContainer *
CPadDoc::FindPadContainer ( VARIANT * pvar )
{
    if (!pvar || V_VT( pvar ) != VT_I4)
        return NULL;

    return FindPadContainer( V_I4( pvar ) );
}

IHTMLElement *
CPadDoc::GetElement ( VARIANT * pvar )
{
    IHTMLElement * pIElement;

    if (!pvar || V_VT( pvar ) != VT_DISPATCH || !V_DISPATCH( pvar ))
        return NULL;

    if (V_DISPATCH( pvar )->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) != S_OK)
        return NULL;

    return pIElement;
}

HRESULT
CPadDoc::Markup (
    VARIANT * pvarParam1, VARIANT * pvarParam2, VARIANT * pvarParam3,
    VARIANT * pvarParam4, VARIANT * pvarParam5, VARIANT * pvarParam6,
    VARIANT * pvarRet )
{
    HRESULT            hr = S_OK;
    IDispatch *        pDocDisp = NULL;
    IHTMLElement *     pIElement = NULL;

    VariantClear( pvarRet );

    hr = THR( get_Document( & pDocDisp ) );

    if (hr)
        goto Cleanup;

    Assert( ! g_MS && ! g_PM );

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupServices, (void **) & g_MS ) );

    if (hr)
        goto Cleanup;

    hr = THR( pDocDisp->QueryInterface( IID_IMarkupContainer, (void **) & g_PM ) );

    if (hr)
        goto Cleanup;

    if (!pvarParam1 || V_VT( pvarParam1 ) != VT_BSTR)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveElement" )))  // element
    {
        if (!pvarParam2)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIElement = GetElement( pvarParam2 );

        if (pIElement)
        {
            hr = THR( RemoveElement( V_DISPATCH( pvarParam2 ) ) );

            if (hr)
                goto Cleanup;
        }
        else if (V_VT( pvarParam2 ) == VT_BSTR)
        {
            ELEMENT_TAG_ID tagId;
            IHTMLElement * pIElement = NULL;

            hr = THR( g_MS->GetTagIDForName ( V_BSTR( pvarParam2 ), & tagId ) );

            if (hr)
                goto Cleanup;

            hr = THR( FindElementByTagId( tagId, & pIElement ) );

            if (hr)
                goto Cleanup;

            if (pIElement)
            {
                hr = THR( RemoveElement( pIElement ) );

                if (hr)
                    goto Cleanup;

                pIElement->Release();
            }

        }
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "TagIdToString" )))  // str/element
    {
        if (!pvarParam2 || V_VT( pvarParam2 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->GetNameForTagID( ELEMENT_TAG_ID( V_I4( pvarParam2 ) ), & V_BSTR( pvarRet ) ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "GetTagId" )))  // str/element
    {
        IHTMLElement * pElement = NULL;
        ELEMENT_TAG_ID tagID = TAGID_NULL;

        if (!pvarParam2)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIElement = GetElement( pvarParam2 );

        if (pIElement)
        {
            hr = THR( g_MS->GetElementTagId( pElement, & tagID ) );

            if (hr)
                goto Cleanup;
        }
        else if (V_VT( pvarParam2 ) == VT_BSTR)
        {
            hr = THR( g_MS->GetTagIDForName ( V_BSTR( pvarParam2 ), & tagID ) );

            if (hr)
                goto Cleanup;
        }

        pvarRet->vt = VT_I4;
        pvarRet->lVal = tagID;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "InsertElement" )))  // pStart, pFin, element
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );

        pIElement = GetElement( pvarParam4 );

        if (!pIPointerStart || !pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->InsertElement( pIElement, pIPointerStart, pIPointerFinish ) );
        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Remove" )))  // pStart, pFin
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );

        if (!pIPointerStart || !pIPointerFinish)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Remove( pIPointerStart, pIPointerFinish ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Move" )))  // pStart, pFin, pTarget
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );
        IMarkupPointer * pIPointerTarget = FindPadPointer( pvarParam4 );

        if (!pIPointerStart || !pIPointerFinish || !pIPointerTarget)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Move( pIPointerStart, pIPointerFinish, pIPointerTarget ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Copy" )))  // pStart, pFin, pTarget
    {
        IMarkupPointer * pIPointerStart = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerFinish = FindPadPointer( pvarParam3 );
        IMarkupPointer * pIPointerTarget = FindPadPointer( pvarParam4 );

        if (!pIPointerStart || !pIPointerFinish || !pIPointerTarget)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->Copy( pIPointerStart, pIPointerFinish, pIPointerTarget ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "FindText" )))  // start, text, end match, end search
    {
        IMarkupPointer * pIPointerStartSearch = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerEndMatch = FindPadPointer( pvarParam4 );
        IMarkupPointer * pIPointerEndSearch = FindPadPointer( pvarParam5 );

        if (!pIPointerStartSearch || !pIPointerStartSearch || !pIPointerEndSearch)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pIPointerStartSearch->FindText( V_BSTR( pvarParam3 ), 0, pIPointerEndMatch, pIPointerEndSearch );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = hr = S_FALSE ? 0 : 1;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "InsertText" )))  // pointer, text
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer || !pvarParam3|| V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            g_MS->InsertText(
                V_BSTR( pvarParam3 ),
                FormsStringLen( V_BSTR( pvarParam3 ) ),
                pIPointer ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveBody" )))  // no args
    {
        hr = THR( MangleRemoveBody() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "RemoveTables" )))   // no args
    {
        hr = THR( MangleRemoveTables() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "DumpTree" )))  // pointer [optional]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IEditDebugServices * pEditDebug;

        hr = THR( pDocDisp->QueryInterface( IID_IEditDebugServices, (void **) & pEditDebug ) );

        if (hr)
            goto Cleanup;

        pEditDebug->DumpTree( pIPointer );

        pEditDebug->Release();
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateElement" ))) // tag id, attribute string, ret element
    {
        hr = THR( g_MS->CreateElement((ELEMENT_TAG_ID)V_I4(pvarParam2), V_BSTR(pvarParam3), &pIElement) );
        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;
        pvarRet->pdispVal = pIElement;

        pIElement = NULL;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CloneElement" )))  // in element, ret clone
    {
        IHTMLElement * pIElementClone;

        pIElement = GetElement( pvarParam2 );

        if (!pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->CloneElement( pIElement, & pIElementClone ) );
        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;
        pvarRet->pdispVal = pIElementClone;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateMarkupPointer" )))  // return pointer
    {
        IMarkupPointer * pIPointer;
        PadPointerData   padPointer;

        hr = THR( g_MS->CreateMarkupPointer( & pIPointer ) );

        if (hr)
            goto Cleanup;

        padPointer._pPointer = pIPointer;
        padPointer._id = _idPadIDNext++;

        _aryPadPointers.AppendIndirect( & padPointer, NULL );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = padPointer._id;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "CreateMarkupContainer" )))  // return pointer
    {
        IMarkupContainer * pIContainer;
        PadContainerData   padContainer;

        hr = THR( g_MS->CreateMarkupContainer( & pIContainer ) );

        if (hr)
            goto Cleanup;

        padContainer._pContainer = pIContainer;
        padContainer._id = _idPadIDNext++;

        _aryPadContainers.AppendIndirect( & padContainer, NULL );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = padContainer._id;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ReleasePointer" )))  // pointer
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIPointer->Release();

        for ( int i = 0 ; i < _aryPadPointers.Size() ; i++ )
            if (_aryPadPointers[i]._id == V_I4( pvarParam2 ))
                _aryPadPointers.Delete( i );
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ReleaseContainer" )))  // pointer
    {
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam2 );

        if (!pIContainer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pIContainer->Release();

        for ( int i = 0 ; i < _aryPadContainers.Size() ; i++ )
            if (_aryPadContainers[i]._id == V_I4( pvarParam2 ))
                _aryPadContainers.Delete( i );
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "SetGravity" )))  // pStrGravity (left|right)
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        POINTER_GRAVITY  eGravity;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            eGravity = POINTER_GRAVITY_Left;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            eGravity = POINTER_GRAVITY_Right;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->SetGravity( eGravity ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "SetCling" )))  // bool
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BOOL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->SetCling( V_BOOL( pvarParam3 ) ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Unposition" )))  // no args
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->Unposition() );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToPointer" )))  // p1, p2
    {
        IMarkupPointer * pIPointerMoveMe = FindPadPointer( pvarParam2 );
        IMarkupPointer * pIPointerToHere = FindPadPointer( pvarParam3 );

        if (!pIPointerMoveMe || !pIPointerToHere)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointerMoveMe->MoveToPointer( pIPointerToHere ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToBeginning" )))  // pointer, container [ optional ]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam3 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveToContainer( pIContainer ? pIContainer : g_PM, TRUE ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveToEnd" )))  // pointer, container [ optional ]
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        IMarkupContainer * pIContainer = FindPadContainer( pvarParam3 );

        if (!pIPointer)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveToContainer( pIContainer ? pIContainer : g_PM, FALSE ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MovePointer" )))  // pointer, dir, cchMax, ret actual cch
    {
        IMarkupPointer * pIPointer = FindPadPointer( pvarParam2 );
        long             cch;
        BOOL             fLeft;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) == VT_ERROR)
            cch = -1;
        else if (V_VT( pvarParam4 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        else
            cch = V_I4( pvarParam4 );

        if (fLeft)
            hr = THR( pIPointer->Left( TRUE, NULL, NULL, & cch, NULL ) );
        else
            hr = THR( pIPointer->Right( TRUE, NULL, NULL, & cch, NULL ) );

        pvarRet->vt = VT_I4;
        pvarRet->lVal = cch;

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Context" )))  // pointer, dir, ret context (bstr)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, NULL, NULL, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;

        switch ( ct )
        {
        case CONTEXT_TYPE_None        : hr = THR( FormsAllocStringW( _T( "None" ),       & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_EnterScope  : hr = THR( FormsAllocStringW( _T( "EnterScope" ), & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_ExitScope   : hr = THR( FormsAllocStringW( _T( "ExitScope" ),  & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_NoScope     : hr = THR( FormsAllocStringW( _T( "NoScope" ),    & pvarRet->bstrVal ) ); break;
        case CONTEXT_TYPE_Text        : hr = THR( FormsAllocStringW( _T( "Text" ),       & pvarRet->bstrVal ) ); break;
        }

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ContextElement" )))  // pointer, dir, ret context (elem)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;
        IHTMLElement *      pIElement = NULL;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, & pIElement, NULL, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, & pIElement, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_DISPATCH;

        if (ct == CONTEXT_TYPE_EnterScope || ct == CONTEXT_TYPE_ExitScope || ct == CONTEXT_TYPE_NoScope)
        {
            hr = THR( pIElement->QueryInterface( IID_IDispatch, (void **) & pvarRet->pdispVal ) );

            if (hr)
                goto Cleanup;
        }
        else
        {
            pvarRet->pdispVal = NULL;
        }

        if (pIElement)
            pIElement->Release();

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "ContextText" )))  // pointer, dir, cchMax, ret text (bstr)
    {
        IMarkupPointer *    pIPointer = FindPadPointer( pvarParam2 );
        BOOL                fLeft;
        MARKUP_CONTEXT_TYPE ct;
        long                cch;

        if (!pIPointer || !pvarParam3 || V_VT( pvarParam3 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Left" )))
            fLeft = TRUE;
        else if (!StrCmpIC( V_BSTR( pvarParam3 ), _T( "Right" )))
            fLeft = FALSE;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) == VT_ERROR)
            cch = -1;
        else if (V_VT( pvarParam4 ) != VT_I4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        else
            cch = V_I4( pvarParam4 );

        if (fLeft)
            hr = THR( pIPointer->Left( FALSE, & ct, NULL, & cch, NULL ) );
        else
            hr = THR( pIPointer->Right( FALSE, & ct, NULL, & cch, NULL ) );

        if (hr)
            goto Cleanup;

        pvarRet->vt = VT_BSTR;

        if (ct == CONTEXT_TYPE_Text)
        {
            TCHAR * pch = new TCHAR [ cch + 1 ];

            if (!pch)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (fLeft)
                hr = THR( pIPointer->Left( FALSE, NULL, NULL, & cch, pch ) );
            else
                hr = THR( pIPointer->Right( FALSE, NULL, NULL, & cch, pch ) );

            pch[cch] = 0;

            hr = THR( FormsAllocStringW( pch, & pvarRet->bstrVal ) );

            delete pch;
        }
        else
        {
            hr = THR( FormsAllocStringW( _T( "" ), & pvarRet->bstrVal ) );

            if (hr)
                goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "MoveAdjacentToElement" )))  // pointer, element, adj
    {
        IMarkupPointer *  pIPointer = FindPadPointer( pvarParam2 );

        ELEMENT_ADJACENCY eAdj;

        pIElement = GetElement( pvarParam3 );

        if (!pIPointer || !pIElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pvarParam4 || V_VT( pvarParam4 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "BeforeBegin" )))
            eAdj = ELEM_ADJ_BeforeBegin;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "AfterBegin" )))
            eAdj = ELEM_ADJ_AfterBegin;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "BeforeEnd" )))
            eAdj = ELEM_ADJ_BeforeEnd;
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "AfterEnd" )))
            eAdj = ELEM_ADJ_AfterEnd;
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( pIPointer->MoveAdjacentToElement( pIElement, eAdj ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "Compare" )))  // p1, p2, how, return t/f
    {
        IMarkupPointer *  p1 = FindPadPointer( pvarParam2 );
        IMarkupPointer *  p2 = FindPadPointer( pvarParam3 );
        BOOL              fResult;

        if (!p1 || !p2 || !pvarParam4 || V_VT( pvarParam4 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsEqualTo" )))
            hr = THR( p1->IsEqualTo( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsLeftOf" )))
            hr = THR( p1->IsLeftOf( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsLeftOfOrEqualTo" )))
            hr = THR( p1->IsLeftOfOrEqualTo( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsRightOf" )))
            hr = THR( p1->IsRightOf( p2, & fResult ) );
        else if (!StrCmpIC( V_BSTR( pvarParam4 ), _T( "IsRightOfOrEqualTo" )))
            hr = THR( p1->IsRightOfOrEqualTo( p2, & fResult ) );
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pvarRet->vt = VT_BOOL;
        pvarRet->boolVal = !!fResult;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "BeginUndoUnit" )))  // undo string
    {
        if (!pvarParam2 || V_VT( pvarParam2 ) != VT_BSTR)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( g_MS->BeginUndoUnit( V_BSTR( pvarParam2 ) ) );

        if (hr)
            goto Cleanup;
    }
    else if (!StrCmpIC( V_BSTR( pvarParam1 ), _T( "EndUndoUnit" )))
    {
        hr = THR( g_MS->EndUndoUnit() );

        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    if (g_PM)
    {
        g_PM->Release();
        g_PM = NULL;
    }

    if (pDocDisp)
        pDocDisp->Release();
    if( pIElement )
        pIElement->Release();

    if (g_MS)
    {
        g_MS->Release();
        g_MS = NULL;
    }

    RRETURN( hr );
}



// #define SELF_TEST        // define if you want self-test
// #define HIGH_RESOLUTION  // define if 63 bits resolution desired

// If your system doesn't have a rotate function for 32 bits integers,
// then define it thus:
// uint32 _lrotr (uint32 x, int r) {
//   return (x >> r) | (x << (sizeof(x)-r));}

// define parameters
#define KK 17
#define JJ 10
#define R1 13
#define R2  5

typedef unsigned long uint32;       // use 32 bit unsigned integers
#ifdef HIGH_RESOLUTION
typedef long double trfloat;        // define floating point precision
#else
typedef double trfloat;             // define floating point precision
#endif

class TRanrotGenerator {            // encapsulate random number generator
  public:
  void RandomInit(uint32 seed);     // initialization
  void SetInterval(int min, int max); // set interval for iRandom
  int iRandom();                    // get integer random number
  trfloat Random();                 // get floating point random number
  TRanrotGenerator(uint32 seed=-1); // constructor
  protected:
  void step();                      // generate next random number
  union {                           // used for conversion to float
    trfloat randp1;
    uint32 randbits[3];};
  int p1, p2;                       // indexes into buffer
  int imin, iinterval;              // interval for iRandom
  uint32 randbuffer[KK][2];         // history buffer
#ifdef SELF_TEST
  uint32 randbufcopy[KK*2][2];      // used for self-test
#endif
};


TRanrotGenerator::TRanrotGenerator(uint32 seed) {
  // constructor
  RandomInit(seed);  SetInterval(0, 0xfffffff);}


void TRanrotGenerator::SetInterval(int min, int max) {
  // set interval for iRandom
  imin = min; iinterval = max - min + 1;}


void TRanrotGenerator::step() {
  // generate next random number
  uint32 a, b;
  // generate next number
  b = _lrotr(randbuffer[p1][0], R1) + randbuffer[p2][0];
  a = _lrotr(randbuffer[p1][1], R2) + randbuffer[p2][1];
  randbuffer[p1][0] = a; randbuffer[p1][1] = b;
  // rotate list pointers
  if (--p1 < 0) p1 = KK - 1;
  if (--p2 < 0) p2 = KK - 1;
#ifdef SELF_TEST
  // perform self-test
  if (randbuffer[p1][0] == randbufcopy[0][0] &&
    memcmp(randbuffer, randbufcopy[KK-p1], 2*KK*sizeof(uint32)) == 0) {
      // self-test failed
      if ((p2 + KK - p1) % KK != JJ) {
        // note: the way of printing error messages depends on system
        printf("Random number generator not initialized");}
      else {
        printf("Random number generator returned to initial state");}
      abort();}
#endif
  // convert to float
  randbits[0] = a;
#ifdef HIGH_RESOLUTION
  randbits[1] = b | 0x80000000;                // 80 bits floats = 63 bits resolution
#else
  randbits[1] = (b & 0x000FFFFF) | 0x3FF00000; // 64 bits floats = 52 bits resolution
#endif
  }


trfloat TRanrotGenerator::Random() {
  // returns a random number between 0 and 1.
  trfloat r = randp1 - 1.;
  step();
  return r;}


int TRanrotGenerator::iRandom() {
  // get integer random number
  int i = iinterval * Random();
  if (i >= iinterval) i = iinterval;
  return imin + i;}


void TRanrotGenerator::RandomInit (uint32 seed) {
  // this function initializes the random number generator.
  int i, j;
  // make sure seed != 0
  if (seed==0) seed = 0x7fffffff;

  // make random numbers and put them into the buffer
  for (i=0; i<KK; i++) {
    for (j=0; j<2; j++) {
      seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5;
      randbuffer[i][j] = seed;}}
  // set exponent of randp1
  randp1 = 1.5;
#ifdef HIGH_RESOLUTION
  assert((randbits[2]&0xFFFF)==0x3FFF); // check that Intel 10-byte float format used
#else
  Assert(randbits[1]==0x3FF80000); // check that IEEE double precision float format used
#endif
  Assert(sizeof(uint32)==4);  // check that 32 bits integers used

  // initialize pointers to circular buffer
  p1 = 0;  p2 = JJ;
#ifdef SELF_TEST
  memcpy (randbufcopy, randbuffer, 2*KK*sizeof(uint32));
  memcpy (randbufcopy[KK], randbuffer, 2*KK*sizeof(uint32));
#endif
  // randomize some more
  for (i=0; i<97; i++) step();
}

static TRanrotGenerator r;

HRESULT
CPadDoc::Random ( long range, long * plRet )
{
    *plRet = range > 0 ? r.iRandom() % range : 0;

    return S_OK;
}

HRESULT
CPadDoc::RandomSeed ( long seed )
{
    r.RandomInit( seed );

    return S_OK;
}

void
GetHeapTotals(LONG * pcHeapBlocks, LONG * pcHeapBytes)
{
    HANDLE rgHeaps[256];
    DWORD dwHeap, dwHeaps;
    PROCESS_HEAP_ENTRY he;
    LONG cBlocks = 0, cBytes = 0;

    dwHeaps = GetProcessHeaps(ARRAY_SIZE(rgHeaps), rgHeaps);

    for (dwHeap = 0; dwHeap < dwHeaps; ++dwHeap)
    {
        HeapLock(rgHeaps[dwHeap]);

        memset(&he, 0, sizeof(PROCESS_HEAP_ENTRY));

        while (HeapWalk(rgHeaps[dwHeap], &he))
        {
            if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY)
            {
                cBlocks += 1;
                cBytes += he.cbData;
            }
        }

        HeapUnlock(rgHeaps[dwHeap]);
    }

    *pcHeapBlocks = cBlocks;
    *pcHeapBytes = cBytes;
}

HRESULT
CPadDoc::GetHeapCounter(long iCounter, long * plRet)
{
    static long g_cHeapBlocks = 0;
    static long g_cHeapBytes  = 0;

    *plRet = 0;

    if (iCounter == 0)
    {
        GetHeapTotals(&g_cHeapBlocks, &g_cHeapBytes);
    }

    if (iCounter == 0)
        *plRet = g_cHeapBytes;
    else if (iCounter == 1)
        *plRet = g_cHeapBlocks;
    else
        *plRet = 0;

    return S_OK;
}

HRESULT
CPadDoc::CreateProcess(BSTR bstrCommandLine, VARIANT_BOOL fWait, VARIANT_BOOL fCaptureOutput, DWORD *pdwExitCode)
{
    char achCommandLine[2048];
    int cch, ret;
    DWORD err;
    PROCESS_INFORMATION pi;
    STARTUPINFOA si = { 0 };

    if (pdwExitCode)
        *pdwExitCode = 0;

    // convert strings to ANSI to be usable on Win95
    cch = WideCharToMultiByte(CP_ACP, 0, bstrCommandLine, _tcslen(bstrCommandLine), achCommandLine, 2048, NULL, NULL);
    if (!cch)
        return E_FAIL;
    achCommandLine[cch] = '\0';

    si.cb = sizeof(STARTUPINFOA);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;

    if (fCaptureOutput)
    {
        // TODO alexmog: this doesn't work. What am I doing wrong?
        AssertSz(0, "fCaptureOutput is not implemented");
        si.dwFlags |= STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    }

    ret = CreateProcessA(NULL, achCommandLine, NULL, NULL, fCaptureOutput, 0, NULL, NULL, &si, &pi);
    if (!ret)
    {
        err = GetLastError();
        return E_FAIL;
    }

    CloseHandle(pi.hThread);

    if (fWait)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(pi.hProcess, INFINITE)
            && pdwExitCode)
        {
            GetExitCodeProcess(pi.hProcess, pdwExitCode);
        }
        else
            AssertSz(0, "Wait for process failed");
    }

    CloseHandle(pi.hProcess);

    return S_OK;
}

HRESULT
CPadDoc::GetCurrentProcessId(long * plRetVal)
{
    *plRetVal = ::GetCurrentProcessId();
    return S_OK;
}

HRESULT
CPadDoc::GetMarkupServices(IMarkupServices **ppMarkupServices)
{
    HRESULT     hr;
    IDispatch   *pdispDoc = NULL;

    if (!ppMarkupServices)
        return E_INVALIDARG;

    *ppMarkupServices = NULL;

    IFC( get_Document(&pdispDoc) );
    IFC( pdispDoc->QueryInterface(IID_IMarkupServices, (LPVOID *)ppMarkupServices) );

Cleanup:
    ReleaseInterface(pdispDoc);
    RRETURN(hr);
}

HRESULT
CPadDoc::InnerHTML(IDispatch *pdispElement, BSTR *pbstrHTML)
{
    HRESULT             hr;
    IMarkupServices     *pMarkupServices = NULL;
    IHTMLElement        *pElement = NULL;

    if (!pbstrHTML || !pdispElement)
        return E_INVALIDARG;

    *pbstrHTML = NULL;

    IFC( GetMarkupServices(&pMarkupServices) );
    IFC( pdispElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );

    IFC( InnerHTML(pMarkupServices, pElement, pbstrHTML) );

Cleanup:
    ReleaseInterface(pMarkupServices);
    ReleaseInterface(pElement);

    RRETURN(hr);
}

HRESULT
CPadDoc::CurrentBlockElement(IDispatch **ppdispElement)
{
    HRESULT             hr;
    IHTMLElement        *pElement = NULL;
    IMarkupServices     *pMarkupServices = NULL;

    if (!ppdispElement)
        return E_INVALIDARG;

    *ppdispElement = NULL;

    IFC( GetMarkupServices(&pMarkupServices) );
    IFC( CurrentBlockElement(pMarkupServices, &pElement) );
    IFC( pElement->QueryInterface(IID_IDispatch, (LPVOID *)ppdispElement) );

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pMarkupServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::DoPerfEnable(BOOL fEnable)
{
    PerfEnable( fEnable );
    return S_OK;
}

HRESULT
CPadDoc::DoPerfLog(BSTR bstrLog)
{
    DWORD  cchLen = SysStringLen(bstrLog);
    char * pchBuf = new char[cchLen+3];

    WideCharToMultiByte(CP_ACP, 0, bstrLog, cchLen, pchBuf, cchLen+1, NULL, NULL);
    pchBuf[cchLen] = '\0';

    PerfLog(tagPerfScript, NULL, pchBuf);

    delete pchBuf;

    return S_OK;
}

HRESULT
CPadDoc::DoPerfDump()
{
    PerfDump();
    return S_OK;
}

HRESULT
CPadDoc::DoPerfClear()
{
    PerfClear();
    return S_OK;
}

static LONGLONG g_lStartCounter0, g_lStartCounter1, g_lStartTime;
static LONGLONG g_lStopCounter0, g_lStopCounter1, g_lStopTime;

#define RDTSC _asm _emit 0fh _asm _emit 31h
#define RDPMC _asm _emit 0fh _asm _emit 33h

HRESULT
CPadDoc::BeginPCounters()
{
#if (defined(_X86_))
    _asm mov ecx, 0
    RDPMC
    _asm mov dword ptr [g_lStartCounter0], eax
    _asm mov dword ptr [g_lStartCounter0+4], edx
    _asm mov ecx, 1
    RDPMC
    _asm mov dword ptr [g_lStartCounter1], eax
    _asm mov dword ptr [g_lStartCounter1+4], edx
    RDTSC
    _asm mov dword ptr [g_lStartTime], eax
    _asm mov dword ptr [g_lStartTime+4], edx
#endif

    return S_OK;
}

HRESULT
CPadDoc::EndPCounters()
{
#if (defined(_X86_))
    RDTSC
    _asm mov dword ptr [g_lStopTime], eax
    _asm mov dword ptr [g_lStopTime+4], edx
    _asm mov ecx, 1
    RDPMC
    _asm mov dword ptr [g_lStopCounter1], eax
    _asm mov dword ptr [g_lStopCounter1+4], edx
    _asm mov ecx, 0
    RDPMC
    _asm mov dword ptr [g_lStopCounter0], eax
    _asm mov dword ptr [g_lStopCounter0+4], edx
#endif

    return S_OK;
}

HRESULT
CPadDoc::GetPCounter( long lWhich, DWORD * plCounter )
{
    if (lWhich == 0)
    {
        *plCounter = (long)(g_lStopCounter0 - g_lStartCounter0);
    }
    else
    {
        *plCounter = (long)(g_lStopCounter1 - g_lStartCounter1);
    }

    return S_OK;
}

HRESULT
CPadDoc::GetPTime( DWORD * plTime )
{
    *plTime = (long)(g_lStopTime - g_lStartTime);

    return S_OK;
}

HRESULT
CPadDoc::GetPCounterString(VARIANT * pValue)
{
    TCHAR ach[256], *pch = ach;

    ach[0] = 0;
    pValue->vt = VT_BSTR;
    pValue->bstrVal = NULL;

#if defined(_X86_)
    if (g_apchCtrShort[0])
    {
        wsprintfW( pch, L"%S=%ld ", g_apchCtrShort[0], (long)(g_lStopCounter0 - g_lStartCounter0) );
        pch += lstrlenW(pch);
    }
    if (g_apchCtrShort[1])
    {
        wsprintfW( pch, L"%S=%ld ", g_apchCtrShort[1], (long)(g_lStopCounter1 - g_lStartCounter1) );
        pch += lstrlenW(pch);
    }

    wsprintfW( pch, L"cycles=%ld ", (long)(g_lStopTime - g_lStartTime) );

    pValue->bstrVal = SysAllocString(ach);
#endif //defined(_X86_)
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::Repaint, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::Repaint()
{
    HRESULT     hr = S_OK;
    HWND        hwndToUse = NULL;

    if(_pInPlaceActiveObject)
    {
        hr = _pInPlaceActiveObject->GetWindow(&hwndToUse);
        if(FAILED(hr))
            goto Cleanup;
    }

    if(!hwndToUse && _pInPlaceObject)
    {
        hr = _pInPlaceObject->GetWindow(&hwndToUse);
        if(FAILED(hr))
            goto Cleanup;
    }

    if(!hwndToUse)
    {
        // Use the host window
        hwndToUse = _hwnd;
    }

    ::RedrawWindow(hwndToUse, NULL, NULL, RDW_INVALIDATE|RDW_ALLCHILDREN|RDW_UPDATENOW);

Cleanup:
    return hr;
}



//---------------------------------------------------------------------------
//
//  Member: CPadDoc::alert, IPad
//
//---------------------------------------------------------------------------
HRESULT
CPadDoc::alert(BSTR bstrLine)
{
    if(!::MessageBox(_hwnd, bstrLine, L"Mshtmpad Message", MB_OK))
        return E_FAIL;
    return S_OK;
}

HRESULT
CPadDoc::IsDebugPad(VARIANT_BOOL *pfDebugPad)
{
    if (!pfDebugPad)
        return E_INVALIDARG;

#if DBG==1
    *pfDebugPad = VARIANT_BOOL_FROM_BOOL(TRUE);
#else
    *pfDebugPad = VARIANT_BOOL_FROM_BOOL(FALSE);
#endif

    return S_OK;
}

HRESULT
CPadDoc::EnableUIUpdate(VARIANT_BOOL vbEnable )
{
    _fUpdateUI = (vbEnable == VB_TRUE);

    RRETURN( S_OK );
}

HRESULT
CPadDoc::GetPrimaryElement( int* piPrimaryElement )
{
    HRESULT hr;
    ISelectionServices          *pSelSvc = NULL;
    IHTMLEditServices           *pIEdServ = NULL;
    IDispatch                   *pDocDisp = NULL;
    IHTMLDocument               *pDoc = NULL;
    IServiceProvider            *pSP = NULL;
    ISegmentList                *pSegmentList = NULL;
    ISegmentListIterator        *pIter = NULL;
    ISegment                    *pSegment = NULL;
    IElementSegment             *pElementSegment = NULL;
    int iPrimary = -1;
    int iIndex = 1;
    BOOL fPrimary;
    SELECTION_TYPE              eType = SELECTION_TYPE_None;
    // Get the selection services
    IFC( get_Document(&pDocDisp) );
    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
    IFC( pDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) );

    IFC( pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)& pIEdServ) );
    IFC( pIEdServ->GetSelectionServices(NULL, &pSelSvc) );
    IFC( pSelSvc->QueryInterface(IID_ISegmentList, (LPVOID *)&pSegmentList ) );

    IFC( pSegmentList->GetType(&eType) );
    if ( eType == SELECTION_TYPE_Control )
    {
        IFC( pSegmentList->CreateIterator( & pIter ));

        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pSegment) );

            IFC( pSegment->QueryInterface( IID_IElementSegment, (void**) & pElementSegment ));
            IFC( pElementSegment->IsPrimary( & fPrimary ));
            if ( fPrimary )
            {
                iPrimary = iIndex;
                break;
            }

            ClearInterface( &pSegment );
            ClearInterface( &pElementSegment);

            IFC( pIter->Advance() );
            iIndex++;
        }

        *piPrimaryElement = iPrimary;
    }
    else
        *piPrimaryElement = -1;

Cleanup:
    ReleaseInterface( pIEdServ );
    ReleaseInterface( pDocDisp );
    ReleaseInterface( pDoc );
    ReleaseInterface( pSP );
    ReleaseInterface( pSelSvc );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );
    ReleaseInterface( pElementSegment );

    RRETURN( hr );
}

HRESULT CPadDoc::LinesInElement(IDispatch *pDispElement, int *piLines)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    IHTMLElement *pIElement = NULL;
    HRESULT hr = S_OK;

    if (!pDispElement)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pDispElement->QueryInterface(IID_IHTMLElement, (void **)&pIElement));
    IFC(pEditDebugServices->LinesInElement(pIElement, (long*)piLines));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    ReleaseInterface(pIElement);
    RRETURN(hr);
}

HRESULT CPadDoc::FontsOnLine(IDispatch *pDispElement, int iLine, BSTR *pbstrFonts)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    IHTMLElement *pIElement = NULL;
    HRESULT hr = S_OK;

    if (!pDispElement)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pDispElement->QueryInterface(IID_IHTMLElement, (void **)&pIElement));
    IFC(pEditDebugServices->FontsOnLine(pIElement, iLine, pbstrFonts));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    ReleaseInterface(pIElement);
    RRETURN(hr);
}

HRESULT CPadDoc::GetPixel(int X, int Y, int *piColor)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = S_OK;

    IFC(get_Document(&pHTMLDoc));
    if (!pHTMLDoc)
        goto Cleanup;
    IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
    IFC(pEditDebugServices->GetPixel(X, Y, (long*)piColor));

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsDebugTrident(VARIANT_BOOL *pfDebugTrident)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fIsDebugTrident = FALSE;

    if (!pfDebugTrident)
        goto Cleanup;
    IFC(get_Document(&pHTMLDoc));
    if (   pHTMLDoc
        && S_OK == pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices)
        && pEditDebugServices != NULL
       )
    {
        fIsDebugTrident = TRUE;
    }

    *pfDebugTrident = VARIANT_BOOL_FROM_BOOL(fIsDebugTrident);
    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsWin2k(VARIANT_BOOL *pfWin2k)
{
    if (!pfWin2k)
        return E_INVALIDARG;

    *pfWin2k = (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000);

    return S_OK;
}

HRESULT
CPadDoc::IsWhistler(VARIANT_BOOL *pfWhistler)
{
    if (!pfWhistler)
        return E_INVALIDARG;

    *pfWhistler = (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050001);

    return S_OK;
}

HRESULT
CPadDoc::ComputerName(BSTR *pbstrComputerName)
{
    HRESULT hr = E_INVALIDARG;

    if (!pbstrComputerName)
        return hr;

    DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    if (GetComputerName(achComputerName, &dwComputerName))
    {
        CStr strComputerName;
        strComputerName.Set(achComputerName);
        hr = THR(strComputerName.AllocBSTR(pbstrComputerName));
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

#include <buildid.hxx>
HRESULT
CPadDoc::get_BuildId(BSTR *pbstrBuildId)
{
    TCHAR * pch = _T(SZ_BUILDID);

    *pbstrBuildId = SysAllocString(pch);

    RRETURN(*pbstrBuildId ? S_OK : E_OUTOFMEMORY);
}

//----------------------------------------------------------------------------
//  Function:   GetUnsecureWindow
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::GetUnsecureWindow(IDispatch * pWindowIn, IDispatch **ppWndDisp)
{
    HRESULT hr;
    IHTMLWindow2 *      pHW2 = NULL;
    IHTMLDocument2 *    pDoc = NULL;
    IServiceProvider *  pSP1 = NULL, * pSP2 = NULL;
    IAccessible *       pAcc = NULL;
    IHTMLWindow2 *      pUnsecureWindow = NULL;

    // get the IHTMLWindow2 of the pWindowIn
    hr = pWindowIn->QueryInterface(IID_IHTMLWindow2, (void **)&pHW2);
    if (hr)
        goto Cleanup;

    // get the IDispatch of the Document
    hr = pHW2->get_document(&pDoc);
    if (hr)
        goto Cleanup;

    // get the service provider from the document object
    hr = pDoc->QueryInterface(IID_IServiceProvider, (void **)&pSP1);
    if (hr)
        goto Cleanup;

    // get the accessible window object from the document
    hr = pSP1->QueryService( IID_IAccessible, IID_IAccessible, (void **)&pAcc);
    if (hr)
        goto Cleanup;

    // make a service QS call on the accessible window object for its inner window
    hr = pAcc->QueryInterface( IID_IServiceProvider, (void **)&pSP2);
    if (hr)
        goto Cleanup;

    hr = pSP2->QueryService( IID_IHTMLWindow2, IID_IHTMLWindow2, (void **)&pUnsecureWindow);
    if (hr)
        goto Cleanup;

    hr = pUnsecureWindow->QueryInterface(IID_IDispatch, (void **)ppWndDisp);

Cleanup:
    ReleaseInterface(pHW2);
    ReleaseInterface(pDoc);
    ReleaseInterface(pSP1);
    ReleaseInterface(pSP2);
    ReleaseInterface(pAcc);
    ReleaseInterface(pUnsecureWindow);

    RRETURN(hr);
}

HRESULT
CPadDoc::IsUsingBckgrnRecalc(VARIANT_BOOL *pfUsingBckgrnRecalc)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fUsingBckgrnRecalc;

    if (!pfUsingBckgrnRecalc)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsUsingBckgrnRecalc(&fUsingBckgrnRecalc));
        *pfUsingBckgrnRecalc = VARIANT_BOOL_FROM_BOOL(fUsingBckgrnRecalc);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsUsingTableIncRecalc(VARIANT_BOOL *pfUsingTableIncRecalc)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fUsingTableIncRecalc;

    if (!pfUsingTableIncRecalc)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsUsingTableIncRecalc(&fUsingTableIncRecalc));
        *pfUsingTableIncRecalc = VARIANT_BOOL_FROM_BOOL(fUsingTableIncRecalc);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::IsEncodingAutoSelect(VARIANT_BOOL *pfEncodingAutoSelect)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;
    BOOL fEncodingAutoSelect;

    if (!pfEncodingAutoSelect)
        goto Cleanup;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->IsEncodingAutoSelect(&fEncodingAutoSelect));
        *pfEncodingAutoSelect = VARIANT_BOOL_FROM_BOOL(fEncodingAutoSelect);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::EnableEncodingAutoSelect(VARIANT_BOOL fEnable)
{
    IDispatch *pHTMLDoc = NULL;
    IEditDebugServices *pEditDebugServices = NULL;
    HRESULT hr = E_INVALIDARG;

    IFC(get_Document(&pHTMLDoc));
    if (pHTMLDoc)
    {
        IFC(pHTMLDoc->QueryInterface(IID_IEditDebugServices, (void **)&pEditDebugServices));
        IFC(pEditDebugServices->EnableEncodingAutoSelect(fEnable));
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pHTMLDoc);
    ReleaseInterface(pEditDebugServices);
    RRETURN(hr);
}

HRESULT
CPadDoc::GetPadEnumPrivacyRecords(IDispatch** ppPadEnumPrivacyRecords )
{
    HWND                     hwnd        = NULL;
    HRESULT                  hr          = S_OK;
    IDispatch              * pHTMLDoc    = NULL;
    IServiceProvider       * pServProv   = NULL;
    IEnumPrivacyRecords    * pIEnumPri   = NULL;
    CPadEnumPrivacyRecords * pPadEnumPri = NULL;

    if ( !ppPadEnumPrivacyRecords )
        return E_POINTER;

    *ppPadEnumPrivacyRecords = NULL;

    // get the document
    hr = get_Document( &pHTMLDoc );
    if ( hr || !pHTMLDoc )
        goto Cleanup;

    // get the service provider interface
    hr = pHTMLDoc->QueryInterface( IID_IServiceProvider, (void **)&pServProv);
    if ( hr || !pServProv )
        goto Cleanup;


    // get the IEnumPrivacyRecords interface
    hr = pServProv->QueryService( IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, (void **)&pIEnumPri);
    if ( hr || !ppPadEnumPrivacyRecords )
        goto Cleanup;

    pPadEnumPri = new CPadEnumPrivacyRecords(pIEnumPri);
    if (!pPadEnumPri)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    *ppPadEnumPrivacyRecords = (IDispatch*)pPadEnumPri;

Cleanup:
    if ( pHTMLDoc )
        pHTMLDoc->Release();

    if ( pServProv )
        pServProv->Release();

    if (pIEnumPri)
        pIEnumPri->Release();

    return hr;
}

HRESULT
CPadDoc::PadCommand(WORD widm)
{
    return OnCommand(0, widm, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\p6cnt.cxx ===
//------------------------------------------------------------------------
//
//  Microsoft MSHTML
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       p6cnt.cxx
//
//  Contents:   Pentium 6+ counter management (copied from NT's pdump.c)
//
//-------------------------------------------------------------------------

#if defined(_X86_)

// This is just a big hack. We can't include padhead.hxx first so it doesn't get first crack
// at doing this stuff.  When I finally change this over to use the new icecap driver instead
// of pstat.sys this should all go away since I won't need the internal nt headers.
// Look in src\core\include\always.h for more details.
// -- JBeda

#define _strdup CRT__strdup_DontUse
#define _wcsdup CRT__wcsdup_DontUse
#define strdup  CRT_strdup_DontUse
#define malloc  CRT_malloc_DontUse
#define realloc CRT_realloc_DontUse
#define calloc  CRT_calloc_DontUse
#define free    CRT_free_DontUse
#define _wcsicmp CRT__wcsicmp
#define isdigit     CRT_isdigit
#define isalpha     CRT_isalpha
#define isspace     CRT_isspace
#define iswspace    CRT_iswspace


#ifndef X_NT_H_
#define X_NT_H_
#include <nt.h>
#endif

#ifndef X_NTRTL_H_
#define X_NTRTL_H_
#include <ntrtl.h>
#endif

#ifndef X_NTURTL_H_
#define X_NTURTL_H_
#include <nturtl.h>
#endif

#undef _strdup
#undef _wcsdup
#undef strdup
#undef _wcsicmp
#undef malloc
#undef realloc
#undef calloc
#undef free
#undef isdigit
#undef isalpha
#undef isspace
#undef iswspace

#undef ASSERT

#include "padhead.hxx"

#ifndef X_PSTAT_H_
#define X_PSTAT_H_
#include "pstat.h"
#endif

static DYNLIB g_dynlibNTDLL = { NULL, NULL, "ntdll.dll" };
static DYNPROC g_dynprocNtQuerySystemInformation = { NULL, &g_dynlibNTDLL, "NtQuerySystemInformation" };
static DYNPROC g_dynprocRtlInitUnicodeString = { NULL, &g_dynlibNTDLL, "RtlInitUnicodeString" };
static DYNPROC g_dynprocNtOpenFile = { NULL, &g_dynlibNTDLL, "NtOpenFile" };
static DYNPROC g_dynprocNtDeviceIoControlFile = { NULL, &g_dynlibNTDLL, "NtDeviceIoControlFile" };
static DYNPROC g_dynprocNtClose = { NULL, &g_dynlibNTDLL, "NtClose" };

typedef NTSTATUS (NTAPI *PFN_NTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
typedef VOID (NTAPI *PFN_RTLINITUNICODESTRING)(PUNICODE_STRING, PCWSTR);
typedef NTSTATUS (NTAPI *PFN_NTOPENFILE)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);
typedef NTSTATUS (NTAPI *PFN_NTDEVICEIOCONTROLFILE)(HANDLE FileHandle, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
typedef NTSTATUS (NTAPI *PFN_NTCLOSE)(HANDLE);

static BOOL g_fNTDLLInitDone = FALSE;
static BOOL g_fNTDLLInitSuccess = FALSE;

static BOOL EnsureInitNTDLL()
{
    LOCK_GLOBALS;

    if (g_fNTDLLInitDone)
        return g_fNTDLLInitSuccess;

    if (    LoadProcedure(&g_dynprocNtQuerySystemInformation) != S_OK
        ||  LoadProcedure(&g_dynprocRtlInitUnicodeString) != S_OK
        ||  LoadProcedure(&g_dynprocNtOpenFile) != S_OK
        ||  LoadProcedure(&g_dynprocNtDeviceIoControlFile) != S_OK
        ||  LoadProcedure(&g_dynprocNtClose) != S_OK)
    {
        g_fNTDLLInitSuccess = FALSE;
    }
    else
    {
        g_fNTDLLInitSuccess = TRUE;
    }

    g_fNTDLLInitDone = TRUE;

    return g_fNTDLLInitSuccess;
}

HRESULT       
InitP6Counters()
{
    HRESULT hr = S_OK;
    Assert( !g_hPStat );

    if (!EnsureInitNTDLL())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( InitPStatDriver() );
    if (hr)
        goto Cleanup;

    hr = THR( SetP6Counters() );
    if (hr)
        goto Cleanup;
    
Cleanup:

    IGNORE_HR( ClosePStatDriver() );

    return hr;
}

HRESULT          
InitPStatDriver()
{
    UCHAR                       NumberOfProcessors;
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    ((PFN_NTQUERYSYSTEMINFORMATION)g_dynprocNtQuerySystemInformation.pfn)(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return E_FAIL;
    }

    //
    // Open PStat driver
    //

    ((PFN_RTLINITUNICODESTRING)g_dynprocRtlInitUnicodeString.pfn)(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = ((PFN_NTOPENFILE)g_dynprocNtOpenFile.pfn) (
            &g_hPStat,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (NT_SUCCESS(status))
    {
        return S_OK;
    }
    else
    {
        g_hPStat = NULL;
        return E_FAIL;
    }
}

HRESULT          
SetP6Counters()
{
    IO_STATUS_BLOCK             IOSB;
    Assert(MAX_EVENTS == 2);

    SETEVENT  aSetEvent[MAX_EVENTS];
    char chModes[2];

    aSetEvent[0].EventId = GetPrivateProfileIntA("P6Ctr", "Ctr0", 0xFF, "mshtmdbg.ini");
    aSetEvent[0].AppReserved = 0;
    aSetEvent[0].Active = aSetEvent[0].EventId != 0xFF;
    GetPrivateProfileStringA("P6Ctr", "Ctr0Modes", "*", chModes, 2, "mshtmdbg.ini");
    aSetEvent[0].UserMode = chModes[0] == '*' || chModes[0] == '3';
    aSetEvent[0].KernelMode = chModes[0] == '*' || chModes[0] == '0';
    aSetEvent[0].EdgeDetect = FALSE;

    aSetEvent[1].EventId = GetPrivateProfileIntA("P6Ctr", "Ctr1", 0xFF, "mshtmdbg.ini");
    aSetEvent[1].AppReserved = 0;
    aSetEvent[1].Active = aSetEvent[1].EventId != 0xFF;
    GetPrivateProfileStringA("P6Ctr", "Ctr1Modes", "*", chModes, 2, "mshtmdbg.ini");
    aSetEvent[1].UserMode = chModes[0] == '*' || chModes[0] == '3';
    aSetEvent[1].KernelMode = chModes[0] == '*' || chModes[0] == '0';
    aSetEvent[1].EdgeDetect = FALSE;

    {
        char                buffer[400];
        ULONG               i, Count;
        NTSTATUS            status;
        PEVENTID            Event;

        Event = (PEVENTID) buffer;
        Count = 0;
        do {
            *((PULONG) buffer) = Count;
            Count += 1;

            status = ((PFN_NTDEVICEIOCONTROLFILE)g_dynprocNtDeviceIoControlFile.pfn)(
                        g_hPStat,
                        (HANDLE) NULL,          // event
                        (PIO_APC_ROUTINE) NULL,
                        (PVOID) NULL,
                        &IOSB,
                        PSTAT_QUERY_EVENTS,
                        buffer,                 // input buffer
                        sizeof (buffer),
                        NULL,                   // output buffer
                        0
                        );

            if (NT_SUCCESS(status))
            {
                for (i=0; i < MAX_EVENTS; i++)
                {
                    if (aSetEvent[i].Active && aSetEvent[i].EventId == Event->EventId)
                    {
                        ULONG nLen;

                        nLen = lstrlenA((char*)(Event->Buffer));
                        Assert(g_apchCtrShort[i] == NULL);
                        g_apchCtrShort[i] = new char[nLen+1];
                        lstrcpyA(g_apchCtrShort[i], (char*)(Event->Buffer));

                        nLen = lstrlenA((char*)(Event->Buffer + Event->DescriptionOffset));
                        Assert(g_apchCtrLong[i] == NULL);
                        g_apchCtrLong[i] = new char[nLen+1];
                        lstrcpyA(g_apchCtrLong[i], (char*)(Event->Buffer + Event->DescriptionOffset));

                        g_achCtrModes[i] = aSetEvent[i].UserMode 
                                            ? (aSetEvent[i].KernelMode ? '*' : '3') 
                                            : (aSetEvent[i].KernelMode ? '0' : '-');
                    }
                }
            }
        } while (NT_SUCCESS(status));

        for (i=0; i < MAX_EVENTS; i++)
            if (g_apchCtrShort[i] == NULL)
                aSetEvent[i].Active = FALSE;
    }

    


    ((PFN_NTDEVICEIOCONTROLFILE)g_dynprocNtDeviceIoControlFile.pfn)(
        g_hPStat,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        aSetEvent,           // input buffer
        sizeof(SETEVENT)*MAX_EVENTS,
        NULL,                   // output buffer
        0
    );

    return S_OK;
}

HRESULT          
ClosePStatDriver()
{
    if (g_hPStat)
    {
        ((PFN_NTCLOSE)g_dynprocNtClose.pfn) (g_hPStat);
    }

    return S_OK;
}

#endif //defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padbox.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padbox.cxx
//
//  Contents:   Implements control palette.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

static BOOL s_fWndClassRegistered = FALSE;

static void CheckButton(int ici);

static const CLSID CLSID_SuperLabel = {0x67EEB7C3L,0x6242,0x11CF,0xA0,0xC0,0x00,0xAA,0x00,0x62,0xBE,0x57};

static const struct CLASSINFO
{
    const CLSID *   pclsid;
    int             idr;
}
s_aci[] =
{
    { &CLSID_NULL, IDR_SELECT_TOOL },
    { &CLSID_HTMLImg, IDR_IMAGE_TOOL },
    { &CLSID_HTMLInputElement, IDR_BUTTON_TOOL },
    { &CLSID_HTMLInputElement, IDR_TEXTBOX_TOOL },
    { &CLSID_HTMLListElement, IDR_LISTBOX_TOOL },
    { &CLSID_HTMLInputElement, IDR_CHECKBOX_TOOL },
    { &CLSID_HTMLInputElement, IDR_RADIOBUTTON_TOOL },
    { &CLSID_HTMLDivPosition, IDR_TEXTSITE_TOOL },
};

//+------------------------------------------------------------------------
//
//  Class:   CControlPaletteService
//
//-------------------------------------------------------------------------

class CControlPaletteService : public IControlPalette
{
public:
    CControlPaletteService();
    ~CControlPaletteService();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IControlPalette methods

    STDMETHOD(SetCursor)();
    STDMETHOD(GetData)(IDataObject **ppDO);
    STDMETHOD(DataUsed)();

    // Data members

    ULONG   _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Class:   CControlPaletteData
//
//-------------------------------------------------------------------------

class CControlPaletteData : public IDataObject, public IDropSource
{
public:
    CControlPaletteData(const CLSID *pclsid);
    ~CControlPaletteData();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IDataObject methods

    STDMETHOD(GetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium);
    STDMETHOD(GetDataHere)(FORMATETC * pformatetc, STGMEDIUM * pmedium);
    STDMETHOD(QueryGetData)(FORMATETC * pfe);
    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC * pformatetc, FORMATETC * pformatetcOut);
    STDMETHOD(SetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, IEnumFORMATETC ** ppenum);
    STDMETHOD(DAdvise)(FORMATETC * pformatetc, DWORD advf, IAdviseSink * pAdvSink, DWORD * pdwConnection);
    STDMETHOD(DUnadvise)(DWORD dwConnection);
    STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** ppenumAdvise);

    // IDropSource methods

    STDMETHOD(QueryContinueDrag)(BOOL fEscPressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

    // Data members

    ULONG _ulRefs;
    CLSID _clsid;
};

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::CControlPaletteService
//
//-------------------------------------------------------------------------

CControlPaletteService::CControlPaletteService()
{
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::~CControlPaletteService
//
//-------------------------------------------------------------------------

CControlPaletteService::~CControlPaletteService( )
{
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IControlPalette)
    {
        *ppv = (IControlPalette *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::AddRef, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteService::AddRef()
{
    return _ulRefs += 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::Release, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteService::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::SetCursor, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::SetCursor()
{
    if (s_iciChecked == 0)
    {
        return S_FALSE;
    }
    else
    {
        ::SetCursor(LoadCursor(NULL, IDC_CROSS));
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::GetData, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::GetData(IDataObject **ppDO)
{
    CControlPaletteData *pData = NULL;

    if (s_iciChecked == 0)
    {
        *ppDO = NULL;
        return S_FALSE;
    }
    else
    {
        *ppDO = new CControlPaletteData(s_aci[s_iciChecked].pclsid);
        RRETURN(*ppDO == NULL ? E_OUTOFMEMORY : S_OK);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteService::DataUsed, IControlPalette
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteService::DataUsed()
{
    CheckButton(0);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::CControlPaletteData
//
//-------------------------------------------------------------------------

CControlPaletteData::CControlPaletteData(const CLSID *pclsid)
{
    _ulRefs = 1;
    _clsid = *pclsid;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::~CControlPaletteData
//
//-------------------------------------------------------------------------

CControlPaletteData::~CControlPaletteData( )
{
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDataObject)
    {
        *ppv = (IDataObject *) this;
    }
    else if (iid == IID_IDropSource)
    {
        *ppv = (IDropSource *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::AddRef, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteData::AddRef()
{
    return _ulRefs += 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::Release, IUnknown
//
//-------------------------------------------------------------------------

ULONG
CControlPaletteData::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryContinueDrag, IDropSource
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryContinueDrag(BOOL fEscPressed, DWORD grfKeyState)
{
    if (fEscPressed)
    {
        return DRAGDROP_S_CANCEL;
    }

    if (!((grfKeyState & MK_LBUTTON) || (grfKeyState & MK_RBUTTON)))
    {
        return DRAGDROP_S_DROP;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryContinueDrag, IDropSource
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GiveFeedback(DWORD dwEffect)
{
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetData(FORMATETC * pfe, STGMEDIUM * pmedium)
{
    HRESULT     hr = S_OK;
    void *      ptr;
#ifdef _MAC
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif

    TCHAR       tszClsid[MAX_PATH] = _T("");

    if (pfe->cfFormat == s_cfCLSID &&
        pfe->dwAspect == DVASPECT_CONTENT &&
        pfe->tymed == TYMED_HGLOBAL)
    {
        hr = THR(Format (
            0, tszClsid, MAX_PATH,
            _T("<0g>"),
            &_clsid));
        if (!OK(hr))
            goto Cleanup;

        *phdl = GlobalAlloc(
            GMEM_SHARE | GMEM_MOVEABLE, 
            (CLSID_STRLEN+1)*sizeof(TCHAR));
        if (*phdl == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

#ifndef _MAC
        ptr = GlobalLock(*phdl);
        memcpy((void *) ptr, tszClsid, (CLSID_STRLEN+1)*sizeof(TCHAR));
        GlobalUnlock(*phdl);
#else
        ptr = GlobalLock(*phdl)
        memcpy(ptr, ptszClsid, (CLSID_STRLEN+1)*sizeof(TCHAR));
        GlobalUnlock(*phdl);
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif
    }
    else
    {
        hr = DV_E_FORMATETC;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetDataHere, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetDataHere(FORMATETC * pformatetc, STGMEDIUM * pmedium)
{
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::QueryGetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::QueryGetData(FORMATETC * pfe)
{
    HRESULT hr;

    if (pfe->cfFormat == s_cfCLSID &&
        pfe->dwAspect == DVASPECT_CONTENT &&
        pfe->tymed == TYMED_HGLOBAL)
    {
        hr = S_OK;
    }
    else
    {
        hr = DV_E_FORMATETC;
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::GetCanonicalFormatEtc, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::GetCanonicalFormatEtc(
        FORMATETC * pformatetc,
        FORMATETC * pformatetcOut)
{
    pformatetcOut = NULL;
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::SetData, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::SetData(
        FORMATETC * pformatetc,
        STGMEDIUM * pmedium,
        BOOL fRelease)
{
    return E_FAIL;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::EnumFormatEtc, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenum)
{
    *ppenum = NULL;
    return E_UNEXPECTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::DAdvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::DAdvise(
        FORMATETC * pformatetc,
        DWORD advf,
        IAdviseSink * pAdvSink,
        DWORD * pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::DUnadvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//+------------------------------------------------------------------------
//
//  Member:     CControlPaletteData::EnumDAdvise, IDataObject
//
//-------------------------------------------------------------------------

HRESULT
CControlPaletteData::EnumDAdvise(IEnumSTATDATA ** ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

static void
CheckButton(int ici)
{
    if (s_hwndBar && ici != s_iciChecked)
    {
        SendMessage(s_hwndBar, TB_CHECKBUTTON, ici, MAKELONG(TRUE, 0));
        s_iciChecked = ici;
    }
}

static LRESULT
FrameOnCommand(WORD wNotifyCode, WORD ici, HWND hwndCtl)
{
    // Get out if it does not look like one of our commands.
    if (hwndCtl != s_hwndBar)
        return 0;

    s_iciChecked = ici;

    return 0;
}

static LRESULT
FrameOnClose()
{
    ShowWindow(s_hwndFrame, SW_HIDE);
    return 0;
}

LRESULT
FrameOnNCHitTest(WPARAM wParam, LPARAM lParam)
{
    LRESULT l;

    l = DefWindowProc(s_hwndFrame, WM_NCHITTEST, wParam, lParam);
    switch (l)
    {
    case HTTOPLEFT:
    case HTBOTTOMLEFT:
    case HTLEFT:
    case HTTOPRIGHT:
    case HTBOTTOMRIGHT:
    case HTRIGHT:
    case HTTOP:
    case HTBOTTOM:
        // Force fixed size window.
        l = HTCAPTION;
        break;
    }

    return l;
}

#if !defined(UNIX)
static LRESULT
FrameOnNotify(int idCtrl, NMHDR *pnmhdr)
{
    TBBUTTON    tbb;
    DWORD       dw;

    if (pnmhdr->hwndFrom == s_hwndBar)
    {
        if (pnmhdr->code == TBN_BEGINDRAG)
        {
            SendMessage(pnmhdr->hwndFrom,
                    TB_GETBUTTON,
                    ((TBNOTIFY *)pnmhdr)->iItem,
                    (LPARAM)&tbb);
            s_iciDrag = tbb.idCommand;
            dw = GetMessagePos();
            s_ptsDrag = MAKEPOINTS(dw);
        }
        else if (pnmhdr->code == TBN_ENDDRAG)
        {
            s_iciDrag = 0;
        }
    }

    return DefWindowProc(s_hwndFrame, WM_NOTIFY, idCtrl, (LPARAM)pnmhdr);
}
#endif

static LRESULT CALLBACK
FrameWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_COMMAND:
        return FrameOnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                              GET_WM_COMMAND_ID(wParam, lParam), 
                              GET_WM_COMMAND_HWND(wParam, lParam));

    case WM_CLOSE:
        return FrameOnClose();

    case WM_NCHITTEST:
        return FrameOnNCHitTest(wParam, lParam);

#if !defined(UNIX)
    case WM_NOTIFY:
        return FrameOnNotify(wParam, (NMHDR *)lParam);
#endif

    default:
        return DefWindowProc(hwnd, wm, wParam, lParam);
    }
}

static LRESULT
BarOnMouseMove(WORD fwKeys, int xPos, int yPos)
{
    POINTS      pts;
    DWORD       dwEffect;
    CControlPaletteData *  pData;
    DWORD       dw;
    POINTS      ptsDrag = s_ptsDrag;

    if (s_iciDrag != 0)
    {
        dw = GetMessagePos();
        pts = MAKEPOINTS(dw);
        if (pts.x < ptsDrag.x - 2 ||
            pts.x > ptsDrag.x + 2 ||
            pts.y < ptsDrag.y - 2 ||
            pts.y > ptsDrag.y + 2)
        {
            Verify(pData = new CControlPaletteData(s_aci[s_iciDrag].pclsid));
            if (pData)
            {
#if DBG==1
                Assert(!TLS(fHandleCaptureChanged));
#endif
                ReleaseCapture();
                CheckButton(s_iciDrag);
                s_iciDrag = 0;
                IGNORE_HR(DoDragDrop(pData, pData, DROPEFFECT_COPY|DROPEFFECT_MOVE, &dwEffect));
                pData->Release();
                CheckButton(0);
            }
        }
    }

    return s_pfnBarWndProc(s_hwndBar, WM_MOUSEMOVE, fwKeys, MAKELONG(xPos, yPos));
}

static LRESULT CALLBACK
BarWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_MOUSEMOVE:
        return BarOnMouseMove(wParam, LOWORD(lParam), HIWORD(lParam));

    default:
        return s_pfnBarWndProc(hwnd, wm, wParam, lParam);
    }
}

static BOOL
InitControlPalette()
{
    WNDCLASS    wc;
    TCHAR       achKey[MAX_PATH];
    TCHAR       achValue[MAX_PATH];
    TCHAR *     pch;
    long        cb;
    int         idr;
    TBADDBITMAP tbab;
    TBBUTTON    tbb;
    int         i, c;
    HINSTANCE   hinst;
    RECT        rc, rcBar;

    s_cfCLSID = RegisterClipboardFormatA("MS Forms CLSID");

    if (!s_fWndClassRegistered)
    {
        LOCK_GLOBALS;

        if (!s_fWndClassRegistered)
        {
            memset(&wc, 0, sizeof(wc));
            wc.style = NULL;
            wc.lpfnWndProc = FrameWndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" CP Frame");

            if (!RegisterClass(&wc))
                return FALSE;
                                  
            if (!GetClassInfo(NULL, TOOLBARCLASSNAME, &wc))
                return FALSE;

            s_pfnBarWndProc = wc.lpfnWndProc;
            wc.lpfnWndProc = BarWndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" CP ToolBar");

            if (!RegisterClass(&wc))
                return FALSE;

            s_fWndClassRegistered = TRUE;
        }
    }

    s_hwndFrame = CreateWindowEx(
            WS_EX_TOOLWINDOW,
            SZ_APPLICATION_NAME TEXT(" CP Frame"),
            TEXT("Controls"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            0, 0,
            s_hwndOwner,
            NULL,
            g_hInstCore,
            NULL);

    if (!s_hwndFrame)
        return FALSE;

    s_hwndBar = CreateWindowEx(
            0,
            SZ_APPLICATION_NAME TEXT(" CP Toolbar"),
            (LPCTSTR) NULL,
            CCS_NODIVIDER |
                TBSTYLE_WRAPABLE |
                WS_CHILD | WS_VISIBLE,
            0, 0, 0, 0,
            s_hwndFrame,
            (HMENU) 0,
            g_hInstCore,
            NULL);
    if (!s_hwndBar)
        return FALSE;

    SendMessage(s_hwndBar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);

    _tcscpy(achKey, TEXT("CLSID\\"));

    c = 0;
    for (i = 0; i < ARRAY_SIZE(s_aci); i++)
    {
        if (s_aci[i].idr)
        {
            tbab.hInst = g_hInstResource;
            tbab.nID   = s_aci[i].idr;
            tbb.iBitmap = SendMessage(s_hwndBar, TB_ADDBITMAP, 1, (WPARAM) &tbab);
            tbb.idCommand = i;
            tbb.fsState = TBSTATE_ENABLED;
            if (i == 0)
            {
                tbb.fsState |= TBSTATE_CHECKED;
            }
            tbb.fsStyle = TBSTYLE_CHECK | TBSTYLE_CHECKGROUP;
            tbb.dwData = 0;
            tbb.iString = 0;
            SendMessage(s_hwndBar, TB_ADDBUTTONS, 1, (LPARAM) &tbb);
        }
        else
        {
            Verify(StringFromGUID2(*s_aci[i].pclsid, &achKey[6], ARRAY_SIZE(achKey) - 6));
            _tcscat(achKey, TEXT("\\ToolboxBitmap32"));

            cb = sizeof(achValue);
            if (RegQueryValue(HKEY_CLASSES_ROOT, achKey, achValue, &cb))
                continue;

            pch = _tcschr(achValue, TEXT(','));
            if (pch)
            {
                *pch++ = TEXT('\0');
                idr = (int)_tcstol(pch, NULL, 10);
            }
            else
            {
                idr = 0;
            }

            hinst = LoadLibraryEx(achValue, NULL, DONT_RESOLVE_DLL_REFERENCES);
            if (!hinst)
                continue;

            tbab.hInst = hinst;
            tbab.nID   = idr;
            tbb.iBitmap = SendMessage(s_hwndBar, TB_ADDBITMAP, 1, (WPARAM) &tbab);
            tbb.idCommand = i;
            tbb.fsState = TBSTATE_ENABLED;
            tbb.fsStyle = TBSTYLE_CHECK | TBSTYLE_CHECKGROUP;
            tbb.dwData = 0;
            tbb.iString = 0;
            SendMessage(s_hwndBar, TB_ADDBUTTONS, 1, (LPARAM) &tbb);

            c += 1;

            FreeLibrary(hinst);
        }
    }

    SendMessage(s_hwndBar, TB_SETROWS, MAKEWPARAM((c + 2) / 3, TRUE), (LPARAM)&rcBar);

    rc = rcBar;

    AdjustWindowRectEx(&rc,
            WS_OVERLAPPEDWINDOW,
            FALSE,
            WS_EX_TOOLWINDOW);

    SetWindowPos(s_hwndFrame,
            NULL,
            0, 0,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    SetWindowPos(s_hwndBar,
            NULL,
            0, 0,
            rcBar.right - rcBar.left,
            rcBar.bottom - rcBar.top,
            SWP_NOZORDER | SWP_NOACTIVATE);

    s_fInitialized = TRUE;

    return TRUE;
}

void
DeinitControlPalette()
{
    if (s_hwndFrame)
    {
        DestroyWindow(s_hwndFrame);
    }
}

BOOL
IsControlPaletteVisible()
{
    return s_hwndFrame && IsWindowVisible(s_hwndFrame);
}

void
ToggleControlPaletteVisibility()
{
    if (!s_fInitialized)
    {
        if (!InitControlPalette())
            return;
    }

    ShowWindow(s_hwndFrame, IsControlPaletteVisible() ? SW_HIDE : SW_SHOW);
}

void
SetControlPaletteOwner(HWND hwnd)
{
    s_hwndOwner = hwnd;
}

HRESULT
GetControlPaletteService(REFIID iid, void **ppv)
{
    HRESULT hr;
    CControlPaletteService *pService;

    pService = new CControlPaletteService();
    if (pService == NULL)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pService->QueryInterface(iid, ppv));

    pService->Release();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\paddisp.h ===
#define DISPID_PadEvents_Load  10
#define DISPID_PadEvents_Status 11
#define DISPID_PadEvents_Timer 12
#define DISPID_PadEvents_DocLoaded 13
#define DISPID_PadEvents_OnPaint 14
#define DISPID_PadEvents_Unload  15
#define DISPID_PadEvents_PerfCtl 16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\paddebug.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddebug.hxx
//
//  Contents:   CDebugWindow class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

BOOL    CDebugWindow::s_fDebugWndClassRegistered = FALSE;


//+-------------------------------------------------------------------
//
// Member:    CDebugWindow ::CDebugWindow
//
// Synopsis:
//
//--------------------------------------------------------------------
CDebugWindow::CDebugWindow (CPadDoc * pDoc)
{     
    _pDoc = pDoc;
}


CDebugWindow::~CDebugWindow ()
{     
}


HRESULT
CDebugWindow::RegisterDebugWndClass()
{
    WNDCLASS    wc;

    // Protect s_fDebugWndClassRegistered
    
    if (!s_fDebugWndClassRegistered)
    {
        LOCK_GLOBALS;

        if (!s_fDebugWndClassRegistered)
        {
            memset(&wc, 0, sizeof(wc));
            wc.lpfnWndProc = CDebugWindow::WndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
            wc.lpszMenuName =  NULL;
            wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" Debug Window");
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

            if (!RegisterClass(&wc))
            {
                return E_FAIL;
            }
            s_fDebugWndClassRegistered = TRUE;
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
// Member:    CDebugWindow ::Init
//
// Synopsis:
//
//--------------------------------------------------------------------
HRESULT
CDebugWindow::Init()
{
    
    HRESULT     hr = S_OK;
    RECT        rc;
    
    hr = THR(RegisterDebugWndClass());
    if (hr)
        goto Error;

   _hwnd = CreateWindowEx(
            0,
            SZ_APPLICATION_NAME TEXT(" Debug Window"),
            SZ_APPLICATION_NAME TEXT(" Debug Window"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            NULL,
            NULL,
            g_hInstCore,
            this);

    if (!_hwnd)
    {
        hr = E_FAIL;
        goto Error;
    }


    GetClientRect (_hwnd, &rc);

    _hwndText = CreateWindowEx(
        NULL,
        TEXT("Edit"),
        NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | 
            WS_BORDER | ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        0, 0, rc.left - rc.right, rc.top - rc.bottom,
        _hwnd,                 
        0,               
        g_hInstCore,          
        NULL);    
    
    if(!_hwndText)
    {
        hr = E_FAIL;
        goto Error;             
    }
  
    SetWindowLongPtr(_hwndText, GWLP_USERDATA, (LONG_PTR) this);
    _wpOrigEditProc = (WNDPROC) SetWindowLongPtr(_hwndText, GWLP_WNDPROC, (LONG_PTR) DebugTextWndProc); 
 
    RRETURN(hr);

Error:
    if(_hwnd)
        DestroyWindow(_hwnd); 
    if(_hwndText)
        DestroyWindow(_hwndText); 
    RRETURN(hr);
}

void
CDebugWindow::Destroy()
{
    if(_hwndText)
        DestroyWindow(_hwndText);
    if(_hwnd)
        DestroyWindow(_hwnd);
}


LRESULT
CDebugWindow::ExecuteScript ()
{
    TCHAR achCommand[256], achString[256];
    LONG cch, lLine;
    DWORD dwStart, dwEnd;
    //HWND hwndAct;
        
    // Retrieve current cursor position
    SendMessage(_hwndText, EM_GETSEL,(WPARAM) &dwStart, (LPARAM) &dwEnd); 
    
    // Retrieve current line index
    lLine = SendMessage(_hwndText, EM_LINEFROMCHAR,(WPARAM) dwStart, 0);
    
    // Retrieve line text
    achCommand[0] = (TCHAR) ARRAY_SIZE(achCommand)-1; 
    cch = SendMessage(_hwndText, EM_GETLINE, lLine, (LPARAM)achCommand);

    // if the end of the buffer has been overwritten!!!
    Assert(cch < ARRAY_SIZE(achCommand)-1);

    achCommand[cch] = TEXT('\0');

    // Replace ? at start of script by PrintDebug command
    cch = 0;

    while (achCommand[cch] == TEXT(' '))
        cch++;

    if (achCommand[cch] == TEXT('?')) 
    {
        wcscpy(achString,TEXT ("PrintDebug"));
        wcscat(achString,achCommand + 1);
        wcscpy(achCommand,achString);
    }
            
    // Move cursor to next line, creating one if necessary
    NextLine();
            
    // ISSUE: chrisf - necessary if SendKeys goes to focus window
    //hwndAct = SetActiveWindow(_pDoc->_hwnd);

    IGNORE_HR(_pDoc->ExecuteTopLevelScriptlet(achCommand));
    
    //SetActiveWindow(hwndAct);

    return 0;
}


LRESULT CALLBACK
CDebugWindow::DebugTextWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    
    switch (wm)
    {
    case WM_CHAR :
        if (wParam == '\r')      //carriage return
        {
            return pDebug->ExecuteScript();
        }
        break;
    }

    return CallWindowProc(pDebug->_wpOrigEditProc, hwnd, wm, wParam, lParam); 
   
}

HRESULT
CDebugWindow::Print(BSTR PrintValue)
{
    LONG lLine;
    LONG lLineLength;
    LONG lLineStart;
    DWORD dwStart, dwEnd;

    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(_hwnd, GWLP_USERDATA);

    // Get cursor position
    SendMessage(pDebug->_hwndText, EM_GETSEL, (WPARAM) &dwStart, (LPARAM) &dwEnd); 
    
    // Retrieve line at cursor position
    lLine = SendMessage (pDebug->_hwndText, EM_LINEFROMCHAR, (WPARAM) dwStart, 0);
    
    // Retrieve line start and length
    lLineLength = SendMessage(_hwndText, EM_LINELENGTH, (WPARAM) dwStart, 0);
    lLineStart = SendMessage(_hwndText, EM_LINEINDEX, (WPARAM) lLine, 0);

    // Selection entire line
    SendMessage(_hwndText, EM_SETSEL, lLineStart, lLineStart + lLineLength);
    
    // And replace with string to print
    SendMessage(
        pDebug->_hwndText, EM_REPLACESEL, 0, LPARAM( STRVAL( PrintValue ) ) );

    // Then move to next line
    NextLine();
    
    return S_OK;
}

HRESULT
CDebugWindow::NextLine()
{ 
    DWORD dwStart, dwEnd;
    LONG lLine, lLineLength, lLineStart;
    LONG lCount;

    lCount = SendMessage(_hwndText, EM_GETLINECOUNT,0, 0L);
    SendMessage(_hwndText, EM_GETSEL, (WPARAM) &dwStart, (LPARAM) &dwEnd); 
    lLine = SendMessage(_hwndText, EM_LINEFROMCHAR, (WPARAM) dwStart, 0);
    lLineLength = SendMessage(_hwndText, EM_LINELENGTH, (WPARAM) dwStart, 0);
    lLineStart = SendMessage(_hwndText, EM_LINEINDEX, (WPARAM) lLine, 0);

    if (lLine + 1 < lCount)
    {
        SendMessage(_hwndText, EM_SETSEL, lLineStart + lLineLength + 2, lLineStart + lLineLength + 2);
    }
    else
    {
        SendMessage(_hwndText, EM_SETSEL, lLineStart + lLineLength, lLineStart + lLineLength);
        CallWindowProc(_wpOrigEditProc, _hwndText, WM_CHAR, '\r', 1); 
    }

    return S_OK;
}


LRESULT
CDebugWindow::DebugWindowOnClose()
{
    ::ShowWindow(_hwnd, SW_HIDE);
    return 0;
}


LRESULT CALLBACK
CDebugWindow::WndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{

    CDebugWindow * pDebug = (CDebugWindow *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (wm)
    {
    case WM_NCCREATE:
        {
            pDebug = (CDebugWindow *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDebug);
            pDebug->_hwnd = hwnd;
        }
        break;
    case WM_NCDESTROY:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            pDebug->_pDoc->_pDebugWindow = NULL;
            delete pDebug;
        }
        break;
    case WM_CLOSE:
        pDebug->DebugWindowOnClose();
        return 0;
    case WM_SIZE:
        ::MoveWindow (pDebug->_hwndText,0,0,LOWORD (lParam), HIWORD (lParam), TRUE);
        return 0;
    case WM_ACTIVATE:
        if(wParam != WA_INACTIVE)
        {
            SetFocus(pDebug->_hwndText);
        }
        return 0;
    }
    return DefWindowProc(hwnd, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padbsc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padbsc.cxx
//
//  Contents:   CPadBSC class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

DeclareTag(tagPadBSC, "PadBSC", "Bind status callback")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadBSC, CPadDoc, PadDoc, _BSC);

HRESULT
CPadBSC::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CPadBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pBinding)
{
    TraceTag((tagPadBSC, "OnStartBinding %08x", grfBSCOption));
    ReplaceInterface(&PadDoc()->_pBinding, pBinding);
    return S_OK;
}

HRESULT
CPadBSC::GetPriority(LONG *pnPriority)
{
    TraceTag((tagPadBSC, "GetPriority"));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnLowResource(DWORD reserved)
{
    TraceTag((tagPadBSC, "OnLowResource"));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnProgress(
    ULONG ulProgress, 
    ULONG ulProgressMax, 
    ULONG ulStatusCode, 
    LPCWSTR pchStatusText)
{
    TCHAR achBuf[MAX_PATH];
    static TCHAR *s_apch[] =
    {
        NULL,                               // 0
        TEXT("Finding resource <0s>"),      // 1
        TEXT("Connecting to <0s>"),         // 2
        TEXT("Redirecting <0s>"),           // 3
        TEXT("Downloading <0s>"),           // 4
        TEXT("Downloading <0s>"),           // 4
        NULL,                               // 6
        TEXT("Downloading components for <0s>"), // 7
        TEXT("Installing components for <0s>"),  // 8
        TEXT("Downloading <0s>"),                // 9
    };

    TraceTag((tagPadBSC, "OnProgress cur=%d, max=%d, status=%d", ulProgress, ulProgressMax, ulStatusCode));

    if (ulStatusCode < ARRAY_SIZE(s_apch) && s_apch[ulStatusCode])
    {
        Verify(!Format(0, achBuf, ARRAY_SIZE(achBuf),
                s_apch[ulStatusCode],
                pchStatusText));
        PadDoc()->SetStatusText(achBuf);
    }

    RRETURN(S_OK);
}

HRESULT
CPadBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    TraceTag((tagPadBSC, "OnStopBinding hr=%hr", hresult));

    if (PadDoc()->_pBCtx)
    {
        THR(RevokeBindStatusCallback(PadDoc()->_pBCtx, &PadDoc()->_BSC));
        ClearInterface(&PadDoc()->_pBCtx);
    }
    ClearInterface(&PadDoc()->_pBinding);
    return S_OK;
}

HRESULT
CPadBSC::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo)
{
    TraceTag((tagPadBSC, "GetBindInfo"));

    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;
    
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    if (pbindinfo)
    {
        DWORD cbSize = pbindinfo->cbSize;
        memset(pbindinfo, 0, cbSize);
        pbindinfo->cbSize = cbSize;

        pbindinfo->dwBindVerb = BINDVERB_GET;
    }
    return S_OK;
}

HRESULT
CPadBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM  *pstgmed)
{
    TraceTag((tagPadBSC, "OnDataAvailable grfBSCF=%08x, size=%d", grfBSCF, dwSize));
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadBSC::OnObjectAvailable(REFIID iid, IUnknown *pUnk)
{
    PerfLog(tagPerfWatchPad, this, "+CPadBSC::OnObjectAvailable");

    HRESULT         hr = S_OK;
    IOleObject *    pObject = NULL;

    TraceTag((tagPadBSC, "OnObjectAvailable"));

    if (PadDoc()->_pBinding)
    {
        hr = THR(pUnk->QueryInterface(IID_IOleObject, (void **)&pObject));
        if (hr)
            goto Cleanup;

        hr = THR(PadDoc()->Activate(pObject));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pObject);
    PerfLog(tagPerfWatchPad, this, "-CPadBSC::OnObjectAvailable");
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padframe.cxx
//
//  Contents:   CPadFrame class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadFrame, CPadDoc, PadDoc, _Frame);

STDMETHODIMP
CPadFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


STDMETHODIMP
CPadFrame::GetWindow(HWND * phWnd)
{
    *phWnd = PadDoc()->_hwnd;
    return S_OK;
}


STDMETHODIMP
CPadFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadFrame::GetBorder(LPOLERECT prcBorder)
{
    RECT rc;
    PadDoc()->GetViewRect(&rc, FALSE);
    CopyRect(prcBorder, &rc);
    return S_OK;
}


STDMETHODIMP
CPadFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    // Always try to grant the space, delay the actual BorderSpace checks to
    // SetBorderSpace.

    RRETURN(S_OK);
}


STDMETHODIMP
CPadFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    RECT         rcCurrentSize;
    BORDERWIDTHS bw;

    if (pbw == NULL) // in-place object is not interested in tools.
    {
        memset(&bw, 0, sizeof(bw));
        pbw = &bw;
    }

    PadDoc()->GetViewRect(&rcCurrentSize, TRUE);

    // If the requested border space is larger than the current window size, no space can be given.

    if (((rcCurrentSize.bottom - rcCurrentSize.top) <= (pbw->top + pbw->bottom)) ||
        ((rcCurrentSize.right - rcCurrentSize.left) <= (pbw->left + pbw->right)))
    {
        RRETURN(INPLACE_E_NOTOOLSPACE);
    }

    // Record the requested in-place toolbar border space and re-set the client window area size.

    PadDoc()->_bwToolbarSpace = *pbw;
    PadDoc()->Resize(); // We must call this here for the doc-obj to resize itself.

    RRETURN(S_OK);
}


STDMETHODIMP
CPadFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    ReplaceInterface(&PadDoc()->_pInPlaceActiveObject, pActiveObj);
    return S_OK;
}


STDMETHODIMP
CPadFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    return PadDoc()->InsertMenus(hmenuShared, pmgw);
}


STDMETHODIMP
CPadFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return S_OK;
}


STDMETHODIMP
CPadFrame::RemoveMenus(HMENU hmenuShared)
{
    while (GetMenuItemCount(hmenuShared) > 0)
    {
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);
    }

    return S_OK;
}


STDMETHODIMP
CPadFrame::SetStatusText(LPCTSTR szStatusText)
{
    PadDoc()->SetStatusText(szStatusText);
    return S_OK;
}


STDMETHODIMP
CPadFrame::EnableModeless(BOOL fEnable)
{
    //  TODO should probably disable ourselves?
    return S_OK;
}


STDMETHODIMP
CPadFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padconst.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padconst.cxx
//
//  Contents:   CPadScriptSite
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadScriptConst, CPadDoc, PadDoc, _ScriptConst);

static HRESULT
LookupSymbol(ITypeComp *pTypeComp, TCHAR *pch, long *pl)
{
    HRESULT     hr;
    ITypeInfo * pTypeInfo = NULL;
    DESCKIND    desckind = DESCKIND_NONE;
    BINDPTR     bindptr;

    hr = THR(pTypeComp->Bind(
            pch, 
            0, 
            INVOKE_PROPERTYGET, 
            &pTypeInfo,
            &desckind,
            &bindptr));
    if (hr)
        goto Cleanup;

    if (desckind != DESCKIND_VARDESC || 
        bindptr.lpvardesc->varkind != VAR_CONST ||
        bindptr.lpvardesc->lpvarValue->vt != VT_I4)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    *pl = V_I4(bindptr.lpvardesc->lpvarValue);

Cleanup:
    switch (desckind)
    {
    case DESCKIND_FUNCDESC:
        pTypeInfo->ReleaseFuncDesc(bindptr.lpfuncdesc);
        break;

    case DESCKIND_VARDESC:
        pTypeInfo->ReleaseVarDesc(bindptr.lpvardesc);
        break;

    case DESCKIND_TYPECOMP:
        ReleaseInterface(bindptr.lptcomp);
        break;

    case DESCKIND_IMPLICITAPPOBJ:
        Assert(0 && "What is this?");
        break;
    }

    ReleaseInterface(pTypeInfo);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::QueryInterface
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPadScriptConst::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IDispatch ||
        iid == IID_IUnknown)
    {
        *ppv = (IDispatch*)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    Assert(FALSE);
    return E_FAIL;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 0;
    return S_OK;
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT     hr;
    int         i;

    hr = THR(PadDoc()->LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    for (i = 0; i < ARRAY_SIZE(PadDoc()->_apTypeComp); i++)
    {
        hr = THR_NOTRACE(LookupSymbol(PadDoc()->_apTypeComp[i], rgszNames[0], rgdispid));
        if (!hr)
            break;
    }

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
// 
//  Member: CPadScriptConst::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptConst::Invoke(DISPID dispidMember, 
                        REFIID riid, 
                        LCID lcid, 
                        WORD wFlags,
                        DISPPARAMS * pdispparams, 
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo, 
                        UINT * puArgErr)
{
    HRESULT hr = S_OK;
    
    if(!(wFlags & DISPATCH_PROPERTYGET))
        return DISP_E_MEMBERNOTFOUND;

    pvarResult->vt = VT_I4;
    pvarResult->lVal = dispidMember;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\paddoc.cxx ===
//------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       paddoc.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include "stdio.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include "platform.h"
#endif

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

#if CICERO==1

#ifndef X_HTMLUIM_I_C
#define X_HTMLUIM_I_C
#define __mshtml_h__	// HACKHACK: to prevent inclusion of mshtml.h
#include "htmluim_i.c"
#endif

#endif

extern "C" const GUID SID_SHTMLEditServices;
extern void DeinitTearOffCache();

BOOL g_fHiResAware = FALSE;
BOOL g_fUseHR = FALSE;

// This is here for testing print templates
//DYNLIB g_dynlibPrintHTML = { NULL, NULL, "mshtml.dll" };

extern void ScrubRegistry();
extern DYNLIB g_dynlibMSHTML;

DeclareTag(tagPadPositionPersist, "Pad", "Save last pad position to mshtmdbg.ini")
DeclareTag(tagPadNoSuspendForMessage, "Pad", "Don't Suspend/Resume CAP around PeekMessage/GetMessage")
DeclareTag(tagStatus, "Status",      "Write status line text to logfile")
DeclareTag(tagPalette, "Palette", "Trace Palette and ColorSet behaviour");
DeclareTag(tagSpanTag, "Edit",    "Insert span tags around block elements when editing")
DeclareTag(tagSpanTag2, "Edit",    "Insert span tags with compose settings outside")
DeclareTag(tagPPVTemplateOverride, "PrintPv", "Use TRIDENT_PPVPATH env var as print template")
PerfTag(tagPerfWatchPad, "Perf", "PerfWatch: Trace MSHTMPAD performance points")
ExternTag(tagPeerProvideTestBehaviors);
ExternTag(tagDefaultDIV);
ExternTag(tagDefault);
MtDefine(Pad, WorkingSet, "mshtmpad.exe")
MtDefine(CPadDoc, Pad, "CPadDoc")
MtDefine(CPadScriptSite, Pad, "CPadScriptSite")
MtDefine(CDebugWindow, Pad, "CDebugWindow")
MtDefine(CDebugDownloadNotify, Pad, "CDebugDownloadNotify")

//
// static to store the pointer to WndProc of ComboBox'es in Format Toolbar
//
static WNDPROC lpfnDefCombo;

// messages for zoom combo box in Standard Toolbar
#define WM_ZOOMRETURN   (WM_USER+1)
#define WM_ZOOMESCAPE   (WM_USER+2)
#define WM_ZOOMUP       (WM_USER+3)
#define WM_ZOOMDOWN     (WM_USER+4)

static FORMATETC s_FormatEtcMF =
    { (CLIPFORMAT) CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT };

BOOL  CPadDoc::s_fPadWndClassRegistered = FALSE;
BOOL  CPadDoc::s_fPaletteDevice;

extern DWORD WINAPI CreatePadDocThreadProc(void * pv);

int CALLBACK
FillFontProc(const LOGFONT *    lplf,
             const TEXTMETRIC * lptm,
             DWORD            iFontType,
             LPARAM           lParam);

static const ComboItem ComboColorItems[] =
{
    {IDS_COLOR_BLACK,      RGB(0, 0, 0)},
    {IDS_COLOR_NAVY,       RGB(0, 0, 128)},
    {IDS_COLOR_BLUE,       RGB(0, 0, 255)},
    {IDS_COLOR_CYAN,       RGB(0, 255, 255)},
    {IDS_COLOR_RED,        RGB(255, 0, 0)},
    {IDS_COLOR_LIME,       RGB(0, 255, 0)},
    {IDS_COLOR_GRAY,       RGB(128, 128, 128)},
    {IDS_COLOR_GREEN,      RGB(0, 128, 0)},
    {IDS_COLOR_YELLOW,     RGB(255, 255, 0)},
    {IDS_COLOR_PINK,       RGB(255, 192, 203)},
    {IDS_COLOR_VIOLET,     RGB(238, 130, 238)},
    {IDS_COLOR_WHITE,      RGB(255, 255, 255)},
    {0, 0L}
};

#define INDEX_ZOOM_100  4

static const ComboItem ComboZoomItems[] =
{
    {IDS_ZOOM_1000,         1000},  //  0
    {IDS_ZOOM_500,          500},   //  1
    {IDS_ZOOM_200,          200},   //  2
    {IDS_ZOOM_150,          150},   //  3
    {IDS_ZOOM_100,          100},   //  4
    {IDS_ZOOM_75,           75},    //  5
    {IDS_ZOOM_50,           50},    //  6
    {IDS_ZOOM_25,           25},    //  7
    {IDS_ZOOM_10,           10},    //  8
    {IDS_ZOOM_5,            5},     //  9
    {IDS_ZOOM_1,            1},     // 10
    {0, 0L}
};

char *
IntToString(int i)
{
    static char ach[32];
    wsprintfA(ach, "%d", i);
    return(ach);
}

BOOL
IsUrlPrefix(const TCHAR * pchPath)
{
    return(memcmp(pchPath, _T("file:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("http:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("https:"),        6 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("ftp:"),          4 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("gopher:"),       7 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("sock:"),         5 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("about:"),        6 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("javascript:"),   11 * sizeof(TCHAR)) == 0 ||
           memcmp(pchPath, _T("vbscript:"),     9 * sizeof(TCHAR)) == 0  ||
           memcmp(pchPath, _T("mk:"),           3 * sizeof(TCHAR)) == 0);
}

HRESULT
GetOmDocumentFromDoc (IUnknown * pUnkDoc, IHTMLDocument2 ** ppOmDoc)
{
    HRESULT             hr;

    hr = THR(pUnkDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppOmDoc));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

static HRESULT
CreateDoc(IUnknown **ppUnk)
{
    CThreadProcParam tpp(FALSE, ACTION_NONE);

    RRETURN(THR(CreatePadDoc(&tpp, ppUnk)));
}

CPadFactory PadDocFactory(CLSID_Pad, CreateDoc);

CPadDoc::CPadDoc(BOOL fUseShdocvw)
  : _aryPadPointers( Mt( Mem ) ), _aryPadContainers( Mt( Mem ) )
{
    PADTHREADSTATE * pts = GetThreadState();

    IncrementObjectCount();
    _ulRefs = 1;
    _ulAllRefs = 1;
    _fUserMode = TRUE;  // start in browse mode
    _pBrowser = NULL;
    _fUseShdocvw = fUseShdocvw;
    _lViewChangesFired = 0;
    _lDataChangesFired = 0;
    _dwCookie = 0;
    _fToolbarDestroy = FALSE;
    _fComboLoaded = FALSE;
    _fToolbarhidden = TRUE;
    _fFormatInit = FALSE;
    _fStandardInit = FALSE;
    _palState = palUnknown;
    _idPadIDNext = 1;
    _fUpdateUI = TRUE;

    _pObjectHBI = NULL;

    //
    //  Add self to the head of the linked list of forms
    //
    _pDocNext = pts->pDocFirst;
    pts->pDocFirst = this;

    _hAccelerators = LoadAccelerators(g_hInstCore, MAKEINTRESOURCE(IDR_PAD_ACCELERATORS));

    _pScriptRecorder = new CDummyScriptRecorder;

    ::AddAtom(DOCHOSTUIATOM_ENABLE_HIRES);
#if CICERO==1
    _pCicero = NULL;
#endif // CICERO==1
}


CPadDoc::~CPadDoc( )
{
    PADTHREADSTATE * pts = GetThreadState();

    CPadDoc ** ppDoc;

    if (pts)
    {
        //  Remove from list of active documents
        for (ppDoc = &pts->pDocFirst; *ppDoc != NULL; ppDoc = &(*ppDoc)->_pDocNext)
        {
            if (*ppDoc == this)
            {
                *ppDoc = _pDocNext;
                break;
            }
        }
    }

    if (!_fDecrementedObjectCount)
    {
        DecrementObjectCount();
    }

    if (_hAccelerators)
        DestroyAcceleratorTable(_hAccelerators);

    delete _pScriptRecorder;

    ::DeleteAtom(::FindAtom(DOCHOSTUIATOM_ENABLE_HIRES));
    DeinitTearOffCache();
}



HRESULT
CPadDoc::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IDispatch)
    {
        HRESULT hr = CreateTearOffThunk(
            this,                                   // pvObject1
            *(void **)(IDispatch*)this,             // apfn1
            NULL,                                   // pUnkOuter
            ppvObj,                                 // ppvThunk
            &_Site,                                  // pvObject2
            *(void **)(IUnknown*)(IOleClientSite *)&_Site, // apfn2
            ADDREF_MASK | RELEASE_MASK,             // dwMask
            NULL);                                  // appropdescsInVtblOrder

        if (hr)
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (iid == IID_IPad || iid == IID_IUnknown)
    {
        *ppvObj = (IPad *)this;
    }
    else if (iid == IID_IOleObject)
    {
        *ppvObj = (IOleObject *)this;
    }
    else if (iid == IID_IOleContainer)
    {
        *ppvObj = (IOleContainer *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

ULONG
CPadDoc::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CPadDoc::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
        SubRelease();
        return 0;
    }

    return _ulRefs;
}

ULONG
CPadDoc::SubAddRef( )
{
    return ++_ulAllRefs;
}

ULONG
CPadDoc::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }
    return 0;
}


DYNPROC s_dynprocClearCache = { NULL, &g_dynlibMSHTML, "SvrTri_ClearCache" };
typedef void (WINAPI *PFN_SVRTRI_CLEARCACHE)();

void
CPadDoc::Passivate( )
{
    PFN_SVRTRI_CLEARCACHE  TRI_ClearCache;
    int i;

    for ( i = 0 ; i < _aryPadPointers.Size() ; i++ )
        _aryPadPointers[i]._pPointer->Release();

    for ( i = 0 ; i < _aryPadContainers.Size() ; i++ )
        _aryPadContainers[i]._pContainer->Release();

    PersistWindowPosition();

    if (    GetModuleHandleA("mshtml.dll")
        &&  OK(LoadProcedure(&s_dynprocClearCache)))
    {
        TRI_ClearCache = (PFN_SVRTRI_CLEARCACHE)s_dynprocClearCache.pfn;
        TRI_ClearCache();
    }

    CloseScripts();
    Deactivate();

    //
    // Some poorly behaved controls don't call OleSetMenuDescriptor when
    // cleaning up.  Do it now on behalf of them.
    //

    OleSetMenuDescriptor(NULL, _hwnd, NULL, &_Frame, NULL);

    ClearInterface(&_pObject);
    ClearInterface(&_pInPlaceObject);
    ClearInterface(&_pInPlaceActiveObject);
    ClearInterface(&_pTypeLibPad);
    ClearInterface(&_pTypeInfoCPad);
    ClearInterface(&_pTypeInfoIPad);
    ClearInterface(&_pTypeInfoILine);
    ClearInterface(&_pTypeInfoICascaded);
    ClearInterface(&_pTypeLibDLL);

    for ( i = 0; i < ARRAY_SIZE(_apTypeComp); i++)
    {
        ClearInterface(&_apTypeComp[i]);
    }

    ReleaseBindContext();

    DestroyToolbars();
    SetMenu(_hwnd, NULL);
    DestroyWindow(_hwnd);

    if(_pDebugWindow)
    {
        _pDebugWindow->Destroy();
    }

    if (!_fDecrementedObjectCount)
    {
        DecrementObjectCount();
        _fDecrementedObjectCount = TRUE;
    }

    if (_hpal)
    {
        DeleteObject(_hpal);
        _hpal = 0;
    }
    if ( _hmenuEdit )
    {
        ::DestroyMenu( _hmenuEdit );
        _hmenuEdit = NULL;
    }
    if ( _hmenuMain )
    {
        ::DestroyMenu( _hmenuMain );
        _hmenuMain = NULL;
    }
    if ( _hmenuHelp )
    {
        ::DestroyMenu( _hmenuHelp );
        _hmenuHelp = NULL;
    }

    delete _pScriptRecorder;
    _pScriptRecorder = NULL;

}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetWindowPosition
//
//  Synopsis:   Restore window position from c:\ef if tagPadPosition is set.
//
//----------------------------------------------------------------------------

void
CPadDoc::SetWindowPosition()
{
    if (GetPrivateProfileIntA("PadPosition", "RestorePosition", FALSE, "mshtmdbg.ini"))
    {
        RECT rc;
        rc.left = GetPrivateProfileIntA("PadPosition", "PadLeft", 0, "mshtmdbg.ini");
        rc.top = GetPrivateProfileIntA("PadPosition", "PadTop", 0, "mshtmdbg.ini");
        rc.right = GetPrivateProfileIntA("PadPosition", "PadRight", 800, "mshtmdbg.ini");
        rc.bottom = GetPrivateProfileIntA("PadPosition", "PadBottom", 600, "mshtmdbg.ini");
        MoveWindow(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::PersistWindowPosition
//
//  Synopsis:   Write the pad window's coordinates to c:\ef if
//              tagPadPositionPersist is set.
//
//----------------------------------------------------------------------------

void
CPadDoc::PersistWindowPosition()
{
    if (IsTagEnabled(tagPadPositionPersist))
    {
        RECT rc;
        GetWindowRect(_hwnd, &rc);

        WritePrivateProfileStringA("PadPosition", "RestorePosition", IntToString(TRUE), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadLeft", IntToString(rc.left), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadTop", IntToString(rc.top), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadRight", IntToString(rc.right), "mshtmdbg.ini");
        WritePrivateProfileStringA("PadPosition", "PadBottom", IntToString(rc.bottom), "mshtmdbg.ini");
    }
}

BOOL
CPadDoc::GetDirtyState()
{
    BOOL fDirty = FALSE;
    IPersistFile *pPF = NULL;

    if (!_pObject)
        return FALSE;

    if (OK(THR_NOTRACE(_pObject->QueryInterface(IID_IPersistFile, (void **)&pPF))))
    {
        // ISSUE: Netscape cannot dirty the document but it reports dirty
        if (_fNetscape)
        {
            fDirty = FALSE;
        }
        else
        {
            fDirty = THR(pPF->IsDirty()) == S_OK;
        }
        pPF->Release();
    }

    return fDirty;
}

HRESULT
CPadDoc::QuerySave(DWORD dwSaveOptions)
{
    if (!GetDirtyState())
        return S_OK;

    switch( dwSaveOptions )
    {
    default:
        Assert(FALSE);

    case SAVEOPTS_SAVEIFDIRTY:
        break;

    case SAVEOPTS_NOSAVE:
        return S_OK;

    case SAVEOPTS_PROMPTSAVE:
        switch (MessageBox(_hwnd,
                TEXT("Do you want to save the changes ?"),
                SZ_APPLICATION_NAME,
                MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL))
        {
        case IDYES:
            break;

        case IDNO:
            return S_OK;

        case IDCANCEL:
        default:
            return S_FALSE;
        }
    }

    return DoSave(FALSE);
}



HRESULT
CPadDoc::DoSave(BOOL fPrompt)
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pCommandTarget = 0;

    // (jenlc) Save through URL has not been implemented yet.
    // Request users to SAVEAS fils.
    //
    if ( fPrompt || _fInitNew || _fOpenURL)
    {
        //  Have to do Save As...
        //  The trick is the user can cancel this
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            hr = pCommandTarget->Exec(
                    NULL,
                    OLECMDID_SAVEAS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);

            if ( hr )
                goto Cleanup;

            _fInitNew = FALSE;
        }
    }
    else
    {
        //  Save silently
        hr = THR(Save((TCHAR*)NULL));
    }

Cleanup:
    if ( hr == OLECMDERR_E_CANCELED )
    {
        hr = S_FALSE;
    }
    UpdateDirtyUI();
    ReleaseInterface(pCommandTarget);
    RRETURN1(hr, S_FALSE);
}


HRESULT
CPadDoc::PromptOpenFile(HWND hwnd, const CLSID * pclsid)
{
    HRESULT         hr;
    OPENFILENAME    ofn;
    BOOL            f;

    hr = QuerySave(SAVEOPTS_PROMPTSAVE);
    if (hr)
        RRETURN1(hr, S_FALSE);

    static TCHAR achPath[MAX_PATH] = _T("");
    static TCHAR achStartDir[MAX_PATH] = _T("");

#if !defined(WINCE)
    if (    !achPath[0]
        &&  !achStartDir[0]
        &&  GetEnvironmentVariable(_T("PAD_DEFAULTFILEDIR"), achStartDir, MAX_PATH))
    {
        if (_tcscmp(achStartDir, _T("CurrentDir")) == 0)
        {
            GetCurrentDirectory(MAX_PATH, achStartDir);
        }
    }
#endif

    if (!achPath[0] && !achStartDir[0])
    {
        char achStartDirA[MAX_PATH] = "";
        GetPrivateProfileStringA("PadDirs","FileDir","",achStartDirA,MAX_PATH, "mshtmdbg.ini");

        if (achStartDirA[0])
        {
            MultiByteToWideChar(CP_ACP, 0, achStartDirA, MAX_PATH, achStartDir, MAX_PATH);
        }
    }

    if (!achPath[0] && !achStartDir[0])
    {
        // Prime file name with samples directory.

        // Start with the directory containing this file.

        _tcscpy(achStartDir, _T(__FILE__));

        // Chop off the name of this file and three directories.
        // This will leave the root of our SLM tree in achPath.

        if ( ! _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR))) {
            achStartDir[0] = (TCHAR)0;

        } else {

            for (int i = 0; i < 4; i++)
                {
                    TCHAR *pch = _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR));
                    if (pch)
                        *pch = 0;
                }
        }

        // Append the name of the directory containing the samples.

        _tcscat(achStartDir, _T(FILENAME_SEPARATOR_STR) _T("src")
                             _T(FILENAME_SEPARATOR_STR) _T("f3")
                             _T(FILENAME_SEPARATOR_STR) _T("drt")
                             _T(FILENAME_SEPARATOR_STR) _T("samples"));
    }

    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd ? hwnd : _hwnd;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0RTF Documents (*.rtf)\0*.rtf\0Text files (*.txt)\0*.txt\0Dialogs (*.fmd)\0*.fmd\0All Files (*.*)\0*.*\0");
    ofn.lpstrFile = achPath;
    ofn.lpstrInitialDir = *achPath ? NULL : achStartDir;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ARRAY_SIZE(achPath);
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    DbgMemoryTrackDisable(TRUE);
    f = GetOpenFileName(&ofn);
    DbgMemoryTrackDisable(FALSE);

    if (!f)
        return S_FALSE;

    hr = _fUseShdocvw ? THR(OpenFile(achPath, NULL)) : ((!pclsid) ? THR(Open(achPath)) : THR(Open(*pclsid, achPath)));

    RRETURN(hr);
}

HRESULT
CPadDoc::PromptOpenURL(HWND hwnd, const CLSID *pclsid)
{
    TCHAR   achURL[MAX_PATH];
    HRESULT hr;

    hr = QuerySave(SAVEOPTS_PROMPTSAVE);
    if (hr)
        RRETURN1(hr, S_FALSE);

    if (!GetURL(hwnd ? hwnd : _hwnd, achURL, ARRAY_SIZE(achURL)))
        return S_FALSE;

    hr = _fUseShdocvw ? THR(OpenFile(achURL, NULL)) : ((!pclsid) ? THR(Open(achURL)) : THR(Open(*pclsid, achURL)));

    if (hr)
    {
        MessageBox(
            _hwnd,
            TEXT("Could not open the specified URL."),
            TEXT("Unable to open URL"),
            MB_APPLMODAL | MB_ICONERROR | MB_OK);
    }

    return S_OK;
}

void
CPadDoc::ReleaseBindContext()
{
    if (_pBinding)
    {
        THR(_pBinding->Abort());
        ClearInterface(&_pBinding);
    }

    if (_pBCtx)
    {
        // TODO (dbau) rearrange so that RevokeBSC is called in BSC::OnStopBinding

        THR(RevokeBindStatusCallback(_pBCtx, &_BSC));

        ClearInterface(&_pBCtx);
    }
}

HRESULT
CPadDoc::InitializeBindContext()
{
    HRESULT hr;

    // Cleanup previous binding and bind context.

    ReleaseBindContext();

    // Create new bind context.

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &_pBCtx, 0));
    if (hr)
        goto Cleanup;

    hr = THR(RegisterBindStatusCallback(_pBCtx, &_BSC, NULL, 0));

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::Open(TCHAR *pchPath)
{
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Open");

    HRESULT         hr = S_OK;
    IOleObject *    pObject = NULL;
    ULONG           ulEaten;

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    // Shutdown the previous object.
    hr = Deactivate();
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(pchPath, TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(InitializeBindContext());
    if (hr)
        goto Cleanup;

    // Parse the text into a moniker. A single call to MkParseDisplayNameEx
    // should be all that it takes to handle this.  Due to bugs in
    // MkParseDisplayNameEx and the possiblity that URLMON.DLL is not
    // installed on the user's system, we have this more complicated code.

    if (IsUrlPrefix(pchPath))
    {
        DbgMemoryTrackDisable(TRUE);
        hr = THR(CreateURLMoniker(NULL, pchPath, &_pMk));
        DbgMemoryTrackDisable(FALSE);
    }
    else
    {
        hr = E_FAIL;
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    if (hr)
    {
        hr = THR(MkParseDisplayName(_pBCtx, pchPath, &ulEaten, &_pMk));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pBCtx->RegisterObjectParam(SZ_HTML_CLIENTSITE_OBJECTPARAM, (IUnknown *)((IOleClientSite *)&_Site)));
    if (FAILED(hr))
        goto Cleanup;

    // Register this moniker as the one that binds asynchronously.

    // Get the object.

    DbgMemoryTrackDisable(TRUE);
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Open BindToObject");
    hr = THR_NOTRACE(_pMk->BindToObject(_pBCtx, NULL, IID_IOleObject, (void **)&pObject));
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Open BindToObject");
    DbgMemoryTrackDisable(FALSE);

    if (FAILED(hr))
        goto Cleanup;

    Assert(hr == S_OK || hr == S_ASYNCHRONOUS);
    hr = S_OK;

    _fOpenURL = IsUrlPrefix(pchPath);
    _fInitNew = FALSE;
    _fUserMode = !_fInitNew;

    // If the binding is asynchronous, then we get the object
    // pointer in a later call to the bind status callback.

    if (pObject)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        hr = THR(Activate(pObject));
    }

Cleanup:
    ReleaseInterface(pObject);
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Open");
    RRETURN(hr);
}

HRESULT
CPadDoc::PopulateDrtNamespaces(IUnknown * punkDoc)
{
    HRESULT                     hr;
    IServiceProvider *          pServiceProvider = NULL;
    IElementNamespaceTable *    pTable = NULL;
    VARIANT                     varFactory;
    BSTR                        bstrNamespace1 = SysAllocString(_T("DRTNS1"));
    BSTR                        bstrNamespace2 = SysAllocString(_T("DRTNS2"));
    BSTR                        bstrNamespace3 = SysAllocString(_T("DRTNS3"));

    // get the table

    hr = THR(punkDoc->QueryInterface(IID_IServiceProvider, (void**) &pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(IID_IElementNamespaceTable, IID_IElementNamespaceTable, (void**) &pTable));
    if (hr)
        goto Cleanup;

    // prepare factory

    V_VT(&varFactory) = VT_UNKNOWN;
    hr = THR(_Site.QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varFactory)));
    if (hr)
        goto Cleanup;

    // add namespaces

    hr = THR(pTable->AddNamespace(bstrNamespace1, NULL, 0, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace2, NULL, ELEMENTNAMESPACEFLAGS_ALLOWANYTAG, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace3, NULL, ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS, &varFactory));
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pTable);
    VariantClear (&varFactory);
    SysFreeString(bstrNamespace1);
    SysFreeString(bstrNamespace2);
    SysFreeString(bstrNamespace3);

    RRETURN (hr);
}

HRESULT
CPadDoc::Open(REFCLSID clsid, TCHAR *pchPath)
{
    HRESULT                 hr;
    IPersistFile *          pPFile = NULL;
    IPersistStreamInit *    pPStm = NULL;
    IPersistMoniker *       pPMk = NULL;
    IPersistStorage *       pPStg = NULL;
    IStorage *              pStg = NULL;
    IOleObject   *          pObject = NULL;
    TCHAR *                 pchClass = NULL;
    IUnknown *              pUnk = NULL;
    DWORD                   dwFlags;
    BOOL                    fInitNew = _fInitNew;
    BOOL                    fUserMode = _fUserMode;
    BOOL                    fOpenURL = _fOpenURL;

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(pchPath, TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    //
    // *********** UGLY WORKAROUND TO ALLOW HOSTING OF Netscape ! (istvanc)**************
    //
    if (clsid == CLSID_NSCP)
    {
        _fNetscape = TRUE;
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            clsid,
            NULL,
            _fNetscape ? CLSCTX_LOCAL_SERVER :
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    _fInitNew = ((pchPath == NULL) || (*pchPath == 0)) && !(clsid == CLSID_WebBrowser);
    _fUserMode = !_fInitNew;
    _fOpenURL = pchPath && IsUrlPrefix(pchPath);

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        // Hack for IHostBehaviorInit testing
        _pObjectHBI = pObject;
        // End Hack
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    if (IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        IGNORE_HR(PopulateDrtNamespaces(pObject));
    }

    if (pchPath)
    {
        // NOTE: (alexz) please note that moniker should be created
        // regardless of if we use it in this routine or not; this moniker
        // will be used by GetMoniker function.

        hr = THR(CreateURLMoniker(NULL, pchPath, &_pMk));
        if (hr)
            goto Cleanup;

        if (IsUrlPrefix(pchPath))
        {
            hr = THR(pObject->QueryInterface(
                    IID_IPersistMoniker,
                    (void **)&pPMk));
            if (hr)
                goto Cleanup;

            hr = THR(pPMk->Load(FALSE, _pMk, NULL, STGM_READ));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pUnk->QueryInterface(
                    IID_IPersistFile,
                    (void **) &pPFile));
            if (hr)
                goto Cleanup;

            hr = THR(pPFile->Load(pchPath, 0));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR(pObject->QueryInterface(
                IID_IPersistStreamInit,
                (void **)&pPStm));
        if (OK(hr))
        {
            hr = THR(pPStm->InitNew());
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pObject->QueryInterface(
                    IID_IPersistStorage,
                    (void **)&pPStg));
            if (hr)
                goto Cleanup;

            hr = THR(StgCreateDocfile(
                    NULL,
                    STGM_READWRITE | STGM_DELETEONRELEASE | STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_TRANSACTED,
                    0,
                    &pStg));
            if (hr)
                goto Cleanup;

            hr = THR(pPStg->InitNew(pStg));
            if (hr)
                goto Cleanup;
        }
    }

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));
    if (hr)
        goto Cleanup;

    //  Reset Zooming
    ResetZoomPercent();

Cleanup:
    if (hr)
    {
        _fInitNew = fInitNew;
        _fUserMode = fUserMode;
        _fOpenURL = fOpenURL;
    }

    CoTaskMemFree(pchClass);
    ReleaseInterface(pUnk);
    ReleaseInterface(pObject);
    ReleaseInterface(pPFile);
    ReleaseInterface(pPStg);
    ReleaseInterface(pStg);
    ReleaseInterface(pPStm);
    ReleaseInterface(pPMk);
    RRETURN(hr);
}

HRESULT
CPadDoc::Deactivate()
{
    HRESULT hr = S_OK;
    CVariant varBool;

    // give events a chance to fire
    hr = THR_NOTRACE(ExecuteCommand(OLECMDID_ONUNLOAD, &varBool, NULL));
    if ((V_VT(&varBool) == VT_BOOL && !V_BOOL(&varBool)))
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (_hwndWelcome)
    {
        DestroyWindow(_hwndWelcome);
        _hwndWelcome = NULL;
    }

    if (_pInPlaceActiveObject)
    {
        IGNORE_HR(_pInPlaceObject->UIDeactivate());
    }

    if (_pInPlaceObject)
    {
        IGNORE_HR(_pInPlaceObject->InPlaceDeactivate());
    }

    if (_PNS._dwCookie)
    {
        DisconnectSink(_pObject, IID_IPropertyNotifySink, &_PNS._dwCookie);
        Assert(_PNS._dwCookie == 0);
    }

    if (_pObject)
    {
        IViewObject *pVO = NULL;

        if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
        {
            pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL);
            pVO->Release();
        }

        if (_dwCookie)
        {
            IDataObject *pDO = NULL;

            if (OK(_pObject->QueryInterface(IID_IDataObject, (void **)&pDO)))
            {
                pDO->DUnadvise(_dwCookie);
                pDO->Release();
            }

            _dwCookie = 0;
        }

        hr = THR(_pObject->Close(OLECLOSE_NOSAVE));
        if (hr)
            goto Cleanup;
    }

    ClearInterface(&_pBrowser);
    ClearInterface(&_pInPlaceObject);
    ClearInterface(&_pInPlaceActiveObject);
    ClearInterface(&_pObject);
    ClearInterface(&_pMk);

    _fOpenURL = FALSE;

    _lReadyState = READYSTATE_UNINITIALIZED;

Cleanup:
    //  Reset doc title
    SetDocTitle(NULL);

    RRETURN(hr);
}

HRESULT
CPadDoc::Activate(IOleObject *pObject)
{
    PerfLog(tagPerfWatchPad, this, "+CPadDoc::Activate");

    HRESULT hr;
    RECT rc;

    // Activate the new object.

    Assert(!_pObject);
    _pObject = pObject;
    _pObject->AddRef();

    IViewObject *pVO = NULL;

    if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
    {
        PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (IID_IViewObject Advise)");
        pVO->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, (IAdviseSink *)&_Site);
        pVO->Release();
    }

    IDataObject *pDO = NULL;

    if (OK(_pObject->QueryInterface(IID_IDataObject, (void **)&pDO)))
    {
        PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (IID_IDataObject Advise)");
        pDO->DAdvise(&s_FormatEtcMF, ADVF_NODATA, (IAdviseSink *)&_Site, &_dwCookie);
        pDO->Release();
    }

    GetViewRect(&rc, TRUE);

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (DoVerb OLEIVERB_SHOW)");
    hr = THR(_pObject->DoVerb(
            OLEIVERB_SHOW,
            NULL,
            &_Site,
            0,
            _hwnd,
            ENSUREOLERECT(&rc)));
    if (hr)
        goto Cleanup;

    Assert(_PNS._dwCookie == 0);

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (ConnectSink IID_IPropertyNotifySink)");
    hr = THR(ConnectSink(_pObject, IID_IPropertyNotifySink, &_PNS,
            &_PNS._dwCookie));
    if (hr)
        goto Cleanup;

    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (UpdateToolbarUI)");
    UpdateToolbarUI();
    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (SetupComposeFont)");
    SetupComposeFont();
    // Use the correct default block element.
    PerfLog(tagPerfWatchPad, this, "CPadDoc::Activate (SetupDefaultBlock)");
    SetupDefaultBlock();

Cleanup:
    PerfLog(tagPerfWatchPad, this, "-CPadDoc::Activate");
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDocPNS::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPadDocPNS, CPadDoc, _PNS)

STDMETHODIMP
CPadDocPNS::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDocPNS::OnChanged
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP CPadDocPNS::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
    {
        MyCPadDoc()->OnReadyStateChange();
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::OnReadyStateChange
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void CPadDoc::OnReadyStateChange()
{
    HRESULT     hr = S_OK;
    CVariant    Var;
    IDispatch * pdisp = NULL;
    LONG        lReadyState;

    _pObject->QueryInterface(IID_IDispatch, (void **)&pdisp);

    if (pdisp == NULL)
        return;

    hr = GetDispProp(pdisp, DISPID_READYSTATE, 0, &Var, NULL);
    pdisp->Release();
    if (hr)
        return;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        lReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        lReadyState = V_I2(&Var);
    }
    else
    {
        return;
    }

    if (_lReadyState == lReadyState)
        return;

    _lReadyState = lReadyState;

    if (!_fDisablePadEvents && _lReadyState == READYSTATE_COMPLETE)
    {
        FireEvent(DISPID_PadEvents_DocLoaded, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::Save
//
//  Synopsis:   This function saves the document to given file name without
//              displaying a dialog. It changes current document name to given
//              name.
//
//----------------------------------------------------------------------------

HRESULT
CPadDoc::Save(LPCTSTR szFileName)
{
    HRESULT            hr = S_OK;
    IPersistFile *    pPF = NULL;

    if ( ! _pObject )
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistFile, (void **)&pPF));
    if (hr)
        goto Cleanup;

    hr = THR(pPF->Save(szFileName, TRUE));
    if (hr)
        goto Cleanup;

    hr = THR(pPF->SaveCompleted(NULL));
    if (hr)
        goto Cleanup;

    _fInitNew = FALSE;

Cleanup:
    ReleaseInterface(pPF);
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
// Member:    CPadDoc::Init
//
// Synopsis:
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::Init(int nCmdShow, CEventCallBack * pEvent)
{
    HRESULT     hr = S_OK;

    _pEvent = pEvent;

    // Ensure that the common control DLL is loaded for status window.
    InitCommonControls();

    _hmenuMain = LoadMenu(g_hInstResource, MAKEINTRESOURCE(GetMenuID()));
    _hmenuEdit = LoadMenu(g_hInstResource, MAKEINTRESOURCE(IDR_PADMENU_EDIT));
    hr = THR(RegisterPadWndClass());
    if(hr)
        goto Cleanup;

    CreateWindowEx(
            0,
            SZ_PAD_WNDCLASS,
            SZ_APPLICATION_NAME,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL,
            NULL,
            g_hInstCore,
            this);

    if (!_hwnd)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    SetWindowPosition();

    CreateToolBarUI();

    // Create the status window.
    _hwndStatus = CreateWindowEx(
            0,                       // no extended styles
            STATUSCLASSNAME,         // name of status window class
            (LPCTSTR) NULL,          // no text when first created
            SBARS_SIZEGRIP |         // includes a sizing grip
            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,   // creates a child window
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            _hwnd,                   // handle to parent window
            (HMENU) 0,               // child window identifier
            g_hInstCore,             // handle to application instance
            NULL);                   // no window creation data
    if (!_hwndStatus)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    this->ShowWindow(nCmdShow);

    SetForegroundWindow(_hwnd);

    SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, _fUseShdocvw);

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::RegisterPadWndClass()
{
    if(!s_fPadWndClassRegistered)
    {
        LOCK_GLOBALS;

        HDC hdc = GetDC(NULL);
        s_fPaletteDevice = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
        extern HRESULT InitPalette();
        InitPalette();
        ReleaseDC(NULL, hdc);

        if(!s_fPadWndClassRegistered)
        {
            WNDCLASS    wc;

            memset(&wc, 0, sizeof(wc));
            wc.lpfnWndProc = CPadDoc::WndProc;                                                                            // windows of this class.
            wc.hInstance = g_hInstCore;
            wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
            wc.lpszMenuName =  MAKEINTRESOURCE(IDR_PADMENU);
            wc.lpszClassName = SZ_PAD_WNDCLASS;
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

            if (!RegisterClass(&wc))
            {
                return E_FAIL;
            }
            s_fPadWndClassRegistered = TRUE;
        }
    }
    return S_OK;
}

void
CPadDoc::SetStatusText(LPCTSTR pchStatusText)
{
    TCHAR * pchar;

    if (!_fDisablePadEvents)
    {
        if (_pEvent && pchStatusText && *pchStatusText)
        {
            _pEvent->Event(pchStatusText);
        }

        FireEvent(DISPID_PadEvents_Status, pchStatusText);
    }

    if ((!pchStatusText || _tcscmp(pchStatusText, _T("Ready")) == 0) &&
        _pScriptSite &&
        _pScriptSite->_achPath[0])
    {
        TCHAR achBuf[MAX_PATH];
        TCHAR *pch;

        _tcscpy(achBuf, _T("Script: "));
        pch = _tcsrchr(_pScriptSite->_achPath, FILENAME_SEPARATOR);
        _tcscat(achBuf, pch ? pch + 1 : _pScriptSite->_achPath);
        SetWindowText(_hwndStatus, achBuf);

        pchar = achBuf;
    }
    else
    {
        SetWindowText(_hwndStatus, pchStatusText);

        pchar = const_cast<TCHAR *>(pchStatusText);
    }

    if (IsTagEnabled(tagStatus))
    {
        char    achStatus[256]= "";   // for log status
        if (pchar)
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchar,
                    _tcslen(pchar),
                    achStatus,
                    256,
                    NULL,
                    NULL);
        }
        TraceTag((tagStatus, "%s", achStatus));
    }
}

void
CPadDoc::GetViewRect(RECT *prc, BOOL fIncludeObjectAdornments)
{
    RECT rcToolbar;
    RECT rcFormatToolbar;
    RECT rcStatus;

    GetClientRect(_hwnd, prc);

    if (_hwndToolbar)
    {
        GetWindowRect(_hwndToolbar, &rcToolbar);
        prc->top += rcToolbar.bottom - rcToolbar.top;
    }
    if ((_hwndFormatToolbar) && ( ! _fToolbarhidden) )
    {
        GetWindowRect(_hwndFormatToolbar, &rcFormatToolbar);
        prc->top += rcFormatToolbar.bottom - rcFormatToolbar.top;
    }

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    if (fIncludeObjectAdornments)
    {
        if ( !_fToolbarhidden )
        {
            prc->top    += (_bwToolbarSpace.top * 2) ;
            prc->bottom -= (_bwToolbarSpace.bottom * 2) ;
            prc->left   += ( _bwToolbarSpace.left * 2)  ;
            prc->right  -= ( _bwToolbarSpace.right * 2);
        }
        else
        {
            prc->top    += _bwToolbarSpace.top  ;
            prc->bottom -= _bwToolbarSpace.bottom ;
            prc->left   += _bwToolbarSpace.left ;
            prc->right  -= _bwToolbarSpace.right ;
        }

    }

    if (prc->bottom < prc->top)
        prc->bottom = prc->top;

    if (prc->right < prc->left)
        prc->right = prc->left;
}

void
CPadDoc::SendAmbientPropertyChange(DISPID dispid)
{
    IOleControl *pControl;

    if ( _pObject &&
         OK(_pObject->QueryInterface(IID_IOleControl, (void **)&pControl)))
    {
        pControl->OnAmbientPropertyChange(dispid);
        pControl->Release();
    }
}

void
CPadDoc::Resize()
{
    RECT rc;

    GetViewRect(&rc, TRUE);

    if (_pView)
    {
        // It's an ActiveX Document.

        IGNORE_HR(_pView->SetRect(&rc));
    }
    else if (_pInPlaceObject)
    {
        // It's an ActiveX Control.

        SIZEL sizel;

        HDC hdc = GetDC(_hwnd);
        sizel.cx = MulDiv(rc.right - rc.left, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
        sizel.cy = MulDiv(rc.bottom - rc.top, 2540, GetDeviceCaps(hdc, LOGPIXELSY));
        ReleaseDC(_hwnd, hdc);

        IGNORE_HR(_pObject->SetExtent(DVASPECT_CONTENT, &sizel));
        IGNORE_HR(_pInPlaceObject->SetObjectRects(ENSUREOLERECT(&rc), ENSUREOLERECT(&rc)));
    }
}

LRESULT
CPadDoc::OnClose()
{
    if (QuerySave(SAVEOPTS_PROMPTSAVE) == S_OK)
    {
        this->ShowWindow(SW_HIDE);
    }
    return 0;
}

LRESULT
CPadDoc::OnDestroy()
{
    if (_pInPlaceObject)
    {
        IGNORE_HR(_pInPlaceObject->InPlaceDeactivate());
    }

    Assert(_PNS._dwCookie == 0);

    ClearInterface(&_pObject);

    if (_fVisible)
    {
        _fVisible = FALSE;
        Release();
    }
    return 0;
}

LRESULT
CPadDoc::OnActivate(WORD wFlags)
{
    HRESULT hr;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    SetControlPaletteOwner(_hwnd);
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    if (_pInPlaceActiveObject)
    {
        hr = THR(_pInPlaceActiveObject->OnFrameWindowActivate(wFlags != WA_INACTIVE));
    }

    _fActive = (wFlags != WA_INACTIVE);

    return 0;
}

LRESULT
CPadDoc::OnSize(WORD fwSizeType, WORD nWidth, WORD nHeight)
{
    RECT rc;

    if (_hwndToolbar)
    {
        PostMessage(_hwndToolbar, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }
    if ( (_hwndFormatToolbar) && ( ! _fToolbarhidden ))
    {
        PostMessage(_hwndFormatToolbar, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }
    if (_hwndStatus)
    {
        PostMessage(_hwndStatus, WM_SIZE, fwSizeType, MAKELONG(nWidth, nHeight));
    }

    GetViewRect(&rc, FALSE);
    if (_pInPlaceActiveObject)
    {
        THR_NOTRACE(_pInPlaceActiveObject->ResizeBorder(
                ENSUREOLERECT(&rc),
                &_Frame,
                TRUE));
    }

    Resize();

    return 0;
}

void
CPadDoc::UpdateFontSizeBtns(IOleCommandTarget *pCommandTarget)
{
    VARIANTARG var;
    MSOCMD msocmd;
    HRESULT hr;

    _iZoom = _iZoomMax = _iZoomMin = 0;
    msocmd.cmdID = OLECMDID_ZOOM;
    msocmd.cmdf  = 0;

    hr = pCommandTarget->QueryStatus(
            NULL,
            1,
            &msocmd,
            NULL);
    if (hr)
        goto Cleanup;

    if (msocmd.cmdf && msocmd.cmdf != MSOCMDSTATE_DISABLED)
    {
        var.vt   = VT_I4;
        var.lVal = 0;
        pCommandTarget->Exec(
                NULL,
                OLECMDID_ZOOM,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &var);
        if (var.vt == VT_I4)
            _iZoom = var.lVal;

        var.vt   = VT_I4;
        var.lVal = 0;
        pCommandTarget->Exec(
                NULL,
                OLECMDID_GETZOOMRANGE,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                NULL,
                &var);
        if (var.vt == VT_I4)
        {
            _iZoomMin = (int)(short)LOWORD(var.lVal);
            _iZoomMax = (int)(short)HIWORD(var.lVal);
        }
    }

Cleanup:
    SendMessage(
            _hwndToolbar,
            TB_ENABLEBUTTON,
            IDM_PAD_FONTINC,
            (LPARAM) MAKELONG((_iZoom < _iZoomMax), 0));
    SendMessage(
            _hwndToolbar,
            TB_PRESSBUTTON,
            IDM_PAD_FONTINC,
            (LPARAM) MAKELONG(FALSE, 0));
    SendMessage(
            _hwndToolbar,
            TB_ENABLEBUTTON,
            IDM_PAD_FONTDEC,
            (LPARAM) MAKELONG((_iZoom > _iZoomMin), 0));
    SendMessage(
            _hwndToolbar,
            TB_PRESSBUTTON,
            IDM_PAD_FONTDEC,
            (LPARAM) MAKELONG(FALSE, 0));
}


struct MsoCmdInfo {
        UINT localIDM;
        UINT MsoCmdIDM;
        const GUID * MsoCmdGUID;
};

BOOL
CPadDoc::IsDebugWindowVisible()
{
    return _pDebugWindow->_hwnd && IsWindowVisible(_pDebugWindow->_hwnd);
}

void
CPadDoc::ToggleDebugWindowVisibility()
{
    HRESULT hr;

    if (_pDebugWindow == NULL)
    {
        _pDebugWindow = new CDebugWindow (this);

        hr = THR(_pDebugWindow->Init());
        if(hr)
        {
            delete _pDebugWindow;
            _pDebugWindow = NULL;
            return;
        }
    }

    ::ShowWindow(_pDebugWindow->_hwnd, IsDebugWindowVisible() ? SW_HIDE : SW_SHOW);
}



static INT_PTR CALLBACK
WelcomeProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CPadDoc *pDoc = (CPadDoc *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        break;

    case WM_COMMAND:
        pDoc->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                        GET_WM_COMMAND_ID(wParam, lParam),
                        GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_ERASEBKGND:
        SendMessage(pDoc->_hwnd, msg, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
CPadDoc::Welcome()
{
    Assert(!_hwndWelcome);
    _hwndWelcome = CreateDialogParam(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_WELCOME_DLG),
            _hwnd,
            &WelcomeProc,
            (LPARAM)this);
}

LRESULT
CPadDoc::OnCommand(WORD wNotifyCode, WORD idm, HWND hwndCtl)
{
    HRESULT hr = S_OK;
    IOleCommandTarget *pCommandTarget = NULL;
    DWORD               nCmdexecopt = MSOCMDEXECOPT_DONTPROMPTUSER;

    static const MsoCmdInfo CmdInfo[] = {
            { IDM_PAD_STOP,       OLECMDID_STOP,      NULL         },
            { IDM_PAD_PRINT,      OLECMDID_PRINT,     NULL         },
            { IDM_PAD_PAGESETUP,  OLECMDID_PAGESETUP, NULL         },
            { IDM_PAD_CUT,        OLECMDID_CUT,       NULL         },
            { IDM_PAD_COPY,       OLECMDID_COPY,      NULL         },
            { IDM_PAD_PASTE,      OLECMDID_PASTE,     NULL         },
            { IDM_PAD_SAVE,       OLECMDID_SAVE,      NULL         },
            { IDM_PAD_SAVEAS,     OLECMDID_SAVEAS,    NULL         },
            { IDM_LAUNCHDEBUGGER, IDM_LAUNCHDEBUGGER, &CGID_MSHTML },
            { IDM_PAD_PRINTPREVIEW, OLECMDID_PRINTPREVIEW, NULL    },
            { IDM_PAD_TESTTEMPLATES, OLECMDID_PRINTPREVIEW, NULL    },
            { 0, 0, NULL }
    };

    switch (idm)
    {
    case IDM_PAD_USESHDOCVW:
        _fUseShdocvw = !_fUseShdocvw;
        SendMessage(_hwndToolbar, TB_CHECKBUTTON, (WPARAM)IDM_PAD_USESHDOCVW, (LPARAM)MAKELONG(_fUseShdocvw, 0));
        break;

    case IDM_PAD_BACK:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoBack());
            ApplyZoomPercent();
        }
        return 0;

    case IDM_PAD_FORWARD:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoForward());
            ApplyZoomPercent();
        }
        return 0;

    case IDM_PAD_HOME:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoHome());
        }
        break;

    case IDM_PAD_FIND:
        if (_pBrowser)
        {
            hr = THR(_pBrowser->GoSearch());
        }
        break;

    case IDM_PAD_CLOSE:
        CloseFile();
        CloseScripts();
        UnregisterLocalCLSIDs();
        CoFreeUnusedLibraries();
        break;

    case IDM_PAD_EXIT:
        SendMessage(_hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        break;

    case IDM_PAD_NEW_HTML:
        hr = THR(QuerySave(SAVEOPTS_PROMPTSAVE));
        if ( hr )
            goto Cleanup;

        hr = THR(Open(CLSID_HTMLDocument));
        if ( hr )
            goto Cleanup;
        break;

    case IDM_PAD_OPEN_FILE:
        hr = THR(PromptOpenFile(_hwnd, &CLSID_HTMLDocument));
        break;

    case IDM_PAD_OPEN_URL:
        hr = THR(PromptOpenURL(_hwnd, &CLSID_HTMLDocument));
        break;

    case IDM_PAD_OPENNSCP:
        hr = THR(PromptOpenFile(_hwnd, &CLSID_NSCP));
        break;

    case IDM_PAD_EXECUTE_SCRIPT:
        hr = THR(PromptExecuteScript(FALSE));
        break;

    case IDM_PAD_EXECUTE_DRT:
        hr = THR(ExecuteDRT());
        break;

    case IDM_PAD_SAVE:
        hr = THR(DoSave(FALSE));
        if ( hr == OLECMDERR_E_CANCELED )
        {
            hr = S_OK;
        }
        break;

    case IDM_PAD_EDITBROWSE:
        IHTMLDocument2 *pOmDoc;

        if (_pObject && S_OK == get_Document((LPDISPATCH *)&pOmDoc))
        {
            _fUserMode = !_fUserMode;

            pOmDoc->put_designMode(_fUserMode ? _T("off") : _T("on"));
            pOmDoc->Release();
            UpdateFormatToolbar();
        }
        break;

    case IDM_PAD_ABOUT:
        #define STRINGIZE2(a) #a
        #define STRINGIZE1(a) _T(STRINGIZE2(a))
        MessageBoxA(
            _hwnd,
            "Microsoft Trident Version " VER_PRODUCTVERSION_STR
            "\r\r"
            "/register - Register Pad Document\r"
            "/mail - Register Trident Exchange Form\r"
            "/nomail - Unregister Trident Exchange Form\r"
            "/local - Register Local MSHTML\r"
            "/system - Register System MSHTML\r"
            "/s - Do not display success message for above commands\r"
            "/n - Open new document\r"
            "/k - Keep running after script completes\r"
            "/l <fname> - Use <fname> to store log\r"
            "/x <fname> - Execute script in <fname>\r"
            "/e <fname> - Open <fname> in edit mode\r"
            "/g <fname> - Open <fname> in script generator mode\r"
            "/trace - Show trace dialog\r"
            "/shdocvw - Host shdocvw in Pad\r"
            "/loadsystem - Load MSHTML from system directory\r"
            "/nopreload - don't pre-load local DLLs (use registered DDLs, not local)\r",
            "About HTMLPad",
            MB_APPLMODAL | MB_OK);
        break;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    case IDM_PAD_TOOLBOX:
        ToggleControlPaletteVisibility();
        break;
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    case IDM_PAD_SHOWGLYPHS:
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            hr = pCommandTarget->Exec(
                    &CGID_MSHTML,
                    IDM_SHOWALLTAGS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);

            pCommandTarget->Release();
        }
        break;

    case IDM_PAD_DISABLE_IME_RECONVERSION:
        EnableIMEReconversion(FALSE);
        break;

    case IDM_PAD_ENABLE_IME_RECONVERSION:
        EnableIMEReconversion(TRUE);
        break;

    case IDM_PAD_IMMEDIATE_WINDOW:
        ToggleDebugWindowVisibility();
        break;

    case IDM_PAD_SCRUB:
        ScrubRegistry();
        break;

    case IDM_PAD_REGISTER_PAD:
        hr = THR(RegisterPad());
        break;

    case IDM_PAD_REGISTER_LOCAL_TRIDENT:
        hr = THR(RegisterTrident(_hwnd, TRUE, FALSE));
        break;

    case IDM_PAD_REGISTER_SYSTEM_TRIDENT:
        hr = THR(RegisterTrident(_hwnd, TRUE, TRUE));
        break;

    case IDM_PAD_DEBUG_TRACE:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExDoTracePointsDialog(FALSE);
        }
        break;

    case IDM_PAD_VIEW_MON:
        if (_pObject)
        {
            DbgExOpenViewObjectMonitor(_hwnd, _pObject, TRUE);
        }
        break;

    case IDM_PAD_MEM_MON:
        DbgExOpenMemoryMonitor();
        break;

    case IDM_PAD_METERS:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExMtOpenMonitor();
        }
        break;

    case IDM_PAD_PERFTAGS:
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExPerfTags();
        }
        break;

    case IDM_PAD_NEWWIN:
        {
            CThreadProcParam tpp(_fUseShdocvw);
            hr = THR(CreatePadDoc(&tpp, NULL));
        }
        break;

    case IDM_PAD_CLEAR_CACHE:
        hr = THR(ClearDownloadCache());
        break;

    case IDM_PAD_REFRESH:
        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            VARIANT var;

            VariantInit(&var);
            var.vt = VT_I4;

            if (GetAsyncKeyState(VK_CONTROL) < 0)
                var.lVal = OLECMDIDF_REFRESH_COMPLETELY;
            else
                var.lVal = OLECMDIDF_REFRESH_NO_CACHE;

            hr = pCommandTarget->Exec(NULL, OLECMDID_REFRESH,
                    MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);

            pCommandTarget->Release();
        }

        if (_pEvent)
            _pEvent->Event(_T("Refresh"), TRUE);

        break;


    case IDM_PAD_TESTTEMPLATES:
        // ISSUE: TODO: (carled) temporary code...  This is here for testing purposes
        // so that we can specify the template to be used.
        {
            if (   _pInPlaceObject
                && OK(_pInPlaceObject->QueryInterface(IID_IOleCommandTarget,
                                                      (void **)&pCommandTarget))
               )
            {
                int i;

                for (i = 0; CmdInfo[i].localIDM && CmdInfo[i].localIDM != idm; i ++);

                if (CmdInfo[i].localIDM)
                {
                    OPENFILENAME    ofn;
                    static TCHAR achPath[MAX_PATH] = _T("");
                    static TCHAR achStartDir[MAX_PATH] = _T("");

#if !defined(WINCE)
                    if (    !achPath[0]
                        &&  !achStartDir[0]
                        &&  GetEnvironmentVariable(_T("PAD_DEFAULTFILEDIR"), achStartDir, MAX_PATH))
                    {
                        if (_tcscmp(achStartDir, _T("CurrentDir")) == 0)
                        {
                            GetCurrentDirectory(MAX_PATH, achStartDir);
                        }
                    }
#endif

                    if (!achPath[0] && !achStartDir[0])
                    {
                        char achStartDirA[MAX_PATH] = "";
                        GetPrivateProfileStringA("PadDirs","FileDir","",achStartDirA,MAX_PATH, "mshtmdbg.ini");

                        if (achStartDirA[0])
                        {
                            MultiByteToWideChar(CP_ACP, 0, achStartDirA, MAX_PATH, achStartDir, MAX_PATH);
                        }
                    }

                    if (!achPath[0] && !achStartDir[0])
                    {
                        // Prime file name with samples directory.

                        // Start with the directory containing this file.

                        _tcscpy(achStartDir, _T(__FILE__));

                        // Chop off the name of this file and three directories.
                        // This will leave the root of our SLM tree in achPath.

                        if ( ! _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR))) {
                            achStartDir[0] = (TCHAR)0;

                        } else {

                            for (int i = 0; i < 4; i++)
                                {
                                    TCHAR *pch = _tcsrchr(achStartDir, _T(FILENAME_SEPARATOR));
                                    if (pch)
                                        *pch = 0;
                                }
                        }

                        // Append the name of the directory containing the samples.

                        _tcscat(achStartDir, _T(FILENAME_SEPARATOR_STR) _T("src")
                                             _T(FILENAME_SEPARATOR_STR) _T("f3")
                                             _T(FILENAME_SEPARATOR_STR) _T("drt")
                                             _T(FILENAME_SEPARATOR_STR) _T("samples"));
                    }

                    memset(&ofn, 0, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner   = _hwnd;
                    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0Text files (*.txt)\0*.txt\0Dialogs (*.fmd)\0*.fmd\0All Files (*.*)\0*.*\0");
                    ofn.lpstrFile   = achPath;
                    ofn.lpstrInitialDir = *achPath ? NULL : achStartDir;
                    ofn.lpstrDefExt = TEXT("htm");
                    ofn.nMaxFile    = ARRAY_SIZE(achPath);
                    ofn.Flags       = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

                    if (IsTagEnabled(tagPPVTemplateOverride))
                    {
                        if (!GetEnvironmentVariable(_T("TRIDENT_PPVPATH"), achPath, ARRAY_SIZE(achPath)))
                        {
                            _tcscpy( achPath, _T("c:\\temp\\preview.dlg") );
                        }
                    }
                    else
                    {
                        DbgMemoryTrackDisable(TRUE);
                        hr = ( GetOpenFileName(&ofn) ? S_OK : S_FALSE);
                        DbgMemoryTrackDisable(FALSE);
                    }

                    if (SUCCEEDED(hr))
                    {
                        CVariant cvarArgIn;
                        V_VT(&cvarArgIn) = VT_BSTR;
                        V_BSTR(&cvarArgIn) = SysAllocString(achPath);
/*
                        // Testing the PrintHTML api
                        char achTemp[6000];

                        memset(achTemp, 0, 6000);
                        if (WideCharToMultiByte(CP_ACP, 0, achPath, -1, achTemp, 6000, 0, NULL))
                        {
                            static DYNPROC s_dynprocPrintHTML =
                                    { NULL, &g_dynlibPrintHTML, "PrintHTML" };

                            if (THR(LoadProcedure(&s_dynprocPrintHTML)))
                                return FALSE;

                            (*(BOOL (APIENTRY *)(HINSTANCE, HINSTANCE, LPSTR, int))s_dynprocPrintHTML.pfn)
                                    (NULL, NULL, achTemp, 0);
                        }
*/
                        hr = pCommandTarget->Exec(
                                        CmdInfo[i].MsoCmdGUID,
                                        CmdInfo[i].MsoCmdIDM,
                                        idm == IDM_PAD_PRINT ? 0 : MSOCMDEXECOPT_DONTPROMPTUSER,
                                        &cvarArgIn,
                                        NULL);

                    }
                    else if (hr == S_FALSE)
                        hr = S_OK;  // mask cancel from the file open dialog
                }
                pCommandTarget->Release();
            }
        }
        break;

    case IDM_PAD_PRINTPREVIEW:  // Just fall through and delegate
    case IDM_PAD_CUT:
    case IDM_PAD_COPY:
    case IDM_PAD_PASTE:
    case IDM_PAD_PAGESETUP:
    case IDM_PAD_PRINT:
    case IDM_PAD_STOP:
    case IDM_LAUNCHDEBUGGER:


        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            int i;

            for (i = 0; CmdInfo[i].localIDM && CmdInfo[i].localIDM != idm; i ++);
            if (CmdInfo[i].localIDM) // CmdInfo[i].localIDM == idm
            {
                hr = pCommandTarget->Exec(
                        CmdInfo[i].MsoCmdGUID,
                        CmdInfo[i].MsoCmdIDM,
                        idm == IDM_PAD_PRINT ? 0 : MSOCMDEXECOPT_DONTPROMPTUSER,
                        NULL,
                        NULL);

            }
            pCommandTarget->Release();
        }
        break;

#if CICERO==1
    case IDM_PAD_TOGGLE_CICERO:
    // Toggle Cicero:
    {
        ToggleCicero();
        break;
    }
#endif

    case IDM_IMAGE:
    case IDM_INSERTOBJECT:
    case IDM_FONT:
    case IDM_FIND :
    case IDM_REPLACE :
    case IDM_HYPERLINK :
          nCmdexecopt = 0;
                        // fall thru.

    //
    // Edit Menu
    //
    case IDM_UNDO :
    case IDM_REDO :
    case IDM_CUT :
    case IDM_COPY :
    case IDM_PASTE :
    case IDM_PASTEINSERT :
    case IDM_DELETE :
    case IDM_SELECTALL :

    case IDM_BOOKMARK :

    case IDM_UNLINK :
    case IDM_UNBOOKMARK :

    //
    // View Menu
    //

    case IDM_TOOLBARS :
    case IDM_STATUSBAR :
    case IDM_FORMATMARK :
    case IDM_TEXTONLY :
    case IDM_VIEWSOURCE:
    case IDM_BASELINEFONT5 :
    case IDM_BASELINEFONT4 :
    case IDM_BASELINEFONT3 :
    case IDM_BASELINEFONT2 :
    case IDM_BASELINEFONT1 :
    case IDM_EDITSOURCE :
    case IDM_FOLLOWLINKC :
    case IDM_FOLLOWLINKN :
    case IDM_PROPERTIES :
    case IDM_OPTIONS :

    //
    //
    // Insert Menu
    //
    case IDM_HORIZONTALLINE:
    case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_PAGEBREAK:
        case IDM_SPECIALCHAR:
        case IDM_MARQUEE:
        case IDM_1D:
        case IDM_TEXTBOX:
        case IDM_TEXTAREA:
#ifdef NEVER
        case IDM_HTMLAREA:
#endif
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:

        case IDM_IFRAME:

    //
    // Format Menu
    //
    case IDM_DIRLTR:
    case IDM_DIRRTL:
    case IDM_BLOCKDIRLTR:
    case IDM_BLOCKDIRRTL:

    case IDM_INDENT:
        case IDM_OUTDENT:

        {
       if ( IsEdit())
       {
            if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
            {

                hr = pCommandTarget->Exec(
                        (GUID *)&CGID_MSHTML,
                        idm,
                        nCmdexecopt,
                        NULL,
                        NULL);

                pCommandTarget->Release();
             }

        }
        }
        break;

    case IDM_PAD_SAVEAS:
        hr = THR(DoSave(TRUE));
        if ( hr == OLECMDERR_E_CANCELED )
        {
            hr = S_OK;
        }
        break;

    case IDM_PAD_VERIFYHTML_BODY:
        GetScriptRecorder()->VerifyHTML(TS_Body);
        break;

    case IDM_PAD_VERIFYHTML_CUR_BLOCK:
        GetScriptRecorder()->VerifyHTML(TS_CurrentElement);
        break;

    case IDM_PAD_RELOADHIST:
        hr = THR(DoReloadHistory());
        break;

    case IDM_ZOOMPERCENT:
        hr = OnStandardCombobox(wNotifyCode, idm, hwndCtl );
        break;

    case IDM_BLOCKFMT:
    case IDM_FONTSIZE:
    case IDM_FONTNAME:
    case IDM_FORECOLOR:
    {
        hr = OnFormatCombobox(wNotifyCode, idm, hwndCtl );
    }

    // fall through

    case IDM_PAD_FONTINC:
    case IDM_PAD_FONTDEC:
        VARIANTARG var;
        BOOL       fExec = TRUE;

        if ( _pInPlaceObject &&
             OK(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget)) )
        {
            var.vt = VT_I4;
            var.lVal = 0;
            hr = pCommandTarget->Exec(
                    NULL,
                    OLECMDID_ZOOM,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    &var);
            if (hr)
                goto Cleanup;

            if (var.vt == VT_I4)
                _iZoom = var.lVal;

            if (idm == IDM_PAD_FONTINC && _iZoom < _iZoomMax)
            {
                var.lVal = _iZoom + 1;
            }
            else if (idm == IDM_PAD_FONTDEC && _iZoom > _iZoomMin)
            {
                var.lVal = _iZoom - 1;
            }
            else
            {
                fExec = FALSE;
            }

            if (fExec)
            {
                pCommandTarget->Exec(
                        NULL,
                        OLECMDID_ZOOM,
                        MSOCMDEXECOPT_DONTPROMPTUSER,
                        &var,
                        NULL);
            }

            pCommandTarget->Release();
        }

        break;
    }



Cleanup:
    if (hr)
    {
        CheckError(_hwnd, hr);
    }
    return 0;
}

HRESULT
CPadDoc::OnFormatCombobox(WORD wNotifyCode, WORD idm, HWND hwndCtl )
{
    BOOL fRestoreFocus = FALSE ;
    VARIANTARG  var;
    TCHAR achBuffer[64];
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr = S_OK;
    VARIANTARG *pvarIn  = NULL;

    switch (idm)
    {
    case IDM_FONTSIZE:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        GetWindowText(
                _hwndComboSize,
                achBuffer,
                ARRAY_SIZE(achBuffer));
        V_VT(&var)   = VT_I4;
        V_I4(&var) = _wtoi(achBuffer);
        pvarIn   = &var;
        break;

    case IDM_BLOCKFMT:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        *(DWORD *)achBuffer =
        GetWindowText(
                _hwndComboTag,
                achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                ARRAY_SIZE(achBuffer) - sizeof(DWORD) / sizeof(TCHAR));
        V_VT(&var)      = VT_BSTR;
        THR(FormsAllocString(achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                             &V_BSTR(&var)));
        pvarIn      = &var;
        break;

    case IDM_FONTNAME:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        *(DWORD *)achBuffer =
        GetWindowText(
                _hwndComboFont,
                achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                ARRAY_SIZE(achBuffer) - sizeof(DWORD) / sizeof(TCHAR));
        V_VT(&var)      = VT_BSTR;
        THR(FormsAllocString(achBuffer + sizeof(DWORD) / sizeof(TCHAR),
                             &V_BSTR(&var)));
        pvarIn      = &var;
        break;

    case IDM_FORECOLOR:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        V_I4(&var) = SendMessage(
                _hwndComboColor,
                CB_GETITEMDATA,
                (WPARAM) SendMessage(_hwndComboColor, CB_GETCURSEL, 0, 0),
                0);
        V_VT(&var)   = VT_I4;
        pvarIn      = &var;
        break;

    }

    if ( !_pInPlaceObject )
        goto Cleanup;
    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    hr = pCommandTarget->Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL);

    //
    // When the user selects a combo item, pop the focus pack into the document.
    //
    if (fRestoreFocus)
    {
        HWND    hWndInPlace;

        _pInPlaceObject->GetWindow(&hWndInPlace);
        if (hWndInPlace)
        {
            ::SetFocus (hWndInPlace);
        }

        //else
            //SetFocus (TRUE);
    }

Cleanup:
    if ( pCommandTarget) pCommandTarget->Release();

    RRETURN ( hr );
}

HRESULT
CPadDoc::OnStandardCombobox(WORD wNotifyCode, WORD idm, HWND hwndCtl )
{
    IOleCommandTarget * pCommandTarget = NULL;
    BOOL                fRestoreFocus = FALSE;
    VARIANTARG          var;
    VARIANTARG          *pvarIn  = NULL;
    WPARAM              wCurSel;
    HRESULT             hr = S_OK;

    switch (idm)
    {
    case IDM_ZOOMPERCENT:
        if (wNotifyCode != CBN_SELENDOK)
            return 0;
        fRestoreFocus = TRUE;
        wCurSel = (WPARAM)::SendMessage(_hwndComboZoom, CB_GETCURSEL, 0, 0);
        if (wCurSel == CB_ERR)
        {
            TCHAR   szText[256];
            DWORD   dwZoomPercent;

            ::SendMessage(_hwndComboZoom, WM_GETTEXT, (WPARAM)(sizeof(szText) / sizeof(szText[0])), (LPARAM)&szText);
            dwZoomPercent = StrToInt(szText);

            if (dwZoomPercent < 1 || dwZoomPercent > 1000)
            {
                HWND    hWndInPlace;
                _pInPlaceObject->GetWindow(&hWndInPlace);

                ::MessageBox(_hwnd,
                    TEXT("The number must be between 1 and 1000."),
                    TEXT("MSHTMLPAD"),
                    MB_ICONEXCLAMATION);

                //  Set default 100%
                dwZoomPercent = 100;
            }

            Format(0, szText, ARRAY_SIZE(szText), TEXT("<0d>%"), dwZoomPercent);
            ::SendMessage(_hwndComboZoom, WM_SETTEXT, 0, (LPARAM)&szText);

            V_I4(&var) = dwZoomPercent;
        }
        else
        {
            V_I4(&var) = ::SendMessage(_hwndComboZoom, CB_GETITEMDATA, wCurSel, 0);
        }

        V_VT(&var)   = VT_I4;
        pvarIn      = &var;
        break;
    }

    if ( !_pInPlaceObject )
        goto Cleanup;
    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    IGNORE_HR(pCommandTarget->Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL));

    //
    // When the user selects a combo item, pop the focus pack into the document.
    //
    if (fRestoreFocus)
    {
        HWND    hWndInPlace;

        _pInPlaceObject->GetWindow(&hWndInPlace);
        if (hWndInPlace)
        {
            ::SetFocus (hWndInPlace);
        }

        //else
            //SetFocus (TRUE);
    }

Cleanup:
    if ( pCommandTarget) pCommandTarget->Release();

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuPopup(HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    if (fSystemMenu)
        return 0;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    CheckMenuItem(
            hmenuPopup,
            IDM_PAD_TOOLBOX,
            IsControlPaletteVisible() ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    static const MsoCmdInfo MenuItemInfo[] = {
            { IDM_PAD_PAGESETUP,    OLECMDID_PAGESETUP, NULL },
            { IDM_PAD_PRINT,        OLECMDID_PRINT,     NULL },
            { IDM_PAD_SHORTCUT,     IDM_UNKNOWN,        NULL },
            { IDM_PAD_PROPERTIES,   IDM_UNKNOWN,        NULL },
            { IDM_PAD_BACK,         IDM_UNKNOWN,        NULL },
            { IDM_PAD_FORWARD,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_UPLEVEL,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_OPTIONS,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_OPENFAVORITE, IDM_UNKNOWN,        NULL },
            { IDM_PAD_ADDFAVORITE,  IDM_UNKNOWN,        NULL },
            { IDM_PAD_SAVE,         OLECMDID_SAVE,      NULL },
            { IDM_PAD_SAVEAS,       OLECMDID_SAVEAS,    NULL },
            { IDM_PAD_SENDFLOPPY,   IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDMAIL,     IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDBRIEFCASE,IDM_UNKNOWN,        NULL },
            { IDM_PAD_SENDWEB,      IDM_UNKNOWN,        NULL },
            { IDM_PAD_PRINTPREVIEW, OLECMDID_PRINTPREVIEW,NULL     },
            { IDM_PAD_TESTTEMPLATES, OLECMDID_PRINTPREVIEW,       NULL },
            { 0, 0, NULL }
    };

    //
    // marka Editing Commands
    //
    static const MsoCmdInfo EditMenuItemInfo[] = {
                { IDM_HORIZONTALLINE,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKNORMAL,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKLEFT,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKRIGHT,   IDM_UNKNOWN, NULL},
                { IDM_LINEBREAKBOTH,   IDM_UNKNOWN, NULL},
                { IDM_NONBREAK,   IDM_UNKNOWN, NULL},
                { IDM_PAGEBREAK,   IDM_UNKNOWN, NULL},
                { IDM_SPECIALCHAR,   IDM_UNKNOWN, NULL},
                { IDM_MARQUEE,   IDM_UNKNOWN, NULL},
                { IDM_1D,   IDM_UNKNOWN, NULL},
                { IDM_TEXTBOX,   IDM_UNKNOWN, NULL},
                { IDM_TEXTAREA,   IDM_UNKNOWN, NULL},
#ifdef NEVER
                { IDM_HTMLAREA,   IDM_UNKNOWN, NULL},
#endif
                { IDM_CHECKBOX,   IDM_UNKNOWN, NULL},
                { IDM_RADIOBUTTON,   IDM_UNKNOWN, NULL},
                { IDM_DROPDOWNBOX,   IDM_UNKNOWN, NULL},
                { IDM_LISTBOX,   IDM_UNKNOWN, NULL},
                { IDM_BUTTON,   IDM_UNKNOWN, NULL},
                { IDM_IMAGE,   IDM_UNKNOWN, NULL},
                { IDM_IFRAME,   IDM_UNKNOWN, NULL},
                { IDM_INSERTOBJECT,   IDM_UNKNOWN, NULL},
            { 0, 0, NULL }
    };

    int cMenuItem;

    HRESULT hr = S_OK;
    MSOCMD msocmd;
    IOleCommandTarget * pCommandTarget;

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    //
    // ISSUE - marka - why loop through all these commands if
    // they're not on the current menu ? leave it for now
    // this will be moved around in beta 2
    //
    for (cMenuItem = 0; MenuItemInfo[cMenuItem].localIDM; cMenuItem ++)
    {
        msocmd.cmdID = MenuItemInfo[cMenuItem].MsoCmdIDM;
        msocmd.cmdf  = 0;

        hr = pCommandTarget->QueryStatus(
            MenuItemInfo[cMenuItem].MsoCmdGUID,
            1,
            &msocmd,
            NULL);

        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
        case MSOCMDF_ENABLED:
            EnableMenuItem(
                    hmenuPopup,
                    MenuItemInfo[cMenuItem].localIDM,
                    MF_ENABLED);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableMenuItem(
                    hmenuPopup,
                    MenuItemInfo[cMenuItem].localIDM,
                    MF_GRAYED);
            break;
        }
    }
    //
    // marka
    //
    switch( uPos )
    {
        case 1:
            OnInitMenuEdit( uPos, hmenuPopup );
            break;
        case 2:
            OnInitMenuView( uPos, hmenuPopup );
            break;
        case 3:
            OnInitMenuInsert( uPos, hmenuPopup );
            break;
        case 4:
            OnInitMenuFormat( uPos, hmenuPopup );
            break;
    }
    pCommandTarget->Release();

Cleanup:
    return 0;
}

LRESULT
CPadDoc::OnInitMenuEdit(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

        UINT    MenuItem [] =  {
        IDM_UNDO,
        IDM_REDO,
        IDM_CUT,
        IDM_COPY,
        IDM_PASTE,
        IDM_PASTEINSERT,
        IDM_DELETE,
        IDM_SELECTALL,
        IDM_FIND,
        IDM_REPLACE,

        IDM_BOOKMARK,
        IDM_HYPERLINK,
        IDM_UNLINK,
        IDM_UNBOOKMARK,
        0
    };

    EnableMenuItems( MenuItem , hmenu);

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuView(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    UINT    MenuItem [] =  {
         IDM_TOOLBARS,
        IDM_STATUSBAR,
        IDM_FORMATMARK,
        IDM_TEXTONLY,
        IDM_VIEWSOURCE,
        IDM_BASELINEFONT5,
        IDM_BASELINEFONT4,
        IDM_BASELINEFONT3,
        IDM_BASELINEFONT2,
        IDM_BASELINEFONT1,
        IDM_PAD_REFRESH,
        IDM_EDITSOURCE,
        IDM_FOLLOWLINKC,
        IDM_FOLLOWLINKN,
        IDM_PROPERTIES,
        IDM_OPTIONS,
        0 };

    EnableMenuItems( MenuItem , hmenu);

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnInitMenuInsert(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    EnableMenuItem(
        hmenu,
        IDM_PAGEBREAK,
        MF_GRAYED);

    EnableMenuItem(
        hmenu,
        IDM_SPECIALCHAR,
        MF_GRAYED);

    RRETURN ( hr );
}

LRESULT CPadDoc::OnInitMenuFormat(UINT uItem, HMENU hmenu)
{
    HRESULT hr = S_OK;

    UINT    MenuItem [] =  {
        IDM_FONT,
        IDM_DIRLTR,
        IDM_DIRRTL,
        IDM_BLOCKDIRLTR,
        IDM_BLOCKDIRRTL,
        IDM_INDENT,
            IDM_OUTDENT,
            0 };

        EnableMenuItems( MenuItem, hmenu );

    RRETURN ( hr );
}

LRESULT
CPadDoc::OnMenuSelect(UINT uItem, UINT fuFlags, HMENU hmenu)
{
    TCHAR achMessage[MAX_PATH];

    if (uItem == 0 && fuFlags == 0xFFFF)
    {
        _tcscpy(achMessage, TEXT("Ready"));
    }
    else if ((fuFlags & (MF_POPUP|MF_SYSMENU)) == 0 && uItem != 0)
    {
        LoadString(g_hInstResource, uItem, achMessage, ARRAY_SIZE(achMessage));
    }
    else
    {
        achMessage[0] = TEXT('\0');
    }

    SetStatusText(achMessage);
    return 0;
}

//+========================================================================
//
// Method: CPadDoc::EnableMenuItems
//
// Given an array of Commands - do a QueryStatus in Trident
// and activate / deactivate the corresponding MenuItem.
//
//-------------------------------------------------------------------------

HRESULT
CPadDoc::EnableMenuItems( UINT * pMenuItem , HMENU hmenuPopup)
{
    int         cMenuItem;
    MSOCMD      msocmd;
    UINT        mf;
    IOleCommandTarget * pCommandTarget =NULL;
    HRESULT hr = S_OK;

    if (! _pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    for (cMenuItem = 0; pMenuItem[cMenuItem]; cMenuItem ++)
    {
        msocmd.cmdID = pMenuItem[cMenuItem];
        msocmd.cmdf  = 0;

        // Only if object is active
        if (_fActive)
        {
            hr = pCommandTarget->QueryStatus(
                    (GUID *)&CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
        }

        switch (msocmd.cmdf)
        {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
        }
        CheckMenuItem(hmenuPopup, msocmd.cmdID, mf);
        EnableMenuItem(hmenuPopup, msocmd.cmdID, mf);
                hr = S_OK;
    }
Cleanup:
    if ( pCommandTarget ) pCommandTarget->Release();

    RRETURN ( hr );
}

LRESULT CALLBACK
ObjectWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CPadDoc * pDoc = (CPadDoc *)GetProp(hwnd, _T("TRIDENT_DOC"));
    LRESULT l;

    if (!pDoc)
    {   // This is very unusual but happens in some scenarios
        // such as running activex.js stand alone.  We are not
        // 100% certain about the cuase but it happens in very
        // deep call stacks during complex shutdown.
        // -Tom
        return( DefWindowProc(hwnd, wm, wParam, lParam) );
    }

    switch(wm)
    {
    case WM_COMMAND:
        // check for justify changes
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDM_JUSTIFYRIGHT:
            case IDM_JUSTIFYLEFT:
            case IDM_JUSTIFYCENTER:
                BOOL fChecked;

                fChecked = SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                       TB_ISBUTTONCHECKED,
                                       (WPARAM)GET_WM_COMMAND_ID(wParam, lParam),
                                       0);

                if (!fChecked)
                    wParam = MAKEWPARAM(IDM_JUSTIFYNONE, LOWORD(wParam));
       }

       break;

    case WM_PAINT:
    {
        long lPaintArea=0;
        RECT rClient = {0};

        if (!pDoc->_fDisablePadEvents)
        {
            if (pDoc->_pEvent)
            {
                pDoc->_pEvent->Event(_T("Paint"));
            }
            pDoc->FireEvent(DISPID_PadEvents_Status, _T("Paint"));

            HRGN hrgn;
            int iRgnType;
            DWORD i;
            RECT rIntersect;

            struct REGION_DATA
            {
                RGNDATAHEADER rdh;
                RECT arc[64];
            } rd;

            Verify((hrgn = CreateRectRgnIndirect(&g_Zero.rc)) != NULL);
            Verify((iRgnType = GetUpdateRgn(hwnd, hrgn, FALSE)) != ERROR);
            Verify(GetClientRect(hwnd, &rClient));
            if (iRgnType != NULLREGION &&
                GetRegionData(hrgn, sizeof(rd), (RGNDATA *)&rd) &&
                rd.rdh.iType == RDH_RECTANGLES &&
                rd.rdh.nCount <= ARRAY_SIZE(rd.arc))
            {
                for (i=0; i<rd.rdh.nCount; i++)
                {
                    if (IntersectRect(&rIntersect, &rClient, &rd.arc[i]))
                    {
                        lPaintArea += (rIntersect.right - rIntersect.left)*(rIntersect.bottom - rIntersect.top);
                    }
                }
            }

            Verify(DeleteObject(hrgn));
        }

        l = CallWindowProc(pDoc->_pfnOrigWndProc, hwnd, wm, wParam, lParam);

        if (!pDoc->_fDisablePadEvents)
        {
            if (lPaintArea)
            {
                VARIANT vargs[2];
                VariantInit(vargs);
                V_VT(vargs) = VT_I4;
                V_I4(vargs) = lPaintArea;
                VariantInit(vargs+1);
                V_VT(vargs+1) = VT_I4;
                V_I4(vargs+1) = rClient.right * rClient.bottom;
                pDoc->FireEvent(DISPID_PadEvents_OnPaint, 2, vargs);
                VariantClear(vargs);
                VariantClear(vargs+1);
            }

            if (pDoc->_pEvent )
            {
                pDoc->_pEvent->Event(_T("After Paint"));
            }
        }

        return l;
        break;
    }
    }
    return CallWindowProc(pDoc->_pfnOrigWndProc, hwnd, wm, wParam, lParam);
}

LRESULT CALLBACK
CPadDoc::WndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CPadDoc * pDoc;

    pDoc = (CPadDoc *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (wm)
    {
    case WM_NCCREATE:
        pDoc = (CPadDoc *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDoc);
        pDoc->_hwnd = hwnd;
        pDoc->SubAddRef();
        break;

    case WM_NCDESTROY:
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        pDoc->_hwnd = NULL;
        pDoc->SubRelease();
        break;

    case WM_GETMINMAXINFO:
        break;

    default:
        if (pDoc)
        {
            LRESULT lResult;

            lResult = pDoc->PadWndProc(hwnd, wm, wParam, lParam);
            return lResult;
        }
    }

    return DefWindowProc(hwnd, wm, wParam, lParam);
}

LRESULT
CPadDoc::PadWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    static UINT g_msgMouseWheel = 0;
    HWND cmdHWND    ;
    switch (wm)
    {
    case WM_SYSCOMMAND:
        if (SC_KEYMENU == (wParam & 0xFFF0) && InSendMessage())
        {
            PostMessage(hwnd, wm, wParam, lParam);
            return 0;
        }
        break;

    case WM_TIMER:
        FireEvent(DISPID_PadEvents_Timer, 0, NULL);
        break;

    case WM_DOKEYACION:
        DoKeyAction();
        break;

    case WM_RUNSCRIPT:
        FireEvent(DISPID_PadEvents_Load, 0, NULL);
        PopScript();
        break;

    case WM_ERASEBKGND:
        if(_pObject)
            return TRUE;
        break;

    case WM_INITMENU:
        _fObjectHelp = FALSE;
        break;

    case WM_INITMENUPOPUP:
        if ((HMENU) wParam == _hmenuObjectHelp)
        {
            HWND hwndDoc;

            _pInPlaceObject->GetWindow(&hwndDoc);
            return SendMessage(hwndDoc, wm, wParam, lParam);
        }
        else
        {

            return OnInitMenuPopup(
                    (HMENU) wParam,
                    LOWORD(lParam),
                    (BOOL) HIWORD(lParam));
        }

    case WM_MENUSELECT:
        UINT fuFlags;
        int  uItem;

        fuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
        uItem   = GET_WM_MENUSELECT_CMD(wParam, lParam);

        // if fuFlag == 0x0000FFFF and (HWND) lParam == NULL, windows closes
        // the popup menu, do nothing.
        //
        if (fuFlags != 0x0000FFFF || GET_WM_MENUSELECT_HMENU(wParam, lParam))
        {
            if (fuFlags & MF_POPUP)
            {
                // selected menu item is a pop-up menu
                if (_hmenuObjectHelp && _hmenuHelp &&
                        _hmenuHelp == GET_WM_MENUSELECT_HMENU(wParam, lParam))
                {
                    _fObjectHelp =
                            (uItem == GetMenuItemCount(_hmenuHelp) - 1);
                }
                else
                {
                    _fObjectHelp = FALSE;
                }
            }
            else
            {
                // selected menu item is a command.

                _fObjectHelp = (GET_WM_MENUSELECT_HMENU(wParam, lParam)== _hmenuObjectHelp);
            }
        }

        if (_fObjectHelp)
        {
            HWND hwndDoc;

            _pInPlaceObject->GetWindow(&hwndDoc);
            return SendMessage(hwndDoc, wm, wParam, lParam);
        }
        else
        {
            return OnMenuSelect(uItem, fuFlags, GET_WM_MENUSELECT_HMENU(wParam, lParam));
        }

    case WM_COMMAND:
        {
            cmdHWND = GET_WM_COMMAND_HWND(wParam, lParam) ;
            if ( (_fObjectHelp && ( cmdHWND != _hwndToolbar) ) || ( cmdHWND == _hwndFormatToolbar) )
            {
                HWND hwndDoc;

                _pInPlaceObject->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
            else
            {
                return OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                 GET_WM_COMMAND_ID(wParam, lParam),
                                 GET_WM_COMMAND_HWND(wParam, lParam));
            }
        }
    case WM_HELP:
        MessageBox(NULL, _T("F1 pressed! If you got here, we bubble onhelp() OK!"), _T("Pad Help Diagnostic"), MB_ICONEXCLAMATION | MB_OK);
        break;

    case WM_DESTROY:
        OnDestroy();
        break;

    case WM_CLOSE:
        return OnClose();

    case WM_ACTIVATE:
        return OnActivate(LOWORD(wParam));

    case WM_SIZE:
        return OnSize((WORD)wParam, LOWORD(lParam), HIWORD(lParam));

#if defined(DBG_TOOLTIPS)
    case WM_NOTIFY:
        // TODO: (jenlc) should be replaced by QueryStatus calls.
        if ((TTN_NEEDTEXTA == ((LPNMHDR) lParam)->code) ||
                (TTN_NEEDTEXTW == ((LPNMHDR) lParam)->code))
        {
            TCHAR           szBuffer[256];
            TCHAR           szTemp[256];
            LPTOOLTIPTEXT   lpTooltipText = (LPTOOLTIPTEXT) lParam;
            int             id = lpTooltipText->hdr.idFrom;

            if (id == IDM_PAD_EDITBROWSE)
                id = _fUserMode ? IDM_PAD_EDIT : IDM_PAD_BROWSE;

            if (id == IDM_PAD_USESHDOCVW)
                id = _fUseShdocvw ? IDM_PAD_UNHOSTSHDOCVW : IDM_PAD_HOSTSHDOCVW;

            LoadString(
                g_hInstResource,
                IDS_TOOLTIP(id),
                szBuffer,
                ARRAY_SIZE(szBuffer));

            DWORD dwVersion;

            dwVersion = GetVersion();
            if (dwVersion >= 0x80000000)
            {
                _tcscpy(szTemp, szBuffer);
                WideCharToMultiByte(
                        CP_ACP,
                        0,
                        szTemp,
                        -1,
                        (char *) szBuffer,
                        sizeof(szBuffer),
                        NULL,
                        NULL);
            }
            lpTooltipText->lpszText = szBuffer;
        }
        break;
#endif

    case WM_PALETTECHANGED:
        if (_hwnd != (HWND)wParam)
            return OnPaletteChanged((HWND)wParam);
        break;
    case WM_QUERYNEWPALETTE:
        return OnQueryNewPalette();
        break;
    default:
        //if (g_msgMouseWheel == 0)
        if (g_msgMouseWheel == 0 && GetVersion() >= 0x80000000)
        {
            g_msgMouseWheel = RegisterWindowMessage(_T("MSWHEEL_ROLLMSG"));
        }
        if (wm == g_msgMouseWheel)
        {
            HWND hwndDoc;

            if (_pInPlaceObject)
            {
                _pInPlaceObject->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
        }
    }

    return DefWindowProc(hwnd, wm, wParam, lParam);
}


BOOL
CPadDoc::OnTranslateAccelerator(MSG * pMsg)
{
    HRESULT hr = S_FALSE;

    if (pMsg->message >= WM_KEYFIRST &&
            pMsg->message <= WM_KEYLAST &&
            _pInPlaceActiveObject)
    {
        //  Hack (olego) we need to give a chance to Combo Zoom getting keyboard messages.
        HWND hwndFocus = ::GetFocus();
        HWND hwndParent = hwndFocus ? ::GetParent(hwndFocus) : NULL;

        if (_hwndComboZoom != hwndParent)
        {
            hr = THR(_pInPlaceActiveObject->TranslateAccelerator(pMsg));
        }
    }
    // Even if hr is not S_OK, the message may have been processed and resulted
    // in an error. In such a case, we don't want to pump the message in again !
    return (hr != S_FALSE);
}


HRESULT
CPadDoc::Open(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnk = NULL;
    IOleObject *            pObject = NULL;
    IPersistStreamInit *    pPS = NULL;
    DWORD                   dwFlags;
    BOOL                    fInitNew = _fInitNew;

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(_T("Open"), TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            CLSID_HTMLDocument,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    _fInitNew = !pStream;

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    hr = THR(pObject->QueryInterface(IID_IPersistStreamInit, (void **)&pPS));

    Assert(pPS);

    if(pStream)
    {
        hr = THR(pPS->Load(pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pPS->InitNew());
        if (hr)
            goto Cleanup;
    }

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));

Cleanup:
    if (hr)
    {
        _fInitNew = fInitNew;
    }

    ReleaseInterface(pObject);
    ReleaseInterface(pPS);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


HRESULT
CPadDoc::Save (IStream *pStream)
{
    HRESULT                 hr = S_OK;
    IPersistStreamInit *    pPS = NULL;

    if (!_pObject)
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistStreamInit, (void **)&pPS));
    if (hr)
        goto Cleanup;

    hr = THR(pPS->Save(pStream, TRUE));
    if (hr)
        goto Cleanup;

    _fInitNew = FALSE;

Cleanup:
    ReleaseInterface(pPS);
    RRETURN(hr);
}



HRESULT
CPadDoc::TimeSaveDocToDummyStream(LONG *plTimeMicros)
{
    LARGE_INTEGER liTimeStart;
    LARGE_INTEGER liTimeEnd;
    LARGE_INTEGER liFreq;
    IStream *pStreamDummy = NULL;
    IOleCommandTarget *pOCT = NULL;
    VARIANTARG varargIn;
    VARIANTARG varargOut;
    HRESULT hr;

    QueryPerformanceFrequency( &liFreq );
    if( liFreq.QuadPart == 0 )
    {
        AssertSz(0,"No high-performance timer available.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Muck with document so that when we save it it actually comes out of the tree
    //

    hr = THR(_pObject->QueryInterface(IID_IOleCommandTarget, (void **)&pOCT));
    if (hr)
        goto Cleanup;

    // Set to design mode.
    hr = THR(pOCT->Exec(&CGID_MSHTML,
                        IDM_EDITMODE,
                        MSOCMDEXECOPT_DODEFAULT,
                        &varargIn,
                        &varargOut) );
    if (hr)
        goto Cleanup;

    // Set dirty bit.
    varargIn.vt = VT_BOOL;
    varargIn.bVal = TRUE;

    hr = THR(pOCT->Exec(&CGID_MSHTML,
                        IDM_SETDIRTY,
                        MSOCMDEXECOPT_DODEFAULT,
                        &varargIn,
                        &varargOut) );
    if (hr)
        goto Cleanup;

    //
    // Make the stream and time the saving.
    //

    CreateStreamOnHGlobal(NULL, TRUE, &pStreamDummy);

    QueryPerformanceCounter( &liTimeStart );
    hr = Save( pStreamDummy );
    QueryPerformanceCounter( &liTimeEnd );

    if( hr )
        goto Cleanup;

    Assert( plTimeMicros );
    *plTimeMicros = (liTimeEnd.QuadPart - liTimeStart.QuadPart) * 1000000 / liFreq.QuadPart;

Cleanup:
    ReleaseInterface( pStreamDummy );
    ReleaseInterface( pOCT );
    RRETURN(hr);
}


HRESULT
CPadDoc::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 0),
            TEXT("&File"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 1),
            TEXT("&Go"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 2),
            TEXT("Favo&rite"));
    _hmenuHelp = LoadMenu(
            g_hInstResource,
            MAKEINTRESOURCE(IDR_PADHELPMENU));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)_hmenuHelp,
            TEXT("&Help"));
    AppendMenu(
            hmenuShared,
            MF_BYPOSITION | MF_POPUP,
            (UINT_PTR)GetSubMenu(_hmenuMain, 4),
            TEXT(" "));

    _cMenuHelpItems = GetMenuItemCount(_hmenuHelp);

    pmgw->width[0] = 1;
    pmgw->width[2] = 0;
    pmgw->width[4] = 2;
    pmgw->width[5] = 2;

    return S_OK;
}

HRESULT
CPadDoc::UIActivateDoc(LPMSG pMsg)
{
    HRESULT hr;
    RECT rc;

    GetViewRect(&rc, TRUE);

    hr = THR(_pObject->DoVerb(
            OLEIVERB_UIACTIVATE,
            pMsg,
            &_Site,
            0,
            _hwnd,
            ENSUREOLERECT(&rc)));

    RRETURN(hr);
}

HRESULT
CPadDoc::UIDeactivateDoc()
{
    RRETURN(THR(_pInPlaceObject->UIDeactivate()));
}

void
CPadDoc::SetDocTitle(TCHAR * pchTitle)
{
    TCHAR szBuf[512];
    TCHAR szTtl[512];

    szTtl[0] = 0;

    if (pchTitle)
    {
        _tcscat(szTtl, pchTitle);
        _tcscat(szTtl, _T(" - "));
    }

    _tcscat(szTtl, SZ_APPLICATION_NAME);

    if (pchTitle)
    {
        //  show if there is a full debug support available.
        if (DbgExIsFullDebug())
        {
            _tcscat(szTtl, _T(" (FULL debug) "));
        }
        else
        {
            _tcscat(szTtl, _T(" (NOT full debug) "));
        }
    }

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    if (!_tcsequal(szBuf, szTtl))
    {
        SetWindowText(_hwnd, szTtl);
    }
    UpdateDirtyUI();
}

HRESULT
CPadDoc::GetMoniker(LPMONIKER * ppmk)
{
    Assert (ppmk);
    if (_pMk)
    {
        * ppmk = _pMk;
        _pMk->AddRef();
        return S_OK;
    }
    else
    {
        * ppmk = NULL;
        RRETURN (E_FAIL);
    }
}

char *
DecodeMessage(UINT msg)
{
    switch (msg)
    {
        case WM_NULL:               return("WM_NULL");
        case WM_CREATE:             return("WM_CREATE");
        case WM_DESTROY:            return("WM_DESTROY");
        case WM_MOVE:               return("WM_MOVE");
        case WM_SIZE:               return("WM_SIZE");
        case WM_ACTIVATE:           return("WM_ACTIVATE");
        case WM_SETFOCUS:           return("WM_SETFOCUS");
        case WM_KILLFOCUS:          return("WM_KILLFOCUS");
        case WM_ENABLE:             return("WM_ENABLE");
        case WM_SETREDRAW:          return("WM_SETREDRAW");
        case WM_SETTEXT:            return("WM_SETTEXT");
        case WM_GETTEXT:            return("WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return("WM_GETTEXTLENGTH");
        case WM_PAINT:              return("WM_PAINT");
        case WM_CLOSE:              return("WM_CLOSE");
        case WM_QUERYENDSESSION:    return("WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return("WM_QUERYOPEN");
        case WM_ENDSESSION:         return("WM_ENDSESSION");
        case WM_QUIT:               return("WM_QUIT");
        case WM_ERASEBKGND:         return("WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return("WM_SYSCOLORCHANGE");
        case WM_SHOWWINDOW:         return("WM_SHOWWINDOW");
        case WM_WININICHANGE:       return("WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return("WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return("WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return("WM_FONTCHANGE");
        case WM_TIMECHANGE:         return("WM_TIMECHANGE");
        case WM_CANCELMODE:         return("WM_CANCELMODE");
        case WM_SETCURSOR:          return("WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return("WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return("WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return("WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return("WM_GETMINMAXINFO");
        case WM_PAINTICON:          return("WM_PAINTICON");
        case WM_ICONERASEBKGND:     return("WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return("WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return("WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return("WM_DRAWITEM");
        case WM_MEASUREITEM:        return("WM_MEASUREITEM");
        case WM_DELETEITEM:         return("WM_DELETEITEM");
        case WM_VKEYTOITEM:         return("WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return("WM_CHARTOITEM");
        case WM_SETFONT:            return("WM_SETFONT");
        case WM_GETFONT:            return("WM_GETFONT");
        case WM_SETHOTKEY:          return("WM_SETHOTKEY");
        case WM_GETHOTKEY:          return("WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return("WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return("WM_COMPAREITEM");
        case WM_COMPACTING:         return("WM_COMPACTING");
        case WM_COMMNOTIFY:         return("WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return("WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return("WM_WINDOWPOSCHANGED");
        case WM_POWER:              return("WM_POWER");
        case WM_COPYDATA:           return("WM_COPYDATA");
        case WM_CANCELJOURNAL:      return("WM_CANCELJOURNAL");
        case WM_NOTIFY:             return("WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return("WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return("WM_INPUTLANGCHANGE");
        case WM_TCARD:              return("WM_TCARD");
        case WM_HELP:               return("WM_HELP");
        case WM_USERCHANGED:        return("WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return("WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return("WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return("WM_STYLECHANGING");
        case WM_STYLECHANGED:       return("WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return("WM_DISPLAYCHANGE");
        case WM_GETICON:            return("WM_GETICON");
        case WM_SETICON:            return("WM_SETICON");
        case WM_NCCREATE:           return("WM_NCCREATE");
        case WM_NCDESTROY:          return("WM_NCDESTROY");
        case WM_NCCALCSIZE:         return("WM_NCCALCSIZE");
        case WM_NCHITTEST:          return("WM_NCHITTEST");
        case WM_NCPAINT:            return("WM_NCPAINT");
        case WM_NCACTIVATE:         return("WM_NCACTIVATE");
        case WM_GETDLGCODE:         return("WM_GETDLGCODE");
        case WM_SYNCPAINT:          return("WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return("WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return("WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return("WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return("WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return("WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return("WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return("WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return("WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return("WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return("WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return("WM_KEYDOWN");
        case WM_KEYUP:              return("WM_KEYUP");
        case WM_CHAR:               return("WM_CHAR");
        case WM_DEADCHAR:           return("WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return("WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return("WM_SYSKEYUP");
        case WM_SYSCHAR:            return("WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return("WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return("WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return("WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return("WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return("WM_INITDIALOG");
        case WM_COMMAND:            return("WM_COMMAND");
        case WM_SYSCOMMAND:         return("WM_SYSCOMMAND");
        case WM_TIMER:              return("WM_TIMER");
        case WM_HSCROLL:            return("WM_HSCROLL");
        case WM_VSCROLL:            return("WM_VSCROLL");
        case WM_INITMENU:           return("WM_INITMENU");
        case WM_INITMENUPOPUP:      return("WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return("WM_MENUSELECT");
        case WM_MENUCHAR:           return("WM_MENUCHAR");
        case WM_ENTERIDLE:          return("WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return("WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return("WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return("WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return("WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return("WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return("WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return("WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return("WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return("WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return("WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return("WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return("WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return("WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return("WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return("WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return("WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return("WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return("WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return("WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return("WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return("WM_EXITMENULOOP");
        case WM_NEXTMENU:           return("WM_NEXTMENU");
        case WM_SIZING:             return("WM_SIZING");
        case WM_CAPTURECHANGED:     return("WM_CAPTURECHANGED");
        case WM_MOVING:             return("WM_MOVING");
        case WM_POWERBROADCAST:     return("WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return("WM_DEVICECHANGE");
        case WM_MDICREATE:          return("WM_MDICREATE");
        case WM_MDIDESTROY:         return("WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return("WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return("WM_MDIRESTORE");
        case WM_MDINEXT:            return("WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return("WM_MDIMAXIMIZE");
        case WM_MDITILE:            return("WM_MDITILE");
        case WM_MDICASCADE:         return("WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return("WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return("WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return("WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return("WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return("WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return("WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return("WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return("WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return("WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return("WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return("WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return("WM_IME_SELECT");
        case WM_IME_CHAR:           return("WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return("WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return("WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return("WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return("WM_MOUSELEAVE");
        case WM_CUT:                return("WM_CUT");
        case WM_COPY:               return("WM_COPY");
        case WM_PASTE:              return("WM_PASTE");
        case WM_CLEAR:              return("WM_CLEAR");
        case WM_UNDO:               return("WM_UNDO");
        case WM_RENDERFORMAT:       return("WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return("WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return("WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return("WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return("WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return("WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return("WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return("WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return("WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return("WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return("WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return("WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return("WM_PALETTECHANGED");
        case WM_HOTKEY:             return("WM_HOTKEY");
        case WM_PRINT:              return("WM_PRINT");
        case WM_PRINTCLIENT:        return("WM_PRINTCLIENT");
        case WM_USER:               return("WM_USER");
        case WM_USER+1:             return("WM_USER+1");
        case WM_USER+2:             return("WM_USER+2");
        case WM_USER+3:             return("WM_USER+3");
        case WM_USER+4:             return("WM_USER+4");
    }

    return("");
}

void
CPadDoc::RunOneMessage(MSG *pmsg)
{
    PADTHREADSTATE * pts = GetThreadState();
    CPadDoc *pDoc;
    char ach[64];
    KEYSTATE ks;

    for (pDoc = pts->pDocFirst; pDoc != NULL; pDoc = pDoc->_pDocNext)
    {
        if (pmsg->hwnd == pDoc->_hwnd || IsChild(pDoc->_hwnd, pmsg->hwnd))
            break;
    }

    ach[0] = 0;

    if (pmsg->hwnd)
    {
        GetClassNameA(pmsg->hwnd, ach, sizeof(ach));
    }

    PerfLog4(tagPerfWatchPad, pDoc, "+CPadDoc::RunOneMessage msg=%04X (%s) hwnd=%lX (%s)",
        pmsg->message, DecodeMessage(pmsg->message), pmsg->hwnd, ach);

    if (pDoc)
    {
        switch (pmsg->message)
        {
        case WM_CHAR:
            ks = (0x8000 & GetKeyState(VK_SHIFT)) ? KEYSTATE_Shift : KEYSTATE_None;

            IGNORE_HR(pDoc->GetScriptRecorder()->RegisterChar(pmsg->wParam, ks));
            break;

        case WM_KEYDOWN:
            ks = (0x8000 & GetKeyState(VK_SHIFT)) ? KEYSTATE_Shift : KEYSTATE_None;

            IGNORE_HR(pDoc->GetScriptRecorder()->RegisterKeyDown(pmsg->wParam, ks));
            break;
        }

        if (WM_KEYFIRST <= pmsg->message &&
                pmsg->message <= WM_KEYLAST &&
                pDoc->OnTranslateAccelerator(pmsg))
        {
            goto leave;
        }

        if (pmsg->message == WM_PAINT && pDoc->_fPaintLocked)
        {
            PAINTSTRUCT ps;
            BeginPaint(pmsg->hwnd, &ps);
            EndPaint(pmsg->hwnd, &ps);
            pDoc->_fPaintOnUnlock = TRUE;
            goto leave;
        }
    }

    TranslateMessage(pmsg);
    DispatchMessage(pmsg);

leave:
    PerfLog(tagPerfWatchPad, pDoc, "-CPadDoc::RunOneMessage");
    return;
}

#define MAX_MESSAGES_TO_RUN 20

int
CPadDoc::Run(BOOL fStopWhenEmpty)
{
    MSG     msg;
    BOOL    fQuit;
    BOOL    fNoSuspend = IsTagEnabled(tagPadNoSuspendForMessage);
    PADTHREADSTATE * pts = GetThreadState();

    msg.wParam = 0;
    if (fStopWhenEmpty)
    {
        // Just grab all the messages that are currently in the queue, then quit.
        // Also quit if the only messages in the queue are timer messages.

        int n = 0;

        for (;;)
        {
            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            Assert(!InSendMessage());

            fQuit = !PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit || msg.message == WM_QUIT)
                break;

            RunOneMessage(&msg);

            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            if (++n > MAX_MESSAGES_TO_RUN)
            {
                fQuit = GetQueueStatus(QS_ALLEVENTS & ~QS_TIMER) == 0;
            }

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit)
                break;
        }
    }
    else
    {
        // Loop until we get a quit message.

        while (!pts->fEndEvents)
        {
            if (!fNoSuspend)
            {
                ::SuspendCAP();
            }

            //
            // When debug dialog brought up we hit this.  The
            // dialog thread was sending itself a WM_INITDIALOG
            // message and filling in the Listbox.  Why should
            // this assert be valid in this case?  davidd
            //
            //             Assert(!InSendMessage());

            fQuit = !GetMessage(&msg, NULL, 0, 0);

            if (!fNoSuspend)
            {
                ::ResumeCAP();
            }

            if (fQuit)
                break;

            RunOneMessage(&msg);
        }

    }

    return fStopWhenEmpty ? 0 : msg.wParam;
}

HRESULT
CPadDoc::GetBrowser()
{
    HRESULT hr = S_OK;

    if (!_pBrowser)
    {
        hr = THR(Open(CLSID_WebBrowser, NULL));
        if (hr)
        {
            goto Cleanup;
        }

        Assert(_pObject);
        hr = THR(_pObject->QueryInterface(IID_IWebBrowser, (void **)&_pBrowser));
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CPadDoc::SaveHistory(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IPersistHistory *       pPH = NULL;

    if (!_pObject)
        goto Cleanup;

    hr = THR(_pObject->QueryInterface(IID_IPersistHistory, (void **)&pPH));
    if (hr)
        goto Cleanup;

    hr = THR(pPH->SaveHistory(pStream));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPH);
    RRETURN(hr);
}


HRESULT
CPadDoc::OpenHistory(IStream * pStream)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnk = NULL;
    IOleObject *            pObject = NULL;
    IPersistHistory *       pPH = NULL;
    CLSID                   clsid;
    DWORD dwFlags;

    Assert(pStream);

    // Shutdown the previous object.
    hr = THR(Deactivate());
    if (hr)
        goto Cleanup;

    if (!_fDisablePadEvents)
    {
        if (_pEvent)
        {
            _pEvent->Event(_T("Open"), TRUE);
        }

        FireEvent(DISPID_PadEvents_Status, _T("Open"));
    }

    hr = THR(RegisterLocalCLSIDs());
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(
            CLSID_HTMLDocument,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObject);
    if (hr)
        goto Cleanup;

    hr = THR(pObject->GetMiscStatus(DVASPECT_CONTENT, &dwFlags));
    if (hr)
        goto Cleanup;

    if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;

        if (_ulDownloadNotifyMask)
        {
            hr = THR(AttachDownloadNotify(pObject));
            if (hr)
                goto Cleanup;
        }
    }

    SendAmbientPropertyChange(DISPID_AMBIENT_USERMODE);

    hr = THR(pObject->QueryInterface(IID_IPersistHistory, (void **)&pPH));
    if (hr)
        goto Cleanup;

    Assert(pPH);

    hr = THR(pPH->GetClassID(&clsid));
    if (hr)
        goto Cleanup;

    Assert(clsid == CLSID_HTMLDocument);

    hr = THR(pPH->LoadHistory(pStream, 0));
    if (hr)
        goto Cleanup;

    if (!(dwFlags & OLEMISC_SETCLIENTSITEFIRST))
    {
        hr = THR(pObject->SetClientSite(&_Site));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Activate(pObject));

Cleanup:

    ReleaseInterface(pObject);
    ReleaseInterface(pPH);
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


HRESULT
CPadDoc::DoReloadHistory()
{
    IStream *pStream = NULL;
    HGLOBAL hg = NULL;
    HRESULT hr;
    static LARGE_INTEGER i64Zero = {0, 0};

    hg = GlobalAlloc(GMEM_MOVEABLE, 0);
    if (!hg)
        return E_OUTOFMEMORY;

    hr = THR(CreateStreamOnHGlobal(hg, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    hr = THR(SaveHistory(pStream));
    if (hr)
        goto Cleanup;

    hr = THR(pStream->Seek(i64Zero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(OpenHistory(pStream));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);

    RRETURN(hr);
}

void
CPadDoc::DirtyColors()
{
    if (_palState == palChanged)
        return;
    _palState = palChanged;
    PostMessage(_hwnd, WM_QUERYNEWPALETTE, 0, 0L);
}

LRESULT
CPadDoc::OnPaletteChanged(HWND hwnd)
{
    HWND hwndDoc = 0;
    if (_pInPlaceObject && SUCCEEDED(_pInPlaceObject->GetWindow(&hwndDoc)) && hwndDoc)
        return SendMessage(hwndDoc, WM_PALETTECHANGED, (WPARAM)hwnd, 0L);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetupComposeFont
//
//  Synopsis:   Set the default composition font for MSHTML when its in edit mode.
//
//----------------------------------------------------------------------------
void
CPadDoc::SetupComposeFont()
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    CVariant varIn;

    Assert(_pInPlaceObject);

    if (_fUserMode)
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = TRUE;

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_HTMLEDITMODE,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );

    V_VT(&varIn) = VT_BSTR;

#if DBG==1
    if (!IsTagEnabled(tagSpanTag))
#endif // DBG==1
        THR(FormsAllocString(_T(",,,,,,Times New Roman"), &V_BSTR(&varIn)));
#if DBG==1
    else if (!IsTagEnabled(tagSpanTag2))
        THR(FormsAllocString(_T("1,,,2,0.128.0,,Times New Roman,MsHtmlPad"), &V_BSTR(&varIn)));
    else
        THR(FormsAllocString(_T("1,,,2,0.128.0,,Times New Roman,MsHtmlPad,1"), &V_BSTR(&varIn)));
#endif // DBG==1

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_COMPOSESETTINGS,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
        );
Cleanup:
    ReleaseInterface(pCommandTarget);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::SetupDefaultBlock
//
//  Synopsis:   Set the default block tag for editting.
//
//----------------------------------------------------------------------------
void
CPadDoc::SetupDefaultBlock()
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    CVariant varIn;

    Assert(_pInPlaceObject);

    if (_fUserMode)
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_BOOL;
    V_BOOL(&varIn) = TRUE;

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_HTMLEDITMODE,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );

    V_VT(&varIn) = VT_BSTR;
    if (IsTagEnabled(tagDefaultDIV))
        THR(FormsAllocString(_T("DIV"), &V_BSTR(&varIn)));
    else
        THR(FormsAllocString(_T("P"), &V_BSTR(&varIn)));

    pCommandTarget->Exec(
        (GUID *)&CGID_MSHTML,
        IDM_DEFAULTBLOCK,
        MSOCMDEXECOPT_DONTPROMPTUSER,
        &varIn,
        NULL
    );
Cleanup:
    ReleaseInterface(pCommandTarget);
    return;
}

#if 0
LRESULT
CPadDoc::OnQueryNewPalette()
{
    HWND hwndDoc = 0;
    if (_pInPlaceObject && SUCCEEDED(_pInPlaceObject->GetWindow(&hwndDoc) && _hwndDoc)
        return SendMessage(hwndDoc, WM_QUERYNEWPALETTE, hwnd, 0L);
    return FALSE;
}
#else
LRESULT
CPadDoc::OnQueryNewPalette()
{
    if (!_pObject || !s_fPaletteDevice)
        return FALSE;

    switch (_palState)
    {
    case palChanged:
    case palUnknown:
    {
        HPALETTE hpal = _hpal;

        IViewObject *pVO = NULL;
        LOGPALETTE *plp = NULL;

        //
        // Try to get a color set
        //
        if (OK(_pObject->QueryInterface(IID_IViewObject, (void **)&pVO)))
        {
            pVO->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, NULL, &plp);
            pVO->Release();
        }

        if (plp)
        {
            PALETTEENTRY ape[256];

            if ( _hpal )
            {
                unsigned cpe = GetPaletteEntries(_hpal, 0, 0, NULL);

                if (cpe > 256 ||
                    cpe != plp->palNumEntries ||
                    (GetPaletteEntries(_hpal, 0, cpe, ape) != cpe) ||
                    memcmp(plp->palPalEntry, ape, cpe * sizeof(PALETTEENTRY)))
                {
                    DeleteObject(_hpal);
                    _hpal = CreatePalette(plp);
                }
            }
            else
            {
                _hpal = CreatePalette(plp);
            }

            CoTaskMemFree(plp);
        }

        if (hpal != _hpal)
            SendAmbientPropertyChange(DISPID_AMBIENT_PALETTE);

        _palState = palNormal;
    }
    // Fall through
    case palNormal:
        HDC hdc = GetDC(_hwnd);
        SelectPalette(hdc, _hpal ? _hpal : (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);
        ReleaseDC(_hwnd, hdc);
    }
    return TRUE;
}
#endif


class CDebugDownloadNotify : public IDownloadNotify
{
public:
    static HRESULT Create(IDownloadNotify **ppdn, ULONG ulMask)
    {
        CDebugDownloadNotify *pddn;
        HRESULT hr = E_OUTOFMEMORY;

        pddn = new CDebugDownloadNotify(ulMask);
        if (!pddn)
            goto Cleanup;

        hr = THR(pddn->QueryInterface(IID_IDownloadNotify, (void**)ppdn));
        if (hr)
            ClearInterface(ppdn);

        pddn->Release();
    Cleanup:
        RRETURN(hr);
    }

private:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDebugDownloadNotify))
    CDebugDownloadNotify(ULONG ulMask) { _ulMask = ulMask; _ulRefs = 1; }

    // IUnknown methods
    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj)
    {
        if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDownloadNotify))
        {
            *ppvObj = (IDownloadNotify *)this;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }

    STDMETHOD_(ULONG,AddRef)()
    {
        return((ULONG)InterlockedIncrement((LONG *)&_ulRefs));
    }

    STDMETHOD_(ULONG,Release)()
    {
        ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulRefs);

        if (ulRefs == 0)
        {
            delete this;
        }

        return(ulRefs);
    }

    // IDownloadNotify methods
    virtual HRESULT STDMETHODCALLTYPE DownloadStart(
        /* [in] */ LPCWSTR pchUrl,
        /* [in] */ DWORD dwDownloadId,
        /* [in] */ DWORD dwType,
        /* [in] */ DWORD dwReserved)
    {
        TraceTag((0, "DownloadStart    %lx (tid%3x): id#%d type %d %ls", this, GetCurrentThreadId(), dwDownloadId, dwType, pchUrl));
        if (!((1 << dwType) & _ulMask))
            return E_ABORT;

        return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE DownloadComplete(
        /* [in] */ DWORD dwDownloadId,
        /* [in] */ HRESULT hrNotify,
        /* [in] */ DWORD dwReserved)
    {
        TraceTag((0, "DownloadComplete %lx (tid%3x): id#%d hr %8lx", this, GetCurrentThreadId(), dwDownloadId, hrNotify));
        return S_OK;
    }

    ULONG _ulRefs;
    ULONG _ulMask;
};


//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::AttachDownloadNotify
//
//  Synopsis:   Attach a new debug download notify object to the doc
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::AttachDownloadNotify(IOleObject *pObject)
{
    IDownloadNotify *pdn = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    VARIANT varIn;

    hr = THR_NOTRACE(pObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    hr = CDebugDownloadNotify::Create(&pdn, _ulDownloadNotifyMask);
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)pdn;

    pCommandTarget->Exec(
                         (GUID *)&CGID_DownloadHost,
                         DWNHCMDID_SETDOWNLOADNOTIFY,
                         MSOCMDEXECOPT_DONTPROMPTUSER,
                         &varIn,
                         NULL
                        );

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pdn);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPadDoc::DetachDownloadNotify
//
//  Synopsis:   Detach the debug download notify object from the doc
//
//----------------------------------------------------------------------------
HRESULT
CPadDoc::DetachDownloadNotify(IOleObject *pObject)
{
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT hr;
    VARIANT varIn;

    hr = THR_NOTRACE(pObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)NULL;

    pCommandTarget->Exec(
                         (GUID *)&CGID_DownloadHost,
                         DWNHCMDID_SETDOWNLOADNOTIFY,
                         MSOCMDEXECOPT_DONTPROMPTUSER,
                         &varIn,
                         NULL
                        );

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}

//----------------------------------------------------------------
//
//  Zoom Combo UI Stuff
//
//
//
//----------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Window Procedure: EditZoomWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
LRESULT CALLBACK
EditZoomWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_KEYDOWN:
        {
            switch ((int)wParam)
            {
            case VK_RETURN:
                ::SendMessage(GetParent(hWnd), WM_ZOOMRETURN, 0, 0);
                return 0;
            case VK_ESCAPE:
                ::SendMessage(GetParent(hWnd), WM_ZOOMESCAPE, 0, 0);
                return 0;
            case VK_UP:
                ::SendMessage(GetParent(hWnd), WM_ZOOMUP, 0, 0);
                return 0;
            case VK_DOWN:
                ::SendMessage(GetParent(hWnd), WM_ZOOMDOWN, 0, 0);
                return 0;
            default:
                break;
            }
        }
        break;

    case WM_KEYUP:
        {
            switch ((int)wParam)
            {
            case VK_RETURN:
            case VK_ESCAPE:
            case VK_UP:
            case VK_DOWN:
                return 0;
            default:
                break;
            }
        }
    default:
        break;
    }
    //  Edit has address of default wnd proc in its GWLP_USERDATA
    return CallWindowProc((WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA),
        hWnd, uMessage, wParam, lParam);
}

//+-------------------------------------------------------------------
//
//  Window Procedure: ZoomComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
LRESULT CALLBACK
ZoomComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) ::SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        ::SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_ZOOMRETURN:
        ::SendMessage(::GetParent(hWnd),
            WM_COMMAND,
            (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
            (LPARAM)hWnd);
        return 0;

    case WM_ZOOMESCAPE:
        if ((WPARAM)::SendMessage(hWnd, CB_GETCURSEL, 0, 0) == CB_ERR)
        {
            ::SendMessage(hWnd, CB_SETCURSEL, (WPARAM)-1, 0);
        }
        else
        {
            ::SendMessage(::GetParent(hWnd),
                WM_COMMAND,
                (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
                (LPARAM)hWnd);
        }
        return 0;

    case WM_ZOOMUP:
    case WM_ZOOMDOWN:
        {
            WPARAM wCurSel;

            wCurSel = (WPARAM)::SendMessage(hWnd, CB_GETCURSEL, 0, 0);
            if (wCurSel == CB_ERR)
            {
                wCurSel = 0;
            }

            if (uMessage == WM_ZOOMUP)
            {
                if (wCurSel > 0)
                {
                    wCurSel--;
                }
            }
            else
            {
                if ((wCurSel + 1) < (WPARAM)::SendMessage(hWnd, CB_GETCOUNT, 0, 0))
                {
                    wCurSel++;
                }
            }

            ::SendMessage(hWnd, CB_SETCURSEL, wCurSel, 0);
        }
        return 0;

    default:
        break;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}

//----------------------------------------------------------------
//
//  Editing Toolbar UI Stuff
//
//
//
//----------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Window Procedure: ComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------
#if defined(DBG_TOOLTIPS)
LRESULT CALLBACK
ComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_CHAR:
        // Don't allow the user to type anything into the combo
        return 0;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}
#endif

//+-------------------------------------------------------------------
//
// Local Helper Function: InstallComboboxTooltip
//
//--------------------------------------------------------------------

void
CPadDoc::InstallComboboxTooltip(HWND hwndCombo, UINT IDMmessage)
{
#if defined(DBG_TOOLTIPS)
    HWND     hwndTooltip;
    TOOLINFO tbToolInfo;

    Assert(hwndCombo);
    Assert(GetParent(hwndCombo));

    hwndTooltip = (HWND) SendMessage(
            GetParent(hwndCombo),
            TB_GETTOOLTIPS,
            0,
            0);

    SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG)ComboWndProc);

    tbToolInfo.cbSize   = sizeof(TOOLINFO);
    tbToolInfo.uFlags   = TTF_IDISHWND;
    tbToolInfo.hwnd     = GetParent(hwndCombo);
    tbToolInfo.uId      = (UINT) hwndCombo;
    tbToolInfo.hinst    = 0;

#ifndef WINCE
    DWORD dwVersion = GetVersion();
#else
    DWORD dwVersion = 0;
#endif

    tbToolInfo.lpszText = (dwVersion < 0x80000000) ?
            ((LPTSTR) LPSTR_TEXTCALLBACKW) : ((LPTSTR) LPSTR_TEXTCALLBACKA);

    Assert(hwndTooltip);
    SendMessage(
            hwndTooltip,
            (dwVersion < 0x80000000) ? (TTM_ADDTOOLW) : (TTM_ADDTOOLA),
            0,
            (LPARAM)(LPTOOLINFO)&tbToolInfo);
#endif
}

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(const LOGFONT *    lplf,
             const TEXTMETRIC * lptm,
             DWORD            iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    // We don't want to list the vertical fonts.
    // These by convention start with an @ symbol.
    if (lplf->lfFaceName[0] == L'@')
        return TRUE;

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const WCHAR *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);
    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------




void
CPadDoc::ConvColorrefToString(COLORREF crColor, LPTSTR szName, int cchName )
{
    int     i;
    BOOL fFound = FALSE;

    if(crColor == (COLORREF)-1)
    {
        szName[0] = 0;
        return;
    }

    // Reset the upper 8 bits because palettergb type color values have them
    // set to 0x20 and the compare will fail
    crColor &= 0xFFFFFF;

    for(i = 0; ComboColorItems[i].iIdm != 0; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        Format(0, szName, cchName, MAKEINTRESOURCE(ComboColorItems[i].iIdm));
    else
        szName[0] = 0;
}


DWORD
CPadDoc::AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;
    TCHAR   achColor[128];

    while(pComboItems->iIdm)
    {
        Format(0, achColor, ARRAY_SIZE(achColor),
                  MAKEINTRESOURCE(pComboItems->iIdm));

        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) achColor);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}
///--------------------------------------------------------------
//
// Member:    CPadDoc::IsEdit
//
// Synopsis: Return TRUE if we are in Edit Mode
//           False if in BROWSE Mode
//
//---------------------------------------------------------------

BOOL
CPadDoc::IsEdit()
{
    return ! _fUserMode;
}

//+=========================================================
//
// Update the Standard Toolbar UI.
//
//
//
//+=========================================================

LRESULT
CPadDoc::UpdateStandardToolbar()
{
   static const MsoCmdInfo TBBtnInfo[] = {
            { IDM_PAD_BACK,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_FORWARD, IDM_UNKNOWN,    NULL },
            { IDM_PAD_HOME,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_FIND,    IDM_UNKNOWN,    NULL },
            { IDM_PAD_STOP,    OLECMDID_STOP,  NULL },
            { IDM_PAD_REFRESH, OLECMDID_REFRESH,NULL },
            { IDM_PAD_PRINT,   OLECMDID_PRINT, NULL },
            { IDM_PAD_CUT,     OLECMDID_CUT,   NULL },
            { IDM_PAD_COPY,    OLECMDID_COPY,  NULL },
            { IDM_PAD_PASTE,   OLECMDID_PASTE, NULL },
            { 0, 0, NULL }
    };
    int cButton;

    HRESULT hr = S_OK;
    MSOCMD msocmd;

    IOleCommandTarget* pCommandTarget = NULL;

    if (!_fStandardInit)
    {
        InitStandardToolbar();
        _fStandardInit = TRUE;
    }

    if (hr)
        goto Cleanup;

    if (!_hwndToolbar)
        goto Cleanup;

    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;
    //
    // Make sure we are in sync with the doc user mode.
    //
    msocmd.cmdID = IDM_EDITMODE;
    msocmd.cmdf  = 0;
    if (OK(THR(pCommandTarget->QueryStatus(&CGID_MSHTML, 1, &msocmd, NULL))))
        _fUserMode = msocmd.cmdf != MSOCMDSTATE_DOWN;

    UpdateFontSizeBtns(pCommandTarget);

    for (cButton = 0; TBBtnInfo[cButton].localIDM; cButton ++)
    {
        msocmd.cmdID = TBBtnInfo[cButton].MsoCmdIDM;
        msocmd.cmdf  = 0;

        hr = pCommandTarget->QueryStatus(
            TBBtnInfo[cButton].MsoCmdGUID,
            1,
            &msocmd,
            NULL);

        if (_pBrowser && (IDM_UNKNOWN == TBBtnInfo[cButton].MsoCmdIDM))
        {
            SendMessage(
                    _hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(TRUE, 0));
        }
        else
        {
            SendMessage(
                    _hwndToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(msocmd.cmdf & MSOCMDF_ENABLED ? TRUE : FALSE, 0));
        }

        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            SendMessage(
                    _hwndToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) TBBtnInfo[cButton].localIDM,
                    (LPARAM) MAKELONG(
                            (msocmd.cmdf == MSOCMDSTATE_DOWN) ?
                                    (TRUE) : (FALSE),
                            0));
            break;
        }
        SendMessage(
                _hwndToolbar,
                TB_PRESSBUTTON,
                TBBtnInfo[cButton].localIDM,
                (LPARAM) MAKELONG(FALSE, 0));
    }



    SendMessage(
            _hwndToolbar,
            TB_CHANGEBITMAP,
            IDM_PAD_EDITBROWSE,
            MAKELPARAM(_fUserMode ? 13 : 12, 0));

    SendMessage(_hwndToolbar, TB_ENABLEBUTTON, (WPARAM)IDM_PAD_EDITBROWSE, !_pBrowser);

    pCommandTarget->Release();

Cleanup:
    return 0;
}

void
CPadDoc::UpdateFormatButtonStatus()
{
    UINT cButtons;
    CVariant var;
    int j, iIndex, iCurrentIndex;
    TCHAR szBuf[128];
    HWND  hwndCombobox = NULL;
    MSOCMD  msocmd;

        // update zoom combobox status
    static const UINT ComboSet[] = {
            IDM_FONTNAME,
            IDM_FONTSIZE,
            IDM_BLOCKFMT,
            IDM_FORECOLOR,
            0 };


    struct ButtonInfo {
        UINT ButtonIDM;
        UINT ToolbarIDR;
    };


    static const ButtonInfo tbButtons[] =
    {
        { IDM_BOLD,          IDR_HTMLFORM_TBFORMAT },
        { IDM_ITALIC,        IDR_HTMLFORM_TBFORMAT },
        { IDM_UNDERLINE,     IDR_HTMLFORM_TBFORMAT },
        { IDM_ORDERLIST,     IDR_HTMLFORM_TBFORMAT },
        { IDM_UNORDERLIST,   IDR_HTMLFORM_TBFORMAT },
        { IDM_INDENT,        IDR_HTMLFORM_TBFORMAT },
        { IDM_OUTDENT,       IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYLEFT,   IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYCENTER, IDR_HTMLFORM_TBFORMAT },
        { IDM_JUSTIFYRIGHT,  IDR_HTMLFORM_TBFORMAT },
        { IDM_BLOCKDIRLTR,   IDR_HTMLFORM_TBFORMAT },
        { IDM_BLOCKDIRRTL,   IDR_HTMLFORM_TBFORMAT },
        { IDM_MULTIPLESELECTION,   IDR_HTMLFORM_TBFORMAT },
        { IDM_2D_POSITION,   IDR_HTMLPAD_TBFORMAT },
        { IDM_ABSOLUTE_POSITION,   IDR_HTMLPAD_TBFORMAT },
        { IDM_LIVERESIZE,    IDR_HTMLFORM_TBFORMAT },
       { 0, 0}
    };

    HRESULT hr;


    IOleCommandTarget * pCommandTarget = NULL;



    if ( !_pInPlaceObject )
        goto Cleanup;

    hr = THR_NOTRACE(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget,
            (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;






    for (j = 0; ComboSet[j]; j ++)
    {
        switch (ComboSet[j])
        {
        case IDM_FONTSIZE:
            hwndCombobox = _hwndComboSize;
            var.vt   = VT_I4;
            var.lVal = 0;
            break;
        case IDM_BLOCKFMT:
            hwndCombobox = _hwndComboTag;
            break;
        case IDM_FONTNAME:
            hwndCombobox = _hwndComboFont;
            break;
        case IDM_FORECOLOR:
            hwndCombobox = _hwndComboColor;
            break;
        }

        msocmd.cmdID = ComboSet[j];
        msocmd.cmdf  = 0;
        hr = THR( pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL));
        switch (msocmd.cmdf)
        {
        case MSOCMDSTATE_UP:
        case MSOCMDSTATE_DOWN:
        case MSOCMDSTATE_NINCHED:
            EnableWindow(hwndCombobox, TRUE);
            break;

        case MSOCMDSTATE_DISABLED:
        default:
            EnableWindow(hwndCombobox, FALSE);
            break;
        }

        hr = THR_NOTRACE( pCommandTarget->Exec((GUID *)&CGID_MSHTML, ComboSet[j],
                MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &var));
        if (FAILED(hr))
            continue;

        switch (ComboSet[j])
        {
        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            // It is legal for the returned bstr to be NULL.
            wcscpy(szBuf, (var.vt == VT_BSTR && var.bstrVal) ? var.bstrVal : TEXT(""));
            break;

        case IDM_FORECOLOR:
            if(V_VT(&var) == VT_NULL)
                szBuf[0] = 0;
            else
                ConvColorrefToString(V_I4(&var), szBuf, ARRAY_SIZE(szBuf));
            break;

        case IDM_FONTSIZE:
            // If the font size is changing in the selection VT_NULL is returned
            if(V_VT(&var) == VT_NULL)
            {
                szBuf[0] = 0;
            }
            else
            {
                Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), var.lVal);
            }
            break;
        }

        iIndex = SendMessage(
                hwndCombobox,
                CB_FINDSTRINGEXACT,
                (WPARAM) -1,
                (LPARAM)(LPTSTR) szBuf);

        if (iIndex == CB_ERR)
        {
            // CB_FINDSTRINGEXACT cannot find the string in the combobox.
            //
            switch (ComboSet[j])
            {
            case IDM_BLOCKFMT:
                // GetBlockFormat returns something not in the BlockFormat
                // combobox, display empty string.
                //
                iIndex = -1;
                break;

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
                // Nothing is selected
                iIndex = -1;
                break;
            }
        }

        iCurrentIndex = SendMessage(hwndCombobox, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if ( iCurrentIndex != iIndex )
            SendMessage(hwndCombobox, CB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0);

        VariantClear(&var);
    }

    // update buttons status
    BOOL fEnabled;
    BOOL fChecked;
    for (cButtons = 0; tbButtons[cButtons].ButtonIDM != 0; cButtons ++)
    {
        if (_hwndFormatToolbar)
        {
            msocmd.cmdID = tbButtons[cButtons].ButtonIDM;
            msocmd.cmdf  = 0;
            hr = pCommandTarget->QueryStatus((GUID *)&CGID_MSHTML, 1, &msocmd, NULL);

            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_DOWN:
            case MSOCMDSTATE_NINCHED:
                fEnabled = TRUE;
                fChecked = (msocmd.cmdf == MSOCMDSTATE_DOWN) ? TRUE : FALSE;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                fEnabled = FALSE;
                fChecked = FALSE;
                break;
            }
            SendMessage(
                    _hwndFormatToolbar,
                    TB_ENABLEBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fEnabled, 0));
            SendMessage(
                    _hwndFormatToolbar,
                    TB_CHECKBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(fChecked, 0));
            SendMessage(
                    _hwndFormatToolbar,
                    TB_PRESSBUTTON,
                    (WPARAM) tbButtons[cButtons].ButtonIDM,
                    (LPARAM) MAKELONG(FALSE, 0));
        }

    }
Cleanup:

    if ( pCommandTarget)
        pCommandTarget->Release();

}

LRESULT
CPadDoc::UpdateFormatToolbar()
{
    if ( !_pInPlaceObject )
        goto Cleanup;


    if ( IsEdit())
    {
        if ( ! _fFormatInit )
        {
            InitFormatToolbar(); // Load the pull-downs and other fun stuff.
            _fFormatInit = TRUE;
        }
        UpdateFormatButtonStatus();
        if ( _fToolbarhidden )
            ShowFormatToolbar();
    }
    else if ( ! _fToolbarhidden )
    {
        HideFormatToolbar();
    }

Cleanup:
    return 0;

}

void
CPadDoc::ShowFormatToolbar()
{
    ::ShowWindow(_hwndFormatToolbar, SW_SHOW);
    _fToolbarhidden = FALSE;
    //
    //Resize
    //
    //
    ::SetMenu( _hwnd, _hmenuEdit );
    Resize();
}

void
CPadDoc::HideFormatToolbar()
{
    ::ShowWindow(_hwndFormatToolbar, SW_HIDE);
    _fToolbarhidden = TRUE;
    //
    // Resize
    //
    ::SetMenu( _hwnd, _hmenuMain );
    Resize();
}

LRESULT
CPadDoc::UpdateToolbarUI()
{
    UpdateStandardToolbar();
    UpdateFormatToolbar();
    UpdateDirtyUI();

    return 0;
}

///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateStandardToolbar
//
// Synopsis: Creates the Standard toolbar UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateStandardToolbar()
{
    HRESULT hr = S_OK;
    HWND   hwndToolbar = NULL;
    HFONT  hFont;
    DWORD  cTBCombos;
    TEXTMETRIC tm;
    HDC    hdc;
    HWND * pHwndCombo = NULL;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };
    static const ComboInfo tbCombos[] =
    {
        { IDM_ZOOMPERCENT, IDR_HTMLFORM_TBSTANDARD, 402, 60, 12,
                CBS_DROPDOWN},
        { 0, 0, 0, 0, 0}
    };

   //
    // Standard Toolbar table
    //
    static const TBBUTTON tbButton[] =
    {
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 0, IDM_PAD_BACK, 0, TBSTYLE_BUTTON, 0L, 0},
        { 1, IDM_PAD_FORWARD, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 2, IDM_PAD_HOME, 0, TBSTYLE_BUTTON, 0L, 0},
        { 3, IDM_PAD_FIND, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 4, IDM_PAD_STOP, 0, TBSTYLE_BUTTON, 0L, 0},
        { 5, IDM_PAD_REFRESH, 0, TBSTYLE_BUTTON, 0L, 0},
        { 6, IDM_PAD_PRINT, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 7, IDM_PAD_FONTINC, 0, TBSTYLE_BUTTON, 0L, 0},
        { 8, IDM_PAD_FONTDEC, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        { 9, IDM_PAD_CUT, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, IDM_PAD_COPY, 0, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_PAD_PASTE, 0, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        {13, IDM_PAD_EDITBROWSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {10, 0, 0, TBSTYLE_SEP, 0L, 0},

        {14, IDM_PAD_USESHDOCVW, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},

        // Reserve space for zoom combo.
        {70, 0, 0, TBSTYLE_SEP, 0L, 0}


    };




    //
    // Create the "standard" toolbar
    //

    _hwndToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE /* TBSTYLE_TOOLTIPS*/,
            IDR_HTMLPAD_TOOLBAR,
            15,                             // number of bitmaps
            g_hInstResource,
            IDB_HTMLPAD_TOOLBAR,
            (LPCTBBUTTON) &tbButton,
            ARRAY_SIZE(tbButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));

    if (!_hwndToolbar)
    {
        hr = E_FAIL;
    }

    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_ZOOMPERCENT:
            pHwndCombo = &(_hwndComboZoom);
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLFORM_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLFORM_TBFORMAT:
            hwndToolbar = _hwndFormatToolbar;
            break;
        }

        Assert(hwndToolbar);

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                hwndToolbar,
                (HMENU)(ULongToPtr(tbCombos[cTBCombos].ComboIDM)),
                GetResourceHInst(),
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM)hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);
#ifdef IE6_VDEVICE
        EnableWindow(*pHwndCombo, TRUE);
#else
        EnableWindow(*pHwndCombo, FALSE);
#endif
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
        lpfnDefCombo = (WNDPROC) GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
        InstallComboboxTooltip(*pHwndCombo, tbCombos[cTBCombos].ComboIDM);

        if (*pHwndCombo == _hwndComboZoom)
        {
            WNDPROC lpfnDefEdit;
            HWND    hWndEdit;
            POINT   pt;

            //  Set window proc for zoom combo
            lpfnDefEdit = (WNDPROC)GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
            SetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC, (LONG_PTR)ZoomComboWndProc);
            SetWindowLongPtr(*pHwndCombo, GWLP_USERDATA, (LONG_PTR)lpfnDefEdit);

            //  Set window proc for zoom combo edit contol
            pt.x = 3;
            pt.y = 3;
            hWndEdit = ChildWindowFromPoint(*pHwndCombo, pt);
            lpfnDefEdit = (WNDPROC)GetWindowLongPtr(hWndEdit, GWLP_WNDPROC);
            SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)EditZoomWndProc);
            SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)lpfnDefEdit);
        }
    }
Cleanup:
RRETURN ( hr );

}
///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateFormatToolbar
//
// Synopsis: Creates the Formatting Toolbar UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateFormatToolbar()
{

    HRESULT hr = S_OK;
    int newTop = 0;


    HWND   hwndToolbar = NULL;
    HFONT  hFont;
    DWORD  cTBCombos;
    TEXTMETRIC tm;
    HDC    hdc;
    HWND * pHwndCombo = NULL;

    struct ComboInfo {
        UINT ComboIDM;
        UINT ToolbarIDR;
        LONG cx;
        LONG dx;
        LONG cElements;
        UINT ComboStyle;
    };
    static const ComboInfo tbCombos[] =
    {
        { IDM_BLOCKFMT,  IDR_HTMLFORM_TBFORMAT,       5, 100, 16,
                CBS_DROPDOWNLIST},
        { IDM_FONTNAME,    IDR_HTMLFORM_TBFORMAT,   110, 150, 43,
                CBS_SORT | CBS_DROPDOWNLIST},
        { IDM_FONTSIZE,    IDR_HTMLFORM_TBFORMAT,   265,  40,  8,
                CBS_DROPDOWNLIST},
        { IDM_FORECOLOR,   IDR_HTMLFORM_TBFORMAT,   384,  55, 12,
                CBS_DROPDOWNLIST},
        { 0, 0, 0, 0, 0}
    };


    static const TBBUTTON tbFmtButton[] =
    {
        // reserved space for HTML Markup Tag,FontName, and FontSize Comboboxes
        {110, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {155, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        { 45, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {0, IDM_BOLD,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {1, IDM_ITALIC,    TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},
        {2, IDM_UNDERLINE, TBSTATE_ENABLED, TBSTYLE_CHECK,  0L, 0},

        // reserved space for BackGroundColor Combobox.
        { 65, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {3, IDM_JUSTIFYLEFT,   TBSTATE_CHECKED, TBSTYLE_CHECK, 0L, 0},
        {4, IDM_JUSTIFYCENTER, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {5, IDM_JUSTIFYRIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {6, IDM_ORDERLIST,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0L, 0},
        {7, IDM_UNORDERLIST, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {8, IDM_OUTDENT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {9, IDM_INDENT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {5, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},

        {10, IDM_BLOCKDIRLTR, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {11, IDM_BLOCKDIRRTL, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {12, IDM_MULTIPLESELECTION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {13, IDM_2D_POSITION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0 },
        {14, IDM_ABSOLUTE_POSITION, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0 },
        {15, IDM_LIVERESIZE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
    };


    _hwndFormatToolbar = CreateToolbarEx(
            _hwnd,
            WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | TBSTYLE_TOOLTIPS | CCS_NODIVIDER ,
            IDR_HTMLPAD_TOOLBAR,
            15,                             // number of bitmaps
            g_hInstResource,
            IDB_HTMLPAD_TBFORMAT ,
            (LPCTBBUTTON) &tbFmtButton,
            ARRAY_SIZE(tbFmtButton),
            16,
            16,
            16,
            16,
            sizeof(TBBUTTON));

    if (!(_hwndFormatToolbar))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
        RECT rcClient;
        GetClientRect( _hwnd, &rcClient);

        RECT rcHost;
        GetWindowRect( _hwnd, & rcHost);
        newTop = 26 ;
        RECT rcTopToolbar;
        GetWindowRect( _hwndToolbar, &rcTopToolbar );
        newTop = rcTopToolbar.bottom - rcTopToolbar.top;
        RECT rcToolbar;
        GetWindowRect( _hwnd, &rcToolbar);

        ::MoveWindow(
                _hwndFormatToolbar,
                0,
                newTop  ,
                3000 /*rcHost.right - rcHost.left*/ ,
                rcToolbar.bottom - rcToolbar.top ,
                TRUE);


    for (cTBCombos = 0; tbCombos[cTBCombos].ComboIDM; cTBCombos ++)
    {
        switch (tbCombos[cTBCombos].ComboIDM)
        {
        case IDM_BLOCKFMT:
            pHwndCombo = &(_hwndComboTag);
            break;
        case IDM_FONTNAME:
            pHwndCombo = &(_hwndComboFont);
            break;
        case IDM_FONTSIZE:
            pHwndCombo = &(_hwndComboSize);
            break;
        case IDM_FORECOLOR:
            pHwndCombo = &(_hwndComboColor);
            break;
        }
        switch (tbCombos[cTBCombos].ToolbarIDR)
        {
        case IDR_HTMLFORM_TBSTANDARD:
            hwndToolbar = _hwndToolbar;
            break;
        case IDR_HTMLFORM_TBFORMAT:
            hwndToolbar = _hwndFormatToolbar;
            break;
        }

        Assert(hwndToolbar);

        *pHwndCombo = CreateWindow(
                TEXT("COMBOBOX"),
                TEXT(""),
                WS_CHILD | WS_VSCROLL | tbCombos[cTBCombos].ComboStyle,
                0,
                0,
                tbCombos[cTBCombos].dx,
                0,
                hwndToolbar,
                (HMENU)(ULongToPtr(tbCombos[cTBCombos].ComboIDM)),
                GetResourceHInst(),
                NULL);
        if (!(*pHwndCombo))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
        SendMessage(*pHwndCombo, WM_SETFONT, (WPARAM) hFont, FALSE);
        hdc   = ::GetDC(*pHwndCombo);
        GetTextMetrics(hdc, &tm);
        ::ReleaseDC(*pHwndCombo, hdc);
        DeleteObject(hFont);

        EnableWindow(*pHwndCombo, TRUE);
        ::ShowWindow(*pHwndCombo, SW_SHOW);
        ::MoveWindow(
                *pHwndCombo,
                tbCombos[cTBCombos].cx,
                2,
                tbCombos[cTBCombos].dx,
                tm.tmHeight * min((long) MAX_COMBO_VISUAL_ITEMS,
                        (long) tbCombos[cTBCombos].cElements),
                FALSE);
        lpfnDefCombo = (WNDPROC) GetWindowLongPtr(*pHwndCombo, GWLP_WNDPROC);
        InstallComboboxTooltip(*pHwndCombo, tbCombos[cTBCombos].ComboIDM);

        }

Cleanup:
    RRETURN ( hr );

}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::ResetZoomPercent
//
//--------------------------------------------------------------------
void
CPadDoc::ResetZoomPercent()
{
    ::SendMessage(_hwndComboZoom, CB_SETCURSEL, INDEX_ZOOM_100, 0);
}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::ApplyZoomPercent
//
//--------------------------------------------------------------------
void
CPadDoc::ApplyZoomPercent()
{
    ::SendMessage(
        _hwnd,
        WM_COMMAND,
        (WPARAM)MAKELONG(IDM_ZOOMPERCENT, CBN_SELENDOK),
        (LPARAM)_hwndComboZoom);
}

//+-------------------------------------------------------------------
//
// Member:  CPadDoc::InitStandardToolbar
//
//--------------------------------------------------------------------
void
CPadDoc::InitStandardToolbar()
{
    AddComboboxItems(_hwndComboZoom, TRUE, ComboZoomItems);
    ResetZoomPercent();
}


//+-------------------------------------------------------------------
//
// Member:  CDoc::InitFormatToolbar
//
//--------------------------------------------------------------------

void
CPadDoc::InitFormatToolbar()
{

    HDC      hdc;
    HRESULT  hr = S_OK ;

    struct ComboStruct {
        UINT ComboIDM;
        BOOL fLoaded;
    };

    // load items into ComboTag, ComboZoom and ComboSize comboboxes
    ComboStruct ComboLoad[] = {
            { IDM_FONTSIZE, FALSE },
            { IDM_GETBLOCKFMTS, FALSE },
            { 0, FALSE },
    };
    int i;

    if ( ! _fComboLoaded)
    {
        //
        // Load Font Names
        //
        hdc = ::GetDC(_hwnd);
        EnumFontFamilies(
                hdc,
                NULL,
                FillFontProc,
                (LPARAM)_hwndComboFont);
        ::ReleaseDC(_hwnd, hdc);


        //
        // Load Colors
        //
        AddComboboxItems(_hwndComboColor, TRUE, ComboColorItems);
        SendMessage(_hwndComboColor, CB_SETCURSEL, 0, 0);
        _fComboLoaded = TRUE;


        VARIANTARG varRange;
        LONG lLBound, lUBound, lIndex, lValue;
        BSTR  bstrBuf;
        TCHAR szBuf[64];
        SAFEARRAY * psa = NULL;
        HWND hwndCombobox = NULL;

        //
        // Load Sizes and Default Block Formats.
        //
        for (i = 0; ComboLoad[i].ComboIDM; i ++)
        {
            if (ComboLoad[i].fLoaded)
                continue;

            switch (ComboLoad[i].ComboIDM)
            {
            case IDM_FONTSIZE:
                hwndCombobox = _hwndComboSize;
                break;
            case IDM_GETBLOCKFMTS:
                hwndCombobox = _hwndComboTag;
                break;
            }
            varRange.vt = VT_ARRAY;
            varRange.parray = psa;

            IOleCommandTarget* pCommandTarget = NULL;

            if ( _pInPlaceObject )
                hr = THR( _pInPlaceObject->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget));

            if ( ! hr )
                hr = THR( pCommandTarget->Exec(
                        (GUID *)&CGID_MSHTML,
                        ComboLoad[i].ComboIDM,
                        MSOCMDEXECOPT_DONTPROMPTUSER,
                        NULL,
                        &varRange));

            pCommandTarget->Release();

            // NULL pointer will sometimes return huge values and go into
            // an infinite loop.
            if (OK(hr) && V_ARRAY(&varRange) != NULL)
            {
                psa = V_ARRAY(&varRange);
                SafeArrayGetLBound(psa, 1, &lLBound);
                SafeArrayGetUBound(psa, 1, &lUBound);
                for (lIndex = lLBound; lIndex <= lUBound; lIndex ++)
                {
                    switch (ComboLoad[i].ComboIDM)
                    {
                    case IDM_GETBLOCKFMTS:
                        SafeArrayGetElement(psa, &lIndex, &bstrBuf);
                        SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) bstrBuf);
                        SysFreeString(bstrBuf);
                        break;

                    case IDM_FONTSIZE:
                        SafeArrayGetElement(psa, &lIndex, &lValue);
                        Format(0, szBuf, ARRAY_SIZE(szBuf), TEXT("<0d>"), lValue);
                        SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM) szBuf);
                        break;
                    }
                }

                // OLEAUT32 crashes if psa is NULL
                if (psa)
                {
                    SafeArrayDestroyData(psa);
                }
                SafeArrayDestroy(psa);

                ComboLoad[i].fLoaded = TRUE;
            }
        }

        _fComboLoaded = TRUE;
    }

}

///--------------------------------------------------------------
//
// Member:    CPadDoc::CreateToolBarUI
//
// Synopsis: Creates the PAD UI. We always create the "standard" toolbar
// and the Editing UI.
//
//
//---------------------------------------------------------------
HRESULT
CPadDoc::CreateToolBarUI()
{
    HRESULT hr = S_OK;

    CreateStandardToolbar();
    CreateFormatToolbar();

    if ( IsEdit())
        ShowFormatToolbar();
    else
        HideFormatToolbar();

    RRETURN ( hr );
}



void
CPadDoc::DestroyToolbars()
{
    if (_hwndToolbar)
    {
        if (_hwndComboZoom) DestroyWindow(_hwndComboZoom);
        DestroyWindow(_hwndToolbar);
        _hwndComboZoom = NULL;
        _hwndToolbar = NULL;
    }
    if (_hwndFormatToolbar)
    {
        if ( _hwndComboTag) DestroyWindow(_hwndComboTag);
        if ( _hwndComboFont) DestroyWindow(_hwndComboFont);
        if ( _hwndComboSize) DestroyWindow(_hwndComboSize);
        if ( _hwndComboColor) DestroyWindow(_hwndComboColor);
        DestroyWindow(_hwndFormatToolbar);

        _hwndComboTag   = NULL;
        _hwndComboFont  = NULL;
        _hwndComboSize  = NULL;
        _hwndComboColor = NULL;
        _hwndFormatToolbar   = NULL;
    }
}

//+======================
// Move it to the right place
//
//-----------------------
HRESULT
CPadDoc::MoveFormatToolbar()
{
    HRESULT hr = S_OK;

    if (_hwndToolbar || _hwndFormatToolbar)
    {
        RECT         rcToolbar;
        RECT         rcFormatToolbar;

        if ( _hwndToolbar)
        {
            GetWindowRect(_hwndToolbar, &rcToolbar);
        }
        else
        {
            SetRectEmpty(&rcToolbar);
        }
        if ( _hwndFormatToolbar)
        {
            GetWindowRect(_hwndFormatToolbar, &rcFormatToolbar);
        }
        else
        {
            SetRectEmpty(&rcFormatToolbar);
        }

        if (hr)
            goto Error;

        if ( _hwndFormatToolbar)
        {
            RECT rcRect;
            GetWindowRect( _hwnd, &rcRect );

            ::MoveWindow(
                    _hwndFormatToolbar,
                    0,
                    50 ,
                    rcFormatToolbar.right - rcFormatToolbar.left,
                    rcFormatToolbar.bottom - rcFormatToolbar.top,
                    TRUE);
        }
    }
Error:

    RRETURN_NOTRACE(hr);
}

BOOL CPadDoc::IsEditCommand(WORD idm)
{
    switch ( idm )
    {
        case IDM_IMAGE:
        case IDM_INSERTOBJECT:
        case IDM_HORIZONTALLINE:
        case IDM_LINEBREAKNORMAL:
        case IDM_LINEBREAKLEFT:
        case IDM_LINEBREAKRIGHT:
        case IDM_LINEBREAKBOTH:
        case IDM_NONBREAK:
        case IDM_PAGEBREAK:
        case IDM_SPECIALCHAR:
        case IDM_MARQUEE:
        case IDM_1D:
        case IDM_TEXTBOX:
#ifdef NEVER
        case IDM_HTMLAREA:
#endif
        case IDM_TEXTAREA:
        case IDM_CHECKBOX:
        case IDM_RADIOBUTTON:
        case IDM_DROPDOWNBOX:
        case IDM_LISTBOX:
        case IDM_BUTTON:
        case IDM_IFRAME:
            return TRUE;

        default:
            return FALSE;
        }
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::UpdateDirtyUI
//
//--------------------------------------------------------------------

LRESULT
CPadDoc::UpdateDirtyUI()
{
    BOOL  fDirty = GetDirtyState();
    BOOL  fDirtyUI;
    TCHAR szBuf[512];
    INT   iTitleLen;

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    iTitleLen = _tcslen(szBuf);
    Assert(iTitleLen > 0);

    fDirtyUI = (szBuf[iTitleLen-1] == TCHAR('*'));

    if (fDirty != fDirtyUI)
    {
        if (fDirty)
        {
            if (iTitleLen < 511)
            {
                szBuf[iTitleLen]   = TCHAR('*');
                szBuf[iTitleLen+1] = 0;
            }
        }
        else
        {
            szBuf[iTitleLen-1]= 0;
        }
        SetWindowText(_hwnd, szBuf);
    }

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::SetScriptRecorder
//
//--------------------------------------------------------------------

void
CPadDoc::SetScriptRecorder(IScriptRecorder *pScriptRecorder)
{
    delete _pScriptRecorder;
    _pScriptRecorder = pScriptRecorder;
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendQuotedString
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::AppendQuotedString(CStr &str, TCHAR *szString, UINT cLength)
{
    HRESULT hr = S_OK;

    for (UINT i = 0; i < cLength; i++)
    {
        switch (szString[i])
        {
            case '\n':
                IFC( str.Append(_T("\\n"), 2) );
                break;

            case '\t':
                IFC( str.Append(_T("\\t"), 2) );
                break;

            case '\r':
                IFC( str.Append(_T("\\r"), 2) );
                break;

            case '\"':
            case '\'':
            case '\\':
                IFC( str.Append(_T("\\"), 1) );
                IFC( str.Append(&szString[i], 1) );
                break;

            default:
                IFC( str.Append(&szString[i], 1) );
        }
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendElementHTML
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::AppendElementAttributes(IMarkupServices *pMarkupServices, CStr &str, IHTMLElement *pElement)
{
    HRESULT                     hr = S_OK;
    IDispatch                   *pdispAttrCollection = NULL;
    IHTMLAttributeCollection    *pAttrCollection = NULL;
    IHTMLDOMNode                *pDomNode = NULL;
    IDispatch                   *pdispAttr = NULL;
    IHTMLDOMAttribute           *pDomAttr = NULL;
    BOOL                        fFirstAttr = TRUE;
    LONG                        lLength;
    VARIANT                     varIndex;
    VARIANT_BOOL                vBool;
    LONG                        i;
    BSTR                        bstrNodeName = NULL;
    VARIANT                     varValue;
    VARIANT                     varValueBSTR;

    VariantInit(&varIndex);
    VariantInit(&varValue);
    VariantInit(&varValueBSTR);

    //
    // Get attribute collection
    //
    IFC( pElement->QueryInterface(IID_IHTMLDOMNode, (LPVOID *)&pDomNode) );
    IFC( pDomNode->get_attributes(&pdispAttrCollection) );
    if (!pdispAttrCollection)
        goto Cleanup;
    IFC( pdispAttrCollection->QueryInterface(IID_IHTMLAttributeCollection, (LPVOID *)&pAttrCollection) );

    //
    // Iterate through attributes
    //
    IFC( pAttrCollection->get_length(&lLength) );
    V_VT(&varIndex) = VT_I4;

    for (i = 0; i < lLength; ++i)
    {
        V_I4(&varIndex) = i;

        ClearInterface(&pdispAttr);
        IFC( pAttrCollection->item(&varIndex, &pdispAttr) );

        ClearInterface(&pDomAttr);
        IFC( pdispAttr->QueryInterface(IID_IHTMLDOMAttribute, (LPVOID *)&pDomAttr) );

        IFC( pDomAttr->get_specified(&vBool) );
        if (BOOL_FROM_VARIANT_BOOL(vBool))
        {
            // Output attribute
            SysFreeString(bstrNodeName);
            bstrNodeName = NULL;

            IFC( pDomAttr->get_nodeName(&bstrNodeName) );

            if (StrCmp(bstrNodeName, L"style") != 0)
            {
                // Output attribute sperator
                if (!fFirstAttr)
                    IFC( str.Append(L", ") )
                else
                    IFC( str.Append(_T(" ")) );

                fFirstAttr = FALSE;

                IFC( str.Append(bstrNodeName) );
                IFC( str.Append(L"=") );

                VariantClear(&varValue);
                IFC( pDomAttr->get_nodeValue(&varValue) );

                VariantClear(&varValueBSTR);
                IFC( VariantChangeType(&varValueBSTR, &varValue, 0, VT_BSTR) );

                IFC( str.Append(V_BSTR(&varValueBSTR)) );
            }
        }
    }


Cleanup:
    ReleaseInterface(pAttrCollection);
    ReleaseInterface(pdispAttrCollection);
    ReleaseInterface(pdispAttr);
    ReleaseInterface(pDomAttr);
    ReleaseInterface(pDomNode);
    SysFreeString(bstrNodeName);
    VariantClear(&varValue);
    VariantClear(&varValueBSTR);

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::AppendHTML
//
//--------------------------------------------------------------------

HRESULT
CPadDoc::AppendHTML(IMarkupServices *pMarkupServices, CStr &str, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    BOOL                fLeftOf;
    IHTMLElement        *pElement = NULL;
    IMarkupPointer      *pCurrent = NULL;
    MARKUP_CONTEXT_TYPE context;
    LONG                cch, cchGoal;
    BSTR                bstrTagName = NULL;
    const LONG          cBufferSize = 1024;
    TCHAR               szBuffer[cBufferSize];

    if (!pStart || !pEnd)
        return E_INVALIDARG;

    IFC( pMarkupServices->CreateMarkupPointer(&pCurrent) );
    IFC( pCurrent->MoveToPointer(pStart) );

    for (;;)
    {
        // Termination check
        IFC( pCurrent->IsLeftOf(pEnd, &fLeftOf) );
        if (!fLeftOf)
            break;

        // Output next
        cch = -1;
        ClearInterface(&pElement);

        IFC( pCurrent->Right(TRUE, &context, &pElement, &cch, NULL) );
        if (pElement)
        {
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
            IFC( pElement->get_tagName(&bstrTagName) );
        }

        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                Assert(pElement && bstrTagName);
                IFC( str.Append(_T("<")) );
                IFC( str.Append(bstrTagName) );
                IFC( AppendElementAttributes(pMarkupServices, str, pElement) );
                IFC( str.Append(_T(">")) );
                break;

            case CONTEXT_TYPE_ExitScope:
                Assert(pElement && bstrTagName);
                IFC( str.Append(_T("</")) );
                IFC( str.Append(bstrTagName) );
                IFC( str.Append(_T(">")) );
                break;

            case CONTEXT_TYPE_Text:
                IFC( pCurrent->IsLeftOfOrEqualTo(pEnd, &fLeftOf) );
                if (!fLeftOf)
                    IFC( pCurrent->MoveToPointer(pEnd) );

                IFC( pCurrent->Left(TRUE, NULL, NULL, &cch, NULL) );
                cchGoal = cch;
                while (cchGoal > 0)
                {
                    cch = min<LONG>(cchGoal, cBufferSize);

                    IFC( pCurrent->Right(TRUE, &context, NULL, &cch, szBuffer) );
                    Assert(context == CONTEXT_TYPE_Text);

                    IFC( str.Append(szBuffer, cch) );

                    cchGoal -= cch;
                }
                break;

            case CONTEXT_TYPE_None:
                goto Cleanup; // done
                break;

        }
    }


Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pCurrent);
    SysFreeString(bstrTagName);
    RRETURN(hr);
}


HRESULT
CPadDoc::IsPointerInside(IMarkupPointer *pPointer, IMarkupPointer *pRangeStart, IMarkupPointer *pRangeEnd)
{
    HRESULT hr = S_OK;
    BOOL    fIsInside = FALSE;

    IFC( pRangeStart->IsLeftOfOrEqualTo(pPointer, &fIsInside) );
    if (fIsInside)
    {
        IFC( pRangeEnd->IsRightOfOrEqualTo(pPointer, &fIsInside) );
    }

    hr = fIsInside ? S_OK : S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::InnerHTML
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::InnerHTML(IMarkupServices *pMarkupServices, IHTMLElement *pElement, BSTR *pbstrHTML)
{
    HRESULT                     hr;
    IMarkupPointer              *pStart = NULL;
    IMarkupPointer              *pEnd = NULL;
    IMarkupPointer2             *pStart2 = NULL;
    IMarkupPointer2             *pEnd2 = NULL;

#if DBG == 1
    IMarkupPointer              *pLastEnd = NULL;
    IMarkupPointer              *pLastStart = NULL;
    BOOL                        fLastStartPositioned = FALSE;
    BOOL                        fLastEndPositioned = FALSE;
#endif
    IMarkupPointer              *pSelStart = NULL;
    IMarkupPointer              *pSelEnd = NULL;

    CStr                        str;
    IHTMLEditServices           *pIEdSvc = NULL;
    ISelectionServices          *pSelSvc = NULL;
    IDispatch                   *pDocDisp = NULL;
    IHTMLDocument               *pDoc = NULL;
    IServiceProvider            *pSP = NULL;
    ISegmentList                *pSegmentList = NULL;
    ISegmentListIterator        *pIter = NULL;
    ISegment                    *pSegment = NULL;
    INT                         iSegmentCount = 0;
    SELECTION_TYPE              eSelectionType;
    BOOL                        fRightOf;

    if (!pbstrHTML)
        return E_INVALIDARG;

    *pbstrHTML = NULL;

    // Position pointers
    IFC( pMarkupServices->CreateMarkupPointer(&pStart) );
    IFC( pStart->QueryInterface( IID_IMarkupPointer2, (void**) & pStart2 ));
    IFC( pStart2->MoveToContent(pElement, TRUE ) );

    IFC( pMarkupServices->CreateMarkupPointer(&pEnd) );
    IFC( pEnd->QueryInterface( IID_IMarkupPointer2, (void**) & pEnd2 ));
    IFC( pEnd2->MoveToContent(pElement, FALSE) );

    // Get the selection services
    IFC( get_Document(&pDocDisp) );
    IFC( pDocDisp->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
    IFC( pDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) );

    IFC( pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)& pIEdSvc ) );
    IFC( pIEdSvc->GetSelectionServices(NULL, &pSelSvc) );
    IFC( pSelSvc->QueryInterface(IID_ISegmentList, (LPVOID *)&pSegmentList ) );

    IFC( pSegmentList->GetType(&eSelectionType) );
    IFC( pSegmentList->CreateIterator(&pIter) );

    if( pIter->IsDone() == S_FALSE )
    {
        // TODO: sort all segment pointers for multiple selection

        IFC( pMarkupServices->CreateMarkupPointer(&pSelStart) );
        IFC( pMarkupServices->CreateMarkupPointer(&pSelEnd) );
#if DBG == 1
        IFC( pMarkupServices->CreateMarkupPointer(& pLastStart ));
        IFC( pMarkupServices->CreateMarkupPointer(& pLastEnd ));
#endif
        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pSegment) );

            IFC( pSegment->GetPointers(pSelStart, pSelEnd) );

            switch (eSelectionType)
            {
                case SELECTION_TYPE_Caret:
                    if (IsPointerInside(pSelStart, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelStart) );
                        IFC( str.Append(_T("{caret}")) );
                        IFC( pStart->MoveToPointer(pSelStart) );
                    }
                    break;

                case SELECTION_TYPE_Text:
                    IFC( pSelStart->IsRightOf(pSelEnd, &fRightOf) );
                    if (fRightOf)
                    {
                        // swap pointers
                        IMarkupPointer *pTempPointer = pSelStart;
                        pSelStart = pSelEnd;
                        pSelEnd = pTempPointer;
                    }

                    if (IsPointerInside(pSelStart, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelStart) );
                        IFC( str.Append(_T("{selection start}")) );
                        IFC( pStart->MoveToPointer(pSelStart) );
#if DBG == 1
                        if ( fLastStartPositioned )
                        {
                            BOOL fLastRightOf = FALSE;
                            pSelStart->IsRightOfOrEqualTo( pLastStart, & fLastRightOf);
                            AssertSz( fLastRightOf, "Multiple Text Selection Segments are not ordered");
                        }
                        pLastStart->MoveToPointer( pSelStart );
                        fLastStartPositioned = TRUE;
#endif
                    }
                    if (IsPointerInside(pSelEnd, pStart, pEnd) == S_OK)
                    {
                        IFC( AppendHTML(pMarkupServices, str, pStart, pSelEnd) );
                        IFC( str.Append(_T("{selection end}")) );
                        IFC( pStart->MoveToPointer(pSelEnd) );
#if DBG == 1
                        if ( fLastEndPositioned )
                        {
                            BOOL fLastRightOf = FALSE;
                            pSelEnd->IsRightOfOrEqualTo( pLastEnd, & fLastRightOf);
                            AssertSz( fLastRightOf, "Multiple Text Selection Segments are not ordered");
                        }
                        pLastEnd->MoveToPointer( pSelEnd );
                        fLastEndPositioned = TRUE;
#endif

                    }
                    break;
            }

            ClearInterface( &pSegment );
            IFC( pIter->Advance() );
        }
    }

    IFC( AppendHTML(pMarkupServices, str, pStart, pEnd) );
    IFC( str.AllocBSTR(pbstrHTML) );


Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    ReleaseInterface(pStart2);
    ReleaseInterface(pEnd2);
    ReleaseInterface(pSelStart);
    ReleaseInterface(pSelEnd);
    ReleaseInterface(pIEdSvc);
    ReleaseInterface(pSelSvc);
    ReleaseInterface(pSegmentList);
    ReleaseInterface(pDocDisp);
    ReleaseInterface(pDoc);
    ReleaseInterface(pSP);
    ReleaseInterface(pIter);
    ReleaseInterface(pSegment);
#if DBG == 1
    ReleaseInterface( pLastStart );
    ReleaseInterface( pLastEnd );
#endif
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::CurrentBlockElement
//
//--------------------------------------------------------------------
HRESULT
CPadDoc::CurrentBlockElement( IMarkupServices  *pMarkupServices,
                              IHTMLElement     **ppBlockElement )
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pOldElement   = NULL;
    IHTMLElement        *pElement      = NULL;
    BSTR                bstrDisplay = NULL;
    IHTMLElement2       *pElement2 = NULL;
    IHTMLCurrentStyle   *pCurrStyle = NULL;
    IHTMLCurrentStyle2  *pCurrStyle2 = NULL;
    IDisplayServices    *pDisplayServices = NULL;
    IHTMLCaret          *pCaret        = NULL;
    IMarkupPointer      *pCaretPointer = NULL;
    BOOL                fStopAtElement;
    VARIANT_BOOL        fHasLayout;

    if (!ppBlockElement || !pMarkupServices)
        return E_INVALIDARG;

    *ppBlockElement = NULL;
    IFC( pMarkupServices->QueryInterface(IID_IDisplayServices, (LPVOID *)&pDisplayServices) );

    // Get scope of caret
    IFC( pDisplayServices->GetCaret(&pCaret) );
    IFC( pMarkupServices->CreateMarkupPointer(&pCaretPointer) );
    IFC( pCaret->MoveMarkupPointerToCaret(pCaretPointer) );
    IFC( pCaretPointer->CurrentScope(&pElement) );

    // Walk up to find current block element
    do
    {
        IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        IFC(pElement2->get_currentStyle(&pCurrStyle));
        if (pCurrStyle)
        {
            IFC(pCurrStyle->get_display(&bstrDisplay));
            fStopAtElement = !_tcscmp(bstrDisplay, _T("block"));

            if (fStopAtElement)
                break;

            IFC(pCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&pCurrStyle2));
            IFC(pCurrStyle2->get_hasLayout(&fHasLayout));

            fStopAtElement = fHasLayout ? TRUE : FALSE;
            if (fStopAtElement)
                break;
        }

        pOldElement = pElement;
        hr = THR(pOldElement->get_parentElement(&pElement));
        pOldElement->Release();
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElement2);
        ClearInterface(&pCurrStyle);
        ClearInterface(&pCurrStyle2);
        SysFreeString(bstrDisplay);
        bstrDisplay = NULL;
    }
    while (pElement);

    if (fStopAtElement)
    {
        *ppBlockElement = pElement;
        pElement->AddRef();
    }

Cleanup:
    ReleaseInterface(pDisplayServices);
    ReleaseInterface(pElement);
    ReleaseInterface(pElement2);
    ReleaseInterface(pCurrStyle);
    ReleaseInterface(pCurrStyle2);
    ReleaseInterface(pCaret);
    ReleaseInterface(pCaretPointer);
    SysFreeString(bstrDisplay);
    RRETURN(hr);
}

HRESULT
CPadDoc::InitEditMode()
{
    HRESULT hr ;
    IOleCommandTarget* pCommandTarget = NULL;
    VARIANT var;
    GUID theGUID = CGID_MSHTML;

    VariantInit( & var );
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_TRUE;

    hr = THR(_pInPlaceObject->QueryInterface(
                IID_IOleCommandTarget, (void **)&pCommandTarget));
    if ( hr )
        goto Cleanup;

    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_MULTIPLESELECTION,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    if ( hr )
        goto Cleanup;

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_2D_POSITION ,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_ABSOLUTE_POSITION ,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));

    V_BOOL(&var) = VARIANT_FALSE;
    hr = THR( pCommandTarget->Exec(
                    & theGUID,
                    IDM_LIVERESIZE,
                    MSOCMDEXECOPT_DODEFAULT,
                    &var,
                    NULL));
    if ( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pCommandTarget );

    RRETURN( hr );

}

//+====================================================================================
//
// Method: OnSetTitle
//
// Synopsis: Change the window UI. Also a cheap way to sync doc changes.
//
//------------------------------------------------------------------------------------


VOID
CPadDoc::OnSetTitle( TCHAR* pchTitle)
{
    SetDocTitle(pchTitle);
}

VOID
CPadDoc::InplaceDeactivate()
{
}

//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::InitCicero
//              Initialize Cicero -- the Universal Input Manager
//              It is implemented as a designer extention to the editor
//
//  Created:    Nov-12-1999     zhenbinx
//--------------------------------------------------------------------
#if CICERO==1
HRESULT CPadDoc::ToggleCicero(void)
{
    HRESULT        hr = S_OK;
    IDispatch      *pDispatch = NULL;
    IHTMLDocument2 *pHTMLDoc = NULL;

    IFC( get_Document(&pDispatch) );
    IFC( pDispatch->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDoc) );
    if (_pCicero)
    {
        IFC(_pCicero->Unattach());
        IFC(_pCicero->DeInitUim());
        ClearInterface(&_pCicero);
    }
    else
    {
        IFC(CoCreateInstance(CLSID_HTMLUim, NULL, CLSCTX_INPROC_SERVER,
                             IID_IHTMLUim, (LPVOID *)&_pCicero));

        IFC(_pCicero->InitUim());
        IFC(_pCicero->Attach(pHTMLDoc) );
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pHTMLDoc);
    RRETURN(hr);
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     CPadDoc::EnableIMEReconversion
//
//  Created:    01/26/1999     zhenbinx
//--------------------------------------------------------------------
HRESULT
CPadDoc::EnableIMEReconversion(BOOL fEnable)
{
    IOleCommandTarget   *pCommandTarget;
    HRESULT hr = S_OK;
    if ( _pInPlaceObject &&
         OK(_pInPlaceObject->QueryInterface(
            IID_IOleCommandTarget, (void **)&pCommandTarget)) )
    {
        VARIANT var;

        VariantInit(&var);
        var.vt = VT_BOOL;
        V_BOOL(&var) = fEnable? VARIANT_TRUE : VARIANT_FALSE;

        hr = pCommandTarget->Exec(
                &CGID_MSHTML,
                IDM_IME_ENABLE_RECONVERSION,
                MSOCMDEXECOPT_DONTPROMPTUSER,
                &var,
                NULL);

        pCommandTarget->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padfact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padfact.cxx
//
//  Contents:   Class factories.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

CPadFactory * CPadFactory::s_pFactoryFirst = NULL;

CPadFactory::CPadFactory(REFCLSID clsid, HRESULT (*pfnCreate)(IUnknown **), void (*pfnRevoke)())
{
    _pfnCreate = pfnCreate;
    _pfnRevoke = pfnRevoke;
    _clsid = clsid;
    _dwRegister = 0;
    _pFactoryNext = s_pFactoryFirst;
    s_pFactoryFirst = this;
}

HRESULT 
CPadFactory::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}
    

ULONG 
CPadFactory::AddRef()
{
    return 0;
}

ULONG 
CPadFactory::Release()
{
    return 0;
}

HRESULT
CPadFactory::CreateInstance(
        IUnknown *pUnkOuter,
        REFIID   iid,
        void **  ppv)
{
    IUnknown *pUnk = NULL;
    HRESULT hr;
    
    if (pUnkOuter)
        RRETURN(CLASS_E_NOAGGREGATION);

    hr = THR(_pfnCreate(&pUnk));
    if (hr)
        goto Cleanup;

    hr = THR(pUnk->QueryInterface(iid, ppv));

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}

HRESULT
CPadFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        IncrementObjectCount();
    }
    else
    {
        DecrementObjectCount();
    }

    return S_OK;
}

HRESULT
CPadFactory::Register()
{
    HRESULT hr;
    CPadFactory *pFactory;

    for (pFactory = s_pFactoryFirst; pFactory; pFactory = pFactory->_pFactoryNext)
    {
        hr = THR(CoRegisterClassObject(
            pFactory->_clsid,
            pFactory,
            CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE,
            &pFactory->_dwRegister));
        if (hr)
            RRETURN(hr);
    }

    return S_OK;
}

HRESULT
CPadFactory::Revoke()
{
    CPadFactory *pFactory;

    for (pFactory = s_pFactoryFirst; pFactory; pFactory = pFactory->_pFactoryNext)
    {
        if (pFactory->_dwRegister)
        {
            IGNORE_HR(CoRevokeClassObject(pFactory->_dwRegister));
            pFactory->_dwRegister = 0;

            if(pFactory->_pfnRevoke)
                (*pFactory->_pfnRevoke)();
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padguid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padguid.cxx
//
//  Contents:   GUIDs
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

const GUID CLSID_CPadMessage = { 0xad000221, 0xa915, 0x11cf, 0x9c, 0xce, 0x00, 0xa0, 0xc9, 0x05, 0x64, 0xde };
const GUID IID_ICommandID = { 0x4a18a0e0, 0xae5d, 0x11cf, { 0xbf, 0xf1, 0x0, 0xaa, 0x0, 0x3f, 0x40, 0xd0 } };
const GUID GUID_ShellDocView = { 0x000214d1, 0, 0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const GUID CLSID_NSCP = { 0x61d8de20, 0xca9a, 0x11ce, 0x9e, 0xa5, 0x00, 0x80, 0xc8, 0x2b, 0xe3, 0xb6 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padmain.cxx
//
//  Contents:   WinMain and associated functions.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include "shlobj.h"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

void CreatePerfCtl(DWORD dwFlags, void * pvHost);
void DeletePerfCtl();

MtDefine(SAryThreads_pv, Pad, "s_aryThreads::_pv")
MtDefine(PADTHREADSTATE, Pad, "PADTHREADSTATE")
DeclareTag(tagPadNoCycleBreak, "Pad", "Don't call UrlZonesDetach in wininet.dll")

//+-------------------------------------------------------------------------
//
// Definitions required for files linked from other directories.
//
//--------------------------------------------------------------------------

CRITICAL_SECTION    CGlobalLock::g_cs;                  // Critical section to protect globals
BOOL                CGlobalLock::g_fInit = FALSE;           // Init flag to protect Critical Section
#if DBG==1
DWORD               CGlobalLock::g_dwThreadID = 0;      // Thread ID which owns the critical section
LONG                CGlobalLock::g_cNesting = 0;        // Enter/LeaveCriticalSection nesting level (DEBUG only)
#endif

// used for assert to fool the compiler
DWORD g_dwFALSE = 0;

// default to loading MSHTML.DLL from the pad directory
BOOL g_fLoadSystemMSHTML = 0;

#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

HINSTANCE           g_hInstCore;
HINSTANCE           g_hInstResource;
EXTERN_C HANDLE     g_hProcessHeap;
HANDLE              g_hProcessHeap;
DWORD               g_dwTls;

#if defined(_X86_)
// P6 counter system
HANDLE  g_hPStat;
char *  g_apchCtrShort[2];
char *  g_apchCtrLong[2];
char    g_achCtrModes[2];
#endif

extern void DeinitDynamicLibraries();
extern void FreeLibraries();

DeclareTag(tagDumpHeapsOnExit, "Pad", "Dump heaps on exit");

//+-------------------------------------------------------------------------
//
// Global variables
//
//--------------------------------------------------------------------------

ATOM               g_atomMain;
HWND               g_hwndMain;
HWND               g_hwndActiveWindow; // Handle to window that hosts Trident in another app
static LONGLONG    s_liPerfFreq;       // perf frequency
static LONGLONG    s_liTimeStart;      // time at start of subtest
static int         s_iInterval;
static long        s_lSecondaryObjCount = 0;

ExternTag(tagScriptLog);

//+-------------------------------------------------------------------------
//
// Timing stuff
//
//--------------------------------------------------------------------------

#define MAXINTERVALS 200
#define MAXNAME      100


struct INTERVAL
{
    int iTime;
    TCHAR achName[MAXNAME];
    BOOL fReset;
}
    intervals[MAXINTERVALS];

class CPadEvent : public CEventCallBack
{
public:

    virtual int Event(LPCTSTR pchEvent, BOOL fReset = FALSE);
};

int CPadEvent::Event(LPCTSTR pchName, BOOL fReset)
{
    LONGLONG    liTimeStop;       // time at stop of subtest

    LOCK_GLOBALS;

    QueryPerformanceCounter((LARGE_INTEGER *)&liTimeStop);
    if (s_iInterval < MAXINTERVALS)
    {
        intervals[s_iInterval].iTime = (int)(((liTimeStop - s_liTimeStart) * 1000) / s_liPerfFreq);
        _tcsncpy(intervals[s_iInterval].achName, pchName, MAXNAME);
        intervals[s_iInterval].fReset = fReset;
        s_iInterval++;
    }
    QueryPerformanceCounter((LARGE_INTEGER *)&s_liTimeStart);

    return 0;
}


static CDataAry<THREAD_HANDLE> s_aryThreads(Mt(SAryThreads_pv));
                                // array of thread handles.
                                // This array is used only by the main
                                // thread.


CPadEvent g_PadEvent;
CPadEvent * g_pEvent = NULL;

void DumpTimes()
{
#if 0
    CHAR    rgch[MAX_PATH];
    UINT    cch = (UINT) GetModuleFileNameA(g_hInstCore, rgch, sizeof(rgch));

    if (s_iInterval)
    {
        Assert(rgch[cch-4] == '.');
        strcpy(&rgch[cch-4], ".tim");
        FILE * f = fopen(rgch, "w");
        int iAbsTime = 0;

        if (f == NULL)
            return;

        for (int i = 0; i < s_iInterval; i++)
        {
            iAbsTime += intervals[i].iTime;
            if (intervals[i].fReset)
            {
                iAbsTime = 0;
            }
            fprintf(f, "%S,\t%d\t%d\n", intervals[i].achName, iAbsTime, intervals[i].iTime);
        }

        fclose(f);
    }
#endif
}

void
IncrementObjectCount()
{
    GetThreadState()->lObjCount++;
    Verify(InterlockedIncrement(&s_lSecondaryObjCount) > 0);
}

void
DecrementObjectCount()
{
    if (--GetThreadState()->lObjCount == 0)
    {
        PostQuitMessage(0);
    }
    Verify(InterlockedDecrement(&s_lSecondaryObjCount) >= 0);
}

void
CheckObjCount()
{
    if (GetThreadState()->lObjCount)
    {
        TraceTag((tagError,
                "Thread (TID=0x%08x) terminated with primary object count=%d",
                GetCurrentThreadId(), GetThreadState()->lObjCount));
    }
}

PADTHREADSTATE *
GetThreadState()
{
    PADTHREADSTATE * pts = (PADTHREADSTATE *)TlsGetValue(g_dwTls);
    //AssertSz(pts != NULL, "PADTHREADSTATE not initialized on this thread");
    return(pts);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreatePadDocThreadProc
//
//  Synopsis:   Creates a new pad window.
//
//
//--------------------------------------------------------------------------

DWORD WINAPI CALLBACK
CreatePadDocThreadProc(void * pv)
{
    CThreadProcParam *ptpp = (CThreadProcParam *)pv;
    CPadDoc *   pDoc = NULL;
    EVENT_HANDLE      hEvent = ptpp->_hEvent;
    HRESULT     hr;
    VARIANT     varScriptParam;
    PADTHREADSTATE * pts = (PADTHREADSTATE *)MemAllocClear(Mt(PADTHREADSTATE), sizeof(PADTHREADSTATE));

    if (pts == NULL)
        goto MemoryError;

    TlsSetValue(g_dwTls, pts);

    // Name this thread for IceCAP
    NameThread("PadDoc");

    ::StartCAP();

    // Emit the PadDoc thread's thread ID so people who are debugging can always
    // know which thread they are looking at - the primary, OLE-non-apartment-model
    // thread, or the 2ndary paddoc thread:
    TraceTag((tagError, "PadDoc 2ndary Thread ID: 0x%x", GetCurrentThreadId() ));

    hr = THR(OleInitialize(NULL));
    if (!OK(hr))
        goto Cleanup;

    pDoc = new CPadDoc(ptpp->_fUseShdocvw);

    if (!pDoc)
        goto MemoryError;

    if (ptpp->_ppStm)
    {
        hr = THR(CoMarshalInterThreadInterfaceInStream(
                IID_IUnknown,
                (IPad *) pDoc,
                ptpp->_ppStm));
        if (hr)
            goto Cleanup;
    }

    hr = pDoc->Init(ptpp->_uShow, g_pEvent);
    if (hr)
        goto Cleanup;

    switch (ptpp->_action)
    {
    case ACTION_SCRIPT:
        {
            BOOL  fKeepRunning        = ptpp->_fKeepRunning;
            TCHAR achParam[MAX_PATH];

            VariantInit(&varScriptParam);

            Assert(_tcslen(ptpp->_pchParam) <= MAX_PATH);

            _tcscpy(achParam, ptpp->_pchParam);

            //
            // Unblock the calling thread before we start executing script code,
            // otherwise we may deadlock. Because of this we must copy all the
            // parameters we plan on using because they'll be destroyed as soon
            // as the calling thread gets CPU time.
            //
            SetEvent(hEvent);
            hEvent = NULL;

            CheckError(pDoc->_hwnd, pDoc->ExecuteScript(achParam, &varScriptParam, FALSE));
            VariantClear(&varScriptParam);

            if (!fKeepRunning)
            {
                pDoc->ShowWindow(SW_HIDE);
            }
        }
        break;

    case ACTION_NEW:
        CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument));
        break;

    case ACTION_OPEN:
        if (ptpp->_fUseShdocvw)
        {
            CheckError(pDoc->_hwnd, pDoc->OpenFile(ptpp->_pchParam, NULL));
        }
        else
        {
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));
        }
        break;
        
    case ACTION_OPEN_EDITMODE:
        CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));

        hr = THR(pDoc->ExecuteCommand(IDM_EDITMODE, NULL, NULL));
        break;

    case ACTION_OPEN_SCRIPTMODE:
    {
        BSTR            bstrScriptPath = NULL;
        CScriptRecorder *pScriptRecorder = NULL;
        
        // Open file
        if (ptpp->_pchParam && *ptpp->_pchParam == 0)
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument));                    // new file
        else
            CheckError(pDoc->_hwnd, pDoc->Open(CLSID_HTMLDocument, ptpp->_pchParam));   // open file

        // Start script recorder
        bstrScriptPath = SysAllocString(ptpp->_pchParam);
        pScriptRecorder = new CScriptRecorder(pDoc);
        if (!bstrScriptPath || !pScriptRecorder)
        {
            SysFreeString(bstrScriptPath);            
            hr = E_OUTOFMEMORY;
            goto Cleanup;            
        }

        hr = THR(pScriptRecorder->Init(bstrScriptPath));
        
        if (SUCCEEDED(hr))
        {
            pDoc->SetScriptRecorder(pScriptRecorder);

            // Go to edit mode 
            hr = THR(pDoc->ExecuteCommand(IDM_EDITMODE, NULL, NULL));
        }
        
        SysFreeString(bstrScriptPath);
            
        if (hr)
            goto Cleanup;
        break;
    }

    case ACTION_HELP:
        pDoc->OnCommand(0, IDM_PAD_ABOUT, NULL);
        // Fall Through

    case ACTION_WELCOME:
        pDoc->Welcome();
        break;

    }

    // We are done with paramters, allow calling thread to continue.

    SetEvent(hEvent);
    hEvent = NULL;

    pDoc->Release();
    pDoc = NULL;

    CPadDoc::Run();

#if DBG==1
    CheckObjCount();
#endif

Cleanup:
    if (hEvent)
        SetEvent(hEvent);
    if (pDoc)
        pDoc->Release();

    UnregisterLocalCLSIDs();

    OleUninitialize();

    FreeLibraries();

    ::StopCAP();

    MemFree(pts);
    TlsSetValue(g_dwTls, NULL);

    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT
CreatePadDoc(CThreadProcParam * ptpp, IUnknown ** ppUnk)
{
    HRESULT         hr = S_OK;
    THREAD_HANDLE   hThread = NULL;
    EVENT_HANDLE    hEvent = NULL;
    LPSTREAM        pStm = NULL;
    DWORD           idThread, dwResult;

    hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);

    if (hEvent == NULL)
        RRETURN(GetLastWin32Error());

    if (ppUnk)
    {
        ptpp->_ppStm = &pStm;
    }

    ptpp->_hEvent = hEvent;
    hThread = CreateThread(NULL, 0, CreatePadDocThreadProc, ptpp, 0, &idThread);
    if (hThread == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    s_aryThreads.AppendIndirect(&hThread);

    ::SuspendCAP();

    dwResult = WaitForSingleObject(hEvent, INFINITE);
    Assert(dwResult == WAIT_OBJECT_0);

    ::ResumeCAP();

    if (pStm)
    {
        hr = THR(CoGetInterfaceAndReleaseStream(pStm, IID_IUnknown, (void **) ppUnk));
    }

Cleanup:
    ptpp->_hEvent = NULL;
    CloseEvent(hEvent);
    RRETURN(hr);
}

LRESULT
WndProcMain(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   switch (msg)
   {
   case WM_DESTROY:
       PostQuitMessage(0);
       break;

   default:
       return DefWindowProc(hwnd, msg, wParam, lParam);
   }

   return 0;
}

PADTHREADSTATE stateMain = { 0 };

static HRESULT
Initialize()
{
    HRESULT             hr = S_OK;
    WNDCLASS            wc;

    g_dwTls = TlsAlloc();
    if (g_dwTls == 0xFFFFFFFF)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    TlsSetValue(g_dwTls, &stateMain);

    EnableTag(tagScriptLog, TRUE);
    SetDiskFlag(tagScriptLog, TRUE);
    SetBreakFlag(tagScriptLog, FALSE);

    QueryPerformanceFrequency((LARGE_INTEGER *)&s_liPerfFreq);
    QueryPerformanceCounter((LARGE_INTEGER *)&s_liTimeStart);

    hr = CGlobalLock::Init();
    if (hr)
        goto Cleanup;

    g_hProcessHeap = GetProcessHeap();

    InitUnicodeWrappers();

    // Create "main" window.  This window is used to keep Windows
    // and OLE happy while we are waiting for something to happen
    // when launched to handle an embedding.

    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = WndProcMain;   // windows of this class.
    wc.hInstance = g_hInstCore;
    wc.hIcon = LoadIcon(g_hInstResource, MAKEINTRESOURCE(IDR_PADICON));
    wc.lpszClassName = SZ_APPLICATION_NAME TEXT(" Main");
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    g_atomMain = RegisterClass(&wc);

    if (!g_atomMain)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    g_hwndMain = CreateWindow(
            SZ_APPLICATION_NAME TEXT(" Main"),
            NULL, WS_OVERLAPPEDWINDOW,
            0, 0, 0, 0, NULL, NULL, g_hInstCore, NULL);
    if (!g_hwndMain)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(OleInitialize(NULL));
    if (hr)
        goto Cleanup;

#if 0
    // Force allocation of memory to hide leaks in OLEAUT32.
    DbgMemoryTrackDisable(TRUE);
    SysFreeString(SysAllocString(_T("Force Allocation Of Memory")));
    DbgMemoryTrackDisable(FALSE);
#endif

    CreatePerfCtl(0, NULL);

    g_hwndActiveWindow = 0;

Cleanup:
    RRETURN(hr);
}

static DYNLIB g_dynlibWininet = { NULL, NULL, "wininet.dll" };
static DYNPROC g_dynprocUrlZonesDetach = { NULL, &g_dynlibWininet, "UrlZonesDetach" };

static void
Terminate()
{
    extern void DeinitPalette();
    DeinitPalette();

#if defined(_X86_)
    int i;
    for (i=0; i<2; i++)
    {
        delete g_apchCtrShort[i];
        g_apchCtrShort[i] = NULL;
        delete g_apchCtrLong[i];
        g_apchCtrLong[i] = NULL;
    }
#endif

    if (g_hwndMain)
    {
        Assert(IsWindow(g_hwndMain));
        Verify(DestroyWindow(g_hwndMain));
    }

    if (g_atomMain)
    {
        Verify(UnregisterClass((TCHAR *)(DWORD_PTR)g_atomMain, g_hInstCore));
    }

    // Hack to break LoadLibrary cycle between WININET and URLMON

    if (    !IsTagEnabled(tagPadNoCycleBreak)
        &&  GetModuleHandleA("wininet.dll")
        &&  GetModuleHandleA("urlmon.dll")
        &&  LoadProcedure(&g_dynprocUrlZonesDetach) == S_OK)
    {
        ((void (STDAPICALLTYPE *)())g_dynprocUrlZonesDetach.pfn)();
    }

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x1");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x1");
    }
#endif

    CPadFactory::Revoke();

    DumpTimes();

    OleUninitialize();

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x2");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x2");
    }
#endif

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    DeinitControlPalette();
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED

    DeinitDynamicLibraries();

#if DBG==1
    if (IsTagEnabled(tagDumpHeapsOnExit))
    {
        DbgExDumpProcessHeaps();
        DeleteFileA("c:\\heapdump.x3");
        MoveFileA("c:\\heapdump.txt", "\\heapdump.x3");
    }
#endif

    CGlobalLock::Deinit();

    DeletePerfCtl();

    TlsFree(g_dwTls);
}


HRESULT
CheckError(HWND hwnd, HRESULT hr)
{
    TCHAR achBuf[MAX_PATH];

    if (OK(hr))
        return hr;

    if (!FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        hr,
        LANG_SYSTEM_DEFAULT,
        achBuf,
        ARRAY_SIZE(achBuf),
        NULL))
    {
        _tcscpy(achBuf, TEXT("Unknown error."));
    }

    MessageBox(hwnd,
            achBuf,
            NULL,
            MB_APPLMODAL | MB_ICONERROR | MB_OK);

    return hr;
}


void
Run ()
{
    for (;;)
    {
        DWORD   result ;
                int     cObjects = s_aryThreads.Size();
        THREAD_HANDLE * pHandle = s_aryThreads;

        // wait for any message sent or posted to this queue
        // or for one of the passed handles to become signaled

        ::SuspendCAP();

        result = MsgWaitForMultipleObjects(
                        cObjects,
                        pHandle,
                        FALSE,
                        INFINITE,
                        QS_ALLINPUT);

        ::ResumeCAP();

        // result tells us the type of event we have:
        // a message or a signaled handle

        // if there are one or more messages in the queue ...
        if (result == (WAIT_OBJECT_0 + cObjects))
        {
            MSG    msg;
            BOOL   fQuit;

            // read all of the messages in this next loop
            // removing each message as we read it

            for (;;)
            {
                ::SuspendCAP();

#ifndef UNIX
                Assert(!InSendMessage());
#endif
                fQuit = !PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

                ::ResumeCAP();

                if (fQuit)
                    break;

#ifdef UNIX
                if (msg.hwnd != GetDesktopWindow()) {
                    CPadDoc::RunOneMessage(&msg);
                    continue;
                }

                Assert(!InSendMessage());
#endif

                if (msg.message == WM_QUIT)
                    return;

                CPadDoc::RunOneMessage(&msg);
            }
        }
        else
        {
            int i = result - WAIT_OBJECT_0;

            CloseThread(s_aryThreads[i]);
            s_aryThreads.Delete(i);
            if (s_aryThreads.Size() == 0)
                return;
        }
    }
}
#ifdef UNIX
extern "C"
#endif
int WINAPI
PadMain(int argc, char ** argv, IMallocSpy * pSpy)
{
    HRESULT     hr = S_OK;
    char *      pchParam = NULL;
    TCHAR       achParam[MAX_PATH];
    int         nRet = 0;
    int         i;
    BOOL        fKeepRunning = FALSE;
    PAD_ACTION  action = ACTION_WELCOME;
    char *      pLogFileName = NULL;
    BOOL        fOpenLogFile = FALSE;
    BOOL        fDoTrace = FALSE;
    BOOL        fDialogs = TRUE;
    BOOL        fUseShdocvw = FALSE;

    // Name this thread for IceCAP
    NameThread("Main");

    ::StopCAPAll();

    hr = Initialize();
    if (hr)
        goto Cleanup;

    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiA(argv[i], "/embedding") == 0 ||
            lstrcmpiA(argv[i], "-embedding") == 0)
        {
            action = ACTION_SERVER;
            fOpenLogFile = TRUE;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/r") == 0 ||
                 lstrcmpiA(argv[i], "-r") == 0 ||
                 lstrcmpiA(argv[i], "/register") == 0 ||
                 lstrcmpiA(argv[i], "-register") == 0))
        {
            action = ACTION_REGISTER_PAD;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/local") == 0 ||
                 lstrcmpiA(argv[i], "-local") == 0))
        {
            action = ACTION_REGISTER_LOCAL_TRIDENT;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/system") == 0 ||
                 lstrcmpiA(argv[i], "-system") == 0))
        {
            action = ACTION_REGISTER_SYSTEM_TRIDENT;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/m") == 0 ||
                 lstrcmpiA(argv[i], "-m") == 0 ||
                 lstrcmpiA(argv[i], "/mail") == 0 ||
                 lstrcmpiA(argv[i], "-mail") == 0))
        {
            action = ACTION_REGISTER_MAIL;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/nomail") == 0 ||
                 lstrcmpiA(argv[i], "-nomail") == 0))
        {
            action = ACTION_UNREGISTER_MAIL;
        }
        else if (argc >= 2 &&
                (lstrcmpiA(argv[i], "/nuke") == 0 ||
                 lstrcmpiA(argv[i], "-nuke") == 0))
        {
            action = ACTION_NUKE_KNOWNDLLS;
        }
        else if (lstrcmpiA(argv[i], "-n") == 0 ||
                lstrcmpiA(argv[i], "/n") == 0)
        {
            action = ACTION_NEW;
        }
        else if (lstrcmpiA(argv[i], "-k") == 0 ||
                lstrcmpiA(argv[i], "/k") == 0)
        {
            fKeepRunning = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-s") == 0 ||
                lstrcmpiA(argv[i], "/s") == 0)
        {
            fDialogs = FALSE;
        }
        else if (lstrcmpiA(argv[i], "-t") == 0 ||
                lstrcmpiA(argv[i], "/t") == 0)
        {
            g_pEvent = &g_PadEvent;  // to log event times
        }
#ifdef UNIX_LATER
        else if (lstrcmpiA(argv[i], "-d") == 0 ||
                 lstrcmpiA(argv[i], "/d") == 0)
        {
            g_pEvent = new CDispatchEvent(); // to do dhtml via IDispatch
        }
#endif
        else if (lstrcmpiA(argv[i], "-l") == 0 ||
                lstrcmpiA(argv[i], "/l") == 0)
        {
            i++;
            fOpenLogFile = TRUE;
            if(i < argc)
            {
                pLogFileName = argv[i];
            }
        }
        else if (lstrcmpiA(argv[i], "-x") == 0 ||
                lstrcmpiA(argv[i], "/x") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i];
                action = ACTION_SCRIPT;
            }
        }
        else if (argc > 2 &&
                (lstrcmpiA(argv[i], "/trace") == 0 ||
                 lstrcmpiA(argv[i], "-trace") == 0))
        {
            fDoTrace = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-?") == 0 ||
                lstrcmpiA(argv[i], "/?") == 0)
        {
            action = ACTION_HELP;
        }
        else if (lstrcmpiA(argv[i], "-shdocvw") == 0 ||
                lstrcmpiA(argv[i], "/shdocvw") == 0)
        {
            fUseShdocvw = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-loadsystem") == 0 ||
                lstrcmpiA(argv[i], "/loadsystem") == 0)
        {
            g_fLoadSystemMSHTML = TRUE;
        }
        else if (lstrcmpiA(argv[i], "-nopreload") == 0 ||
                lstrcmpiA(argv[i], "/nopreload") == 0)
        {
            NoLocalCLSIDs();
        }
        else if (lstrcmpiA(argv[i], "-1") == 0 ||
                lstrcmpiA(argv[i], "/1") == 0)
        {
            BOOL (WINAPI *pfn)(HANDLE, DWORD);
            pfn = (BOOL (WINAPI *)(HANDLE, DWORD))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "SetProcessAffinityMask");
            if (pfn)
            {
                pfn(GetCurrentProcess(), 1);
            }
        }
        else if (lstrcmpiA(argv[i], "-rt") == 0 ||
                lstrcmpiA(argv[i], "/rt") == 0)
        {
            BOOL (WINAPI *pfn)(HANDLE, DWORD);
            pfn = (BOOL (WINAPI *)(HANDLE, DWORD))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "SetPriorityClass");
            if (pfn)
            {
                pfn(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
            }
        }
        else if (lstrcmpiA(argv[i], "-p6cnt") == 0 ||
                lstrcmpiA(argv[i], "/p6cnt") == 0)
        {
#if defined(_X86_)
            InitP6Counters();
#endif
        }
        else if (lstrcmpiA(argv[i], "-e") == 0 ||
                lstrcmpiA(argv[i], "/e") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i];
                action = ACTION_OPEN_EDITMODE;
            }
        }
        else if (lstrcmpiA(argv[i], "-g") == 0 ||
                lstrcmpiA(argv[i], "/g") == 0)
        {
            if (i + 1 < argc)
            {
                pchParam = argv[++i]; // open existing file
            }
            else
            {
                pchParam = "";        // create new file
            }
            action = ACTION_OPEN_SCRIPTMODE;
        } 
        else
        {
            pchParam = argv[i];
            action = ACTION_OPEN;
        }
    }

    if (fDoTrace)
    {
        hr = THR(RegisterLocalCLSIDs());
        if (hr == S_OK)
        {
            DbgExDoTracePointsDialog(FALSE);
        }
    }

    if((pLogFileName != NULL && *pLogFileName != 0) || fOpenLogFile)
    {
        DbgExOpenLogFile(pLogFileName);
    }


    if (pchParam)
    {
        MultiByteToWideChar(CP_ACP, 0, pchParam, -1, achParam, ARRAY_SIZE(achParam));
    }

    if (pSpy)
    {
        CoRegisterMallocSpy(pSpy);
    }

    // Emit the main thread's thread ID so people who are debugging can always
    // know which thread they are looking at - the primary, OLE-non-apartment-model
    // thread, or the 2ndary paddoc thread:
    TraceTag((tagError, "Main Thread ID: 0x%x", GetCurrentThreadId() ));

    switch (action)
    {
    case ACTION_SERVER:
        hr = THR(CPadFactory::Register());
        break;

    case ACTION_REGISTER_PAD:
        hr = THR(RegisterPad());
        goto Cleanup;

    case ACTION_REGISTER_LOCAL_TRIDENT:
        hr = THR(RegisterTrident(NULL, fDialogs, FALSE));
        goto Cleanup;

    case ACTION_REGISTER_SYSTEM_TRIDENT:
        hr = THR(RegisterTrident(NULL, fDialogs, TRUE));
        goto Cleanup;

    case ACTION_NUKE_KNOWNDLLS:
        hr = THR(NukeKnownDLLStuff());
        goto Cleanup;

    default:
        {
            CThreadProcParam tpp(fUseShdocvw, action, fKeepRunning, achParam);
            if (CheckError(NULL, CreatePadDoc(&tpp, NULL)) != S_OK)
                goto Cleanup;
        }
        break;
    }

    Run();

Cleanup:

    // Flush the message queue now

    {
        MSG msg;
        for (int n = 0; n < 1000; ++n)
            PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    }

    Terminate();
    return nRet;
}

#ifdef UNIX
extern "C"
#endif
BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore     = (HINSTANCE)hDll;
    g_hInstResource = (HINSTANCE)hDll;
#ifdef DLOAD1
    BaseDllHandle   = (HINSTANCE)hDll;    // for DelayLoadFailureHook
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls((HINSTANCE)hDll);

        //  Tags for the .dll should be registered before
        //  calling DbgExRestoreDefaultDebugState().  Do this by
        //  declaring each global tag object or by explicitly calling
        //  DbgExTagRegisterTrace.

        DbgExRestoreDefaultDebugState();

        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    AssertThreadDisable(FALSE);

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padole.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padole.cxx
//
//  Contents:   CPadDoc IOleObject implementation.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

HRESULT
CPadDoc::SetClientSite(IOleClientSite *)
{
    RRETURN(E_NOTIMPL);
}
       
HRESULT
CPadDoc::GetClientSite(IOleClientSite **ppClientSite)
{
    *ppClientSite = NULL;
    return S_OK;
}
      
HRESULT
CPadDoc::SetHostNames(LPCOLESTR, LPCOLESTR)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Close(DWORD)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetMoniker(DWORD , IMoniker *)
{
    RRETURN(E_NOTIMPL);
}
  
HRESULT
CPadDoc::GetMoniker(DWORD, DWORD, IMoniker **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::InitFromData(IDataObject *, BOOL, DWORD)
{
    RRETURN(E_NOTIMPL);
}
        
HRESULT
CPadDoc::GetClipboardData(DWORD, IDataObject **)
{
    RRETURN(E_NOTIMPL);
}
       
HRESULT
CPadDoc::DoVerb(LONG, LPMSG, IOleClientSite *, LONG, HWND, LPCOLERECT)
{
    RRETURN(E_NOTIMPL);
}
    
HRESULT
CPadDoc::EnumVerbs(IEnumOLEVERB **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Update()
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::IsUpToDate()
{
    RRETURN(E_NOTIMPL);
}
     
HRESULT
CPadDoc::GetUserClassID(CLSID *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetUserType(DWORD, LPOLESTR *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetExtent(DWORD, SIZEL *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetExtent(DWORD, SIZEL *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Advise(IAdviseSink *, DWORD *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::Unadvise(DWORD)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::EnumAdvise(IEnumSTATDATA **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::GetMiscStatus(DWORD, DWORD *)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::SetColorScheme(LOGPALETTE  *pLogpal)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::ParseDisplayName(IBindCtx *, LPOLESTR, ULONG *, IMoniker **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::EnumObjects(DWORD, IEnumUnknown **)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CPadDoc::LockContainer(BOOL)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padrc2.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padrc2.h
//
//  Contents:   Definitions for the Trident application
//
//-------------------------------------------------------------------------


//
// Custom Resource types
//

#define FILERESOURCE    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pad.rc
//
#define IDR_SEND_FORM                   2
#define IDR_READ_FORM                   3
#define IDR_PAD_ACCELERATORS            4
#define IDS_E_OUTOFMEMORY               100
#define IDF_CFG_FILE                    100
#define IDR_PADICON                     101
#define IDS_INVALID_ARGUMENT            101
#define IDF_SMALL_ICON                  101
#define IDR_PADMENU                     102
#define IDS_INVALID_OBJECT              102
#define IDF_LARGE_ICON                  102
#define IDR_PADHELPMENU                 103
#define IDS_INTERFACE_NOT_SUPPORTED     103
#define IDS_ACCESS_DENIED               104
#define IDR_SELECT_TOOL                 105
#define IDS_NOT_SUPPORTED               105
#define IDS_INVALID_CHARWIDTH           106
#define IDR_WELCOME_DLG                 107
#define IDS_NOT_FOUND                   107
#define IDR_FRAMESITE_TOOL              108
#define IDS_CALL_FAILED                 108
#define IDR_TWODSITE_TOOL               109
#define IDS_USER_CANCEL                 109
#define IDR_TEXTSITE_TOOL               110
#define IDS_ERRORS_RETURNED             110
#define IDS_UNKNOWN_FLAGS               111
#define IDS_UNEXPECTED                  112
#define IDB_PAD_SPLASH                  112
#define IDS_CANTNOW                     113
#define IDS_COMPONENT                   114
#define IDI_PADSMALLICON                115
#define IDB_MESSAGE_SEND                118
#define IDR_IMAGE_TOOL                  119
#define IDR_ABOUT_DIALOG                119
#define IDR_TEXTBOX_TOOL                120
#define IDR_LISTBOX_TOOL                121
#define IDR_CHECKBOX_TOOL               122
#define IDR_RADIOBUTTON_TOOL            123
#define IDR_BUTTON_TOOL                 124
#define IDR_PADMENU_EDIT                125
#define IDB_HTMLPAD_TOOLBAR             1000
#define IDM_MESSAGE_SAVE                1000
#define IDB_MESSAGE_TOOLBAR             1001
#define IDM_MESSAGE_MOVE                1002
#define IDM_MESSAGE_COPY                1003
#define IDM_MESSAGE_PRINT               1004
#define IDM_MESSAGE_DELETE              1005
#define IDM_MESSAGE_CLOSE               1006
#define IDM_MESSAGE_SUBMIT              1007
#define IDM_MESSAGE_REPLY               1008
#define IDM_MESSAGE_REPLY_ALL           1009
#define IDM_MESSAGE_FORWARD             1010
#define IDR_MESSAGE_TOOLBAR             1011
#define ID_SUBMIT                       1013
#define IDB_HTMLPAD_TBSTANDARD          1014
#define IDB_HTMLPAD_TBFORMAT            1015
#define IDR_OPEN_URL                    1122
#define IDI_ADDRESS                     1123
#define IDR_HTMLPAD_TOOLBAR             1200
#define IDM_VIEW_ITEMABOVE              1200
#define IDM_VIEW_ITEMBELOW              1201
#define IDR_HTMLPAD_TBSTANDARD          1202
#define IDR_HTMLPAD_TBFORMAT            1203
#define IDR_HTMLPAD_CONTEXT_MENU        1205
#define IDM_PAD_TESTTEMPLATES           1206
#define IDM_PAD_SAVE                    2000
#define ID_TO_BUTTON                    2000
#define IDM_PAD_SAVEAS                  2001
#define IDM_PAD_PAGESETUP               2002
#define ID_CC_BUTTON                    2002
#define IDM_PAD_PRINT                   2003
#define ID_CC                           2003
#define ID_SUBJECT_LABEL                2004
#define IDM_PAD_EXIT                    2006
#define ID_FROM_LABEL                   2006
#define IDM_PAD_BACK                    2007
#define ID_FROM                         2007
#define IDM_PAD_FORWARD                 2008
#define ID_SENT_LABEL                   2008
#define IDM_PAD_UPLEVEL                 2009
#define ID_SENT                         2009
#define IDM_PAD_OPTIONS                 2010
#define ID_TO_LABEL                     2010
#define IDM_PAD_OPENFAVORITE            2011
#define ID_TO                           2011
#define IDM_PAD_ADDFAVORITE             2012
#define ID_CC_LABEL                     2012
#define IDM_PAD_ABOUT                   2013
#define ID_SUBJECT                      2013
//#define IDM_PAD_TOOLBOX               2014
#define IDM_PAD_DEBUG_TRACE             2015
#define IDM_PAD_OPEN_URL                2017
#define IDM_PAD_OPEN_FILE               2018
#define IDM_PAD_NEW_HTML                2019
#define IDM_PAD_PRINTPREVIEW            2020
#define IDM_PAD_GOTO                    2021
#define IDM_PAD_HOME                    2022
#define IDM_PAD_REGISTER_LOCAL_TRIDENT  2023
#define IDM_PAD_STOP                    2024
#define IDM_PAD_REFRESH                 2025
#define IDM_PAD_FONTINC                 2026
#define IDM_PAD_FONTDEC                 2027
#define IDM_PAD_CUT                     2028
#define IDM_PAD_COPY                    2029
#define IDM_PAD_PASTE                   2030
#define IDM_PAD_EDITBROWSE              2031
#define IDM_PAD_EXECUTE_DRT             2034
#define IDM_PAD_EXECUTE_SCRIPT          2035
#define IDM_PAD_REGISTER_SYSTEM_TRIDENT 2036
#define IDM_PAD_OPENNSCP                2037
#define IDM_PAD_LOGTIME                 2038
#define IDM_PAD_IMMEDIATE_WINDOW        2039
#define IDM_PAD_NEWWIN                  2040
#define IDD_CFDIALOG                    2045
#define IDC_TREEVIEW                    2046
#define IDC_NEWFLD                      2047
#define IDI_ALLSTORES                   2048
#define IDI_ROOTFLD                     2049
#define IDI_OPENFLD                     2050
#define IDI_CLSDFLD                     2051
#define IDD_NEWNAME                     2052
#define IDC_NAME                        2053
#define IDC_NAMELABEL                   2054
#define IDM_PAD_SCRUB                   2055
#define IDM_PAD_REGISTER_PAD            2058
#define IDS_ErrorCaptionMail            2059
#define IDS_TripoleFullName             2060
#define IDM_MESSAGE_SAVE_AS             2061
#define IDM_PAD_REGISTER_MSG            2062
#define IDM_MESSAGE_OPENHTM             2063
#define IDM_PAD_CLEAR_CACHE             2064
#define IDM_MESSAGE_CHECK_NAMES         2065
#define IDM_PAD_VIEW_MON                2066
#define IDM_PAD_MEM_MON                 2067
#define IDM_PAD_FIND                    2070
#define IDM_PAD_SHORTCUT                2071
#define IDM_PAD_SENDFLOPPY              2072
#define IDM_PAD_SENDMAIL                2073
#define IDM_PAD_SENDBRIEFCASE           2074
#define IDM_PAD_SENDWEB                 2075
#define IDM_PAD_EDIT                    2076
#define IDM_PAD_BROWSE                  2077
#define IDM_PAD_PROPERTIES              2078
#define IDC_BITMAPSPLASH                2079
#define IDM_PAD_USESHDOCVW              2080
#define IDM_PAD_HOSTSHDOCVW             2081
#define IDM_PAD_UNHOSTSHDOCVW           2082
#define IDM_PAD_RELOADHIST              2083
#define IDM_PAD_CLOSE                   2084
#define IDM_PAD_METERS                  2085
#define IDM_PAD_PERFTAGS                2086
#define IDS_COLOR_BLACK                 2087
#define IDS_COLOR_NAVY                  2088
#define IDS_COLOR_BLUE                  2089
#define IDS_COLOR_CYAN                  2090
#define IDS_COLOR_RED                   2091
#define IDS_COLOR_LIME                  2092
#define IDS_COLOR_GRAY                  2093
#define IDS_COLOR_GREEN                 2094
#define IDS_COLOR_YELLOW                2095
#define IDS_COLOR_PINK                  2096
#define IDS_COLOR_VIOLET                2097
#define IDS_COLOR_WHITE                 2098

#define IDS_ZOOM_1000                   2099
#define IDS_ZOOM_900                    2100
#define IDS_ZOOM_800                    2101
#define IDS_ZOOM_700                    2102
#define IDS_ZOOM_600                    2103
#define IDS_ZOOM_500                    2104
#define IDS_ZOOM_400                    2105
#define IDS_ZOOM_300                    2106
#define IDS_ZOOM_275                    2107
#define IDS_ZOOM_250                    2108
#define IDS_ZOOM_225                    2109
#define IDS_ZOOM_200                    2110
#define IDS_ZOOM_175                    2111
#define IDS_ZOOM_150                    2112
#define IDS_ZOOM_125                    2113
#define IDS_ZOOM_100                    2114
#define IDS_ZOOM_90                     2115
#define IDS_ZOOM_80                     2116
#define IDS_ZOOM_75                     2117
#define IDS_ZOOM_70                     2118
#define IDS_ZOOM_60                     2119
#define IDS_ZOOM_50                     2120
#define IDS_ZOOM_40                     2121
#define IDS_ZOOM_30                     2122
#define IDS_ZOOM_25                     2123
#define IDS_ZOOM_20                     2124
#define IDS_ZOOM_15                     2125
#define IDS_ZOOM_10                     2126
#define IDS_ZOOM_5                      2127
#define IDS_ZOOM_1                      2128

#define IDM_PAD_VERIFYHTML_CUR_BLOCK    10000
#define IDM_PAD_VERIFYHTML_BODY         10001
#define IDM_PAD_TOGGLE_CICERO           10002
#define IDM_PAD_SHOWGLYPHS              10003
#define IDM_PAD_ENABLE_IME_RECONVERSION   10004
#define IDM_PAD_DISABLE_IME_RECONVERSION  10005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         2089
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       padreg.cxx
//
//  Contents:   Register pad stuff
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#include "platform.h"

#define MSHTML_STR  _T("mshtml.dll")
#define MSHTMLED_STR _T("mshtmled.dll")
#define MSTIME_STR _T("mstime.dll")
#define DXTRANS_STR _T("dxtrans.dll")
#define DXTMSFT_STR _T("dxtmsft.dll")
#define PROCTEXE_STR _T("proctexe.ocx")

#define IEPEERS_STR _T("iepeers.dll")
#define MSHTMLTB_STR _T("mshtmltb.dll")

typedef HRESULT (STDAPICALLTYPE *CTLREGPROC)();
extern void DeinitDynamicLibraries();


//+------------------------------------------------------------------------
//
//  Format Strings
//
//  The following strings describe the data added to the registry.
//
//  The strings consist of major keys followed by subkey/value pairs.
//  Each set of subkey/value pairs is terminated with two nulls (that is,
//  the next subkey name is missing). The entire list is terminated
//  by three nulls (that is, the next major key is missing). Major
//  keys are allowed one value without an associated name (subkey); the
//  value of the first subkey, if the subkey name is missing, is treated
//  as the value for the major key. Since a missing subkey name usually
//  terminates the list of subkey/value pairs, the value for the major key
//  (the one without a subkey) *must* be first in the set of subkey/value
//  pairs. This works because all keys must have at least one value.
//
//  (While the values of named subkeys may be other than strings, only
//   strings are supported. To support more than strings, these structures
//   should be changed to precede the value with a single character type ID.)
//
//  To keep the strings clear, the major keys occur first, on a line
//  by themselves, followed by the pairs of subkey/value indented underneath.
//  The terminator for the subkey/value pair stands on a line by itself as well.
//
//  Each key and value string is used as a format string in the Format
//  function (see CORE\FORMAT.CXX for more info).  The arguments for
//  substitution into these strings are:
//
//      0 pstr      - Name of EXE
//      1 pclsid    - Class id
//      2 pstr      - Prog ID
//      3 pstr      - Friendly name
//      4 idr       - Icon
//
//-------------------------------------------------------------------------

#define DEFAULT_VALUE   TEXT("\0")

static TCHAR s_strCLSIDFmt[] =
    TEXT("<1g>\0")
        DEFAULT_VALUE               TEXT("<3s>\0")
        TEXT("\0")
        TEXT("LocalServer32\0")
                DEFAULT_VALUE               TEXT("<0s>\0")
        TEXT("\0")
    TEXT("ProgID\0")
        DEFAULT_VALUE               TEXT("<2s>\0")
        TEXT("\0")
    TEXT("DefaultIcon\0")
        DEFAULT_VALUE               TEXT("<0s>,-<4d>\0")
        TEXT("\0")
    TEXT("\0");

static TCHAR s_strProgIDFmt[] =
    TEXT("<2s>\0")
        DEFAULT_VALUE               TEXT("<3s>\0")
        TEXT("\0")
    TEXT("CLSID\0")
        DEFAULT_VALUE               TEXT("<1g>\0")
        TEXT("\0")
    TEXT("\0");

//+------------------------------------------------------------------------
//
//  Function:   GetPadDLLName
//
//  Synopsis:   Return a .DLL pathname for a .DLL in the same directory
//              as the pad .EXE
//
//-------------------------------------------------------------------------

void
GetPadDLLName(TCHAR * pszDLL, TCHAR * achBuf, int cchBuf)
{
    TCHAR * pName;

        achBuf[0] = 0;
    Verify(::GetModuleFileName(NULL, achBuf, cchBuf));
    pName = _tcsrchr(achBuf, FILENAME_SEPARATOR);
    if (pName)
    {
        *pName = '\0';              // Remove the name.
    }

    _tcscat(achBuf, pszDLL);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterClass
//
// Synopsis:    Register a single class.
//
//-------------------------------------------------------------------------

HRESULT
RegisterOneClass(HKEY hkeyCLSID, TCHAR *pchFile, REFCLSID clsid, TCHAR *pchProgID, TCHAR *pchFriendly)
{
    HRESULT hr;
    DWORD_PTR adwArgs[10];

    adwArgs[0] = (DWORD_PTR)pchFile;
    adwArgs[1] = (DWORD_PTR)&clsid;
    adwArgs[2] = (DWORD_PTR)pchProgID;
    adwArgs[3] = (DWORD_PTR)pchFriendly;
    adwArgs[4] = IDR_PADICON;

    hr = THR(RegDbSetValues(HKEY_CLASSES_ROOT, s_strProgIDFmt, adwArgs));
    if (hr)
        goto Cleanup;

    hr = THR(RegDbSetValues(hkeyCLSID, s_strCLSIDFmt, adwArgs));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterPad
//
// Synopsis:    Register objects for this server.
//
//-------------------------------------------------------------------------

HRESULT
RegisterPad()
{
    HRESULT hr;
    HKEY    hkeyCLSID = 0;
    TCHAR   achExe[MAX_PATH];
    HINSTANCE hInst = 0;

    GetModuleFileName(hInst, achExe, ARRAY_SIZE(achExe));

    hr = THR(RegDbOpenCLSIDKey(&hkeyCLSID));
    if (hr)
        RRETURN(hr);

    hr = THR(RegisterOneClass(
            hkeyCLSID,
            achExe,
            CLSID_Pad,
            _T("TridentPad"),
            _T("Trident Pad")));
    if (hr)
        goto Cleanup;

Cleanup:
    RegCloseKey(hkeyCLSID);
    RegFlushKey(HKEY_CLASSES_ROOT);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterTrident
//
// Purpose:     Registers Mshtml.dll as well as Mshtmled.dll
//-------------------------------------------------------------------------

HRESULT
RegisterTrident(HWND hwnd, BOOL fDialog, BOOL fSystem)
{
    TCHAR       achBuf[MAX_PATH];
    TCHAR       achMshtmled[MAX_PATH];
    TCHAR       achMstime[MAX_PATH];
    TCHAR       achIepeers[MAX_PATH];
    TCHAR       achDxtrans[MAX_PATH];
    TCHAR       achDxtmsft[MAX_PATH];
    TCHAR       achProctexe[MAX_PATH];
    TCHAR       achMshtmltb[MAX_PATH];

    HRESULT     hr;

    if (fSystem)
    {
        Verify(GetSystemDirectory(achBuf, ARRAY_SIZE(achBuf)));
        _tcscat(achBuf, 
                _T(FILENAME_SEPARATOR_STR)
                MSHTML_STR);
        Verify(GetSystemDirectory(achMshtmled, ARRAY_SIZE(achMshtmled)));
        _tcscat(achMshtmled,
                _T(FILENAME_SEPARATOR_STR)
                MSHTMLED_STR);

        Verify(GetSystemDirectory(achMstime, ARRAY_SIZE(achMstime)));
        _tcscat(achMstime,
            _T(FILENAME_SEPARATOR_STR)
            MSTIME_STR);

        Verify(GetSystemDirectory(achIepeers, ARRAY_SIZE(achIepeers)));
        _tcscat(achIepeers,
                _T(FILENAME_SEPARATOR_STR)
                IEPEERS_STR);
                                    
        Verify(GetSystemDirectory(achDxtrans, ARRAY_SIZE(achDxtrans)));
        _tcscat(achDxtrans,
            _T(FILENAME_SEPARATOR_STR)
            DXTRANS_STR);
        
        Verify(GetSystemDirectory(achDxtmsft, ARRAY_SIZE(achDxtmsft)));
        _tcscat(achDxtmsft,
            _T(FILENAME_SEPARATOR_STR)
            DXTMSFT_STR);

        Verify(GetSystemDirectory(achProctexe, ARRAY_SIZE(achProctexe)));
        _tcscat(achProctexe,
            _T(FILENAME_SEPARATOR_STR)
            PROCTEXE_STR);

        Verify(GetSystemDirectory(achMshtmltb, ARRAY_SIZE(achMshtmltb)));
        _tcscat(achMshtmltb,
                _T(FILENAME_SEPARATOR_STR)
                MSHTMLTB_STR);
    }
    else
    {
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTML_STR, achBuf, ARRAY_SIZE(achBuf));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLED_STR, achMshtmled, ARRAY_SIZE(achMshtmled));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSTIME_STR, achMstime, ARRAY_SIZE(achMstime));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      IEPEERS_STR, achIepeers, ARRAY_SIZE(achIepeers));

        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      DXTMSFT_STR, achDxtmsft, ARRAY_SIZE(achDxtmsft));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      DXTRANS_STR, achDxtrans, ARRAY_SIZE(achDxtrans));
        
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      PROCTEXE_STR, achProctexe, ARRAY_SIZE(achProctexe));
                      
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLTB_STR, achMshtmltb, ARRAY_SIZE(achMshtmltb));               
    }

    hr = RegisterDLL(achBuf);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMshtmled);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMstime);
    if (hr)
        goto Error;

    hr = RegisterDLL(achIepeers);
    if (hr)
        goto Error;

    hr = RegisterDLL(achDxtrans);
    if (hr)
        goto Error;

    hr = RegisterDLL(achDxtmsft);
    if (hr)
        goto Error;

    hr = RegisterDLL(achProctexe);
    if (hr)
        goto Error;

    hr = RegisterDLL(achMshtmltb);
    if (hr && !fSystem)
        goto Error;
    else if (hr)
    {
        // If we can't register the system version, at 
        // least unregister the local version.
        GetPadDLLName(_T(FILENAME_SEPARATOR_STR)
                      MSHTMLTB_STR, achMshtmltb, ARRAY_SIZE(achMshtmltb));
        hr = UnregisterDLL(achMshtmltb);
        if (hr)
            goto Error;
    }
    
    if (fDialog)
    {
        if(fSystem)
        {
            MessageBox(
                hwnd,
                _T("System MSHTML and other system dlls registered as HTML viewer."),
                SZ_APPLICATION_NAME,
                MB_APPLMODAL | MB_OK);
        }
        else
        {
            MessageBox(
                hwnd,
                _T("Local trident MSHTML and other dlls registered as HTML viewer."),
                SZ_APPLICATION_NAME,
                MB_APPLMODAL | MB_OK);
        }
    }

Error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    RegisterLocalCLSIDs
//
//-------------------------------------------------------------------------

DYNLIB  g_dynlibMSHTML = { NULL, NULL, "mshtml.dll" };
DYNPROC g_dynprocMSHTMLClassObjects = { NULL, &g_dynlibMSHTML, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSHTMLED = { NULL, NULL, "mshtmled.dll" };
DYNPROC g_dynprocMSHTMLEDClassObjects = { NULL, &g_dynlibMSHTMLED, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSTIME = { NULL, NULL, "mstime.dll" };
DYNPROC g_dynprocMSTIMEClassObjects = { NULL, &g_dynlibMSTIME, "DllEnumClassObjects" };
DYNLIB  g_dynlibIEPEERS = { NULL, NULL, "iepeers.dll" };
DYNPROC g_dynprocIEPEERSClassObjects = { NULL, &g_dynlibIEPEERS, "DllEnumClassObjects" };
DYNLIB  g_dynlibDXTRANS = { NULL, NULL, "dxtrans.dll" };
DYNPROC g_dynprocDXTRANSClassObjects = { NULL, &g_dynlibDXTRANS, "DllEnumClassObjects" };
DYNLIB  g_dynlibDXTMSFT = { NULL, NULL, "dxtmsft.dll" };
DYNPROC g_dynprocDXTMSFTClassObjects = { NULL, &g_dynlibDXTMSFT, "DllEnumClassObjects" };
DYNLIB  g_dynlibPROCTEXE = { NULL, NULL, "proctexe.ocx" };
DYNPROC g_dynprocPROCTEXEClassObjects = { NULL, &g_dynlibPROCTEXE, "DllEnumClassObjects" };
DYNLIB  g_dynlibMSHTMLTB = { NULL, NULL, "mshtmltb.dll" };
DYNPROC g_dynprocMSHTMLTBClassObjects = { NULL, &g_dynlibMSHTMLTB, "DllEnumClassObjects" };

DYNPROC * g_adynprocDlls[] = {
                                &g_dynprocMSHTMLClassObjects,
#ifndef UNIX
                                &g_dynprocMSHTMLEDClassObjects,
                                &g_dynprocMSTIMEClassObjects,
                                &g_dynprocDXTRANSClassObjects,
                                &g_dynprocDXTMSFTClassObjects,
                                &g_dynprocPROCTEXEClassObjects,
#endif
                                &g_dynprocIEPEERSClassObjects,
#ifndef UNIX
                                &g_dynprocMSHTMLTBClassObjects,
#endif                                
                                NULL
                             };

HRESULT
RegisterLocalCLSIDs()
{
    PADTHREADSTATE * pts = GetThreadState();
    int         i, j;
    HRESULT     hr = S_OK;
    CLSID       clsid;
    int         cFactory = 0;

    IUnknown ** pUnkFactory = pts->pUnkFactory;
    DWORD *     dwCookie    = pts->dwCookie;

    if (pts->fLocalReg)
        return S_OK;

    // We register class objects per thread, so hold on to
    // one instance of library per thread.

    for (i=0; g_adynprocDlls[i]; i++)
    {
        //
        // We do an explicit load to increment the system's refcount on the DLL.
        //
        pts->hinstDllThread[i] = LoadLibraryA(g_adynprocDlls[i]->pdynlib->achName);

        hr = THR(LoadProcedure(g_adynprocDlls[i]));
        if (hr)
        {
#if DBG == 1
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                TraceTag((tagError, "\n\n**** WARNING! Could not locally register class "
                          "factories for %hs!", g_adynprocDlls[i]->pdynlib->achName));
                TraceTagEx((tagError, TAG_NONAME, "OLE objects may be pulled from the system DLL "
                          "instead of the local DLL.\n"));
            }
#endif

            // Couldn't load this DLL. Go on to the next one.
            hr = S_OK;
            continue;
        }

        for (j = 0; cFactory < PUNKFACTORY_ARRAY_SIZE; j++, cFactory++)
        {
            hr = THR(((HRESULT (STDAPICALLTYPE *)(int, CLSID *, IUnknown **))
                        g_adynprocDlls[i]->pfn)(j,
                        &clsid,
                        &pUnkFactory[cFactory]));
            if (hr)
                break;

            hr = THR(CoRegisterClassObject( clsid,
                                            pUnkFactory[cFactory],
                                            CLSCTX_INPROC_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            &dwCookie[cFactory]));
            if (hr)
                break;
        }

        if (!OK(hr))
            RRETURN(hr);
    }

    AssertSz(cFactory < PUNKFACTORY_ARRAY_SIZE, "Ran out of room to register factories!");

    if (OK(hr))
        hr = S_OK;

    pts->fLocalReg = hr == S_OK;

    RRETURN(hr);
}

void
UnregisterLocalCLSIDs()
{
    PADTHREADSTATE * pts = GetThreadState();
    IUnknown ** pUnkFactory = pts->pUnkFactory;
    DWORD * dwCookie = pts->dwCookie;
    int i;

    for (i = 0; i < PUNKFACTORY_ARRAY_SIZE; i++)
    {
        if (dwCookie[i])
        {
            Verify(OK(CoRevokeClassObject(dwCookie[i])));
            dwCookie[i] = 0;
        }

        ClearInterface(&pUnkFactory[i]);
    }

    pts->fLocalReg = FALSE;
}

void NoLocalCLSIDs()
{
    // this clears the local DLL list
    ZeroMemory(g_adynprocDlls, sizeof(g_adynprocDlls));
}

void
FreeLibraries()
{
    PADTHREADSTATE * pts = GetThreadState();

    for (int i = 0; i < NUM_LOCAL_DLLS; i++)
    {
        if (pts->hinstDllThread[i] != NULL)
        {
            FreeLibrary(pts->hinstDllThread[i]);
        }
    }

    DeinitDynamicLibraries();
}


//+------------------------------------------------------------------------
//
// Function:    RegisterDLL
//
//-------------------------------------------------------------------------

HRESULT
RegisterDLL(LPOLESTR Path)
{
    HMODULE     hModule = NULL;
    CTLREGPROC  DLLRegisterServer;
    HRESULT     hr = E_FAIL;

    hModule = ::LoadLibraryEx(Path, 0, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hModule)
    {
        goto WinError;
    }

    // Control found try to register.
    DLLRegisterServer = (CTLREGPROC)::GetProcAddress(hModule,
                                                       "DllRegisterServer");

    if (DLLRegisterServer == NULL)
    {
        goto WinError;
    }

    hr = THR(DLLRegisterServer());  // Register control

Cleanup:
    if (hModule)
    {
        ::FreeLibrary(hModule);
    }
#if DBG == 1
    OutputDebugString(_T("\n\rDLL "));
    OutputDebugString((hr == S_OK) ?
                        _T("registered: ") :
                        _T("NOT registered: "));
    OutputDebugString(Path);
    OutputDebugString(_T("\n\r"));
#endif
    RRETURN(hr);

WinError:
    hr = HRESULT_FROM_WIN32(::GetLastError());
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
// Function:    UnregisterDLL
//
//-------------------------------------------------------------------------

HRESULT
UnregisterDLL(LPOLESTR Path)
{
    HMODULE     hModule = NULL;
    CTLREGPROC  DLLUnregisterServer;
    HRESULT     hr = E_FAIL;

    hModule = ::LoadLibraryEx(Path, 0, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hModule)
    {
        goto WinError;
    }

    // Control found try to register.
    DLLUnregisterServer = (CTLREGPROC)::GetProcAddress(hModule,
                                                       "DllUnregisterServer");

    if (DLLUnregisterServer == NULL)
    {
        goto WinError;
    }

    hr = THR(DLLUnregisterServer());  // Register control

Cleanup:
    if (hModule)
    {
        ::FreeLibrary(hModule);
    }
#if DBG == 1
    OutputDebugString(_T("\n\rDLL "));
    OutputDebugString((hr == S_OK) ?
                        _T("unregistered: ") :
                        _T("NOT unregistered: "));
    OutputDebugString(Path);
    OutputDebugString(_T("\n\r"));
#endif
    RRETURN(hr);

WinError:
    hr = HRESULT_FROM_WIN32(::GetLastError());
    goto Cleanup;
}
//+---------------------------------------------------------------------------
//
//  Function:   NukeKnownDLLStuff
//
//  Synopsis:   Removes standard dlls from the knowndll list.
//
//----------------------------------------------------------------------------

HRESULT
NukeKnownDLLStuff()
{
    HRESULT             hr      = S_OK;
    long                error;
    HKEY                hkey    = NULL;
    long                i;
    BOOL                fChanged = FALSE;
    static char *       g_achDLLs[] =
        { "shdocvw", "urlmon", "wininet" };

    // Check if oleaut32 is in known dlls list.
    error = TW32_NOTRACE(1, RegOpenKeyA(
            HKEY_LOCAL_MACHINE,
            "System\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs",
            &hkey));
    if (error)
    {
        // On Win95, the key is spelled differently.
        error = TW32(1, RegOpenKeyA(
                HKEY_LOCAL_MACHINE,
                "System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs",
                &hkey));

        if (error)
            goto Cleanup;
    }

    for (i = ARRAY_SIZE(g_achDLLs); i > 0; i--)
    {
        error = TW32_NOTRACE(1, RegQueryValueExA(
                hkey,
                g_achDLLs[i-1],
                NULL,
                NULL,
                NULL,
                NULL));
        if (error)
            continue;

        // Delete the value.
        error = TW32(1, RegDeleteValueA(hkey, g_achDLLs[i-1]));
        if (error)
            goto Win32Error;

        fChanged = TRUE;
    }

Cleanup:
    if (hkey)
        Verify(!RegCloseKey(hkey));

    if (!hr)
    {
        MessageBox(
            NULL,
            fChanged ?
                _T("Known DLLs nuked OK. Need Reboot.") :
                _T("Known DLLs nuked OK."),
            SZ_APPLICATION_NAME,
            MB_APPLMODAL | MB_OK);
    }
    else
    {
        MessageBox(
            NULL,
            _T("Failed nuking Known DLLs."),
            SZ_APPLICATION_NAME,
            MB_APPLMODAL | MB_OK);
    }

    RRETURN(hr);

Win32Error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padscrub.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scrub.cxx
//
//  Contents:   Function to delete dangling references from the system registry.
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include "stdio.h"
#endif

char g_achScrub[2048];

static BOOL
OkToDelete(char *pch)
{
    static BOOL g_fAlwaysDelete;
    int iRet;

    if (g_fAlwaysDelete)
        return TRUE;

    wsprintfA(&g_achScrub[lstrlenA(g_achScrub)], "\nDelete %s from the registry?", pch);

    iRet = MessageBoxA(g_hwndMain, g_achScrub, "Scrub Registry", MB_APPLMODAL | MB_YESNO);

    if (iRet != IDYES)
        return FALSE;

    if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
        g_fAlwaysDelete = TRUE;

    return TRUE;
}

static void
DeleteKey(HKEY hkeyParent, char *pstrDelete)
{
    char    achSubKey[MAX_PATH];
    HKEY    hkeyDelete;

    if (RegOpenKeyA(hkeyParent, pstrDelete, &hkeyDelete) == ERROR_SUCCESS)
    {
        while (RegEnumKeyA(hkeyDelete, 0, achSubKey, sizeof(achSubKey))
                == ERROR_SUCCESS)
        {
            DeleteKey(hkeyDelete, achSubKey);
        }

        RegCloseKey(hkeyDelete);
    }
    RegDeleteKeyA(hkeyParent, pstrDelete);
}

static void
CheckCLSIDs(HKEY hkeyCLSID)
{
    char    achServer[MAX_PATH];
    char    achClass[MAX_PATH];
    char    achProgID[MAX_PATH];
    char    achPath[MAX_PATH];
    char    achUserType[MAX_PATH];
    HKEY    hkeyClass = NULL;
    DWORD   i;
    long    cb;

    // For each class....

    i = 0;
    while (RegEnumKeyA(hkeyCLSID,
            i,
            achClass,
            sizeof(achClass)) == ERROR_SUCCESS)
    {
        if (hkeyClass)
        {
            Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
            hkeyClass = NULL;
        }

        if (RegOpenKeyA(hkeyCLSID, achClass, &hkeyClass) == ERROR_SUCCESS)
        {
            // If we can't find the server for a class....

            cb = sizeof(achServer);
            if (RegQueryValueA(hkeyClass, INPROCSERVER, achServer, &cb)
                    == ERROR_SUCCESS &&
                achServer[0] &&         // Ignore empty strings.
                achServer[0] != '"' &&  // Ole2View registers with quotes. Ignore.
                SearchPathA(NULL, achServer, NULL, sizeof(achPath), achPath, NULL)
                    == 0)
            {
                // Find ProgID and user type name.

                cb = sizeof(achProgID);
                if (RegQueryValueA(hkeyClass, "ProgID", achProgID, &cb)
                        != ERROR_SUCCESS)
                {
                    achProgID[0] = 0;
                    achUserType[0] = 0;
                }
                else
                {
                    cb = sizeof(achUserType);
                    if (RegQueryValueA(HKEY_CLASSES_ROOT, achProgID, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }
                }

                // If we couldn't get a user type name from the ProgID, then
                // try to fetch one from the class id key.

                if (achUserType[0] == 0)
                {
                    cb = sizeof(achUserType);
                    if (RegQueryValueA(hkeyCLSID, achClass, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }
                }

                // Ask the user about deleting the class.

                wsprintfA(g_achScrub, "Server not found for CLSID\n\n"
                    "  Name   = %s\n"
                    "  Server = %s\n"
                    "  CLSID  = %s\n"
                    "  ProgID = %s\n",
                    achUserType,
                    achServer,
                    achClass,
                    achProgID);
                if (OkToDelete("class"))
                {
                    Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
                    hkeyClass = NULL;
                    DeleteKey(hkeyCLSID, achClass);
                    if (achProgID[0])
                        DeleteKey(HKEY_CLASSES_ROOT, achProgID);
                    continue;
                }
            }
        }
        i += 1;
    }

    if (hkeyClass)
    {
        Verify(RegCloseKey(hkeyClass)  == ERROR_SUCCESS);
    }
}

static void
CheckProgIDs(HKEY hkeyCLSID)
{
    char    achClass[MAX_PATH];
    char    achProgID[MAX_PATH];
    char    achUserType[MAX_PATH];
    HKEY    hkeyProgID = NULL;
    HKEY    hkeyClass;
    DWORD   i;
    long    cb;

    // For each ProgID....

    i = 0;
    while (RegEnumKeyA(HKEY_CLASSES_ROOT,
            i,
            achProgID,
            sizeof(achProgID)) == ERROR_SUCCESS)
    {
        if (hkeyProgID)
        {
            Verify(RegCloseKey(hkeyProgID)  == ERROR_SUCCESS);
            hkeyProgID = NULL;
        }

        if (RegOpenKeyA(HKEY_CLASSES_ROOT, achProgID, &hkeyProgID) == ERROR_SUCCESS)
        {
            // If there's a class id...

            cb = sizeof(achClass);
            if (RegQueryValueA(hkeyProgID, "CLSID", achClass, &cb)
                    == ERROR_SUCCESS)
            {
                if (achClass[0] && RegOpenKeyA(hkeyCLSID, achClass, &hkeyClass) == ERROR_SUCCESS)
                {
                    RegCloseKey(hkeyClass);
                    hkeyClass = NULL;
                }
                else
                {
                    // We can't find the class id in the registry, so ask about deleting it.

                    cb = sizeof(achUserType);
                    if (RegQueryValueA(HKEY_CLASSES_ROOT, achProgID, achUserType, &cb)
                            != ERROR_SUCCESS)
                    {
                        achUserType[0] = 0;
                    }

                    wsprintfA(g_achScrub, "CLSID not found for ProgID:\n\n"
                        "  Name   = %s\n"
                        "  CLSID  = %s\n"
                        "  ProgID = %s\n",
                        achUserType,
                        achClass,
                        achProgID);
                    if (OkToDelete("ProgID"))
                    {
                        RegCloseKey(hkeyProgID);
                        hkeyProgID = NULL;
                        DeleteKey(HKEY_CLASSES_ROOT, achProgID);
                        continue;
                    }
                }
            }

        }
        i += 1;
    }

    if (hkeyProgID)
    {
        Verify(RegCloseKey(hkeyProgID)  == ERROR_SUCCESS);
    }
}

static BOOL
CheckTypeLibraryPlatforms(
    HKEY hkeyVersion,
    char *pchTypeLib,
    char *pchVersion,
    char *pchName,
    char *pchLanguage)
{
    char    achFile[MAX_PATH];
    char    achPath[MAX_PATH];
    char    achPlatform[MAX_PATH];
    HKEY    hkeyLanguage;
    BOOL    fDelete = TRUE;
    long    cb;
    int     i;

    if (RegOpenKeyA(hkeyVersion, pchLanguage, &hkeyLanguage) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyLanguage,
            i,
            achPlatform,
            sizeof(achPlatform)) == ERROR_SUCCESS)
    {
        cb = sizeof(achFile);
        if (RegQueryValueA(hkeyLanguage, achPlatform, achFile, &cb)
                == ERROR_SUCCESS &&
            SearchPathA(NULL, achFile, NULL, sizeof(achPath), achPath, NULL)
                == 0)
        {
            wsprintfA(g_achScrub, "Type library file not found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n"
                "  Version  = %s\n"
                "  Language = %s\n"
                "  Platform = %s\n"
                "  File     = %s\n",
                pchName,
                pchTypeLib,
                pchVersion,
                pchLanguage,
                achPlatform,
                achFile);
            if (OkToDelete("platform entry"))
            {
                DeleteKey(hkeyLanguage, achPlatform);
                continue;
            }
            else
            {
                fDelete = FALSE;
            }
        }
        else
        {
            fDelete = FALSE;
        }
        i += 1;
    }

    RegCloseKey(hkeyLanguage);

    return fDelete;
}

static BOOL
CheckTypeLibraryLanguages(
    HKEY hkeyTypeLib,
    char *pchTypeLib,
    char *pchName,
    char *pchVersion)
{
    char    achLanguage[MAX_PATH];
    HKEY    hkeyVersion;
    BOOL    fDelete = TRUE;
    int     i;

    if (RegOpenKeyA(hkeyTypeLib, pchVersion, &hkeyVersion) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyVersion,
            i,
            achLanguage,
            sizeof(achLanguage)) == ERROR_SUCCESS)
    {
        if ('0' <= achLanguage[0] && achLanguage[0] <= '9')
        {
            if (CheckTypeLibraryPlatforms(
                        hkeyVersion,
                        pchTypeLib,
                        pchVersion,
                        pchName,
                        achLanguage))
            {
                wsprintfA(g_achScrub, "No entries for type library language found:\n\n"
                    "  Name     = %s\n"
                    "  TLID     = %s\n"
                    "  Version  = %s\n"
                    "  Language = %s\n",
                    pchName,
                    pchTypeLib,
                    pchVersion,
                    achLanguage);
                if (OkToDelete("language entry"))
                {
                    DeleteKey(hkeyVersion, achLanguage);
                    continue;
                }
                else
                {
                    fDelete = FALSE;
                }
            }
            else
            {
                fDelete = FALSE;
            }
        }
        i += 1;
    }

    RegCloseKey(hkeyVersion);

    return fDelete;
}

static BOOL
CheckTypeLibraryVersions(
    HKEY hkeyTypeLibRoot,
    char *pchTypeLib,
    char *pchName)
{
    char    achVersion[MAX_PATH];
    HKEY    hkeyTypeLib;
    BOOL    fDelete = TRUE;
    int     i;
    long    cb;

    if (RegOpenKeyA(hkeyTypeLibRoot, pchTypeLib, &hkeyTypeLib) != ERROR_SUCCESS)
        return FALSE;

    i = 0;
    while (RegEnumKeyA(hkeyTypeLib,
            i,
            achVersion,
            sizeof(achVersion)) == ERROR_SUCCESS)
    {
        cb = MAX_PATH;
        if (RegQueryValueA(hkeyTypeLib, achVersion, pchName, &cb)
                != ERROR_SUCCESS)
        {
            pchName[0] = 0;
        }

        if (CheckTypeLibraryLanguages(hkeyTypeLib, pchTypeLib, pchName, achVersion))
        {
            wsprintfA(g_achScrub, "No entries for type library version found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n"
                "  Version  = %s\n",
                pchName,
                pchTypeLib,
                achVersion);
            if (OkToDelete("version entry"))
            {
                DeleteKey(hkeyTypeLib, achVersion);
                continue;
            }
            else
            {
                fDelete = FALSE;
            }
        }
        else
        {
            fDelete = FALSE;
        }
        i += 1;
    }

    RegCloseKey( hkeyTypeLib );

    return fDelete;
}

static void
CheckTypeLibraries()
{
    char    achTypeLib[MAX_PATH];
    char    achName[MAX_PATH];
    HKEY    hkeyTypeLibRoot = NULL;
    int i;

    RegOpenKeyA(HKEY_CLASSES_ROOT, "TypeLib", &hkeyTypeLibRoot);

    i = 0;
    while (RegEnumKeyA(hkeyTypeLibRoot,
            i,
            achTypeLib,
            sizeof(achTypeLib)) == ERROR_SUCCESS)
    {
        achName[0] = 0;

        if (CheckTypeLibraryVersions(hkeyTypeLibRoot, achTypeLib, achName))
        {
            wsprintfA(g_achScrub, "No entries for type library found:\n\n"
                "  Name     = %s\n"
                "  TLID     = %s\n",
                achName,
                achTypeLib);
            if (OkToDelete("type library entry"))
            {
                DeleteKey(hkeyTypeLibRoot, achTypeLib);
                continue;
            }
        }
        i += 1;
    }

    RegCloseKey(hkeyTypeLibRoot);
}

void
ScrubRegistry()
{
    HKEY  hkeyCLSID = NULL;

    RegOpenKeyA(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);

    // Find dangling CLSIDs (server is missing)
    CheckCLSIDs(hkeyCLSID);

    // Find dangling ProgIDs (CLSID is missing)
    CheckProgIDs(hkeyCLSID);

    RegCloseKey(hkeyCLSID);

    // Find dangling Type libraries

    CheckTypeLibraries();

    MessageBoxA(g_hwndMain, "Done scanning registry for dangling references.", "Scrub Registry", MB_APPLMODAL | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padsite.cxx
//
//  Contents:   CPadSite class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

DeclareTag(tagUserAgent, "Pad", "Test user agent string");
DeclareTag(tagNoClientPull, "Pad", "No client-pull");
DeclareTag(tagIAsyncServiceProvider, "Pad", "Test IAsyncServiceProvider");
DeclareTag(tagNoContextMenus, "Pad", "Turn off context menus in MSHtmPad");

DeclareTag(tagIHTMLDragEditHostResizeFeedback, "Pad", "Test Resize of Drag Feedback ");
DeclareTag(tagIHTMLDragEditHostDrawFeedback, "Pad", "Test Drawing of Drag Feedback");
DeclareTag(tagIHTMLDragEditHostSnapPoint, "Pad", "Test Point Snap at End ");
DeclareTag(tagIHTMLDragEditHostChangeElement, "Pad", "Test Changing IHTMLElement at Begin Drag");
DeclareTag(tagIHTMLDragEditHostCancelDrag, "Pad", "Test Cancelling drag at Begin Drag");
DeclareTag(tagIHTMLDragEditHostPasteInFlow, "Pad", "Test Paste In Flow Code at End Drag");
DeclareTag(tagPeerProvideTestBehaviors, "Peer", "Provide test host behaviors");
DeclareTag(tagShowSnap, "Pad", "Show snap to grid output");
DeclareTag(tagImplementNSFactory2, "Peer", "Have pad implement NS factory 2")
DeclareTag(tagIHostBehaviorInit, "Peer", "Implement IHostBehaviorInit");

ExternTag(tagSnapGrid);

IMPLEMENT_SUBOBJECT_IUNKNOWN(CPadSite, CPadDoc, PadDoc, _Site);

// {94D12430-B6A8-11d0-8778-00A0C90564EC}
static const GUID IID_IAsyncServiceProvider =
{ 0x94d12430, 0xb6a8, 0x11d0, { 0x87, 0x78, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xec } };

const IID IID_IHTMLDragEditHost = {0x3050f5e1,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};

extern "C" const GUID SID_SEditCommandTarget;
extern "C" const GUID CGID_EditStateCommands;

STDMETHODIMP
CPadSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *) this;
    }
    else if (iid == IID_IOleDocumentSite)
    {
        *ppv = (IOleDocumentSite *) this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IAdviseSink)
    {
        *ppv = (IAdviseSink *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
#if DBG==1
    else if (IsTagEnabled(tagIAsyncServiceProvider) && (iid == IID_IAsyncServiceProvider))
    {
        *ppv = (IServiceProvider *) this;
    }
#endif
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *) this;
    }
    else if (IsTagEnabled(tagIHostBehaviorInit) && (iid == IID_IHostBehaviorInit))
    {
        *ppv = (IHostBehaviorInit *) this;
    }
    else if (iid == IID_IElementBehaviorFactory)
    {
        *ppv = (IElementBehaviorFactory *) this;
    }
    else if (iid == IID_IElementNamespaceFactory)
    {
        *ppv = (IElementNamespaceFactory *) this;
    }
    else if (iid == IID_IElementNamespaceFactory2 && 
             IsTagEnabled(tagImplementNSFactory2))
    {
        *ppv = (IElementNamespaceFactory2 *) this;
    }
    else if (iid == IID_IElementNamespaceFactoryCallback)
    {
        *ppv = (IElementNamespaceFactoryCallback *) this;
    }
    else if (iid == IID_IVersionHost)
    {
        *ppv = (IVersionHost *) this;
    }
#if DBG==1
    else if (IsTagEnabled(tagSnapGrid) && (iid == IID_IHTMLEditHost))
    {
        *ppv = (IHTMLEditHost*) this;
    }
#endif
    else if( iid == IID_ISequenceNumber )
    {
        *ppv = (ISequenceNumber *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP
CPadSite::SaveObject()
{
    RRETURN(PadDoc()->Save((LPCTSTR)NULL));
}


STDMETHODIMP
CPadSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    if ((OLEGETMONIKER_UNASSIGN != dwAssign) &&
        (OLEWHICHMK_OBJFULL == dwWhichMoniker))
    {
        RRETURN (PadDoc()->GetMoniker(ppmk));
    }
    else
    {
        *ppmk = NULL;
        RRETURN(E_NOTIMPL);
    }
}


STDMETHODIMP
CPadSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    *ppContainer = PadDoc();
    (*ppContainer)->AddRef();
    return S_OK;
}


STDMETHODIMP
CPadSite::ShowObject( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::OnShowWindow(BOOL fShow)
{
    return S_OK;
}


STDMETHODIMP
CPadSite::RequestNewObjectLayout( )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::GetWindow(HWND * phwnd)
{
    *phwnd = PadDoc()->_hwnd;
    return S_OK;
}


STDMETHODIMP
CPadSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::CanInPlaceActivate( )
{
    return S_OK;
}

extern LRESULT
ObjectWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);

STDMETHODIMP
CPadSite::OnInPlaceActivate( )
{
    HRESULT     hr;
    IUnknown *  pUnk;

    if (PadDoc()->_pView)
    {
        // Use view if activating an ActiveX Document.
        pUnk = PadDoc()->_pView;
    }
    else
    {
        // Use object if activating an ActiveX Control.
        pUnk =  PadDoc()->_pObject;
    }

    hr = THR(pUnk->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &PadDoc()->_pInPlaceObject));

    if (!hr)
    {
        HWND hwnd;

        if (!PadDoc()->_pInPlaceObject->GetWindow(&hwnd))
        {
            PadDoc()->_hwndHooked = hwnd;
            PadDoc()->_pfnOrigWndProc = (WNDPROC) SetWindowLongPtr(
                hwnd, GWLP_WNDPROC, (LONG_PTR) ObjectWndProc);
            SetProp(hwnd, _T("TRIDENT_DOC"), (HANDLE)PadDoc());
        }
    }

    RRETURN(hr);
}


STDMETHODIMP
CPadSite::OnUIActivate( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    *ppFrame = &PadDoc()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

    PadDoc()->GetViewRect(prcPosRect, TRUE);
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = PadDoc()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


STDMETHODIMP
CPadSite::Scroll(OLESIZE scrollExtent)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::OnUIDeactivate(BOOL fUndoable)
{
    HWND hwnd;
    HRESULT hr;

    // release hook for server window
    hr = PadDoc()->_pInPlaceObject->GetWindow(&hwnd);
    if (hr)
        goto Cleanup;

    if (hwnd == PadDoc()->_hwndHooked)
    {
        RemoveProp(hwnd, _T("TRIDENT_DOC"));
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) PadDoc()->_pfnOrigWndProc);
        PadDoc()->_hwndHooked = NULL;
    }

    // Set focus back to the frame.
    SetFocus(PadDoc()->_hwnd);

    // Show our menu again.
    IGNORE_HR(PadDoc()->_Frame.SetMenu(NULL, NULL, NULL));

Cleanup:

    RRETURN(hr);
}

STDMETHODIMP
CPadSite::OnInPlaceDeactivate( )
{
    ClearInterface(&PadDoc()->_pInPlaceObject);
    ClearInterface(&PadDoc()->_pView);
    PadDoc()->InplaceDeactivate();
    return S_OK;
}


STDMETHODIMP
CPadSite::DiscardUndoState( )
{
    return S_OK;
}


STDMETHODIMP
CPadSite::DeactivateAndUndo( )
{
    RRETURN(THR(PadDoc()->_pInPlaceObject->UIDeactivate()));
}


STDMETHODIMP
CPadSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    Assert(FALSE);
    return S_OK;
}

STDMETHODIMP
CPadSite::ActivateMe(IOleDocumentView *pView)
{
    HRESULT         hr;
    IOleDocument *  pDocument = NULL;
    RECT            rc;

    if (PadDoc()->_pView &&
        PadDoc()->_pView != pView)
        RRETURN(E_UNEXPECTED);

    //
    // *********** ISSUE: TODO: UGLY TERRIBLE HACK FOR MSHTML ! (istvanc) **************
    //
    if (PadDoc()->_fMSHTML)
    {
        hr = THR(PadDoc()->_pObject->QueryInterface(IID_IOleDocument,
                (void **)&pDocument));
        if (hr)
            goto Cleanup;

        hr = THR(pDocument->CreateView(this, NULL, 0, &pView));
        if (hr)
            goto Cleanup;

        hr = THR(pView->SetInPlaceSite(this));
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (!pView)
        {
            hr = THR(PadDoc()->_pObject->QueryInterface(IID_IOleDocument,
                    (void **)&pDocument));
            if (hr)
                goto Cleanup;

            hr = THR(pDocument->CreateView(this, NULL, 0, &pView));
            if (hr)
                goto Cleanup;
        }
        else if(!PadDoc()->_pView)
        {
            hr = THR(pView->SetInPlaceSite(this));
            if (hr)
                goto Cleanup;

            pView->AddRef();
        }
    }

    PadDoc()->_pView = pView;

    // This sets up toolbars and menus first

    hr = THR(pView->UIActivate(TRUE));
    if (hr)
        goto Cleanup;

    // Set the window size sensitive to new toolbars

    PadDoc()->GetViewRect(&rc, TRUE);
    hr = THR(pView->SetRect(&rc));
    if (hr)
        goto Cleanup;

    // Makes it all visible
    hr = THR(pView->Show(TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDocument);
    RRETURN(hr);
}

STDMETHODIMP
CPadSite::GetTypeInfoCount( UINT * pctinfo )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CPadSite::GetIDsOfNames(
        REFIID      riid,
        LPTSTR *    rgstrNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::Invoke(
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_AMBIENT_USERMODE:
        V_VT(pvarResult) = VT_BOOL;
        V_BOOL(pvarResult) = !!PadDoc()->_fUserMode;
        break;

    case DISPID_AMBIENT_SILENT:
        V_VT(pvarResult) = VT_BOOL;
        V_BOOL(pvarResult) = !!IsTagEnabled(tagAssertExit);
        break;

    case DISPID_AMBIENT_PALETTE:
        V_VT(pvarResult) = VT_HANDLE;
        V_BYREF(pvarResult) = PadDoc()->_hpal;
        break;

    case DISPID_AMBIENT_USERAGENT:
        if (IsTagEnabled(tagUserAgent))
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(_T("Mozilla/4.0 (compatible; MSIE 4.0b1; user agent string test)"),
                                      &V_BSTR(pvarResult)));
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
        break;

    case DISPID_AMBIENT_DLCONTROL:
        if (IsTagEnabled(tagNoClientPull))
        {
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = DLCTL_NO_CLIENTPULL;
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
        break;

    default:
        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    return hr;
}

STDMETHODIMP
CPadSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

#ifdef WHEN_CONTROL_PALETTE_IS_SUPPORTED
    if (sid == SID_SControlPalette)
    {
        hr = THR(GetControlPaletteService(iid, ppv));
    }
    else
#endif // WHEN_CONTROL_PALETTE_IS_SUPPORTED
        if (sid == IID_IElementBehaviorFactory && IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHostBehaviorInit && IsTagEnabled(tagIHostBehaviorInit))
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == SID_SVersionHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLDragEditHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLEditHost)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if (sid == SID_SEditCommandTarget)
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else if( sid == IID_ISequenceNumber )
    {
        hr = THR(QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

// ICommandTarget methods

STDMETHODIMP
CPadSite::QueryStatus(
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    if (pguidCmdGroup != NULL)
        return (OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // By default command text is NOT SUPPORTED.
    if (pcmdtext && (pcmdtext->cmdtextf != MSOCMDTEXTF_NONE))
        pcmdtext->cwActual = 0;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch (pCmd->cmdID)
        {
        case OLECMDID_UPDATECOMMANDS:
        case OLECMDID_SETTITLE:
        case OLECMDID_NEW:
        case OLECMDID_OPEN:
        case OLECMDID_SAVE:
        case OLECMDID_SETPROGRESSTEXT:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
        }
    }

    return (hr);
}

STDMETHODIMP
CPadSite::Exec(const GUID * pguidCmdGroup,
              DWORD nCmdID,
              DWORD nCmdexecopt,
              VARIANTARG * pvarargIn,
              VARIANTARG * pvarargOut)
{
    HRESULT hr = S_OK;

    if ( ! pguidCmdGroup )
    {
        switch (nCmdID)
        {
        case OLECMDID_NEW:
            if (!(THR_NOTRACE(PadDoc()->QuerySave(SAVEOPTS_PROMPTSAVE))))
                THR_NOTRACE(PadDoc()->Open(CLSID_HTMLDocument));
            break;

        case OLECMDID_OPEN:
            THR_NOTRACE(PadDoc()->PromptOpenFile(
                    PadDoc()->_hwnd,
                    &CLSID_HTMLDocument));
            break;

        case OLECMDID_SAVE:
            THR_NOTRACE(PadDoc()->DoSave(FALSE));
            break;

        case OLECMDID_SETPROGRESSTEXT:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                PadDoc()->SetStatusText(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        case OLECMDID_UPDATECOMMANDS:
            if( PadDoc()->_fUpdateUI )
                PadDoc()->UpdateToolbarUI();
            break;

        case OLECMDID_SETTITLE:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {            
                PadDoc()->OnSetTitle(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;

        if (*pguidCmdGroup == CGID_MSHTML)
        {
            // Only register non-query based commands
            if (pvarargOut == NULL)
                IGNORE_HR(PadDoc()->GetScriptRecorder()->RegisterCommand(nCmdID, nCmdexecopt, pvarargIn) );

        }
        else if (*pguidCmdGroup == CGID_EditStateCommands)
        {
            // Make sure script recorder is enabled before returning S_OK here
            if (nCmdID == IDM_CONTEXT)
                hr = S_OK; // must return S_OK to enable routing to the pad
        }
    }
    return (hr);
}

// snap to grid implementation from the host - IPad
STDMETHODIMP
CPadSite::SnapRect(IHTMLElement* pIElement, RECT* prcNew, ELEMENT_CORNER eHandle)
{
#if DBG==1
    if (IsTagEnabled(tagSnapGrid))
    { 
        RECT rect = *prcNew;

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_LEFT       || 
            eHandle == ELEMENT_CORNER_TOPLEFT    ||
            eHandle == ELEMENT_CORNER_BOTTOMLEFT ||
            eHandle == ELEMENT_CORNER_NONE )
        {           
            if ((rect.left % 10) != 0)
                rect.left += 10 - (rect.left % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_RIGHT       || 
            eHandle == ELEMENT_CORNER_TOPRIGHT    ||
            eHandle == ELEMENT_CORNER_BOTTOMRIGHT )
        {
            if ((rect.right % 10) != 0)
                rect.right += 10 - (rect.right % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_TOP      || 
            eHandle == ELEMENT_CORNER_TOPLEFT  ||
            eHandle == ELEMENT_CORNER_TOPRIGHT ||
            eHandle == ELEMENT_CORNER_NONE )
        {
            if ((rect.top % 10) != 0)
                rect.top += 10 - (rect.top % 10);
        }

        // just move the point to next whole number divided by 10
        if (eHandle == ELEMENT_CORNER_BOTTOM      || 
            eHandle == ELEMENT_CORNER_BOTTOMLEFT  ||
            eHandle == ELEMENT_CORNER_BOTTOMRIGHT )
        {
            if ((rect.bottom % 10) != 0)
                rect.bottom  += 10 - (rect.bottom % 10);
        }

        TraceTag((tagShowSnap,"Rect snapped to: left:%d top:%d right:%d bottom:%d", 
                              rect.left, rect.top, rect.right, rect.bottom));

        *prcNew = rect;
    }    

    
#endif
    RRETURN(S_OK);
}


STDMETHODIMP
CPadSite::OnControlInfoChanged(void)
{
    return S_OK;
}

STDMETHODIMP
CPadSite::LockInPlaceActive(BOOL fLock)
{
    return S_OK;
}

STDMETHODIMP
CPadSite::GetExtendedControl(IDispatch ** ppDisp)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::TransformCoords(
        POINTL * pPtlHiMetric,
        POINTF * pPtfContainer,
        DWORD dwFlags)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::TranslateAccelerator(MSG * lpmsg, DWORD grfModifiers)
{
    RRETURN1(S_FALSE, S_FALSE);
}

STDMETHODIMP
CPadSite::OnFocus(BOOL fGotFocus)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadSite::ShowPropertyFrame(void)
{
    RRETURN(E_NOTIMPL);
}

void STDMETHODCALLTYPE
CPadSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    if ((dwAspect & DVASPECT_CONTENT))
        PadDoc()->DirtyColors();

    PadDoc()->_lViewChangesFired++;
}

void STDMETHODCALLTYPE
CPadSite::OnDataChange(FORMATETC *petc, STGMEDIUM *pstgmed)
{
    PadDoc()->_lDataChangesFired++;
}

void STDMETHODCALLTYPE
CPadSite::OnRename(IMoniker *pmk)
{
}

void STDMETHODCALLTYPE
CPadSite::OnSave()
{
}

void STDMETHODCALLTYPE
CPadSite::OnClose()
{
}

DeclareTag(tagDefaultDIV, "Edit", "Default block element is DIV");

//+---------------------------------------------------------------
//
//      Skeletal Implemenation of IDocHostUIHandler
//
//+---------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetHostInfo
//
//  Synopsis:   Fetch information and flags from the host.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    HRESULT     hr = S_OK;

    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
        return E_INVALIDARG;

    pInfo->dwFlags = DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
    
    if (IsTagEnabled(tagDefaultDIV))
        pInfo->dwFlags |= DOCHOSTUIFLAG_DIV_BLOCKDEFAULT;

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    //
    // behaviors testing
    //

    if (IsTagEnabled(tagPeerProvideTestBehaviors))
    {
        static const TCHAR achNS [] = _T("HOST1;HOST2");
        static const TCHAR achCss[] = _T("HOST1\\:* { behavior:url(#default#DRT1) } ")
                                      _T("HOST2\\:* { behavior:url(#default#DRT2) } ");

        pInfo->pchHostNS  = (LPTSTR) CoTaskMemAlloc (sizeof(achNS));
        pInfo->pchHostCss = (LPTSTR) CoTaskMemAlloc (sizeof(achCss));
        if (!pInfo->pchHostNS || !pInfo->pchHostCss)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _tcscpy (pInfo->pchHostNS,  achNS);
        _tcscpy (pInfo->pchHostCss, achCss);
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ShowUI
//
//  Synopsis:   This method allows the host replace object's menu
//              and toolbars. It returns S_OK if host display
//              menu and toolbar, otherwise, returns S_FALSE.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ShowUI(
        DWORD dwID,
        IOleInPlaceActiveObject * pActiveObject,
        IOleCommandTarget * pCommandTarget,
        IOleInPlaceFrame * pFrame,
        IOleInPlaceUIWindow * pDoc)
{
    return S_OK ;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::HideUI
//
//  Synopsis:   Remove menus and toolbars cretaed during the call
//              to ShowUI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::HideUI(void)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::UpdateUI
//
//  Synopsis:   Update the state of toolbar buttons.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::UpdateUI(void)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::EnableModeless
//
//  Synopsis:   Enable or disable modless UI.
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::OnDocWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::OnDocWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::OnFrameWindowActivate
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::OnFrameWindowActivate(BOOL fActivate)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ResizeBorder
//
//  Returns:    S_OK.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ResizeBorder(
        LPCRECT prc,
        IOleInPlaceUIWindow * pUIWindow,
        BOOL fFrameWindow)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::ShowContextMenu
//
//  Returns:    S_OK -- Host displayed its own UI.
//              S_FALSE -- Host did not display any UI.
//              DOCHOST_E_UNKNOWN -- The menu ID is unknown..
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::ShowContextMenu(
            DWORD dwID,
            POINT * pptPosition,
            IUnknown * pcmdtReserved,
            IDispatch * pDispatchObjectHit)
{
    // lie about displaying UI to disable context menus
    if(IsTagEnabled(tagNoContextMenus))
        return S_OK;
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::TranslateAccelerator
//
//  Returns:    S_OK -- The mesage was translated successfully.
//              S_FALSE -- The message was not translated.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::TranslateAccelerator(
            LPMSG lpmsg,
            const GUID * pguidCmdGroup,
            DWORD nCmdID)
{
    HRESULT hr = S_FALSE;

    if (PadDoc()->_hAccelerators)
    {
        INT rc;

        rc = ::TranslateAccelerator(PadDoc()->_hwnd, PadDoc()->_hAccelerators, lpmsg);
        hr = rc ? S_OK : S_FALSE;
    }

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetOptionKeyPath
//
//  Synopsis:   Get the registry key where host stores its default
//              options.
//
//  Returns:    S_OK          -- Success.
//              E_OUTOFMEMORY -- Fail.
//
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    return S_FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::GetDropTarget
//
//  Returns:    S_OK -- Host will return its droptarget to overwrite given one.
//              S_FALSE -- Host does not want to overwrite droptarget
//---------------------------------------------------------------
STDMETHODIMP
CPadSite::GetDropTarget(
        IDropTarget * pDropTarget,
        IDropTarget ** ppDropTarget)
{
    return S_FALSE;
}
//+------------------------------------------------------------------------
//
//  Member:     CPadSite::PopulateNamespaceTable()
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPadSite::PopulateNamespaceTable(void)
{
    IDispatch * pdispDoc = NULL;
    
    HRESULT                     hr;
    IServiceProvider *          pServiceProvider = NULL;
    IElementNamespaceTable *    pTable = NULL;
    VARIANT                     varFactory;
    BSTR                        bstrNamespace1 = SysAllocString(_T("HBINS1"));
    BSTR                        bstrNamespace2 = SysAllocString(_T("HBINS2"));
    BSTR                        bstrNamespace3 = SysAllocString(_T("HBINS3"));

    if (bstrNamespace1 == NULL ||
        bstrNamespace2 == NULL ||
        bstrNamespace3 == NULL)
        goto Cleanup;

    HWND Wnd;

    VariantInit(&varFactory);

    hr = PadDoc()->get_Document_Early(&pdispDoc);
    if (hr || pdispDoc == NULL)
        goto Cleanup;

    // get the table

    hr = THR(pdispDoc->QueryInterface(IID_IServiceProvider, (void**) &pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(IID_IElementNamespaceTable, IID_IElementNamespaceTable, (void**) &pTable));
    if (hr)
        goto Cleanup;

    // prepare factory

    V_VT(&varFactory) = VT_UNKNOWN;
    hr = THR(QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varFactory)));
    if (hr)
        goto Cleanup;

    // add namespaces

    hr = THR(pTable->AddNamespace(bstrNamespace1, NULL, 0, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace2, NULL, ELEMENTNAMESPACEFLAGS_ALLOWANYTAG, &varFactory));
    if (hr)
        goto Cleanup;

    hr = THR(pTable->AddNamespace(bstrNamespace3, NULL, ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS, &varFactory));
    if( hr )
        goto Cleanup;

Cleanup:

    ReleaseInterface(pdispDoc);

    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pTable);
    VariantClear (&varFactory);
    SysFreeString(bstrNamespace1);
    SysFreeString(bstrNamespace2);
    SysFreeString(bstrNamespace3);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPadSite::Create, per IElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT
CreateHelper(IElementNamespace * pNamespace, BOOL fSpecial)
{
    HRESULT     hr = S_OK;
    BSTR        bstrTag1 = SysAllocString(_T("ELEM1"));
    BSTR        bstrTag2 = SysAllocString(_T("ELEM2"));
    BSTR        bstrTag3 = SysAllocString(_T("ELEM3"));
    BSTR        bstrTag4 = SysAllocString(_T("Special"));

    Assert (pNamespace);

    hr = THR(pNamespace->AddTag(bstrTag1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->AddTag(bstrTag2, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->AddTag(bstrTag3, 0));
    if (hr)
        goto Cleanup;

    if( fSpecial )
    {
        hr = THR(pNamespace->AddTag(bstrTag4, 2));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrTag1);
    SysFreeString(bstrTag2);
    SysFreeString(bstrTag3);
    SysFreeString(bstrTag4);
    
    RRETURN (hr);
}

HRESULT
CPadSite::Create(IElementNamespace * pNamespace)
{
    if( !IsTagEnabled(tagImplementNSFactory2) )
    {
        RRETURN( CreateHelper( pNamespace, FALSE ) );
    }
    else
    {
        return E_UNEXPECTED;
    }
}

HRESULT
CPadSite::CreateWithImplementation( IElementNamespace * pNamespace, BSTR bstrImplementation )
{
    BOOL fSpecial = bstrImplementation && !StrCmpIC( bstrImplementation, _T("#default#special") );

    RRETURN (CreateHelper( pNamespace, fSpecial ) );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CPadSite::Resolve
//  
//  Synopsis:   Responds to requests from Trident to resolve tags
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          BSTR bstrNamespace - 
//          BSTR bstrTagName - 
//          BSTR bstrAttrs - 
//          IElementNamespace * pNamespace - 
//  
//+----------------------------------------------------------------------------

HRESULT
CPadSite::Resolve( BSTR bstrNamespace,
                   BSTR bstrTagName,
                   BSTR bstrAttrs,
                   IElementNamespace * pNamespace )
{
    Assert( bstrTagName && *bstrTagName );

    BOOL    fMakeLiteral = bstrTagName[0] == _T('L');
    BOOL    fMakeNested  = bstrTagName[0] == _T('N');
    BOOL    fMakeUnknown = bstrTagName[0] == _T('U');
    HRESULT hr           = S_OK;

    //
    // Testing host-queried element behaviors.  
    // If first char is "L", we'll call it literal.
    // If first char is "N", it's nested literal
    // If first char is "U", we'll claim we don't know it.
    //

    if( fMakeUnknown )
        goto Cleanup;

    hr = THR( pNamespace->AddTag( bstrTagName, fMakeLiteral ? ELEMENTDESCRIPTORFLAGS_LITERAL : ( fMakeNested ? ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL : 0 ) ) );
    if( hr )
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::FindBehavior, per IElementBehaviorFactory
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::FindBehavior(
    LPOLESTR                pchName,
    LPOLESTR                pchUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT         hr = S_OK;
    const static CLSID CLSID_OmegaBehavior = {0x3BF60250,0x6FAA,0x11D2,{0x98,0x68,0x00,0x00,0xF8,0x7A,0x48,0xD6}};

    if (!pchName ||
        (0 != StrCmpNIC(_T("DRT"),    pchName, 3) &&
         0 != StrCmpNIC(_T("ELEM1"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM2"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM3"),  pchName, 5) &&
         0 != StrCmpNIC(_T("ELEM01"), pchName, 6) &&
         0 != StrCmpNIC(_T("ELEM02"), pchName, 6) &&
         0 != StrCmpNIC(_T("ELEM03"), pchName, 6) &&
         0 != StrCmpNIC(_T("QueryElem"), pchName, 10) &&
         0 != StrCmpNIC(_T("LiteralElem"), pchName, 12) &&
         0 != StrCmpNIC(_T("RandomElem"), pchName, 11) &&
         0 != StrCmpNIC(_T("NestedLiteral"), pchName, 13) &&
         0 != StrCmpNIC(_T("Special"), pchName, 7)))
        return E_FAIL;

    if (ppPeer)
    {
        hr = THR(CoCreateInstance(
            CLSID_OmegaBehavior,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehavior,
            (void **)ppPeer));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPadSite::QueryUseLocalVersionVector
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::QueryUseLocalVersionVector(BOOL *pfUseLocal)
{
    *pfUseLocal = FALSE;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CPadSite::QueryVersionVector
//
//---------------------------------------------------------------

STDMETHODIMP
CPadSite::QueryVersionVector(IVersionVector *pVersion)
{
    HRESULT hr;
    TCHAR ach[MAX_PATH];

    hr = THR(pVersion->SetVersion(_T("mshtmpad"), _T("1.1p")));
    if (hr)
        goto Cleanup;

    _tcscpy(ach, _T("1."));
    _tcscat(ach, PadDoc()->ProcessorArchitecture());
    hr = THR(pVersion->SetVersion(_T("ProcessorArchitecture"), ach));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CPadSite::GetSequenceNumber( long nCurrent, long * pnNew )
{
    static long nSequenceNumber;

    if( !pnNew )
    {
        return E_INVALIDARG;
    }

    if( nCurrent == nSequenceNumber )
        *pnNew = nCurrent;
    else
        *pnNew = InterlockedIncrement( &nSequenceNumber );

    return S_OK;
}

STDMETHODIMP
CPadSite::GetExternal(IDispatch** ppDisp)
{
    HRESULT hr = E_INVALIDARG;

    if (ppDisp && PadDoc())
    {
        Assert(PadDoc()->GetObjectRefs());
        hr = THR(PadDoc()->QueryInterface(IID_IDispatch, (void**)ppDisp));
        Assert(PadDoc()->GetObjectRefs());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padsend.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padauto.cxx
//
//  Contents:   CPadDoc class.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PADDEBUG_HXX_
#define X_PADDEBUG_HXX_
#include "paddebug.hxx"
#endif

enum SENDKEY_FLAGS
{
    FLAG_SHIFT      = 1,
    FLAG_CONTROL    = 2,
    FLAG_MENU       = 4
};

//---------------------------------------------------------------------------
//?
//  Member:     CPadDoc::EnqueueKeyAction
//
//  Synopsis:   Enqueue action for later processing.  Actions are
//              processed by DoKeyAction in response to WM_USER messages.
//
//---------------------------------------------------------------------------

void
CPadDoc::EnqueueKeyAction(DWORD dwFlags, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if ( IsWindow( g_hwndActiveWindow ) )
    {
        PostMessage(g_hwndActiveWindow, msg, wParam, lParam);
    }
    else
    {
        PADTHREADSTATE * pts = GetThreadState();
        SENDKEY_ACTION *paction;

        if (pts->caction >= ARRAY_SIZE(pts->aaction) - 1)
        {
            Assert(0 && "SendKey buffer overflow.");
            return;
        }

        paction = &pts->aaction[pts->caction++];
        paction->msg  = msg;
        paction->wParam = wParam;
        paction->lParam = lParam;
        paction->dwFlags = dwFlags;

        if (pts->caction == 1)
        {
            PostMessage(_hwnd, WM_DOKEYACION, 0, 0);
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member:     CPadDoc::DoKeyAction
//
//  Synopsis:   This method is called in response to a WM_USER message
//              and processes on keyboard action at a time.  If more
//              keyboard actions are waiting, it posts a new WM_USER
//              message. 
//
//---------------------------------------------------------------------------

void
CPadDoc::DoKeyAction()
{
    PADTHREADSTATE * pts = GetThreadState();
    SENDKEY_ACTION * paction;
    BYTE             abState[256];
    HWND             hwnd;
    MSG              msg = {0};
    
    Assert(pts->iaction < pts->caction);
    paction = &pts->aaction[pts->iaction++];   

    if (!_fKeyStateLocked)
    {
        if (GetKeyboardState(abState))
        {
            abState[VK_SHIFT] = (paction->dwFlags & FLAG_SHIFT) ? 0x80 : 0;
            abState[VK_CONTROL] = (paction->dwFlags & FLAG_CONTROL) ? 0x80 : 0;
            abState[VK_MENU] = (paction->dwFlags & FLAG_MENU) ? 0x80 : 0;
            SetKeyboardState(abState);
        }
    }

    msg.message = paction->msg;
    msg.wParam = paction->wParam;
    msg.lParam = paction->lParam;

    if (GetLastActivePopup(_hwnd) == _hwnd)
    {
        if ((hwnd = GetFocus()) != NULL)
        {
            // use focus window if we can get one
        }
        else if (_pInPlaceActiveObject &&
            OK(_pInPlaceActiveObject->GetWindow(&hwnd)))
        {
            // use inplace active object hwnd
        }
        else if (_pInPlaceObject &&
            OK(_pInPlaceObject->GetWindow(&hwnd)))
        {
            // use inplace object window
        }
        else
        {
            // use our window
            hwnd = _hwnd;
        }

        msg.hwnd = hwnd;
        if (!OnTranslateAccelerator(&msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            // Retrieve the WM_CHAR/WM_SYSCHAR message that may have been
            // generated by TranslateMessage() and dispatch it
            // immediately, so that it gets processed with the right
            // key state set.
            if (PeekMessage(&msg,
                     msg.hwnd, 
                    (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR, 
                    (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR,
                    PM_REMOVE))

            {
                if (!OnTranslateAccelerator(&msg))
                    DispatchMessage(&msg);
            }
        }
    }
    else
    {
        // Active window is not the pad window.  Make it be the foreground
        // window so that the focus is correct.
        
        if (GetForegroundWindow() != GetLastActivePopup(_hwnd))
        {
            SetForegroundWindow(GetLastActivePopup(_hwnd));
        }

        // Send the message to the foreground window.
        msg.hwnd = GetFocus();

        if (paction->dwFlags & (FLAG_MENU|FLAG_SHIFT|FLAG_CONTROL))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            // Retrieve the WM_CHAR/WM_SYSCHAR message that may have been
            // generated by TranslateMessage() and dispatch it
            // immediately, so that it gets processed with the right
            // key state set.
            if (PeekMessage(&msg,
                        msg.hwnd, 
                        (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR, 
                        (paction->dwFlags & FLAG_MENU) ? WM_SYSCHAR : WM_CHAR,
                        PM_REMOVE))

             {
                DispatchMessage(&msg);
             }
        }
        else
            PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
    }

    if (pts->iaction < pts->caction)
    {
        PostMessage(_hwnd, WM_DOKEYACION, 0, 0);
    }
    else
    {
        if (!_fKeyStateLocked)
        {
            abState[VK_MENU] = 0;
            abState[VK_SHIFT] = 0;
            abState[VK_CONTROL] = 0;
            SetKeyboardState(abState);
        }
        pts->iaction = 0;
        pts->caction = 0;

        if (_pDebugWindow && pts->fDebugWindowInFront)
        {
            SetForegroundWindow(_pDebugWindow->_hwnd);
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::LockKeyState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::LockKeyState(VARIANT_BOOL fShift, VARIANT_BOOL fControl, VARIANT_BOOL fAlt)
{
    if (!_fKeyStateLocked)
    {
        BYTE    abState[256];
    
        _fKeyStateLocked = TRUE;
        if (GetKeyboardState(abState))
        {
            abState[VK_SHIFT] = (fShift) ? 0x80 : 0;
            abState[VK_CONTROL] = (fControl) ? 0x80 : 0;
            abState[VK_MENU] = (fAlt) ? 0x80 : 0;
            SetKeyboardState(abState);
        }
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::UnlockKeyState, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::UnlockKeyState()
{
    if (_fKeyStateLocked)
    {
        BYTE    abState[256];
    
        _fKeyStateLocked = FALSE;
        if (GetKeyboardState(abState))
        {
            abState[VK_MENU] = 0;
            abState[VK_SHIFT] = 0;
            abState[VK_CONTROL] = 0;
            SetKeyboardState(abState);
        }
    }
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SendKeys, IPad
//
//---------------------------------------------------------------------------

HRESULT
CPadDoc::SendKeys(BSTR bstrKeys, VARIANT_BOOL fWait)
{
    PADTHREADSTATE * pts = GetThreadState();
    TCHAR * pch;

    if (!g_hwndActiveWindow && !_pInPlaceActiveObject)
        return S_OK;

    if ( g_hwndActiveWindow )
    {
        if ( IsWindow( g_hwndActiveWindow ) )
        {
            SetForegroundWindow( g_hwndActiveWindow );
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (_pDebugWindow &&
        GetForegroundWindow() == _pDebugWindow->_hwnd)
    {
        pts->fDebugWindowInFront = TRUE;
        SetForegroundWindow(GetLastActivePopup(_hwnd));
    }
    else
    {
        pts->fDebugWindowInFront = FALSE;
    }

    pch = bstrKeys;

    while (*pch != 0)
    {
        pch = SendKey(pch, 0);
    }

    if (fWait)
    {
        Run(TRUE);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadDoc::SendKey, IPad
//
//---------------------------------------------------------------------------
          
TCHAR *
CPadDoc::SendKey(TCHAR * pch, DWORD dwFlags)
{
    switch (*pch)
    {
    case _T('+'):
        pch = SendKey(++pch, dwFlags | FLAG_SHIFT);
        break;
    
    case _T('^'):
        pch = SendKey(++pch, dwFlags | FLAG_CONTROL);
        break;
     
    case _T('%'):
        pch = SendKey(++pch, dwFlags | FLAG_MENU);
        break;

    case _T('{'):
        pch = SendSpecial(++pch, dwFlags);
        break;

    case _T('~'):
        EnqueueKeyAction(dwFlags, WM_KEYDOWN, VK_RETURN, (LPARAM)1);

        // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
        // generates spurious WM_CHAR.
        EnqueueKeyAction(dwFlags, WM_KEYUP, VK_RETURN, (LPARAM)0xc0000001);
        pch++;
        break;

    case _T('('):
        pch++;
        while (*pch != _T(')') && *pch != 0)
            pch = SendKey(pch, dwFlags);
        if(*pch == _T(')'))
            pch++;
        break;

    default:
        {
            WORD vKeyCode = VkKeyScan(*pch++);
        
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_SYSKEYDOWN, LOBYTE(vKeyCode), 0x20000001);
            else
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_KEYDOWN, LOBYTE(vKeyCode),1);

            // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
            // generates spurious WM_CHAR.            
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_SYSKEYUP, LOBYTE(vKeyCode), 0xc0000001);
            else
                EnqueueKeyAction(dwFlags | HIBYTE(vKeyCode), WM_KEYUP, LOBYTE(vKeyCode), 0xc0000001);
        }
        break;
    }

    return pch;
}

struct KEYENTRY
{
    TCHAR achName[20];
    int nKey;
};

KEYENTRY aKeyEntry[] =
{
    {_T("BACKSPACE"),   VK_BACK},
    {_T("BS"),          VK_BACK},
    {_T("BKSP"),        VK_BACK},
    {_T("BREAK"),       VK_PAUSE},
    {_T("CAPSLOCK"),    VK_CAPITAL},
    {_T("DELETE"),      VK_DELETE},
    {_T("DEL"),         VK_DELETE},
    {_T("DOWN"),        VK_DOWN},
    {_T("END"),         VK_END},
    {_T("ENTER"),       VK_RETURN},
    {_T("ESC"),         VK_ESCAPE},
    {_T("HOME"),        VK_HOME},
    {_T("INSERT"),      VK_INSERT},
    {_T("LEFT"),        VK_LEFT},
    {_T("NUMLOCK"),     VK_NUMLOCK},
    {_T("PGDN"),        VK_NEXT},
    {_T("PGUP"),        VK_PRIOR},
    {_T("PRTSC"),       VK_SNAPSHOT},
    {_T("RIGHT"),       VK_RIGHT},
    {_T("SCROLLLOCK"),  VK_SCROLL},
    {_T("TAB"),         VK_TAB},
    {_T("UP"),          VK_UP},
    {_T("HELP"),        VK_HELP},
    {_T("NUMPAD0"),     VK_NUMPAD0},
    {_T("NUMPAD0"),     VK_NUMPAD1},
    {_T("NUMPAD0"),     VK_NUMPAD2},
    {_T("NUMPAD0"),     VK_NUMPAD3},
    {_T("NUMPAD0"),     VK_NUMPAD4},
    {_T("NUMPAD0"),     VK_NUMPAD5},
    {_T("NUMPAD0"),     VK_NUMPAD6},
    {_T("NUMPAD0"),     VK_NUMPAD7},
    {_T("NUMPAD0"),     VK_NUMPAD8},
    {_T("NUMPAD0"),     VK_NUMPAD9},
    {_T("MULTIPLY"),    VK_MULTIPLY},
    {_T("ADD"),         VK_ADD},
    {_T("SEPARATOR"),   VK_SEPARATOR},
    {_T("SUBTRACT"),    VK_SUBTRACT},
    {_T("DECIMAL"),     VK_DECIMAL},
    {_T("DIVIDE"),      VK_DIVIDE},
    {_T("F1"),          VK_F1},
    {_T("F2"),          VK_F2},
    {_T("F3"),          VK_F3},
    {_T("F4"),          VK_F4},
    {_T("F5"),          VK_F5},
    {_T("F6"),          VK_F6},
    {_T("F7"),          VK_F7},
    {_T("F8"),          VK_F8},
    {_T("F9"),          VK_F9},
    {_T("F10"),         VK_F10},
    {_T("F11"),         VK_F11},
    {_T("F12"),         VK_F12},
    {_T("F13"),         VK_F13},
    {_T("F14"),         VK_F14},
    {_T("F15"),         VK_F15},
    {_T("F16"),         VK_F16},
    {_T("KANJI"),       VK_KANJI},
    {_T(""),            0}
};

TCHAR *
CPadDoc::SendSpecial(TCHAR * pch, DWORD dwFlags)
{
    KEYENTRY *pKeyEntry = aKeyEntry;
    TCHAR * pch1, * pch2;
    TCHAR ch1, ch2;
    int cRepeat = 1;

    Assert (pch[-1] == _T('{'));

    pch1 = pch;
    while(*pch1 != _T(' ') && *pch1 != _T('}') && *pch1)
        pch1++;

    ch1 = *pch1;
    *pch1 = 0;

    pch2 = pch1 + 1;

    if(ch1 == _T(' '))
    {
        while(*pch2 != _T('}') && *pch2)
            pch2++;

        ch2 = *pch2;
        *pch2 = 0;

        cRepeat = _wtoi(pch1 + 1);

        *pch2 = ch2;

        pch2++;
    }

    while(pKeyEntry->nKey != 0)
    {
        if(StrCmpIC(pch, pKeyEntry->achName) == 0)
        {
            for(int i = 0; i < cRepeat; i++)
            {
                if (dwFlags & FLAG_MENU)
                    EnqueueKeyAction(
                            dwFlags,
                            WM_SYSKEYDOWN,
                            pKeyEntry->nKey,
                            (LPARAM) 0x20000001);
                else
                    EnqueueKeyAction(
                            dwFlags,
                            WM_KEYDOWN,
                            pKeyEntry->nKey,
                            (LPARAM)1);
            }
            if (dwFlags & FLAG_MENU)
                EnqueueKeyAction(
                        dwFlags,
                        WM_SYSKEYUP,
                        pKeyEntry->nKey,
                        (LPARAM) 0xC0000001);
            else
                // Set the bits 29-31 as per WM_KEYUP documentation. Otherwise, TranslateMessage()
                // generates spurious WM_CHAR.            
                EnqueueKeyAction(
                        dwFlags,
                        WM_KEYUP,
                        pKeyEntry->nKey,
                        (LPARAM)0xC0000001);
            break;
        }

        pKeyEntry++;
    }

    // ??????? Ask Gary what this could be
    if(pKeyEntry->nKey == 0 && *pch != 0 && pch1 == pch + 1)
    {
        for(int i = 0; i < cRepeat; i++)
            EnqueueKeyAction(dwFlags, WM_CHAR, *pch, 1);
    }

    *pch1 = ch1;

    return pch2;
}


// Send keys in such a way that the IME can see them.
TCHAR *
   CPadDoc::SendIMESpecial(TCHAR * pch, DWORD dwFlags)
{
    KEYENTRY *pKeyEntry = aKeyEntry;
    TCHAR * pch1, * pch2;
    TCHAR ch1, ch2;

    Assert (pch[-1] == _T('{'));

    // Eat leading spaces.
    pch1 = pch;
    while(*pch1 != _T(' ') && *pch1 != _T('}') && *pch1)
        pch1++;

    ch1 = *pch1;
    *pch1 = 0;

    pch2 = pch1 + 1;

    // Eat trailling spaces.
    if(ch1 == _T(' '))
    {
        while(*pch2 != _T('}') && *pch2)
            pch2++;

        ch2 = *pch2;
        *pch2 = 0;

        *pch2 = ch2;

        pch2++;
    }

    while(pKeyEntry->nKey != 0)
    {
        if(StrCmpIC(pch, pKeyEntry->achName) == 0)
        {
            keybd_event((BYTE)pKeyEntry->nKey, 0, 0, 0);
            keybd_event((BYTE)pKeyEntry->nKey, 0, KEYEVENTF_KEYUP, 0);
            break;
        }

        pKeyEntry++;
    }

    *pch1 = ch1;

    return pch2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padssite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padssite.hxx
//
//  Contents:   CPadScriptSite
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

EXTERN_C const GUID CGID_ScriptSite = {0x3050f3f1, 0x98b5, 0x11cf, {0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}};
#define CMDID_SCRIPTSITE_URL            0
#define CMDID_SCRIPTSITE_HTMLDLGTRUST   1
#define CMDID_SCRIPTSITE_SECSTATE       2
#define CMDID_SCRIPTSITE_SID            3

#undef ASSERT

class CConnectionPoint : public IConnectionPoint
{
public:

    CConnectionPoint(CPadScriptSite *pSite);
    ~CConnectionPoint();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CPadScriptSite *_pSite;
    ULONG    _ulRefs;
};

CConnectionPoint::CConnectionPoint(CPadScriptSite *pSite)
{
    _ulRefs = 1;
    _pSite = pSite;
    _pSite->AddRef();
}

CConnectionPoint::~CConnectionPoint()
{
    _pSite->Release();
}

ULONG
CConnectionPoint::AddRef()
{
    return _ulRefs += 1;
}

ULONG
CConnectionPoint::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

HRESULT
CConnectionPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_PadEvents;
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pSite;
    (*ppCPC)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    ClearInterface(&_pSite->_pDispSink);
    RRETURN(THR(pUnkSink->QueryInterface(IID_IDispatch, (void **)&_pSite->_pDispSink)));
}

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    ClearInterface(&_pSite->_pDispSink);
    return S_OK;
}

HRESULT
CConnectionPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CPadScriptSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IPad || iid == IID_IDispatch)
    {
        *ppv = (IPad *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppv = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo ||
            iid == IID_IProvideClassInfo2 ||
            iid == IID_IProvideMultipleClassInfo)
    {
        *ppv = (IProvideMultipleClassInfo *)this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite constructor
//
//---------------------------------------------------------------------------

CPadScriptSite::CPadScriptSite(CPadDoc * pDoc)
{
    _pDoc = pDoc;
    _ulRefs = 1;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite destructor
//
//---------------------------------------------------------------------------

CPadScriptSite::~CPadScriptSite()
{
    VariantClear(&_varParam);
    ClearInterface(&_pDispSink);
    Assert(_ulRefs <= 1);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::AddRef, Release
//
//---------------------------------------------------------------------------

ULONG
CPadScriptSite::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CPadScriptSite::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::Init
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::Init(TCHAR *pchType)
{
    HRESULT hr;
    IActiveScriptParse *pParse = NULL;
    static const CLSID CLSID_VBS = { 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8 };
    static const CLSID CLSID_JSCRIPT = { 0xf414c260, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58};
    BSTR    bstrName = NULL;
    BOOL    fJscript = FALSE;

    // CoCreate and connect to Script engine

    if (pchType)
    {
        fJscript = (StrCmpIC(pchType, _T(".js")) == 0);
    }

    hr = THR(CoCreateInstance(
            pchType && fJscript ? CLSID_JSCRIPT : CLSID_VBS,
            NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&_pScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->InitNew());
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->AddNamedItem(_T("Pad"), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS));
    if (hr)
        goto Cleanup;

    if (fJscript)
    {
        //
        // For JavaScript we have to manually hook up known event handlers.
        // All four of these methods _must_ exist in the .js file.
        //

        // Add any pad events that we know people use.
        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadLoad()"),
                     _T("Pad"),
                     NULL,
                     _T("Load"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadDocLoaded(fLoaded)"),
                     _T("Pad"),
                     NULL,
                     _T("DocLoaded(fLoaded)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadStatus(Status)"),
                     _T("Pad"),
                     NULL,
                     _T("Status(Status)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadTimer()"),
                     _T("Pad"),
                     NULL,
                     _T("Timer"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadUnload()"),
                     _T("Pad"),
                     NULL,
                     _T("Unload"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;

        hr = THR(pParse->AddScriptlet(
                     NULL,
                     _T("PadPerfCtl(dwArg)"),
                     _T("Pad"),
                     NULL,
                     _T("PerfCtl(dwArg)"),
                     _T("\""),
                     0,
                     0,
                     0,
                     &bstrName,
                     NULL));
        FormsFreeString(bstrName);
        bstrName = NULL;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::Close
//
//---------------------------------------------------------------------------

void
CPadScriptSite::Close()
{
    if (_pScript)
    {
        IGNORE_HR(_pScript->Close());
        ClearInterface(&_pScript);
    }
}


//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetClassInfo, IProvideClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    HRESULT hr;

    hr = _pDoc->LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *ppTypeInfo = _pDoc->_pTypeInfoCPad;
    (*ppTypeInfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetGUID, IProvideClassInfo2
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = DIID_PadEvents;
    }
    else
    {
        return E_NOTIMPL;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
CPadScriptSite::GetMultiTypeInfoCount(ULONG *pc)
{
    *pc = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CPadScriptSite::GetInfoOfIndex, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetInfoOfIndex(
    ULONG       itinfo,
    DWORD       dwFlags,
    ITypeInfo** pptinfoCoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    Assert(itinfo == 0);

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        *pptinfoCoClass = _pDoc->_pTypeInfoCPad;
        (*pptinfoCoClass)->AddRef();
        if (pdwTIFlags)
            *pdwTIFlags = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        *pcdispidReserved = 100;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = IID_IPad;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = DIID_PadEvents;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------
HRESULT
CPadScriptSite::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    // I hate this interface.
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_PadEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CConnectionPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetLCID, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetLCID(LCID *plcid)
{
  return E_NOTIMPL;     // Use system settings
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetItemInfo, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetItemInfo(
      LPCOLESTR   pstrName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
            return E_INVALIDARG;
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
            return E_INVALIDARG;
        *ppunkItemOut = NULL;
    }

    if (!StrCmpIC(_T("Pad"), pstrName))
    {
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            *pptinfoOut = PadDoc()->_pTypeInfoCPad;
            (*pptinfoOut)->AddRef();
        }
        if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
        {
            *ppunkItemOut = (IPad *)this;
            (*ppunkItemOut)->AddRef();
        }
        return S_OK;
    }


    return TYPE_E_ELEMENTNOTFOUND;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::GetDocVersionString, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::GetDocVersionString(BSTR *pbstrVersion)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::RequestItems()
{
    return _pScript->AddNamedItem(_T("Pad"), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::RequestTypeLibs, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::RequestTypeLibs()
{
    return _pScript->AddTypeLib(LIBID_Pad, 1, 0, 0);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnScriptTerminate, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnScriptTerminate(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo)
{
    // UNDONE: Put up error dlg here
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnStateChange, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
    // Don't care about notification
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnScriptError, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::OnScriptError(IActiveScriptError *pse)
{
    BSTR        bstrLine = NULL;
    BSTR        bstr;
    TCHAR *     pchDescription;
    TCHAR       achDescription[256];
    TCHAR *     pchMessage = NULL;
    EXCEPINFO   ei;
    DWORD       dwSrcContext;
    ULONG       ulLine;
    LONG        ichError;
    HRESULT     hr;

    hr = THR(pse->GetExceptionInfo(&ei));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourceLineText(&bstrLine));
    if (hr)
        hr = S_OK;  // Ignore this error, there may not be source available

    if (ei.bstrDescription)
    {
        pchDescription = ei.bstrDescription;
    }
    else
    {
        achDescription[0] = 0;
        FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                ei.scode,
                LANG_SYSTEM_DEFAULT,
                achDescription,
                ARRAY_SIZE(achDescription),
                NULL);
        pchDescription = achDescription;
    }

    hr = THR(Format(FMT_OUT_ALLOC, &pchMessage, 0,
        _T("File: <0s>\r\n")
        _T("Line: <1d>\r\n")
        _T("Char: <2d>\r\n")
        _T("Text: <3s>\r\n")
        _T("Scode: <4x>\r\n")
        _T("Source: <5s>\r\n")
        _T("Description: <6s>\r\n"),
        _achPath,
        (long)(ulLine + 1),
        (long)(ichError),
        bstrLine ? bstrLine : _T(""),
        ei.scode,
        ei.bstrSource ? ei.bstrSource : _T(""),
        pchDescription));
    if (hr)
        goto Cleanup;

    bstr = SysAllocString(pchMessage);

    // PrintLog needs a BSTR
    _pDoc->PrintLog(bstr);

    SysFreeString(bstr);

    if (!IsTagEnabled(tagAssertExit))
    {
        MSGBOXPARAMS mbp;
        memset(&mbp, 0, sizeof(mbp));
        mbp.cbSize = sizeof(mbp);
        mbp.hwndOwner = PadDoc()->_hwnd;
        mbp.lpszText = pchMessage;
        mbp.lpszCaption = _T("Error");
        mbp.dwStyle = MB_APPLMODAL | MB_ICONERROR | MB_OK;

        MessageBoxIndirect(&mbp);
    }
    else
    {
        AssertSz(FALSE, "Script Error Occurred. (See logfile)");
    }

Cleanup:
    if(ei.bstrSource)
        SysFreeString(ei.bstrSource);
    if(ei.bstrDescription)
        SysFreeString(ei.bstrDescription);
    if(ei.bstrHelpFile)
        SysFreeString(ei.bstrHelpFile);
    MemFree(pchMessage);
    if (bstrLine)
        SysFreeString(bstrLine);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnEnterScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::OnEnterScript()
{
    // No need to do anything
    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::OnLeaveScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::OnLeaveScript()
{
    // No need to do anything
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::GetWindow(HWND *phwndOut)
{
    *phwndOut = PadDoc()->_hwnd;
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::EnableModeless, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CPadScriptSite::ExecuteScriptFile
//
//  Load and execute script file
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::ExecuteScriptFile(TCHAR *pchPath)
{
    HRESULT     hr;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cchFile;
    DWORD       cbRead;
    char *      pchBuf = 0;
    TCHAR *     pchBufWide = 0;
    TCHAR *     pchFile;

    GetFullPathName(pchPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);

    // Load script file

    hFile = CreateFile(pchPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    cchFile = GetFileSize(hFile, NULL);
    if (cchFile == 0xFFFFFFFF)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    pchBuf = new char[cchFile + 1];
    pchBufWide = new TCHAR[cchFile + 1];
    if (!pchBuf || !pchBufWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!ReadFile(hFile, pchBuf, cchFile, &cbRead, 0))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    pchBuf[cbRead] = 0;

    MultiByteToWideChar(CP_ACP, 0, pchBuf, -1, pchBufWide, cchFile + 1);

    // Execute script

    _pDoc->SetStatusText(NULL);

    hr = ExecuteScriptStr(pchBufWide);
    if(hr)
        goto Cleanup;

    _pDoc->SetStatusText(NULL);

Cleanup:
    delete pchBuf;
    delete pchBufWide;
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::ExecuteScriptStr
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::ExecuteScriptStr(TCHAR * pchScript)
{
    HRESULT hr;
    IActiveScriptParse * pParse = NULL;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->ParseScriptText(pchScript, _T("Pad"), NULL, NULL, 0, 0, 0L, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::SetScriptState
//
//---------------------------------------------------------------------------

HRESULT
CPadScriptSite::SetScriptState(SCRIPTSTATE ss)
{
    return _pScript->SetScriptState(ss);
}

//---------------------------------------------------------------------------
//
// Method:  CPadScriptSite::xxx, IPad
//
//          The implementation of IPad passed to the script engine
//          cannot be the same as that of the CPadDoc because this
//          causes a reference count loop with the script engine.
//
//---------------------------------------------------------------------------

HRESULT CPadScriptSite::GetTypeInfoCount(UINT FAR* pctinfo)
            { return PadDoc()->GetTypeInfoCount(pctinfo); }
HRESULT CPadScriptSite::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo FAR* FAR* pptinfo)
            { return PadDoc()->GetTypeInfo(itinfo, lcid, pptinfo); }
HRESULT CPadScriptSite::GetIDsOfNames(
  REFIID riid,
  OLECHAR FAR* FAR* rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID FAR* rgdispid)
            { return PadDoc()->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
HRESULT CPadScriptSite::Invoke(
						  DISPID dispidMember,
						  REFIID riid,
						  LCID lcid,
						  WORD wFlags,
						  DISPPARAMS FAR* pdispparams,
						  VARIANT FAR* pvarResult,
						  EXCEPINFO FAR* pexcepinfo,
						  UINT FAR* puArgErr)
            { return PadDoc()->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }
HRESULT CPadScriptSite::DoEvents(VARIANT_BOOL Wait)
            { return PadDoc()->DoEvents(Wait); }
HRESULT CPadScriptSite::EndEvents()
            { return PadDoc()->EndEvents(); }
HRESULT CPadScriptSite::ClearDownloadCache()
            { return PadDoc()->ClearDownloadCache(); }
HRESULT CPadScriptSite::WaitForRecalc()
            { return PadDoc()->WaitForRecalc(); }
HRESULT CPadScriptSite::SetPerfCtl(DWORD dwFlags)
            { return PadDoc()->SetPerfCtl(dwFlags); }
HRESULT CPadScriptSite::LockWindowUpdate(VARIANT_BOOL fLock)
            { return PadDoc()->LockWindowUpdate(fLock); }
HRESULT CPadScriptSite::LockKeyState(VARIANT_BOOL fShift, VARIANT_BOOL fControl, VARIANT_BOOL fAlt)
            { return PadDoc()->LockKeyState(fShift, fControl, fAlt); }
HRESULT CPadScriptSite::UnlockKeyState()
            { return PadDoc()->UnlockKeyState(); }
HRESULT CPadScriptSite::SendKeys(BSTR Keys, VARIANT_BOOL Wait)
            { return PadDoc()->SendKeys(Keys, Wait); }
HRESULT CPadScriptSite::OpenFile(BSTR Path, BSTR ProgID)
            { return PadDoc()->OpenFile(Path, ProgID); }
HRESULT CPadScriptSite::SaveFile(BSTR Path)
            { return PadDoc()->SaveFile(Path); }
HRESULT CPadScriptSite::CloseFile()
            { return PadDoc()->CloseFile(); }
HRESULT CPadScriptSite::ExecuteCommand(long CmdID, VARIANT * Data, VARIANT *pIDocument)
            { return PadDoc()->ExecuteCommand(CmdID, Data, pIDocument); }
HRESULT CPadScriptSite::QueryCommandStatus(long CmdID, VARIANT * Status)
            { return PadDoc()->QueryCommandStatus(CmdID, Status); }
HRESULT CPadScriptSite::ExecuteScript(BSTR Path, VARIANT *ScriptParam, VARIANT_BOOL Async)
            { return PadDoc()->ExecuteScript(Path, ScriptParam, Async); }
HRESULT CPadScriptSite::RegisterControl(BSTR Path)
            { return PadDoc()->RegisterControl(Path); }
HRESULT CPadScriptSite::IncludeScript(BSTR Path)
            { return PadDoc()->IncludeScript(Path); }
HRESULT CPadScriptSite::SetProperty(IDispatch * pDisp, BSTR bstrProp, VARIANT * pVar)
            { return PadDoc()->SetProperty(pDisp, bstrProp, pVar); }
HRESULT CPadScriptSite::GetProperty(IDispatch * pDisp, BSTR bstrProp, VARIANT * pVar)
            { return PadDoc()->GetProperty(pDisp, bstrProp, pVar); }
HRESULT CPadScriptSite::get_ScriptPath(long Level, BSTR * Path)
            { return PadDoc()->get_ScriptPath(Level, Path); }
HRESULT CPadScriptSite::get_ProcessorArchitecture(BSTR * MachineType)
            { return PadDoc()->get_ProcessorArchitecture(MachineType); }
HRESULT CPadScriptSite::get_ScriptParam(VARIANT *ScriptParam)
            { return PadDoc()->get_ScriptParam(ScriptParam); }
HRESULT CPadScriptSite::get_ScriptObject(IDispatch **ScriptObject)
            { return PadDoc()->get_ScriptObject(ScriptObject); }
HRESULT CPadScriptSite::get_CurrentTime(long * Time)
            { return PadDoc()->get_CurrentTime(Time); }
HRESULT CPadScriptSite::get_Document(IDispatch * * Document)
            { return PadDoc()->get_Document(Document); }
HRESULT CPadScriptSite::get_TempPath(BSTR * Path)
            { return PadDoc()->get_TempPath(Path); }
HRESULT CPadScriptSite::GetTempFileName(BSTR * Name)
            { return PadDoc()->GetTempFileName(Name); }
HRESULT CPadScriptSite::PrintStatus(BSTR Message)
            { return PadDoc()->PrintStatus(Message); }
HRESULT CPadScriptSite::PrintLog(BSTR Line)
            { return PadDoc()->PrintLog(Line); }
HRESULT CPadScriptSite::PrintLogFile(BSTR FileName)
            { return PadDoc()->PrintLogFile(FileName); }
HRESULT CPadScriptSite::PrintDebug(BSTR Line)
            { return PadDoc()->PrintDebug(Line); }
HRESULT CPadScriptSite::CreateObject(BSTR ProgID, IDispatch **ppDisp)
            { return PadDoc()->CreateObject(ProgID, ppDisp); }
HRESULT CPadScriptSite::GetObject(BSTR FileName, BSTR ProgID, IDispatch **ppDisp)
            { return PadDoc()->GetObject(FileName, ProgID, ppDisp); }
HRESULT CPadScriptSite::CompareFiles(BSTR File1, BSTR File2, VARIANT_BOOL * FilesMatch)
            { return PadDoc()->CompareFiles(File1, File2, FilesMatch); }
HRESULT CPadScriptSite::CopyThisFile(BSTR File1, BSTR File2, VARIANT_BOOL * Success)
            { return PadDoc()->CopyThisFile(File1, File2, Success); }
HRESULT CPadScriptSite::DRTPrint(long Flags, VARIANT_BOOL * Success)
            { return PadDoc()->DRTPrint(Flags, Success); }
HRESULT CPadScriptSite::SetDefaultPrinter(BSTR bstrNewDefaultPrinter, VARIANT_BOOL * Success)
            { return PadDoc()->SetDefaultPrinter(bstrNewDefaultPrinter, Success); }
HRESULT CPadScriptSite::SetPrintTemplate(IUnknown *pUnk, VARIANT_BOOL fTemplate)
            { return PadDoc()->SetPrintTemplate(pUnk, fTemplate); }
HRESULT CPadScriptSite::IsPrintTemplate(IUnknown *pUnk, VARIANT_BOOL *pfTemplate)
            { return PadDoc()->IsPrintTemplate(pUnk, pfTemplate); }
HRESULT CPadScriptSite::FileExists(BSTR File, VARIANT_BOOL * pfFileExists)
            { return PadDoc()->FileExists(File, pfFileExists); }
HRESULT CPadScriptSite::get_TimerInterval(long * Interval)
            { return PadDoc()->get_TimerInterval(Interval); }
HRESULT CPadScriptSite::put_TimerInterval(long Interval)
            { return PadDoc()->put_TimerInterval(Interval); }
HRESULT CPadScriptSite::DisableDialogs()
            { return PadDoc()->DisableDialogs(); }
HRESULT CPadScriptSite::ShowWindow(long lCmdShow)
            { return PadDoc()->ShowWindow(lCmdShow); }
HRESULT CPadScriptSite::MoveWindow(long x,long y, long cx, long cy)
            { return PadDoc()->MoveWindow(x, y, cx, cy); }
HRESULT CPadScriptSite::get_WindowLeft(long *x)
            { return PadDoc()->get_WindowLeft(x); }
HRESULT CPadScriptSite::get_WindowTop(long *y)
            { return PadDoc()->get_WindowTop(y); }
HRESULT CPadScriptSite::get_WindowWidth(long *cx)
            { return PadDoc()->get_WindowWidth(cx); }
HRESULT CPadScriptSite::get_WindowHeight(long *cy)
            { return PadDoc()->get_WindowHeight(cy); }
HRESULT CPadScriptSite::get_DialogsEnabled(VARIANT_BOOL *Enabled)
            { return PadDoc()->get_DialogsEnabled(Enabled); }
HRESULT CPadScriptSite::StartCAP()
            { return PadDoc()->StartCAP(); }
HRESULT CPadScriptSite::StopCAP()
            { return PadDoc()->StopCAP(); }
HRESULT CPadScriptSite::SuspendCAP()
            { return PadDoc()->SuspendCAP(); }
HRESULT CPadScriptSite::ResumeCAP()
            { return PadDoc()->ResumeCAP(); }
HRESULT CPadScriptSite::TicStartAll()
            { return PadDoc()->TicStartAll(); }
HRESULT CPadScriptSite::TicStopAll()
            { return PadDoc()->TicStopAll(); }
HRESULT CPadScriptSite::ASSERT(VARIANT_BOOL Assertion, BSTR LogMsg)
            { return PadDoc()->ASSERT(Assertion, LogMsg); }
HRESULT CPadScriptSite::get_Lines(IDispatch * pObject, long *pl)
            { return PadDoc()->get_Lines(pObject, pl); }
HRESULT CPadScriptSite::get_Line(IDispatch * pObject, long l, IDispatch **ppLine)
            { return PadDoc()->get_Line(pObject, l, ppLine); }
HRESULT CPadScriptSite::get_Cascaded(IDispatch * pObject, IDispatch **ppCascaded)
            { return PadDoc()->get_Cascaded(pObject, ppCascaded); }
HRESULT CPadScriptSite::EnableTraceTag(BSTR bstrTag, BOOL fEnable)
            { return PadDoc()->EnableTraceTag(bstrTag, fEnable); }
HRESULT CPadScriptSite::EnableSnapToGrid(BOOL fEnable)
            { return PadDoc()->EnableSnapToGrid(fEnable); }
HRESULT CPadScriptSite::get_Dbg(long * plDbg)
            { return PadDoc()->get_Dbg(plDbg); }
HRESULT CPadScriptSite::CleanupTempFiles()
            { return PadDoc()->CleanupTempFiles(); }
HRESULT CPadScriptSite::WsClear()
            { return PadDoc()->WsClear(); }
HRESULT CPadScriptSite::WsTakeSnapshot()
            { return PadDoc()->WsTakeSnapshot(); }
HRESULT CPadScriptSite::get_WsModule(long row, BSTR *pbstrModule)
            { return PadDoc()->get_WsModule(row, pbstrModule); }
HRESULT CPadScriptSite::get_WsSection(long row, BSTR *pbstrSection)
            { return PadDoc()->get_WsSection(row, pbstrSection); }
HRESULT CPadScriptSite::get_WsSize(long row, long *plWsSize)
            { return PadDoc()->get_WsSize(row, plWsSize); }
HRESULT CPadScriptSite::get_WsCount(long *plCount)
            { return PadDoc()->get_WsCount(plCount); }
HRESULT CPadScriptSite::get_WsTotal(long *plTotal)
            { return PadDoc()->get_WsTotal(plTotal); }
HRESULT CPadScriptSite::WsStartDelta()
            { return PadDoc()->WsStartDelta(); }
HRESULT CPadScriptSite::WsEndDelta(long *pnPageFaults)
            { return PadDoc()->WsEndDelta(pnPageFaults); }
HRESULT CPadScriptSite::SetRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName, VARIANT value)
            { return PadDoc()->SetRegValue(hkey, bstrSubKey, bstrValueName, value); }
HRESULT CPadScriptSite::CoMemoryTrackDisable(VARIANT_BOOL fDisable)
            { return PadDoc()->CoMemoryTrackDisable(fDisable); }
HRESULT CPadScriptSite::get_UseShdocvw(VARIANT_BOOL *pfHosted)
            { return PadDoc()->get_UseShdocvw(pfHosted); }
HRESULT CPadScriptSite::put_UseShdocvw(VARIANT_BOOL fHosted)
            { return PadDoc()->put_UseShdocvw(fHosted); }
HRESULT CPadScriptSite::GoBack(VARIANT_BOOL *pfWentBack)
            { return PadDoc()->GoBack(pfWentBack); }
HRESULT CPadScriptSite::GoForward(VARIANT_BOOL *pfWentForward)
            { return PadDoc()->GoForward(pfWentForward); }
HRESULT CPadScriptSite::TestExternal(BSTR bstrDLLName, BSTR bstrFunctionName, VARIANT *pParam, long *plRetVal)
            { return PadDoc()->TestExternal(bstrDLLName, bstrFunctionName, pParam, plRetVal); }
HRESULT CPadScriptSite::UnLoadDLL()
            { return PadDoc()->UnLoadDLL(); }
HRESULT CPadScriptSite::DeinitDynamicLibrary(BSTR bstrDLLName)
            { return PadDoc()->DeinitDynamicLibrary(bstrDLLName); }
HRESULT CPadScriptSite::IsDynamicLibraryLoaded(BSTR bstrDLLName, VARIANT_BOOL * pfLoaded)
            { return PadDoc()->IsDynamicLibraryLoaded(bstrDLLName, pfLoaded); }
HRESULT CPadScriptSite::GetRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName, VARIANT *pValue)
            { return PadDoc()->GetRegValue(hkey, bstrSubKey, bstrValueName, pValue); }
HRESULT CPadScriptSite::DeleteRegValue(long hkey, BSTR bstrSubKey, BSTR bstrValueName)
            { return PadDoc()->DeleteRegValue(hkey, bstrSubKey, bstrValueName); }
HRESULT CPadScriptSite::TrustProvider(BSTR bstrKey, BSTR bstrProvider, VARIANT *poldValue)
            { return PadDoc()->TrustProvider(bstrKey, bstrProvider, poldValue); }
HRESULT CPadScriptSite::RevertTrustProvider(BSTR bstrKey)
            { return PadDoc()->RevertTrustProvider(bstrKey); }
HRESULT CPadScriptSite::DoReloadHistory()
            { return PadDoc()->DoReloadHistory(); }
HRESULT CPadScriptSite::ComputeCRC(BSTR bstrKey, VARIANT * pCRC)
            { return PadDoc()->ComputeCRC(bstrKey, pCRC); }
HRESULT CPadScriptSite::OpenFileStream(BSTR bstrPath)
            { return PadDoc()->OpenFileStream(bstrPath); }
HRESULT CPadScriptSite::get_ViewChangesFired(long *plCount)
            { return PadDoc()->get_ViewChangesFired(plCount); }
HRESULT CPadScriptSite::get_DataChangesFired(long *plCount)
            { return PadDoc()->get_DataChangesFired(plCount); }
HRESULT CPadScriptSite::get_DownloadNotifyMask(ULONG *pulMask)
            { return PadDoc()->get_DownloadNotifyMask(pulMask); }
HRESULT CPadScriptSite::put_DownloadNotifyMask(ULONG ulMask)
            { return PadDoc()->put_DownloadNotifyMask(ulMask); }
HRESULT CPadScriptSite::DumpMeterLog(BSTR bstrFileName)
            { return PadDoc()->DumpMeterLog(bstrFileName); }
HRESULT CPadScriptSite::LookupMeter(BSTR Meter, long* mt)
            { return PadDoc()->LookupMeter(Meter, mt); }
HRESULT CPadScriptSite::GetMeterName(long mt, BSTR* pbstrName)
            { return PadDoc()->GetMeterName(mt, pbstrName); }
HRESULT CPadScriptSite::GetMeterDesc(long mt, BSTR* pbstrDesc)
            { return PadDoc()->GetMeterDesc(mt, pbstrDesc); }
HRESULT CPadScriptSite::GetMeterCnt(long mt, VARIANT_BOOL fExcl, long* plCnt)
            { return PadDoc()->GetMeterCnt(mt, fExcl, plCnt); }
HRESULT CPadScriptSite::GetMeterVal(long mt, VARIANT_BOOL fExcl, long* plVal)
            { return PadDoc()->GetMeterVal(mt, fExcl, plVal); }
HRESULT CPadScriptSite::MeterAdd(long mt, long lCnt, long lVal)
            { return PadDoc()->MeterAdd(mt, lCnt, lVal); }
HRESULT CPadScriptSite::MeterSet(long mt, long lCnt, long lVal)
            { return PadDoc()->MeterSet(mt, lCnt, lVal); }
HRESULT CPadScriptSite::GetSwitchTimers(VARIANT * pValue)
            { return PadDoc()->GetSwitchTimers(pValue); }
HRESULT CPadScriptSite::TransformXGlobal(int x, int* retX)
            { return PadDoc()->TransformXGlobal(x, retX); }
HRESULT CPadScriptSite::TransformYGlobal(int y, int* retY)
            { return PadDoc()->TransformXGlobal(y,retY); }
HRESULT CPadScriptSite::TransformXDocument(int x, int* retX)
            { return PadDoc()->TransformXDocument(x, retX);}
HRESULT CPadScriptSite::TransformYDocument(int y, int* retY)
            { return PadDoc()->TransformYDocument(y,retY);}
HRESULT CPadScriptSite::MoveMouseTo(int X, int Y, VARIANT_BOOL fLeftButton, int keyState)
            { return PadDoc()->MoveMouseTo(X, Y, fLeftButton, keyState); }
HRESULT CPadScriptSite::DoMouseButton(VARIANT_BOOL fLeftButton, BSTR action, int keyState)
            { return PadDoc()->DoMouseButton(fLeftButton, action, keyState); }
HRESULT CPadScriptSite::DoMouseButtonAt(int X, int Y,VARIANT_BOOL fLeftButton, BSTR action, int keyState)
            { return PadDoc()->DoMouseButtonAt(X, Y, fLeftButton, action, keyState); }            
HRESULT CPadScriptSite::TimeSaveDocToDummyStream(long * plTimeMicros)
            { return PadDoc()->TimeSaveDocToDummyStream(plTimeMicros); }
HRESULT CPadScriptSite::Sleep (int nTimeout)
            { return PadDoc()->Sleep (nTimeout); }
HRESULT CPadScriptSite::IsWin95 (long * pfWin95)
            { return PadDoc()->IsWin95(pfWin95); }
HRESULT CPadScriptSite::GetAccWindow( IDispatch ** ppAccWindow)
        { return PadDoc()->GetAccWindow( ppAccWindow ); }
HRESULT CPadScriptSite::GetAccObjAtPoint( long x, long y, IDispatch **ppAccObject )
        { return PadDoc()->GetAccObjAtPoint(x, y, ppAccObject ); }
HRESULT CPadScriptSite::GetAccChildIdAtPoint( IDispatch * pAccObj, long x, long y, long * plChildId )
        { return PadDoc()->GetAccChildIdAtPoint( pAccObj, x, y, plChildId ); }
HRESULT CPadScriptSite::SetKeyboard(BSTR bstrKeyboard)
        { return PadDoc()->SetKeyboard(bstrKeyboard); }
HRESULT CPadScriptSite::GetKeyboard(VARIANT *pKeyboard)
        { return PadDoc()->GetKeyboard(pKeyboard); }
HRESULT CPadScriptSite::ToggleIMEMode(BSTR bstrIME)
        { return PadDoc()->ToggleIMEMode(bstrIME); }
HRESULT CPadScriptSite::SendIMEKeys(BSTR bstrKeys)
        { return PadDoc()->SendIMEKeys(bstrKeys); }
HRESULT CPadScriptSite::Markup(VARIANT * p1,VARIANT * p2,VARIANT * p3, VARIANT * p4, VARIANT * p5, VARIANT * p6, VARIANT * p7 )
        { return PadDoc()->Markup( p1, p2, p3, p4, p5, p6, p7 ); }
HRESULT CPadScriptSite::Random(long a, long * b )
        { return PadDoc()->Random( a, b ); }
HRESULT CPadScriptSite::RandomSeed(long a )
        { return PadDoc()->RandomSeed( a ); }
HRESULT CPadScriptSite::GetHeapCounter(long a, long * b )
        { return PadDoc()->GetHeapCounter( a, b ); }
HRESULT CPadScriptSite::CreateProcess(BSTR bstrCommandLine, VARIANT_BOOL fWait, VARIANT_BOOL fCaptureOutput, DWORD *pdwExitCode)
        { return PadDoc()->CreateProcess(bstrCommandLine, fWait, fCaptureOutput, pdwExitCode); }
HRESULT CPadScriptSite::GetCurrentProcessId(long * plRetVal)
        { return PadDoc()->GetCurrentProcessId(plRetVal); }
HRESULT CPadScriptSite::InnerHTML(IDispatch *pdispElement, BSTR *pbstrHTML)
        { return PadDoc()->InnerHTML(pdispElement, pbstrHTML); }
HRESULT CPadScriptSite::CurrentBlockElement(IDispatch **ppdispElement)
        { return PadDoc()->CurrentBlockElement(ppdispElement); }
HRESULT CPadScriptSite::FindMshtmlWindow(BSTR bstrClassName, long * plhwnd)
        { return PadDoc()->FindMshtmlWindow( bstrClassName, plhwnd ); }
HRESULT CPadScriptSite::GetMshtmlDoc(long hwnd, IDispatch **ppdispDocument)
        { return PadDoc()->GetMshtmlDoc( hwnd, ppdispDocument); }
HRESULT CPadScriptSite::SetActiveWindow( long lhwnd )
        { return PadDoc()->SetActiveWindow( lhwnd ); }
HRESULT CPadScriptSite::DoPerfEnable(BOOL fEnable)
        { return PadDoc()->DoPerfEnable(fEnable); }
HRESULT CPadScriptSite::DoPerfLog(BSTR bstrLog)
        { return PadDoc()->DoPerfLog(bstrLog); }
HRESULT CPadScriptSite::DoPerfDump()
        { return PadDoc()->DoPerfDump(); }
HRESULT CPadScriptSite::DoPerfClear()
        { return PadDoc()->DoPerfClear(); }
HRESULT CPadScriptSite::BeginPCounters()
        { return PadDoc()->BeginPCounters(); }
HRESULT CPadScriptSite::EndPCounters()
        { return PadDoc()->EndPCounters(); }
HRESULT CPadScriptSite::GetPCounter(long lWhich, DWORD * plCounter)
        { return PadDoc()->GetPCounter(lWhich, plCounter); }
HRESULT CPadScriptSite::GetPTime(DWORD * plTime)
        { return PadDoc()->GetPTime(plTime); }
HRESULT CPadScriptSite::Repaint()
        { return PadDoc()->Repaint(); }
HRESULT CPadScriptSite::alert(BSTR str)
        { return PadDoc()->alert(str); }
HRESULT CPadScriptSite::IsDebugPad(VARIANT_BOOL *pfDebugPad)
        { return PadDoc()->IsDebugPad(pfDebugPad); }        
HRESULT CPadScriptSite::GetPCounterString(VARIANT *pValue)
        { return PadDoc()->GetPCounterString(pValue); }
HRESULT CPadScriptSite::GetPrimaryElement( int* piPrimaryElement )
        { return PadDoc()->GetPrimaryElement( piPrimaryElement ) ; }
HRESULT CPadScriptSite::LinesInElement(IDispatch *pDispElement, int *pValue)
        { return PadDoc()->LinesInElement(pDispElement, pValue); }
HRESULT CPadScriptSite::FontsOnLine(IDispatch *pDispElement, int iLine, BSTR *pbstrFonts)
        { return PadDoc()->FontsOnLine(pDispElement, iLine, pbstrFonts); }
HRESULT CPadScriptSite::IsDebugTrident(VARIANT_BOOL *pfDebugTrident)
        { return PadDoc()->IsDebugTrident(pfDebugTrident); }        
HRESULT CPadScriptSite::IsWin2k(VARIANT_BOOL *pfWin2k)
        { return PadDoc()->IsWin2k(pfWin2k); }        
HRESULT CPadScriptSite::IsWhistler(VARIANT_BOOL *pfWhistler)
        { return PadDoc()->IsWhistler(pfWhistler); }        
HRESULT CPadScriptSite::ComputerName(BSTR *pbstrComputerName)
        { return PadDoc()->ComputerName(pbstrComputerName); }        
HRESULT CPadScriptSite::GetPixel(int X, int Y, int *piColor)
        { return PadDoc()->GetPixel(X, Y, piColor); }
HRESULT CPadScriptSite::GetUnsecureWindow(IDispatch * pWindowIn, IDispatch **ppWndDisp)
        { return PadDoc()->GetUnsecureWindow(pWindowIn, ppWndDisp); }
HRESULT CPadScriptSite::EnableUIUpdate( VARIANT_BOOL fEnable )
        { return PadDoc()->EnableUIUpdate( fEnable ); }
HRESULT CPadScriptSite::get_BuildId(BSTR * pbstrBuildId)
            { return PadDoc()->get_BuildId(pbstrBuildId); }
HRESULT CPadScriptSite::IsUsingBckgrnRecalc(VARIANT_BOOL *pfUsingBckgrnRecalc)
        { return PadDoc()->IsUsingBckgrnRecalc(pfUsingBckgrnRecalc); }        
HRESULT CPadScriptSite::IsEncodingAutoSelect(VARIANT_BOOL *pfEncodingAutoSelect)
        { return PadDoc()->IsEncodingAutoSelect(pfEncodingAutoSelect); }        
HRESULT CPadScriptSite::EnableEncodingAutoSelect(VARIANT_BOOL fEnable)
        { return PadDoc()->EnableEncodingAutoSelect(fEnable); }        
HRESULT CPadScriptSite::IsUsingTableIncRecalc(VARIANT_BOOL *pfUsingTableIncRecalc)
        { return PadDoc()->IsUsingTableIncRecalc(pfUsingTableIncRecalc); }        
HRESULT CPadScriptSite::GetPadEnumPrivacyRecords(IDispatch** ppEnumPrivacyRecords)
        { return PadDoc()->GetPadEnumPrivacyRecords(ppEnumPrivacyRecords); }
HRESULT CPadScriptSite::PadCommand(WORD widm)
        { return PadDoc()->PadCommand(widm); }

HRESULT 
CPadScriptSite::QueryStatus(
			        const GUID * pguidCmdGroup,
			        ULONG cCmds,
			        MSOCMD rgCmds[],
			        MSOCMDTEXT * pcmdtext)
{
    return S_OK;
}

HRESULT 
CPadScriptSite::Exec(
			const GUID * pguidCmdGroup,
			DWORD nCmdID,
			DWORD nCmdexecopt,
			VARIANTARG * pvarargIn,
			VARIANTARG * pvarargOut)
{
    HRESULT                     hr = S_OK;
    IDispatch *                 pDisp = NULL;
    IInternetSecurityManager *  pSecMgr = NULL;
    CVariant                    VarUrl;
    TCHAR                       ach[4096];  // pdlUrlLen
    DWORD                       dwSize;
    BYTE                        abSID[MAX_SIZE_SECURITY_ID];
    DWORD                       cbSID = ARRAY_SIZE(abSID);

    if (!pguidCmdGroup || *pguidCmdGroup != CGID_ScriptSite)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    switch (nCmdID)
    {
    case CMDID_SCRIPTSITE_SID:
    case CMDID_SCRIPTSITE_URL:
        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT(pvarargOut) = VT_BSTR;

        hr = THR(_pDoc->_pObject->QueryInterface(IID_IDispatch, (void **) &pDisp));
        if (hr)
            goto Cleanup;

        // call invoke DISPID_SECURITYCTX off pDisp to get SID
        hr = THR_NOTRACE(GetDispProp(
                pDisp,
                DISPID_SECURITYCTX,
                LOCALE_SYSTEM_DEFAULT,
                &VarUrl,
                NULL,
                FALSE));
        if (hr) 
            goto Cleanup;

        if (V_VT(&VarUrl) != VT_BSTR || !V_BSTR(&VarUrl))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(CoInternetParseUrl(
                V_BSTR(&VarUrl), 
                PARSE_ENCODE, 
                0, 
                ach, 
                ARRAY_SIZE(ach), 
                &dwSize, 
                0));
        if (hr)
            goto Cleanup;

        if (nCmdID == CMDID_SCRIPTSITE_URL)
        {
            hr = FormsAllocStringLen(ach, dwSize, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;
        }
        else    // nCmdID == CMDID_SCRIPTSITE_SID
        {
            hr = THR(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0));
            if (hr)
                goto Cleanup;

            memset(abSID, 0, cbSID);

            hr = THR(pSecMgr->GetSecurityId(
                    ach, 
                    abSID, 
                    &cbSID,
                    0));
            if (hr)
                goto Cleanup;

            hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;

            memcpy(V_BSTR(pvarargOut), abSID, MAX_SIZE_SECURITY_ID);
        }

        break;

    case CMDID_SCRIPTSITE_HTMLDLGTRUST:
        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = TRUE;      // Trusted
            break;
        }

    case CMDID_SCRIPTSITE_SECSTATE:
        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = (long) 2;    // SSL_SECURITY_SECURE;
            break;
        }

    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
        break;

    }

Cleanup:
    ReleaseInterface(pDisp);
    ReleaseInterface(pSecMgr);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padurl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       padurl.cxx
//
//  Contents:   Ask the user for a URL.
//
//-------------------------------------------------------------------------

#include "padhead.hxx"

static INT_PTR CALLBACK
GetURLProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PADTHREADSTATE * pts = GetThreadState();

    switch (msg)
    {
    case WM_INITDIALOG:
        if (pts->achURL[0] == 0)
        {
#if !defined(WINCE)
            if (!GetEnvironmentVariable(_T("PAD_DEFAULTURL"), pts->achURL, INTERNET_MAX_URL_LENGTH))
            {
#endif
#if DBG==1
                _tcscpy(pts->achURL, TEXT("http://trident"));
#else
                _tcscpy(pts->achURL, TEXT("http://www.microsoft.com"));
#endif
#if !defined(WINCE)
            }
#endif
        }
        SetDlgItemText(hwnd, IDI_ADDRESS, pts->achURL);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDOK:
                GetDlgItemText(hwnd, IDI_ADDRESS, pts->achURL, ARRAY_SIZE(pts->achURL));
                // Fall through.
            case IDCANCEL:
                EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                return TRUE;
        }
        // Fall through

    default:
        return FALSE;
    }
}

// el cheapo file path recognition logic copied from shdocvw
BOOL PathIsFilePath(TCHAR *pchPath)
{
    if (pchPath[0]==_T('\\') || pchPath[0] && pchPath[1]==_T(':'))
        return TRUE;

    if (_tcsnipre(_T("file:"), 5, pchPath, -1))
        return TRUE;

    return FALSE;
}

BOOL
GetURL(HWND hwnd, TCHAR *pchURL, int cch)
{
    if (DialogBoxParam(
        g_hInstResource,
        MAKEINTRESOURCE(IDR_OPEN_URL),
        hwnd,
        &GetURLProc,
        NULL) == IDOK)
    {
        PADTHREADSTATE * pts = GetThreadState();
        ULONG cchUlong = cch;

        if (!PathIsFilePath(pts->achURL))
            return InternetCanonicalizeUrl(pts->achURL, pchURL, &cchUlong, 0);

        if (_tcsnipre(_T("file:"), 5, pts->achURL, -1))
        {
            TCHAR *pch = pts->achURL+5;

            if (_tcsnipre(_T("//"), 2, pch, -1))
                pch += 2;

            _tcsncpy(pchURL, pch, cch);
        }
        else
            _tcsncpy(pchURL, pts->achURL, cch);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\padws.cxx ===
//+------------------------------------------------------------------------
//  
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       Working set test infrastructure
//  
//-------------------------------------------------------------------------

#include "padhead.hxx"

HRESULT CPadDoc::WsClear()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(DbgExWsClear(hProcess));
}

HRESULT CPadDoc::WsTakeSnapshot()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

	RRETURN(DbgExWsTakeSnapshot(hProcess));
}

HRESULT CPadDoc::get_WsModule(long row, BSTR *pbstrModule)
{
    *pbstrModule = SysAllocString(DbgExWsGetModule(row));
    return S_OK;
}

HRESULT CPadDoc::get_WsSection(long row, BSTR *pbstrSection)
{
    *pbstrSection = SysAllocString(DbgExWsGetSection(row));
    return S_OK;
}

HRESULT CPadDoc::get_WsSize(long row, long *plWsSize)
{
    *plWsSize = DbgExWsSize(row);
    return S_OK;
}

HRESULT CPadDoc::get_WsCount(long *plCount)
{
    *plCount = DbgExWsCount();
    return S_OK;
}

HRESULT CPadDoc::get_WsTotal(long *plTotal)
{
    *plTotal = DbgExWsTotal();
    return S_OK;
}

HRESULT CPadDoc::WsStartDelta()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(DbgExWsStartDelta(hProcess));
}

HRESULT CPadDoc::WsEndDelta(long *pnPageFaults)
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        RRETURN(E_FAIL);
    }

    *pnPageFaults = DbgExWsEndDelta(hProcess);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\pad_wrap.c ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:   Wrap the midl generated pad_i.c so we don't get lots of 
//          level 4 warnings from the system headers
//
//-------------------------------------------------------------------------

#define WIN32_LEAN_AND_MEAN
#pragma warning(disable:4201)   // nameless struct/union

#include <pad_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\tvdlg.h ===
////////////////////////////////////////////////////////////////////////////
//
//      TVDLG.H
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////

#ifndef __TVDLG__H__
#define __TVDLG__H__


enum { iEID, iDispName, iSubfldrs, nhtProps};
static SizedSPropTagArray(nhtProps, spthtProps) =
{ nhtProps,
    {   PR_ENTRYID,
        PR_DISPLAY_NAME_A,
        PR_SUBFOLDERS
    }
};  

#define Align4(_cb) (((_cb) + 3) & ~3)

extern LPTSTR g_szNoFolderName;
extern LPSTR g_szAllStoresA;

class CTVNodeFactory;
class CChsFldDlg;


/////////////////////////////////////////////////////////////////////////
// CTVNode

class CTVNode;
typedef CTVNode * LPTVNODE;

class CTVNode
{

friend CTVNodeFactory;
friend HTREEITEM HtiFindChild(HWND hwTreeCtl, HTREEITEM hti, ULONG cb,
                LPENTRYID pbEID, CChsFldDlg *pCFDlg, LPTVNODE *ppNode);


public:
    LPTSTR GetName(void);
    HRESULT HrExpand(CChsFldDlg * pCFDlg);
    HRESULT HrGetFolder(CChsFldDlg * pCFDlg, LPMAPIFOLDER * ppfld,
                            LPMDB *ppmdb);

    void SetHandle(HTREEITEM hItem) { _htiMe = hItem;}
    void SetKidsLoaded(BOOL fLoaded) { _fKidsLoaded = fLoaded;}

    HRESULT HrNewFolder(CChsFldDlg * pCFDlg, LPTSTR szFldName);

    static LPVOID operator new( size_t cb );
    static VOID   operator delete( LPVOID pv );

    void Write(BOOL fWrite, LONG iLevel, LPBYTE * ppb);
    
    ~CTVNode();

private:
    
    //can only be created in CTVNodeFactory::HrCreateNode
    CTVNode(LPSPropValue pvals, ULONG cprops, LPMDB pmdb);

    HRESULT HrOpenMDB(CChsFldDlg * pCFDlg);
    HRESULT HrOpenFolder(CChsFldDlg * pCFDlg);
    
    HTREEITEM       _htiMe;
    LPSPropValue    _pval;
    BOOL            _fKidsLoaded;
    LPMAPIFOLDER    _pfld;
    CTVNode         *_pNext;
    LPMDB           _pmdb;
};


////////////////////////////////////////////////////////////////////////
// CTVNodeFactory

class CTVNodeFactory
{
public:
    HRESULT HrCreateNode(LPSPropValue pval, ULONG cVals, LPMDB pmdb,
                            LPTVNODE * pptvnode);

    CTVNodeFactory();
    ~CTVNodeFactory();

private:
    void Insert(CTVNode * ptvnode);

    LPTVNODE    _pHead;
};


////////////////////////////////////////////////////////////////////////
// CChsFldDlg

class CChsFldDlg
{
public:
    HRESULT HrPick(LPCTSTR lpTemplateName, HWND hWnd,
                DLGPROC pfnDlgProc, LPMAPIFOLDER * ppfld, LPMDB *ppmdb);
    HRESULT HrInitTree(HWND hDlg, HWND hwTreeCtl);
    HRESULT HrLoadRoots(void);
    HRESULT HrInsertRoot(LPSPropValue pval);
    BOOL    IsTreeRoot(HTREEITEM hti) { return (hti == _hiRoot); }

    int     IndAllStores(void)  { return _iIconAllStores; }
    int     IndRootFld(void)    { return _iIconRootFld; }
    int     IndOpenFld(void)    { return _iIconOpenFld; }
    int     IndClsdFld(void)    { return _iIconClsdFld; }
    HWND    hwDialog(void)      { return _hDlg; }
    HWND    hwTreeCtl(void)     { return _hwTreeCtl; }

    LPMAPISESSION   Session(void) { return _pses; }

    
    HINSTANCE hInst(void)   { return _hInst; }

    HRESULT HrCreateNode(LPSPropValue pval, ULONG cvals, LPMDB pmdb,
                            LPTVNODE * ppNode)
        { return _NodeFactory.HrCreateNode(pval, cvals, pmdb, ppNode);}

    void    SetFolder(LPMAPIFOLDER plfd, LPMDB pmdb);
    void    SetError(HRESULT hr)    { _hr = hr;}

    HRESULT HrSaveTreeState(void);
    HRESULT HrRestoreTreeState(void);

    CChsFldDlg(LPMAPISESSION pses, HINSTANCE hInst, ULONG * pcb, LPBYTE * ppb);
    ~CChsFldDlg();

private:

    HRESULT HrSaveTreeStateEx(BOOL fWrite, ULONG * pcb, LPBYTE * ppb);
    HRESULT HrRestoreTreeState(ULONG cb, LPBYTE pb);
    
    LPMAPISESSION   _pses;
    LPMAPIFOLDER    _pfld;
    LPMDB           _pmdb;
    HRESULT         _hr;
    HTREEITEM       _hiRoot;
    HINSTANCE       _hInst;
    HWND            _hDlg;
    HWND            _hwTreeCtl;

    HIMAGELIST      _hIml;
    int             _iIconAllStores;
    int             _iIconRootFld;
    int             _iIconOpenFld;
    int             _iIconClsdFld;
    
    ULONG           *_pcbState;
    LPBYTE          *_ppbState;
    
    CTVNodeFactory  _NodeFactory;
    
};


HTREEITEM AddOneItem( HTREEITEM hParent, HTREEITEM hInsAfter, 
    int iImage, int iImageSel, HWND hwndTree, LPTVNODE pNode, int cKids);


#endif //__TVDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\scripter.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       script.cxx
//
//  Contents:   Implementation of script recorder
//
//  History:    03-22-99 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "padhead.hxx"

#ifndef X_SCRIPTER_HXX_
#define X_SCRIPTER_HXX_
#include "scripter.hxx"
#endif

//
// Externs
//
MtDefine(CScriptRecorder, EditCommand, "CScriptRecorder");
MtDefine(CDummyScriptRecorder, EditCommand, "CDummyScriptRecorder");

extern HINSTANCE     g_hInstCore;         // Instance of dll

////////////////////////////////////////////////////////////////////////////////
// CScriptRecorder
////////////////////////////////////////////////////////////////////////////////

CScriptRecorder::CScriptRecorder(CPadDoc *pPadDoc)
{
    _pPadDoc = pPadDoc;
    _hStream = NULL;
}

CScriptRecorder::~CScriptRecorder()
{
    IGNORE_HR( Flush() );
    Output(_T("}\r\n"));
    CloseHandle(_hStream);
}

HRESULT
CScriptRecorder::Init(BSTR bstrFileName)
{
    HRESULT     hr;
    CStr        strPreScript;
    HRSRC       hRsrc;
    HGLOBAL     hGlob;
    char        *szBase;
    DWORD       nbw = 0;
    INT         rc;

    hRsrc = FindResource(g_hInstCore, L"base.js", RT_HTML);
    if (!hRsrc)
        return E_UNEXPECTED;

    hGlob = LoadResource(g_hInstCore, hRsrc);
    szBase = (char*)LockResource(hGlob);
    if (szBase == NULL)
        return E_UNEXPECTED;
    
    _hStream = CreateFile(
            _T("c:\\ee.js"),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (!_hStream)
        return E_FAIL;

    rc = ::WriteFile(_hStream, szBase, ::SizeofResource(g_hInstCore, hRsrc), &nbw, NULL);
    if (!rc)
        return E_UNEXPECTED;    

    IFC( strPreScript.Append(_T("var g_fileName = \'")) );
    IFC( GetPadDoc()->AppendQuotedString(strPreScript, bstrFileName, SysStringLen(bstrFileName)) );
    IFC( strPreScript.Append(_T("\';\r\n\r\n")) );
    IFC( strPreScript.Append(_T("function Test()\r\n{\r\n")) );

    IFC( Output(strPreScript) );
    
 Cleanup:        
    RRETURN(hr);
}


HRESULT
CScriptRecorder::WriteFile(TCHAR *szBuffer, LONG cLength)
{
    const LONG  cBufferSize = 1024;
    char        szAnsiBuffer[cBufferSize+1]; 
    LONG        cchLen;
    DWORD       nbw = 0;
    INT         rc = 0;     

    if (cLength < cBufferSize)
    {
        cchLen = WideCharToMultiByte(
            CP_ACP, 0, szBuffer, cLength,
            szAnsiBuffer, ARRAY_SIZE(szAnsiBuffer), NULL, NULL );

        szAnsiBuffer[cchLen] = 0;

        rc = ::WriteFile(_hStream, szAnsiBuffer, cchLen, &nbw, NULL);
    }
    else
    {
        char *szLargeBuffer = new char[cLength + 1];

        cchLen = WideCharToMultiByte(
            CP_ACP, 0, szBuffer, cLength,
            szLargeBuffer, cLength, NULL, NULL );

        szLargeBuffer[cchLen] = 0;

        rc = ::WriteFile(_hStream, szLargeBuffer, cchLen, &nbw, NULL);

        delete [] szLargeBuffer;
    }

    if (!rc)
        return E_UNEXPECTED;

    return S_OK; // TODO: return error for WriteFile status
}

HRESULT 
CScriptRecorder::OutputLinePrefix()
{
    HRESULT hr;

    hr = THR(Output(_T("    ")));

    RRETURN(hr);
}

HRESULT
CScriptRecorder::Output(CStr &cstr)
{
    HRESULT hr;

    hr = THR(WriteFile(cstr, cstr.Length()));

    RRETURN(hr);
}

HRESULT
CScriptRecorder::Output(TCHAR *szOutput)
{
    HRESULT hr;

    hr = THR(WriteFile(szOutput, _tcslen(szOutput)));

    RRETURN(hr);
}

HRESULT 
CScriptRecorder::Flush(BOOL fDoEvents)
{
    HRESULT hr = S_OK;
    
    if (_strKeyStrokes.Length() > 0)
    {
        IFC( OutputLinePrefix() );
        
        if (fDoEvents)        
        {
            IFC( Output(_T("SendKeysDE(\"")) )
        }
        else
        {
            IFC( Output(_T("SendKeys(\"")) );
        }
        
        IFC( Output(_strKeyStrokes) );
        IFC( Output(_T("\");\r\n")) );
        
        _strKeyStrokes.Free();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT 
CScriptRecorder::RegisterChar(DWORD dwKey, KEYSTATE ks)
{    
    HRESULT     hr = S_OK;
    const UINT  cMaxSendKeyLen = 50;
    CStr        strKeyStroke;
    
    // Add keystroke
    if (dwKey > ' ' && dwKey < 128)
    {
        TCHAR szBuf[2];
        
        // Wrapping of sendkey statements to make the generated script more readable.
        if (_strKeyStrokes.Length() > cMaxSendKeyLen)
        {
            Flush(FALSE /* Do Events */);
        }

        // TODO: fix range above [ashrafm]
        szBuf[0] = dwKey;
        szBuf[1] = 0;

        IFC( GetPadDoc()->AppendQuotedString(_strKeyStrokes, szBuf, 1) );
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT 
CScriptRecorder::RegisterKeyDown(DWORD dwKey, KEYSTATE ks)
{    
    HRESULT     hr = S_OK;
    const UINT  cMaxSendKeyLen = 50;
    CStr        strKeyStroke;

    // Add keystroke
    switch (dwKey)
    {
        case VK_RETURN:
            IFC( strKeyStroke.Append(_T("{enter}")) );
            break;

        case VK_BACK:
            IFC( strKeyStroke.Append(_T("{bs}")) );
            break;

        case VK_SPACE:
            IFC( strKeyStroke.Append(_T(" ")) );
            break;

        case VK_TAB:
            IFC( strKeyStroke.Append(_T("{tab}")) );
            break;
    
        case VK_LEFT:
            IFC( strKeyStroke.Append(_T("{left}")) );
            break;

        case VK_RIGHT:
            IFC( strKeyStroke.Append(_T("{right}")) );
            break;

        case VK_UP:
            IFC( strKeyStroke.Append(_T("{up}")) );
            break;

        case VK_DOWN:
            IFC( strKeyStroke.Append(_T("{down}")) );
            break;
        
        case VK_HOME:
            IFC( strKeyStroke.Append(_T("{home}")) );
            break;

        case VK_END:
            IFC( strKeyStroke.Append(_T("{end}")) );
            break;

        case VK_ESCAPE:
            IFC( strKeyStroke.Append(_T("{esc}")) );
            break;            

        case VK_NEXT:
            IFC( strKeyStroke.Append(_T("{pgdn}")) );
            break;            

        case VK_PRIOR:
            IFC( strKeyStroke.Append(_T("{pgup}")) );
            break;            
    }

    if (strKeyStroke.Length() > 0)
    {
        // Wrapping of sendkey statements to make the generated script more readable.
        if (_strKeyStrokes.Length() > cMaxSendKeyLen)
        {
            Flush(FALSE /* Do Events */);
        }

        // Add modifiers
        if (ks & KEYSTATE_Ctrl)
            IFC( _strKeyStrokes.Append(_T("{ctrl}+")) );

        if (ks & KEYSTATE_Shift)
            IFC( _strKeyStrokes.Append(_T("{shift}+")) );

        IFC( GetPadDoc()->AppendQuotedString(_strKeyStrokes, strKeyStroke, strKeyStroke.Length()) );
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CScriptRecorder::ShouldQuote(VARENUM vt)
{
    switch (vt)
    {
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_I8:
        case VT_UI8:
        case VT_INT:
        case VT_UINT:
            return FALSE;
    }

    return TRUE;
}
    
HRESULT 
CScriptRecorder::RegisterCommand(DWORD    cmdId,     
                                 DWORD    nCmdexecopt,
                                 VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;
    VARIANT varCmdId;
    VARIANT varCmdIdBSTR;
    VARIANT varParam;
    CStr    strParam;

    // Check for some commands that should not be scripted
    switch (cmdId)
    {
        case IDM_EDITSOURCE:
        case IDM_BROWSEMODE:
        case IDM_EDITMODE:
        case IDM_VIEWSOURCE:
        case IDM_GETBLOCKFMTS:
        case IDM_PARSECOMPLETE:
        case IDM_HTMLEDITMODE:
        case IDM_CONTEXT:
        case IDM_HWND:
        case IDM_SIZETOCONTROLWIDTH:
        case IDM_SIZETOCONTROLHEIGHT:
            goto Cleanup;        
            break;

        case IDM_HYPERLINK:
        case IDM_IMAGE:
        case IDM_FONT:
            // don't script dialog commands
            if (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER)
                goto Cleanup;
            break;
    };

    

    VariantInit(&varCmdId);
    VariantInit(&varCmdIdBSTR);
    VariantInit(&varParam);
    
    IFC( Flush() );

    // Change cmdId to appropriate string
    V_VT(&varCmdId) = VT_I4;
    V_I4(&varCmdId) = cmdId;
    IFC( VariantChangeType(&varCmdIdBSTR, &varCmdId, 0, VT_BSTR) );

    // Change param type to string and output as such
    if (pvarargIn)
    {
        IFC( VariantChangeType(&varParam, pvarargIn, 0, VT_BSTR) );
        IFC( GetPadDoc()->AppendQuotedString(strParam, V_BSTR(&varParam), SysStringLen(V_BSTR(&varParam))) );
    }
    else
    {
        IFC( strParam.Append(L"null") );
    }

    // Output exec command
    IFC( OutputLinePrefix() );
    IFC( Output(L"ExecuteCommand(") );
    IFC( Output(V_BSTR(&varCmdIdBSTR)) );
    IFC( Output(L", ") );
    
    if (pvarargIn && ShouldQuote(VARENUM(V_VT(pvarargIn))))
        IFC( Output(L"\"") );
        
    IFC( Output(strParam) );
    
    if (pvarargIn && ShouldQuote(VARENUM(V_VT(pvarargIn))))
        IFC( Output(L"\"") );
        
    IFC( Output(L");\r\n") );
    
Cleanup:
    VariantClear(&varCmdId);
    VariantClear(&varParam);

    RRETURN(hr);
}
                            
HRESULT
CScriptRecorder::VerifyHTML(TestScope ts)
{
    HRESULT         hr;
    CStr            str;
    BSTR            bstrElement      = NULL;
    BSTR            bstrHTML         = NULL;
    IHTMLDocument2  *pDoc            = NULL;
    IHTMLElement    *pElement        = NULL;
    IDispatch       *pdispDoc        = NULL;
    IMarkupServices *pMarkupServices = NULL;

    IFC( GetPadDoc()->GetMarkupServices(&pMarkupServices) );

    //
    // Get test element
    //
    
    switch (ts)
    {
        case TS_Body:
        {
            IFC( GetPadDoc()->get_Document(&pdispDoc) );
            IFC( pdispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );
            IFC( pDoc->get_body(&pElement) );            
            bstrElement = SysAllocString(L"document.body");
            break;
        }
            
        case TS_CurrentElement:
        {
            ELEMENT_TAG_ID tagId;
            
            IFC( GetPadDoc()->CurrentBlockElement(pMarkupServices, &pElement) );            
            if (pElement == NULL)
                return E_FAIL;

            IFC( pMarkupServices->GetElementTagId(pElement, &tagId) );
            if (tagId == TAGID_BODY)
                return E_FAIL;
            
            bstrElement = SysAllocString(L"CurrentBlockElement()");
            break;
        }

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    IFC( GetPadDoc()->InnerHTML(pMarkupServices, pElement, &bstrHTML) );
    
    //
    // Generate HTML
    //
    IFC( Flush() );

    IFC( OutputLinePrefix() );
    
    IFC( Output(L"VerifyHTML(InnerHTML(") );
    IFC( Output(bstrElement) );
    IFC( Output(L"), \"") );
    
    IFC( GetPadDoc()->AppendQuotedString(str, bstrHTML, SysStringLen(bstrHTML)) );
    IFC( Output(str) );

    IFC( Output(L"\");\r\n") );

Cleanup:
    SysFreeString(bstrElement);
    SysFreeString(bstrHTML);
    ReleaseInterface(pDoc);
    ReleaseInterface(pElement);
    ReleaseInterface(pdispDoc);
    ReleaseInterface(pMarkupServices);
    
    RRETURN(hr);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\privacy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       privacy.cxx
//
//  Contents:   Definition of classes to expose privacy list to pad
//
//----------------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_PRIVACY_H_
#define X_PRIVACY_H_
#include "privacy.h"
#endif

#undef ASSERT

CPadEnumPrivacyRecords::CPadEnumPrivacyRecords(IEnumPrivacyRecords * pIEPR)
    :_ulRefs(1)
{
    Assert(pIEPR);
    _pIEPR = pIEPR;
    _pIEPR->AddRef();
}

CPadEnumPrivacyRecords::~CPadEnumPrivacyRecords()
{
    _pIEPR->Release();
}

HRESULT
CPadEnumPrivacyRecords::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG
CPadEnumPrivacyRecords::AddRef()
{
    return ++_ulRefs;
}

ULONG 
CPadEnumPrivacyRecords::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }
    
    return _ulRefs;
}

HRESULT
CPadEnumPrivacyRecords::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return NOERROR;
}
HRESULT
CPadEnumPrivacyRecords::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
    *ppTInfo = NULL;
    return ResultFromScode(E_NOTIMPL);
}

#define   DISPID_CPrivacyList_size                           1000
#define   DISPID_CPrivacyList_next                           1001
#define   DISPID_CPrivacyList_reset                          1002
#define   DISPID_CPrivacyList_privacyimpacted                1003
#define   DISPID_CPrivacyList_url                            1004
#define   DISPID_CPrivacyList_cookiestate                    1005
#define   DISPID_CPrivacyList_policyref                      1006
#define   DISPID_CPrivacyList_privacyflags                   1007

HRESULT
CPadEnumPrivacyRecords::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    
    for (; cNames > 0; --cNames)
    {
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("size")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_size;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("next")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_next;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("reset")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_reset;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("privacyimpacted")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_privacyimpacted;
            hr = NO_ERROR;
        }
        else
        {
            hr = ResultFromScode(DISP_E_UNKNOWNNAME);
            break;
        }
    }

    RRETURN(hr);
}
HRESULT
CPadEnumPrivacyRecords::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT             hr          = ResultFromScode(DISPID_UNKNOWN);
    CPadPrivacyRecord * pPPR        = NULL;    

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    if (NULL == pVarResult)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    VariantInit(pVarResult);
    
    switch(dispIdMember)
    {
    case DISPID_CPrivacyList_size:
        ULONG ulSize;
        hr = _pIEPR->GetSize(&ulSize);
        if (hr)
            RRETURN(hr);
        V_VT(pVarResult) = VT_I4;
        V_I4(pVarResult) = (int)ulSize;
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_next:
        {
        BSTR  bstrUrl     = NULL;     
        LONG  cookieState = 0;
        BSTR  bstrPolicyRef = NULL;
        DWORD dwFlags = 0;

        hr = _pIEPR->Next(&bstrUrl, &bstrPolicyRef, &cookieState, &dwFlags);
        if (hr)
            RRETURN(hr);        
        pPPR = new CPadPrivacyRecord(bstrUrl, cookieState, bstrPolicyRef, dwFlags);
        if (!pPPR)
        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
        V_VT(pVarResult) = VT_DISPATCH;
        V_DISPATCH(pVarResult) = (IDispatch*)pPPR;
        hr = NOERROR;
        }
        break;

    case DISPID_CPrivacyList_reset:
        V_VT(pVarResult) = VT_EMPTY;
        _pIEPR->Reset();
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_privacyimpacted:
        BOOL bImpacted;
        hr = _pIEPR->GetPrivacyImpacted(&bImpacted);
        if (hr)
            RRETURN(hr);
        V_VT(pVarResult) = VT_BOOL;
        V_BOOL(pVarResult) = (int)bImpacted;
        hr = NOERROR;
        break;

    }

    return hr;
}

HRESULT
CPadPrivacyRecord::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG
CPadPrivacyRecord::AddRef(void)
{
    return ++_ulRefs;
}

ULONG
CPadPrivacyRecord::Release(void)
{
    --_ulRefs;
    if (!_ulRefs)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

HRESULT
CPadPrivacyRecord::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return NOERROR;
}
 
HRESULT
CPadPrivacyRecord::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
    *ppTInfo = NULL;
    return ResultFromScode(E_NOTIMPL);
}

HRESULT
CPadPrivacyRecord::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    
    for (; cNames > 0; --cNames)
    {
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("url")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_url;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("cookiestate")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_cookiestate;
            hr = NO_ERROR;
        }
        if (0 == lstrcmpi(rgszNames[cNames], OLESTR("policyref")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_policyref;
            hr = NO_ERROR;
        }
        else if (0 == lstrcmpi(rgszNames[cNames], OLESTR("privacyflags")))
        {
            rgDispId[cNames] = DISPID_CPrivacyList_privacyflags;
            hr = NO_ERROR;
        }
        else
        {
            hr = ResultFromScode(DISP_E_UNKNOWNNAME);
            break;
        }
    }

    RRETURN(hr);
}

HRESULT
CPadPrivacyRecord::Invoke(DISPID dispIdMember, 
                          REFIID riid, 
                          LCID lcid, 
                          WORD wFlags, 
                          DISPPARAMS *pDispParams, 
                          VARIANT *pVarResult, 
                          EXCEPINFO *pExcepInfo, 
                          UINT *puArgErr)
{
    HRESULT hr            = ResultFromScode(DISPID_UNKNOWN);
    BSTR    bstrUrl       = NULL;
    BSTR    bstrPolicyRef = NULL;
    
    if (riid != IID_NULL)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    if (NULL == pVarResult)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    VariantInit(pVarResult);
    
    switch(dispIdMember)
    {
    case DISPID_CPrivacyList_url:
        hr = FormsAllocString((LPCWSTR)_bstrUrl, &bstrUrl);        
        if (hr)
            break;
        V_VT(pVarResult) = VT_BSTR;
        V_BSTR(pVarResult) = bstrUrl;
        hr = NOERROR;
        break;

    case DISPID_CPrivacyList_cookiestate:
        V_VT(pVarResult) = VT_I4;
        V_I4(pVarResult) = (int)_cookieState;
        hr = NOERROR;
        break;

     case DISPID_CPrivacyList_policyref:
        hr = FormsAllocString((LPCWSTR)_bstrPolicyRef, &bstrPolicyRef);
        if (hr)
            break;
        V_VT(pVarResult) = VT_BSTR;
        V_BSTR(pVarResult) = bstrPolicyRef;
        hr = NOERROR;
        break;

     case DISPID_CPrivacyList_privacyflags:
        V_VT(pVarResult) = VT_UI4;
        V_UI4(pVarResult) = (int)_dwFlags;
        hr = NOERROR;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\tvnode.cpp ===
/////////////////////////////////////
//
//  TVNODE.CPP
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
/////////////////////////////////////


#include <padhead.hxx>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>
#endif

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_TVDLG_H_
#define X_TVDLG_H_
#include "tvdlg.h"
#endif

LPTSTR g_szNoFolderName = TEXT("<No Name>");

//
//  CTVNode::CTVNode
//
CTVNode::CTVNode(LPSPropValue pval, ULONG cProps, LPMDB pmdb)
{
    Assert(cProps == nhtProps);
    Assert(pval);

    _pval = pval;

    _htiMe = NULL;
        
    _fKidsLoaded = FALSE;

    _pfld = NULL;

    _pNext = NULL;

    _pmdb = pmdb;
    if(pmdb)
        pmdb->AddRef();

}

//
//  CTVNode::~CTVNode
//
CTVNode::~CTVNode()
{
    MAPIFreeBuffer(_pval);
    ReleaseInterface(_pfld);
    ReleaseInterface(_pmdb);
}

//
//  CTVNode::GetName
//
LPTSTR CTVNode::GetName(void)
{
    static TCHAR achw[256];

    if(_pval[iDispName].ulPropTag == PR_DISPLAY_NAME_A)
    {
        MultiByteToWideChar(CP_ACP, 0, _pval[iDispName].Value.lpszA, -1, 
                            achw, sizeof(achw));
        return achw;
    }
    else
        return g_szNoFolderName;
}

//
//  CTVNode::HrExpand
//
//  Put all kids of the given folder in the tree control
//
HRESULT CTVNode::HrExpand(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    LPMAPITABLE ptblHier = NULL;
    LPSRowSet pRowSet = NULL;
    UINT ind;
    
    static SSortOrderSet sosName;

    sosName.cSorts = 1;
    sosName.cCategories = 0;
    sosName.cExpanded = 0;
    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME_A;
    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND;


    Assert(_htiMe);
    
    if(_fKidsLoaded || !_pval[iSubfldrs].Value.b)
        return hrSuccess;

    if(!_pmdb)
    {
    // this node corresponds to the top level of a message store which has
    // not been opend yet.
    // _pval[iEID] contains entry ID of the message store
    // 
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }
    
    Assert(_pmdb);     
    
    if(!_pfld)
    {
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pfld); 
    
    hr = _pfld->GetHierarchyTable(MAPI_DEFERRED_ERRORS, &ptblHier);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pfld);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }

    hr = HrQueryAllRows(ptblHier, (LPSPropTagArray)&spthtProps, NULL, &sosName,
                        0, &pRowSet);
    if(HR_FAILED(hr))
        goto err;

    if(0 == pRowSet->cRows)
    {
        _pval[iSubfldrs].Value.b = FALSE;
        goto err;
    }

    for(ind = 0; ind < pRowSet->cRows; ++ind)
    {
        LPSPropValue pval = pRowSet->aRow[ind].lpProps;
        
        Assert(pRowSet->aRow[ind].cValues == nhtProps);
        Assert(pval[iEID].ulPropTag == PR_ENTRYID);
        Assert(pval[iDispName].ulPropTag == PR_DISPLAY_NAME_A);
        Assert(pval[iSubfldrs].ulPropTag == PR_SUBFOLDERS);

        LPTVNODE pNode = NULL;

        hr = pCFDlg->HrCreateNode(pval, nhtProps, _pmdb, &pNode);
        if(hr)
            goto err;
    
        //this row will be freed in ~CTVNode
        pRowSet->aRow[ind].cValues = 0;
        pRowSet->aRow[ind].lpProps = NULL;

        HTREEITEM hItem;
        
        hItem = AddOneItem(_htiMe,  TVI_LAST, pCFDlg->IndClsdFld(),
                            pCFDlg->IndOpenFld(), pCFDlg->hwTreeCtl(), pNode,
                            pval[iSubfldrs].Value.b? 1: 0);
        if(!hItem)
        {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto err;
        }
            
    }

    _fKidsLoaded = TRUE;

err:
    ReleaseInterface(ptblHier);
    FreeProws(pRowSet);

    //DebugTraceResult(CTVNode::HrExpand, hr);
    return hr;
}

//
//  CTVNode::HrOpenMDB
//
HRESULT CTVNode::HrOpenMDB(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    LPMDB pmdb = NULL;
    LPSPropValue pvalIPM = NULL;
    ULONG ulObjType;
    
    Assert(_pval[iEID].ulPropTag == PR_ENTRYID);

    //DebugTrace("ChsFld: Openning Msg Store: %s\n", GetName());
    
    hr = pCFDlg->Session()->OpenMsgStore(0L, _pval[iEID].Value.bin.cb,
                                (LPENTRYID)_pval[iEID].Value.bin.lpb,
                                NULL, MAPI_BEST_ACCESS, &pmdb);
    if(hr) //Display warning messages too
    {
        g_LastError.SetLastError(hr, pCFDlg->Session());
        g_LastError.ShowError(pCFDlg->hwDialog());
    }

    if(HR_FAILED(hr))
        goto err;

    hr = HrGetOneProp(pmdb, PR_IPM_SUBTREE_ENTRYID, &pvalIPM);
    if(hr)
    {
        g_LastError.SetLastError(hr, pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());

        goto err;
    }

    hr = pmdb->OpenEntry(pvalIPM->Value.bin.cb,
                (LPENTRYID)pvalIPM->Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,
                 &ulObjType, (LPUNKNOWN *) &_pfld);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }
    
    Assert(MAPI_FOLDER == ulObjType);

/*  if(pvalIPM->Value.bin.cb > _pval[iEID].Value.bin.cb)
    {
        if(hr = MAPIAllocateMore(pvalIPM->Value.bin.cb,
                        _pval, (LPVOID *)&_pval[iEID].Value.bin.lpb))
            goto err;
                
    }

    CopyMemory(_pval[iEID].Value.bin.lpb, pvalIPM->Value.bin.lpb,
                                        pvalIPM->Value.bin.cb);
    _pval[iEID].Value.bin.cb = pvalIPM->Value.bin.cb;*/

err:
    if(HR_FAILED(hr))
    {
        ReleaseInterface(pmdb);
        ReleaseInterface(_pfld);
        _pfld = NULL;
    }
    else
    {
        _pmdb = pmdb;
        hr = hrSuccess; //don't return warnings
    }

    MAPIFreeBuffer(pvalIPM);

    //DebugTraceResult(CTVNode::HrOpenMDB, hr);
    return hr;
}

//
//  CTVNode::HrOpenFolder
//
HRESULT CTVNode::HrOpenFolder(CChsFldDlg * pCFDlg)
{
    HRESULT hr;
    ULONG ulObjType;

    Assert(_pval[iEID].ulPropTag == PR_ENTRYID);
    Assert(_pmdb);
    
    // MAPI_MODIFY flag affects only IMAPIProp interface of the object.
    // It does not guarantee permission to create subfolders.
    hr = _pmdb->OpenEntry(_pval[iEID].Value.bin.cb,
                (LPENTRYID)_pval[iEID].Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,
                 &ulObjType, (LPUNKNOWN *) &_pfld);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pmdb);
        g_LastError.ShowError(pCFDlg->hwDialog());
        
        goto err;
    }
    
    Assert(MAPI_FOLDER == ulObjType);
err:

    //DebugTraceResult(CTVNode::HrOpenFolder, hr);
    return hr;

}

//
//  CTVNode::HrGetFolder
//
//  return folder interface for the node
HRESULT CTVNode::HrGetFolder(CChsFldDlg * pCFDlg,
                            LPMAPIFOLDER * ppfld, LPMDB *ppmdb)
{
    HRESULT hr = hrSuccess;
    ULONG ulObjType = 0;

    
    Assert(pCFDlg);
    Assert(ppfld);
    Assert(ppmdb);


    if(!_pmdb)
    {
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }
    Assert(_pmdb);
    
    if(!_pfld)
    {
        Assert(!_fKidsLoaded);
        
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;

    }
    Assert(_pfld);

    *ppfld = _pfld;
    _pfld->AddRef();

    _pmdb->AddRef();
    *ppmdb = _pmdb;            

err:

    //DebugTraceResult(CTVNode::HrGetFolder, hr);
    return hr;
}


//
//  CTVNode::HrNewFolder
//
// Create subfolder szFldName
//
HRESULT CTVNode::HrNewFolder(CChsFldDlg * pCFDlg,
                                     LPTSTR szFldName)
{
    HRESULT hr;
    LPMAPIFOLDER pfldNew = NULL;
    LPTVNODE pNode = NULL;
    ULONG ulObjType = 0;
    LPSPropValue pval = NULL;
    HTREEITEM hItem;

    Assert(szFldName);
    Assert(pCFDlg);
    

    if(!_pmdb)
    {
        hr = HrOpenMDB(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pmdb);
    
    if(!_pfld)
    {
        hr = HrOpenFolder(pCFDlg);
        if(FAILED(hr))
            goto err;
    }

    Assert(_pmdb);
    
    hr = _pfld->CreateFolder(FOLDER_GENERIC, szFldName, NULL,
                                NULL, 0, &pfldNew);
    if(HR_FAILED(hr))
    {
        g_LastError.SetLastError(hr, _pfld);
        g_LastError.ShowError(pCFDlg->hwDialog());

        goto err;
    }

    if(!_pval[iSubfldrs].Value.b)
    {
        _pval[iSubfldrs].Value.b = TRUE;

        TV_ITEM tvI;

        tvI.hItem           = _htiMe;
        tvI.mask            = TVIF_CHILDREN;
        tvI.cChildren       = 1;

        TreeView_SetItem(pCFDlg->hwTreeCtl(), &tvI);
    }

    if(_fKidsLoaded)
    {
        hr = MAPIAllocateBuffer(sizeof(SPropValue)* nhtProps, (LPVOID *)&pval);
        if(hr)
            goto err;

        ZeroMemory(pval, sizeof(SPropValue) * nhtProps );

        pval[iEID].ulPropTag = PR_ENTRYID;
        pval[iDispName].ulPropTag = PR_DISPLAY_NAME_A;
        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;

        pval[iSubfldrs].Value.b = FALSE;

        int cb = lstrlen(szFldName) + 1;
        hr = MAPIAllocateMore(cb, pval, (LPVOID *)&pval[iDispName].Value.lpszA);
        if(hr) 
            goto err;

        WideCharToMultiByte(CP_ACP, 0, szFldName, -1, pval[iDispName].Value.lpszA, cb+1, NULL, NULL);

        hr = pCFDlg->HrCreateNode(pval, nhtProps, _pmdb, &pNode);
        if(HR_FAILED(hr))
            goto err;

        pval = NULL;

        hItem = AddOneItem(_htiMe,  TVI_SORT, pCFDlg->IndClsdFld(),
                        pCFDlg->IndOpenFld(), pCFDlg->hwTreeCtl(), pNode, 0);
        if(!hItem)
        {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto err;
        }
            
        pNode->_pfld = pfldNew;
        pfldNew = NULL;
        
    }

err:
    MAPIFreeBuffer(pval);
    ReleaseInterface(pfldNew);

    //DebugTraceResult(CTVNode::HrNewFolder, hr);
    return hr;
}

//
//  CTVNode::Write
//
// Used in CChsFldDlg::HrSaveTreeState
void CTVNode::Write(BOOL fWrite, LONG iLevel, LPBYTE * ppb)
{
    if(fWrite)
        *((LONG *)*ppb) = iLevel;
    *ppb += sizeof(LONG);

    if(iLevel != 0)
    {
        ULONG cb = _pval[iEID].Value.bin.cb;
        
        if(fWrite)
            *((ULONG *)*ppb) = cb;
        *ppb += sizeof(ULONG);

        if(fWrite)
            CopyMemory(*ppb, _pval[iEID].Value.bin.lpb, cb);
        *ppb += Align4(cb);
    }
    else
    {
        Assert(_pval[iDispName].Value.lpszA == g_szAllStoresA);
    }

}

LPVOID CTVNode::operator new( size_t cb )
{
    LPVOID pv;

    if ( MAPIAllocateBuffer( (ULONG)cb, &pv ) )
        pv = NULL;

    return pv; 
}

void CTVNode::operator delete( LPVOID pv )
{
    MAPIFreeBuffer( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\exe\padexe.cxx ===
#include <windows.h>
#include <w4warn.h>
#include <mshtmdbg.h>

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

void NonCrtStrCat(LPSTR pszDst, LPCSTR pszSrc)
{
    while (*pszDst)
        ++pszDst;

    while (*pszSrc)
        *pszDst++ = *pszSrc++;

    *pszDst = 0;
}

class CPadMallocSpy : public IMallocSpy
{
public:

    CPadMallocSpy() { _pSpyFwd = 0; }
    void * __cdecl operator new(size_t cb) { return(LocalAlloc(LPTR, cb)); } \
    void __cdecl operator delete(void * pv) { LocalFree(pv); }

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IMallocSpy methods

    STDMETHOD_(SIZE_T, PreAlloc)(SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc)(void *pvActual);
    STDMETHOD_(void *, PreFree)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(void,   PostFree)(BOOL fSpyed);
    STDMETHOD_(SIZE_T, PreRealloc)(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc)(void *pvActual, BOOL fSpyed);
    STDMETHOD_(void *, PreGetSize)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize)(SIZE_T cbActual, BOOL fSpyed);
    STDMETHOD_(void *, PreDidAlloc)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(BOOL,   PostDidAlloc)(void *pvRequest, BOOL fSpyed, BOOL fActual);
    STDMETHOD_(void,   PreHeapMinimize)();
    STDMETHOD_(void,   PostHeapMinimize)();

    IMallocSpy *    _pSpyFwd;
};

STDMETHODIMP
CPadMallocSpy::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IMallocSpy)
    {
        *ppv = (IMallocSpy *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CPadMallocSpy::AddRef()
{
    return 1;
}

STDMETHODIMP_(ULONG)
CPadMallocSpy::Release()
{
    return 1;
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreAlloc(cbRequest));
    else
        return(cbRequest);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PostAlloc(void *pvActual)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostAlloc(pvActual));
    else
        return(pvActual);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreFree(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreFree(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(void)
CPadMallocSpy::PostFree(BOOL fSpyed)
{
    if (_pSpyFwd)
        _pSpyFwd->PostFree(fSpyed);
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PreRealloc(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreRealloc(pvRequest, cbRequest, ppvActual, fSpyed));
    else
    {
        *ppvActual = pvRequest;
        return(cbRequest);
    }
}

STDMETHODIMP_(void *)
CPadMallocSpy::PostRealloc(void *pvActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostRealloc(pvActual, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreGetSize(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreGetSize(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(SIZE_T)
CPadMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostGetSize(cbActual, fSpyed));
    else
        return(0);
}

STDMETHODIMP_(void *)
CPadMallocSpy::PreDidAlloc(void *pvRequest, BOOL fSpyed)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PreDidAlloc(pvRequest, fSpyed));
    else
        return(NULL);
}

STDMETHODIMP_(BOOL)
CPadMallocSpy::PostDidAlloc(void *pvRequest, BOOL fSpyed, BOOL fActual)
{
    if (_pSpyFwd)
        return(_pSpyFwd->PostDidAlloc(pvRequest, fSpyed, fActual));
    else
        return(FALSE);
}

STDMETHODIMP_(void)
CPadMallocSpy::PreHeapMinimize()
{
}

STDMETHODIMP_(void)
CPadMallocSpy::PostHeapMinimize()
{
}

typedef int (WINAPI * PFNPADMAIN)(int argc, char ** argv, IMallocSpy * pSpy);
typedef DWORD (WINAPI * PFNDBGEXGETVERSION)();
typedef TRACETAG (WINAPI * PFNTAGREGISTEROTHER)(char * szOwner, char * szDesc, BOOL fEnabled);
typedef void (WINAPI * PFNDBGCOMEMORYTRACKDISABLE)(BOOL fDisable);
typedef void * (WINAPI * PFNDBGGETMALLOCSPY)();
typedef void (WINAPI * PFNRESTOREDEFAULTDEBUGSTATE)();
typedef BOOL (WINAPI * PFNISTAGENABLED)(TRACETAG tag);
typedef BOOL (WINAPI * PFNASSERTIMPL)(char const * szFile, int iLine, char const * szMessage);
typedef BOOL (WINAPI * PFNENUMPROCESSMODULES)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded);
typedef DWORD (WINAPI * PFNGETMODULEBASENAMEA)(HANDLE hProcess, HMODULE hModule, LPSTR lpBaseName, DWORD nSize);

extern "C"
void WINAPI mainCRTStartup(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    CPadMallocSpy *             g_pSpy = new CPadMallocSpy;
    HINSTANCE                   hInstPSAPI  = NULL;
    PFNDBGEXGETVERSION          pfnDbgExGetVersion = NULL;
    PFNTAGREGISTEROTHER         pfnTagRegisterOther = NULL;
    PFNDBGCOMEMORYTRACKDISABLE  pfnDbgCoMemoryTrackDisable = NULL;
    PFNDBGGETMALLOCSPY          pfnDbgGetMallocSpy = NULL;
    PFNRESTOREDEFAULTDEBUGSTATE pfnRestoreDefaultDebugState = NULL;
    PFNISTAGENABLED             pfnIsTagEnabled = NULL;
    PFNASSERTIMPL               pfnAssertImpl = NULL;
    PFNENUMPROCESSMODULES       pfnEnumProcessModules = NULL;
    PFNGETMODULEBASENAMEA       pfnGetModuleBaseNameA = NULL;
    TRACETAG                    tagCoTrack = 0;
    TRACETAG                    tagCoTrackDisable = 0;
    TRACETAG                    tagModuleLeaks = 0;
    HMODULE                     ahModuleBeg[64];
    UINT                        chModuleBeg = 0;
    DWORD                       cb;
    int                         argc = 0;
    char *                      argv[64] = { 0 };
    char *                      pch = GetCommandLineA();
    char                        chDelim;

    // Parse command line manually
    while (*pch)
    {
        while (*pch == ' ') ++pch;
                
                if (*pch == '\0')
                        break;

        if (*pch == '"')
        {
            chDelim = '"';
            ++pch;
        }
        else
        {
            chDelim = ' ';
        }

        if (argc == 64)
            break;

        argv[argc++] = pch;

        while (*pch != chDelim && *pch != '\0') ++pch;

        if (*pch == chDelim)
            *pch++ = '\0';
    }

    hInstPSAPI = LoadLibraryA("PSAPI.DLL");

    if (hInstPSAPI)
    {
        pfnEnumProcessModules = (PFNENUMPROCESSMODULES)GetProcAddress(hInstPSAPI, "EnumProcessModules");
        pfnGetModuleBaseNameA = (PFNGETMODULEBASENAMEA)GetProcAddress(hInstPSAPI, "GetModuleBaseNameA");

        if (pfnEnumProcessModules && pfnEnumProcessModules(GetCurrentProcess(), ahModuleBeg, sizeof(ahModuleBeg), &cb))
        {
            chModuleBeg = cb / sizeof(HMODULE);
        }
    }

    HINSTANCE hInstDbg = LoadLibraryA("mshtmdbg.dll");

    if (hInstDbg)
    {
        pfnDbgExGetVersion          = (PFNDBGEXGETVERSION)GetProcAddress(hInstDbg, "DbgExGetVersion");
        pfnTagRegisterOther         = (PFNTAGREGISTEROTHER)GetProcAddress(hInstDbg, "DbgExTagRegisterOther");
        pfnDbgCoMemoryTrackDisable  = (PFNDBGCOMEMORYTRACKDISABLE)GetProcAddress(hInstDbg, "DbgExCoMemoryTrackDisable");
        pfnDbgGetMallocSpy          = (PFNDBGGETMALLOCSPY)GetProcAddress(hInstDbg, "DbgExGetMallocSpy");
        pfnRestoreDefaultDebugState = (PFNRESTOREDEFAULTDEBUGSTATE)GetProcAddress(hInstDbg, "DbgExRestoreDefaultDebugState");
        pfnIsTagEnabled             = (PFNISTAGENABLED)GetProcAddress(hInstDbg, "DbgExIsTagEnabled");
        pfnAssertImpl               = (PFNASSERTIMPL)GetProcAddress(hInstDbg, "DbgExAssertImpl");

        DWORD dwVer = pfnDbgExGetVersion ? pfnDbgExGetVersion() : 0;

        if (pfnDbgExGetVersion)
        {
            if (dwVer != MSHTMDBG_API_VERSION)
            {
                OutputDebugStringA("MSHTMPAD: Version mismatch for MSHTMDBG.DLL.  Continuing without it.\r\n");
                FreeLibrary(hInstDbg);
                hInstDbg = NULL;
            }
        }

        if (    hInstDbg
            &&  (   !pfnTagRegisterOther
                ||  !pfnDbgCoMemoryTrackDisable
                ||  !pfnDbgGetMallocSpy
                ||  !pfnRestoreDefaultDebugState
                ||  !pfnIsTagEnabled))
        {
            OutputDebugStringA("MSHTMPAD: Can't find one or more entrypoints in MSHTMDBG.DLL.  Continuing without it.\r\n");
            FreeLibrary(hInstDbg);
            hInstDbg = NULL;
        }

        if (hInstDbg)
        {
            tagCoTrack = pfnTagRegisterOther("!Memory", "Track all CoMemory leaks", FALSE);
            tagCoTrackDisable = pfnTagRegisterOther("!Memory", "Do not register CoMemory spy (MUST RESTART EXE)", FALSE);
            tagModuleLeaks = pfnTagRegisterOther("!Memory", "Leaks: Assert on module leaks", FALSE);
            pfnRestoreDefaultDebugState();
        }
    }
    else
    {
        OutputDebugStringA("MSHTMPAD: Can't find MSHTMDBG.DLL.  Continuing without it.\r\n");
    }

#if !defined(PRODUCT_PROF)
    if (g_pSpy && hInstDbg && !pfnIsTagEnabled(tagCoTrackDisable))
    {
        g_pSpy->_pSpyFwd = (IMallocSpy *)pfnDbgGetMallocSpy();
    }
#endif

    if (hInstDbg && !pfnIsTagEnabled(tagCoTrack))
    {
        pfnDbgCoMemoryTrackDisable(TRUE);

        //$ISSUE: Not ready for prime-time yet
        pfnDbgCoMemoryTrackDisable(TRUE);
    }

    HINSTANCE hInstPad = LoadLibraryA("htmlpad.dll");

    if (hInstPad == NULL)
    {
        OutputDebugStringA("MSHTMPAD: Unable to load HTMLPAD.DLL\r\n");
        ExitProcess(1);
    }

    PFNPADMAIN pfnPadMain = (PFNPADMAIN)GetProcAddress(hInstPad, "PadMain");

    if (!pfnPadMain)
    {
        OutputDebugStringA("MSHTMPAD: Can't find PadMain entrypoint in HTMLPAD.DLL\r\n");
        ExitProcess(1);
    }

    pfnPadMain(argc, argv, (g_pSpy && g_pSpy->_pSpyFwd) ? g_pSpy : NULL);

    FreeLibrary(hInstPad);

    if (hInstDbg && pfnIsTagEnabled(tagModuleLeaks))
    {
        HMODULE ahModuleEnd[64];
        UINT    chModuleEnd = 0;
        
        if (pfnEnumProcessModules && pfnEnumProcessModules(GetCurrentProcess(), ahModuleEnd, sizeof(ahModuleEnd), &cb))
        {
            chModuleEnd = cb / sizeof(HMODULE);
        }

        if (chModuleEnd)
        {
            HMODULE ahModuleLeak[64];
            UINT    chModuleLeak = 0;
            
            while (chModuleEnd > 0)
            {
                chModuleEnd -= 1;

                HMODULE hModule = ahModuleEnd[chModuleEnd];

                for (cb = 0; cb < chModuleBeg; ++cb)
                {
                    if (ahModuleBeg[cb] == hModule)
                        break;
                }

                if (cb == chModuleBeg && hModule != (HMODULE)hInstDbg)
                {
                    ahModuleLeak[chModuleLeak++] = hModule;
                }
            }

            if (chModuleLeak)
            {
                char achLeakMsg[2048];
                char achModule[128];

                achLeakMsg[0] = 0;

                NonCrtStrCat(achLeakMsg, "The following modules were leaked: ");

                for (cb = 0; cb < chModuleLeak; ++cb)
                {
                    if (!pfnGetModuleBaseNameA(GetCurrentProcess(), ahModuleLeak[cb], achModule, sizeof(achModule)))
                        NonCrtStrCat(achLeakMsg, "<unknown>");
                    if (cb > 0)
                        NonCrtStrCat(achLeakMsg, ", ");
                    NonCrtStrCat(achLeakMsg, achModule);
                }

                if (pfnAssertImpl(__FILE__, __LINE__, achLeakMsg))
                    F3DebugBreak();
            }
        }
    }

        if (hInstPSAPI)
        {
                FreeLibrary(hInstPSAPI);
        }

    if (hInstDbg)
    {
        FreeLibrary(hInstDbg);
    }

    g_pSpy->_pSpyFwd = NULL;

    ExitProcess(0);
}

#ifdef UNIX
// IEUNIX uses WinMain as program entry.
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    return mainCRTStartup(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "padhead.hxx"

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>         // for UINT_MAX below
#endif

//+---------------------------------------------------------------
//
//  Class:      CEnumXXX
//
//  Synopsis:   Base class for enumerators.
//
//----------------------------------------------------------------

class CEnumXXX : public IUnknown
{
public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(CEnumXXX);

    //*** IEnumX methods ***
    STDMETHOD(Next) (ULONG c, void * pv, ULONG * pcFetched);
    STDMETHOD(Skip) (ULONG c);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (void ** ppEnumXXX) = 0;

protected:
    CEnumXXX(REFIID iid, int c, int i);
    virtual ~CEnumXXX();

    virtual HRESULT FetchElements(int c, void *pv) = 0;

    REFIID _iid;
    int  _c;
    int  _i;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::CEnumXXX
//
//  Synopsis:   Constructor.
//
//  Arguments:  iid     iid for this enumerator.
//              c       count of elements
//              i       starting index
//
//----------------------------------------------------------------

CEnumXXX::CEnumXXX(REFIID iid, int c, int i)
    : _iid(iid)
{
    _c = c;
    _i = i;
    _ulRefs = 1;
    IncrementObjectCount();
}

CEnumXXX::~CEnumXXX()
{
    DecrementObjectCount();
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::QueryInterface, IUnknown
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::QueryInterface(REFIID iid, void ** ppvObj)
{
    if (IsEqualIID(iid,IID_IUnknown) || IsEqualIID(iid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Next(ULONG c, void *pv, ULONG *pcFetched)
{
    int   cFetched;
    HRESULT hr;

    cFetched = c;
    if (cFetched > _c - _i)
        cFetched = _c - _i;

    Assert(cFetched >= 0);

    hr = THR(FetchElements(cFetched, pv));
    if (hr)
        goto Error;

    _i += cFetched;
    hr = cFetched == (int)c ? S_OK : S_FALSE;

Cleanup:
    if (pcFetched)
    {
        *pcFetched = cFetched;
    }

    RRETURN1(hr, S_FALSE);

Error:
    cFetched = 0;
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Skip(ULONG c)
{
    _i += c;
    if (_i > _c)
        _i = c;

    return _i == _c ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Reset()
{
    _i = 0;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

class CEnumOLEVERB: public CEnumXXX
{
    friend HRESULT CreateOLEVERBEnum(OLEVERB const *, ULONG, LPENUMOLEVERB FAR*);

public:
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

private:
    CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iVerb);

    OLEVERB const * _pOleVerb;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumOLEVERB::CEnumOLEVERB, private
//
//  Synopsis:   Constructor for CEnumOLEVERB objects
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [iOleVerb] -- starting index for enumerator.
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

inline
CEnumOLEVERB::CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iOleVerb)
    : CEnumXXX(IID_IEnumOLEVERB, cOleVerb, iOleVerb)
{
    _pOleVerb = pOleVerb;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumOLEVERB::FetchElements(int c, void *pv)
{
    HRESULT   hr = S_OK;
    int       i;
    LPOLEVERB pOleVerb = (LPOLEVERB)pv;

    for (i = 0; i < c; i++)
    {
        pOleVerb[i] = _pOleVerb[i + _i];
        if (pOleVerb[i].lpszVerbName)
        {
            hr = TaskAllocString(pOleVerb[i].lpszVerbName,
                    &pOleVerb[i].lpszVerbName);
            if (hr)
                goto Error;
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    while (--i >= 0)
    {
        TaskFreeString(pOleVerb[i].lpszVerbName);
    }
    memset(pv, 0, sizeof(OLEVERB) * c);
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumOLEVERB::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumOLEVERB(_pOleVerb, _c, _i);
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [ppEnum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(OLEVERB const * pOleVerb, ULONG cOleVerb, LPENUMOLEVERB * ppEnum)
{
    *ppEnum = (LPENUMOLEVERB)new CEnumOLEVERB(pOleVerb, cOleVerb, 0);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

class CEnumFORMATETC: public CEnumXXX
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*, BOOL fDeleteOnExit);
public:

    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

    CEnumFORMATETC  *_pClonedFrom;

protected:
    virtual ~CEnumFORMATETC();

private:
    CEnumFORMATETC(LPFORMATETC pFmt, int cFmt, int iFmt, BOOL fDeleteOnExit);

    LPFORMATETC     _pFmtEtc;
    BOOL            _fDeleteOnExit;

};

//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::CEnumFORMATETC, private
//
//  Synopsis:   Constructor for CEnumFORMATETC objects
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [iFmtEtc] -- starting position for enumerator.
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

inline
CEnumFORMATETC::CEnumFORMATETC(LPFORMATETC pFmtEtc, int cFmtEtc, int iFmtEtc, BOOL fDeleteOnExit)
    : CEnumXXX(IID_IEnumFORMATETC, cFmtEtc, iFmtEtc)
{
    _pFmtEtc = pFmtEtc;
    _fDeleteOnExit = fDeleteOnExit;
    _pClonedFrom = 0;
}

CEnumFORMATETC::~CEnumFORMATETC()
{
    if (_fDeleteOnExit)
    {
        delete [] _pFmtEtc;
    }
    ReleaseInterface(_pClonedFrom);
}

//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumFORMATETC::FetchElements(int c, void *pv)
{
    HRESULT     hr = S_OK;
    int         i;
    LPFORMATETC pFmtEtc = (LPFORMATETC)pv;

    for (i = 0; i < c; i++)
    {
        pFmtEtc[i] = _pFmtEtc[i + _i];
        if (pFmtEtc[i].ptd)
        {
            pFmtEtc[i].ptd = (DVTARGETDEVICE *)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));
            if (!pFmtEtc[i].ptd)
                goto MemoryError;
            *(pFmtEtc[i].ptd) = *(_pFmtEtc[i + _i].ptd);
        }
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    while (--i >= 0)
    {
        CoTaskMemFree(pFmtEtc[i].ptd);
    }
    memset(pv, 0, sizeof(FORMATETC) * c);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumFORMATETC::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumFORMATETC(_pFmtEtc, _c, _i, FALSE);
    if (*ppEnumXXX && _fDeleteOnExit)
    {
        ((CEnumFORMATETC*)*ppEnumXXX)->_pClonedFrom = this;
        AddRef();
    }
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFmtEtc, ULONG cFmtEtc, LPENUMFORMATETC * ppEnum, BOOL fDeleteOnExit)
{
    *ppEnum = (IEnumFORMATETC *)new CEnumFORMATETC(pFmtEtc, cFmtEtc, 0, fDeleteOnExit);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}


#if 0   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;

    TraceTag((tagStdEnum, "StdStaticEnum constructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    TraceTag((tagStdEnum, "StdStaticEnum destructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\tvstack.h ===
///////////////////////////////////////////////////////////////////////
//
//  TVSTACK.H
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
///////////////////////////////////////////////////////////////////////


#define StackSize 64

class CTIStack
{

public:
    CTIStack()  { m_ptos = m_ahti; m_pMax = m_ahti + StackSize - 1;}
    ~CTIStack() {};

    BOOL Push(HTREEITEM hti);
    HTREEITEM Pop(void);
    BOOL IsEmpty(void);

private:
    HTREEITEM m_ahti[StackSize];
    HTREEITEM *m_ptos;
    HTREEITEM *m_pMax;
};

inline BOOL CTIStack::Push(HTREEITEM hti)
{
    Assert(m_ptos >= m_ahti);
    Assert(m_ptos <= m_pMax);

    if(m_ptos == m_pMax)
        return FALSE;

    *m_ptos++ = hti;
    return TRUE;
}

inline BOOL CTIStack::IsEmpty(void)
{
    Assert(m_ptos >= m_ahti);
    Assert(m_ptos <= m_pMax);
    
    return (m_ptos == m_ahti);
}

inline HTREEITEM CTIStack::Pop(void)
{
    Assert(m_ptos > m_ahti);
    Assert(m_ptos <= m_pMax);

    if(m_ptos == m_ahti)
        return NULL;
        
    return *--m_ptos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\critsec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       critsec.cxx
//
//  Contents:   Critical Section initialization wrapper
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WIN16

CGlobalCriticalSection *CGlobalCriticalSection::g_gcsList = NULL;

//+---------------------------------------------------------------------------
//
//  Wrapper for InitializeCriticalSection to hide the exception that can be
//  thrown and convert it to an HRESULT
//
//----------------------------------------------------------------------------

HRESULT     HrInitializeCriticalSection(LPCRITICAL_SECTION pcs)
{
    HRESULT     hr = S_OK;

    __try
    {
        ::InitializeCriticalSection(pcs);
    } __except(GetExceptionCode() == STATUS_NO_MEMORY)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#endif  // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dllmain3.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitChkStk(unsigned long dwFill);
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupChkStk
#define DLL_MAIN_PRE_CINIT      InitChkStk(0xCCCCCCCC);
#define DLL_MAIN_PRE_CEXIT      /* Nothing */
#define DLL_MAIN_POST_CEXIT     /* Nothing */
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dllmain1.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define DLL_MAIN_FUNCTION_NAME  _DllMainStartup
#define DLL_MAIN_PRE_CINIT      /* Nothing */
#define DLL_MAIN_PRE_CEXIT      /* Nothing */
#define DLL_MAIN_POST_CEXIT     /* Nothing */
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dllmain.cxx ===
#ifdef __cplusplus
extern "C" {
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern CRITICAL_SECTION g_csHeap;
extern int  __cdecl __sbh_process_detach();
extern int trirt_proc_attached;
extern HANDLE g_hProcessHeap;
extern BOOL WINAPI _DllMainCRTStartup(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);

BOOL WINAPI DLL_MAIN_FUNCTION_NAME(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
    BOOL retcode = TRUE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            trirt_proc_attached++;

            if (HrInitializeCriticalSection(&g_csHeap) != S_OK)
                retcode = FALSE;

            if (!retcode)
                break;

            g_hProcessHeap = GetProcessHeap();

            DLL_MAIN_PRE_CINIT

            // Initialize the CRT and have it call into our DllMain for us
            
            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            if (trirt_proc_attached <= 0)
            {
                /*
                 * no prior process attach notification. just return
                 * without doing anything.
                 */
                return FALSE;
            }

            DLL_MAIN_PRE_CEXIT

            trirt_proc_attached--;

            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);

            DLL_MAIN_POST_CEXIT

#if DBG==1
            if (!__sbh_process_detach())
            {
				char ach[1024];
                wsprintfA(ach, "Small block heap not empty at DLL_PROCESS_DETACH\r\nFile: %s; Line %ld\r\n", __FILE__, __LINE__);
				OutputDebugStringA(ach);
            }
#else
            __sbh_process_detach();
#endif

            DeleteCriticalSection(&g_csHeap);

            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            retcode = _DllMainCRTStartup(hDllHandle, dwReason, lpreserved);
            break;
        }
    }

    return retcode;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\include\trirt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       Common header file for trirt
//
//  Note:       This file is very order-dependent.  Don't switch files around
//              just for the heck of it!
//
//----------------------------------------------------------------------------

#ifndef I_TRIRT_H_
#define I_TRIRT_H_

#ifndef INCMSG
//#define INCMSG(x)
#define INCMSG(x) message(x)
#endif

#pragma INCMSG("--- Beg 'trirt.h'")


// Make it so you can't use the CRT strdup functions.  Use MemAllocString instead.
// We want to do this so that the memory is allocated and tagged with our allocators.
#define _strdup CRT__strdup_DontUse
#define _wcsdup CRT__wcsdup_DontUse
#define strdup  CRT_strdup_DontUse

// Also don't let people use the CRT malloc/realloc/calloc/free functions
#define malloc  CRT_malloc_DontUse
#define realloc CRT_realloc_DontUse
#define calloc  CRT_calloc_DontUse
#define free    CRT_free_DontUse

// We are redefining this one because at one time we had our own implemenation that
// used Win32 CompareString.  Apparently CompareString can take NULL as an input
// but _wcsicmp can't.  So, lets just keep using the CompareString version.  We can't
// use the standard prototype however as it will be tagged with __declspec(dllimport).
#define _wcsicmp CRT__wcsicmp

// We want to use shlwapi for these so we redefine them
#define isdigit     CRT_isdigit
#define isalpha     CRT_isalpha
#define isspace     CRT_isspace
#define iswspace    CRT_iswspace

// Windows include
#include <w4warn.h>

#ifndef X_SHLWRAP_H_
#define X_SHLWRAP_H_
#include "shlwrap.h"
#endif

#include <w4warn.h>

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#pragma INCMSG("--- Beg <windows.h>")
#include <windows.h>
#pragma INCMSG("--- End <windows.h>")
#endif

#include <w4warn.h> // windows.h reenables some pragmas

#ifndef X_WINDOWSX_H_
#define X_WINDOWSX_H_
#pragma INCMSG("--- Beg <windowsx.h>")
#include <windowsx.h>
#pragma INCMSG("--- End <windowsx.h>")
#endif

// C runtime includes

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#pragma INCMSG("--- Beg <stdlib.h>")
#include <stdlib.h>
#pragma INCMSG("--- End <stdlib.h>")
#endif


#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#pragma INCMSG("--- Beg <limits.h>")
#include <limits.h>
#pragma INCMSG("--- End <limits.h>")
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#pragma INCMSG("--- Beg <stddef.h>")
#include <stddef.h>
#pragma INCMSG("--- End <stddef.h>")
#endif

#ifndef X_SEARCH_H_
#define X_SEARCH_H_
#pragma INCMSG("--- Beg <search.h>")
#include <search.h>
#pragma INCMSG("--- End <search.h>")
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#pragma INCMSG("--- Beg <string.h>")
#include <string.h>
#pragma INCMSG("--- End <string.h>")
#endif

#ifndef X_TCHAR_H_
#define X_TCHAR_H_
#pragma INCMSG("--- Beg <tchar.h>")
#include <tchar.h>
#pragma INCMSG("--- End <tchar.h>")
#endif

// We want to include this here so that
// no one else can.
#ifndef X_MALLOC_H_
#define X_MALLOC_H_
#pragma INCMSG("--- Beg <malloc.h>")
#include <malloc.h>
#pragma INCMSG("--- End <malloc.h>")
#endif

#undef _strdup
#undef _wcsdup
#undef strdup
#undef _wcsicmp
#undef malloc
#undef realloc
#undef calloc
#undef free

#undef isdigit
#undef isalpha
#undef isspace
#undef iswspace


// If you get an error pointing to these functions please look at
// at the note above -- JBeda
__declspec(deprecated) char *  __cdecl _strdup(const char *);
__declspec(deprecated) char *  __cdecl strdup(const char *);
__declspec(deprecated) wchar_t * __cdecl _wcsdup(const wchar_t *);
__declspec(deprecated) void * __cdecl malloc(size_t);
__declspec(deprecated) void * __cdecl realloc(void *, size_t);
__declspec(deprecated) void * __cdecl calloc(size_t, size_t);
__declspec(deprecated) void   __cdecl free(void *);

int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);


#ifndef X_F3DEBUG_H_
#define X_F3DEBUG_H_
#include "f3debug.h"
#endif

//+---------------------------------------------------------------------------
//
// Usefull Macros
//
//----------------------------------------------------------------------------
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x
#define IF_WIN32(x) x

#define PTR_DIFF(x, y)   ((x) - (y))

#if defined(_M_AMD64) || defined(_M_IA64)
#define SPEED_OPTIMIZE_FLAGS "tg"       // flags used for local speed optimisation in #pragma optimize
#else
#define SPEED_OPTIMIZE_FLAGS "tyg"      // flags used for local speed optimisation in #pragma optimize
#endif


#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

//+------------------------------------------------------------------------
//
// DYNCAST macro
//
// Use to cast objects from one class type to another. This should be used
// rather than using standard casts.
//
// Example:
//         CBodyElement *pBody = (CBodyElement*)_pElement;
//
//      is replaced by:
//
//         CBodyElement *pBody = DYNCAST(CBodyElement, _pElement);
//
// The dyncast macro will assert if _pElement is not really a CBodyElement.
//
// For ship builds the DYNCAST macro expands to a standard cast.
//
//-------------------------------------------------------------------------

#if DBG != 1 || defined(WINCE) || defined(NO_RTTI)

#ifdef UNIX
#define DYNCAST(Dest_type, Source_Value) ((Dest_type*)(Source_Value))
#else
#define DYNCAST(Dest_type, Source_Value) (static_cast<Dest_type*>(Source_Value))
#endif

#else // DBG == 1

#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#pragma INCMSG("--- Beg <typeinfo.h>")
#include <typeinfo.h>
#pragma INCMSG("--- End <typeinfo.h>")
#endif

extern char g_achDynCastMsg[];
extern char *g_pszDynMsg;
extern char *g_pszDynMsg2;

template <class TS, class TD>
TD * DYNCAST_IMPL (TS * source, TD &, char* pszType)
{
    if (!source) return NULL;

    TD * dest  = dynamic_cast <TD *> (source);
    TD * dest2 = static_cast <TD *> (source);
    if (!dest)
    {
        wsprintfA(g_achDynCastMsg, g_pszDynMsg, typeid(*source).name(), pszType);
        AssertSz(FALSE, g_achDynCastMsg);
    }
    else if (dest != dest2)
    {
        wsprintfA(g_achDynCastMsg, g_pszDynMsg2, typeid(*source).name(), pszType);
        AssertSz(FALSE, g_achDynCastMsg);
    }

    return dest2;
}

#define DYNCAST(Dest_type, Source_value) \
    DYNCAST_IMPL(Source_value,(Dest_type &)*(Dest_type*)NULL, #Dest_type)

#endif // ifdef DBG != 1


//+------------------------------------------------------------------------
//
// Min and max templates
//
// Warning, Arguments must be cast to same types for template instantiation
//
//-------------------------------------------------------------------------

#ifdef min
#undef min
#endif

template < class T > inline T min ( T a, T b ) { return a < b ? a : b; }

#ifdef max
#undef max
#endif

template < class T > inline T max ( T a, T b ) { return a > b ? a : b; }

//+------------------------------------------------------------------------
// Performance tags and metering
//-------------------------------------------------------------------------

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#pragma INCMSG("--- Beg <mshtmdbg.h>")
#include <mshtmdbg.h>
#pragma INCMSG("--- End <mshtmdbg.h>")
#endif

extern HTMPERFCTL * g_pHtmPerfCtl;

//+------------------------------------------------------------------------
// Memory allocation
//-------------------------------------------------------------------------

MtExtern(Mem)

EXTERN_C void *  _MemAlloc(ULONG cb);
EXTERN_C void *  _MemAllocClear(ULONG cb);
EXTERN_C HRESULT _MemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MemGetSize(void * pv);
EXTERN_C void    _MemFree(void * pv);
HRESULT          _MemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDest);
#define          _MemFreeString(pch) _MemFree(pch)
void __cdecl     _MemSetName(void * pv, char * szFmt, ...);
char *           _MemGetName(void * pv);

EXTERN_C void *  _MtMemAlloc(PERFMETERTAG mt, ULONG cb);
EXTERN_C void *  _MtMemAllocClear(PERFMETERTAG mt, ULONG cb);
EXTERN_C HRESULT _MtMemRealloc(PERFMETERTAG mt, void ** ppv, ULONG cb);
EXTERN_C ULONG   _MtMemGetSize(void * pv);
EXTERN_C void    _MtMemFree(void * pv);
HRESULT          _MtMemAllocString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MtMemAllocString(PERFMETERTAG mt, ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MtMemReplaceString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst);
#define          _MtMemFreeString(pch) _MtMemFree(pch)
void __cdecl     _MtMemSetName(void * pv, char * szFmt, ...);
char *           _MtMemGetName(void * pv);
int              _MtMemGetMeter(void * pv);
void             _MtMemSetMeter(void * pv, PERFMETERTAG mt);

EXTERN_C void *  _MgMemAlloc(ULONG cb);
EXTERN_C void *  _MgMemAllocClear(ULONG cb);
EXTERN_C HRESULT _MgMemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MgMemGetSize(void * pv);
EXTERN_C void    _MgMemFree(void * pv);
HRESULT          _MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MgMemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MgMemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDst);
#define          _MgMemFreeString(pch) _MgMemFree(pch)

#ifdef PERFMETER

#define MemAlloc(mt, cb)                            _MtMemAlloc(mt, cb)
#define MemAllocClear(mt, cb)                       _MtMemAllocClear(mt, cb)
#define MemRealloc(mt, ppv, cb)                     _MtMemRealloc(mt, ppv, cb)
#define MemGetSize(pv)                              _MtMemGetSize(pv)
#define MemFree(pv)                                 _MtMemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MtMemAllocString(mt, pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MtMemAllocString(mt, cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MtMemReplaceString(mt, pch, ppch)
#define MemFreeString(pch)                          _MtMemFreeString(pch)
#define MemGetMeter(pv)                             _MtMemGetMeter(pv)
#define MemSetMeter(pv, mt)                         _MtMemSetMeter(pv, mt)

#elif defined(MEMGUARD)

#define MemAlloc(mt, cb)                            _MgMemAlloc(cb)
#define MemAllocClear(mt, cb)                       _MgMemAllocClear(cb)
#define MemRealloc(mt, ppv, cb)                     _MgMemRealloc(ppv, cb)
#define MemGetSize(pv)                              _MgMemGetSize(pv)
#define MemFree(pv)                                 _MgMemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MgMemAllocString(pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MgMemAllocString(cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MgMemReplaceString(pch, ppch)
#define MemFreeString(pch)                          _MgMemFreeString(pch)
#define MemGetMeter(pv)                             0
#define MemSetMeter(pv, mt)

#else

#define MemAlloc(mt, cb)                            _MemAlloc(cb)
#define MemAllocClear(mt, cb)                       _MemAllocClear(cb)
#define MemRealloc(mt, ppv, cb)                     _MemRealloc(ppv, cb)
#define MemGetSize(pv)                              _MemGetSize(pv)
#define MemFree(pv)                                 _MemFree(pv)
#define MemAllocString(mt, pch, ppch)               _MemAllocString(pch, ppch)
#define MemAllocStringBuffer(mt, cch, pch, ppch)    _MemAllocString(cch, pch, ppch)
#define MemReplaceString(mt, pch, ppch)             _MemReplaceString(pch, ppch)
#define MemFreeString(pch)                          _MemFreeString(pch)
#define MemGetMeter(pv)                             0
#define MemSetMeter(pv, mt)

#endif

#if DBG==1
    #ifdef PERFMETER
        #define MemGetName(pv)              _MtMemGetName(pv)
        #define MemSetName(x)               _MtMemSetName x
    #else
        #define MemGetName(pv)              _MemGetName(pv)
        #define MemSetName(x)               _MemSetName x
    #endif
#else
    #define MemGetName(pv)
    #define MemSetName(x)
#endif

HRESULT TaskAllocString(const TCHAR *pstrSrc, TCHAR **ppstrDest);
HRESULT TaskReplaceString(const TCHAR * pstrSrc, TCHAR **ppstrDest);

MtExtern(OpNew)

#ifndef TRIMEM_NOOPNEW

#ifdef PERFMETER
       void * __cdecl UseOperatorNewWithMemoryMeterInstead(size_t cb);
inline void * __cdecl operator new(size_t cb)           { return UseOperatorNewWithMemoryMeterInstead(cb); }
inline void * __cdecl operator new[](size_t cb)         { return UseOperatorNewWithMemoryMeterInstead(cb); }
#else
inline void * __cdecl operator new(size_t cb)           { return MemAlloc(Mt(OpNew), cb); }
#ifndef UNIX // UNIX can't take new[] and delete[]
inline void * __cdecl operator new[](size_t cb)         { return MemAlloc(Mt(OpNew), cb); }
#endif // UNIX
#endif

inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt)   { return MemAlloc(mt, cb); }
#ifndef UNIX
inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return MemAlloc(mt, cb); }
#endif
inline void * __cdecl operator new(size_t cb, void * pv){ return pv; }
inline void   __cdecl operator delete(void *pv)         { MemFree(pv); }
#ifndef UNIX
inline void   __cdecl operator delete[](void *pv)       { MemFree(pv); }
#endif

#else // TRIMEM_NOOPNEW

inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt)   { return operator new(cb); }
#ifndef UNIX
inline void * __cdecl operator new[](size_t cb) { return operator new(cb); }
inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return operator new(cb); }
#endif

#endif // TRIMEM_NOOPNEW

inline void TaskFreeString(LPVOID pstr)
        { CoTaskMemFree(pstr); }

#ifndef UNIX
#define DECLARE_MEMALLOC_NEW_DELETE(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(mt, cb)); }

#define DECLARE_DELETE \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE(mt) \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(mt, cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMMETER_NEW \
    inline void * __cdecl operator new(size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); } \
    inline void * __cdecl operator new[](size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); }
#else
#define DECLARE_MEMALLOC_NEW_DELETE(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); } \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAlloc(mt, cb)); }

#define DECLARE_DELETE \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE(mt) \
    void * __cdecl operator new(size_t cb) { return(MemAllocClear(mt, cb)); } \
    void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMMETER_NEW \
    void * __cdecl operator new(size_t cb, PERFMETERTAG mt) { return(MemAlloc(mt, cb)); }
#endif //UNIX

#define DECLARE_PLACEMENT_NEW \
    inline void * __cdecl operator new(size_t cb, void * pv) { return pv; }

//+------------------------------------------------------------------------
//
//  Locale-correct implementations for the string compare functions
//  Added benefit is getting rid of the C runtime baggage.
//
//  Implementation lives in strcmp.c
//
//-------------------------------------------------------------------------

#undef _tcscmp
#undef _tcsicmp
#ifndef WINCE
#undef _wcsicmp
#endif
#undef _tcsncmp
#undef _tcsnicmp

#undef _istspace
#undef _istdigit
#undef _istalpha
#undef _istalnum
#undef _istxdigit
#undef _istprint

// Unlocalized string comparisons
int _cdecl _tcscmp  (const TCHAR *string1, const TCHAR *string2);
int _cdecl _tcsicmp (const TCHAR *string1, const TCHAR *string2);
const TCHAR * __cdecl _tcsistr (const TCHAR * wcs1,const TCHAR * wcs2);
int _cdecl _tcsncmp (const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
int _cdecl _tcsnicmp(const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
BOOL _tcsequal(const TCHAR *string1, const TCHAR *string2);
BOOL _tcsiequal(const TCHAR *string1, const TCHAR *string2);
BOOL _tcsnpre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);
BOOL _tcsnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);
BOOL _7csnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2);

// Localized string comparisons
int _cdecl _tcscmpLoc  (const TCHAR *string1, const TCHAR *string2);
int _cdecl _tcsicmpLoc (const TCHAR *string1, const TCHAR *string2);
const TCHAR * __cdecl _tcsistrLoc (const TCHAR * wcs1,const TCHAR * wcs2);
int _cdecl _tcsncmpLoc (const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);
int _cdecl _tcsnicmpLoc(const TCHAR *string1, int cch1, const TCHAR * string2, int cch2);

int _cdecl _istspace  (TCHAR ch);
int _cdecl _istdigit  (TCHAR ch);
int _cdecl _istalpha  (TCHAR ch);
int _cdecl _istalnum  (TCHAR ch);
int _cdecl _istxdigit  (TCHAR ch);
int _cdecl _istprint  (TCHAR ch);

int __cdecl isdigit(int ch);
int __cdecl isalpha(int ch);
int __cdecl isspace(int ch);
int __cdecl iswspace(wchar_t ch);


#pragma INCMSG("--- End 'trirt.h'")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\rsrc\makefile.inc ===
# Run the HTML dialogs though the preprocessor to remove comments
# then through a sed script to reomave extra whitespace.

$O\replace.dls : replace.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP replace.dlg > $@

$O\replace.dlx : $O\replace.dls dlg.pl
    perl dlg.pl < $O\replace.dls > $@

$O\forpar.dls : forpar.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP forpar.dlg > $@

$O\forpar.dlx : $O\forpar.dls dlg.pl
    perl dlg.pl < $O\forpar.dls > $@

$O\gobook.dls : gobook.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP gobook.dlg > $@

$O\gobook.dlx : $O\gobook.dls dlg.pl
    perl dlg.pl < $O\gobook.dls > $@

# Run the HTML property pages through a sed
# script to remove extra whitespaces.

$O\selfreg_mshtml.inf : selfreg.inx
	cleaninf.exe -w selfreg.inx $@

FORMS3R_DEP = \
    $(BASEDIR)\public\sdk\inc\ieverp.h \
    $O\replace.dlx \
    $O\forpar.dlx \
    $O\gobook.dlx \
    backgrnd.ppg \
    backgrnd.jpg \
    clouds.gif \
    waves.gif \
    authfla.gif \
    cforms.ico \
    selbar.cur \
    west.cur \
    south.cur \
    north.cur \
    nomove2d.cur \
    east.cur \
    sw.cur \
    se.cur \
    nw.cur \
    ne.cur \
    hyperlnk.cur \
    hlnocach.cur \
    csimtool.bmp \
    $O\selfreg_mshtml.inf

forms3r.rc : $(FORMS3R_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dbgstk.cxx ===
/***
*dbgstk.c - debug check stack routine
*
*       Copyright (c) 1986-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This module contains a debug impelmentation of the standard _chkstk
*   for i386.  It will do the standard stack probe (code copied from
*   VC5 CRT) and then call a debug routine which will have the oportunity
*   top spew the stack before it gets initialized (or not).
*
*******************************************************************************/
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if defined(USE_STACK_SPEW) && defined(_X86_)

#pragma check_stack(off)

static BOOL    g_fStackSpewEnabled = FALSE;
static DWORD   g_dwSpew = 0x0;

extern "C" void __declspec(naked) __cdecl _chkstk()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't 
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx                        

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled
        
        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:        
        ret     12                      ; return, popping off 12 padding
    }
}

// NOTE: _alloca_probe is impelemented exactly the same as _chkstk
// I'd like to find some way to merge these two pieces of code but I
// don't know how with inline assembly...
extern "C" void __declspec(naked) __cdecl _alloca_probe()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't 
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx                        

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled
        
        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:        
        ret     12                      ; return, popping off 12 padding
    }
}

//
// Initialize the debug stack system
//

extern "C" void
InitChkStk(BOOL dwFill)
{
    g_dwSpew = dwFill;
    g_fStackSpewEnabled = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dllmain2.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void TermDebugLib(HANDLE, BOOL);
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupDebug
#define DLL_MAIN_PRE_CINIT      InitDebugLib(hDllHandle, DLL_MAIN_FUNCTION_NAME);
#define DLL_MAIN_PRE_CEXIT      TermDebugLib(hDllHandle, FALSE);
#define DLL_MAIN_POST_CEXIT     TermDebugLib(hDllHandle, TRUE);
#include "dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\winheap.h ===
/***
*winheap.h - Private include file for winheap directory.
*
*       Copyright (c) 1988-1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains information needed by the C library heap code.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_WINHEAP
#define _INC_WINHEAP

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#include <windows.h>
#endif

#if defined(UNIX)
#define _PAGESIZE_      0x2000      /* one page */
#else
#define _PAGESIZE_      0x1000      /* one page */
#endif

/*
 * Constants and types for used by the small-block heap
 */
#define _PARASIZE               0x10
#define _PARASHIFT              0x4

#if defined(_M_AMD64) || defined(_M_IA64)

#define _PARAS_PER_PAGE         239
#define _PADDING_PER_PAGE       12
#define _PAGES_PER_REGION       1024
#define _PAGES_PER_COMMITMENT   16

#elif defined(UNIX)

#define _PARAS_PER_PAGE         454
#define _PADDING_PER_PAGE       3
#define _PAGES_PER_REGION       512
#define _PAGES_PER_COMMITMENT   8

#else

#define _PARAS_PER_PAGE         240
#define _PADDING_PER_PAGE       3
#define _PAGES_PER_REGION       1024
#define _PAGES_PER_COMMITMENT   16
#define _MARK_SBH

#endif

#define _NO_INDEX               -1

typedef char            __para_t[16];

#if defined(UNIX)
typedef unsigned short  __map_t;
#else
typedef unsigned char   __map_t;
#endif

#define _FREE_PARA              (__map_t)(0)
#define _UNCOMMITTED_PAGE       (__map_t)(-1)
#define _NO_FAILED_ALLOC        (__map_t)(_PARAS_PER_PAGE + 1);

typedef struct __sbh_region_struct  __sbh_region_t;

/*
 * Small-block heap page. The first four fields of the structure below are
 * descriptor for the page. That is, they hold information about allocations
 * in the page. The last field (typed as an array of paragraphs) is the
 * allocation area.
 */
typedef struct {
        __map_t *   pstarting_alloc_map;
        unsigned long free_paras_at_start;
        __map_t     alloc_map[_PARAS_PER_PAGE];
        __map_t     sentinel;                       /* always set to -1 */
        __map_t     reserved[_PADDING_PER_PAGE];
        __sbh_region_t * preg;
        __para_t    alloc_blocks[_PARAS_PER_PAGE];
}       __sbh_page_t;

// If the compiler barfs on the following line, it means that the data structure for
// __sbh_page_t is not exactly the size of a page.  It needs to be.  Adjust the parameter
// above until this compile-time assert doesn't fire.
typedef int _farf___sbh_page_t[sizeof(__sbh_page_t) == (_PAGESIZE_)];

/*
 * Small-block heap region descriptor. Most often, the small-block heap
 * consists of a single region, described by the statically allocated
 * decriptor __small_block_heap (declared below).
 */
struct __sbh_region_struct {
        struct __sbh_region_struct *    p_next_region;
        struct __sbh_region_struct *    p_prev_region;
        int                             starting_page_index;
        int                             first_uncommitted_index;
        __map_t                         region_map[_PAGES_PER_REGION];
        __map_t                         last_failed_alloc[_PAGES_PER_REGION];
        __sbh_page_t *                  p_pages;
};

typedef struct __sbh_region_struct  __sbh_region_t;

extern  HANDLE _crtheap;

/*
 * Global variable declarations for the small-block heap.
 */
extern __sbh_region_t  __small_block_heap;

// BUGBUG until CTableCell goes below 480 bytes (istvanc)
//efine __sbh_threshold (_PARASIZE * (_PARAS_PER_PAGE / 8))
#define __sbh_threshold (_PARASIZE * 35)

void * __cdecl _nh_malloc( size_t, int);
void * __cdecl _heap_alloc(size_t);

/*
 * Prototypes for internal functions of the small-block heap.
 */
void *    __cdecl __sbh_alloc_block(size_t);
void *    __cdecl __sbh_alloc_block_from_page(__sbh_page_t *, size_t, size_t);
void      __cdecl __sbh_decommit_pages(int);
__map_t * __cdecl __sbh_find_block(void *, __sbh_region_t **, __sbh_page_t **);
void      __cdecl __sbh_free_block(__sbh_region_t *, __sbh_page_t *, __map_t *);
int       __cdecl __sbh_heap_check(void);
__sbh_region_t * __cdecl __sbh_new_region(void);
void      __cdecl __sbh_release_region(__sbh_region_t *);
int       __cdecl __sbh_resize_block(__sbh_region_t *, __sbh_page_t *,
                                     __map_t *, size_t);


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif  /* _INC_WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\fontlinkcore\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\idl\$(O) to $(O)
#

$(O)\fontlink_i.c : ..\idl\$(O)\fontlink_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\trirt0.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       trirt0.c
//
//  Contents:   Data for trirt
//
//----------------------------------------------------------------------------

#include <w4warn.h>
#define NOGDI
#define NOCRYPT
#include <windows.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

CRITICAL_SECTION g_csHeap;

int trirt_proc_attached = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\dllmain4.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void InitDebugChkStk(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));
extern "C" void TermDebugLib(HANDLE, BOOL);
extern "C" void InitChkStk(unsigned long dwFill);
#undef  DLL_MAIN_FUNCTION_NAME
#undef  DLL_MAIN_PRE_CINIT
#define DLL_MAIN_FUNCTION_NAME  _DllMainStartupDebugChkStk
#define DLL_MAIN_PRE_CINIT      InitDebugChkStk(hDllHandle, DLL_MAIN_FUNCTION_NAME);
#define DLL_MAIN_PRE_CEXIT      TermDebugLib(hDllHandle, FALSE);
#define DLL_MAIN_POST_CEXIT     TermDebugLib(hDllHandle, TRUE);
#include "dllmain.cxx"
#include <mshtmdbg.h>

extern "C"
void
InitDebugChkStk(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    DWORD dwFill;

    InitDebugLib(hDllHandle, pfnDllMain);

    if (DbgExGetChkStkFill(&dwFill))
    {
        InitChkStk(dwFill);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intl.inc ===
WARNING_LEVEL=W4

# include common.inc in mshtml
!include $(ROOT)\common.inc

# optimize for the ppro/pII
# X86_CPU_OPTIMIZATION = /G6

SRCROOT=$(ROOT)\src
INTLROOT=$(SRCROOT)\intl

INTL_INC_DIRS= \
    $(INTLROOT)\include; \
    $(INTLROOT)\idl\$(O); \
    $(ROOT)\src\core\include; \
    $(SHELL_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\sbheap.c ===
/***
*sbheap.c -  Small-block heap code
*
*       Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Core code for small-block heap.
*
*******************************************************************************/

#define _CRTBLD 1

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4244)
#pragma warning(disable:4514)
#pragma warning(disable:4711) /* function 'function' selected for inline expansion */
#define WIN32_LEAN_AND_MEAN
#include <stdlib.h>
#include <string.h>
#include "winheap.h"
#include <windows.h>
#include <limits.h>

#if DBG==1
#define OUTDBG(x)   OutputDebugStringA("TRI SBHEAP: " x "\r\n")
#else
#define OUTDBG(x)
#endif

extern HANDLE g_hProcessHeap;

__sbh_region_t __small_block_heap = {
        &__small_block_heap,
        &__small_block_heap,
        0,
        0,
        {(__map_t)(-1)},
        {(__map_t)(-1)},
        NULL };

static __sbh_region_t *__sbh_p_starting_region = &__small_block_heap;

static int __sbh_decommitable_pages = 0;

/*
 * Prototypes for user functions.
 */
size_t __cdecl _get_sbh_threshold(void);
int    __cdecl _set_sbh_threshold(size_t);


/***
*size_t _get_sbh_threshold() - return small-block threshold
*
*Purpose:
*       Return the current value of __sbh_threshold
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _get_sbh_threshold (
        void
        )
{
        return __sbh_threshold;
}


/***
*int _set_sbh_threshold(size_t threshold) - set small-block heap threshold
*
*Purpose:
*       Set the upper limit for the size of an allocation which will be
*       supported from the small-block heap. It is required that at least two
*       allocations can come from a page. This imposes an upper limit on how
*       big the new threshold can  be.
*
*Entry:
*       size_t  threshold   - proposed new value for __sbh_theshold
*
*Exit:
*       Returns 1 if successful. Returns 0 if threshold was too big.
*
*Exceptions:
*
*******************************************************************************/

#if 0
int __cdecl _set_sbh_threshold (
        size_t threshold
        )
{
        /*
         * Round up the proposed new value to the nearest paragraph
         */
        threshold = (threshold + _PARASIZE - 1) & ~(_PARASIZE - 1);

        /*
         * Require that at least two allocations be can be made within a
         * page.
         */
        if ( threshold <= (_PARASIZE * (_PARAS_PER_PAGE / 2)) ) {
            __sbh_threshold = threshold;
            return 1;
        }
        else
            return 0;
}
#endif

/***
*__sbh_region_t * __sbh_new_region() - get a region for the small-block heap
*
*Purpose:
*       Creates and adds a new region for the small-block heap. First, a
*       descriptor (__sbh_region_t) is obtained for the new region. Next,
*       VirtualAlloc() is used to reserved an address space of size
*       _PAGES_PER_REGION * _PAGESIZE_, and the first _PAGES_PER_COMMITTMENT
*       pages are committed.
*
*       Note that if __small_block_heap is available (i.e., the p_pages field
*       is NULL), it becomes the descriptor for the new regions. This is
*       basically the small-block heap initialization.
*
*Entry:
*       No arguments.
*
*Exit:
*       If successful, a pointer to the descriptor for the new region is
*       returned. Otherwise, NULL is returned.
*
*******************************************************************************/

__sbh_region_t * __cdecl __sbh_new_region(
        void
        )
{
        __sbh_region_t *pregnew;
        __sbh_page_t *  ppage;
        int             i;

        /*
         * Get a region descriptor (__sbh_region_t). If __small_block_heap is
         * available, always use it.
         */
        if ( __small_block_heap.p_pages == NULL ) {
            pregnew = &__small_block_heap;
        }
        else {
            /*
             * Allocate space for the new __sbh_region_t structure. Note that
             * this allocation comes out of the 'big block heap.
             */
            if ( (pregnew = HeapAlloc( g_hProcessHeap, 0, sizeof(__sbh_region_t) ))
                 == NULL )
                return NULL;
        }

        /*
         * Reserve a new contiguous address range (i.e., a region).
         */
        if ( (ppage = VirtualAlloc( NULL,
                                    _PAGESIZE_ * _PAGES_PER_REGION,
                                    MEM_RESERVE,
                                    PAGE_READWRITE )) != NULL )
        {
            /*
             * Commit the first _PAGES_PER_COMMITMENT of the new region.
             */
            if ( VirtualAlloc( ppage,
                               _PAGESIZE_ * _PAGES_PER_COMMITMENT,
                               MEM_COMMIT,
                               PAGE_READWRITE ) != NULL )
            {
                /*
                 * Insert *pregnew into the linked list of regions (just
                 * before __small_block_heap)
                 */
                if ( pregnew == &__small_block_heap ) {
                    if ( __small_block_heap.p_next_region == NULL )
                        __small_block_heap.p_next_region =
                            &__small_block_heap;
                    if ( __small_block_heap.p_prev_region == NULL )
                        __small_block_heap.p_prev_region =
                            &__small_block_heap;
                }
                else {
                    pregnew->p_next_region = &__small_block_heap;
                    pregnew->p_prev_region = __small_block_heap.p_prev_region;
                    __small_block_heap.p_prev_region = pregnew;
                    pregnew->p_prev_region->p_next_region = pregnew;
                }

                /*
                 * Fill in the rest of *pregnew
                 */
                pregnew->p_pages = ppage;
                pregnew->starting_page_index = 0;
                pregnew->first_uncommitted_index = _PAGES_PER_COMMITMENT;

                /*
                 * Initialize pregnew->region_map[].
                 */
                for ( i = 0 ; i < _PAGES_PER_REGION ; i++ ) {

                    if ( i < _PAGES_PER_COMMITMENT )
                        pregnew->region_map[i] = (__map_t)_PARAS_PER_PAGE;
                    else
                        pregnew->region_map[i] = _UNCOMMITTED_PAGE;

                    pregnew->last_failed_alloc[i] = _NO_FAILED_ALLOC;
                }

                /*
                 * Initialize pages
                 */
                while ( ppage < pregnew->p_pages + _PAGES_PER_COMMITMENT ) {
                    ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                    ppage->free_paras_at_start = _PARAS_PER_PAGE;
                    memset(ppage->alloc_map, 0, sizeof(ppage->alloc_map));
#ifdef _MARK_SBH
                    *(DWORD *)&ppage->sentinel = 0x486253FF;    // SbH
#else
                    ppage->sentinel = (__map_t)-1;
#endif
                    ppage->preg = &__small_block_heap;
                    ++ppage;
                }

                /*
                 * Return success
                 */
                return pregnew;
            }
            else {
                /*
                 * Couldn't commit the pages. Release the address space .
                 */
                VirtualFree( ppage, 0, MEM_RELEASE );
            }
        }

        /*
         * Unable to create the new region. Free the region descriptor, if necessary.
         */
        if ( pregnew != &__small_block_heap )
            HeapFree(g_hProcessHeap, 0, pregnew);

        /*
         * Return failure.
         */
        return NULL;
}


/***
*void __sbh_release_region(preg) - release region
*
*Purpose:
*       Release the address space associated with the specified region
*       descriptor. Also, free the specified region descriptor and update
*       the linked list of region descriptors if appropriate.
*
*Entry:
*       __sbh_region_t *    preg    - pointer to descriptor for the region to
*                                     be released.
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_release_region(
        __sbh_region_t *preg
        )
{
        /*
         * Release the passed region
         */
        VirtualFree( preg->p_pages, 0, MEM_RELEASE);

        /*
         * Update __sbh_p_starting_region, if necessary
         */
        if ( __sbh_p_starting_region == preg )
            __sbh_p_starting_region = preg->p_prev_region;

        if ( preg != &__small_block_heap ) {
            /*
             * Update linked list of region descriptors.
             */
            preg->p_prev_region->p_next_region = preg->p_next_region;
            preg->p_next_region->p_prev_region = preg->p_prev_region;

            /*
             * Free the region desciptor
             */
            HeapFree(g_hProcessHeap, 0, preg);
        }
        else {
            /*
             * Mark p_pages as NULL to indicate __small_block_heap is not
             * associated with any region (and can be reused). This the only
             * region descriptor for which this is supported.
             */
            __small_block_heap.p_pages = NULL;
        }
}


/***
*void __sbh_decommit_pages(count) - decommit specified number of pages
*
*Purpose:
*       Decommit count pages, if possible, in reverse (i.e., last to
*       first) order. If this results in all the pages in any region being
*       uncommitted, the region is released.
*
*Entry:
*       int count   -  number of pages to decommit
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_decommit_pages(
        int             count
        )
{
        __sbh_region_t *preg1;
        __sbh_region_t *preg2;
        __map_t *       pmap;
        int             page_decommitted_flag;
        int             i;

        /*
         * Scan the regions of the small-block heap, in reverse order. looking
         * for pages which can be decommitted.
         */
        preg1 = __small_block_heap.p_prev_region;
        do {
            if ( preg1->p_pages != NULL ) {
                /*
                 * Scan the pages in *preg1, in reverse order, looking for
                 * pages which can be decommitted.
                 */
                for ( i = _PAGES_PER_REGION - 1, page_decommitted_flag = 0,
                        pmap = &((preg1->region_map)[i]) ;
                      i >= 0 ; i--, pmap-- )
                {
                    /*
                     * Check if the pool page is unused and, if so, decommit it.
                     */
                    if ( *pmap == _PARAS_PER_PAGE ) {
                        if ( VirtualFree((preg1->p_pages) + i, _PAGESIZE_,
                                         MEM_DECOMMIT) )
                        {
                            /*
                             * Mark the page as uncommitted, update the count
                             * (global) decommitable pages, update the
                             * first_uncommitted_index field of the region
                             * descriptor, set the flag indicating at least
                             * one page has been decommitted in the region,
                             * and decrement count.
                             */
                            *pmap = _UNCOMMITTED_PAGE;

                            __sbh_decommitable_pages--;

                            if ( (preg1->first_uncommitted_index == _NO_INDEX)
                                 || (preg1->first_uncommitted_index > i) )
                                preg1->first_uncommitted_index = i;

                            page_decommitted_flag++;
                            if ( --count == 0 )
                                break;
                        }
                    }
                }

                /*
                 * 'Decrement' the preg1 pointer, but save a copy in preg2 in
                 * case the region needs to be released.
                 */
                preg2 = preg1;
                preg1 = preg1->p_prev_region;

                /*
                 * If appropriate, determine if all the pages in the region
                 * are uncommitted so that the region can be released.
                 */
                if ( page_decommitted_flag &&
                    ((preg2->region_map)[0] == _UNCOMMITTED_PAGE) )
                {

                    for ( i = 1, pmap = &((preg2->region_map)[1]) ;
                          (i < _PAGES_PER_REGION) &&
                            (*pmap == _UNCOMMITTED_PAGE) ;
                          i++, pmap++ );

                    if ( i == _PAGES_PER_REGION )
                        __sbh_release_region(preg2);
                }
            }
        }
        while ( (preg1 != __small_block_heap.p_prev_region) && (count > 0) );
}


/***
*__map_t *__sbh_find_block(pblck, ppreg, pppage) - find block in small-block
*       heap
*
*Purpose:
*       Determine if the specified allocation block lies in the small-block
*       heap and, if so, return the region, page and starting paragraph index
*       of the block.
*
*Entry:
*       void *              pblck   - pointer to block to be freed
*       __sbh_region_t **   ppreg   - pointer to a pointer to the region
*                                     holding *pblck, if found
*       __sbh_page_t **     pppage  - pointer to a pointer to the page holding
*                                     *pblck, if found
*
*Exit:
*       If successful, a pointer to the starting alloc_map[] entry for the
*       allocation block is returned.
*       If unsuccessful, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

__map_t * __cdecl __sbh_find_block (
        void *              pblck,
        __sbh_region_t **   ppreg,
        __sbh_page_t   **   pppage
        )
{
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;

        preg = &__small_block_heap;
        do
        {
            /*
             * Does the block lie within this small heap region?
             */
            if ( (preg->p_pages != NULL) &&
                 (pblck > (void *)preg->p_pages) &&
                 (pblck < (void *)(preg->p_pages + _PAGES_PER_REGION)) )
            {
                /*
                 * Yes, fill copy the region and page through the
                 * passed pointers.
                 */
                *ppreg = preg;
                *pppage = ppage = (__sbh_page_t *)((DWORD_PTR)pblck &
                                  ~(_PAGESIZE_ - 1));

                /*
                 * Return the alloc_map[] index of the block.
                 */
                return ( &(ppage->alloc_map[0]) + ((__para_t *)pblck -
                         &(ppage->alloc_blocks[0])) );
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        return NULL;
}


/***
*void __sbh_free_block(preg, ppage, pmap) - free block
*
*Purpose:
*       Free the specified block from the small-block heap.
*
*Entry:
*       __sbh_region_t *preg        - pointer to the descriptor for the
*                                     region containing the block
*       __sbh_page_t *  ppage       - pointer to the page containing the
*                                     block
*       __map_t *       pmap        - pointer to the initial alloc_map[]
*                                     entry for the allocation block
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_free_block (
        __sbh_region_t *preg,
        __sbh_page_t *  ppage,
        __map_t *       pmap
        )
{
        int             page_index;

        /*
         * Update the region_map[] entry.
         */
        page_index = (int)(ppage - (preg->p_pages));
        preg->region_map[page_index] += (int)*pmap;

        /*
         * Mark the alloc_map[] entry as free
         */
        *pmap = _FREE_PARA;

        /*
         * Clear the last_failed_alloc[] entry for the page.
         */
        preg->last_failed_alloc[page_index] = _NO_FAILED_ALLOC;

        /*
         * Check if the count of decommitable pages needs to be updated, and
         * if some pages need to be decommited.
         */
        if ( (preg->region_map)[page_index] == _PARAS_PER_PAGE )
            if ( ++__sbh_decommitable_pages == 2 * _PAGES_PER_COMMITMENT )
                __sbh_decommit_pages(_PAGES_PER_COMMITMENT);
}


/***
*void * __sbh_alloc_block(para_req) - allocate a block
*
*Purpose:
*       Allocate a block from the small-block heap, the specified number of
*       paragraphs in size.
*
*Entry:
*       size_t  para_req    - size of the allocation request in paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, if failure.
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl __sbh_alloc_block (
        size_t          para_req
        )
{
        __sbh_region_t  *preg;
        __sbh_page_t    *ppage;
        void *          retp;
        int             i, j;

        /*
         * Prevent allocation of zero paragraphs because it will trash the heap.
         */

        if (para_req == 0)
        {
            #if DBG==1
            OUTDBG("Attempt to allocate zero paragraphs");
            DebugBreak();
            #endif
            return NULL;
        }

        /*
         * First pass through the small-block heap. Try to satisfy the current
         * request from already committed pages.
         */
        preg = __sbh_p_starting_region;

        do {
            if ( preg->p_pages != NULL ) {
                /*
                 * Search from starting_page_index to the end of the region.
                 */
                for ( i = preg->starting_page_index ; i < _PAGES_PER_REGION ;
                      i++ )
                {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (preg->region_map[i] >= para_req) &&
                         (preg->region_map[i] != _UNCOMMITTED_PAGE) &&
                         (preg->last_failed_alloc[i] > para_req) )
                    {
                        if ( (retp = __sbh_alloc_block_from_page(
                                        preg->p_pages + i,
                                        (int)(preg->region_map[i]),
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __sbh_p_starting_region.
                             *  Update the region_map[] entry for the page.
                             *  Update the starting_page_index in the region.
                             *  Return a pointer to the allocated block.
                             */
                            __sbh_p_starting_region = preg;
                            preg->region_map[i] -= (__map_t)para_req;
                            preg->starting_page_index = i;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc[] entry.
                             */
                            preg->last_failed_alloc[i] = (__map_t)para_req;
                        }
                    }
                }

                /*
                 * If necessary, search from 0 page to search_start_index.
                 */
                for ( i = 0 ; i < preg->starting_page_index ; i++ ) {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (preg->region_map[i] >= para_req) &&
                         (preg->region_map[i] != _UNCOMMITTED_PAGE) &&
                         (preg->last_failed_alloc[i] > para_req) )
                    {
                        if ( (retp = __sbh_alloc_block_from_page(
                                        preg->p_pages + i,
                                        (int)(preg->region_map[i]),
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __sbh_p_starting_region.
                             *  Update the region_map[] entry for the page
                             *  Update the starting_page_index in the region.
                             *  Return a pointer to the allocated block.
                             */
                            __sbh_p_starting_region = preg;
                            preg->region_map[i] -= (__map_t)para_req;
                            preg->starting_page_index = i;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc[] entry.
                             */
                            preg->last_failed_alloc[i] = (__map_t)para_req;
                        }
                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != __sbh_p_starting_region );

        /*
         * Second pass through the small-block heap. This time, look for an
         * uncommitted page. Also, start at __small_block_heap rather than at
         * *__sbh_p_starting_region.
         */
        preg = &__small_block_heap;

        do
        {
            if ( (preg->p_pages != NULL) &&
                 (preg->first_uncommitted_index != _NO_INDEX) )
            {
                i = preg->first_uncommitted_index;
                j = __min( i + _PAGES_PER_COMMITMENT, _PAGES_PER_REGION );

                /*
                 * Determine how many adjacent pages, up to
                 * _PAGES_PER_COMMITMENT, are uncommitted (and can now be
                 * committed)
                 */
                for ( i++ ;
                      (i < j) && (preg->region_map[i] == _UNCOMMITTED_PAGE) ;
                      i++ ) ;

                /*
                 * Commit the pages.
                 */
                if ( VirtualAlloc( (void *)(preg->p_pages +
                                        preg->first_uncommitted_index),
                                   (i - preg->first_uncommitted_index) *
                                        _PAGESIZE_,
                                   MEM_COMMIT,
                                   PAGE_READWRITE ) ==
                     (preg->p_pages + preg->first_uncommitted_index) )
                {
                    /*
                     * Initialize the committed pages.
                     */
                    for ( j = preg->first_uncommitted_index,
                            ppage = preg->p_pages + j ;
                          j < i ; j++, ppage++ )
                    {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = _PARAS_PER_PAGE;
                        memset(ppage->alloc_map, 0, sizeof(ppage->alloc_map));
#ifdef _MARK_SBH
                        *(DWORD *)&ppage->sentinel = 0x486253FF;    // SbH
#else
                        ppage->sentinel = (__map_t)-1;
#endif
                        ppage->preg = &__small_block_heap;
                        preg->region_map[j] = _PARAS_PER_PAGE;
                        preg->last_failed_alloc[j] = _NO_FAILED_ALLOC;
                    }

                    /*
                     * Update __sbh_p_starting_region
                     */
                    __sbh_p_starting_region = preg;

                    /*
                     * Update the first_uncommitted_index for the region.
                     */
                    while ( (i < _PAGES_PER_REGION) &&
                            (preg->region_map[i] != _UNCOMMITTED_PAGE) )
                        i++;

                    j = preg->first_uncommitted_index;

                    preg->first_uncommitted_index = (i < _PAGES_PER_REGION) ?
                                                    i : _NO_INDEX;

                    /*
                     * Fulfill the allocation request using the first of the
                     * newly committed pages.
                     */
                    ppage = preg->p_pages + j;
                    ppage->alloc_map[0] = (__map_t)para_req;

                    /*
                     * Update the starting_page_index field in the region
                     * descriptor and region_map[] entry for the page. Also,
                     * update the starting_para_index field in the page.
                     */
                    preg->starting_page_index = j;
                    preg->region_map[j] -= (__map_t)para_req;

                    /*
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields of the page.
                     */
                    ppage->pstarting_alloc_map = &(ppage->alloc_map[para_req]);
                    ppage->free_paras_at_start -= para_req;

                    /*
                     * Return pointer to allocated paragraphs.
                     */
                    return (void *)&(((preg->p_pages + j)->alloc_blocks)[0]);
                }
                else {
                    /*
                     * Attempt to commit the pages failed. Return failure, the
                     * allocation will be attempted in the Win32 heap manager.
                     */
                    return NULL;
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        /*
         * Failure so far. None of the pages have a big enough free area to
         * fulfill the pending request. All of the pages in all of the current
         * regions are committed. Therefore, try to create a new region.
         */
        if ( (preg = __sbh_new_region()) != NULL ) {
            /*
             * Success! A new region has been created and the first few pages
             * (_PAGES_PER_COMMITMENT to be exact) have been committed.
             * satisfy the request out of the first page of the new region.
             */
            ppage = preg->p_pages;
            ppage->alloc_map[0] = (__map_t)para_req;

            __sbh_p_starting_region = preg;
            ppage->pstarting_alloc_map = &(ppage->alloc_map[para_req]);
            ppage->free_paras_at_start = _PARAS_PER_PAGE - para_req;
            (preg->region_map)[0] -= (__map_t)para_req;
            return (void *)&((preg->p_pages->alloc_blocks)[0]);
        }

        /*
         * Everything has failed, return NULL
         */
        return NULL;
}


/***
*void * __sbh_alloc_block_from_page(ppage, free_para_count, para_req) -
*       allocate a block from the given page.
*
*Purpose:
*       Allocate a block from the specified page of the small-block heap, of
*       the specified number of paragraphs in size.
*
*Entry:
*       __sbh_page_t *  ppage           - pointer to a page in the small-block
*                                         heap
*       int             free_para_count - number of free paragraphs in *ppage
*       size_t          para_req        - size of the allocation request in
*                                         paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, otherwise.
*
*Exceptions:
*       It is assumed that free_para_count >= para_req on entry. This must be
*       guaranteed by the caller. The behavior is undefined if this condition
*       is violated.
*
*******************************************************************************/

void * __cdecl __sbh_alloc_block_from_page (
        __sbh_page_t *  ppage,
        size_t          free_para_count,
        size_t          para_req
        )
{
        __map_t *   pmap1;
        __map_t *   pmap2;
        __map_t *   pstartmap;
        size_t      contiguous_free;

        /*
         * Start at start_para_index and walk towards the end of alloc_map[],
         * looking for a string of free paragraphs big enough to satisfy the
         * the current request.
         */
        pmap1 = pstartmap = ppage->pstarting_alloc_map;

        /*
         * Check if there are enough free paragraphs are pstarting_alloc_map
         * to satisfy the pending allocation request.
         */
        if ( ppage->free_paras_at_start >= para_req ) {
            /*
             * Success right off!
             * Mark the alloc_map entry with the size of the allocation
             * request.
             */
            *pmap1 = (__map_t)para_req;

            /*
             * Update the pstarting_alloc_map and free_paras_at_start fields
             * in the page.
             */
            if ( pmap1 + para_req < &(ppage->sentinel) ) {
                ppage->pstarting_alloc_map += para_req;
                ppage->free_paras_at_start -= para_req;
            }
            else {
                ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                ppage->free_paras_at_start = 0;
            }

            /*
             * Derive and return a pointer to the newly allocated
             * paragraphs.
             */
            return (void *)&(ppage->alloc_blocks[pmap1 -
                &(ppage->alloc_map[0])]);
        }

        /*
         * See if the search loop can be started just beyond the paragraphs
         * examined above. Note, this test assumes sentinel != _FREE_PARA!
         */
        if ( *(pmap1 + ppage->free_paras_at_start) != _FREE_PARA )
            pmap1 += ppage->free_paras_at_start;

        while ( pmap1 + para_req < &ppage->sentinel ) {

            if ( *pmap1 == _FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request. Note that the loop below requires that
                 * sentinel != _FREE_PARA to guarantee termination.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs. Do
                     * a little bookkeeping before going on to the next
                     * interation.
                     */

                     /* If pmap1 != pstartmap then these free paragraphs
                     * cannot be revisited.
                     */
                    if ( pmap1 == pstartmap ) {
                        /*
                         * Make sure free_paras_at_start is up-to-date.
                         */
                         ppage->free_paras_at_start = contiguous_free;
                    }
                    else {
                        /*
                         * These free paragraphs will not be revisited!
                         */
                        if ( (free_para_count -= contiguous_free) < para_req )
                            /*
                             * There are not enough unvisited free paragraphs
                             * to satisfy the current request. Return failure
                             * to the caller.
                             */
                            return NULL;
                    }

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields in the page.
                     */
                    if ( pmap1 + para_req < &(ppage->sentinel) ) {
                        ppage->pstarting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = (DWORD)(contiguous_free -
                                                     para_req);
                    }
                    else {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Now start at index 0 in alloc_map[] and walk towards, but not past,
         * index starting_para_index, looking for a string of free paragraphs
         * big enough to satisfy the allocation request.
         */
        pmap1 = &(ppage->alloc_map[0]);

        while ( (pmap1 < pstartmap) &&
                (pmap1 + para_req <= &(ppage->alloc_map[_PARAS_PER_PAGE - 1])) )
        {
            if ( *pmap1 == _FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs.
                     *
                     * Update the count of unvisited free paragraphs.
                     */
                    if ( (free_para_count -= contiguous_free) < para_req )
                        /*
                         * There are not enough unvisited free paragraphs
                         * to satisfy the current request. Return failure
                         * to the caller.
                         */
                        return NULL;

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the pstarting_alloc_map and free_paras_at_start
                     * fields in the page..
                     */
                    if ( pmap1 + para_req < &(ppage->sentinel) ) {
                        ppage->pstarting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = (DWORD)(contiguous_free -
                                                     para_req);
                    }
                    else {
                        ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Return failure.
         */
        return NULL;
}


/***
*size_t __sbh_resize_block(preg, ppage, pmap, new_para_sz) -
*       resize block
*
*Purpose:
*       Resize the specified block from the small-block heap. The allocation
*       block is not moved.
*
*Entry:
*       __sbh_region_t *preg        - pointer to the descriptor for the
*                                     region containing the block
*       __sbh_page_t *  ppage       - pointer to the page containing the
*                                     block
*       __map_t *       pmap        - pointer to the initial alloc_map[]
*                                     entry for the allocation block
*       size_t          new_para_sz - requested new size for the allocation
*                                     block, in paragraphs.
*
*Exit:
*       Returns 1, if successful. Otherwise, 0 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_resize_block (
        __sbh_region_t *preg,
        __sbh_page_t *  ppage,
        __map_t *       pmap,
        size_t          new_para_sz
        )
{
        __map_t *       pmap2;
        __map_t *       pmap3;
        size_t          old_para_sz;
        size_t          free_para_count;
        int             retval = 0;

        if ( (old_para_sz = *pmap) > new_para_sz ) {
            /*
             *  The allocation block is to be shrunk.
             */
            *pmap = (__map_t)new_para_sz;

            preg->region_map[ppage - preg->p_pages] += (__map_t)(old_para_sz - new_para_sz);
            preg->last_failed_alloc[ppage - preg->p_pages] = _NO_FAILED_ALLOC;

            retval++;
        }
        else if ( old_para_sz < new_para_sz ) {
            /*
             * The allocation block is to be grown to new_para_sz paragraphs
             * (if possible).
             */
            if ( pmap + new_para_sz <= &(ppage->sentinel) ) {
                /*
                 * Determine if there are sufficient free paragraphs to
                 * expand the block to the desired new size.
                 */
                for ( pmap2 = pmap + old_para_sz,
                        pmap3 = pmap + new_para_sz ;
                      (pmap2 < pmap3) && (*pmap2 == _FREE_PARA) ;
                      pmap2++ ) ;

                if ( pmap2 == pmap3 ) {
                    /*
                     * Success, mark the resized allocation
                     */
                    *pmap = (__map_t)new_para_sz;

                    /*
                     * Check whether the pstarting_alloc_map and the
                     * free_paras_at_start fields need to be updated.
                     */
                    if ( (pmap <= ppage->pstarting_alloc_map) &&
                         (pmap3 > ppage->pstarting_alloc_map) )
                    {
                        if ( pmap3 < &(ppage->sentinel) ) {
                            ppage->pstarting_alloc_map = pmap3;
                            /*
                             * Determine how many contiguous free paragraphs
                             * there are starting a *pmap3. Note, this assumes
                             * that sentinel != _FREE_PARA.
                             */
                            for ( free_para_count = 0 ; *pmap3 == _FREE_PARA ;
                                  free_para_count++, pmap3++ ) ;
                            ppage->free_paras_at_start = free_para_count;
                        }
                        else {
                            ppage->pstarting_alloc_map = &(ppage->alloc_map[0]);
                            ppage->free_paras_at_start = 0;
                        }
                    }

                    /*
                     * Update the region_map[] entry.
                     */
                    preg->region_map[ppage - preg->p_pages] -=
                        (__map_t)(new_para_sz - old_para_sz);

                    retval++;
                }
            }
        }

        return retval;
}


/***
*void * __sbh_heap_check() - check small-block heap
*
*Purpose:
*       Perform validity checks on the small-block heap.
*
*Entry:
*       There are no arguments.
*
*Exit:
*       Returns 0 if the small-block is okay.
*       Returns < 0 if the small-block heap has an error. The exact value
*       identifies where, in the source code below, the error was detected.
*
*Exceptions:
*       There is no protection against memory access error (exceptions).
*
*******************************************************************************/

int __cdecl __sbh_heap_check (
        void
        )
{
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        int                 uncommitted_pages;
        int                 free_paras_in_page;
        int                 contiguous_free_paras;
        int                 starting_region_found;
        int                 pstarting_alloc_map_found;
        int                 i, j, k;

        starting_region_found = 0;
        preg = &__small_block_heap;
        do {
            if ( __sbh_p_starting_region == preg )
                starting_region_found++;

            if ( (ppage = preg->p_pages) != NULL ) {
                /*
                 * Scan the pages of the region looking for
                 * inconsistencies.
                 */
                for ( i = 0, uncommitted_pages = 0, ppage = preg->p_pages ;
                      i < _PAGES_PER_REGION ;
                      i++, ppage++ )
                {
                    if ( preg->region_map[i] == _UNCOMMITTED_PAGE ) {
                        /*
                         * Verify the first_uncommitted_index field.
                         */
                        if ( (uncommitted_pages == 0) &&
                             (preg->first_uncommitted_index != i) )
                        {
                            OUTDBG("Bad first_uncommitted_index field");
                            return -1;
                        }

                        uncommitted_pages++;
                    }
                    else {

                        if ( ppage->pstarting_alloc_map >=
                             &(ppage->sentinel) )
                        {
                            OUTDBG("Bad pstarting_alloc_map field");
                            return -2;
                        }

                        if ( ppage->sentinel != (__map_t)-1 )
                        {
                            OUTDBG("Bad sentinel field");
                            return -3;
                        }

                        /*
                         * Scan alloc_map[].
                         */
                        j  = 0;
                        pstarting_alloc_map_found = 0;
                        free_paras_in_page = 0;
                        contiguous_free_paras = 0;

                        while ( j < _PARAS_PER_PAGE ) {
                            /*
                             * Look for the *pstarting_alloc_map.
                             */
                            if ( &(ppage->alloc_map[j]) ==
                                 ppage->pstarting_alloc_map )
                                pstarting_alloc_map_found++;

                            if ( ppage->alloc_map[j] == _FREE_PARA ) {
                                /*
                                 * Free paragraph, increment the count.
                                 */
                                free_paras_in_page++;
                                contiguous_free_paras++;
                                j++;
                            }
                            else {
                                /*
                                 * First paragraph of an allocated block.
                                 */

                                /*
                                 * Make sure the preceding free block, if any,
                                 * was smaller than the last_failed_alloc[]
                                 * entry for the page.
                                 */
                                if ( contiguous_free_paras >=
                                     (int)preg->last_failed_alloc[i] )
                                {
                                     OUTDBG("last_failed_alloc[i] was mismarked!");
                                     return -4;
                                }

                                /*
                                 * If this is the end of the string of free
                                 * paragraphs starting at *pstarting_alloc_map,
                                 * verify that free_paras_at_start is
                                 * reasonable.
                                 */
                                if ( pstarting_alloc_map_found == 1 ) {
                                    if ( contiguous_free_paras <
                                         (int)ppage->free_paras_at_start )
                                    {
                                         OUTDBG("free_paras_at_start not reasonable");
                                         return -5;
                                    }
                                    else
                                        /*
                                         * Set flag to 2 so the check is not
                                         * repeated.
                                         */
                                        pstarting_alloc_map_found++;
                                }

                                contiguous_free_paras = 0;

                                /*
                                 * Scan the remaining paragraphs and make
                                 * sure they are marked properly (they should
                                 * look like free paragraphs).
                                 */
                                for ( k = j + 1 ;
                                      k < j + ppage->alloc_map[j] ; k++ )
                                {
                                    if ( ppage->alloc_map[k] != _FREE_PARA )
                                    {
                                        OUTDBG("alloc_map[k] is mismarked!");
                                        return -6;
                                    }
                                }

                                j = k;
                            }
                        }

                        if ( free_paras_in_page != preg->region_map[i] )
                        {
                            OUTDBG("region_map[i] does not match the number of free paragraphs in the page!");
                            return -7;
                        }

                        if ( pstarting_alloc_map_found == 0 )
                        {
                            OUTDBG("Bad pstarting_alloc_map field!");
                            return -8;
                        }
                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__small_block_heap );

        if ( starting_region_found == 0 )
        {
            OUTDBG("Bad __sbh_p_starting_region!");
            return -9;
        }

        return 0;
}

int __cdecl __sbh_process_detach()
{
   __sbh_decommit_pages(INT_MAX);
   return(   __small_block_heap.p_next_region == &__small_block_heap
          && __small_block_heap.p_prev_region == &__small_block_heap
          && __small_block_heap.p_pages == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\fontlinkcore\fontlinkcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       fontlinkcf.cxx
//
//  Contents:   Class factory for fontlinking objects.
//
//----------------------------------------------------------------------------

#ifndef X_FONTLINKCORE_HXX_
#define X_FONTLINKCORE_HXX_
#include "fontlinkcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef NEVER 

extern CUnicodeRanges g_UnicodeRanges;

CFontLinkCF::CFontLinkCF()
{
    _cRef = 0;
    AddRef();
}

CFontLinkCF::~CFontLinkCF()
{
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::QueryInterface(
    REFIID riid,
    void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (IsEqualGUID(IID_IClassFactory, riid))
    {
        *ppvObject = static_cast<IClassFactory *>(this);
    }

    if (*ppvObject)
    {
        static_cast<IUnknown *>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CFontLinkCF::AddRef()
{
    InterlockedIncrement(reinterpret_cast<long *>(&_cRef));
    return _cRef;
}

ULONG STDMETHODCALLTYPE CFontLinkCF::Release()
{
    InterlockedDecrement(reinterpret_cast<long *>(&_cRef));

    //_ASSERT(_cRef != 0);    // This object is created on the stack

    return _cRef;
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID riid, 
    void ** ppvObject)
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    // Just say no to aggregation.
    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Query for requested interface
    if (IsEqualGUID(IID_IUnicodeScriptMapper, riid))
    {
        return g_UnicodeRanges.QueryInterface(riid, ppvObject);
    }

    // Query for requested interface
    return QueryInterface(riid, ppvObject);
}

HRESULT STDMETHODCALLTYPE CFontLinkCF::LockServer(
    BOOL fLock)
{
    if (fLock)
        AddRef();
    else
        Release();

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\trirt\strutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       strutil.cxx
//
//  Contents:   These string comparison functions replace the C runtime's
//              implementation. They use the correct locale for string
//              comparison and make it unnecessary to link to the C runtime.
//
//              Also contains our versions of the _is??? C-Runtime functions
//
//  Note:       For Far East compatibility, the case insensitive compare functions
//              should also ignore char width (single-byte 'a' is the same
//              as double-byte 'a') and kana type (this is Japanese-specific).
//  NOTE:       How do we convert the internal Unicode representation to BDCS?
//              Is it possible to convert in a way that we can avoid these extra
//              comparison attributes for performance's sake?
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTYPE_H_
#define X_CTYPE_H_
#include <ctype.h>
#endif

#if defined(_MAC) && !defined(_MACUNICODE)
#define RETURN_TYPE int
#else
#define RETURN_TYPE int __cdecl
#endif

// IEUNIX: From NT's string.h  Where should this go?
#ifdef UNIX
#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif
#endif

//  "Language-Neutral" on downlevel platforms - this just uses the user locale info.
//  "Language-Invariant" is only available on Whistler.
//  US English has the same sort order for string comparisions as Language Invariant, and is supported on downlevel, so we use that.
const LCID g_lcidLangInvariant = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);

#ifndef IsCharDigit
BOOL
IsCharDigit(TCHAR ch)
{
    return (unsigned)(ch - L'0') <= (L'9' - L'0');
}
#endif

BOOL
_tcsequal(const TCHAR *string1, const TCHAR *string2)
{
    // This function optimizes the case where all we want to find
    // is if the strings are equal and do not care about the relative
    // ordering of the strings.

    while (*string1)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;

    }
    return (*string2) ? (FALSE) : (TRUE);
}

BOOL
_tcsiequal(const TCHAR *string1, const TCHAR *string2)
{
    // NOTE: Doing two CharLowerBuffs per char is way way too expensive
#if DBG==1
    BOOL fSlowCheck;
    LPCTSTR strdbg1 = string1, strdbg2 = string2;
    // This function optimizes the case where all we want to find
    // is if the strings are equal and do not care about the relative
    // ordering of the strings (or CaSe).

    while (*strdbg1)
    {
        TCHAR ch1 = *strdbg1;
        TCHAR ch2 = *strdbg2;

        CharLowerBuff(&ch1, 1);
        CharLowerBuff(&ch2, 1);

        if (ch1 != ch2)
        {
            fSlowCheck = FALSE;
            goto SlowDone;
        }

        strdbg1 += 1;
        strdbg2 += 1;

    }
    fSlowCheck = (*strdbg2) ? (FALSE) : (TRUE);

SlowDone:
#endif

    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    Assert( fSlowCheck == (cc == CSTR_EQUAL) );

    return cc == CSTR_EQUAL;
}

BOOL
_tcsnpre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(string1);
    if (cch2 == -1)
        cch2 = _tcslen(string2);
    return( cch1 <= cch2
        &&  CompareString(g_lcidLangInvariant,
                          0,
                          string1, cch1,
                          string2, cch1) == 2);
}

BOOL
_tcsnipre(const TCHAR * string1, int cch1, const TCHAR * string2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(string1);
    if (cch2 == -1)
        cch2 = _tcslen(string2);
    return( cch1 <= cch2
        &&  CompareString(g_lcidLangInvariant,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                string1, cch1, string2, cch1) == 2);
}

#ifndef WIN16
RETURN_TYPE
_tcscmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString( g_lcidLangInvariant,
                        0, string1, -1, string2, -1);

    if ( cc > 0 )
        return(cc - 2);     //  CompareString returns values in the 1..3 range
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcscmpLoc(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault, 0, string1, -1, string2, -1);

    if ( cc > 0 )
        return(cc - 2);     //  CompareString returns values in the 1..3 range
    else
        return _NLSCMPERROR;
}


// Matches behavior of CRT's _wcsicmp -- case insensitive, lexographic (i.e. stringsort
// instead of wordsort), locale insensitive.
RETURN_TYPE
_wcsicmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(0,   // deliberately NOT locale sensitive
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE | SORT_STRINGSORT,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}

RETURN_TYPE
_tcsicmp(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsicmpLoc(const wchar_t *string1, const wchar_t *string2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, -1,
                       string2, -1);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}



RETURN_TYPE
_tcsncmp(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant,
                       0,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsncmpLoc(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       0,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
            return(cc - 2);
    else
        return _NLSCMPERROR;
}

RETURN_TYPE
_tcsnicmp(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidLangInvariant, 
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}
RETURN_TYPE
_tcsnicmpLoc(const wchar_t *string1, int cch1, const wchar_t *string2, int cch2)
{
    int cc;

    cc = CompareString(g_lcidUserDefault,
                       NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                       string1, cch1,
                       string2, cch2);

    if ( cc > 0 )
        return(cc - 2);
    else
        return _NLSCMPERROR;
}


//
// CONSIDER -- would it be better to have these inline?
//

RETURN_TYPE
_istspace(TCHAR ch)
{
    return IsCharSpace(ch);
}

RETURN_TYPE
_istdigit(TCHAR ch)
{
    return IsCharDigit(ch);
}

RETURN_TYPE
_istxdigit(TCHAR ch)
{
    return IsCharXDigit(ch);
}

RETURN_TYPE
_istalpha(TCHAR ch)
{
    return IsCharAlpha(ch);
}

RETURN_TYPE
_istalnum(TCHAR ch)
{
    return IsCharAlphaNumeric(ch);
}

RETURN_TYPE
_istprint(TCHAR ch)
{
    return IsCharCntrl(ch) ? 0 : 1;
}

RETURN_TYPE
isspace(int ch)
{
    return IsCharSpace((USHORT)ch);
}

RETURN_TYPE
isdigit(int ch)
{
    WORD    charType;

    BOOL fRet = GetStringTypeExA(g_lcidLangInvariant, CT_CTYPE1, (LPCSTR) &ch, 1, &charType);
    if (!fRet)
        return 0;

    return (charType & C1_DIGIT) ? 1: 0;
}

RETURN_TYPE
isalpha(int ch)
{
    WORD    charType;

    BOOL fRet = GetStringTypeExA(g_lcidLangInvariant, CT_CTYPE1, (LPCSTR) &ch, 1, &charType);
    if (!fRet)
        return 0;

    return (charType & C1_ALPHA) ? 1: 0;
}

RETURN_TYPE
iswspace(wchar_t ch)
{
    return IsCharSpace(ch);
}

#endif // !WIN16

//+------------------------------------------------------------------------
//
//  Member:     _7csicmp
//
//  Synopsis:   Compare two 7 bit ascii strings case insensitive
//
//-------------------------------------------------------------------------

int
_7csicmp(const TCHAR *pch1, const TCHAR *pch2)
{
    while (*pch1)
    {
        TCHAR ch1 = *pch1 >= _T('a') && *pch1 <= _T('z') ?
                *pch1 + _T('A') - _T('a') : *pch1;

        TCHAR ch2 = *pch2 >= _T('a') && *pch2 <= _T('z') ?
                *pch2 + _T('A') - _T('a') : *pch2;

        if (ch1 > ch2)
            return 1;
        else if (ch1 < ch2)
            return -1;

        pch1 += 1;
        pch2 += 1;
    }

    return *pch2 ? -1 : 0;
}


//+------------------------------------------------------------------------
//
//  Member:     _7cscmp
//
//  Synopsis:   Compare two 7 bit ascii strings case insensitive
//
//-------------------------------------------------------------------------

int
_7cscmp(const TCHAR *pch1, const TCHAR *pch2)
{
    while (*pch1)
    {
        TCHAR ch1 = *pch1;
        TCHAR ch2 = *pch2;

        if (ch1 > ch2)
            return 1;
        else if (ch1 < ch2)
            return -1;

        pch1 += 1;
        pch2 += 1;
    }

     return *pch2 ? -1 : 0;
}

BOOL
_7csnipre(const TCHAR * pch1, int cch1, const TCHAR * pch2, int cch2)
{
    if (cch1 == -1)
        cch1 = _tcslen(pch1);
    if (cch2 == -1)
        cch2 = _tcslen(pch2);
    if (cch1 <= cch2)
    {
        while (cch1)
        {
            TCHAR ch1 = *pch1 >= _T('a') && *pch1 <= _T('z') ?
                    *pch1 + _T('A') - _T('a') : *pch1;

            TCHAR ch2 = *pch2 >= _T('a') && *pch2 <= _T('z') ?
                    *pch2 + _T('A') - _T('a') : *pch2;

            if (ch1 != ch2)
                return FALSE;

            pch1 += 1;
            pch2 += 1;
            cch1--;
        }
        return TRUE;
    }
    else
        return FALSE;
}

const TCHAR * __cdecl _tcsistr (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(g_lcidLangInvariant,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}
const TCHAR * __cdecl _tcsistrLoc (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(g_lcidUserDefault,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intlcore\fontcoverage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       fontcoverage.cxx
//
//  Contents:   Font face script coverage helpers.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  Function:   EFF_GetFontSignature (EnumFontFamiliesEx callback)
//
//  Synopsis:   Fill font signature and set TrueType flag.
//
//  Returns:    FALSE to immediately stop enumeration.
//
//-----------------------------------------------------------------------------

struct FSBAG {
    FONTSIGNATURE * pfs;
    BOOL * pfTrueType;
};

#pragma warning(disable : 4100)
static int CALLBACK EFF_GetFontSignature(
    ENUMLOGFONTEX * lpelfe,   // [in]
    NEWTEXTMETRICEX * lpntme, // [in]
    DWORD FontType,           // [in]
    LPARAM lParam)            // [in]
{
    FSBAG * pfsbag = (FSBAG *)lParam;

    *pfsbag->pfTrueType = (0 != (TRUETYPE_FONTTYPE & FontType));

    if (*pfsbag->pfTrueType)
    {
        memcpy(pfsbag->pfs, &lpntme->ntmFontSig, sizeof(FONTSIGNATURE));
    }

    return FALSE;
}
#pragma warning(default : 4100)

//+----------------------------------------------------------------------------
//
//  Function:   GetFontSignature
//
//  Synopsis:   Retrieve font signature from font name.
//
//  Returns:    TRUE font has been found. Doen't mean that font signature 
//              has been successfully retrieved. FS is vaild only in case 
//              of True Type font.
//
//-----------------------------------------------------------------------------

BOOL GetFontSignature(
    const wchar_t * pszFontFamilyName, // [in]
    BYTE bCharSet,                     // [in]
    FONTSIGNATURE * pfs,               // [out]
    BOOL * pfTrueType)                 // [out]
{
    HDC hdcScreen = GetDC(NULL);

    LOGFONT lf;
    lf.lfCharSet = bCharSet;
    lf.lfPitchAndFamily = 0;
    StrCpyNW(lf.lfFaceName, pszFontFamilyName, LF_FACESIZE);

    FSBAG fsbag;
    fsbag.pfs = pfs;
    fsbag.pfTrueType = pfTrueType;

    BOOL fRet = (0 == EnumFontFamiliesEx(hdcScreen, &lf, FONTENUMPROC(EFF_GetFontSignature), 
        LPARAM(&fsbag), 0));

    if (!fRet)
    {
        // Ignore charset
        lf.lfCharSet = DEFAULT_CHARSET;
        fRet = (0 == EnumFontFamiliesEx(hdcScreen, &lf, FONTENUMPROC(EFF_GetFontSignature), 
            LPARAM(&fsbag), 0));
    }

    ReleaseDC(NULL, hdcScreen);

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptsFromFontSignature
//
//  Synopsis:   Compute the SCRIPT_IDS information based on the Unicode
//              subrange coverage of the TrueType font.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

static SCRIPT_ID s_asidUnicodeSubRangeScriptMapping[] =
{
    sidAsciiLatin, sidLatin,      sidLatin,      sidLatin,        // 128-131
    sidLatin,      sidLatin,      0,             sidGreek,        // 132-135
    sidGreek,      sidCyrillic,   sidArmenian,   sidHebrew,       // 136-139
    sidHebrew,     sidArabic,     sidArabic,     sidDevanagari,   // 140-143
    sidBengali,    sidGurmukhi,   sidGujarati,   sidOriya,        // 144-147
    sidTamil,      sidTelugu,     sidKannada,    sidMalayalam,    // 148-151
    sidThai,       sidLao,        sidGeorgian,   sidGeorgian,     // 152-155
    sidHangul,     sidLatin,      sidGreek,      0,               // 156-159
    0,             0,             0,             0,               // 160-163
    0,             0,             0,             0,               // 164-167
    0,             0,             0,             0,               // 168-171
    0,             0,             0,             0,               // 172-175
    sidHan,        sidKana,       sidKana,       sidBopomofo,     // 176-179
    sidHangul,     0,             0,             0,               // 180-183
    sidHangul,     sidHangul,     sidHangul,     sidHan,          // 184-187
    0,             sidHan,        0,             0,               // 188-191
    0,             0,             0,             0,               // 192-195
    0,             0,             sidHangul,     0,               // 196-199
};

SCRIPT_IDS GetFontScriptsFromFontSignature(
    const FONTSIGNATURE * pfs)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;
    
    SCRIPT_ID sid;
    unsigned long i;
    DWORD dwUsbBits;
    bool fHangul = false;

    dwUsbBits = pfs->fsUsb[0];
    if (dwUsbBits)
    {
        for (i = 0; i < 32; i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    dwUsbBits = pfs->fsUsb[1];
    if (dwUsbBits)
    {
        fHangul = (0 != (dwUsbBits & 0x01000000)); // USR#56 = 32 + 24

        for (i = 32; i < 64; i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    dwUsbBits = pfs->fsUsb[2];
    if (dwUsbBits)
    {
        // Hack for half-width Kana; Half-width Kana characters fall in
        // U+FFxx Halfwidth and Fullwidth Forms (Unicode Subrange #68),
        // but the subrange contains a mixture of Hangul/Alphanumeric/Kana
        // characters.  To work around this, we claim the font supports
        // half-width kana if it claims to support Unicode Subrange #68,
        // but not #56 (Hangul)

        if (!fHangul && (dwUsbBits & 0x00000010)) // USR#68 = 64 + 4
        {
            sids |= ScriptBit(sidHalfWidthKana);
        }

        for (i = 64; i < ARRAY_SIZE(s_asidUnicodeSubRangeScriptMapping); i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    //
    // Do some additional tweaking
    //

    if (sids)
    {
        if (sids & ScriptBit(sidAsciiLatin))
        {
            // HACKHACK (cthrash) This is a hack. We want to be able to
            // turn off, via CSS, this bit.  This will allow FE users
            // to pick a Latin font for their punctuation.  For now,
            // we just will basically never fontlink for sidAsciiSym
            // because virtually no font is lacking sidAsciiLatin
            // coverage.

            sids |= ScriptBit(sidAsciiSym);
        }

        sids |= ScriptBit(sidEUDC);
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetScriptsFromCharset
//
//  Synopsis:   Compute the SCRIPT_IDS information based on charset.
//              Used for non-TrueType fonts.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

const SCRIPT_IDS s_asidsTable[] =
{
    #define SIDS_BASIC_LATIN 0
    ScriptBit(sidDefault) |
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidLatin) |
    ScriptBit(sidCurrency) |
    ScriptBit(sidEUDC),

    #define SIDS_CYRILLIC 1
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidCyrillic) |
    ScriptBit(sidEUDC),

    #define SIDS_GREEK 2
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidGreek) |
    ScriptBit(sidEUDC),

    #define SIDS_HEBREW 3
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidHebrew) |
    ScriptBit(sidEUDC),

    #define SIDS_ARABIC 4
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidArabic) |
    ScriptBit(sidEUDC),

    #define SIDS_THAI 5
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidThai) |
    ScriptBit(sidEUDC),

    #define SIDS_JAPANESE 6
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidKana) |
    ScriptBit(sidHalfWidthKana) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_CHINESE 7
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidKana) |
    ScriptBit(sidBopomofo) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_HANGUL 8
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidHangul) |
    ScriptBit(sidKana) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_ALL 9
    sidsAll
};

const BYTE s_asidsIndex[256] =
{
    SIDS_BASIC_LATIN,    //   0 ANSI_CHARSET
    SIDS_ALL,            //   1 DEFAULT_CHARSET
    SIDS_ALL,            //   2 SYMBOL_CHARSET
    SIDS_ALL,            //   3 
    SIDS_ALL,            //   4 
    SIDS_ALL,            //   5 
    SIDS_ALL,            //   6 
    SIDS_ALL,            //   7 
    SIDS_ALL,            //   8 
    SIDS_ALL,            //   9 
    SIDS_ALL,            //  10 
    SIDS_ALL,            //  11 
    SIDS_ALL,            //  12 
    SIDS_ALL,            //  13 
    SIDS_ALL,            //  14 
    SIDS_ALL,            //  15 
    SIDS_ALL,            //  16 
    SIDS_ALL,            //  17 
    SIDS_ALL,            //  18 
    SIDS_ALL,            //  19 
    SIDS_ALL,            //  20 
    SIDS_ALL,            //  21 
    SIDS_ALL,            //  22 
    SIDS_ALL,            //  23 
    SIDS_ALL,            //  24 
    SIDS_ALL,            //  25 
    SIDS_ALL,            //  26 
    SIDS_ALL,            //  27 
    SIDS_ALL,            //  28 
    SIDS_ALL,            //  29 
    SIDS_ALL,            //  30 
    SIDS_ALL,            //  31 
    SIDS_ALL,            //  32 
    SIDS_ALL,            //  33 
    SIDS_ALL,            //  34 
    SIDS_ALL,            //  35 
    SIDS_ALL,            //  36 
    SIDS_ALL,            //  37 
    SIDS_ALL,            //  38 
    SIDS_ALL,            //  39 
    SIDS_ALL,            //  40 
    SIDS_ALL,            //  41 
    SIDS_ALL,            //  42 
    SIDS_ALL,            //  43 
    SIDS_ALL,            //  44 
    SIDS_ALL,            //  45 
    SIDS_ALL,            //  46 
    SIDS_ALL,            //  47 
    SIDS_ALL,            //  48 
    SIDS_ALL,            //  49 
    SIDS_ALL,            //  50 
    SIDS_ALL,            //  51 
    SIDS_ALL,            //  52 
    SIDS_ALL,            //  53 
    SIDS_ALL,            //  54 
    SIDS_ALL,            //  55 
    SIDS_ALL,            //  56 
    SIDS_ALL,            //  57 
    SIDS_ALL,            //  58 
    SIDS_ALL,            //  59 
    SIDS_ALL,            //  60 
    SIDS_ALL,            //  61 
    SIDS_ALL,            //  62 
    SIDS_ALL,            //  63 
    SIDS_ALL,            //  64 
    SIDS_ALL,            //  65 
    SIDS_ALL,            //  66 
    SIDS_ALL,            //  67 
    SIDS_ALL,            //  68 
    SIDS_ALL,            //  69 
    SIDS_ALL,            //  70 
    SIDS_ALL,            //  71 
    SIDS_ALL,            //  72 
    SIDS_ALL,            //  73 
    SIDS_ALL,            //  74 
    SIDS_ALL,            //  75 
    SIDS_ALL,            //  76 
    SIDS_BASIC_LATIN,    //  77 MAC_CHARSET
    SIDS_ALL,            //  78 
    SIDS_ALL,            //  79 
    SIDS_ALL,            //  80 
    SIDS_ALL,            //  81 
    SIDS_ALL,            //  82 
    SIDS_ALL,            //  83 
    SIDS_ALL,            //  84 
    SIDS_ALL,            //  85 
    SIDS_ALL,            //  86 
    SIDS_ALL,            //  87 
    SIDS_ALL,            //  88 
    SIDS_ALL,            //  89 
    SIDS_ALL,            //  90 
    SIDS_ALL,            //  91 
    SIDS_ALL,            //  92 
    SIDS_ALL,            //  93 
    SIDS_ALL,            //  94 
    SIDS_ALL,            //  95 
    SIDS_ALL,            //  96 
    SIDS_ALL,            //  97 
    SIDS_ALL,            //  98 
    SIDS_ALL,            //  99 
    SIDS_ALL,            // 100 
    SIDS_ALL,            // 101 
    SIDS_ALL,            // 102 
    SIDS_ALL,            // 103 
    SIDS_ALL,            // 104 
    SIDS_ALL,            // 105 
    SIDS_ALL,            // 106 
    SIDS_ALL,            // 107 
    SIDS_ALL,            // 108 
    SIDS_ALL,            // 109 
    SIDS_ALL,            // 110 
    SIDS_ALL,            // 111 
    SIDS_ALL,            // 112 
    SIDS_ALL,            // 113 
    SIDS_ALL,            // 114 
    SIDS_ALL,            // 115 
    SIDS_ALL,            // 116 
    SIDS_ALL,            // 117 
    SIDS_ALL,            // 118 
    SIDS_ALL,            // 119 
    SIDS_ALL,            // 120 
    SIDS_ALL,            // 121 
    SIDS_ALL,            // 122 
    SIDS_ALL,            // 123 
    SIDS_ALL,            // 124 
    SIDS_ALL,            // 125 
    SIDS_ALL,            // 126 
    SIDS_ALL,            // 127 
    SIDS_JAPANESE,       // 128 SHIFTJIS_CHARSET
    SIDS_HANGUL,         // 129 HANGEUL_CHARSET
    SIDS_HANGUL,         // 130 JOHAB_CHARSET
    SIDS_ALL,            // 131 
    SIDS_ALL,            // 132 
    SIDS_ALL,            // 133 
    SIDS_CHINESE,        // 134 GB2312_CHARSET
    SIDS_ALL,            // 135 
    SIDS_CHINESE,        // 136 CHINESEBIG5_CHARSET
    SIDS_ALL,            // 137 
    SIDS_ALL,            // 138 
    SIDS_ALL,            // 139 
    SIDS_ALL,            // 140 
    SIDS_ALL,            // 141 
    SIDS_ALL,            // 142 
    SIDS_ALL,            // 143 
    SIDS_ALL,            // 144 
    SIDS_ALL,            // 145 
    SIDS_ALL,            // 146 
    SIDS_ALL,            // 147 
    SIDS_ALL,            // 148 
    SIDS_ALL,            // 149 
    SIDS_ALL,            // 150 
    SIDS_ALL,            // 151 
    SIDS_ALL,            // 152 
    SIDS_ALL,            // 153 
    SIDS_ALL,            // 154 
    SIDS_ALL,            // 155 
    SIDS_ALL,            // 156 
    SIDS_ALL,            // 157 
    SIDS_ALL,            // 158 
    SIDS_ALL,            // 159 
    SIDS_ALL,            // 160 
    SIDS_GREEK,          // 161 GREEK_CHARSET
    SIDS_BASIC_LATIN,    // 162 TURKISH_CHARSET
    SIDS_BASIC_LATIN,    // 163 VIETNAMESE_CHARSET
    SIDS_ALL,            // 164 
    SIDS_ALL,            // 165 
    SIDS_ALL,            // 166 
    SIDS_ALL,            // 167 
    SIDS_ALL,            // 168 
    SIDS_ALL,            // 169 
    SIDS_ALL,            // 170 
    SIDS_ALL,            // 171 
    SIDS_ALL,            // 172 
    SIDS_ALL,            // 173 
    SIDS_ALL,            // 174 
    SIDS_ALL,            // 175 
    SIDS_ALL,            // 176 
    SIDS_HEBREW,         // 177 HEBREW_CHARSET
    SIDS_ARABIC,         // 178 ARABIC_CHARSET
    SIDS_ALL,            // 179 
    SIDS_ALL,            // 180 
    SIDS_ALL,            // 181 
    SIDS_ALL,            // 182 
    SIDS_ALL,            // 183 
    SIDS_ALL,            // 184 
    SIDS_ALL,            // 185 
    SIDS_BASIC_LATIN,    // 186 BALTIC_CHARSET
    SIDS_ALL,            // 187 
    SIDS_ALL,            // 188 
    SIDS_ALL,            // 189 
    SIDS_ALL,            // 190 
    SIDS_ALL,            // 191 
    SIDS_ALL,            // 192 
    SIDS_ALL,            // 193 
    SIDS_ALL,            // 194 
    SIDS_ALL,            // 195 
    SIDS_ALL,            // 196 
    SIDS_ALL,            // 197 
    SIDS_ALL,            // 198 
    SIDS_ALL,            // 199 
    SIDS_ALL,            // 200 
    SIDS_ALL,            // 201 
    SIDS_ALL,            // 202 
    SIDS_ALL,            // 203 
    SIDS_CYRILLIC,       // 204 RUSSIAN_CHARSET
    SIDS_ALL,            // 205 
    SIDS_ALL,            // 206 
    SIDS_ALL,            // 207 
    SIDS_ALL,            // 208 
    SIDS_ALL,            // 209 
    SIDS_ALL,            // 210 
    SIDS_ALL,            // 211 
    SIDS_ALL,            // 212 
    SIDS_ALL,            // 213 
    SIDS_ALL,            // 214 
    SIDS_ALL,            // 215 
    SIDS_ALL,            // 216 
    SIDS_ALL,            // 217 
    SIDS_ALL,            // 218 
    SIDS_ALL,            // 219 
    SIDS_ALL,            // 220 
    SIDS_ALL,            // 221 
    SIDS_THAI,           // 222 THAI_CHARSET
    SIDS_ALL,            // 223 
    SIDS_ALL,            // 224 
    SIDS_ALL,            // 225 
    SIDS_ALL,            // 226 
    SIDS_ALL,            // 227 
    SIDS_ALL,            // 228 
    SIDS_ALL,            // 229 
    SIDS_ALL,            // 230 
    SIDS_ALL,            // 231 
    SIDS_ALL,            // 232 
    SIDS_ALL,            // 233 
    SIDS_ALL,            // 234 
    SIDS_ALL,            // 235 
    SIDS_ALL,            // 236 
    SIDS_ALL,            // 237 
    SIDS_BASIC_LATIN,    // 238 EASTEUROPE_CHARSET
    SIDS_ALL,            // 239 
    SIDS_ALL,            // 240 
    SIDS_ALL,            // 241 
    SIDS_ALL,            // 242 
    SIDS_ALL,            // 243 
    SIDS_ALL,            // 244 
    SIDS_ALL,            // 245 
    SIDS_ALL,            // 246 
    SIDS_ALL,            // 247 
    SIDS_ALL,            // 248 
    SIDS_ALL,            // 249 
    SIDS_ALL,            // 250 
    SIDS_ALL,            // 251 
    SIDS_ALL,            // 252 
    SIDS_ALL,            // 253 
    SIDS_ALL,            // 254 
    SIDS_ALL             // 255 OEM_CHARSET
};

SCRIPT_IDS GetScriptsFromCharset(
    BYTE bCharSet)
{
    return s_asidsTable[s_asidsIndex[bCharSet]];
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptCoverage
//
//  Synopsis:   Compute the SCRIPT_IDS information based on font family name
//              and charset.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

SCRIPT_IDS GetFontScriptCoverage(
    const wchar_t * pszFontFamilyName,
    BYTE bCharset,
    UINT cp)
{
    SCRIPT_IDS sids = sidsAll;
    SCRIPT_IDS sidsAlt;
    FONTSIGNATURE fs;
    BOOL fTrueType;

    if (!GetFontSignature(pszFontFamilyName, bCharset, &fs, &fTrueType))
        return sids;

    if (fTrueType)
    {
        sids = GetFontScriptsFromFontSignature(&fs);

        //
        // ScriptIDsFromFontSignature() doesn't return complete sids coverage, especially
        // for new fonts.
        // Using IMLangFontLink* interfaces get sids coverage in a different way, which is
        // not a perfect way either.
        // Finally get a union of them.
        //
        // PERF (grzegorz): For Latin1 pages don't load MLang to verify script coverage,
        //                  when asking for ANSI font.
        //
        if (   (bCharset == ANSI_CHARSET)
            && IsLatin1Codepage(cp)
            && !(sids & 0x000000fffffffc00))
        {
            sidsAlt = sids | ScriptBit(sidUserDefined);
#if DBG == 1
            SCRIPT_IDS sidsDbg;
            sidsDbg = mlang().GetFontScripts(pszFontFamilyName);
            Assert((sidsDbg ==  0) || ((sidsDbg | sids) == sidsAlt));
#endif
        }
        else
        {
            sidsAlt = mlang().GetFontScripts(pszFontFamilyName);
        }

        //
        // HACKHACK (grzegorz) MLang may return sidLatin even if the font doesn't cover
        // Latin codepoints. But don't apply this hack in case of hacked fonts, where
        // font signature is 0 (sid == 0).
        //
        if (sids != 0)
            sidsAlt &= ~ScriptBit(sidLatin);

        sids |= sidsAlt;
    }
    else
    {
        sids = GetScriptsFromCharset(bCharset);
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptCoverage
//
//  Synopsis:   Compute the SCRIPT_IDS information based on font family name
//              and charset.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

SCRIPT_IDS GetFontScriptCoverage(
    const wchar_t * pszFontFamilyName,
    HDC hdc,
    HFONT hfont,
    BOOL fTrueType,
    BOOL fFSOnly)
{
    SCRIPT_IDS sids = sidsAll;
    SCRIPT_IDS sidsAlt;
    FONTSIGNATURE fs;
    HFONT hfontOld;
    BYTE bCharset;

    hfontOld = (HFONT)SelectObject(hdc, hfont);
    bCharset = (BYTE)GetTextCharsetInfo(hdc, &fs, 0);
    SelectObject(hdc, hfontOld);

    if (fTrueType)
    {
        sids = GetFontScriptsFromFontSignature(&fs);

        if (!fFSOnly)
        {
            //
            // ScriptIDsFromFontSignature() doesn't return complete sids coverage, especially
            // for new fonts.
            // Using IMLangFontLink* interfaces get sids coverage in a different way, which is
            // not a perfect way either.
            // Finally get a union of them.
            //
            sidsAlt = mlang().GetFontScripts(pszFontFamilyName);

            //
            // HACKHACK (grzegorz) MLang may return sidLatin even if the font doesn't cover
            // Latin codepoints. But don't apply this hack in case of hacked fonts, where
            // font signature is 0 (sid == 0).
            //
            if (sids != 0)
                sidsAlt &= ~ScriptBit(sidLatin);

            sids |= sidsAlt;
        }
    }
    else
    {
        sids = GetScriptsFromCharset(bCharset);
    }

    return sids;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intlcore\multilang.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       multilang.cxx
//
//  Contents:   MLang wrapper.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
// Unix MIDL doesn't output this.
extern "C" const CLSID CLSID_CMultiLanguage;
#endif

const wchar_t * const g_pszArialUnicodeMS = L"Arial Unicode MS";

//+----------------------------------------------------------------------------
//
//  g_asidCPBit
//
//  Code page bit to windows codepage mapping.
//
//-----------------------------------------------------------------------------

const UINT g_aCPCPBit[32] =
{
    /* FS_LATIN1        0x00000001 */ CP_1252,
    /* FS_LATIN2        0x00000002 */ CP_1250,
    /* FS_CYRILLIC      0x00000004 */ CP_1251,
    /* FS_GREEK         0x00000008 */ CP_1253,
    /* FS_TURKISH       0x00000010 */ CP_1254,
    /* FS_HEBREW        0x00000020 */ CP_1255,
    /* FS_ARABIC        0x00000040 */ CP_1256,
    /* FS_BALTIC        0x00000080 */ CP_1257,
    /* FS_VIETNAMESE    0x00000100 */ CP_1258,
    /* FS_UNKNOWN       0x00000200 */ 0,
    /* FS_UNKNOWN       0x00000400 */ 0,
    /* FS_UNKNOWN       0x00000800 */ 0,
    /* FS_UNKNOWN       0x00001000 */ 0,
    /* FS_UNKNOWN       0x00002000 */ 0,
    /* FS_UNKNOWN       0x00004000 */ 0,
    /* FS_UNKNOWN       0x00008000 */ 0,
    /* FS_THAI          0x00010000 */ CP_THAI,
    /* FS_JISJAPAN      0x00020000 */ CP_JPN_SJ,
    /* FS_CHINESESIMP   0x00040000 */ CP_CHN_GB,
    /* FS_WANSUNG       0x00080000 */ CP_KOR_5601,
    /* FS_CHINESETRAD   0x00100000 */ CP_TWN,
    /* FS_JOHAB         0x00200000 */ CP_1361,
    /* FS_UNKNOWN       0x00400000 */ 0,
    /* FS_UNKNOWN       0x00800000 */ 0,
    /* FS_UNKNOWN       0x01000000 */ 0,
    /* FS_UNKNOWN       0x02000000 */ 0,
    /* FS_UNKNOWN       0x04000000 */ 0,
    /* FS_UNKNOWN       0x08000000 */ 0,
    /* FS_UNKNOWN       0x10000000 */ 0,
    /* FS_UNKNOWN       0x20000000 */ 0,
    /* FS_UNKNOWN       0x40000000 */ 0,
    /* FS_SYMBOL        0x80000000 */ CP_SYMBOL,
};

#if DBG == 1
//+----------------------------------------------------------------------------
//
//  Debugging only functions.
//  Accessed only by mshtmpad to support lifetime control API.
//
//-----------------------------------------------------------------------------

void MLangUnload()
{
    mlang().Unload();
}

BOOL IsMLangLoaded()
{
    return mlang().IsLoaded();
}
#endif

//+----------------------------------------------------------------------------
// MLang wrapper object
//-----------------------------------------------------------------------------

CMLang g_MLang;

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CMLang
//
//  Synopsis:   Initializes MLang wrapper object.
//
//-----------------------------------------------------------------------------

CMLang::CMLang()
{
    _pMultiLanguage  = NULL;
    _pMultiLanguage2 = NULL;
    _pMLangFontLink  = NULL;
    _pMLangFontLink2 = NULL;

    _dwInstalledLangPacks = 0;

    _cs.Init();
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CMLang
//
//  Synopsis:   Deinitializes MLang wrapper object.
//
//-----------------------------------------------------------------------------

CMLang::~CMLang()
{
    // TODO (grzegorz): Enable these asserts when ref counting in TLS is fixed.
//    Assert(_pMultiLanguage == NULL);
//    Assert(_pMultiLanguage2 == NULL);
//    Assert(_pMLangFontLink == NULL);
//    Assert(_pMLangFontLink2 == NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::EnsureObjects
//
//  Synopsis:   Make sure MLang is loaded.
//
//-----------------------------------------------------------------------------

#if DBG == 1
void CMLang::EnsureObjects()
{
    if (!_pMultiLanguage) CreateObjects();
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CreateObjects
//
//  Synopsis:   Create MLang object and QI required interfaces.
//
//-----------------------------------------------------------------------------

void CMLang::CreateObjects()
{
    CGuard<CCriticalSection> guard(_cs);

    // Need to check again after locking objects.
    if (!_pMultiLanguage)
    {
        HRESULT hr;

        hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            hr = THR(CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, 
                IID_IMultiLanguage, (void**)&_pMultiLanguage));

            if (SUCCEEDED(hr))
            {
                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMultiLanguage2, (void **)&_pMultiLanguage2));

                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMLangFontLink,  (void **)&_pMLangFontLink));

                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMLangFontLink2, (void **)&_pMLangFontLink2));
            }
            CoUninitialize();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::DestroyObjects
//
//  Synopsis:   Release all MLang interfaces
//
//-----------------------------------------------------------------------------

void CMLang::DestroyObjects()
{
    CGuard<CCriticalSection> guard(_cs);

    if (_pMultiLanguage)
    {
        _pMultiLanguage->Release();
        _pMultiLanguage = NULL;
    }
    if (_pMultiLanguage2)
    {
        _pMultiLanguage2->Release();
        _pMultiLanguage2 = NULL;
    }
    if (_pMLangFontLink)
    {
        _pMLangFontLink->Release();
        _pMLangFontLink = NULL;
    }
    if (_pMLangFontLink2)
    {
        _pMLangFontLink2->Release();
        _pMLangFontLink2 = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::FetchInstalledLangPacks
//
//  Synopsis:   Retrieve information about installed lang packs.
//
//-----------------------------------------------------------------------------

void CMLang::FetchInstalledLangPacks()
{
    DWORD dwInstalledLangPacks = 0;

    EnsureObjects();

    if (_pMultiLanguage2)
    {
        HRESULT hr;
        MIMECPINFO mimeCpInfo;
        UINT cp;

        unsigned long i = 0;
        while (i < ARRAY_SIZE(g_aCPCPBit))
        {
            cp = g_aCPCPBit[i];
            if (cp != 0)
            {
                hr = THR(_pMultiLanguage2->GetCodePageInfo(cp, MLGetUILanguage(), &mimeCpInfo));

                if (SUCCEEDED(hr) && (MIMECONTF_VALID & mimeCpInfo.dwFlags))
                {
                    dwInstalledLangPacks |= (1 << i);
                }
            }
            ++i;
        }
    }

    {
        CGuard<CCriticalSection> guard(_cs);
        if (0 == _dwInstalledLangPacks)
            _dwInstalledLangPacks = dwInstalledLangPacks;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::GetTextCodePages
//
//  Synopsis:   Determine the codepage coverage of requested text.
//
//  Arguments:  [dwPriorityCodePages] - set of code pages caller is interested in
//              [pch]  - text buffer to analyze
//              [pcch] - [in]  size of the text buffer
//                       [out] number of characters analyzed
//
//  Returns:    Codepage coverage as a bit field (FS_*, see wingdi.h).
//              dwPriorityCodePages in case of error.
//
//-----------------------------------------------------------------------------

DWORD CMLang::GetTextCodePages(
    DWORD dwPriorityCodePages,  // [in]
    const wchar_t * pch,        // [in]
    long * pcch)                // [in, out]
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    EnsureObjects();

    if (!_pMLangFontLink)
        return dwPriorityCodePages;

    HRESULT hr;
    DWORD dwRet;
    DWORD dwCodePages = DWORD(-1);
    long cchToCheck = *pcch;

    while (cchToCheck)
    {
        hr = _pMLangFontLink->GetCharCodePages(*pch, &dwRet);
        if (FAILED(hr))
            return (dwCodePages & dwPriorityCodePages);

        // GetCharCodePages for some characters returns 0. In this case for compatibility
        // reasons we need to have the same behavior as MLang's GetStrCodePages, so we
        // set codepages bits to 1.
        if (!dwRet)
            dwRet = (DWORD)~0;

        dwRet &= dwPriorityCodePages;
        if (dwCodePages == DWORD(-1))
        {
            dwCodePages = dwRet;
        }
        else if (dwCodePages != dwRet)
        {
            break;
        }
        --cchToCheck;
        ++pch;
    }

    *pcch -= cchToCheck;

    return (dwCodePages & dwPriorityCodePages);
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::GetFontScripts
//
//  Synopsis:   Determine the script coverage of requested font family.
//
//  Arguments:  [pszFontFamilyName] - font family name
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//              sidsNotSet in case of error.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS CMLang::GetFontScripts(
    const wchar_t * pszFontFamilyName)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;

    EnsureObjects();

    //
    // FUTURE (grzegorz) At this point we should use IMLangFontLink3::GetFontScritps()
    // Since this interface is not implemented yet we use IMLangFontLink3::GetScriptFontInfo()
    // to get sids supported by the font.
    //

    if (!_pMLangFontLink2)
        return sids;

    HRESULT hr;
    SCRIPT_ID sid;
    UINT uFont;
    UINT csfi = 32;     // Initial buffer size
    SCRIPTFONTINFO * lpPreFail;
    SCRIPTFONTINFO * psfi = (SCRIPTFONTINFO *)HeapAlloc(GetProcessHeap(), 0, sizeof(SCRIPTFONTINFO) * csfi);
    if (psfi == NULL)
        goto Cleanup;

    //
    // We can skip sidDefault and sidMerge (they are artificial sids)
    // To improve perf we can start with sidAsciiLatin and then enumerate 
    // rest of sids.
    // NOTE: sidLatin implies sidAsciiLatin, so we can skip it.
    //

    sid = sidAsciiLatin;
    while (sid != sidLim)
    {
        BOOL fFixedPitch = FALSE; // First check variable pitch fonts
        BOOL fAtFont = (pszFontFamilyName[0] == L'@');

        do
        {
            UINT cFonts = 0;
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, fFixedPitch ? SCRIPTCONTF_FIXED_FONT : 0, &cFonts, NULL));

            if (SUCCEEDED(hr) && cFonts)
            {
                if (cFonts > csfi)
                {
                    csfi = ((cFonts / csfi) + 1) * csfi;
                    lpPreFail =  psfi;
#pragma prefast(suppress:308, "noise")
                    psfi = (SCRIPTFONTINFO *)HeapReAlloc(GetProcessHeap(), 0, (void *)psfi, sizeof(SCRIPTFONTINFO) * csfi);
                    if (psfi == NULL)
                    {
                        psfi =  lpPreFail;
                        goto Cleanup;
                    }
                }
                hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, fFixedPitch ? SCRIPTCONTF_FIXED_FONT : 0, &cFonts, psfi));

                if (SUCCEEDED(hr))
                {
                    for (uFont = 0; uFont < cFonts; uFont++)
                    {
                        if (0 == _wcsicmp(pszFontFamilyName, psfi[uFont].wszFont))
                        {
                            sids = psfi[uFont].scripts;
                            break;
                        }
                        else if (fAtFont)
                        {
                            if (0 == _wcsicmp(pszFontFamilyName + 1, psfi[uFont].wszFont))
                            {
                                sids = psfi[uFont].scripts;
                                break;
                            }
                        }
                    }
                }
            }

            fFixedPitch = !fFixedPitch;
        } while (fFixedPitch && sids == sidsNotSet);

        if (sids != sidsNotSet)
            break;

        if (sid == sidAsciiLatin)
            sid = sidAsciiSym;
        else if (sid == sidAsciiSym)
            sid = sidGreek;
        else
            ++sid;
    }
Cleanup:
    if (psfi)
        HeapFree(GetProcessHeap(), 0, (void *)psfi);

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::ValidateCodePage
//
//  Synopsis:   Validate codepage using MLang, optionally do IOD.
//
//  Arguments:  [cpSystem]    - system default codepage
//              [cp]          - requested code page
//              [hwnd]        - window handle for UI feedback
//              [fUserSelect] - selected by the user?
//              [fSilent]     - silent mode?
//
//  Returns:    S_OK if codepage is valid.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::ValidateCodePage(
    UINT cpSystem,
    UINT cp, 
    HWND hwnd, 
    BOOL fUserSelect, 
    BOOL fSilent)
{
    //
    // When _pMultiLanguage2 is NULL it's not a success,
    // but we don't want to fail.
    //
    HRESULT hr = S_OK;

    //
    // CP_1252 is always valid codepage.
    // Latin 1 (CP_ISO_8859_1) is always valid on Wester European systems.
    // Unicode and utf-8 are always valid.
    //
    if (   cp == CP_1252 
        || (cp == CP_ISO_8859_1 && cpSystem == CP_1252)
        || cp == CP_UCS_2
        || cp == CP_UTF_8)
    {
        return hr;
    }

    EnsureObjects();

    if (_pMultiLanguage2)
    {
        DWORD dwfIODControl = 0;
        dwfIODControl |= fSilent ? CPIOD_PEEK : 0;
        dwfIODControl |= fUserSelect ? CPIOD_FORCE_PROMPT : 0;

        hr = THR(_pMultiLanguage2->ValidateCodePageEx(cp, hwnd, dwfIODControl));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::IsConvertible
//
//  Synopsis:   Decides if conversion is possible.
//
//  Arguments:  [cpSrcEncoding] - source encoding
//              [cpDstEncoding] - destination encoding
//
//  Returns:    S_OK if conversion is possible.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::IsConvertible(
    UINT cpSrcEncoding, 
    UINT cpDstEncoding)
{
    // Auto select is always convertible to Unicode
    if (cpSrcEncoding == CP_AUTO && cpDstEncoding == CP_UCS_2)
        return S_OK;

    EnsureObjects();
    return _pMultiLanguage ? _pMultiLanguage->IsConvertible(cpSrcEncoding, cpDstEncoding) : E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::ScriptAppropriateFaceName
//
//  Synopsis:   Queries MLANG for fonts that supports a particular script.
//
//  Arguments:  [sid]          - script id
//              [pchPropName]  - pointer to array containing proportional font 
//                               name appropriate for the script.
//                               assuming size = LF_FACESIZE.
//              [pchFixedName] - pointer to array containing fixed pitch font 
//                               name appropriate for the script. 
//                               assuming size = LF_FACESIZE.
//
//  Returns:    S_OK if successful.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::ScriptAppropriateFaceName(
    SCRIPT_ID sid,          // [in]
    wchar_t * pchPropName,  // [out]
    wchar_t * pchFixedName) // [out]
{
    Assert(pchPropName && pchFixedName);
    pchFixedName[0] = pchPropName[0] = 0;

    HRESULT hr = E_FAIL;

    EnsureObjects();

    //
    // First enum scripts using the IEnumScript interface.
    // Keep this method for compatibility.
    //
    if (_pMultiLanguage2)
    {
        UINT cScripts;

        hr = THR(_pMultiLanguage2->GetNumberOfScripts(&cScripts));

        if (SUCCEEDED(hr))
        {
            ULONG c;
            SCRIPTINFO si;
            IEnumScript * pEnumScript;

            hr = THR(_pMultiLanguage2->EnumScripts(SCRIPTCONTF_SCRIPT_USER, 0, &pEnumScript));

            if (SUCCEEDED(hr))
            {
                while (cScripts--)
                {
                    hr = THR(pEnumScript->Next(1, &si, &c));

                    if (FAILED(hr) || !c)
                    {
                        break;
                    }

                    if (si.ScriptId == sid)
                    {
                        if (si.wszProportionalFont[0])
                        {
                            // Make sure we don't overflow static buffer
                            Assert(wcslen(si.wszProportionalFont) < LF_FACESIZE);
                            si.wszProportionalFont[LF_FACESIZE - 1] = 0;

                            wcscpy(pchPropName, si.wszProportionalFont);
                        }
                        if (si.wszFixedWidthFont[0])
                        {
                            // Make sure we don't overflow static buffer
                            Assert(wcslen(si.wszFixedWidthFont) < LF_FACESIZE);
                            si.wszFixedWidthFont[LF_FACESIZE - 1] = 0;

                            wcscpy(pchFixedName, si.wszFixedWidthFont);
                        }
                        break;
                    }
                }
                pEnumScript->Release();
            }
        }
        hr = S_OK;  // Ignore any errors and allow to use more accurate method.
    }

    //
    // If script enumeration failed to find fonts for the sid, use another more 
    // accurate method using GetScriptFontInfo.
    //
    // If script enumeration was succesful and the sid is sidAsciiLatin, 
    // we will trust MLang and we are done. 
    // If sid != sidAsciiLatin don't trust MLang and check results usign 
    // GetScriptFontInfo, which returs fonts array for the sid. Then check
    // if script enumeration result much. If yes, then return proposed font.
    // If not return first available font for the sid.
    //
    if (   (   sid != sidAsciiLatin 
            || pchPropName[0]
            || pchFixedName[0]
           )
        && _pMLangFontLink2)
    {
        //
        // We are requesting any available font for specified sid.
        // There are 4 possible situations:
        //
        // 1) There is exactly one font available for specified sid 
        //    and pitch. We will pick it up.
        //
        // 2) There are more then one fonts available for specified sid 
        //    and pitch. We will pick up font proposed by script enumeration
        //    if exists or the first one returned by MLang.
        //
        // 3) There is no match for specified sid and pitch. In this case
        //    we ignore pich and try to find a match using only sid.
        //
        // 4) There is no match for specified sid and pitch or for sid only. 
        //    In this case cannot do much - use system font.
        //

        SCRIPTFONTINFO * psfiFixed = NULL;
        SCRIPTFONTINFO * psfiProp  = NULL;
        UINT cFixedFonts = 0;
        UINT cPropFonts = 0;
        UINT iFont;
        bool fEnumFailed;

        // Get first available proportional font
        hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &cPropFonts, NULL));
        if (SUCCEEDED(hr) && cPropFonts != 0)
        {
            psfiProp = new SCRIPTFONTINFO [cPropFonts];
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &cPropFonts, psfiProp));
        }

        // Get first available fixed font
        hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &cFixedFonts, NULL));
        if (SUCCEEDED(hr) && cFixedFonts != 0)
        {
            psfiFixed = new SCRIPTFONTINFO [cFixedFonts];
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &cFixedFonts, psfiFixed));
        }

        //
        // Check if proposed by script enumeration font name covers the sid.
        //
        fEnumFailed = true;
        if (pchPropName[0] && psfiProp)
        {
            const wchar_t * pchAltName = AlternateFontName(pchPropName);
            for (iFont = 0; iFont < cPropFonts; iFont++)
            {
                if (0 == _wcsicmp(pchPropName, psfiProp[iFont].wszFont))
                {
                    fEnumFailed = false;
                    break;
                }
                if (pchAltName)
                {
                    if (0 == _wcsicmp(pchAltName, psfiProp[iFont].wszFont))
                    {
                        // Make sure we don't overflow static buffer
                        Assert(wcslen(pchAltName) < LF_FACESIZE);
                        wcsncpy(pchPropName, pchAltName, LF_FACESIZE);
                        pchPropName[LF_FACESIZE - 1] = 0;

                        fEnumFailed = false;
                        break;
                    }
                }
            }
        }

        // If script enumeration failed use first availabe font.
        // HACKHACK (grzegorz): Because "Arial Unicode MS" has weird text metrics 
        // prefer to use another font, if available.
        if (fEnumFailed)
        {
            SCRIPTFONTINFO * psfi = cPropFonts ? psfiProp : (cFixedFonts ? psfiFixed : NULL);
            iFont = 0;
            if (psfi)
            {
                UINT cFonts = cPropFonts ? cPropFonts : (cFixedFonts ? cFixedFonts : 0);
                if (cFonts > 1 && 0 == _wcsicmp(g_pszArialUnicodeMS, psfi[iFont].wszFont))
                    ++iFont;

                // Make sure we don't overflow static buffer
                Assert(wcslen(psfi[iFont].wszFont) < LF_FACESIZE);
                psfi[iFont].wszFont[LF_FACESIZE - 1] = 0;
                wcscpy(pchPropName, psfi[iFont].wszFont);
            }
            else
            {
                pchPropName[0] = 0;
            }
        }

        //
        // Check if proposed by script enumeration font name covers the sid.
        //
        fEnumFailed = true;
        if (pchFixedName[0] && psfiFixed)
        {
            const TCHAR * pchAltName = AlternateFontName(pchFixedName);
            for (iFont = 0; iFont < cFixedFonts; iFont++)
            {
                if (0 == _wcsicmp(pchFixedName, psfiFixed[iFont].wszFont))
                {
                    fEnumFailed = false;
                    break;
                }
                if (pchAltName)
                {
                    if (0 == _wcsicmp(pchAltName, psfiFixed[iFont].wszFont))
                    {
                        // Make sure we don't overflow static buffer
                        Assert(wcslen(pchAltName) < LF_FACESIZE);
                        wcsncpy(pchFixedName, pchAltName, LF_FACESIZE);
                        pchFixedName[LF_FACESIZE - 1] = 0;

                        fEnumFailed = false;
                        break;
                    }
                }
            }
        }

        // If script enumeration failed use first availabe font.
        // HACKHACK (grzegorz): Because "Arial Unicode MS" has weird text metrics 
        // prefer to use another font, if available.
        if (fEnumFailed)
        {
            SCRIPTFONTINFO * psfi = cFixedFonts ? psfiFixed : (cPropFonts ? psfiProp : NULL);
            iFont = 0;
            if (psfi)
            {
                UINT cFonts = cFixedFonts ? cFixedFonts : (cPropFonts ? cPropFonts : 0);
                if (cFonts > 1 && 0 == _wcsicmp(g_pszArialUnicodeMS, psfi[iFont].wszFont))
                    ++iFont;

                // Make sure we don't overflow static buffer
                Assert(wcslen(psfi[iFont].wszFont) < LF_FACESIZE);
                psfi[iFont].wszFont[LF_FACESIZE - 1] = 0;
                wcscpy(pchFixedName, psfi[iFont].wszFont);
            }
            else
            {
                pchFixedName[0] = 0;
            }
        }

        delete [] psfiProp;
        delete [] psfiFixed;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::LCIDFromString
//
//  Synopsis:   Map a locale string (rfc 1766) to locale id.
//
//  Arguments:  [pszLcid] - locale string (rfc 1766)
//
//  Returns:    0 in case of failure.
//
//-----------------------------------------------------------------------------

LCID CMLang::LCIDFromString(
    wchar_t * pszLcid)
{
    LCID lcid = 0;

    EnsureObjects();

    if (pszLcid && _pMultiLanguage)
    {
        THR(_pMultiLanguage->GetLcidFromRfc1766(&lcid, pszLcid));
    }

    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\project.inc ===
# project.inc - project specific settings

OTHER_INC_DIRS = $(SRCROOT)\core\include $(SRCROOT)\other\include $(SRCROOT)\f3\include $(SDKDIR) 
OTHER_INC_DIRS = $(OTHER_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) $(BLDROOT)\types 
OTHER_INC_DIRS = $(OTHER_INC_DIRS) $(SRCROOT)\core\types $(SRCROOT)\f3\types $(SRCROOT)\f3\ocx96
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intlcore\unisid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       unisid.cxx
//
//  Contents:   Unicode scripts helpers.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  g_asidScriptIDFromCharClass
//
//  Unicode partition to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidScriptIDFromCharClass[]=
{
    // CC           SCRIPT_ID
    /* WOB_   1*/   sidHan,
    /* NOPP   2*/   sidAsciiSym,
    /* NOPA   2*/   sidAsciiSym,
    /* NOPW   2*/   sidDefault,        // was sidLatin for no good reason
    /* HOP_   3*/   sidHalfWidthKana,
    /* WOP_   4*/   sidHan,
    /* WOP5   5*/   sidHan,
    /* NOQW   6*/   sidLatin,          // 00AB and 2039 only, new partition required
    /* AOQW   7*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* WOQ_   8*/   sidHan,
    /* WCB_   9*/   sidHan,
    /* NCPP  10*/   sidAsciiSym,
    /* NCPA  10*/   sidAsciiSym,
    /* NCPW  10*/   sidDefault,
    /* HCP_  11*/   sidHalfWidthKana,
    /* WCP_  12*/   sidHan,
    /* WCP5  13*/   sidHan,
    /* NCQW  14*/   sidLatin,
    /* ACQW  15*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* WCQ_  16*/   sidHan,
    /* ARQW  17*/   sidAmbiguous,      // should go to sidLatin if narrow
    /* NCSA  18*/   sidAsciiSym,
    /* HCO_  19*/   sidHalfWidthKana,
    /* WC__  20*/   sidHan,
    /* WCS_  20*/   sidHan,
    /* WC5_  21*/   sidHan,
    /* WC5S  21*/   sidHan,
    /* NKS_  22*/   sidHalfWidthKana,
    /* WKSM  23*/   sidKana,
    /* WIM_  24*/   sidHan,
    /* NSSW  25*/   sidDefault,
    /* WSS_  26*/   sidHan,
    /* WHIM  27*/   sidKana,
    /* WKIM  28*/   sidKana,
    /* NKSL  29*/   sidHalfWidthKana,
    /* WKS_  30*/   sidKana,
    /* WKSC  30*/   sidKana,
    /* WHS_  31*/   sidKana,
    /* NQFP  32*/   sidAsciiSym,
    /* NQFA  32*/   sidAsciiSym,
    /* WQE_  33*/   sidHan,
    /* WQE5  34*/   sidHan,
    /* NKCC  35*/   sidHalfWidthKana,
    /* WKC_  36*/   sidKana,
    /* NOCP  37*/   sidAsciiSym,
    /* NOCA  37*/   sidAsciiSym,
    /* NOCW  37*/   sidLatin,
    /* WOC_  38*/   sidHan,
    /* WOCS  38*/   sidHan,
    /* WOC5  39*/   sidHan,
    /* WOC6  39*/   sidHan,
    /* AHPW  40*/   sidAmbiguous,
    /* NPEP  41*/   sidAsciiSym,
    /* NPAR  41*/   sidAmbiguous,
    /* HPE_  42*/   sidHalfWidthKana,
    /* WPE_  43*/   sidHan,
    /* WPES  43*/   sidHan,
    /* WPE5  44*/   sidHan,
    /* NISW  45*/   sidDefault,
    /* AISW  46*/   sidAmbiguous,      // if narrow, 2014 and 2026 should go to sidLatin, NP
    /* NQCS  47*/   sidAmbiguous,
    /* NQCW  47*/   sidAmbiguous,
    /* NQCC  47*/   sidAmbiguous,
    /* NPTA  48*/   sidAsciiSym,
    /* NPNA  48*/   sidAsciiSym,
    /* NPEW  48*/   sidLatin,          // would really require a new partition, NP
    /* NPEH  48*/   sidHebrew,
    /* NPEV  48*/   sidLatin,          // NEW Dong sign
    /* APNW  49*/   sidAmbiguous,
    /* HPEW  50*/   sidHangul,
    /* WPR_  51*/   sidHan,
    /* NQEP  52*/   sidAsciiSym,
    /* NQEW  52*/   sidLatin,          // would really require a new partition, NP
    /* NQNW  52*/   sidDefault,
    /* AQEW  53*/   sidAmbiguous,      // if narrow, 00B0, 2030 should go to sidLatin, NP
    /* AQNW  53*/   sidAmbiguous,
    /* AQLW  53*/   sidAmbiguous,
    /* WQO_  54*/   sidHan,
    /* NSBL  55*/   sidAsciiSym,
    /* WSP_  56*/   sidHan,
    /* WHI_  57*/   sidKana,
    /* NKA_  58*/   sidHalfWidthKana,
    /* WKA_  59*/   sidKana,
    /* ASNW  60*/   sidAmbiguous,      // if narrow, most should go to sidLatin, NP
    /* ASEW  60*/   sidAmbiguous,
    /* ASRN  60*/   sidAmbiguous,
    /* ASEN  60*/   sidAmbiguous,
    /* ALA_  61*/   sidLatin,
    /* AGR_  62*/   sidGreek,
    /* ACY_  63*/   sidCyrillic,
    /* WID_  64*/   sidHan,
    /* WPUA  65*/   sidEUDC,
    /* NHG_  66*/   sidHangul,
    /* WHG_  67*/   sidHangul,
    /* WCI_  68*/   sidHan,
    /* NOI_  69*/   sidHan,
    /* WOI_  70*/   sidHan,
    /* WOIC  70*/   sidHan,
    /* WOIL  70*/   sidHan,
    /* WOIS  70*/   sidHan,
    /* WOIT  70*/   sidHan,
    /* NSEN  71*/   sidDefault,
    /* NSET  71*/   sidDefault,
    /* NSNW  71*/   sidDefault,
    /* ASAN  72*/   sidAmbiguous,
    /* ASAE  72*/   sidAmbiguous,
    /* NDEA  73*/   sidAsciiLatin,
    /* WD__  74*/   sidHan,
    /* NLLA  75*/   sidAsciiLatin,
    /* WLA_  76*/   sidHan,
    /* NWBL  77*/   sidDefault,
    /* NWZW  77*/   sidDefault,
    /* NPLW  78*/   sidAmbiguous,
    /* NPZW  78*/   sidMerge,
    /* NPF_  78*/   sidAmbiguous,
    /* NPFL  78*/   sidAmbiguous,
    /* NPNW  78*/   sidAmbiguous,
    /* APLW  79*/   sidAmbiguous,
    /* APCO  79*/   sidAmbiguous,
    /* ASYW  80*/   sidAmbiguous,
    /* NHYP  81*/   sidAsciiSym,       // was sidDefault (error)
    /* NHYW  81*/   sidDefault,
    /* AHYW  82*/   sidAmbiguous,      // if narrow, 2013 should be sidLatin, NP
    /* NAPA  83*/   sidAsciiSym,
    /* NQMP  84*/   sidAsciiSym,
    /* NSLS  85*/   sidAsciiSym,
    /* NSF_  86*/   sidAmbiguous,
    /* NSBS  86*/   sidAmbiguous,
    /* NSBB  86*/   sidAmbiguous,      // NEW
    /* NLA_  87*/   sidLatin,
    /* NLQ_  88*/   sidLatin,
    /* NLQN  88*/   sidLatin,
    /* NLQC  88*/   sidLatin,          // NEW
    /* ALQ_  89*/   sidAmbiguous,      // if narrow, should go to sidLatin, no NP
    /* ALQN  89*/   sidAmbiguous,      // NEW, same remark as above
    /* NGR_  90*/   sidGreek,
    /* NGRN  90*/   sidGreek,
    /* NGQ_  91*/   sidGreek,
    /* NGQN  91*/   sidGreek,
    /* NCY_  92*/   sidCyrillic,
    /* NCYP  93*/   sidCyrillic,
    /* NCYC  93*/   sidCyrillic,
    /* NAR_  94*/   sidArmenian,
    /* NAQL  95*/   sidArmenian,       // NEW
    /* NAQN  95*/   sidArmenian,
    /* NHB_  96*/   sidHebrew,
    /* NHBC  96*/   sidHebrew,
    /* NHBW  96*/   sidHebrew,
    /* NHBR  96*/   sidHebrew,
    /* NASR  97*/   sidArabic,
    /* NAAR  97*/   sidArabic,
    /* NAAC  97*/   sidArabic,
    /* NAAD  97*/   sidArabic,
    /* NAED  97*/   sidArabic,
    /* NANW  97*/   sidArabic,
    /* NAEW  97*/   sidArabic,
    /* NAAS  97*/   sidArabic,
    /* NHI_  98*/   sidDevanagari,
    /* NHIN  98*/   sidDevanagari,
    /* NHIC  98*/   sidDevanagari,
    /* NHID  98*/   sidDevanagari,
    /* NBE_  99*/   sidBengali,
    /* NBEC  99*/   sidBengali,
    /* NBED  99*/   sidBengali,
    /* NBET  99*/   sidBengali,        // NEW
    /* NGM_ 100*/   sidGurmukhi,
    /* NGMC 100*/   sidGurmukhi,
    /* NGMD 100*/   sidGurmukhi,
    /* NGJ_ 101*/   sidGujarati,
    /* NGJC 101*/   sidGujarati,
    /* NGJD 101*/   sidGujarati,
    /* NOR_ 102*/   sidOriya,
    /* NORC 102*/   sidOriya,
    /* NORD 102*/   sidOriya,
    /* NTA_ 103*/   sidTamil,
    /* NTAC 103*/   sidTamil,
    /* NTAD 103*/   sidTamil,
    /* NTE_ 104*/   sidTelugu,
    /* NTEC 104*/   sidTelugu,
    /* NTED 104*/   sidTelugu,
    /* NKD_ 105*/   sidKannada,
    /* NKDC 105*/   sidKannada,
    /* NKDD 105*/   sidKannada,
    /* NMA_ 106*/   sidMalayalam,
    /* NMAC 106*/   sidMalayalam,
    /* NMAD 106*/   sidMalayalam,
    /* NTH_ 107*/   sidThai,
    /* NTHC 107*/   sidThai,
    /* NTHD 107*/   sidThai,
    /* NTHT 107*/   sidThai,
    /* NLO_ 108*/   sidLao,
    /* NLOC 108*/   sidLao,
    /* NLOD 108*/   sidLao,
    /* NTI_ 109*/   sidTibetan,
    /* NTIC 109*/   sidTibetan,
    /* NTID 109*/   sidTibetan,
    /* NTIN 109*/   sidTibetan,        // NEW
    /* NGE_ 110*/   sidGeorgian,
    /* NGEQ 111*/   sidGeorgian,
    /* NBO_ 112*/   sidBopomofo,
    /* NBSP 113*/   sidAsciiSym,
    /* NBSS 113*/   sidDefault,        // NEW
    /* NOF_ 114*/   sidAmbiguous,
    /* NOBS 114*/   sidAmbiguous,
    /* NOEA 114*/   sidAsciiSym,
    /* NONA 114*/   sidAsciiSym,
    /* NONP 114*/   sidAsciiSym,
    /* NOEP 114*/   sidAsciiSym,
    /* NONW 114*/   sidLatin,          // should be split in 2 partitions
    /* NOEW 114*/   sidCurrency,
    /* NOLW 114*/   sidLatin,          // should be split in 2 partitions
    /* NOCO 114*/   sidMerge,          // was sidLatin
    /* NOSP 114*/   sidAmbiguous,      // why?, what about sidMerge
    /* NOEN 114*/   sidDefault,
    /* NOBN 114*/   sidAsciiSym,       // NEW, some are not Ascii, issue?
    /* NET_ 115*/   sidEthiopic,
    /* NETP 115*/   sidEthiopic,
    /* NETD 115*/   sidEthiopic,
    /* NCA_ 116*/   sidCanSyllabic,
    /* NCH_ 117*/   sidCherokee,
    /* WYI_ 118*/   sidYi,
    /* WYIN 118*/   sidYi,             // NEW
    /* NBR_ 119*/   sidBraille,
    /* NRU_ 120*/   sidRunic,
    /* NOG_ 121*/   sidOgham,
    /* NOGS 121*/   sidOgham,          // NEW
    /* NOGN 121*/   sidOgham,          // NEW
    /* NSI_ 122*/   sidSinhala,
    /* NSIC 122*/   sidSinhala,
    /* NTN_ 123*/   sidThaana,
    /* NTNC 123*/   sidThaana,
    /* NKH_ 124*/   sidKhmer,
    /* NKHC 124*/   sidKhmer,
    /* NKHD 124*/   sidKhmer,
    /* NKHT 124*/   sidKhmer,          // NEW
    /* NBU_ 125*/   sidBurmese,
    /* NBUC 125*/   sidBurmese,
    /* NBUD 125*/   sidBurmese,
    /* NSY_ 126*/   sidSyriac,
    /* NSYP 126*/   sidSyriac,
    /* NSYC 126*/   sidSyriac,
    /* NSYW 126*/   sidSyriac,
    /* NMO_ 127*/   sidMongolian,
    /* NMOC 127*/   sidMongolian,
    /* NMOD 127*/   sidMongolian,
    /* NMOB 127*/   sidMongolian,      // NEW
    /* NMON 127*/   sidMongolian,      // NEW
#ifndef NO_UTF16
    /* NHS_ 128*/   sidSurrogateA,
    /* WHT_ 129*/   sidSurrogateB,
#else
    /* NHS_ 128*/   sidDefault,
    /* WHT_ 129*/   sidDefault,
#endif
    /* LS__ 130*/   sidMerge,
    /* XNW_ 131*/   sidDefault,
    /* XNWA 131*/   sidDefault,        // NEW
};

//+----------------------------------------------------------------------------
//
//  g_asidAscii
//
//  [U+0000, U+007F] Unicode range to script identifier mapping.
//
//  NB (cthrash) This table name is a little misleading. Obviously not all
//  script ids in the ASCII range are sidAscii(Latin or Sym). This is just
//  a quick lookup for the most common characters on the web.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidAscii[128] =
{
    /* U+0000 */ sidMerge,
    /* U+0001 */ sidMerge,
    /* U+0002 */ sidMerge,
    /* U+0003 */ sidMerge,
    /* U+0004 */ sidMerge,
    /* U+0005 */ sidMerge,
    /* U+0006 */ sidMerge,
    /* U+0007 */ sidMerge,
    /* U+0008 */ sidMerge,
    /* U+0009 */ sidMerge,
    /* U+000A */ sidMerge,
    /* U+000B */ sidMerge,
    /* U+000C */ sidMerge,
    /* U+000D */ sidMerge,
    /* U+000E */ sidMerge,
    /* U+000F */ sidMerge,
    /* U+0010 */ sidMerge,
    /* U+0011 */ sidMerge,
    /* U+0012 */ sidMerge,
    /* U+0013 */ sidMerge,
    /* U+0014 */ sidMerge,
    /* U+0015 */ sidMerge,
    /* U+0016 */ sidMerge,
    /* U+0017 */ sidMerge,
    /* U+0018 */ sidMerge,
    /* U+0019 */ sidMerge,
    /* U+001A */ sidMerge,
    /* U+001B */ sidMerge,
    /* U+001C */ sidMerge,
    /* U+001D */ sidMerge,
    /* U+001E */ sidMerge,
    /* U+001F */ sidMerge,
    /* U+0020 */ sidMerge,
    /* U+0021 */ sidAsciiSym,
    /* U+0022 */ sidAsciiSym,
    /* U+0023 */ sidAsciiSym,
    /* U+0024 */ sidAsciiSym,
    /* U+0025 */ sidAsciiSym,
    /* U+0026 */ sidAsciiSym,
    /* U+0027 */ sidAsciiSym,
    /* U+0028 */ sidAsciiSym,
    /* U+0029 */ sidAsciiSym,
    /* U+002A */ sidAsciiSym,
    /* U+002B */ sidAsciiSym,
    /* U+002C */ sidAsciiSym,
    /* U+002D */ sidDefault,
    /* U+002E */ sidAsciiSym,
    /* U+002F */ sidAsciiSym,
    /* U+0030 */ sidAsciiLatin,
    /* U+0031 */ sidAsciiLatin,
    /* U+0032 */ sidAsciiLatin,
    /* U+0033 */ sidAsciiLatin,
    /* U+0034 */ sidAsciiLatin,
    /* U+0035 */ sidAsciiLatin,
    /* U+0036 */ sidAsciiLatin,
    /* U+0037 */ sidAsciiLatin,
    /* U+0038 */ sidAsciiLatin,
    /* U+0039 */ sidAsciiLatin,
    /* U+003A */ sidAsciiSym,
    /* U+003B */ sidAsciiSym,
    /* U+003C */ sidAsciiSym,
    /* U+003D */ sidAsciiSym,
    /* U+003E */ sidAsciiSym,
    /* U+003F */ sidAsciiSym,
    /* U+0040 */ sidAsciiSym,
    /* U+0041 */ sidAsciiLatin,
    /* U+0042 */ sidAsciiLatin,
    /* U+0043 */ sidAsciiLatin,
    /* U+0044 */ sidAsciiLatin,
    /* U+0045 */ sidAsciiLatin,
    /* U+0046 */ sidAsciiLatin,
    /* U+0047 */ sidAsciiLatin,
    /* U+0048 */ sidAsciiLatin,
    /* U+0049 */ sidAsciiLatin,
    /* U+004A */ sidAsciiLatin,
    /* U+004B */ sidAsciiLatin,
    /* U+004C */ sidAsciiLatin,
    /* U+004D */ sidAsciiLatin,
    /* U+004E */ sidAsciiLatin,
    /* U+004F */ sidAsciiLatin,
    /* U+0050 */ sidAsciiLatin,
    /* U+0051 */ sidAsciiLatin,
    /* U+0052 */ sidAsciiLatin,
    /* U+0053 */ sidAsciiLatin,
    /* U+0054 */ sidAsciiLatin,
    /* U+0055 */ sidAsciiLatin,
    /* U+0056 */ sidAsciiLatin,
    /* U+0057 */ sidAsciiLatin,
    /* U+0058 */ sidAsciiLatin,
    /* U+0059 */ sidAsciiLatin,
    /* U+005A */ sidAsciiLatin,
    /* U+005B */ sidAsciiSym,
    /* U+005C */ sidAsciiSym,
    /* U+005D */ sidAsciiSym,
    /* U+005E */ sidAsciiSym,
    /* U+005F */ sidAsciiSym,
    /* U+0060 */ sidAsciiSym,
    /* U+0061 */ sidAsciiLatin,
    /* U+0062 */ sidAsciiLatin,
    /* U+0063 */ sidAsciiLatin,
    /* U+0064 */ sidAsciiLatin,
    /* U+0065 */ sidAsciiLatin,
    /* U+0066 */ sidAsciiLatin,
    /* U+0067 */ sidAsciiLatin,
    /* U+0068 */ sidAsciiLatin,
    /* U+0069 */ sidAsciiLatin,
    /* U+006A */ sidAsciiLatin,
    /* U+006B */ sidAsciiLatin,
    /* U+006C */ sidAsciiLatin,
    /* U+006D */ sidAsciiLatin,
    /* U+006E */ sidAsciiLatin,
    /* U+006F */ sidAsciiLatin,
    /* U+0070 */ sidAsciiLatin,
    /* U+0071 */ sidAsciiLatin,
    /* U+0072 */ sidAsciiLatin,
    /* U+0073 */ sidAsciiLatin,
    /* U+0074 */ sidAsciiLatin,
    /* U+0075 */ sidAsciiLatin,
    /* U+0076 */ sidAsciiLatin,
    /* U+0077 */ sidAsciiLatin,
    /* U+0078 */ sidAsciiLatin,
    /* U+0079 */ sidAsciiLatin,
    /* U+007A */ sidAsciiLatin,
    /* U+007B */ sidAsciiSym,
    /* U+007C */ sidAsciiSym,
    /* U+007D */ sidAsciiSym,
    /* U+007E */ sidAsciiSym,
    /* U+007F */ sidAsciiSym,
};

//+----------------------------------------------------------------------------
//
//  g_asidLang
//
//  Primary language identifier to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidLang[LANG_NEPALI + 1] =
{
    /* LANG_NEUTRAL     0x00 */ sidDefault,
    /* LANG_ARABIC      0x01 */ sidArabic,
    /* LANG_BULGARIAN   0x02 */ sidCyrillic,
    /* LANG_CATALAN     0x03 */ sidLatin,
    /* LANG_CHINESE     0x04 */ sidMerge,       // need to look at sublang id
    /* LANG_CZECH       0x05 */ sidLatin,
    /* LANG_DANISH      0x06 */ sidLatin,
    /* LANG_GERMAN      0x07 */ sidLatin,
    /* LANG_GREEK       0x08 */ sidGreek,
    /* LANG_ENGLISH     0x09 */ sidLatin,
    /* LANG_SPANISH     0x0a */ sidLatin,
    /* LANG_FINNISH     0x0b */ sidLatin,
    /* LANG_FRENCH      0x0c */ sidLatin,
    /* LANG_HEBREW      0x0d */ sidHebrew,
    /* LANG_HUNGARIAN   0x0e */ sidLatin,
    /* LANG_ICELANDIC   0x0f */ sidLatin,
    /* LANG_ITALIAN     0x10 */ sidLatin,
    /* LANG_JAPANESE    0x11 */ sidKana,
    /* LANG_KOREAN      0x12 */ sidHangul,
    /* LANG_DUTCH       0x13 */ sidLatin,
    /* LANG_NORWEGIAN   0x14 */ sidLatin,
    /* LANG_POLISH      0x15 */ sidLatin,
    /* LANG_PORTUGUESE  0x16 */ sidLatin,
    /*                  0x17 */ sidDefault,
    /* LANG_ROMANIAN    0x18 */ sidLatin,
    /* LANG_RUSSIAN     0x19 */ sidCyrillic,
    /* LANG_SERBIAN     0x1a */ sidMerge,       // need to look at sublang id
    /* LANG_SLOVAK      0x1b */ sidLatin,
    /* LANG_ALBANIAN    0x1c */ sidLatin,
    /* LANG_SWEDISH     0x1d */ sidLatin,
    /* LANG_THAI        0x1e */ sidThai,
    /* LANG_TURKISH     0x1f */ sidLatin,
    /* LANG_URDU        0x20 */ sidArabic,
    /* LANG_INDONESIAN  0x21 */ sidLatin,
    /* LANG_UKRAINIAN   0x22 */ sidCyrillic,
    /* LANG_BELARUSIAN  0x23 */ sidCyrillic,
    /* LANG_SLOVENIAN   0x24 */ sidLatin,
    /* LANG_ESTONIAN    0x25 */ sidLatin,
    /* LANG_LATVIAN     0x26 */ sidLatin,
    /* LANG_LITHUANIAN  0x27 */ sidLatin,
    /*                  0x28 */ sidDefault,
    /* LANG_FARSI       0x29 */ sidArabic,
    /* LANG_VIETNAMESE  0x2a */ sidLatin,
    /* LANG_ARMENIAN    0x2b */ sidArmenian,
    /* LANG_AZERI       0x2c */ sidMerge,       // need to look at sublang id
    /* LANG_BASQUE      0x2d */ sidLatin,
    /*                  0x2e */ sidDefault,
    /* LANG_MACEDONIAN  0x2f */ sidCyrillic,
    /* LANG_SUTU        0x30 */ sidLatin,
    /*                  0x31 */ sidDefault,
    /*                  0x32 */ sidDefault,
    /*                  0x33 */ sidDefault,
    /*                  0x34 */ sidDefault,
    /*                  0x35 */ sidDefault,
    /* LANG_AFRIKAANS   0x36 */ sidLatin,
    /* LANG_GEORGIAN    0x37 */ sidGeorgian,
    /* LANG_FAEROESE    0x38 */ sidLatin,
    /* LANG_HINDI       0x39 */ sidDevanagari,
    /*                  0x3a */ sidDefault,
    /*                  0x3b */ sidDefault,
    /*                  0x3c */ sidDefault,
    /*                  0x3d */ sidDefault,
    /* LANG_MALAY       0x3e */ sidLatin,
    /* LANG_KAZAKH      0x3f */ sidCyrillic,
    /*                  0x40 */ sidDefault,
    /* LANG_SWAHILI     0x41 */ sidLatin,
    /*                  0x42 */ sidDefault,
    /* LANG_UZBEK       0x43 */ sidMerge,       // need to look at sublang id
    /* LANG_TATAR       0x44 */ sidCyrillic,
    /* LANG_BENGALI     0x45 */ sidBengali,
    /* LANG_PUNJABI     0x46 */ sidGurmukhi,
    /* LANG_GUJARATI    0x47 */ sidGujarati,
    /* LANG_ORIYA       0x48 */ sidOriya,
    /* LANG_TAMIL       0x49 */ sidTamil,
    /* LANG_TELUGU      0x4a */ sidTelugu,
    /* LANG_KANNADA     0x4b */ sidKannada,
    /* LANG_MALAYALAM   0x4c */ sidMalayalam,
    /* LANG_ASSAMESE    0x4d */ sidBengali,
    /* LANG_MARATHI     0x4e */ sidDevanagari,
    /* LANG_SANSKRIT    0x4f */ sidDevanagari,
    /*                  0x50 */ sidDefault,
    /*                  0x51 */ sidDefault,
    /*                  0x52 */ sidDefault,
    /*                  0x53 */ sidDefault,
    /*                  0x54 */ sidDefault,
    /* LANG_BURMESE     0x55 */ sidBurmese,
    /*                  0x56 */ sidDefault,
    /* LANG_KONKANI     0x57 */ sidDevanagari,
    /* LANG_MANIPURI    0x58 */ sidBengali,
    /* LANG_SINDHI      0x59 */ sidArabic,
    /*                  0x5a */ sidDefault,
    /*                  0x5b */ sidDefault,
    /*                  0x5c */ sidDefault,
    /*                  0x5d */ sidDefault,
    /*                  0x5e */ sidDefault,
    /*                  0x5f */ sidDefault,
    /* LANG_KASHMIRI    0x60 */ sidArabic,
    /* LANG_NEPALI      0x61 */ sidDevanagari,
};

//+----------------------------------------------------------------------------
//
//  g_asidCPBit
//
//  Code page bit to script identifier mapping.
//
//-----------------------------------------------------------------------------

const SCRIPT_ID g_asidCPBit[32] =
{
    /* FS_LATIN1        0x00000001 */ sidLatin,
    /* FS_LATIN2        0x00000002 */ sidLatin,
    /* FS_CYRILLIC      0x00000004 */ sidCyrillic,
    /* FS_GREEK         0x00000008 */ sidGreek,
    /* FS_TURKISH       0x00000010 */ sidLatin,
    /* FS_HEBREW        0x00000020 */ sidHebrew,
    /* FS_ARABIC        0x00000040 */ sidArabic,
    /* FS_BALTIC        0x00000080 */ sidLatin,
    /* FS_VIETNAMESE    0x00000100 */ sidLatin,
    /* FS_UNKNOWN       0x00000200 */ sidDefault,
    /* FS_UNKNOWN       0x00000400 */ sidDefault,
    /* FS_UNKNOWN       0x00000800 */ sidDefault,
    /* FS_UNKNOWN       0x00001000 */ sidDefault,
    /* FS_UNKNOWN       0x00002000 */ sidDefault,
    /* FS_UNKNOWN       0x00004000 */ sidDefault,
    /* FS_UNKNOWN       0x00008000 */ sidDefault,
    /* FS_THAI          0x00010000 */ sidThai,
    /* FS_JISJAPAN      0x00020000 */ sidKana,
    /* FS_CHINESESIMP   0x00040000 */ sidHan,
    /* FS_WANSUNG       0x00080000 */ sidHangul,
    /* FS_CHINESETRAD   0x00100000 */ sidBopomofo,
    /* FS_JOHAB         0x00200000 */ sidHangul,
    /* FS_UNKNOWN       0x00400000 */ sidDefault,
    /* FS_UNKNOWN       0x00800000 */ sidDefault,
    /* FS_UNKNOWN       0x01000000 */ sidDefault,
    /* FS_UNKNOWN       0x02000000 */ sidDefault,
    /* FS_UNKNOWN       0x04000000 */ sidDefault,
    /* FS_UNKNOWN       0x08000000 */ sidDefault,
    /* FS_UNKNOWN       0x10000000 */ sidDefault,
    /* FS_UNKNOWN       0x20000000 */ sidDefault,
    /* FS_UNKNOWN       0x40000000 */ sidDefault,
    /* FS_SYMBOL        0x80000000 */ sidDefault,
};

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCharClass
//
//  Synopsis:   Map character class to script id.
//
//  Arguments:  [cc] - character class
//
//  Returns:    Script id appropriate for given character class.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromCharClass(
    CHAR_CLASS cc)  // [in]
{
    Assert(cc >= 0 && cc < CHAR_CLASS_MAX);

    return g_asidScriptIDFromCharClass[cc];
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromLangIDSlow
//
//  Synopsis:   Map language identifier to script id.
//
//  Arguments:  [lang] - language id
//
//  Returns:    Script id appropriate for given language id.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromLangIDSlow(
    LANGID lang)    // [in]
{
    SCRIPT_ID sid = sidDefault;
    WORD sublang = SUBLANGID(lang);
    switch (PRIMARYLANGID(lang))
    {
    case LANG_CHINESE:
        sid = (SCRIPT_ID)(sublang == SUBLANG_CHINESE_TRADITIONAL ? sidBopomofo : sidHan);
        break;
    case LANG_SERBIAN:
        sid = (SCRIPT_ID)(sublang == SUBLANG_SERBIAN_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    case LANG_AZERI:
        sid = (SCRIPT_ID)(sublang == SUBLANG_AZERI_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    case LANG_UZBEK:
        sid = (SCRIPT_ID)(sublang == SUBLANG_UZBEK_CYRILLIC ? sidCyrillic : sidLatin);
        break;
    default:
        Assert(FALSE); // Should get data in fast vertion (ScriptIDFromLangID)
    }
    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCPBit
//
//  Synopsis:   Map code page bit to script id.
//
//  Arguments:  [dwCPBit] - code page bit
//
//  Returns:    Script id appropriate for given code page bit.
//
//-----------------------------------------------------------------------------

SCRIPT_ID ScriptIDFromCPBit(
    DWORD dwCPBit)  // [in]
{
    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        if (dwCPBit & (1 << i))
            return g_asidCPBit[i];
        ++i;
    }
    return sidDefault;
}

//+----------------------------------------------------------------------------
//
//  Function:   CPBitFromScripts
//
//  Synopsis:   Map scripts to code page bits.
//
//  Arguments:  [sids] - scripts
//
//  Returns:    Code page bits appropriate for given scripts.
//
//-----------------------------------------------------------------------------

DWORD CPBitFromScripts(
    SCRIPT_IDS sids)  // [in]
{
    DWORD dwCPBit = 0;
    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        SCRIPT_ID sid = g_asidCPBit[i];
        if (sid != sidDefault && (ScriptBit(sid) & sids))
            dwCPBit |= (1 << i);
        ++i;
    }
    return dwCPBit;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptsFromCPBit
//
//  Synopsis:   Map code page bits to script ids.
//
//  Arguments:  [dwCPBit] - code page bit-mask
//
//  Returns:    Script ids appropriate for given code page bit-mask.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS ScriptsFromCPBit(
    DWORD dwCPBit)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;

    int i = 0;
    while (i < ARRAY_SIZE(g_asidCPBit))
    {
        if (dwCPBit & DWORD(1 << i))
            sids |= ScriptBit(g_asidCPBit[i]);
        ++i;
    }

    return sids;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\fontlinkcore\unicoderanges.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       unicoderanges.cxx
//
//  Contents:   Object encapsulating Unicode ranges and it's properties.
//
//----------------------------------------------------------------------------

#ifndef X_FONTLINKCORE_HXX_
#define X_FONTLINKCORE_HXX_
#include "fontlinkcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
// The only one CUnicodeRanges object
//-----------------------------------------------------------------------------

CUnicodeRanges g_UnicodeRanges;

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::CUnicodeRanges
//
//-----------------------------------------------------------------------------

CUnicodeRanges::CUnicodeRanges()
{
    _cRef = 0;
    AddRef();
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::~CUnicodeRanges
//
//-----------------------------------------------------------------------------

CUnicodeRanges::~CUnicodeRanges()
{
    Assert(_cRef == 1); // This object is a global object.
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::QueryInterface
//
//  Synopsis:   Return a pointer to a specified interface on an object to 
//              which a client currently holds an interface pointer.
//
//  Arguments:  [riid]      - identifier of the requested interface
//              [ppvObject] - address of output variable that receives the 
//                            interface pointer requested in riid
//
//  Returns:    S_OK if the interface is supported, E_NOINTERFACE if not.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::QueryInterface(
    REFIID riid,        // [in]
    void ** ppvObject)  // [out]
{
    if (ppvObject == NULL)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (IsEqualGUID(IID_IUnicodeScriptMapper, riid))
    {
        *ppvObject = static_cast<IUnicodeScriptMapper *>(this);
    }

    if (*ppvObject)
    {
        static_cast<IUnknown *>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::AddRef
//
//  Synopsis:   Increment the reference count of the object.
//
//  Returns:    The value of the new reference count.
//
//-----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CUnicodeRanges::AddRef()
{
    InterlockedIncrement(reinterpret_cast<long *>(&_cRef));
    return _cRef;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::Release
//
//  Synopsis:   Decrement the reference count of the object.
//
//  Returns:    The resulting value of the reference count.
//
//-----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CUnicodeRanges::Release()
{
    InterlockedDecrement(reinterpret_cast<long *>(&_cRef));

    Assert(_cRef != 0); // This object is a global object.

    return _cRef;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::GetScriptId
//
//  Synopsis:   Map Unicode character to an appropriate script id. In case of:
//              * sidAmbiguous - the caller should disambiguate script
//              * sidHan - the caller should ununify Han script
//              * sidMerge - the caller should merge with the previous character
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::GetScriptId(
    wchar_t ch,         // [in]
    byte * pScriptId)   // [out]
{
    if (pScriptId == NULL)
        return E_INVALIDARG;

    *pScriptId = ScriptIDFromCh(ch);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::GetScriptIdMulti
//
//  Synopsis:   Map string of Unicode characters to an appropriate script id. 
//              Will stop analyzing when finds a new script.
//              In case of:
//              * sidAmbiguous - the caller should disambiguate script
//              * sidHan - the caller should ununify Han script
//              * sidMerge - the caller should merge with the previous character
//
//  Arguments:  [pch]       - text buffer to analyze
//              [cch]       - number of characters to analyze
//              [pcchSplit] - number of characters analyzed
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::GetScriptIdMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL)
        return E_INVALIDARG;

    // TODO

    if (pcchSplit)
        *pcchSplit = cch;

    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::UnunifyHanScript
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a Han character.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::UnunifyHanScript(
    wchar_t ch,          // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    byte * pScriptId)    // [out]
{
    if ((pScriptId == NULL) || (sidHan != ScriptIDFromCh(ch)))
        return E_INVALIDARG;

    DWORD dwPriorityCodePages;
    long cch = 1;
    dwPriorityCodePages = (FS_JOHAB | FS_CHINESETRAD | FS_WANSUNG | FS_CHINESESIMP | FS_JISJAPAN);
    *pScriptId = ResolveAmbiguousScript(&ch, &cch, sidPrefered, sidsAvailable, 
                                        dwPriorityCodePages, (unsigned char)flags);

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::UnunifyHanScriptMulti
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a string of Han characters.
//              Will stop analyzing when finds a new script.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::UnunifyHanScriptMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(*pch);
    if (sidHan != sid && sidMerge != sid && sid != sidAmbiguous)
        return E_INVALIDARG;

    if (sid != sidAmbiguous)
    {
        DWORD dwPriorityCodePages;
        dwPriorityCodePages = (FS_JOHAB | FS_CHINESETRAD | FS_WANSUNG | FS_CHINESESIMP | FS_JISJAPAN);
        *pScriptId = ResolveAmbiguousScript(pch, &cch, sidPrefered, sidsAvailable, 
                                            dwPriorityCodePages, (unsigned char)flags);
    }
    else
    {
        *pScriptId = sidHan; // This character has been already disambiguated.
        cch = 1;
    }

    if (pcchSplit)
        *pcchSplit = cch;

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::DisambiguateScript
//
//  Synopsis:   Pick up one of valid script ids for an ambiguous character.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::DisambiguateScript(
    wchar_t ch,          // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    byte * pScriptId)    // [out]
{
    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(ch);
    if (sidAmbiguous != sid && sidMerge != sid)
        return E_INVALIDARG;

    long cch = 1;
    *pScriptId = ResolveAmbiguousScript(&ch, &cch, sidPrefered, sidsAvailable, 
                                        0xFFFFFFFF, (unsigned char)flags);

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::DisambiguateScriptMulti
//
//  Synopsis:   Pick up one of valid script ids for a string of ambiguous characters.
//              Will stop analyzing when finds a new script.
//
//  Returns:    E_INVALIDARG if invalid argument, S_OK otherwise.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CUnicodeRanges::DisambiguateScriptMulti(
    const wchar_t * pch, // [in]
    long cch,            // [in]
    byte sidPrefered,    // [in]
    hyper sidsAvailable, // [in]
    byte flags,          // [in]
    long * pcchSplit,    // [out]
    byte * pScriptId)    // [out]
{
    if (pch == NULL || cch == 0)
        return E_INVALIDARG;

    if (pScriptId == NULL) 
        return E_INVALIDARG;

    SCRIPT_ID sid = ScriptIDFromCh(*pch);
    if (sidAmbiguous != sid && sidMerge != sid)
        return E_INVALIDARG;

    *pScriptId = ResolveAmbiguousScript(pch, &cch, sidPrefered, sidsAvailable, 
                                        0xFFFFFFFF, (unsigned char)flags);

    if (pcchSplit)
        *pcchSplit = cch;

    return (*pScriptId == sidDefault) ? S_FALSE : S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CUnicodeRanges::ResolveAmbiguousScript
//
//  Synopsis:   Relolve ambiguous script to a valid script.
//
//  Returns:    A valid script id, appropriate for passed Unicode string.
//
//-----------------------------------------------------------------------------

SCRIPT_ID CUnicodeRanges::ResolveAmbiguousScript(
    const wchar_t * pch,        // [in]
    long * pcch,                // [in, out]
    SCRIPT_ID sidPrefered,      // [in]
    SCRIPT_IDS sidsAvailable,   // [in]
    DWORD dwCPBit,              // [in]
    unsigned char uFlags)       // [in]
{
    DWORD dwCodePages;
    SCRIPT_ID sid;
    SCRIPT_IDS sidsText;

    dwCodePages = mlang().GetTextCodePages(dwCPBit, pch, pcch);
    sidsText = ScriptsFromCPBit(dwCodePages);

    if (   (sidPrefered != sidDefault)
        && (ScriptBit(sidPrefered) & sidsText)
       )
    {
        sid = sidPrefered;
    }
    else
    {
        // Prefer to use user default locale
        LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
        sidPrefered = ScriptIDFromLangID(lid);

        if (sidsAvailable & sidsText)
        {
            if (ScriptBit(sidPrefered) & sidsAvailable & sidsText)
                sid = sidPrefered;
            else
                sid = ScriptIDFromCPBit((CPBitFromScripts(sidsAvailable) & dwCodePages));
        }
        else if (uFlags & USM_AVAILABLESIDONLY)
        {
            sid = sidDefault;
        }
        else
        {
            if (ScriptBit(sidPrefered) & sidsText)
                sid = sidPrefered;
            else
                sid = ScriptIDFromCPBit(dwCodePages);
        }
    }

    return sid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intlcore\unipart.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File: unipart.cxx
//
//  This is a generated file.  Do not modify by hand.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//  Generating script: unipart_make_cxx.pl
//  Generated on Mon Dec  4 18:56:31 2000


const CHAR_CLASS acc_00[256] = // U+00xx
{
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NSF_,NSBB,NOF_,NSBS,NSBB,NOBN,NOBN, // 00 - 0F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBS,NOBS,NOF_, // 10 - 1F
    NSBL,NQFP,NQMP,NOEA,NPTA,NQEP,NONA,NAPA,NOPP,NCPP,NONP,NOEP,NCSA,NHYP,NPEP,NSLS, // 20 - 2F
    NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NOCP,NOCA,NONA,NONP,NONA,NQFA, // 30 - 3F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 40 - 4F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPP,NPNA,NCPP,NONA,NONA, // 50 - 5F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 60 - 6F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPA,NONA,NCPA,NONA,NOBN, // 70 - 7F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 80 - 8F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 90 - 9F
    NBSP,ASNW,NQEW,NPEW,ASEW,NPEW,NONW,ASNW,ASNW,NONW,ASAN,NOQW,NONW,ASYW,NONW,ASNW, // A0 - AF
    AQEW,ASEW,ASAE,ASAE,ASNW,NOLW,ASNW,ASNW,ASNW,ASAE,ASAN,NCQW,ASNW,ASNW,ASNW,ASNW, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ASNW,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // D0 - DF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,ALA_,ALA_,ALA_,NLA_,ALA_,ALA_,NLA_,NLA_, // E0 - EF
    ALA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ASNW,ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_01[256] = // U+01xx
{
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_, // 30 - 3F
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_,ALA_,ALA_,ALA_,ALA_,ALA_,ALA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_, // C0 - CF
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_02[256] = // U+02xx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    ALA_,ALA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPLW,NPLW,NPLW,NPLW,NPLW, // B0 - BF
    NPLW,NPLW,NPNW,NPNW,NPNW,NPNW,ALQN,ALQ_,NPNW,ALQ_,ALQ_,ALQ_,NPNW,ALQ_,NPNW,NPNW, // C0 - CF
    APLW,NPLW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,ALQ_,ALQ_,ALQ_,ALQ_,NLQN,ALQ_,NPNW,NPNW, // D0 - DF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPLW,NPNW, // E0 - EF
    NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW  // F0 - FF
};

const CHAR_CLASS acc_03[256] = // U+03xx
{
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 00 - 0F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 30 - 3F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 40 - 4F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 50 - 5F
    NQCC,NQCC,NQCC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC, // 60 - 6F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQ_,NGQN,NGQN,NGQN,NGQN,NGQN, // 70 - 7F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGR_,NGQN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // 90 - 9F
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // B0 - BF
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // E0 - EF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_  // F0 - FF
};

const CHAR_CLASS acc_04[256] = // U+04xx
{
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 10 - 1F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 20 - 2F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 30 - 3F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 40 - 4F
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 50 - 5F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 60 - 6F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 70 - 7F
    NCY_,NCY_,NCYP,NCYC,NCYC,NCYC,NCYC,NCYC,NCYP,NCYP,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 80 - 8F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 90 - 9F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // A0 - AF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // B0 - BF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // C0 - CF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // D0 - DF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // E0 - EF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_  // F0 - FF
};

const CHAR_CLASS acc_05[256] = // U+05xx
{
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 10 - 1F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 20 - 2F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 30 - 3F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 40 - 4F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL, // 50 - 5F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 60 - 6F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 70 - 7F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NPAR,NAQN,NAQL,NAQL,NAQL,NAQL,NAQL, // 80 - 8F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // 90 - 9F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // A0 - AF
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHB_,NHBC, // B0 - BF
    NHB_,NHBC,NHBC,NHB_,NHBC,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // C0 - CF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // D0 - DF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // E0 - EF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_  // F0 - FF
};

const CHAR_CLASS acc_06[256] = // U+06xx
{
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NASR,NAAR,NAAR,NAAR, // 00 - 0F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 10 - 1F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 20 - 2F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 30 - 3F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC, // 40 - 4F
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // 50 - 5F
    NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAEW,NAAD,NAAD,NAAR,NAAR,NAAR, // 60 - 6F
    NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 70 - 7F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 80 - 8F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 90 - 9F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // A0 - AF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // B0 - BF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // C0 - CF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // D0 - DF
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAC,NAAC,NANW,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // E0 - EF
    NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR  // F0 - FF
};

const CHAR_CLASS acc_07[256] = // U+07xx
{
    NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYW, // 00 - 0F
    NSY_,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 10 - 1F
    NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 20 - 2F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC, // 30 - 3F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_, // 40 - 4F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 50 - 5F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 60 - 6F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 70 - 7F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 80 - 8F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 90 - 9F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC, // A0 - AF
    NTNC,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_09[256] = // U+09xx
{
    NHI_,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 00 - 0F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 10 - 1F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 20 - 2F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHIC,NHI_,NHIC,NHIC, // 30 - 3F
    NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_, // 40 - 4F
    NHI_,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 50 - 5F
    NHI_,NHI_,NHIC,NHIC,NHIN,NHIN,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID, // 60 - 6F
    NHIN,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 70 - 7F
    NBE_,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 80 - 8F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 90 - 9F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // A0 - AF
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBEC,NBE_,NBEC,NBEC, // B0 - BF
    NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_, // C0 - CF
    NBE_,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // D0 - DF
    NBE_,NBE_,NBEC,NBEC,NBE_,NBE_,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED, // E0 - EF
    NBE_,NBE_,NBET,NBET,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_  // F0 - FF
};

const CHAR_CLASS acc_0A[256] = // U+0Axx
{
    NGM_,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 00 - 0F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 10 - 1F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 20 - 2F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGMC,NGM_,NGMC,NGMC, // 30 - 3F
    NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_, // 40 - 4F
    NGM_,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 50 - 5F
    NGM_,NGM_,NGMC,NGMC,NGM_,NGM_,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD, // 60 - 6F
    NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 70 - 7F
    NGJ_,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 80 - 8F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 90 - 9F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // A0 - AF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJC,NGJ_,NGJC,NGJC, // B0 - BF
    NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_, // C0 - CF
    NGJ_,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // D0 - DF
    NGJ_,NGJ_,NGJC,NGJC,NGJ_,NGJ_,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD, // E0 - EF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_  // F0 - FF
};

const CHAR_CLASS acc_0B[256] = // U+0Bxx
{
    NOR_,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 00 - 0F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 10 - 1F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 20 - 2F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NORC,NOR_,NORC,NORC, // 30 - 3F
    NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_, // 40 - 4F
    NOR_,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 50 - 5F
    NOR_,NOR_,NORC,NORC,NOR_,NOR_,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD, // 60 - 6F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 70 - 7F
    NTA_,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 80 - 8F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 90 - 9F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // A0 - AF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTAC,NTA_,NTAC,NTAC, // B0 - BF
    NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_, // C0 - CF
    NTA_,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // D0 - DF
    NTA_,NTA_,NTAC,NTAC,NTA_,NTA_,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD, // E0 - EF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_  // F0 - FF
};

const CHAR_CLASS acc_0C[256] = // U+0Cxx
{
    NTE_,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 00 - 0F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 10 - 1F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 20 - 2F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTEC,NTE_,NTEC,NTEC, // 30 - 3F
    NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_, // 40 - 4F
    NTE_,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 50 - 5F
    NTE_,NTE_,NTEC,NTEC,NTE_,NTE_,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED, // 60 - 6F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 70 - 7F
    NKD_,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 80 - 8F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 90 - 9F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // A0 - AF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKDC,NKD_,NKDC,NKDC, // B0 - BF
    NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_, // C0 - CF
    NKD_,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // D0 - DF
    NKD_,NKD_,NKDC,NKDC,NKD_,NKD_,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD, // E0 - EF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_  // F0 - FF
};

const CHAR_CLASS acc_0D[256] = // U+0Dxx
{
    NMA_,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 00 - 0F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 10 - 1F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 20 - 2F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMAC,NMA_,NMAC,NMAC, // 30 - 3F
    NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_, // 40 - 4F
    NMA_,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 50 - 5F
    NMA_,NMA_,NMAC,NMAC,NMA_,NMA_,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD, // 60 - 6F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 70 - 7F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 80 - 8F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 90 - 9F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // A0 - AF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // B0 - BF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSIC,NSI_,NSI_,NSI_,NSI_,NSIC, // C0 - CF
    NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC, // D0 - DF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // E0 - EF
    NSI_,NSI_,NSIC,NSIC,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_  // F0 - FF
};

const CHAR_CLASS acc_0E[256] = // U+0Exx
{
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 00 - 0F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 10 - 1F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 20 - 2F
    NTH_,NTHC,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHT, // 30 - 3F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTH_, // 40 - 4F
    NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 50 - 5F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 60 - 6F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 70 - 7F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 80 - 8F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 90 - 9F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // A0 - AF
    NLO_,NLOC,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLO_,NLO_,NLO_, // B0 - BF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC, // C0 - CF
    NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // D0 - DF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // E0 - EF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_  // F0 - FF
};

const CHAR_CLASS acc_0F[256] = // U+0Fxx
{
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_, // 00 - 0F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 10 - 1F
    NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID, // 20 - 2F
    NTID,NTID,NTID,NTID,NTI_,NTIC,NTI_,NTIC,NTI_,NTIC,NTIN,NTIN,NTIN,NTIN,NTIC,NTIC, // 30 - 3F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 40 - 4F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 50 - 5F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 60 - 6F
    NTI_,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 70 - 7F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 80 - 8F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 90 - 9F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // A0 - AF
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTI_,NTI_, // B0 - BF
    NTIC,NTIC,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // C0 - CF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // D0 - DF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // E0 - EF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_  // F0 - FF
};

const CHAR_CLASS acc_10[256] = // U+10xx
{
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 00 - 0F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 10 - 1F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC, // 20 - 2F
    NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC, // 30 - 3F
    NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 40 - 4F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 50 - 5F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 60 - 6F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 70 - 7F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 80 - 8F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 90 - 9F
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // A0 - AF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // B0 - BF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // C0 - CF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // D0 - DF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // E0 - EF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGEQ,NGE_,NGE_,NGE_,NGE_  // F0 - FF
};

const CHAR_CLASS acc_13[256] = // U+13xx
{
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 00 - 0F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 10 - 1F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 20 - 2F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 30 - 3F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 40 - 4F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 50 - 5F
    NET_,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETD,NETD,NETD,NETD,NETD,NETD,NETD, // 60 - 6F
    NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NET_,NET_,NET_, // 70 - 7F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 80 - 8F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 90 - 9F
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // A0 - AF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // B0 - BF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // C0 - CF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // D0 - DF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // E0 - EF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_  // F0 - FF
};

const CHAR_CLASS acc_16[256] = // U+16xx
{
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 00 - 0F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 10 - 1F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 20 - 2F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 30 - 3F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 40 - 4F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 50 - 5F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 60 - 6F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 70 - 7F
    NOGS,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_, // 80 - 8F
    NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOGN,NOGN,NOG_,NOG_,NOG_, // 90 - 9F
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // A0 - AF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // B0 - BF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // C0 - CF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // D0 - DF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // E0 - EF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_  // F0 - FF
};

const CHAR_CLASS acc_17[256] = // U+17xx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 80 - 8F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 90 - 9F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // A0 - AF
    NKH_,NKH_,NKH_,NKH_,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // B0 - BF
    NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // C0 - CF
    NKHC,NKHC,NKHC,NKHC,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKHT,NKH_,NKH_,NKH_,NKH_, // D0 - DF
    NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // E0 - EF
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_  // F0 - FF
};

const CHAR_CLASS acc_18[256] = // U+18xx
{
    NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMOB,NMOB,NMOB,NMOB,NMOB, // 00 - 0F
    NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 10 - 1F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 20 - 2F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 30 - 3F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 40 - 4F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 50 - 5F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 60 - 6F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 70 - 7F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 80 - 8F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 90 - 9F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMOC,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // A0 - AF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_1E[256] = // U+1Exx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // B0 - BF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_1F[256] = // U+1Fxx
{
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 00 - 0F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 10 - 1F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 20 - 2F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 30 - 3F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 40 - 4F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 50 - 5F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 60 - 6F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 70 - 7F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 90 - 9F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGR_,NGRN, // B0 - BF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // E0 - EF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN  // F0 - FF
};

const CHAR_CLASS acc_20[256] = // U+20xx
{
    NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NQCS,NWBL,NWBL,NWBL,NWZW,NPZW,NPZW,NPFL,NPF_, // 00 - 0F
    AHYW,NPNW,NHYW,AHYW,AISW,ASNW,ASNW,NONW,AOQW,ARQW,NCQW,NOQW,AOQW,ACQW,NCQW,NOQW, // 10 - 1F
    ASNW,ASNW,NOCW,NONW,NISW,AISW,AISW,AHPW,NSBS,NSBB,NOSP,NOSP,NOSP,NOSP,NOSP,NBSS, // 20 - 2F
    AQEW,NQEW,AQEW,AQEW,NQEW,AQNW,NQNW,NQNW,NONW,NOQW,NCQW,ASNW,NSSW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NSSW,NOPW,NCPW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN, // 50 - 5F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 60 - 6F
    NSEN,NSEN,NSEN,NSEN,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,ASAN, // 70 - 7F
    NSEN,ASAE,ASAE,ASAE,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,NSNW, // 80 - 8F
    NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW, // 90 - 9F
    NOEW,NPEW,NPEW,NOEW,NPEW,NOEW,NOEW,NQEW,NOEW,HPEW,NPEH,NPEV,NOEW,NOEW,NOEW,NOEW, // A0 - AF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // B0 - BF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // C0 - CF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // D0 - DF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // E0 - EF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO  // F0 - FF
};

const CHAR_CLASS acc_21[256] = // U+21xx
{
    NONW,NONW,NOLW,AQNW,NONW,ASNW,NONW,NOLW,NONW,AQNW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 00 - 0F
    NOLW,NOLW,NOLW,ASRN,NONW,NOLW,APNW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW, // 10 - 1F
    NONW,ASNW,ASNW,NONW,NOLW,NONW,AQLW,NONW,NOLW,NONW,NOLW,ASRN,NOLW,NOLW,NOEW,NOLW, // 20 - 2F
    NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW, // 50 - 5F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 70 - 7F
    NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_22[256] = // U+22xx
{
    ASNW,NONW,ASNW,ASNW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW, // 00 - 0F
    NONW,ASNW,NOEW,NOEW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,NONW,NONW,ASNW,NONW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_23[256] = // U+23xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 50 - 5F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_24[256] = // U+24xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 60 - 6F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 70 - 7F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 80 - 8F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASRN,ASRN,ASRN,ASRN, // 90 - 9F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // A0 - AF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // B0 - BF
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // C0 - CF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // D0 - DF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOEN,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_25[256] = // U+25xx
{
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 00 - 0F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 20 - 2F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 30 - 3F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW, // 40 - 4F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 50 - 5F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 60 - 6F
    ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 80 - 8F
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // B0 - BF
    ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW, // C0 - CF
    ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_26[256] = // U+26xx
{
    NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,ASNW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,NONW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_27[256] = // U+27xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_2E[256] = // U+2Exx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 80 - 8F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 90 - 9F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // A0 - AF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // B0 - BF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // C0 - CF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // D0 - DF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // E0 - EF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_  // F0 - FF
};

const CHAR_CLASS acc_30[256] = // U+30xx
{
    WSP_,WC__,WPE_,WOI_,WOI_,WIM_,WOIL,WOIL,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_, // 00 - 0F
    WOP_,WCP_,WOI_,WOI_,WOB_,WCB_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WSS_,WOQ_,WCQ_,WCQ_, // 10 - 1F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIC,WOIC,WOIC,WOIC,WOIC,WOIC, // 20 - 2F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOI_,WOI_,WOIL,WOIL,WOIL,WOI_,WOI_,WOI_,WOI_,WOI_, // 30 - 3F
    WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 40 - 4F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 50 - 5F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 60 - 6F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 70 - 7F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHS_,WHI_, // 80 - 8F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WKSC,WKSC,WKSM,WKSM,WHIM,WHIM,WHI_, // 90 - 9F
    WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // A0 - AF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // B0 - BF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // C0 - CF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // D0 - DF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKA_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKS_,WKA_,WKA_,WKA_,WKA_,WKC_,WKS_,WKIM,WKIM,WKA_  // F0 - FF
};

const CHAR_CLASS acc_31[256] = // U+31xx
{
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 00 - 0F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 10 - 1F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 20 - 2F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 30 - 3F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 40 - 4F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // A0 - AF
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_  // F0 - FF
};

const CHAR_CLASS acc_32[256] = // U+32xx
{
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 00 - 0F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 10 - 1F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 20 - 2F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 30 - 3F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 40 - 4F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // A0 - AF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // E0 - EF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL  // F0 - FF
};

const CHAR_CLASS acc_33[256] = // U+33xx
{
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 00 - 0F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 10 - 1F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 20 - 2F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 30 - 3F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 40 - 4F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 60 - 6F
    WCI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 70 - 7F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 80 - 8F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 90 - 9F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // A0 - AF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // E0 - EF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_  // F0 - FF
};

const CHAR_CLASS acc_A4[256] = // U+A4xx
{
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 00 - 0F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 10 - 1F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 20 - 2F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 30 - 3F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 40 - 4F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 50 - 5F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 60 - 6F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 70 - 7F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 80 - 8F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // 90 - 9F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // A0 - AF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // B0 - BF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // C0 - CF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // D0 - DF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // E0 - EF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN  // F0 - FF
};

const CHAR_CLASS acc_D8[256] = // U+D8xx
{
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 00 - 0F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 10 - 1F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 20 - 2F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 30 - 3F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 40 - 4F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 50 - 5F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 60 - 6F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 70 - 7F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 80 - 8F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 90 - 9F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // A0 - AF
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // B0 - BF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // C0 - CF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // D0 - DF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // E0 - EF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_  // F0 - FF
};

const CHAR_CLASS acc_FB[256] = // U+FBxx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NHBR,NHBC,NHBR, // 10 - 1F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBW,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 20 - 2F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 30 - 3F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FD[256] = // U+FDxx
{
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 00 - 0F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 10 - 1F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 20 - 2F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NANW,NANW, // 30 - 3F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // D0 - DF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FE[256] = // U+FExx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5, // 30 - 3F
    WCP5,WOP5,WCP5,WOP5,WCP5,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 40 - 4F
    WC5S,WC5_,WPE5,WOI_,WOC6,WOC5,WQE5,WQE5,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOIT, // 50 - 5F
    WOI_,WOI_,WOIT,WOIT,WOI_,WOI_,WOI_,WOI_,WOI_,WPR_,WQO_,WOI_,WOI_,WOI_,WOI_,WOI_, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NQCW  // F0 - FF
};

const CHAR_CLASS acc_FF[256] = // U+FFxx
{
    XNW_,WQE_,WOI_,WOIT,WPR_,WQO_,WOI_,WOI_,WOB_,WCB_,WOI_,WOIT,WCS_,WOIT,WPES,WOIS, // 00 - 0F
    WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WOCS,WOC_,WOI_,WOI_,WOI_,WQE_, // 10 - 1F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 20 - 2F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOB_,WOI_,WCB_,WOI_,WOI_, // 30 - 3F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 40 - 4F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOP_,WOI_,WCP_,WOI_,XNW_, // 50 - 5F
    XNW_,HPE_,HOP_,HCP_,HCO_,NKCC,NKA_,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL, // 60 - 6F
    NKSL,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 70 - 7F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 80 - 8F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKS_,NKS_, // 90 - 9F
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // A0 - AF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // B0 - BF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // C0 - CF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,XNW_,XNW_,XNW_, // D0 - DF
    WQO_,WPR_,WOI_,WOI_,WOI_,WPR_,WPR_,XNW_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,XNW_, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN,NOBN,NOBN,NOBN,NONW,NOBN,NOBN  // F0 - FF
};

const CHAR_CLASS * const pccUnicodeClass[256] =
{
    acc_00, acc_01, acc_02, acc_03, acc_04, acc_05, acc_06, acc_07,  // 00 - 07
    __XNW_, acc_09, acc_0A, acc_0B, acc_0C, acc_0D, acc_0E, acc_0F,  // 08 - 0F
    acc_10, __WHG_, __NET_, acc_13, __NCA_, __NCA_, acc_16, acc_17,  // 10 - 17
    acc_18, __XNW_, __XNW_, __XNW_, __XNW_, __XNW_, acc_1E, acc_1F,  // 18 - 1F
    acc_20, acc_21, acc_22, acc_23, acc_24, acc_25, acc_26, acc_27,  // 20 - 27
    __NBR_, __NONW, __NONW, __XNW_, __XNW_, __XNW_, acc_2E, __WOI_,  // 28 - 2F
    acc_30, acc_31, acc_32, acc_33, __WID_, __WID_, __WID_, __WID_,  // 30 - 37
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 38 - 3F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 40 - 47
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 48 - 4F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 50 - 57
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 58 - 5F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 60 - 67
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 68 - 6F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 70 - 77
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 78 - 7F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 80 - 87
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 88 - 8F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 90 - 97
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 98 - 9F
    __WYI_, __WYI_, __WYI_, __WYI_, acc_A4, __XNW_, __XNW_, __XNW_,  // A0 - A7
    __XNW_, __XNW_, __XNW_, __XNW_, __WHG_, __WHG_, __WHG_, __WHG_,  // A8 - AF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B0 - B7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B8 - BF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C0 - C7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C8 - CF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // D0 - D7
    acc_D8, __NHS_, __NHS_, __NHS_, __LS__, __LS__, __LS__, __LS__,  // D8 - DF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E0 - E7
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E8 - EF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // F0 - F7
    __WPUA, __WID_, __WID_, acc_FB, __NAAS, acc_FD, acc_FE, acc_FF   // F8 - FF
};

//+----------------------------------------------------------------------------
//
//  Function:   CharClassFromChSlow
//
//  Synopsis:   Given a character return a Unicode character class.  This
//              character class implies other properties, such as script id,
//              breaking class, etc.
//
//      Note:   pccUnicodeClass is a hack table.  For every Unicode page for
//              which every codepoint is the same value, the table entry is
//              the charclass itself.  Otherwise we have a pointer to a table
//              of charclass.
//
//-----------------------------------------------------------------------------

CHAR_CLASS CharClassFromChSlow(
    wchar_t wch) // [in]
{
    const CHAR_CLASS * const pcc = pccUnicodeClass[wch>>8];
    const UINT_PTR icc = UINT_PTR(pcc);

    return (CHAR_CLASS)(icc < 256 ? icc : pcc[wch & 0xff]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\hta\main.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       main.cxx
//
//  Contents:   WinMain and associated functions.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

typedef HRESULT STDAPICALLTYPE RUNHTMLAPPLICATIONFN(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow);

#define ARRAYSIZE   (MAX_PATH + 1)

// Simply a pass-through entry point.  It forwards this call to the registered MSHTML's 
// RunHTMLApplication API.

EXTERN_C int PASCAL
WinMain(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow)
{

    HINSTANCE hinstMSHTML = NULL;
    RUNHTMLAPPLICATIONFN *lpfnRunHTMLApp = NULL;
    HKEY hKey = (HKEY)INVALID_HANDLE_VALUE;    
    DWORD dwType;
    DWORD dwLen = ARRAYSIZE;
    LPSTR lpszMshtmlPath = new char[ARRAYSIZE];
    LPSTR lpszExpandedMshtmlPath = new char[ARRAYSIZE];

    if (!lpszMshtmlPath || !lpszExpandedMshtmlPath)
        goto Cleanup;

    // Find the location of the registered mshtml.dll on this system

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_CLASSES_ROOT, "clsid\\{25336920-03f9-11cf-8fd0-00aa00686f13}\\InProcServer32", 0, KEY_QUERY_VALUE, &hKey))
        goto Cleanup;

    if (ERROR_SUCCESS != RegQueryValueExA(hKey, NULL, NULL, &dwType, (LPBYTE)lpszMshtmlPath, &dwLen))
        goto Cleanup;
        
    // Expand environment variables, if necessary
    if (REG_EXPAND_SZ == dwType)
    {
        if (0 == ExpandEnvironmentStringsA(lpszMshtmlPath, lpszExpandedMshtmlPath, ARRAYSIZE))
            goto Cleanup;
    }
    
    hinstMSHTML = LoadLibraryA(((dwType == REG_EXPAND_SZ) ? lpszExpandedMshtmlPath : lpszMshtmlPath));

    // Done with the char arrays and reg handle, release now so they aren't allocated
    // for the entire lifetime of the HTA.

    delete [] lpszMshtmlPath;
    delete [] lpszExpandedMshtmlPath;
    lpszMshtmlPath = lpszExpandedMshtmlPath = NULL;

    if (hKey != INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hKey);
        hKey = (HKEY)INVALID_HANDLE_VALUE;
    }
    
    // Run the HTA
    if (hinstMSHTML)
    {
        lpfnRunHTMLApp = (RUNHTMLAPPLICATIONFN *) GetProcAddress(hinstMSHTML, "RunHTMLApplication");
        if (lpfnRunHTMLApp)
        {
            (*lpfnRunHTMLApp)(hinst, hPrevInst, szCmdLine, nCmdShow);
        }
        FreeLibrary(hinstMSHTML);
    }

Cleanup:

    if (lpszMshtmlPath)
        delete [] lpszMshtmlPath;

    if (lpszExpandedMshtmlPath)
        delete [] lpszExpandedMshtmlPath;
        
    if (hKey != INVALID_HANDLE_VALUE)
        RegCloseKey(hKey);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\intl\intlcore\altfont.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       altfont.cxx
//
//  Contents:   Alternate font name helpers.
//              Provide English <=> localized font name mapping.
//
//  The following was generated programmatically.  It is crucial that the
//  strings remain sort StrCmpIC-wise, as we use a bsearch to find the
//  alternate name of the font.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const TCHAR g_pszAltFontName000[] = L"Ami R";
const TCHAR g_pszAltFontName001[] = L"AR P\x30da\x30f3\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName002[] = L"AR P\x30da\x30f3\x884c\x6977\x66f8\x4f53 L";
const TCHAR g_pszAltFontName003[] = L"AR P\x52d8\x4ead\x6d41H";
const TCHAR g_pszAltFontName004[] = L"AR P\x53e4\x5370\x4f53\x0042";
const TCHAR g_pszAltFontName005[] = L"AR P\x6977\x66f8\x4f53\x4f53 M";
const TCHAR g_pszAltFontName006[] = L"AR P\x767d\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName007[] = L"AR P\x884c\x6977\x66f8\x4f53H";
const TCHAR g_pszAltFontName008[] = L"AR P\x884c\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName009[] = L"AR P\x96b7\x66f8\x4f53 M";
const TCHAR g_pszAltFontName010[] = L"AR P\x9ed2\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName011[] = L"Arphic Gyokailenmentai Heavy JIS";
const TCHAR g_pszAltFontName012[] = L"Arphic Gyokailenmentai Light JIS";
const TCHAR g_pszAltFontName013[] = L"Arphic Gyokaisho Heavy JIS";
const TCHAR g_pszAltFontName014[] = L"Arphic Gyokaisho Light JIS";
const TCHAR g_pszAltFontName015[] = L"Arphic Kaisho Medium JIS";
const TCHAR g_pszAltFontName016[] = L"Arphic Kanteiryu Heavy JIS";
const TCHAR g_pszAltFontName017[] = L"Arphic Koin-Tai Bold JIS";
const TCHAR g_pszAltFontName018[] = L"Arphic Kuro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName019[] = L"Arphic Pengyokaisho Light JIS";
const TCHAR g_pszAltFontName020[] = L"Arphic Penkaisho Light JIS";
const TCHAR g_pszAltFontName021[] = L"Arphic PGyokaisho Heavy JIS";
const TCHAR g_pszAltFontName022[] = L"Arphic PGyokaisho Light JIS";
const TCHAR g_pszAltFontName023[] = L"Arphic PKaisho Medium JIS";
const TCHAR g_pszAltFontName024[] = L"Arphic PKanteiryu Heavy JIS";
const TCHAR g_pszAltFontName025[] = L"Arphic PKoin-Tai Bold JIS";
const TCHAR g_pszAltFontName026[] = L"Arphic PKuro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName027[] = L"Arphic PPengyokaisho Light JIS";
const TCHAR g_pszAltFontName028[] = L"Arphic PPenkaisho Light JIS";
const TCHAR g_pszAltFontName029[] = L"Arphic PReisho Medium JIS";
const TCHAR g_pszAltFontName030[] = L"Arphic PSiro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName031[] = L"Arphic Reisho Medium JIS";
const TCHAR g_pszAltFontName032[] = L"Arphic Siro-Maru-POP Heavy JIS";
const TCHAR g_pszAltFontName033[] = L"AR\x30da\x30f3\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName034[] = L"AR\x30da\x30f3\x884c\x6977\x66f8\x4f53 L";
const TCHAR g_pszAltFontName035[] = L"AR\x52d8\x4ead\x6d41H";
const TCHAR g_pszAltFontName036[] = L"AR\x53e4\x5370\x4f53\x0042";
const TCHAR g_pszAltFontName037[] = L"AR\x6977\x66f8\x4f53 M";
const TCHAR g_pszAltFontName038[] = L"AR\x767d\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName039[] = L"AR\x884c\x6977\x66f8\x4f53H";
const TCHAR g_pszAltFontName040[] = L"AR\x884c\x6977\x66f8\x4f53L";
const TCHAR g_pszAltFontName041[] = L"AR\x884c\x6977\x9023\x7dbf\x4f53H";
const TCHAR g_pszAltFontName042[] = L"AR\x884c\x6977\x9023\x7dbf\x4f53L";
const TCHAR g_pszAltFontName043[] = L"AR\x96b7\x66f8\x4f53 M";
const TCHAR g_pszAltFontName044[] = L"AR\x9ed2\x4e38\xff30\xff2f\xff30\x4f53H";
const TCHAR g_pszAltFontName045[] = L"Batang";
const TCHAR g_pszAltFontName046[] = L"BatangChe";
const TCHAR g_pszAltFontName047[] = L"DFGothic-EB";
const TCHAR g_pszAltFontName048[] = L"DFKai-SB";
const TCHAR g_pszAltFontName049[] = L"DFLiHeiBold";
const TCHAR g_pszAltFontName050[] = L"DFLiHeiBold(P)";
const TCHAR g_pszAltFontName051[] = L"DFPGothic-EB";
const TCHAR g_pszAltFontName052[] = L"DFPOP-SB";
const TCHAR g_pszAltFontName053[] = L"DFPPOP-SB";
const TCHAR g_pszAltFontName054[] = L"Dotum";
const TCHAR g_pszAltFontName055[] = L"DotumChe";
const TCHAR g_pszAltFontName056[] = L"Expo M";
const TCHAR g_pszAltFontName057[] = L"FangSong_GB2312";
const TCHAR g_pszAltFontName058[] = L"FZShuTi";
const TCHAR g_pszAltFontName059[] = L"FZYaoTi";
const TCHAR g_pszAltFontName060[] = L"Gulim";
const TCHAR g_pszAltFontName061[] = L"GulimChe";
const TCHAR g_pszAltFontName062[] = L"Gungsuh";
const TCHAR g_pszAltFontName063[] = L"GungsuhChe";
const TCHAR g_pszAltFontName064[] = L"Headline R";
const TCHAR g_pszAltFontName065[] = L"Headline Sans R";
const TCHAR g_pszAltFontName066[] = L"HGGothicE";
const TCHAR g_pszAltFontName067[] = L"HGGothicM";
const TCHAR g_pszAltFontName068[] = L"HGGyoshotai";
const TCHAR g_pszAltFontName069[] = L"HGKyokashotai";
const TCHAR g_pszAltFontName070[] = L"HGMinchoB";
const TCHAR g_pszAltFontName071[] = L"HGMinchoE";
const TCHAR g_pszAltFontName072[] = L"HGPGothicE";
const TCHAR g_pszAltFontName073[] = L"HGPGothicM";
const TCHAR g_pszAltFontName074[] = L"HGPGyoshotai";
const TCHAR g_pszAltFontName075[] = L"HGPKyokashotai";
const TCHAR g_pszAltFontName076[] = L"HGPMinchoB";
const TCHAR g_pszAltFontName077[] = L"HGPMinchoE";
const TCHAR g_pszAltFontName078[] = L"HGPSoeiKakugothicUB";
const TCHAR g_pszAltFontName079[] = L"HGPSoeiKakupoptai";
const TCHAR g_pszAltFontName080[] = L"HGPSoeiPresenceEB";
const TCHAR g_pszAltFontName081[] = L"HGP\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName082[] = L"HGP\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName083[] = L"HGP\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName084[] = L"HGP\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName085[] = L"HGP\x660e\x671d\x0042";
const TCHAR g_pszAltFontName086[] = L"HGP\x660e\x671d\x0045";
const TCHAR g_pszAltFontName087[] = L"HGP\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName088[] = L"HGP\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName089[] = L"HGP\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName090[] = L"HGSGothicE";
const TCHAR g_pszAltFontName091[] = L"HGSGothicM";
const TCHAR g_pszAltFontName092[] = L"HGSGyoshotai";
const TCHAR g_pszAltFontName093[] = L"HGSKyokashotai";
const TCHAR g_pszAltFontName094[] = L"HGSMinchoB";
const TCHAR g_pszAltFontName095[] = L"HGSMinchoE";
const TCHAR g_pszAltFontName096[] = L"HGSoeiKakugothicUB";
const TCHAR g_pszAltFontName097[] = L"HGSoeiKakupoptai";
const TCHAR g_pszAltFontName098[] = L"HGSoeiPresenceEB";
const TCHAR g_pszAltFontName099[] = L"HGSSoeiKakugothicUB";
const TCHAR g_pszAltFontName100[] = L"HGSSoeiKakupoptai";
const TCHAR g_pszAltFontName101[] = L"HGSSoeiPresenceEB";
const TCHAR g_pszAltFontName102[] = L"HGS\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName103[] = L"HGS\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName104[] = L"HGS\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName105[] = L"HGS\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName106[] = L"HGS\x660e\x671d\x0042";
const TCHAR g_pszAltFontName107[] = L"HGS\x660e\x671d\x0045";
const TCHAR g_pszAltFontName108[] = L"HGS\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName109[] = L"HGS\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName110[] = L"HGS\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName111[] = L"HG\x5275\x82f1\x89d2\xff7a\xff9e\xff7c\xff6f\xff78UB";
const TCHAR g_pszAltFontName112[] = L"HG\x5275\x82f1\x89d2\xff8e\xff9f\xff6f\xff8c\xff9f\x4f53";
const TCHAR g_pszAltFontName113[] = L"HG\x5275\x82f1\xff8c\xff9f\xff9a\xff7e\xff9e\xff9d\xff7d\x0045\x0042";
const TCHAR g_pszAltFontName114[] = L"HG\x6559\x79d1\x66f8\x4f53";
const TCHAR g_pszAltFontName115[] = L"HG\x660e\x671d\x0042";
const TCHAR g_pszAltFontName116[] = L"HG\x660e\x671d\x0045";
const TCHAR g_pszAltFontName117[] = L"HG\x884c\x66f8\x4f53";
const TCHAR g_pszAltFontName118[] = L"HG\xff7a\xff9e\xff7c\xff6f\xff78\x0045";
const TCHAR g_pszAltFontName119[] = L"HG\xff7a\xff9e\xff7c\xff6f\xff78M";
const TCHAR g_pszAltFontName120[] = L"HYGothic-Extra";
const TCHAR g_pszAltFontName121[] = L"HYMyeongJo-Extra";
const TCHAR g_pszAltFontName122[] = L"HYPMokGak-Bold";
const TCHAR g_pszAltFontName123[] = L"HYPost-Medium";
const TCHAR g_pszAltFontName124[] = L"HYShortSamul-Medium";
const TCHAR g_pszAltFontName125[] = L"HYSinMun-MyeongJo";
const TCHAR g_pszAltFontName126[] = L"HYTaJa-Medium";
const TCHAR g_pszAltFontName127[] = L"HY\xacac\xace0\xb515";
const TCHAR g_pszAltFontName128[] = L"HY\xacac\xba85\xc870";
const TCHAR g_pszAltFontName129[] = L"HY\xbaa9\xac01\xd30c\xc784\x0042";
const TCHAR g_pszAltFontName130[] = L"HY\xc2e0\xbb38\xba85\xc870";
const TCHAR g_pszAltFontName131[] = L"HY\xc595\xc740\xc0d8\xbb3cM";
const TCHAR g_pszAltFontName132[] = L"HY\xc5fd\xc11cM";
const TCHAR g_pszAltFontName133[] = L"HY\xd0c0\xc790M";
const TCHAR g_pszAltFontName134[] = L"KaiTi_GB2312";
const TCHAR g_pszAltFontName135[] = L"LiSu";
const TCHAR g_pszAltFontName136[] = L"MingLiU";
const TCHAR g_pszAltFontName137[] = L"MingLiU_HKSCS";
const TCHAR g_pszAltFontName138[] = L"MoeumT R";
const TCHAR g_pszAltFontName139[] = L"MS Gothic";
const TCHAR g_pszAltFontName140[] = L"MS Mincho";
const TCHAR g_pszAltFontName141[] = L"MS PGothic";
const TCHAR g_pszAltFontName142[] = L"MS PMincho";
const TCHAR g_pszAltFontName143[] = L"NSimSun";
const TCHAR g_pszAltFontName144[] = L"PMingLiU";
const TCHAR g_pszAltFontName145[] = L"Pyunji R";
const TCHAR g_pszAltFontName146[] = L"SimHei";
const TCHAR g_pszAltFontName147[] = L"SimSun";
const TCHAR g_pszAltFontName148[] = L"STCaiyun";
const TCHAR g_pszAltFontName149[] = L"STFangsong";
const TCHAR g_pszAltFontName150[] = L"STHupo";
const TCHAR g_pszAltFontName151[] = L"STKaii";
const TCHAR g_pszAltFontName152[] = L"STLiti";
const TCHAR g_pszAltFontName153[] = L"STSong";
const TCHAR g_pszAltFontName154[] = L"STXihei";
const TCHAR g_pszAltFontName155[] = L"STXingkai";
const TCHAR g_pszAltFontName156[] = L"STXinwei";
const TCHAR g_pszAltFontName157[] = L"STZhongsong";
const TCHAR g_pszAltFontName158[] = L"Yet R";
const TCHAR g_pszAltFontName159[] = L"YouYuan";
const TCHAR g_pszAltFontName160[] = L"\x4eff\x5b8b_GBG2312";
const TCHAR g_pszAltFontName161[] = L"\x534e\x6587\x4e2d\x5b8b";
const TCHAR g_pszAltFontName162[] = L"\x534e\x6587\x4eff\x5b8b";
const TCHAR g_pszAltFontName163[] = L"\x534e\x6587\x5b8b\x4f53";
const TCHAR g_pszAltFontName164[] = L"\x534e\x6587\x5f69\x4e91";
const TCHAR g_pszAltFontName165[] = L"\x534e\x6587\x65b0\x9b4f";
const TCHAR g_pszAltFontName166[] = L"\x534e\x6587\x6977\x4f53";
const TCHAR g_pszAltFontName167[] = L"\x534e\x6587\x7425\x73c0";
const TCHAR g_pszAltFontName168[] = L"\x534e\x6587\x7ec6\x9ed1";
const TCHAR g_pszAltFontName169[] = L"\x534e\x6587\x884c\x6977";
const TCHAR g_pszAltFontName170[] = L"\x534e\x6587\x96b6\x4e66";
const TCHAR g_pszAltFontName171[] = L"\x5b8b\x4f53";
const TCHAR g_pszAltFontName172[] = L"\x5e7c\x5706";
const TCHAR g_pszAltFontName173[] = L"\x65b0\x5b8b\x4f53";
const TCHAR g_pszAltFontName174[] = L"\x65b0\x7d30\x660e\x9ad4";
const TCHAR g_pszAltFontName175[] = L"\x65b9\x6b63\x59da\x4f53\x7b80\x4f53";
const TCHAR g_pszAltFontName176[] = L"\x65b9\x6b63\x8212\x4f53\x7b80\x4f53";
const TCHAR g_pszAltFontName177[] = L"\x6977\x4f53_GBG2312";
const TCHAR g_pszAltFontName178[] = L"\x6a19\x6977\x9ad4";
const TCHAR g_pszAltFontName179[] = L"\x7d30\x660e\x9ad4";
const TCHAR g_pszAltFontName180[] = L"\x7d30\x660e\x9ad4_HKSCS";
const TCHAR g_pszAltFontName181[] = L"\x83ef\x5eb7\x5137\x7c97\x9ed1";
const TCHAR g_pszAltFontName182[] = L"\x83ef\x5eb7\x65b0\x5137\x7c97\x9ed1";
const TCHAR g_pszAltFontName183[] = L"\x96b6\x4e66";
const TCHAR g_pszAltFontName184[] = L"\x9ed1\x4f53";
const TCHAR g_pszAltFontName185[] = L"\xad74\xb9bc";
const TCHAR g_pszAltFontName186[] = L"\xad74\xb9bc\xccb4";
const TCHAR g_pszAltFontName187[] = L"\xad81\xc11c";
const TCHAR g_pszAltFontName188[] = L"\xad81\xc11c\xccb4";
const TCHAR g_pszAltFontName189[] = L"\xb3cb\xc6c0";
const TCHAR g_pszAltFontName190[] = L"\xb3cb\xc6c0\xccb4";
const TCHAR g_pszAltFontName191[] = L"\xbc14\xd0d5";
const TCHAR g_pszAltFontName192[] = L"\xbc14\xd0d5\xccb4";
const TCHAR g_pszAltFontName193[] = L"\xd734\xba3c\xac01\xc9c4\xd5e4\xb4dc\xb77c\xc778";
const TCHAR g_pszAltFontName194[] = L"\xd734\xba3c\xb465\xadfc\xd5e4\xb4dc\xb77c\xc778";
const TCHAR g_pszAltFontName195[] = L"\xd734\xba3c\xbaa8\xc74cT";
const TCHAR g_pszAltFontName196[] = L"\xd734\xba3c\xc544\xbbf8\xccb4";
const TCHAR g_pszAltFontName197[] = L"\xd734\xba3c\xc5d1\xc2a4\xd3ec";
const TCHAR g_pszAltFontName198[] = L"\xd734\xba3c\xc61b\xccb4";
const TCHAR g_pszAltFontName199[] = L"\xd734\xba3c\xd3b8\xc9c0\xccb4";
const TCHAR g_pszAltFontName200[] = L"\xff24\xff26POP\x4f53";
const TCHAR g_pszAltFontName201[] = L"\xff24\xff26\x7279\x592a\x30b4\x30b7\x30c3\x30af\x4f53";
const TCHAR g_pszAltFontName202[] = L"\xff24\xff26\xff30POP\x4f53";
const TCHAR g_pszAltFontName203[] = L"\xff24\xff26\xff30\x7279\x592a\x30b4\x30b7\x30c3\x30af\x4f53";
const TCHAR g_pszAltFontName204[] = L"\xff28\xff27\x30b4\x30b7\x30c3\x30af\x0045-PRO";
const TCHAR g_pszAltFontName205[] = L"\xff28\xff27\xff7a\xff9e\xff7c\xff6f\xff78\x0045-PRO";
const TCHAR g_pszAltFontName206[] = L"\xff2d\xff33 \x30b4\x30b7\x30c3\x30af";
const TCHAR g_pszAltFontName207[] = L"\xff2d\xff33 \x660e\x671d";
const TCHAR g_pszAltFontName208[] = L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af";
const TCHAR g_pszAltFontName209[] = L"\xff2d\xff33 \xff30\x660e\x671d";

const TCHAR * const pszAltFontNames[] = 
{
   g_pszAltFontName000,
   g_pszAltFontName001,
   g_pszAltFontName002,
   g_pszAltFontName003,
   g_pszAltFontName004,
   g_pszAltFontName005,
   g_pszAltFontName006,
   g_pszAltFontName007,
   g_pszAltFontName008,
   g_pszAltFontName009,
   g_pszAltFontName010,
   g_pszAltFontName011,
   g_pszAltFontName012,
   g_pszAltFontName013,
   g_pszAltFontName014,
   g_pszAltFontName015,
   g_pszAltFontName016,
   g_pszAltFontName017,
   g_pszAltFontName018,
   g_pszAltFontName019,
   g_pszAltFontName020,
   g_pszAltFontName021,
   g_pszAltFontName022,
   g_pszAltFontName023,
   g_pszAltFontName024,
   g_pszAltFontName025,
   g_pszAltFontName026,
   g_pszAltFontName027,
   g_pszAltFontName028,
   g_pszAltFontName029,
   g_pszAltFontName030,
   g_pszAltFontName031,
   g_pszAltFontName032,
   g_pszAltFontName033,
   g_pszAltFontName034,
   g_pszAltFontName035,
   g_pszAltFontName036,
   g_pszAltFontName037,
   g_pszAltFontName038,
   g_pszAltFontName039,
   g_pszAltFontName040,
   g_pszAltFontName041,
   g_pszAltFontName042,
   g_pszAltFontName043,
   g_pszAltFontName044,
   g_pszAltFontName045,
   g_pszAltFontName046,
   g_pszAltFontName047,
   g_pszAltFontName048,
   g_pszAltFontName049,
   g_pszAltFontName050,
   g_pszAltFontName051,
   g_pszAltFontName052,
   g_pszAltFontName053,
   g_pszAltFontName054,
   g_pszAltFontName055,
   g_pszAltFontName056,
   g_pszAltFontName057,
   g_pszAltFontName058,
   g_pszAltFontName059,
   g_pszAltFontName060,
   g_pszAltFontName061,
   g_pszAltFontName062,
   g_pszAltFontName063,
   g_pszAltFontName064,
   g_pszAltFontName065,
   g_pszAltFontName066,
   g_pszAltFontName067,
   g_pszAltFontName068,
   g_pszAltFontName069,
   g_pszAltFontName070,
   g_pszAltFontName071,
   g_pszAltFontName072,
   g_pszAltFontName073,
   g_pszAltFontName074,
   g_pszAltFontName075,
   g_pszAltFontName076,
   g_pszAltFontName077,
   g_pszAltFontName078,
   g_pszAltFontName079,
   g_pszAltFontName080,
   g_pszAltFontName081,
   g_pszAltFontName082,
   g_pszAltFontName083,
   g_pszAltFontName084,
   g_pszAltFontName085,
   g_pszAltFontName086,
   g_pszAltFontName087,
   g_pszAltFontName088,
   g_pszAltFontName089,
   g_pszAltFontName090,
   g_pszAltFontName091,
   g_pszAltFontName092,
   g_pszAltFontName093,
   g_pszAltFontName094,
   g_pszAltFontName095,
   g_pszAltFontName096,
   g_pszAltFontName097,
   g_pszAltFontName098,
   g_pszAltFontName099,
   g_pszAltFontName100,
   g_pszAltFontName101,
   g_pszAltFontName102,
   g_pszAltFontName103,
   g_pszAltFontName104,
   g_pszAltFontName105,
   g_pszAltFontName106,
   g_pszAltFontName107,
   g_pszAltFontName108,
   g_pszAltFontName109,
   g_pszAltFontName110,
   g_pszAltFontName111,
   g_pszAltFontName112,
   g_pszAltFontName113,
   g_pszAltFontName114,
   g_pszAltFontName115,
   g_pszAltFontName116,
   g_pszAltFontName117,
   g_pszAltFontName118,
   g_pszAltFontName119,
   g_pszAltFontName120,
   g_pszAltFontName121,
   g_pszAltFontName122,
   g_pszAltFontName123,
   g_pszAltFontName124,
   g_pszAltFontName125,
   g_pszAltFontName126,
   g_pszAltFontName127,
   g_pszAltFontName128,
   g_pszAltFontName129,
   g_pszAltFontName130,
   g_pszAltFontName131,
   g_pszAltFontName132,
   g_pszAltFontName133,
   g_pszAltFontName134,
   g_pszAltFontName135,
   g_pszAltFontName136,
   g_pszAltFontName137,
   g_pszAltFontName138,
   g_pszAltFontName139,
   g_pszAltFontName140,
   g_pszAltFontName141,
   g_pszAltFontName142,
   g_pszAltFontName143,
   g_pszAltFontName144,
   g_pszAltFontName145,
   g_pszAltFontName146,
   g_pszAltFontName147,
   g_pszAltFontName148,
   g_pszAltFontName149,
   g_pszAltFontName150,
   g_pszAltFontName151,
   g_pszAltFontName152,
   g_pszAltFontName153,
   g_pszAltFontName154,
   g_pszAltFontName155,
   g_pszAltFontName156,
   g_pszAltFontName157,
   g_pszAltFontName158,
   g_pszAltFontName159,
   g_pszAltFontName160,
   g_pszAltFontName161,
   g_pszAltFontName162,
   g_pszAltFontName163,
   g_pszAltFontName164,
   g_pszAltFontName165,
   g_pszAltFontName166,
   g_pszAltFontName167,
   g_pszAltFontName168,
   g_pszAltFontName169,
   g_pszAltFontName170,
   g_pszAltFontName171,
   g_pszAltFontName172,
   g_pszAltFontName173,
   g_pszAltFontName174,
   g_pszAltFontName175,
   g_pszAltFontName176,
   g_pszAltFontName177,
   g_pszAltFontName178,
   g_pszAltFontName179,
   g_pszAltFontName180,
   g_pszAltFontName181,
   g_pszAltFontName182,
   g_pszAltFontName183,
   g_pszAltFontName184,
   g_pszAltFontName185,
   g_pszAltFontName186,
   g_pszAltFontName187,
   g_pszAltFontName188,
   g_pszAltFontName189,
   g_pszAltFontName190,
   g_pszAltFontName191,
   g_pszAltFontName192,
   g_pszAltFontName193,
   g_pszAltFontName194,
   g_pszAltFontName195,
   g_pszAltFontName196,
   g_pszAltFontName197,
   g_pszAltFontName198,
   g_pszAltFontName199,
   g_pszAltFontName200,
   g_pszAltFontName201,
   g_pszAltFontName202,
   g_pszAltFontName203,
   g_pszAltFontName204,
   g_pszAltFontName205,
   g_pszAltFontName206,
   g_pszAltFontName207,
   g_pszAltFontName208,
   g_pszAltFontName209,
};

const TCHAR * const pszAltFontNamesAlt[] = 
{
   g_pszAltFontName196,
   g_pszAltFontName028,
   g_pszAltFontName027,
   g_pszAltFontName024,
   g_pszAltFontName025,
   g_pszAltFontName023,
   g_pszAltFontName030,
   g_pszAltFontName021,
   g_pszAltFontName022,
   g_pszAltFontName029,
   g_pszAltFontName026,
   g_pszAltFontName041,
   g_pszAltFontName042,
   g_pszAltFontName039,
   g_pszAltFontName040,
   g_pszAltFontName037,
   g_pszAltFontName035,
   g_pszAltFontName036,
   g_pszAltFontName044,
   g_pszAltFontName034,
   g_pszAltFontName033,
   g_pszAltFontName007,
   g_pszAltFontName008,
   g_pszAltFontName005,
   g_pszAltFontName003,
   g_pszAltFontName004,
   g_pszAltFontName010,
   g_pszAltFontName002,
   g_pszAltFontName001,
   g_pszAltFontName009,
   g_pszAltFontName006,
   g_pszAltFontName043,
   g_pszAltFontName038,
   g_pszAltFontName020,
   g_pszAltFontName019,
   g_pszAltFontName016,
   g_pszAltFontName017,
   g_pszAltFontName015,
   g_pszAltFontName032,
   g_pszAltFontName013,
   g_pszAltFontName014,
   g_pszAltFontName011,
   g_pszAltFontName012,
   g_pszAltFontName031,
   g_pszAltFontName018,
   g_pszAltFontName191,
   g_pszAltFontName192,
   g_pszAltFontName201,
   g_pszAltFontName178,
   g_pszAltFontName181,
   g_pszAltFontName182,
   g_pszAltFontName203,
   g_pszAltFontName200,
   g_pszAltFontName202,
   g_pszAltFontName189,
   g_pszAltFontName190,
   g_pszAltFontName197,
   g_pszAltFontName160,
   g_pszAltFontName176,
   g_pszAltFontName175,
   g_pszAltFontName185,
   g_pszAltFontName186,
   g_pszAltFontName187,
   g_pszAltFontName188,
   g_pszAltFontName194,
   g_pszAltFontName193,
   g_pszAltFontName118,
   g_pszAltFontName119,
   g_pszAltFontName117,
   g_pszAltFontName114,
   g_pszAltFontName115,
   g_pszAltFontName116,
   g_pszAltFontName088,
   g_pszAltFontName089,
   g_pszAltFontName087,
   g_pszAltFontName084,
   g_pszAltFontName085,
   g_pszAltFontName086,
   g_pszAltFontName081,
   g_pszAltFontName082,
   g_pszAltFontName083,
   g_pszAltFontName078,
   g_pszAltFontName079,
   g_pszAltFontName080,
   g_pszAltFontName075,
   g_pszAltFontName076,
   g_pszAltFontName077,
   g_pszAltFontName074,
   g_pszAltFontName072,
   g_pszAltFontName073,
   g_pszAltFontName109,
   g_pszAltFontName110,
   g_pszAltFontName108,
   g_pszAltFontName105,
   g_pszAltFontName106,
   g_pszAltFontName107,
   g_pszAltFontName111,
   g_pszAltFontName112,
   g_pszAltFontName113,
   g_pszAltFontName102,
   g_pszAltFontName103,
   g_pszAltFontName104,
   g_pszAltFontName099,
   g_pszAltFontName100,
   g_pszAltFontName101,
   g_pszAltFontName093,
   g_pszAltFontName094,
   g_pszAltFontName095,
   g_pszAltFontName092,
   g_pszAltFontName090,
   g_pszAltFontName091,
   g_pszAltFontName096,
   g_pszAltFontName097,
   g_pszAltFontName098,
   g_pszAltFontName069,
   g_pszAltFontName070,
   g_pszAltFontName071,
   g_pszAltFontName068,
   g_pszAltFontName066,
   g_pszAltFontName067,
   g_pszAltFontName127,
   g_pszAltFontName128,
   g_pszAltFontName129,
   g_pszAltFontName132,
   g_pszAltFontName131,
   g_pszAltFontName130,
   g_pszAltFontName133,
   g_pszAltFontName120,
   g_pszAltFontName121,
   g_pszAltFontName122,
   g_pszAltFontName125,
   g_pszAltFontName124,
   g_pszAltFontName123,
   g_pszAltFontName126,
   g_pszAltFontName177,
   g_pszAltFontName183,
   g_pszAltFontName179,
   g_pszAltFontName180,
   g_pszAltFontName195,
   g_pszAltFontName206,
   g_pszAltFontName207,
   g_pszAltFontName208,
   g_pszAltFontName209,
   g_pszAltFontName173,
   g_pszAltFontName174,
   g_pszAltFontName199,
   g_pszAltFontName184,
   g_pszAltFontName171,
   g_pszAltFontName164,
   g_pszAltFontName162,
   g_pszAltFontName167,
   g_pszAltFontName166,
   g_pszAltFontName170,
   g_pszAltFontName163,
   g_pszAltFontName168,
   g_pszAltFontName169,
   g_pszAltFontName165,
   g_pszAltFontName161,
   g_pszAltFontName198,
   g_pszAltFontName172,
   g_pszAltFontName057,
   g_pszAltFontName157,
   g_pszAltFontName149,
   g_pszAltFontName153,
   g_pszAltFontName148,
   g_pszAltFontName156,
   g_pszAltFontName151,
   g_pszAltFontName150,
   g_pszAltFontName154,
   g_pszAltFontName155,
   g_pszAltFontName152,
   g_pszAltFontName147,
   g_pszAltFontName159,
   g_pszAltFontName143,
   g_pszAltFontName144,
   g_pszAltFontName059,
   g_pszAltFontName058,
   g_pszAltFontName134,
   g_pszAltFontName048,
   g_pszAltFontName136,
   g_pszAltFontName137,
   g_pszAltFontName049,
   g_pszAltFontName050,
   g_pszAltFontName135,
   g_pszAltFontName146,
   g_pszAltFontName060,
   g_pszAltFontName061,
   g_pszAltFontName062,
   g_pszAltFontName063,
   g_pszAltFontName054,
   g_pszAltFontName055,
   g_pszAltFontName045,
   g_pszAltFontName046,
   g_pszAltFontName065,
   g_pszAltFontName064,
   g_pszAltFontName138,
   g_pszAltFontName000,
   g_pszAltFontName056,
   g_pszAltFontName158,
   g_pszAltFontName145,
   g_pszAltFontName052,
   g_pszAltFontName047,
   g_pszAltFontName053,
   g_pszAltFontName051,
   g_pszAltFontName205,
   g_pszAltFontName204,
   g_pszAltFontName139,
   g_pszAltFontName140,
   g_pszAltFontName141,
   g_pszAltFontName142,
};

//+----------------------------------------------------------------------------
//
//  Function:   CompareStringFunction
//
//  Synopsis:   Comparison function used by the bsearch call in the function
//              AlternateFontName.  Note that we call StrCmpIC, so the only
//              variation we recognize is case in the ASCII range.  We *do
//              not*, for example, treat narrow and wide variations or kana
//              variations as equivalent.
//
//-----------------------------------------------------------------------------

int __cdecl
CompareStringFunction( const void * v0, const void * v1)
{
    return StrCmpIC( *(wchar_t **)v0, *(wchar_t **)v1 );
}

//+----------------------------------------------------------------------------
//
//  Function:   AlternateFontName
//
//  Synopsis:   Fonts often have two names associated with them, an ASCII
//              name and a Native name.  This is most often true on Asian
//              systems.  GDI, however, is not smart enough to recognize
//              alternate names as equivalent.  We therefore have a hard-
//              coded table (courtesy of the Office group) to help GDI out.
//
//  Returns:    Alternate font name, or NULL, if none is known.
//
//-----------------------------------------------------------------------------

const wchar_t *
AlternateFontName( const wchar_t * pszName )
{
    wchar_t **pszNameT = (wchar_t **)bsearch( (const void *)&pszName,
                                          (const void *)&pszAltFontNames,
                                          sizeof(pszAltFontNames) / sizeof(wchar_t *),
                                          sizeof(wchar_t *),
                                          CompareStringFunction );
    return pszNameT
            ? pszAltFontNamesAlt[pszNameT - pszAltFontNames]
            : NULL;
}

const wchar_t *
AlternateFontNameIfAvailable( const wchar_t * pszName )
{
    wchar_t **pszNameT = (wchar_t **)bsearch( (const void *)&pszName,
                                          (const void *)&pszAltFontNames,
                                          sizeof(pszAltFontNames) / sizeof(wchar_t *),
                                          sizeof(wchar_t *),
                                          CompareStringFunction );
    return pszNameT
            ? pszAltFontNamesAlt[pszNameT - pszAltFontNames]
            : pszName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\apprc.h ===
#define IDR_APPICON						101
#define IDF_LARGE_ICON					101

#define IDR_SMALLCON					102
#define IDF_SMALL_ICON					102

#define IDR_PADMENU						103

#define IDI_APPICON		                501
#define IDI_APPSMALLICON                502

#define IDS_UNEXPECTED                  1000
#define IDS_CANTNOW                     1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\apprc2.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       apprc2.h
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------


//
// Custom Resource types
//

#define FILERESOURCE    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\app.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       app.cxx
//
//  Contents:   application functionality.
//
//  Created:    02/20/98    philco   
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_APPRC_H_
#define X_APPRC_H_
#include "apprc.h"
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_REGKEY_HXX_
#define X_REGKEY_HXX_
#include "regkey.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

// this is defined in winuser.h for WINVER >= 0x0500
// We need this to compile
#if(WINVER < 0x0500)
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WINVER >= 0x0500 */

DeclareTag(tagHTAWndMsg, "HTA", "HtmlApp Windows Messages")
DeclareTagEx(tagHTAWndAssert, "HTA", "HtmlApp IsWindow Asserts ",TRUE)

CHTMLApp::CHTMLApp()
{
    // Default window styles
    _dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
    _dwStyleEx   = WS_EX_APPWINDOW;
    _windowState = SW_NORMAL;

    _fShowInTaskBar = TRUE;
    _fContextMenu   = TRUE;

    // Set defaults for pending move/resize operations
    _pMovePending.x = _pMovePending.y = LONG_MIN;
    _pSizePending.cx = _pSizePending.cy = LONG_MIN;
}

ULONG
CHTMLApp::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        return 0;
    }
    return _ulAllRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Register
//
//  Synopsis:   Creates registry entries under various keys for this app
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Register()
{
    HRESULT hr = S_OK;
    CRegKey key, subKey, serverKey;
    TCHAR aryAppPath[MAX_PATH+1];
    TCHAR arydefIcon[MAX_PATH+3];
    long lRet = ERROR_SUCCESS;
    
    // Remove any previous registration information
    Unregister();
    
    GetModuleFileName(_hinst, aryAppPath, MAX_PATH);

    // append icon resource ID to app path
    _tcscpy(arydefIcon, aryAppPath);
    _tcscat(arydefIcon, SZ_REG_DEF_ICON_ID);

    // Update file extension
    lRet = key.Create(HKEY_CLASSES_ROOT, SZ_REG_FILE_EXT);
    TESTREG(lRet);
    key.SetValue(SZ_REG_PROGID, NULL);
    key.SetValue(SZ_REG_CONTENT_TYPE, TEXT("Content Type"));

    // Update file association actions
    lRet= key.Create(HKEY_CLASSES_ROOT, SZ_REG_PROGID);
    TESTREG(lRet);
    key.SetValue(SZ_REG_FILE_READABLE_STRING, NULL);

    // Add a key to indicate the default icon for this file type
    lRet = subKey.Create(key, TEXT("DefaultIcon"));
    TESTREG(lRet);
    subKey.SetValue(arydefIcon, NULL);
        
    // Add a shell action key
    lRet = subKey.Create(key, TEXT("Shell\\Open\\Command"));
    TESTREG(lRet);

    TCHAR aryOpenCmd[MAX_PATH+4];
    _tcscpy(aryOpenCmd, aryAppPath);
    _tcscat(aryOpenCmd, TEXT(" \"%1\" %*"));
    subKey.SetValue(aryOpenCmd, NULL);

    // Register COM server information
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("clsid"));
    TESTREG(lRet);

    // add our clsid
    lRet = subKey.Create(key, SZ_SERVER_CLSID);
    TESTREG(lRet);
    subKey.SetValue(SZ_REG_FILE_READABLE_STRING, NULL);

    // Now add all the other server goo
    lRet = serverKey.Create(subKey, TEXT("DefaultIcon"));
    TESTREG(lRet);
    serverKey.SetValue(arydefIcon, NULL);

    lRet = serverKey.Create(subKey, TEXT("LocalServer32"));
    TESTREG(lRet);
    serverKey.SetValue(aryAppPath, NULL);

    lRet = serverKey.Create(subKey, TEXT("Version"));
    TESTREG(lRet);            
    serverKey.SetValue(SZ_APPLICATION_VERSION, NULL);

    lRet = serverKey.Create(subKey, TEXT("ProgID"));
    TESTREG(lRet);            
    serverKey.SetValue(SZ_REG_PROGID, NULL);

    // Update content-type information
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("MIME\\Database\\Content Type"));
    TESTREG(lRet);

    lRet = subKey.Create(key, SZ_REG_CONTENT_TYPE);
    TESTREG(lRet);
    subKey.SetValue(SZ_SERVER_CLSID, TEXT("CLSID"));                    
    subKey.SetValue(SZ_REG_FILE_EXT, TEXT("Extension"));                    

Cleanup:
    if (lRet != ERROR_SUCCESS)
    {
        // On failure, don't leave an inconsistent registry state
        Unregister();  
        hr = E_FAIL;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Unregister
//
//  Synopsis:   Removes registry entries under various keys for this app.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Unregister()
{
    HRESULT hr = S_OK;
    CRegKey key;
    long lRet = ERROR_SUCCESS;
    
    lRet = key.Open(HKEY_CLASSES_ROOT, NULL);
    if (lRet == ERROR_SUCCESS)
    {
        key.RecurseDeleteKey(SZ_REG_FILE_EXT);
        key.RecurseDeleteKey(SZ_REG_PROGID);
    }
    
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("clsid"));
    if (lRet == ERROR_SUCCESS)
        key.RecurseDeleteKey(SZ_SERVER_CLSID);

    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("MIME\\Database\\Content Type"));
    if (lRet == ERROR_SUCCESS)
        key.RecurseDeleteKey(SZ_REG_CONTENT_TYPE);

    if (lRet != ERROR_SUCCESS)
        hr = E_FAIL;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::RegisterWindowClasses
//
//  Synopsis:   Registers window class for app's frame.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::RegisterWindowClasses()
{
    WNDCLASS wc = {0};

    wc.lpfnWndProc   = WndProc;                                                                            
    wc.hInstance     = _hinst;
    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_PADMENU);
    wc.lpszClassName = SZ_APPLICATION_WNDCLASS;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

    if (!RegisterClass(&wc))
    {
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Init
//
//  Synopsis:   One-time initialization 
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Init(HINSTANCE hInst, LPTSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;

    _hinst = hInst;
    _windowState = nCmdShow;
    _cstrCmdLine.Set(lpszCmdLine);
    
    hr = THR(OleInitialize(NULL));

    // Need to remember whether this succeeded.  If it fails, don't
    // call OleUninitialize when the app shuts down.
    if (SUCCEEDED(hr))
        _fOLEInitialized = TRUE;

    TEST(hr);

    // The window must be created before CServerObject::Load is called
    // so that there will be a window for calls to GetViewRect.
    //
    hr = CreateAppWindow();
    TEST(hr);
        
    // COM will pass "/Embedding" as the command line if we are
    // launched via that means.  Register our class factory in 
    // this case.
    if (_tcsiequal(_cstrCmdLine, _T("/Embedding")) ||
        _tcsiequal(_cstrCmdLine, _T("-Embedding")))
    {
        _cstrCmdLine.Free();  // command line shouldn't contain embedding switch.
        _Factory.Register();
    }
    else if (_tcsiequal(_cstrCmdLine, _T("/Register")) ||
        _tcsiequal(_cstrCmdLine, _T("-Register")))
    {
        Register();
        hr = E_FAIL;  // Used to indicate the app should exit immediately
        goto Cleanup;        
    }
    else if (_tcsiequal(_cstrCmdLine, _T("/Unregister")) ||
        _tcsiequal(_cstrCmdLine, _T("-Unregister")))
    {
        Unregister();
        hr = E_FAIL;  // Used to indicate the app should exit immediately
        goto Cleanup;        
    }
    else
    {
        // We are being launched from the command line, or as the result of a
        // file extension association.  The command line argument should contain
        // an URL.

        IMoniker *pMk = NULL;
        
        hr = CreateHTAMoniker(&pMk);
        
        TEST(hr);
        
        hr = _Factory.CreateInstance(NULL, IID_IPersistMoniker, (void **)&_pServer);
        TEST(hr);

        _pServer->Load(TRUE, pMk, NULL, 0);

        ReleaseInterface(((IPersistMoniker *)_pServer));
        _pServer = NULL;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Passivate
//
//  Synopsis:   General cleanup that occurs before dtor
//
//----------------------------------------------------------------------------

void CHTMLApp::Passivate()
{
    // general app cleanup
    
    // Then passivate the subobjects
    _Client.Passivate();
    _Frame.Passivate();
    _Factory.Passivate();

    if (_pServer)
    {
        Assert(!_pServer->GetRefs());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Terminate
//
//  Synopsis:   Called when app terminates.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Terminate()
{
    HRESULT hr = S_OK;
    
    Passivate();
    
    if (_pServer)
    {
        ReleaseInterface(((IPersistMoniker *)_pServer));
        _pServer = NULL;
    }

    if (_aAppName)
    {
        ::GlobalDeleteAtom(_aAppName);
        _aAppName = NULL;
    }

    if (_fOLEInitialized)
        OleUninitialize();

    // If there is a hidden parent window, destroy it now.
    if (_hwndParent)
       DestroyWindow(_hwndParent);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Run
//
//  Synopsis:   Message pump
//
//----------------------------------------------------------------------------

void CHTMLApp::Run()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (S_FALSE == _Frame.TranslateKeyMsg(&msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::CreateHTAMoniker
//
//  Synopsis:   Creates an URL moniker based on the command line provided by
//              the system.
//
//  Notes:      This function is invoked only when an HTA is launched from a
//              command line or by the shell.
//----------------------------------------------------------------------------

HRESULT CHTMLApp::CreateHTAMoniker(IMoniker ** ppm)
{
    HRESULT hr = S_OK;
    CStr cstrPath;

    Assert(ppm);

    // Make a copy, remove command-line arguments and quotes.
    cstrPath.Set(_cstrCmdLine);
    PathRemoveArgs(cstrPath);
    PathUnquoteSpaces(cstrPath);
    
#ifndef UNICODE
    // Convert ansi URL to Unicode
    WCHAR awch[pdlUrlLen];
    UnicodeFromMbcs(awch, pdlUrlLen, cstrPath);
    hr = ::CreateURLMoniker(NULL, awch, ppm);
#else
    hr = ::CreateURLMoniker(NULL, cstrPath, ppm);
#endif

    TEST(hr);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::RunHTMLApplication
//
//  Synopsis:   Given a moniker, creates the frame window and an instance of 
//              trident.  Loads the moniker and activates Trident as a doc object.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::RunHTMLApplication(IMoniker *pMk)
{
	HRESULT hr = S_OK;

	// A moniker is required.  Otherwise, what would we load?
	if (!pMk)
	{
		hr = E_POINTER;
		goto Cleanup;
	}
	
    hr = THR(_Client.Create(CLSID_HTADoc));
    TEST(hr);
    
    hr = THR(_Client.Load(pMk));
    TEST(hr);
    
    // We must activate the document here otherwise
    // modal dialogs such as VBScript's MsgBox won't work.
    //
    IGNORE_HR(_Client.Show());

Cleanup:
	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::GetViewRect
//
//  Synopsis:   Provides the current client rect.
//
//----------------------------------------------------------------------------

void CHTMLApp::GetViewRect(OLERECT *prc)
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}   
#endif

    if (prc)
    {
        ::GetClientRect(_hwnd, prc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Resize
//
//  Synopsis:   Resizes the doc object to fill the new size of our frame window.
//
//----------------------------------------------------------------------------

void CHTMLApp::Resize()
{
    _Frame.Resize();
    _Client.Resize(); 
}


HRESULT CHTMLApp::Pending_moveTo(long x, long y)
{
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    _pMovePending.x = x;
    _pMovePending.y = y;

    return S_OK;
}

HRESULT CHTMLApp::Pending_moveBy(long x, long y)
{
    HRESULT hr = E_PENDING;
    
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    // Can't move by a relative amount until we have a non-default rect.
    if (_pMovePending.x != LONG_MIN && _pMovePending.y != LONG_MIN)
    {
        _pMovePending += CSize(x, y);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CHTMLApp::Pending_resizeTo(long x, long y)
{
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    _pSizePending.SetSize(x, y);

    return S_OK;
}

HRESULT CHTMLApp::Pending_resizeBy(long x, long y)
{
    HRESULT hr = E_PENDING;
    
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    // Can't resize by a relative amount until we have a non-default rect.
    if (_pSizePending.cx != LONG_MIN && _pSizePending.cy != LONG_MIN)
    {
        _pSizePending += CSize(x, y);
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::CreateAppWindow
//
//  Synopsis:   Creates the application's frame window
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::CreateAppWindow()
{
    HRESULT hr = S_OK;

    // This method should only be called one time.
    Assert(!::IsWindow(_hwnd));
    
    if (::IsWindow(_hwnd))
        goto Error;
        
    // Register our window class
    hr = THR(RegisterWindowClasses());
    TEST(hr);

    // Create a hidden window to parent the app. This is necessary so
    // that if the user specifies showInTaskBar="no", the taskbar icon
    // will not be displayed.
    //
    _hwndParent = CreateWindowEx(
        0,
        SZ_APPLICATION_WNDCLASS,
        _T(""),
        0,
        0, 0, 0, 0,
        NULL,
        NULL,
        _hinst,
        this);

    Assert(::IsWindow(_hwndParent));
    
    if (!_hwndParent)
        goto Error;
       
    // We set this extended style here rather than in the CHTMLApp constructor
    // where the other styles are initialized because the g_fMirroredBidiLayout
    // is not initialized by then
    // If the following two lines change, update it for the html dialogs 
    // as well (..\htmldlg\htmldlg.cxx - CHTMLDlg::Activate)
    if (g_fMirroredBidiLayout)
        _dwStyleEx |= WS_EX_LAYOUTRTL;

    // Create main application window.
    _hwnd = CreateWindowEx(
            _dwStyleEx,
            _cstrAppName ? _cstrAppName : SZ_APPLICATION_WNDCLASS,
            _T(""),
            _dwStyle,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            _hwndParent,
            NULL,
            _hinst,
            this);

#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}
#endif

    if (!_hwnd)
        goto Error;

    // Morph to a popup style...
    _dwStyle |= WS_POPUP;
    ::SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
    ::SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    
    // If we are running on NT5, then we need to tell the window that we are
    // interested in UIState messages.  This should only be called once per top
    // level window
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::ShowFrameWindow
//
//  Synopsis:   Shows the application's frame window (setting initial size/position if
//              appropriate
//
//----------------------------------------------------------------------------

void CHTMLApp::ShowFrameWindow()
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}   
#endif
    
    // There will be a pending move if script has already called MoveTo before
    // this window was shown.
    if ((_pMovePending.x != LONG_MIN) && (_pMovePending.y != LONG_MIN))
    {
        // Move to new location.
        SetWindowPos(_hwnd,
                 NULL, 
                 _pMovePending.x, 
                 _pMovePending.y, 
                 0, 
                 0, 
                 SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE );

        // Being paranoid here...  not strictly necessary.
        _pMovePending.x = _pMovePending.y = LONG_MIN;
    }
    
    // There will be a pending size if script has already called resizeTo before
    // this window was shown.
    if ((_pSizePending.cx != LONG_MIN) && (_pSizePending.cy != LONG_MIN))
    {
        // resize according to pending information.
        SetWindowPos(_hwnd,
                 NULL, 
                 0, 
                 0, 
                 _pSizePending.cx, 
                 _pSizePending.cy, 
                 SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE );

        // Being paranoid here...  not strictly necessary.
        _pSizePending.cx = _pSizePending.cy = LONG_MIN;
    }


    ShowWindow(_hwnd, _windowState);
    UpdateWindow(_hwnd); 
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::SetTitle
//
//  Synopsis:   Sets the caption for frame window.
//
//----------------------------------------------------------------------------

void CHTMLApp::SetTitle(TCHAR * pchTitle)
{
    TCHAR szBuf[512];

#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(IsWindow(_hwnd));
}   
#endif

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    if (!_tcsequal(szBuf, pchTitle))
    {
        SetWindowText(_hwnd, pchTitle);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::SetAttributes
//
//  Synopsis:   Retrieves application attributes from the behavior.
//
//----------------------------------------------------------------------------

void CHTMLApp::SetAttributes(CAppBehavior *pApp)
{
    CDoc *  pDoc; 
    HRESULT hr;

    // Get these directly from the attribute array.
    _fSingleInstance = pApp->GetAAsingleInstance();
    _cstrAppName.Set(pApp->GetAAapplicationName());

    // Handle single instance behavior
    if (_fSingleInstance && PriorInstance())
    {
        _fLoaded = TRUE;  // Needed so that FinalInit won't be called in CClient::Exec
        
        ::PostQuitMessage(0);
        return;  
    }

    // Computed values
    _dwStyle = pApp->GetStyles();
    _dwStyleEx |= pApp->GetExtendedStyles();
    
    _fShowInTaskBar  = pApp->GetAAshowInTaskBar();
    _fContextMenu    = pApp->GetAAcontextMenu();
    
    _windowState = pApp->GetAAwindowState();
    _cstrAppIcon.Set(pApp->GetAAicon());
    _cstrAppVersion.Set(pApp->GetAAversion());

    Assert(_Client._pUnk);
    
    hr = THR(_Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));

    if (SUCCEEDED(hr))
    {
        // Set IDocHostUIHandler Flags
        //
        // Note that the default values of navigable and scrollFlat are 
        // different than the other properties. They are "no" by default.
        //
        if (pApp->GetAAnavigable())  // Allow inplace navigation of top-level content
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
            _dwHostInfo |= DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
        }

        if (pApp->GetAAscrollFlat())  
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
            _dwHostInfo |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
        }

        if (!pApp->GetAAinnerBorder())
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_NO3DBORDER;
            _dwHostInfo |= DOCHOSTUIFLAG_NO3DBORDER;
        }

        if (!pApp->GetAAscroll())
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_SCROLL_NO;
            _dwHostInfo |= DOCHOSTUIFLAG_SCROLL_NO;
        }

        if (!pApp->GetAAselection())  // Acts like a dialog: no selection
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_DIALOG;
            _dwHostInfo |= DOCHOSTUIFLAG_DIALOG;
        }
    }

    FinalInit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::FinalInit
//
//  Synopsis:   Performs final initialization operations such as checking 
//              for other instances of the application if singleInstance
//              is set and showing the window.
//
//----------------------------------------------------------------------------

void CHTMLApp::FinalInit()
{
    HICON   hIcon = NULL;
    HRESULT hr;
    CDoc *  pDoc; 

    Assert(_Client._pUnk);
    
    hr = THR(_Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));

    if (hr)
        return;

    pDoc->UpdateTitle();
    
    if (_cstrAppIcon)
    {
        hIcon = ::ExtractIcon(_hinst, _cstrAppIcon, 0);
    }

    // If we don't have a custom icon (or it couldn't be loaded), use the
    // default windows application icon.
    if ((HICON)1 == hIcon || NULL == hIcon)
    {
        hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
    }

    if (hIcon)
    {
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
        Assert(::IsWindow(_hwndParent));
        Assert(::IsWindow(_hwnd));
}   
#endif
    

        // Set the big icon for the parent so that the icon is displayed in 
        // the ALT+TAB dialog. Set the small icon for the displayed window
        // so that the icon will be displayed in the title bar.
        //
        ::SendMessage(_hwndParent, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)hIcon);
        ::SendMessage(_hwnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);
    }

    // If the user has specified showInTaskBar="no", 
    // do not show the icon on the taskbar.
    //
    if (!_fShowInTaskBar)
    {
        _dwStyleEx &= ~WS_EX_APPWINDOW;
    }

    // Apply final window styles before showing the frame window
    ::SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
    ::SetWindowLong(_hwnd, GWL_EXSTYLE, _dwStyleEx);
    ::SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

    // Save the application name in the window property table associated for this window.
    // This is used in PriorInstance() for the singleInstance functionality.
    //
    _aAppName = GlobalAddAtom((LPTSTR)_cstrAppName);
    ::SetProp(_hwndParent, (LPCTSTR)_aAppName, (HANDLE)_hwndParent ? _hwndParent : _hwnd);


    ShowFrameWindow();

    _fLoaded = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::PriorInstance
//
//  Synopsis:   Searches for another window that has a class name matching the
//              application name attribute for this instance.  Returns TRUE if
//              such a window is found.  Also brings that window (and any associated
//              popups) to the foreground.
//
//----------------------------------------------------------------------------

BOOL CHTMLApp::PriorInstance()
{
    BOOL  fPriorInstance = FALSE;
    TCHAR szClassName[MAX_PATH];
    HWND  hwndNext;

    // Only check for a prior instance if we aren't already loaded.
    // This prevents us from being shut down in the case of a refresh.
    // Also, we need an application name to determine if a prior 
    // instance is running
    //
    if (_fLoaded || !_cstrAppName)
    {
        goto Cleanup;
    }

    // Look for any other HTA windows that have the same application
    // name as this one. The application name is stored in the window
    // properties table for the HTA window.
    //
    hwndNext = ::FindWindow(SZ_APPLICATION_WNDCLASS, NULL);

    while (hwndNext)
    {
        memset(szClassName, 0, sizeof(szClassName));
        
        if (!::GetClassName(hwndNext, szClassName, ARRAY_SIZE(szClassName)))
        {
            goto Cleanup;
        }

        if (!StrCmp(szClassName, SZ_APPLICATION_WNDCLASS))
        {
            if (::GetProp(hwndNext, (LPCTSTR)GlobalFindAtom((LPTSTR)_cstrAppName)))
            {
                HWND hwndChild = ::GetLastActivePopup(hwndNext);

                // If previous instance is minimized, restore it.
                if (::IsIconic(hwndNext))
                {
                    ::ShowWindow(hwndNext, SW_RESTORE);
                }

                // Bring the previous instance (or its last popup window) to the foreground.
                ::SetForegroundWindow(hwndChild);

                // Previous instance was running...
                fPriorInstance = TRUE;
                break;
            }
        }

        hwndNext = ::GetWindow(hwndNext, GW_HWNDNEXT);
    }

Cleanup:
    return fPriorInstance;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::HandleClose
//
//  Synopsis:   Handles closing the application.  Causes onBeforeUnload to be fired.
//
//----------------------------------------------------------------------------

void
CHTMLApp::HandleClose(HWND hwnd)
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(IsWindow(hwnd) && (_hwnd == hwnd));
}   
#endif

    CVariant varOut;

    _Client.SendCommand(NULL, OLECMDID_ONUNLOAD, OLECMDEXECOPT_PROMPTUSER, NULL, &varOut);
    if ((V_VT(&varOut) == VT_BOOL) && (V_BOOL(&varOut)) != VARIANT_TRUE)
        return;

    DestroyWindow(hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::WndProc
//
//  Synopsis:   WndProc for the frame.
//
//----------------------------------------------------------------------------

LRESULT CHTMLApp::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_CLOSE:
        TraceTag((tagHTAWndMsg, "WM_CLOSE"));
        theApp.HandleClose(hwnd);
        break;
        
    case WM_SYSCOMMAND:
        TraceTag((tagHTAWndMsg, "WM_SYSCOMMAND"));

        if (wParam == SC_CLOSE)
            theApp.HandleClose(hwnd);
        else
            return DefWindowProc(hwnd, msg, wParam, lParam);
        break;
        
    case WM_DESTROY:
        TraceTag((tagHTAWndMsg, "WM_DESTROY"));
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        TraceTag((tagHTAWndMsg, "WM_SIZE"));
        theApp.Resize();
        break;

    case WM_ACTIVATE:
        {
            // Activate or Deactivate the document.  This is needed 
            // in order to make focus adornments work correctly on 
            // Win9x and NT4
            //
            TraceTag((tagHTAWndMsg, "WM_ACTIVATE"));
            
            CDoc*   pDoc; 
            HRESULT hr;
            IOleInPlaceActiveObject* pActiveObj;
            
            if (theApp._Client._pUnk)
            {
                hr = THR(theApp._Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
                if (SUCCEEDED(hr))
                {
                    hr = pDoc->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&pActiveObj);
                    if (SUCCEEDED(hr))
                    {
                        pActiveObj->OnFrameWindowActivate((WA_INACTIVE == LOWORD(wParam)) ? FALSE : TRUE);
                        ReleaseInterface(pActiveObj);
                    }
                }
            }
        }
        break;
        
    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        if (msg == WM_QUERYNEWPALETTE)
        {
            TraceTag((tagHTAWndMsg, "WM_QUERYNEWPALETTE"));
        }
        else
        {
            TraceTag((tagHTAWndMsg, "WM_PALETTECHANGED"));
        }
                                
        return theApp._Client.DelegateMessage(msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\frame.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       frame.cxx
//
//  Contents:   Implementation of frame object
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLAppFrame, CHTMLApp, HTMLApp, _Frame)

CHTMLAppFrame::CHTMLAppFrame()
    : _pActiveObj(NULL)
{
}

void CHTMLAppFrame::Passivate()
{
}

void CHTMLAppFrame::Resize()
{
    // Note:  We provide the client area rectangle because:
    //
    //  1.  No frame-level adornments are allowed.
    //  2.  No status bar is implemented.
    //
    //  if either condition changes, we should revist this code so that the
    //  appropriate area is excluded from this rect.
    //
    
    if (_pActiveObj)
    {
        RECT rc;
        HTMLApp()->GetViewRect(&rc);
        _pActiveObj->ResizeBorder( &rc, this, TRUE);
    }
}

HRESULT
CHTMLAppFrame::TranslateKeyMsg(MSG * pMsg)
{
    HRESULT hr = S_FALSE;

    // Only allow keyboard messages to be translated
    if (_pActiveObj && ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST)))
    {
        hr = _pActiveObj->TranslateAccelerator(pMsg);
    }
    
    RRETURN1(hr, S_FALSE);
}

HRESULT CHTMLAppFrame::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IOleInPlaceFrame ||
        riid == IID_IOleWindow ||
        riid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
    }
    else if (riid == IID_IOleInPlaceUIWindow)
    {
        *ppv = (IOleInPlaceUIWindow *) this;
    }

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }
    
    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::GetWindow(HWND * phWnd)
{
    *phWnd = HTMLApp()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::GetBorder(LPOLERECT prcBorder)
{
    HTMLApp()->GetViewRect(prcBorder);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    ReplaceInterface(&_pActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND 
hwndActiveObject)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::RemoveMenus(HMENU hmenuShared)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetStatusText(LPCTSTR szStatusText)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::EnableModeless(BOOL fEnable)
{
    //  TODO: should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\client.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       olesite.cxx
//
//  Contents:   implementation of client object
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_CLIENT_HXX_
#define X_CLIENT_HXX_
#include "client.hxx"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CClient, CHTMLApp, HTMLApp, _Client)

//+---------------------------------------------------------------------------
//
//  Member:     CClient::CClient
//
//  Synopsis:   Initializes data members
//
//----------------------------------------------------------------------------
CClient::CClient()
    : _pUnk(NULL), _pIoo(NULL), _pView(NULL)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::~CClient
//
//  Synopsis:   
//
//----------------------------------------------------------------------------
CClient::~CClient()
{
    Assert(!_pUnk);
    Assert(!_pIoo);
    Assert(!_pView);
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::QueryObjectInterface
//
//  Synopsis:   Query the control for an interface.
//              The purpose of this function is to reduce code size.
//
//  Arguments:  iid     Interface to query for
//              ppv     Returned interface
//
//-------------------------------------------------------------------------

HRESULT
CClient::QueryObjectInterface(REFIID iid, void **ppv)
{
    if (_pUnk)
        return _pUnk->QueryInterface(iid, ppv);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Passivate
//
//  Synopsis:   Called when app is shutting down.
//
//----------------------------------------------------------------------------
void CClient::Passivate()
{
    IOleInPlaceObject *pIP = NULL;

    // InplaceDeactivate the contained object
    QueryObjectInterface(IID_IOleInPlaceObject, (void **)&pIP);
    if (pIP)
    {
        pIP->InPlaceDeactivate();
        ReleaseInterface(pIP);
    }

    // ISSUE:  is this the right flag to send?
    if (_pIoo)
        _pIoo->Close(OLECLOSE_NOSAVE);
        
    ClearInterface(&_pIoo);
    ClearInterface(&_pView);
    ClearInterface(&_pDT);
    ClearInterface(&_pUnk);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Show
//
//  Synopsis:   Causes the docobject to show itself in our client area
//
//----------------------------------------------------------------------------

HRESULT CClient::Show()
{
    HRESULT hr = S_OK;
    
    if (_pIoo)
    {
        RECT rc;
        App()->GetViewRect(&rc);
        hr = _pIoo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, App()->_hwnd, &rc);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Resize
//
//  Synopsis:   Resizes this object (usually as a result of the frame windo
//              changing size).
//
//----------------------------------------------------------------------------

void CClient::Resize()
{
    if (_pView)
    {
        RECT rc;
        App()->GetViewRect(&rc);
        _pView->SetRect(&rc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::Create
//
//  Synopsis:   Creates COM object instance
//
//----------------------------------------------------------------------------

HRESULT CClient::Create(REFCLSID clsid)
{
    HRESULT hr;
        
    hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&_pUnk));
    if (hr)
        goto Cleanup;
        
    hr = QueryObjectInterface(IID_IOleObject, (void **)&_pIoo);

    // Fall through.  Check hr if new code is added here.
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Load
//
//  Synopsis:   In addition to loading, set's the client site.
//
//----------------------------------------------------------------------------

HRESULT CClient::Load(IMoniker *pMk)
{
    HRESULT hr = S_OK;
	IPersistMoniker *pIpm = NULL;

    if (!_pUnk)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // TODO:  move to its own fn (and check OLEMISC for order)??
    if (_pIoo)
        _pIoo->SetClientSite(this);

	QueryObjectInterface(IID_IPersistMoniker, (void **)&pIpm);
	if (pIpm)
	{
		hr = THR(pIpm->Load(TRUE, pMk, NULL, 0));
		ReleaseInterface(pIpm);
	}

    TEST(hr);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::SendCommand
//
//  Synopsis:   Sends an Exec command to the hosted object.
//
//----------------------------------------------------------------------------

HRESULT
CClient::SendCommand(
        const GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT                 hr;
    IOleCommandTarget *     pCmdTarget = NULL;
    
    hr = THR_NOTRACE(QueryObjectInterface(
        IID_IOleCommandTarget,
        (void **)&pCmdTarget));

    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pCmdTarget->Exec(pguidCmdGroup,
            nCmdID,
            nCmdexecopt,
            pvarargIn,
            pvarargOut));

Cleanup:
    ReleaseInterface(pCmdTarget);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::GetService
//
//  Synopsis:   Retrieves a service from the hosted object.
//
//----------------------------------------------------------------------------

HRESULT
CClient::GetService(
        REFGUID guidService,
        REFIID  riid,
        void ** ppObj)
{
    HRESULT                 hr;
    IServiceProvider *      pServiceProvider = NULL;
    
    Assert(ppObj);
    
    hr = THR_NOTRACE(QueryObjectInterface(
        IID_IServiceProvider,
        (void **)&pServiceProvider));

    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pServiceProvider->QueryService(guidService,
            riid,
            ppObj));

Cleanup:
    ReleaseInterface(pServiceProvider);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::DelegateMessage
//
//  Synopsis:   Delegates messages to the contained instance of Trident.
//
//----------------------------------------------------------------------------

LRESULT
CClient::DelegateMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    IOleInPlaceObject * pAO = NULL;
    LRESULT lRes = 0;
    
    if (_pView)
    {
        HRESULT hr;
        HWND hwnd;
        
        hr = _pView->QueryInterface(IID_IOleInPlaceObject, (void **) &pAO);
        if (hr)
            goto Cleanup;

        hr = pAO->GetWindow(&hwnd);
        if (hr)
            goto Cleanup;
            
        Assert(::IsWindow(hwnd));
        lRes = ::SendMessage(hwnd, msg, wParam, lParam);
    }
    
Cleanup:
    ReleaseInterface(pAO);
    return lRes;
}

BOOL
CClient::SelfDragging(void)
{
    BOOL fSelfDrag = FALSE;
    CVariant var;

    SendCommand(&CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &var);

    // if the return variant is VT_I4 and non-zero, it is a self-drag.
    if ((V_VT(&var) == VT_I4) && (V_I4(&var)))
        fSelfDrag = TRUE;

    return fSelfDrag;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::Frame
//
//  Synopsis:   Returns a pointer to the app's frame object
//
//----------------------------------------------------------------------------

CHTMLAppFrame * CClient::Frame()
{
    return &App()->_Frame;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::App
//
//  Synopsis:   Returns a pointer to the application object.
//
//----------------------------------------------------------------------------

CHTMLApp * CClient::App()
{
    return HTMLApp();
}    

LPCTSTR CClient::GetAppName()
{
    return App()->GetAppName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\factory.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.cxx
//
//  Contents:   class factory
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTAClassFactory, CHTMLApp, HTMLApp, _Factory)

EXTERN_C const GUID CLSID_HTMLApplication;

CHTAClassFactory::CHTAClassFactory()
    : _dwRegCookie(0)
{
}

void CHTAClassFactory::Passivate()
{
    // If we registered a class factory, revoke it now.
    if (_dwRegCookie)
    {
        CoRevokeClassObject(_dwRegCookie);
    }
}

HRESULT CHTAClassFactory::Register()
{
    HRESULT hr = THR(CoRegisterClassObject(CLSID_HTMLApplication, this, CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &_dwRegCookie));
    RRETURN(hr);
}

HRESULT CHTAClassFactory::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv = (IClassFactory *)this;

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CHTAClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppv)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CServerObject *pServer = new CServerObject(HTMLApp());
    if (!pServer)
        return E_OUTOFMEMORY;

    return (pServer->QueryInterface(riid, ppv));
}

HRESULT CHTAClassFactory::LockServer(BOOL fLock)
{
    // Keep a combined ref/lock count.  No need to distinguish in the case.
    if (fLock)
    {
        AddRef();
    }
    else
    {
        Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\peerfact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.cxx
//
//  Contents:   class factory
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

BOOL CBehaviorFactory::_fCreated = FALSE;

IMPLEMENT_SUBOBJECT_IUNKNOWN(CBehaviorFactory, CHTMLApp, HTMLApp, _PeerFactory)

CBehaviorFactory::CBehaviorFactory()
{
}

HRESULT CBehaviorFactory::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IElementBehaviorFactory)
        *ppv = (IElementBehaviorFactory *)this;

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// IElementBehaviorFactory methods
HRESULT CBehaviorFactory::FindBehavior(BSTR bstrName, BSTR bstrUrl,
            IElementBehaviorSite * pSite, IElementBehavior ** ppPeer)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    
    // We don't hand out more than a single instance of the application behavior.
    if (_fCreated)
        goto Cleanup;
        
    if (bstrName && (0 == StrCmpICW(bstrName, L"Application")))
    {
        CAppBehavior *pApp = new CAppBehavior;

        if (!pApp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        hr = pApp->QueryInterface(IID_IElementBehavior, (void **)ppPeer);

        // This object should have a refcount of one when this function returns, otherwise
        // it will never get to zero.  CBase contributes an initial refcount of 1, the QI
        // (if successful) increments the refcount to 2.  We need to release one of them now.
        if (SUCCEEDED(hr))
            pApp->Release();

        _fCreated = TRUE;
    }

Cleanup:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\main.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       main.cxx
//
//  Contents:   WinMain and associated functions.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

CHTMLApp theApp;

LPTSTR
GetCmdLine()
{
    #ifdef UNICODE
        LPTSTR pszCmdLine = GetCommandLine();
    #else
        // for multibyte should make it unsigned
        BYTE * pszCmdLine = (BYTE *)GetCommandLine();
    #endif

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    return (LPTSTR) pszCmdLine;
}

STDAPI
RunHTMLApplication(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow)
{
    HRESULT hr = S_OK;
    LPTSTR lpszCmdLine = GetCmdLine();

    hr = theApp.Init(hinst, lpszCmdLine, nCmdShow);
    if (hr)
        goto Cleanup;

    theApp.Run();

Cleanup:
    hr = theApp.Terminate();
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\regkey.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       regkey.cxx
//
//  Contents:   implementation of non-inline CRegKey functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_REGKEY_HXX_
#define X_REGKEY_HXX_
#include "regkey.hxx"
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* 
pdwCount)
{
	_ASSERTE(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR 
lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR 
lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\peers.cxx ===
#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

// ISSUE: TODO: Can we fix this somewhat evil inclusion due to
// CMarkup needing CLayoutContext?
#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "..\..\site\layout\layout.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#define _cxx_
#include "htmlapp.hdl"

MtDefine(HTA, Behaviors, "HTA")
MtDefine(CAppBehavior, HTA, "CAppBehavior")

const CBase::CLASSDESC CAppBehavior::s_classdesc =
{
    &CLSID_HTMLAppBehavior,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAppBehavior,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------
STDMETHODIMP
CBaseBehavior::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IElementBehavior)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Passivate
//
//  Synopsis:   Called when object's refcount goes to zero.
//
//--------------------------------------------------------------------------
void
CBaseBehavior::Passivate()
{
    // Object is going away.  Notify factory that it can now create another.
    // Needed in the case where an HTA is refreshed.

    theApp._PeerFactory.BehaviorDestroyed();    
    super::Passivate();
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Init
//
//  Synopsis:   Per IElementBehavior
//
//--------------------------------------------------------------------------
STDMETHODIMP
CBaseBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        _pSite = pSite;
        _pSite->AddRef();
        hr = S_OK;
    }
    return hr;  
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Notify
//
//  Synopsis:   Per IElementBehavior
//
//--------------------------------------------------------------------------
STDMETHODIMP CBaseBehavior::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    RRETURN(S_OK);
}



//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::CBaseBehavior
//              CBaseBehavior::~CBaseBehavior
//
//  Synopsis:   Constructor/Destructor for app behavior.
//
//--------------------------------------------------------------------------
CAppBehavior::CAppBehavior()
{
    // Load the commandline into the attribute array.
    SetAAcommandLine(theApp.cmdLine()); 
}

CAppBehavior::~CAppBehavior()
{
    if (_pBitsCtx)
    {
        _pBitsCtx->SetProgSink(NULL);
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior2, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior3, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::Init
//
//  Synopsis:   Per IElementBehavior
//
//  Notes:      Initialization function for APPLICATION tag
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = super::Init(pSite);
    IHTMLElement *pElement = NULL;
    CDoc * pDoc;
    const TCHAR * pchUrl;

    if (_pSite)
    {
        hr = _pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());
        
            for(vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
            {
                const VTABLEDESC *pVTblDesc = vTableIterator.Item();
                const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
                Assert(pPropDesc);

                VARIANT attrValue;
                VariantInit(&attrValue);

                if (pPropDesc->pstrName)
                {
                    hr = GetAttrValue(pElement, pPropDesc->pstrName, &attrValue);
                    if (SUCCEEDED(hr))
                    {
                        pPropDesc->HandleLoadFromHTMLString(this, attrValue.bstrVal, 0);
                        VariantClear(&attrValue);
                    }
                }
            }
            ReleaseInterface(pElement);
        }
    }

    pchUrl = GetAAicon();
    if (!pchUrl || !*pchUrl)
        goto Cleanup;

    hr = THR(theApp._Client._pUnk->QueryInterface(
            CLSID_HTMLDocument,
            (void **) &pDoc));
    if (hr)
        goto Cleanup;

    // Notify the app that we are starting an async property download so it
    // can ignore the IDM_PARSECOMPLETE exec command if it comes in before 
    // this download is complete.
    theApp.Wait(TRUE);

    Assert(!_pBitsCtx);

    // Get the bits context
    // NB: (jbeda) It should be okay to pass FALSE for fPendingRoot
    //     here because we switch markup for identity behaviors
    hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, GetAAicon(),
                NULL, (CDwnCtx **) &_pBitsCtx, FALSE));        // TODO (lmollico): should we pass pElement?
    if (hr || !_pBitsCtx)
    {
        theApp.Wait(FALSE);
        goto Cleanup;
    }

    // if bits already got, call the callback
    if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        OnDwnChan();
    else    // register the callback
    {
        // NOTE (lmollico): we shouldn't use _pBitsCtx here
        _pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pDoc->PrimaryMarkup()));
        _pBitsCtx->SetCallback(OnDwnChanCallback, this);
        _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
    }

    return S_OK;
Cleanup:
    theApp.SetAttributes(this);
    return S_OK;
}


void CAppBehavior::OnDwnChan()
{
    HRESULT hr;
    ULONG ulState = _pBitsCtx->GetState();

    if (ulState & DWNLOAD_COMPLETE)
    {
        TCHAR * pchFile;

        hr = _pBitsCtx->GetFile(&pchFile);
        if (hr)
            goto Cleanup;

        SetAAicon(pchFile);     // TODO (lmollico): we should use a private member string instead
        MemFreeString(pchFile);
    }

Cleanup:
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR))
    {
        _pBitsCtx->SetProgSink(NULL);
        theApp.Wait(FALSE);
        theApp.SetAttributes(this);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::InvokeEx
//
//  Synopsis:   Per IDispatchEx
//
//  Notes:      Override of CBase implementation.  Filters out all dispids
//              except those generated by this behavior.
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::InvokeEx(DISPID id, LCID lcid, WORD wFlags,
                      DISPPARAMS *pdp, VARIANT *pvarRes,
                      EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    if (id == DISPID_CAppBehavior_commandLine)
        RRETURN(super::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller));
    else
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//  Notes:      Override of CBase implementation.  Filters out all properties
//              except those generated by this behavior.
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    if (!StrCmpIC(bstrName, TEXT("commandLine")))
        return DISP_E_UNKNOWNNAME;
    else    
        RRETURN(super::GetDispID(bstrName, grfdex, pid));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetStyles
//
//  Synopsis:   Returns window styles reflecting values specified in APPLICATION
//              tag attributes (or default values if not specified).
//
//--------------------------------------------------------------------------
DWORD
CAppBehavior::GetStyles()
{
    DWORD dwStyle = WS_OVERLAPPED | 
                    GetAAcaption() | 
                    GetAAsysMenu() | 
                    GetAAborder() | 
                    GetAAminimizeButton() | 
                    GetAAmaximizeButton();

    if (GetAAcaption() == HTMLCaptionFlagNo || GetAAborder() == HTMLBorderNone)
    {
        // The only way to get a captionless or borderless window is to turn 
        // off the caption and everything that goes along with it.  It must
        // also be a POPUP window, but we morph it later.
        dwStyle &= ~(WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
    }

    return dwStyle;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetExtendedStyles
//
//  Synopsis:   Returns extended window styles reflecting values specified in
//              APPLICATION tag attributes (or default values if not specified).
//
//--------------------------------------------------------------------------
DWORD CAppBehavior::GetExtendedStyles()
{
    DWORD dwStyleEx = GetAAborderStyle();
    return dwStyleEx;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAttrValue
//
//  Synopsis:   Given an element and attribute name, retrieves the current
//              value of that element.
//
//----------------------------------------------------------------------------
STDMETHODIMP
GetAttrValue(IHTMLElement *pElement, const TCHAR * pchAttrName, VARIANT *pVarOut)
{
    VARIANT attrName;
    HRESULT hr = S_OK;

    if (!pElement || !pVarOut)
        return E_POINTER;
        
    V_VT(&attrName) = VT_BSTR;
    V_BSTR(&attrName) = SysAllocString(pchAttrName);
    if ( !V_BSTR(&attrName) )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = pElement->getAttribute(attrName.bstrVal, 0, pVarOut);
    VariantClear(&attrName);

    // If this attribute doesn't exist, clear the variant and return a failure code.
    if (V_VT(pVarOut) == VT_NULL)
    {
        VariantClear(pVarOut);
        hr = E_FAIL;
    }
Cleanup:        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\site.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       client.cxx
//
//  Contents:   implementation of OLE site.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_THEMEHLP_H_
#define X_THEMEHLP_H_
#include "themehlp.hxx"
#endif

#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory

EXTERN_C UINT  DragQueryFileWrapW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);

//+-------------------------------------------------------------------------
//
//  Method:     CClient::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

HRESULT CClient::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IOleClientSite)
        *ppv = (IOleClientSite *)this;
    else if (riid == IID_IOleCommandTarget)
        *ppv = (IOleCommandTarget *) this;
    else if (riid == IID_IOleWindow)
        *ppv = (IOleWindow *) this;
    else if (riid == IID_IOleInPlaceSite)
        *ppv = (IOleInPlaceSite *) this;
    else if (riid == IID_IOleDocumentSite)
        *ppv = (IOleDocumentSite *) this;
    else if (riid == IID_IAdviseSink)
        *ppv = (IAdviseSink *) this;
    else if (riid == IID_IServiceProvider)
        *ppv = (IServiceProvider *) this;
    else if (riid == IID_IInternetSecurityManager)
        *ppv = (IInternetSecurityManager *) this ;
    else if (riid == IID_IDocHostUIHandler)
        *ppv = (IDocHostUIHandler *) this ;
    else if (riid == IID_IDocHostShowUI)
        *ppv = (IDocHostShowUI *) this ;
    else if (riid == IID_IHTMLOMWindowServices)
        *ppv = (IHTMLOMWindowServices *) this;
    else if (riid == IID_IDropTarget)
        *ppv = (IDropTarget *) this;
    
    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


/* IOleClientSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::SaveObject()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR * ppmk)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetContainer(LPOLECONTAINER FAR * ppContainer)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::ShowObject()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}


HRESULT CClient::QueryStatus(const GUID * pguidCmdGroup, ULONG cCmds,
        MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext)
{
    if (pguidCmdGroup != NULL)
        return (OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch (pCmd->cmdID)
        {
        case OLECMDID_ALLOWUILESSSAVEAS:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
        }
    }

    RRETURN(hr);
}

HRESULT CClient::Exec(const GUID * pguidCmdGroup, DWORD nCmdID,
        DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT hr = S_OK;

    if ( ! pguidCmdGroup )
    {
        switch (nCmdID)
        {
        case OLECMDID_SETTITLE:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                App()->SetTitle(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        case OLECMDID_CLOSE:
            App()->Close();
            break;
            
        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_MSHTML,*pguidCmdGroup ))
    {
        switch (nCmdID)
        {
            case IDM_PARSECOMPLETE:

                // Document is fully parsed. Show the application window.
                //
                if (!theApp.isLoaded() && !theApp.isBusy())
                {
                    theApp.FinalInit();
                }
                
                break;
                
            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

    RRETURN(hr);
}


/* IOleWindow methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

HRESULT CClient::GetWindow(HWND FAR *lpHwnd)
{
    HRESULT hr = S_OK;
    
    if (!lpHwnd)
        return E_POINTER;
    
    *lpHwnd = App()->_hwnd;
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

HRESULT CClient::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/* IOleInPlaceSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::CanInPlaceActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnInPlaceActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnUIActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetWindowContext(
                    LPOLEINPLACEFRAME FAR* lplpFrame,
                    LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                    LPOLERECT lprcPosRect,
                    LPOLERECT lprcClipRect,
                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    HRESULT hr = S_OK;

    CHTMLAppFrame *pFrame = Frame();
    Assert(pFrame);
    
    *lplpFrame = (LPOLEINPLACEFRAME)pFrame;
    *lplpDoc = (LPOLEINPLACEUIWINDOW)pFrame;

    App()->GetViewRect(lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    // Nothing much interesting in this struct.  We don't have any
    // menus or accelerators.
    Assert(lpFrameInfo->cb >= sizeof(OLEINPLACEFRAMEINFO));
    lpFrameInfo->fMDIApp = FALSE ;
    lpFrameInfo->hwndFrame = App()->_hwnd ;
    lpFrameInfo->haccel = 0 ;
    lpFrameInfo->cAccelEntries = 0 ;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::Scroll(OLESIZE scrollExtent)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnInPlaceDeactivate()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::DiscardUndoState()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::DeactivateAndUndo()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnPosRectChange(LPCOLERECT lprcPosRect)
{
    return E_NOTIMPL;
}

                    
/* IOleDocumentSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::ActivateMe
//
//  Synopsis:   Per IOleDocumentSite
//
//--------------------------------------------------------------------------

HRESULT CClient::ActivateMe(IOleDocumentView * pViewToActivate)
{
    HRESULT hr = S_OK;
    
    // TODO: if pViewToActivate is null, call CreateView.
    ReleaseInterface(_pView);

    _pView = pViewToActivate;
    if (_pView)
    {
        // We're going to hold on to this, so AddRef it.
        _pView->AddRef();

        hr = _pView->SetInPlaceSite(this);
        TEST(hr);
        
        hr = _pView->UIActivate(TRUE);
        TEST(hr);
        
        hr = _pView->Show(TRUE);
        TEST(hr);
    }
    
Cleanup:

    RRETURN(hr);
}


/* IAdviseSink methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnDataChange
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnDataChange(FORMATETC * pFormatetc, STGMEDIUM * pmedium)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnViewChange
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnViewChange(DWORD dwAspect, long lindex)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnRename
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnRename(LPMONIKER pmk)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnSave
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnSave()
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnClose
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnClose()
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::QueryService
//
//  Synopsis:   Per IServiceProvider
//
//--------------------------------------------------------------------------

HRESULT CClient::QueryService(REFGUID guidService, REFIID riid, void ** ppv)
{
    HRESULT hr = E_FAIL;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;
    
    if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
    {
        *ppv = &App()->_PeerFactory;
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(guidService, IID_IInternetSecurityManager) ||
             IsEqualGUID(guidService, IID_IHTMLOMWindowServices))
    {
        hr = QueryInterface(riid, ppv);
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::SetSecuritySite
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::GetSecuritySite
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::MapURLToZone
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::MapUrlToZone(LPCWSTR pwszUrl, DWORD* pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CClient::ProcessURLAction
//
//  Synopsis:   Per IInternetSecurityManager.  Return URLPOLICY_ALLOW for
//              most actions if this comes from a trusted source.  Security is 
//              disabled in this context.
//
//-------------------------------------------------------------------------

HRESULT
CClient::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy,
                          BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    DWORD dwPolicy = URLPOLICY_ALLOW;
    DWORD *pdw = (DWORD *)pPolicy;
    HRESULT hr = S_OK;
    
    // If this is not coming from a trusted source, do default.
    if (!(dwFlags & PUAF_TRUSTED))
    {
        return INET_E_DEFAULT_ACTION;
    }
    
    // Policies are DWORD values, so we need at least 4 bytes.
    if (cbPolicy < sizeof(DWORD))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    switch(dwAction)
    {
        case URLACTION_CREDENTIALS_USE:
        case URLACTION_AUTHENTICATE_CLIENT:
        case URLACTION_JAVA_PERMISSIONS:
        case URLACTION_CHANNEL_SOFTDIST_PERMISSIONS:
            {
                IInternetSecurityManager *pism = NULL;
                hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IInternetSecurityManager, (void**)&pism);
                if (SUCCEEDED(hr) && pism)
                {
                    hr = pism->ProcessUrlAction(pwszUrl,
                                                dwAction,
                                                pPolicy,
                                                cbPolicy,
                                                pContext,
                                                cbContext,
                                                dwFlags,
                                                dwReserved);
                    pism->Release();
                    return hr;
                }
            }
            break;
    }

    if (dwPolicy != URLPOLICY_ALLOW)
        hr = S_FALSE;
        
    // we know pPolicy points to a buffer that can contain a DWORD. I'd really like to use:
    // *((DWORD *)pPolicy) = dwPolicy;   but that is illegal in C++.  Can't cast the left
    // side of an assignment.

    *pdw = dwPolicy;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::GetSecurityID
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetSecurityId(LPCWSTR pwszUrl, BYTE __RPC_FAR *pbSecurityId,
                       DWORD __RPC_FAR *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::SetZoneMapping
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::SetZoneMapping  (DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::QueryCustomPolicy
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::QueryCustomPolicy (LPCWSTR pwszUrl, REFGUID guidKey, BYTE** ppPolicy,
                            DWORD* pcbPolicy, BYTE* pContext, DWORD cbContext,
                            DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}
                        
//+------------------------------------------------------------------------
//
//  Member:     CClient::GetZoneMappings
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetZoneMappings (DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT
CClient::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    HRESULT hr = S_OK;

    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pInfo->dwFlags = theApp.GetHostInfoFlags();
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    pInfo->pchHostCss = (OLECHAR *)CoTaskMemAlloc(sizeof(SZ_APPLICATION_BEHAVIORCSS)+1);
    if ( !pInfo->pchHostCss )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pInfo->pchHostNS = (OLECHAR *)CoTaskMemAlloc(sizeof(SZ_APPLICATION_BEHAVIORNAMESPACE)+1);
    if ( !pInfo->pchHostNS )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    StrCpyW(pInfo->pchHostCss, SZ_APPLICATION_BEHAVIORCSS);
    StrCpyW(pInfo->pchHostNS, SZ_APPLICATION_BEHAVIORNAMESPACE);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::ShowContextMenu
//
//  Synopsis:   Called by Trident when its about to show its context menu.
//
//  Returns:    S_OK to disable context menu
//              S_FALSE to allow Trident to show its context menu
//
//-------------------------------------------------------------------------
HRESULT
CClient::ShowContextMenu(DWORD dwID, POINT * pptPosition,
                         IUnknown * pcmdtReserved,
                         IDispatch * pDispatchObjectHit)
{
    if (!theApp.contextMenu())
       return S_OK;

    return S_FALSE;
}

HRESULT
CClient::GetExternal(IDispatch ** ppDisp)
{
    if (!ppDisp)
        return E_POINTER;

    *ppDisp = NULL;
    return S_OK;
}

HRESULT
CClient::ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
            DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT *plResult)
{
    TCHAR szBuf[512];
    int iReturn = GetWindowText(App()->_hwnd, szBuf, ARRAY_SIZE(szBuf));

    // GetWindowText will return zero if there is no window text, or upon failure.  Rather
    // than have a blank title for this message box, default to "HTML Application".
    
    ULONG_PTR dwfTheme = 0;
    
    if (IsAppThemed())    
    {           
        SHActivateContext(&dwfTheme);
    }    

    if (iReturn)
        iReturn = MessageBox(hwnd, lpstrText, szBuf, dwType);
    else
        iReturn = MessageBox(hwnd, lpstrText, _T("HTML Application"), dwType);

    if (dwfTheme != 0)
        SHDeactivateContext(dwfTheme);

    if (plResult)
        *plResult = iReturn;
        
    return (iReturn ? S_OK : S_FALSE);
}


//==================================================================
//  method implementatiosn for IHTMLOMWindowServices
//
//  this interface is used by the hta to implement the window sevices
//  that COmWindow delagates to. e.g .moveTo, resizeby
//
//==================================================================


//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::moveTo(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;
    
    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_moveTo(x,y);
        goto Cleanup;
    }

    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested position
    rect.bottom = rect.bottom-rect.top + y;
    rect.right  = rect.right-rect.left + x;
    rect.top = y;
    rect.left = x;

    // now we've the go-ahead to actually set the position
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::moveBy(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_moveBy(x,y);
        goto Cleanup;
    }

    // If the window has been created, but we can't get the rect, something
    // is badly wrong.  Fail this call.
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested position
    rect.bottom += y;
    rect.right  += x;
    rect.top += y;
    rect.left += x;

    // do we actually need to even move?
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::resizeTo(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_resizeTo(x,y);
        goto Cleanup;
    }

    // get the current window rect
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested Size 
    rect.bottom = rect.top + y;
    rect.right  = rect.left + x;

    // set our new size
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::resizeBy(long x, long y)
{
    HRESULT hr;
    RECT    rect;
    HWND    hwnd = App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_resizeBy(x,y);
        goto Cleanup;
    }


    // If the window has been created, but we can't get the rect, something
    // is badly wrong.  Fail this call.
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested Size 
    rect.bottom += y;
    rect.right  += x;

    // set our new size
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

HRESULT
CClient::DragEnter(
            LPDATAOBJECT pDataObj,
            DWORD grfKeyState,
            POINTL pt,
            LPDWORD pdwEffect)
{
    Assert(_pDT && pDataObj && pdwEffect);
    
    _pDT->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    
    if (*pdwEffect == DROPEFFECT_NONE && DropAllowed(pt))    
    {
        *pdwEffect = DROPEFFECT_LINK;
    }
    
    return S_OK;
}

HRESULT
CClient::DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    Assert(_pDT && pdwEffect);
    
    _pDT->DragOver(grfKeyState, pt, pdwEffect);
    
    if (*pdwEffect == DROPEFFECT_NONE && DropAllowed(pt))    
    {
        *pdwEffect = DROPEFFECT_LINK;
    }
    
    return S_OK;
}

HRESULT
CClient::DragLeave(void)
{
    return _pDT->DragLeave();
}


HRESULT
CClient::Drop(LPDATAOBJECT pDataObj,
            DWORD grfKeyState,
            POINTL pt,
            LPDWORD pdwEffect)
{
    Assert(pDataObj && pdwEffect);

    HRESULT hr = S_OK;

    IEnumFORMATETC *pFormatEtc = NULL;
    IHTMLWindow2   *pOMWindow2 = NULL;
    
    if (DropAllowed(pt))
    {
        hr = pDataObj->EnumFormatEtc(DATADIR_GET, &pFormatEtc);

        if (OK(hr))
        {
            ULONG cEltFetched = 0;
            FORMATETC fmtetcEnum;
            while(SUCCEEDED(pFormatEtc->Next(1, &fmtetcEnum, &cEltFetched)) && (cEltFetched > 0))
            {
                if (fmtetcEnum.cfFormat == CF_HDROP || fmtetcEnum.cfFormat == g_rgFETC[iUniformResourceLocator].cfFormat)
                {
                    STGMEDIUM stgmed;

                    hr = THR(pDataObj->GetData(&fmtetcEnum, &stgmed));
                    if(OK(hr))
                    {
                        HDROP hdrop = (HDROP)GlobalLock(stgmed.hGlobal);

                        if (NULL != hdrop)
                        {
                            TCHAR szUrl[_MAX_PATH + 1];
                            ZeroMemory(szUrl, ARRAY_SIZE(szUrl));

                            if (fmtetcEnum.cfFormat == CF_HDROP)
                            {
                                // Only take the first filename (in case of multi-select files)
#if !defined(_AMD64_) && !defined(_IA64_)
                                DragQueryFile(hdrop, 0, (LPTSTR) szUrl, ARRAY_SIZE(szUrl));
#else
                                DragQueryFileWrapW(hdrop, 0, szUrl, ARRAY_SIZE(szUrl));
#endif
                                // if this is an internet shortcut (*.url), need to retrieve the URL
                                if (!StrCmpI(PathFindExtension(szUrl), _T(".URL")))
                                {
                                    IPersistFile *ppf = NULL;
                                    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, 
                                        CLSCTX_ALL, IID_IPersistFile, (void **) &ppf)))
                                    {
                                        if (SUCCEEDED(ppf->Load(szUrl, STGM_READ)))
                                        {
                                            IUniformResourceLocatorW *pUrl;
                                            LPTSTR pszUrl = NULL;
                                            if (SUCCEEDED(ppf->QueryInterface(IID_IUniformResourceLocator,
                                                (void **) &pUrl)))
                                            {
                                                hr = pUrl->GetURL(&pszUrl);
                                                StrCpyN(szUrl, pszUrl, ARRAY_SIZE(szUrl));
                                                CoTaskMemFree(pszUrl);
                                                ReleaseInterface(pUrl);
                                            }
                                        }
                                        ReleaseInterface(ppf);
                                    }
                                }
                            }
                            else
                            {
                                // hdrop points to an ANSI string.  Need to convert to UNICODE.
                                MultiByteToWideChar(CP_ACP, 0, (LPCSTR)hdrop, _MAX_PATH, szUrl, _MAX_PATH);
                            }

                            GlobalUnlock(hdrop);

                            // Trident will never get a DragLeave call since we navigate away here.
                            _pDT->DragLeave();
                            
                            // And away we go...
                            hr = WindowObjectFromPoint(pt, &pOMWindow2);

                            if (OK(hr) && pOMWindow2)
                                hr = pOMWindow2->navigate(szUrl);
                        }
                        ReleaseStgMedium(&stgmed);
                    }
                    goto Cleanup;
                }
            }
        }
    }
    
    // Give trident a chance to handle the drop
    if (_pDT)
        hr = THR(_pDT->Drop(pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pFormatEtc);
    ReleaseInterface(pOMWindow2);
    RRETURN(hr);
}


BOOL CClient::DropAllowed(POINTL pt)
{
    IHTMLElement *pOMElement = NULL;   // Not used here, but required by ElementIsFrame().
    BOOL fRet = FALSE;
    
    // Always allow drops onto frame/iframe elements.  Otherwise, allow only if top-level 
    // navigation is permitted and this isn't a self-drag.
    if (ElementIsFrame(pt, &pOMElement) || 
            (!SelfDragging() && App()->GetHostInfoFlags() & DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION))
    {
        fRet = TRUE;
    }

    ReleaseInterface(pOMElement);
    return fRet;
}


BOOL
CClient::ElementIsFrame(POINTL pt, IHTMLElement **ppOMElement)
{
    IHTMLDocument2 *pOMDocument = NULL;
    IHTMLElement   *pOMElement = NULL;
    IHTMLElement   *pFrameBase2 = NULL;
    BOOL    fRet = FALSE;
    HRESULT hr;
    CPoint cpt(pt.x, pt.y);
    
    Assert(ppOMElement);
    
    hr = THR(GetService(SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&pOMDocument));
    if (hr)
        goto Cleanup;

    // Need to convert to client coordinate system
    ScreenToClient(App()->_hwnd, &cpt);
    
    hr = THR(pOMDocument->elementFromPoint(cpt.x, cpt.y, &pOMElement));
    if (hr)
        goto Cleanup;

    // If this element implements IHTMLFrameBase2, it is either a frame or iframe.
    if (pOMElement && SUCCEEDED(pOMElement->QueryInterface(IID_IHTMLFrameBase2, (void **)&pFrameBase2)))
    {
        ReplaceInterface(ppOMElement, pOMElement);
        fRet = TRUE;
    }

Cleanup:
    ReleaseInterface(pOMDocument);
    ReleaseInterface(pOMElement);
    ReleaseInterface(pFrameBase2);
    return fRet;
}


HRESULT
CClient::WindowObjectFromPoint(POINTL pt, IHTMLWindow2 **ppOMWindow2)
{
    IHTMLDocument2  *pOMDocument = NULL;
    IHTMLElement    *pOMElement = NULL;
    IHTMLFrameBase2 *pFrameBase2 = NULL;
    HRESULT hr = E_FAIL;
    
    Assert(ppOMWindow2);
    
    if (ElementIsFrame(pt, &pOMElement))
    {
        Assert(pOMElement);
        // dropped either a frame or iframe.  Get that window object.
        if (SUCCEEDED(pOMElement->QueryInterface(IID_IHTMLFrameBase2, (void **)&pFrameBase2)))
            hr = THR(pFrameBase2->get_contentWindow(ppOMWindow2));
    }
    else
    {
        hr = THR(GetService(SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&pOMDocument));
        Assert(pOMDocument);

        if (SUCCEEDED(hr) && pOMDocument)
        {
            // dropped on top-level content.  Get that window object.
            hr = THR(pOMDocument->get_parentWindow(ppOMWindow2));
        }
    }

    ReleaseInterface(pOMDocument);
    ReleaseInterface(pOMElement);
    ReleaseInterface(pFrameBase2);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\dlgframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsite.cxx
//
//  Contents:   Implementation of the frame for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//  Notes:      This frame does not supply a real frame window if
//              it is acting as a property page.  If it's acting as 
//              a dialog, then it does.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

DeclareTag(tagHTMLDlgFrameMethods, "HTML Dialog Frame", "Methods on the html dialog frame")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLDlgFrame, CHTMLDlg, HTMLDlg, _Frame);


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::GetWindow(HWND * phWnd)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleWindow::GetWindow"));
    
    *phWnd = HTMLDlg()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::GetBorder(LPOLERECT prcBorder)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::GetBorder"));

#ifndef WIN16    
    HTMLDlg()->GetViewRect(prcBorder);
#else
    RECTL rcBorder;
    HTMLDlg()->GetViewRect(&rcBorder);
    CopyRect(prcBorder, &rcBorder);
#endif
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::RequestBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::SetBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::SetActiveObject"));
    
    ReplaceInterface(&HTMLDlg()->_pInPlaceActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::InsertMenus"));
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::SetMenu"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::RemoveMenus(HMENU hmenuShared)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::RemoveMenus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetStatusText(LPCTSTR szStatusText)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::SetStatusText"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::EnableModeless(BOOL fEnable)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::EnableModeless"));
    
    //  TODO: (anandra) should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::TranslateAccelerator"));
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\dlgsink.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsink.cxx
//
//  Contents:   Implementation of the dlg sinks + extender
//
//  History:    06-25-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif


DeclareTag(tagHTMLDlgExtenderMethods, "HTML Dialog Xtender", "Methods on the html dialog Xtender")

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::CHTMLDlgExtender
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CHTMLDlgExtender::CHTMLDlgExtender(
    CHTMLDlg *      pDlg, 
    IHTMLElement *  pHTMLElement, 
    DISPID          dispid)
{
    HRESULT         hr = S_OK;
    CVariant        var;

    TraceTag((tagHTMLDlgExtenderMethods, "constructor"));

    _pDlg = pDlg;
    _pHTMLElement = pHTMLElement;
    _pHTMLElement->AddRef();
    _dispid = dispid;
    _ulRefs = 1;

    if (S_OK == hr)
        hr = THR_NOTRACE(GetDispProp(
                                    _pHTMLElement, 
                                    DISPID_A_VALUE, 
                                    g_lcidUserDefault, 
                                    &var, 
                                    NULL));

    _ExchangeValueBy = (S_OK == hr) ? EXCHANGEVALUEBY_VALUE : EXCHANGEVALUEBY_INNERTEXT;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::~CHTMLDlgExtender
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CHTMLDlgExtender::~CHTMLDlgExtender()
{
    TraceTag((tagHTMLDlgExtenderMethods, "destructor"));

    _pHTMLElement->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::Value_PropPageToObject
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::Value_PropPageToObject ()
{
    HRESULT     hr = S_OK;
    CVariant    var;
    CExcepInfo  ei;

    switch (_ExchangeValueBy)
    {

    case EXCHANGEVALUEBY_VALUE:

        hr = THR(::GetDispProp(
                _pHTMLElement,
                DISPID_A_VALUE,
                g_lcidUserDefault,
                &var,
                &ei));
        if (hr)
        {
            hr = THR(::GetDispProp(
                    _pHTMLElement,
                    DISPID_VALUE,
                    g_lcidUserDefault,
                    &var,
                    &ei));
            if (hr)
                goto Cleanup;
        }

        break;

    case EXCHANGEVALUEBY_INNERTEXT:

        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(_pDlg->_pEngine->SetProperty(_dispid, &var));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::Value_ObjectToPropPage
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::Value_ObjectToPropPage ()
{
    HRESULT                 hr;
    CVariant                varValue;
    CVariant                varText;
    CExcepInfo              ei;
    IHTMLControlElement *   pControlElement = NULL;

    Assert (_pDlg && _pDlg->_pEngine);

    hr = THR(_pDlg->_pEngine->GetProperty(_dispid, &varValue));
    if (hr)
        goto Cleanup;

    switch (_ExchangeValueBy)
    {

    case EXCHANGEVALUEBY_VALUE:

        hr = THR(::SetDispProp(
                _pHTMLElement,
                DISPID_A_VALUE,
                g_lcidUserDefault,
                &varValue,
                &ei));
        if (hr)
        {
            hr = THR(::SetDispProp(
                _pHTMLElement,
                DISPID_VALUE,
                g_lcidUserDefault,
                &varValue,
                &ei));
            if (hr)
                goto Cleanup;
        }

        break;

    case EXCHANGEVALUEBY_INNERTEXT:

        hr = THR(VariantChangeTypeEx(&varText, &varValue, g_lcidUserDefault, 0, VT_BSTR));
        if (hr)
            goto Cleanup;

        hr = THR(_pHTMLElement->put_innerText(V_BSTR(&varText)));
        if (hr)
            goto Cleanup;

        break;

    default:
        Assert (0);
        break;
    }

Cleanup:
    ReleaseInterface (pControlElement);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::OnChanged
//
//  Synopsis:   per IPropertyNotifySink.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::OnChanged(DISPID dispid)
{
    TraceTag((tagHTMLDlgExtenderMethods, "IPropertyNotifySink::OnChanged dispid:%d", dispid));

    //
    // Just look for the value property changing.  If this does
    // occur, then we have a dirty page.  Additionally, look to see
    // if this is occuring when the page is first being initialized.
    // Skip this prop change if so.
    //

    if ((DISPID_VALUE == dispid || DISPID_A_VALUE == dispid) && !_pDlg->_fInitializing)
    {
        _pDlg->OnPropertyChange(this);
    }
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::OnRequestEdit
//
//  Synopsis:   per IPropertyNotifySink.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::OnRequestEdit(DISPID dispid)
{
    TraceTag((tagHTMLDlgExtenderMethods, "IPropertyNotifySink::OnRequestEdit dispid:%d", dispid));
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDlgDocPNS::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CDlgDocPNS, CHTMLDlg, _PNS)

STDMETHODIMP
CDlgDocPNS::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDlgDocPNS::OnChanged
//
//  Synopsis:   
//
//----------------------------------------------------------------------------

STDMETHODIMP CDlgDocPNS::OnChanged(DISPID dispid)
{

    RRETURN(_pDlg->OnPropertyChange(dispid, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmlapp\server.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       server.cxx
//
//  Contents:   implementation of server object
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

CServerObject::CServerObject(CHTMLApp *pApp)
    : _pApp(pApp), _ulRefs(0)
{
}

HRESULT CServerObject::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IPersistMoniker)
    {
        *ppv = (IPersistMoniker *)this;
    }
    else if (riid == IID_IOleObject)
    {
        *ppv = (IOleObject *)this;
    }

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CServerObject::GetClassID(CLSID *pClsid)
{
    return CLSIDFromString(SZ_SERVER_CLSID, pClsid);
}

HRESULT CServerObject::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CServerObject::Load(BOOL fFullyAvailable, IMoniker * pmk, LPBC pbc, DWORD grfMode)
{
    HRESULT hr = THR(_pApp->RunHTMLApplication(pmk));
    RRETURN(hr);
}

HRESULT CServerObject::Save(IMoniker * pmk, LPBC pbc, BOOL fRemember)
{
    return E_NOTIMPL;
}

HRESULT CServerObject::SaveCompleted(IMoniker * pmk, LPBC pbc)
{
    return E_NOTIMPL;
}

HRESULT CServerObject::GetCurMoniker(IMoniker ** ppmk)
{
    return E_NOTIMPL;
}


// IOleObject methods

HRESULT CServerObject::SetClientSite(IOleClientSite *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetClientSite(IOleClientSite **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetHostNames(LPCOLESTR, LPCOLESTR)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Close(DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetMoniker(DWORD , IMoniker *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetMoniker(DWORD, DWORD, IMoniker **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::InitFromData(IDataObject *, BOOL, DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetClipboardData(DWORD, IDataObject **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::DoVerb(LONG, LPMSG, IOleClientSite *, LONG, HWND, LPCOLERECT)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::EnumVerbs(IEnumOLEVERB **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Update()
{
    return E_NOTIMPL;
}


HRESULT CServerObject::IsUpToDate()
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetUserClassID(CLSID *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetUserType(DWORD, LPOLESTR *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetExtent(DWORD, SIZEL *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetExtent(DWORD, SIZEL *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Advise(IAdviseSink *, DWORD *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Unadvise(DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::EnumAdvise(IEnumSTATDATA **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetMiscStatus(DWORD, DWORD *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetColorScheme(LOGPALETTE  *pLogpal)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\dlgmodel.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgmodel.cxx
//
//  Contents:   Implementation of the object model for html based dialogs
//
//  History:    08-22-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::close
//
//  Synopsis:   close the dialog
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::close()
{
    PostMessage(_hwnd, WM_CLOSE, 0, 0);
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::hide
//
//  Synopsis:   Allows a trusted dialog to be hidden.  This is currently used
//  by print preview after we print and before we are done spooling.  we return
//  control to the parent window.
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::onDialogHide()
{
    HRESULT     hr = S_OK;

    // since 'no' is the default it is safe to just set/reset it
    if (!_fTrusted)
    {
        if (_enumfHide==HTMLDlgFlagYes)
        {
            _enumfHide = HTMLDlgFlagNo;  
            hr = S_OK;
        }
        else
        {
            hr = CTL_E_METHODNOTAPPLICABLE;
        }
        goto Cleanup;
    }

    // modeless windows will close on their own or when the parent document
    // navigates away (or closes).  
    //
    // ISSUE: we may want to remove our _hwnd from the parent document's _aryActiveModelessWindow... 
    // if we can figure out how to access it.
    //
    // modal, are not going to be modal after this call and are going to 
    // have to close themselves, since we have no means by which to add
    // _hwnd to the parentDoc's _aryActiveModelessWindow.

    if (!_fIsModeless)
    {
        // if hide is Yes, enable parent window (TRUE), else disable parent (FALSE)
        ::EnableWindow(_hwndTopParent, (_enumfHide==HTMLDlgFlagYes));
    }

        // don't deavitive or transition, just hide.
    hr = THR(Show( (_enumfHide==HTMLDlgFlagYes) ? SW_HIDE : SW_SHOW));

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_dialogArguments
//
//  Synopsis:   Get the argument
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_dialogArguments(VARIANT * pvar)
{
    HRESULT hr = E_FAIL;

    if(!pvar)
        goto Cleanup;
     
    hr = VariantClear(pvar);
    if(hr)
        goto Cleanup;

    if(AccessAllowed())
        hr = VariantCopy(pvar, &_varArgIn);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_menuArguments
//
//  Synopsis:   Get the argument (same as dialogArguments, but
//              renamed for neatness)
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_menuArguments(VARIANT * pvar)
{
    HRESULT hr = E_FAIL;

    if(!pvar)
        goto Cleanup;
     
    hr = VariantClear(pvar);
    if(hr)
        goto Cleanup;

    if(AccessAllowed())
        hr = VariantCopy(pvar, &_varArgIn);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_returnValue
//
//  Synopsis:   Get the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_returnValue(VARIANT * pvar)
{
    RRETURN(SetErrorInfo(VariantCopy(pvar, &_varRetVal)));
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::put_returnValue
//
//  Synopsis:   Set the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::put_returnValue(VARIANT var)
{
    RRETURN(SetErrorInfo(VariantCopy(&_varRetVal, &var)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\htmldlg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       htmldlg.cxx
//
//  Contents:   Implementation of the dlg xobject for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>
#endif

#ifndef X_MULTIMON_H_
#define X_MULTIMON_H_
#include "multimon.h"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "resprot.hxx"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifdef UNIX
#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include <mshtmlrc.h>
#endif

#include <mainwin.h>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#define WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#include "unixmodeless.hxx"
#endif

// TODO: (anandra) Try to get rid of all this stuff below.

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"    // for MAKEUNITVALUE macro.
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"     // for propdesc components
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"    // for CSSParser
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for FRAMEOPTIONS_FOO
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"    // For firing print template events
#endif

#define MAX_NUM_ZONES_ICONS         12

HICON g_arhiconZones[MAX_NUM_ZONES_ICONS] = {0};

#define DIALOG_MIN_WIDTH    100     // in pixel
#define DIALOG_MIN_HEIGHT   100     // in pixel

// 220 is the width used in browser, we should in ssync with it
#define DIALOG_ZONE_WIDTH   220     // in pixel
#define DIALOG_STATUS_MIN   50      // in pixel

// True if we run on unicode operating system
extern BOOL g_fUnicodePlatform;


// Needs this for the IElementCollection interface
#ifndef X_COLLECT_H_
#define X_COLLECT_H_
#include <collect.h>
#endif

#define _cxx_
#include "htmldlg.hdl"

// this is defined in winuser.h for WINVER >= 0x0500
// We need this to compile
#if(WINVER < 0x0500)
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WINVER >= 0x0500 */

DeclareTag(tagHTMLDlgMethods, "HTML Dialog", "Methods on the html dialog")
DeclareTag(tagHTMLDlgHack, "HTML Dialog Hack", "Look for dlg in file system")
MtDefine(Dialogs, Mem, "Dialogs")
MtDefine(CHTMLDlg, Dialogs, "CHTMLDlg")
MtDefine(CHTMLDlg_aryDispObjs_pv, CHTMLDlg, "CHTMLDlg::_aryDispObjs::_pv")
MtDefine(CHTMLDLG_aryXObjs_pv, CHTMLDlg, "CHTMLDlg::_aryXObjs::_pv")
MtDefine(CHTMLPropPageCF, Dialogs, "CHTMLPropPageCF")
MtDefine(CHTMLDlgExtender, Dialogs, "CHTMLDlgExtender")
MtDefine(CHTMLDlgFrame, Dialogs, "CHTMLDlgFrame")

HRESULT CreateResourceMoniker(HINSTANCE hInst, TCHAR *pchRID, IMoniker **ppmk);
CODEPAGE CodePageFromString (TCHAR * pch, BOOL fLookForWordCharset);

HRESULT InternalModelessDialog(HTMLDLGINFO * pdlgInfo );

#ifdef _MAC
#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI BOOL WINAPI AfxTerminateThread(HANDLE hThread, DWORD dwExitCode);
#ifdef __cplusplus
}
#endif
#endif // _MAC


const CBase::CLASSDESC CHTMLDlg::s_classdesc =
{
    &CLSID_HTMLDialog,              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDialog,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::CHTMLPropPageCF
//
//  Synopsis:   ctor of class factory
//
//-------------------------------------------------------------------------

CHTMLPropPageCF::CHTMLPropPageCF(IMoniker *pmk) : CDynamicCF()
{
    Assert(pmk);
    _pmk = pmk;
    _pmk->AddRef();   
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::~CHTMLPropPageCF
//
//  Synopsis:   dtor of class factory
//
//-------------------------------------------------------------------------

CHTMLPropPageCF::~CHTMLPropPageCF()
{
    if (_pmk)
        _pmk->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::CreateInstance
//
//  Synopsis:   per IClassFactory
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPropPageCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT                 hr;
    HTMLDLGINFO             dlginfo;    

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    Assert(_pmk);
   
    dlginfo.pmk             = _pmk;
    dlginfo.fPropPage       = TRUE;

    hr = THR(CHTMLDlg::CreateHTMLDlgIndirect(pUnkOuter, &dlginfo, riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHTMLDlgIndirect
//
//  Synopsis:   static ctor
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::CreateHTMLDlgIndirect(
    IUnknown *pUnkOuter,
    HTMLDLGINFO *pdlginfo,
    REFIID riid,
    void **ppv)
{
    HRESULT     hr;
    CHTMLDlg *  pDlg = new CHTMLDlg(pUnkOuter, TRUE, NULL);

    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDlg->Create(pdlginfo));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pDlg->PrivateQueryInterface(riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pDlg)
    {
        pDlg->PrivateRelease();
    }
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CHTMLDlg::CHTMLDlg(IUnknown *pUnkOuter, BOOL fTrusted, IUnknown *pUnkHost)
         : CBase(), _aryDispObjs(Mt(CHTMLDlg_aryDispObjs_pv)), _aryXObjs(Mt(CHTMLDLG_aryXObjs_pv))
{
    TraceTag((tagHTMLDlgMethods, "constructing CHTMLDlg"));

    if (pUnkHost)
    {
        pUnkHost->QueryInterface(IID_IServiceProvider, (void **)&_pHostServiceProvider);
    }

    _aryXObjs.SetSize(0);

    // nonpropdesc member defaults. should match the pdl file
    _lDefaultFontSize = 16;
    _enumfScroll     = HTMLDlgFlagYes;
    _enumEdge        = HTMLDlgEdgeRaised;
    _enumfStatus     = HTMLDlgFlagNotSet;
    _enumfResizeable = HTMLDlgFlagNo;
    _enumfUnadorned  = HTMLDlgFlagNo;
    _enumfHide       = HTMLDlgFlagNo;
    
    _fTrusted    = fTrusted;
}


//+------------------------------------------------------------------------
//
//  Member:     ~CHTMLDlg
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CHTMLDlg::~CHTMLDlg( )
{
    TraceTag((tagHTMLDlgMethods, "destroying CHTMLDlg"));

    Assert(_aryDispObjs.Size() == 0);
    Assert(_aryXObjs.Size() == 0);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Create
//
//  Synopsis:   Creation function the primary task here is to process the
//          dialog info structure in order to initialize the propdesc and
//          other member variables.  If we got here from formsSetmodalDialog
//          then the propdesc has already been set and most of the info-struct
//          is empty.
//
//  Arguments:  pdlginfo    Struct containing creation info
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::Create(HTMLDLGINFO * pdlginfo )
{
    HRESULT              hr;
    IBindCtx *           pBCtx = NULL;
    IPersistMoniker *    pPMk = NULL;
    IStream *            pStm = NULL;
    TCHAR *              pchUrl = NULL;
    TCHAR *              pchOptions;

    // Retrieve the options string.
    pchOptions = (pdlginfo->pvarOptions && VT_BSTR == V_VT(pdlginfo->pvarOptions)) ?
        V_BSTR(pdlginfo->pvarOptions) : NULL;

    if (!pdlginfo->pmk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else
    {
       
        _pOriginalMoniker = pdlginfo->pmk;
        _pOriginalMoniker->AddRef();
    }

    // create the doc
    hr = THR(CoCreateInstance(CLSID_HTMLDocument,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUnknown,
                              (void **) &_pUnkObj));

    if (hr)
        goto Cleanup;

    // Set various bits on the doc: trust, printing, "in dialog" etc.
    // This must be called before setting the client site!
    hr = THR(SetFlagsOnDoc(pdlginfo));
    if (hr)
        goto Cleanup;

    // process and store incoming options
    _fPropPageMode  = pdlginfo->fPropPage;
    _fIsModeless    = pdlginfo->fModeless;
    _fVerifyRect    = (!_fTrusted) || (pdlginfo->dwFlags & HTMLDLG_VERIFY);

    hr = THR(DefaultMembers());
    if (hr)
        goto Cleanup;

    // parse the options string
    if (pchOptions && *pchOptions )
    {
        // we need an attr array to parse into.  The parser has changed.
        if (!_pAA)
        {
            _pAA = new CAttrArray;
            if ( !_pAA )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        CCSSParser ps(
            NULL,
            &_pAA,
            FALSE,
            FALSE, // there's no markup which we could access
            eSingleStyle,
            BaseDesc() ? BaseDesc()->_apHdlDesc : &CStyle::s_apHdlDescs,
            this);

        ps.Open();
        ps.Write( pchOptions, lstrlen( pchOptions ) );
        ps.Close();
    }

    _dwFrameOptions = (_enumfScroll ? FRAMEOPTIONS_SCROLL_AUTO :
                                      FRAMEOPTIONS_SCROLL_NO) |
                       (_enumEdge);

    // Set the Window Style flag:
    _dwWS = GetAAborder() | WS_SYSMENU |
            (_enumfMin  ? WS_MINIMIZEBOX    : 0) |
            (_enumfMax  ? WS_MAXIMIZEBOX    : 0);

    _dwWSEx = WS_EX_DLGMODALFRAME | 
              ((!!_enumfHelp) ? WS_EX_CONTEXTHELP : 0);

    hr = THR(_pUnkObj->QueryInterface(IID_IOleObject, (void **) &_pOleObj));
    if (hr)
        goto Cleanup;

    hr = THR(_pOleObj->SetClientSite(&_Site));
    if (hr)
        goto Cleanup;

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
    if (hr)
        goto Cleanup;

    if (pdlginfo->pMarkup)
    {
        CStr    cstrBindCtxUrl;

        cstrBindCtxUrl.Set((TCHAR *) CMarkup::GetUrl(pdlginfo->pMarkup));

        hr = THR( AddBindContextParam(pBCtx, &cstrBindCtxUrl));
        if (hr)
            goto Cleanup;
    }

    //
    // In proppage mode, just go sync because the design of IPropertyPage
    // and IPropertyPageSite are not suited for aync operation.
    //

    if (_fPropPageMode)
    {
        //
        // Special case res: and just extract stream right here.  Urlmon
        // returns a failure if you do a synchronous
        // bind to something which does not return a file.  (anandra)
        //
        hr = THR(pdlginfo->pmk->GetDisplayName(pBCtx, NULL, &pchUrl));
        if (hr)
            goto Cleanup;

        if (!StrCmpNIC(_T("res:"), pchUrl, 4))
        {
            CStr    cstrResName;
            CStr    cstrResType;
            CStr    cstrRID;
            hr = THR(CResProtocol::DoParseAndBind(
                    pchUrl,
                    cstrResName,
                    cstrResType,
                    cstrRID,
                    &pStm,
                    NULL));
        }
        else
        {
            hr = THR(pdlginfo->pmk->BindToStorage(
                    pBCtx,
                    NULL,
                    IID_IStream,
                    (void **)&pStm));
        }
        if (hr)
            goto Cleanup;

        hr = THR(LoadDocSynchronous(pStm, pchUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // asynchronous moniker binding
        hr = THR(_pUnkObj->QueryInterface(IID_IPersistMoniker, (void **)&pPMk));
        if (hr)
            goto Cleanup;

        hr = THR(pPMk->Load(TRUE, pdlginfo->pmk, pBCtx, STGM_READ));
        if (hr)
            goto Cleanup;
    }

    //Connect a Property Notify sink to the document so that we can catch property changes
    // which we might be interested in
    hr = THR(ConnectSink(
            _pOleObj,
            IID_IPropertyNotifySink,
            &_PNS,
            &_PNS._dwCookie));
    if (hr)
        goto Cleanup;


    // if our caller wants an initialization callback,
    // let 'em have it....
    if (   pdlginfo->dwFlags & HTMLDLG_INIT_WITH_CALLBACK
        && pdlginfo->pfnInit != NULL)
    {
        (*(pdlginfo->pfnInit))(this, pdlginfo->_cvarInitData);
    }

    _PNS._pDlg = this;

Cleanup:
    if (pchUrl)
        CoTaskMemFree(pchUrl);

    ReleaseInterface(pBCtx);
    ReleaseInterface(pPMk);
    ReleaseInterface(pStm);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Passivate
//
//  Synopsis:   1st stage destruction
//
//-------------------------------------------------------------------------

void
CHTMLDlg::Passivate()
{        
    if (_fPropPageMode)  
        OnClose();        
    
    if ( IsPrintingDialog() )
        FirePrintTemplateEvent(IDM_FIRE_PRINTTEMPLATEDOWN);

    //Release _pUnkObj before the VariantClear to work around OLE fault
    //Bug #69805
    ClearInterface(&_pUnkObj);
    VariantClear(&_varArgIn);

    ClearInterface(&_pOleObj);
    ClearInterface(&_pInPlaceObj);
    ClearInterface(&_pInPlaceActiveObj);
    ClearInterface(&_pPageSite);
    ClearInterface(&_pHostServiceProvider);
    ClearInterface(&_pOriginalMoniker);

    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetViewRect
//
//  Synopsis:   Get the rectangular extent of the window.
//
//-------------------------------------------------------------------------

void
CHTMLDlg::GetViewRect(RECT *prc)
{
    *prc = _rcView;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnClose
//
//  Synopsis:   Handle the WM_CLOSE message
//
//-------------------------------------------------------------------------

LRESULT
CHTMLDlg::OnClose()
{
    TraceTag((tagHTMLDlgMethods, "OnClose"));

    HRESULT hr = THR(Deactivate());
    
    if (S_FALSE == hr)
    {
        return 0;
    }

    if (_hwndTopParent)
    {
        //
        // Re-enable the top level parent window upon
        // destruction.
        //

        ::EnableWindow(_hwndTopParent, TRUE);
    }

    Terminate();

    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnDestroy
//
//  Synopsis:   Handle the WM_DESTROY message
//
//-------------------------------------------------------------------------

LRESULT
CHTMLDlg::OnDestroy()
{
    TraceTag((tagHTMLDlgMethods, "OnDestroy"));

    _hwnd = NULL;

    return 0;
}


LRESULT
CHTMLDlg::OnActivate(WORD wFlags)
{
    TraceTag((tagHTMLDlgMethods, "OnActivate"));

    if (_pInPlaceActiveObj)
    {
        IGNORE_HR(_pInPlaceActiveObj->OnFrameWindowActivate(wFlags != WA_INACTIVE));
    }
    return 0;
}


LRESULT
CHTMLDlg::OnWindowPosChanged(RECT *prc)
{
    TraceTag((tagHTMLDlgMethods, "OnWindowPosChanged"));

    SIZEL       sizel;
    RECT        rcStatus;
    CUnitValue  cuvParam;
    CDoc* pDoc = NULL ;

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    sizel.cx = HimetricFromHPix(prc->right - prc->left);
    sizel.cy = HimetricFromHPix(prc->bottom - prc->top);

    Assert( _pUnkObj && _pOleObj );
    
    if ( S_OK == _pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc) && 
         pDoc && ! pDoc->IsShut() &&
         _pOleObj )
    {
        IGNORE_HR(_pOleObj->SetExtent(DVASPECT_CONTENT, &sizel));
    }   
    
    if (_pInPlaceObj)
    {
        IGNORE_HR(_pInPlaceObj->SetObjectRects(ENSUREOLERECT(prc), ENSUREOLERECT(prc)));
    }

    _rcView = *prc;

    if (_hwndStatus)
        MoveStatusWindow();

    // and don't forget the dialogTop, left, width and height properties.
    //---------------------------------------------------------------------
    GetWindowRect(_hwnd, &rcStatus);
    cuvParam.SetValue (rcStatus.top, CUnitValue::UNIT_PIXELS);
    SetAAdialogTop(cuvParam);

    cuvParam.SetValue ( rcStatus.left, CUnitValue::UNIT_PIXELS);
    SetAAdialogLeft(cuvParam);

    cuvParam.SetValue ( rcStatus.right-rcStatus.left, CUnitValue::UNIT_PIXELS);
    SetAAdialogWidth(cuvParam);

    cuvParam.SetValue ( rcStatus.bottom-rcStatus.top, CUnitValue::UNIT_PIXELS);
    SetAAdialogHeight(cuvParam);

    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetDoc
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDoc(IHTMLDocument2 ** ppDoc)
{
    Assert (ppDoc);

    RRETURN (THR(_pUnkObj->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc)));
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::InitValues
//
//  Synopsis:   Given the objects populate the dialog with values
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::InitValues()
{
    IHTMLElementCollection *    pElements = NULL;
    IEnumVARIANT *              pEnumVar = NULL;
    IUnknown *              pUnk = NULL;
    IHTMLElement *              pHTMLElement = NULL;
    BSTR                        bstrID = NULL;
    HRESULT                     hr = S_OK;
    VARIANT                     var;
    IHTMLDocument2 *            pDoc = NULL;

    VariantInit(&var);

    //
    // First get a list of all elements thru an enumerator
    //

    hr = THR(GetDoc (&pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->get_all(&pElements));
    if (hr)
        goto Cleanup;

    // avoid casts of the type -> (BaseClass **)&DerivedClass. -
    //hr = THR(pElements->get__newEnum((IUnknown **)&pEnumVar));
    hr = THR(pElements->get__newEnum(&pUnk));
    if (hr)
        goto Cleanup;

    pEnumVar = (IEnumVARIANT *)pUnk;
    //
    // Iterate thru elements, looking for ID attributes that start
    // with _*.  The * signifies which attribute name to
    // load in it.  E.g. _Align will load the Align attribute
    // into the field.
    //

    while (S_OK == (hr = pEnumVar->Next(1, &var, NULL)))
    {
        Assert(V_VT(&var) == VT_DISPATCH);

        hr = THR_NOTRACE(V_DISPATCH(&var)->QueryInterface(
                IID_IHTMLElement,
                (void **)&pHTMLElement));
        if (hr)
            goto LoopCleanup;

        // get id
        hr = THR(pHTMLElement->get_id(&bstrID));

        // if id begins with '_'
        if (S_OK == hr && bstrID && _T('_') == bstrID[0])
        {
            hr = THR(ConnectElement(pHTMLElement, bstrID + 1));
            if (hr)
                goto LoopCleanup;
        }

LoopCleanup:
        FormsFreeString(bstrID);
        bstrID = NULL;
        ClearInterface(&pHTMLElement);
        VariantClear(&var);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pElements);
    ReleaseInterface(pEnumVar);
    ReleaseInterface(pDoc);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetValue
//
//  Synopsis:   Set the value of some control element.
//
//  Arguments:  pCtrl       The control element to set
//              bstrID      ID to look for
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::ConnectElement(IHTMLElement * pHTMLElement, BSTR bstrID)
{
    HRESULT             hr = S_OK;
    DISPID              dispid;
    CHTMLDlgExtender *  pExtender = NULL;

    //
    // The underlying assumption here is that given an attribute,
    // the dispid of this attribute is the same across all objects
    // for this dialog.
    //

    //
    // find out dispid of the property
    //

    hr = THR(_aryDispObjs[0]->GetIDsOfNames(
            IID_NULL,
            &bstrID,
            1,
            _lcid,
            &dispid));
    if (hr)
        goto Cleanup;

    //
    // create, hookup and update extender
    //

    pExtender = new CHTMLDlgExtender(this, pHTMLElement, dispid);
    if (!pExtender)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pExtender->Value_ObjectToPropPage());
    if (hr)
        goto Error;

    hr = THR(::ConnectSink(
            pHTMLElement,
            IID_IPropertyNotifySink,
            pExtender,
            &pExtender->_dwCookie));
    if (hr)
        goto Error;

    hr = THR(_aryXObjs.Append(pExtender));
    if (hr)
        goto Error;

Cleanup:

    RRETURN(hr);

Error:
    delete pExtender;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::UpdateValues
//
//  Synopsis:   Update dialog with values based on the commit engine
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::UpdateValues()
{
    HRESULT             hr = S_OK;
    long                c;
    CHTMLDlgExtender ** ppExtender;

    if (!_fPropPageMode)
        goto Cleanup;

    for (c = _aryXObjs.Size(), ppExtender = _aryXObjs; c > 0; c--, ppExtender++)
    {
        hr = THR((*ppExtender)->Value_ObjectToPropPage());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetDirty
//
//  Synopsis:   Set the dirty property and if necessary call on the pagesite.
//
//  Arguments:  dw      As per IPropertyPageSite::OnStatusChange
//
//-------------------------------------------------------------------------

void
CHTMLDlg::SetDirty(DWORD dw)
{
    _fDirty = (dw & PROPPAGESTATUS_DIRTY) != 0;
    if (_pPageSite)
    {
        _pPageSite->OnStatusChange(dw | PROPPAGESTATUS_DIRTY);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnPropertyChange
//
//  Synopsis:   Receive an on property change for some dispid
//              and propagate value down to commit engine.
//
//  Arguments:  pExtend      Extender info on the control
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::OnPropertyChange(CHTMLDlgExtender *pExtender)
{
    HRESULT     hr = S_OK;

    hr = THR(pExtender->Value_PropPageToObject());
    if (hr)
        goto Cleanup;

    SetDirty(PROPPAGESTATUS_DIRTY);

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetDocumentTitle
//
//  Synopsis:   Retrieve the document's title in a bstr
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDocumentTitle(BSTR *pbstr)
{
    HRESULT             hr;
    IHTMLDocument2 *    pDoc = NULL;

    hr = THR(GetDoc (&pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->get_title(pbstr));

Cleanup:
    ReleaseInterface (pDoc);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS2(this, IPropertyPage, IPropertyPage2)
        QI_INHERITS(this, IPropertyPage2)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_HTML_TEAROFF(this, IHTMLDialog2, NULL)

        default:
            //
            // Check for the primary dispatch interface first
            //

            if (iid == IID_IHTMLDialog)
            {
                hr = THR(CreateTearOffThunk(this, (void *)s_apfnpdIHTMLDialog, NULL, ppv, (void *)(CHTMLDlg::s_ppropdescsInVtblOrderIHTMLDialog)));
                if (hr)
                    goto Cleanup;
            }
            else if (iid == CLSID_HTMLDialog)
            {
                *ppv = this;
                goto Cleanup;
            }
            break;
    }

    if (!*ppv)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetPageSite
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetPageSite(IPropertyPageSite *pPageSite)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::SetPageSite"));
    IServiceProvider *  pSP = NULL;
    IDispatch *         pDisp = NULL;

    HRESULT hr = S_OK;

    if (_pPageSite && pPageSite)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    ReplaceInterface(&_pPageSite, pPageSite);

    if (!pPageSite)
    {
        if (_pOleObj)
        {
            hr = THR(_pOleObj->Close(OLECLOSE_NOSAVE));
            if (hr)
                goto Cleanup;
        }
        ClearInterface(&_pOleObj);
    }
    else
    {
        hr = THR(_pPageSite->GetLocaleID(&_lcid));
        if (hr)
            goto Cleanup;

        // query the IPageSite for the SID_SHTMLProperyPageArg service,        
        if (_pPageSite->QueryInterface(IID_IServiceProvider,
            (void **)&pSP))               
            goto Cleanup;
                    
        if (pSP->QueryService(SID_SHTMLProperyPageArg,        
            IID_IDispatch, (void **)&pDisp))       
            goto Cleanup;
        else
        {
        
            hr = VariantClear(&_varArgIn);
            if (hr)
                goto Cleanup;

            V_VT(&_varArgIn) = VT_DISPATCH;
            V_DISPATCH(&_varArgIn) = pDisp;
            pDisp->AddRef();
            }
     }

Cleanup:              
     ReleaseInterface(pDisp);     
     ReleaseInterface(pSP);    
     RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Activate
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Activate(HWND hwndParent, LPCRECT prc, BOOL fModal)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Activate"));

    HRESULT     hr = S_OK;
    HDC         hdc;
    TEXTMETRIC  tmMetrics;
    TCHAR     * pszBuf;
    DWORD       dwStyle = 0;

    if (!prc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    _fInitializing = TRUE;
    _fActive = TRUE;

    //
    // Create a frame window if we're not in the property page mode.
    // I.e. This is a standard html dialog.
    //

    if (!_fPropPageMode)
    {
        HWND    hwndTemp;

        if (!GetWndClassAtom(WNDCLASS_DIALOG))
        {
            HICON hIconSm;

            // NOTE (lmollico): icons are in mshtml.dll

            hIconSm = (HICON)LoadImage( g_hInstCore,                    
                                        MAKEINTRESOURCE(RES_ICO_HTML),
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        LR_SHARED );

            hr = THR(RegisterWindowClass(
                    WNDCLASS_DIALOG,
                    HTMLDlgWndProc,
                    CS_DBLCLKS,
                    NULL,
                    NULL,
                    hIconSm));
            if (hr)
                goto Cleanup;
        }

        pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_DIALOG);

        // Every dialog gets these window styles:
        dwStyle = WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_POPUP;
        
        // if not trusted, or adornment is desired, add these styles:
        if (!_fTrusted || !_enumfUnadorned)
        {
            dwStyle |= ((!!_enumfResizeable) ? (WS_OVERLAPPED|WS_THICKFRAME) : 0) |
                        WS_CAPTION | _dwWS;
        }

        // Turn off extra window styles for unadorned dialogs.
        if (_fTrusted && _enumfUnadorned)
            _dwWSEx = 0;
            
        // If the following two lines change, update it for the HTA's
        // as well (..\htmlapp\app.cxx - CHTMLApp::CreateAppWindow)
        if (g_fMirroredBidiLayout)
            _dwWSEx |= WS_EX_LAYOUTRTL;

        _hwnd = CreateWindowEx(
#ifndef UNIX
                _dwWSEx,
#else
                _dwWSEx | WS_EX_TOPMOST | (fModal ? WS_EX_MWMODAL_POPUP : 0),
#endif
                pszBuf,
                _T(""),
                dwStyle,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                hwndParent,
                NULL,
                g_hInstCore,
                this);

        if (!_hwnd)
        {
            hr = GetLastWin32Error();
            goto Cleanup;
        }

        // Use the Status flag to determine whether to put this in or not.
        // trusted defaults to off, untrusted defaults to on
        if ((!_fTrusted && !!_enumfStatus) ||
            (_fTrusted && _enumfStatus==HTMLDlgFlagYes))
        {
            // Create the status window.
            _hwndStatus = CreateWindowEx(
                    0,                       // no extended styles
                    STATUSCLASSNAME,         // name of status window class
                    (LPCTSTR) NULL,          // no text when first created
                    WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS ,   // creates a child window
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    _hwnd,                   // handle to parent window
                    (HMENU) 0,               // child window identifier
                    g_hInstCore,             // handle to application instance
                    NULL);                   // no window creation data
            if (!_hwndStatus)
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }

            DividePartsInStatusWindow();
            // we will set URL and Zone info latre, when actual navigation happens (in OnReadyStateChange)
            // this will allow to account for possible redirections.
        }

        //
        // Compute top-level parent and disable this window
        // because we want to function as a modal dialog
        //

        // we are looking for first window in parent chain which is not
        // child

        hwndTemp = _hwndTopParent = hwndParent;
        while (::GetWindowLong(hwndTemp, GWL_STYLE) & WS_CHILD)
        {
            hwndTemp = GetParent(hwndTemp);
            if (!hwndTemp)
                break;
            _hwndTopParent = hwndTemp;
        }

        if (fModal)
            EnableWindow(_hwndTopParent, FALSE);

        GetClientRect(_hwnd, &_rcView);
    }
    else
    {
        Assert(V_VT(&_varArgIn) == VT_DISPATCH && V_DISPATCH(&_varArgIn));

        //
        // Ensure that we have a commit holder and engine
        //

        hr = THR(EnsureCommitHolder((DWORD_PTR)hwndParent, &_pHolder));
        if (hr)
            goto Cleanup;

        hr = THR(_pHolder->GetEngine(_aryDispObjs.Size(), _aryDispObjs, &_pEngine));
        if (hr)
            goto Cleanup;

        //
        // Initialize the array of binding information
        //

        hr = THR(InitValues());
        if (hr)
            goto Cleanup;

        _hwnd = hwndParent;
        _rcView = *prc;
    }

    _fInitializing = FALSE;

    Assert(_hwnd);

    hdc = GetDC(_hwnd);
    if (hdc)
    {
        if (GetTextMetrics(hdc, &tmMetrics))
            _lDefaultFontSize = tmMetrics.tmHeight;
        ReleaseDC(_hwnd, hdc);
    }

    //
    // Only do a show if in proppage mode or if we've already gone interactive
    //

    if (_fPropPageMode || _fInteractive)
    {
        Show((_enumfHide==HTMLDlgFlagNo) ? SW_SHOW : SW_HIDE);
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Deactivate
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Deactivate()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Deactivate"));

    HRESULT             hr = S_OK;
    long                i;
    CHTMLDlgExtender ** ppExtend;
    CVariant            varBool;
    IOleCommandTarget * pCommandTarget = NULL;

    if (!_pInPlaceObj)
        goto Cleanup;

    // give events a chance to fire.
    hr = THR_NOTRACE(_pInPlaceObj->QueryInterface(
                        IID_IOleCommandTarget,
                        (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    hr = pCommandTarget->Exec(
            (GUID *)&CGID_MSHTML,
            OLECMDID_ONUNLOAD,
            MSOCMDEXECOPT_DONTPROMPTUSER,
            NULL,
            &varBool);

    if ((V_VT(&varBool) == VT_BOOL && !V_BOOL(&varBool)))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (_pInPlaceActiveObj)
    {
        hr = THR(_pInPlaceObj->UIDeactivate());
        if (hr)
            goto Cleanup;
        ClearInterface(&_pInPlaceActiveObj);
    }

    if (_pInPlaceObj)
    {
        hr = THR(_pInPlaceObj->InPlaceDeactivate());
        if (hr)
            goto Cleanup;
        ClearInterface(&_pInPlaceObj);
    }
    // disconnect the Prop Notify Sink
    if (_PNS._dwCookie && _pOleObj)
    {
        DisconnectSink(_pOleObj, IID_IPropertyNotifySink, &_PNS._dwCookie);
        Assert(_PNS._dwCookie == 0);
    }

    if (_pOleObj)
    {
        hr = THR(_pOleObj->Close(OLECLOSE_NOSAVE));
        if (hr)
            goto Cleanup;
        ClearInterface(&_pOleObj);
    }

    _aryDispObjs.ReleaseAll();

    for (i = _aryXObjs.Size(), ppExtend = _aryXObjs; i > 0; i--, ppExtend++)
    {
        DisconnectSink(
            (*ppExtend)->_pHTMLElement,
            IID_IPropertyNotifySink,
            &((*ppExtend)->_dwCookie));
    }
    _aryXObjs.ReleaseAll();

    if (_pHolder)
    {
        _pHolder->Release();
        _pHolder = NULL;
    }
    _pEngine = NULL;

Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN1(hr,S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetPageInfo
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetPageInfo(PROPPAGEINFO *ppageinfo)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::GetPageInfo"));

    HRESULT     hr;
    BSTR        bstrTitle = NULL;
    long        cb;

    Assert(ppageinfo->cb == sizeof(PROPPAGEINFO));

    hr = THR(GetDocumentTitle(&bstrTitle));
    if (hr)
        goto Cleanup;

    // Convert this bstr into a tchar *
    cb = FormsStringByteLen(bstrTitle);
    if (!cb)
    {
        ppageinfo->pszTitle = NULL;
    }
    else
    {
        ppageinfo->pszTitle = (TCHAR *)CoTaskMemAlloc(cb + sizeof(TCHAR));
        if (!ppageinfo->pszTitle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memcpy(ppageinfo->pszTitle, bstrTitle, cb);
        ppageinfo->pszTitle[cb / sizeof(TCHAR)] = 0;
    }

    ppageinfo->size.cx = GetWidth();
    ppageinfo->size.cy = GetHeight();
    ppageinfo->pszDocString = NULL;
    ppageinfo->pszHelpFile = NULL;
    ppageinfo->dwHelpContext = 0;

Cleanup:
    FormsFreeString(bstrTitle);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetObjects
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetObjects(ULONG cUnk, IUnknown **ppUnks)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::SetObjects"));

    long                    i;
    IUnknown **             ppUnk;
    IDispatch *             pDisp;
    IServiceProvider *      pSP = NULL;
    IDispatch *             pService = NULL;
    BOOL                    fHaveServiceProvider;
    HRESULT                 hr = S_OK;

    Assert((_aryDispObjs.Size() == 0 && cUnk) ||
           (_aryDispObjs.Size() > 0 && !cUnk));

    //
    // First release any existing objects.
    //

    _aryDispObjs.ReleaseAll();
    
    //
    // Check if the page site provided the SID_SHTMLProperyPageArg service
    //
    fHaveServiceProvider = (V_VT(&_varArgIn) == VT_DISPATCH && V_DISPATCH(&_varArgIn));            

    //
    // Cache a ptr to the object's dispatch
    //

    hr = THR(_aryDispObjs.EnsureSize(cUnk));
    if (hr)
        goto Cleanup;

    for (i = cUnk, ppUnk = ppUnks; i > 0; i--, ppUnk++)
    {
        hr = THR((*ppUnk)->QueryInterface(IID_IDispatch, (void **)&pDisp));
        if (hr)
            goto Error;

        hr = THR(_aryDispObjs.Append(pDisp));
        if (hr)
        {
            ReleaseInterface(pDisp);
            goto Error;
        }

        // cache the first service provider that provides us
        // with the SID_SHTMLProperyPageArg service                                               
        if (!fHaveServiceProvider &&                
            !(*ppUnk)->QueryInterface(IID_IServiceProvider, (void**)&pSP) &&
            !pSP->QueryService(SID_SHTMLProperyPageArg, IID_IDispatch, (void **)&pService))                
        {
            fHaveServiceProvider = TRUE;
            VariantClear(&_varArgIn);
            V_VT(&_varArgIn) = VT_DISPATCH;
            V_DISPATCH(&_varArgIn) = pService;
            V_DISPATCH(&_varArgIn)->AddRef();
        }
        ClearInterface(&pService);
        ClearInterface(&pSP);       
    }

Cleanup:
    RRETURN(hr);

Error:
    _aryDispObjs.ReleaseAll();
    goto Cleanup;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Show
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Show(UINT nCmdShow)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Show"));

    HRESULT hr = S_OK;

    _fInitializing = TRUE;

    if (!_fPropPageMode)
    {
        if(!_fKeepHidden)
        {
            ::ShowWindow(_hwnd, nCmdShow);
        }
    }

    if (SW_SHOW == nCmdShow || SW_SHOWNORMAL == nCmdShow || SW_SHOWNA == nCmdShow)
    {
        if (!_fInteractive)
        {
            //
            // Cause a SetExtent to occur on the object.  No need to do this
            // if already interactive because SetExtent has already happened
            // in that case.
            //

            OnWindowPosChanged(&_rcView);
        }

        hr = THR(_pOleObj->DoVerb(
                OLEIVERB_UIACTIVATE,
                NULL,
                &_Site,
                0,
                _hwnd,
                ENSUREOLERECT(&_rcView)));
        if (hr)
            goto Cleanup;

        // The dialog is often a sibling of the app that raised it, but it usually
        // wants to be visible over it, so bring it to the top. (Bug #102125)
        Assert( _hwnd );
        if (!_fKeepHidden)
            ::BringWindowToTop( _hwnd );

        hr = THR(UpdateValues());
        if (hr)
            goto Cleanup;

    }
    else
    {
        Assert(SW_HIDE == nCmdShow);

        hr = THR(_pOleObj->DoVerb(
                OLEIVERB_HIDE,
                NULL,
                &_Site,
                0,
                _hwnd,
                ENSUREOLERECT(&_rcView)));
        if (hr)
            goto Cleanup;
    }

    // We're not done initializing unless we're done with the layout
    if (nCmdShow != SW_HIDE)
    {
        hr = THR(EnsureLayout());
        if (hr)
            goto Cleanup;
    }

    _fInitializing = FALSE;

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Move
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Move(LPCRECT prc)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Move"));

    Assert(_fPropPageMode);

    OnWindowPosChanged((RECT *)prc);

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::IsPageDirty
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::IsPageDirty()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::IsPageDirty"));

    RRETURN (S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Apply
//
//  Synopsis:   per IPropertyPage, a no-op in browse mode
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Apply()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Apply"));
     
    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Help
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Help(LPCOLESTR bstrHelpDir)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Help"));

    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::TranslateAccelerator
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::TranslateAccelerator(LPMSG lpmsg)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::TranslateAccelerator"));

    HRESULT         hr = S_FALSE;

    if (!_pInPlaceObj)
        goto Cleanup;

    if (_pInPlaceActiveObj)
    {
        hr = THR(_pInPlaceActiveObj->TranslateAccelerator(lpmsg));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::EditProperty
//
//  Synopsis:   per IPropertyPage2
//
//---------------------------------------------------------------------------
//lookatme
HRESULT
CHTMLDlg::EditProperty(DISPID dispid)
{
    HRESULT hr = S_OK;
#ifdef NEVER
    IControls *     pCtrls;
    IEnumControl *  pEnum = NULL;
    IControl *      pCtrl;
    CPPXObject *    pPPXO;
    DISPID          dispidCtrl;
    VARIANT         var;

    if (dispid == DISPID_UNKNOWN)
        return E_FAIL;

    hr = THR(_pForm->GetControls(&pCtrls));
    if (hr)
        goto Cleanup;

    hr = THR(pCtrls->Enum(&pEnum));
    if (hr)
        goto Cleanup;

    while (!(hr = pEnum->Next(1, &pCtrl, NULL)))
    {
        hr = THR(pCtrl->QueryInterface(g_iidPPXObject, (void **) &pPPXO));
        if (hr)
            continue;

        pPPXO->GetControlSource(&dispidCtrl);
        pPPXO->Release();
        if (dispidCtrl == dispid)
        {
            V_VT(&var) = VT_BOOL;
            V_BOOL(&var) = -1;
            hr = THR(pCtrl->SetFocus(var));
            pCtrl->Release();
            goto Cleanup;
        }

        pCtrl->Release();
    }

    hr = E_FAIL;

  Cleanup:
    ReleaseInterface(pCtrls);
    ReleaseInterface(pEnum);

    RRETURN(hr);
#endif
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlg::Invoke(
        DISPID dispidMember,
        REFIID,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    RRETURN(InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlg::GetIDsOfNames(REFIID,
                     LPOLESTR *  rgszNames,
                     UINT,
                     LCID,
                     DISPID *    rgdispid)
{
    RRETURN(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::GetDispID, IDispatchEx
//
//  Synopsis:   First try GetIDsOfNames, then try expando version.
//
//--------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(THR_NOTRACE(super::GetInternalDispID(bstrName,
                                              pid,
                                              grfdex,
                                              NULL,
                                              NULL)));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetNextDispID
//
//  Synopsis:   per IDispatchEx, use the window's properties (as usable ing GINEx
//              and ::invoke) when that returns S_FALS then use CBase's for std
//              dialog and expando
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetNextDispID(DWORD grfdex,
                        DISPID id,
                        DISPID *prgid)
{
    HRESULT     hr;

    // if the id is in the range of the htmldlg properties get the dialog's properties
    // ISSUE (carled) expandos do not work properly, and this has to be by-design.
    if ((id >= STDPROPID_XOBJ_LEFT  && id <= STDPROPID_XOBJ_HEIGHT) ||
        (id >= DISPID_HTMLDLG && id < DISPID_HTMLDLGMODEL) ||
        id == DISPID_STARTENUM)
    {
        hr = THR(super::GetNextDispID(grfdex, id, prgid));

        if (hr == S_FALSE)
        {
            // we've exhausted the dialog's properties
            id = DISPID_STARTENUM;
        }
        else
            goto Cleanup;
    }

    *prgid = DISPID_UNKNOWN;
    hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CHTMLDlg::InvokeEx(DISPID dispidMember,
                   LCID lcid,
                   WORD wFlags,
                   DISPPARAMS * pdispparams,
                   VARIANT * pvarResult,
                   EXCEPINFO * pexcepinfo,
                   IServiceProvider *pSrvProvider)
{

    TraceTag((tagHTMLDlgMethods, "IDispatch::Invoke"));

    RRETURN(THR_NOTRACE(super::InvokeEx(dispidMember,
                                     lcid,
                                     wFlags,
                                     pdispparams,
                                     pvarResult,
                                     pexcepinfo,
                                     pSrvProvider)));
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::HTMLDlgWndProc
//
//  Synopsis:   Window procedure
//
//---------------------------------------------------------------------------
LRESULT CALLBACK
CHTMLDlg::HTMLDlgWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CHTMLDlg * pDlg = (CHTMLDlg *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (!pDlg && wm != WM_NCCREATE && wm != WM_CREATE)
        goto Cleanup;

    switch (wm)
    {
    case WM_ERASEBKGND:
        if(pDlg->_pUnkObj)
            return TRUE;
        break;

#ifndef WINCE
    case WM_NCCREATE:
#else
    case WM_CREATE:
#endif // !WINCE
        pDlg = (CHTMLDlg *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDlg);

        pDlg->_hwnd = hwnd;
        pDlg->AddRef();
#ifndef WINCE
        break;

    case WM_CREATE:
        HMENU   hMenu;

        hMenu = GetSystemMenu(hwnd, FALSE);
        if (hMenu)
        {
            if (!pDlg->_enumfMin)
                RemoveMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfMax)
                RemoveMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfResizeable)
                RemoveMenu(hMenu, SC_SIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfMin && !pDlg->_enumfMax)
                RemoveMenu(hMenu, SC_RESTORE, MF_BYCOMMAND);
        }
#endif // !WINCE
        break;

#ifndef WINCE
    case WM_NCDESTROY:
#else
    case WM_DESTROY:
#endif // !WINCE
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        pDlg->_hwnd = NULL;
        pDlg->Release();
#ifndef WINCE
        break;

    case WM_DESTROY:
#endif // !WINCE
        return pDlg->OnDestroy();
        break;

    case WM_CLOSE:
        return pDlg->OnClose();
        break;

    case WM_WINDOWPOSCHANGED:
        if (   !IsIconic(hwnd) 
            && !(SWP_NOSIZE & ((WINDOWPOS *) lParam)->flags ))
        {
            RECT    rc;

            GetClientRect(hwnd, &rc);
            pDlg->OnWindowPosChanged(&rc);

        }
        return 0;

    case WM_ACTIVATE:
        return pDlg->OnActivate(LOWORD(wParam));

    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
        {
            HWND hwndDoc;

            if (pDlg->_pInPlaceObj)
            {
                pDlg->_pInPlaceObj->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
        }
        break;
    }

Cleanup:
    return DefWindowProc(hwnd, wm, wParam, lParam);
}



//+-------------------------------------------------------------------------
//
//  member:CHTMLDlg::Terminate () - 
//
//  Synopsis: for Modeless dialogs this needs to shut down the thread and 
//      for modal it just needs to destroy the window.
//
//--------------------------------------------------------------------------

HRESULT
CHTMLDlg::Terminate ()
{     
    if (!_fIsModeless)
    {
        if (_fPropPageMode)
            _hwnd = NULL;
        else
        {
            HWND hwnd = _hwnd;
            _hwnd = NULL;
            DestroyWindow(hwnd);
        }
    }
    else
    {
        Assert(!_fPropPageMode);

        HANDLE  hThread = GetCurrentThread();
        HWND    hwndCurrent = _hwnd;
        _hwnd = NULL;

#ifdef NO_MARSHALLING
        g_Modeless.Remove(this);
#endif

        // release the ref that the thread has on the CModelessDlg
        Release();

        // now destory the hwnd. we cached it in case the above release
        // DTor's *this*
        DestroyWindow(hwndCurrent);

#ifndef NO_MARSHALLING
        OleUninitialize();

        if (hThread)
        {
            DWORD dwExitCode;

            if (GetExitCodeThread(hThread, &dwExitCode) &&
                dwExitCode == STILL_ACTIVE)
            {
                CloseHandle(hThread);
                ExitThread(0);
            }
        }
#endif
    }
    return S_OK; 
}

//---------------------------------------------------------------------------
//
//  Member:     InternalShowModalDialog
//
//  Synopsis:   Internal helper to show the modal html dialog.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------
HRESULT 
InternalShowModalDialog( HTMLDLGINFO * pdlgInfo, CHTMLDlg ** ppDlgRet)
{
    HRESULT             hr = S_OK;
    CHTMLDlg *          pDlg = NULL;
    RECT                rc;
    MSG                 msg;
    BOOL                fTrusted;

    // ReleaseCapture to cancel any drag-drop operation
    // TODO (lmollico): This call should be in EnableModeless in shdocvw instead
    ::ReleaseCapture();

    // decode the trusted flag
    fTrusted = (pdlgInfo->dwFlags & HTMLDLG_DONTTRUST) ? FALSE : TRUE;

    // First create the dialog
    pDlg = new CHTMLDlg(NULL, fTrusted, pdlgInfo->punkHost);
    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now set appropriate binding info
    if (pdlgInfo->pvarArgIn)
    {
        hr = THR(VariantCopy (&pDlg->_varArgIn, pdlgInfo->pvarArgIn));
        if (hr)
            goto Cleanup;
    }

    pDlg->_lcid = g_lcidUserDefault;
    pDlg->_fKeepHidden = pdlgInfo->dwFlags & HTMLDLG_NOUI ? TRUE : FALSE;
    pDlg->_fAutoExit = pdlgInfo->dwFlags & HTMLDLG_AUTOEXIT ? TRUE : FALSE;

    hr = THR(pDlg->Create(pdlgInfo));

    if (hr)
        goto Cleanup;

    rc.left   = pDlg->GetLeft();
    rc.top    = pDlg->GetTop();
    rc.right  = rc.left + pDlg->GetWidth();
    rc.bottom = rc.top  + pDlg->GetHeight();

    if (pDlg->_fVerifyRect)
    {
        // Dialog width and heght each have a minimum size and no bigger than screen size
        // and the dialog Must be all on the screen
        // We need to pass a hwndParent that is used for multimonitor systems to determine
        // which monitor to use for restricting the dialog
        pDlg->VerifyDialogRect(&rc, pdlgInfo->hwndParent);
    }

    hr = THR(pDlg->Activate(pdlgInfo->hwndParent, &rc, TRUE));
    if (hr)
        goto Cleanup;

    if (pdlgInfo->pOptionsHolder)
    {
        pdlgInfo->pOptionsHolder->SetParentHWnd(pDlg->_hwnd);
    }

    // Finally push a message loop and give messages to the dialog

    if (!pDlg->_fIsModeless)
    {
        // this is the expected code path 
        while (pDlg->_hwnd)
        {
            ::GetMessage(&msg, NULL, 0, 0);

            if (msg.message < WM_KEYFIRST ||
                msg.message > WM_KEYLAST  ||
                THR(pDlg->TranslateAccelerator(&msg)) != S_OK)
            {
                ::TranslateMessage(&msg);
                ::DispatchMessage(&msg);
            }
        }

        if (pdlgInfo->pvarArgOut)
        {
            hr = THR(VariantCopy(pdlgInfo->pvarArgOut, &pDlg->_varRetVal));
            if (hr)
                goto Cleanup;

            // if the _varRetVal is the dlg's window then the dlg
            // is keeping a ref count on itself and will never release
            // therefore we need to Clear that now. in this case the
            // dlg.returnValue property will subsequently return
            // VT_EMPTY/NULL from pvarArgOut.
            if ( (V_VT(&pDlg->_varRetVal) == VT_DISPATCH ||
                  V_VT(&pDlg->_varRetVal) == VT_UNKNOWN) )
            {
                CHTMLDlg *pRetTest = NULL;

                hr = THR_NOTRACE(
                    V_UNKNOWN(&pDlg->_varRetVal)->QueryInterface(CLSID_HTMLDialog,
                              (void**)&pRetTest));
                if (!hr && pRetTest==pDlg)
                {
                    VariantClear(&pDlg->_varRetVal);
                }
                hr = S_OK;
            }
        }
    }

    if (ppDlgRet)
    {
        // this case only happens when a HTMLDialogEx call wants a modal dialog
        // on its own thread
        *ppDlgRet = pDlg;
        pDlg = NULL;
        hr = S_OK;
    }

Cleanup:
    if (pDlg)
        pDlg->Release();

    RRETURN(hr);
}

HRESULT 
InternalShowModalDialog( HTMLDLGINFO * pdlgInfo )
{
    return InternalShowModalDialog( pdlgInfo, NULL);
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModalDialog
//
//  Synopsis:   Show an html dialog given a resource to load from.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowModalDialog(HWND        hwndParent,
                IMoniker *  pMk,
                VARIANT *   pvarArgIn,
                TCHAR *     pchOptions,
                VARIANT *   pvarArgOut)
{
    HRESULT hr;
    HTMLDLGINFO dlginfo;
    VARIANT     varOptionStr;

    hr = THR(OleInitialize(NULL));
    if (FAILED(hr))
        goto Cleanup;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMk;
    dlginfo.pvarArgIn = pvarArgIn;

    dlginfo.pvarOptions = &varOptionStr;
    V_BSTR(dlginfo.pvarOptions) = pchOptions;       // fake the variant.
    V_VT(dlginfo.pvarOptions) = VT_BSTR;

    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;

    // show modal and trusted dialog.
    hr = THR(InternalShowModalDialog( &dlginfo ));

    OleUninitialize();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     ShowHTMLDialog
//
//  Synopsis:   Just like ShowModalDialog, but with a prettier name.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowHTMLDialog(HWND        hwndParent,
                IMoniker *  pMk,
                VARIANT *   pvarArgIn,
                TCHAR *     pchOptions,
                VARIANT *   pvarArgOut)
{
    HRESULT hr;

    hr = THR(ShowModalDialog(
        hwndParent,
        pMk,
        pvarArgIn,
        pchOptions,
        pvarArgOut));

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// the ex function is what showHTMLDialog should have been.  it takes
// flags to determine if this dialog is to be modal or not (one stop shopping)
//
//----------------------------------------------------------------------------
STDAPI
ShowHTMLDialogEx(HWND        hwndParent,
                 IMoniker *  pMk,
                 DWORD       dwDialogFlags,
                 VARIANT *   pvarArgIn,
                 TCHAR *     pchOptions,
                 VARIANT *   pvarArgOut)
{
    HRESULT     hr = S_OK;
    HTMLDLGINFO dlginfo;
    CVariant    cvarOptions;


    CoInitialize(NULL);

    V_VT(&cvarOptions) = VT_BSTR;
    V_BSTR(&cvarOptions) = SysAllocString(pchOptions);

    dlginfo.hwndParent  = hwndParent;
    dlginfo.pmk         = pMk;
    dlginfo.pvarArgIn   = pvarArgIn;
    dlginfo.pvarOptions = &cvarOptions;
    dlginfo.fModeless   = (dwDialogFlags & HTMLDLG_MODAL) ? FALSE : TRUE;
    // ISSUE (KTam): Why are we filtering flags out before passing them on?
    dlginfo.dwFlags     = dwDialogFlags & ( HTMLDLG_NOUI | HTMLDLG_PRINT_TEMPLATE | HTMLDLG_VERIFY);

    if (dwDialogFlags & HTMLDLG_MODELESS)
    {
        IHTMLWindow2 * pWin = NULL;

        dlginfo.ppDialog    = (pvarArgOut ? &pWin : NULL);

        hr = InternalModelessDialog( &dlginfo );

        if (pvarArgOut)
        {
            // transfer ref to out arg
            V_VT(pvarArgOut) = VT_UNKNOWN;
            V_UNKNOWN(pvarArgOut) = pWin;
        }
    }
    else if (dwDialogFlags & HTMLDLG_MODAL)
    {
        dlginfo.pvarArgOut = pvarArgOut;

        hr = THR(InternalShowModalDialog( &dlginfo ));
    }


    CoUninitialize();

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModelessHTMLDialog
//
//  Synopsis:   like the window::createModelessDialog, this creates and brings up
//              a modeless version of the HTMLDialog.  This function is the api 
//              implementation rather then the OM.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowModelessHTMLDialog(HWND       hwndParent,
                       IMoniker * pMK,
                       VARIANT  * pvarArgIn,
                       VARIANT  * pvarOptions,
                       IHTMLWindow2 ** ppDialog)
{
    HRESULT     hr;
    HTMLDLGINFO dlginfo;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMK;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.ppDialog = ppDialog;
    dlginfo.fModeless = TRUE;

    hr = InternalModelessDialog( &dlginfo );

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModalDialogHelper
//
//  Synopsis:   A helper used by internal forms code to call the
//              html dialog api.
//
//  Arguments:  pBase       -   Pointer to associated CBase instance.
//              pchHTML         HTML name - resource name or Url
//              pDisp           The IDispatch to work on
//              pvarArgOut      The return value from the dialog.
//              pcoh            COptionsHolder (if any) passed down
//              dwFlags         Option flags
//
// HTMLDLG_NOUI             0x1     // run the dialog but don't show it
// HTMLDLG_RESOURCEURL      0x2     // create the moniker for a resource
// HTMLDLG_AUTOEXIT         0x4     // exit immediatly after running script
// HTMLDLG_DONTTRUST        0x8     // don't trust the moniker passed in
//
//---------------------------------------------------------------------------

HRESULT
ShowModalDialogHelper(
                      CMarkup *pMarkup,
                      TCHAR *pchHTML,
                      IDispatch *pDisp,
                      COptionsHolder * pcoh,
                      VARIANT *pvarArgOut,
                      DWORD   dwFlags)
{
    HRESULT         hr;
    CVariant        varArgIn;
    IMoniker *      pmk = NULL;
    HWND            hwndParent;
    BOOL            fTrusted;

    V_VT(&varArgIn) = VT_DISPATCH;
    V_DISPATCH(&varArgIn) = pDisp;
    pDisp->AddRef();

    if(dwFlags & HTMLDLG_RESOURCEURL)
    {
#if DBG == 1
        if (IsTagEnabled(tagHTMLDlgHack))
        {
            TCHAR   achTemp[MAX_PATH];
            TCHAR * pch;

            _tcscpy(achTemp, _T("file://"));
            Verify(GetModuleFileName(g_hInstCore, achTemp + 7, MAX_PATH - 7));
            pch = _tcsrchr(achTemp, _T('\\'));
            _tcscpy(pch + 1, pchHTML);
            hr = THR(CreateURLMoniker(NULL, achTemp, &pmk));
        }
        else
#endif
        hr = THR(CreateResourceMoniker(
                GetResourceHInst(),
                pchHTML,
                &pmk));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(CreateURLMoniker(NULL, pchHTML, &pmk));
        if(hr)
            goto Cleanup;
    }

    fTrusted = (dwFlags & HTMLDLG_DONTTRUST) ? FALSE : TRUE ;

    {
        CDoc * pDoc = pMarkup->Doc();
        CDoEnableModeless   dem(pDoc, pMarkup->GetWindowedMarkupContextWindow());

        hwndParent = dem._hwnd;

        if (hwndParent)
        {
            HTMLDLGINFO dlginfo;

            dlginfo.hwndParent = hwndParent;
            dlginfo.pmk        = pmk;
            dlginfo.fModeless  = FALSE;
            dlginfo.pvarArgIn  = &varArgIn;
            dlginfo.pvarArgOut = pvarArgOut;
            dlginfo.pOptionsHolder = pcoh;
            dlginfo.dwFlags = dwFlags;
            dlginfo.pMarkup = pMarkup;
            hr = THR(InternalShowModalDialog( &dlginfo ));
        }
    }
    
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pmk);
    RRETURN(hr);
}



//+----------------------------------------------------------
//
//  member : VerifyDialogRect()
//
//  Synopsis : for security type reasons we do not want the
//      dialogs to get relocated (via script or bad styles)
//      offscreen.  similarly we want a minimum size (which was
//      set in the pdl
//
//  parameters : pRect is an In/Out parameter.
//               hwndRef - HWND that is used to obtain current monitor
//                      on multimonitor systems
//-----------------------------------------------------------
void
CHTMLDlg::VerifyDialogRect(RECT * pRect, HWND hwndRef)
{
    long     dlgWidth  = pRect->right - pRect->left;
    long     dlgHeight = pRect->bottom - pRect->top;

    Assert(IsWindow(hwndRef));

    HMONITOR        curMonitor;
    MONITORINFO     monitorInfo;

    // Get the current monitor
    curMonitor = MonitorFromWindow(hwndRef, MONITOR_DEFAULTTONEAREST);

    monitorInfo.cbSize = sizeof(monitorInfo);

    Verify(GetMonitorInfo(curMonitor, &monitorInfo));

    long    lLeftMonitor     = monitorInfo.rcMonitor.left;
    long    lTopMonitor      = monitorInfo.rcMonitor.top;
    long    lWidthMonitor    = monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left;
    long    lHeightMonitor   = monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top;

    // make sure width is no larger than screen
    dlgWidth  = min(max(dlgWidth, (long)DIALOG_MIN_WIDTH), lWidthMonitor);
    dlgHeight = min(max(dlgHeight, (long)DIALOG_MIN_HEIGHT ), lHeightMonitor);

    // Always keep whole dialog visable
    pRect->left = max(pRect->left, (long) lLeftMonitor);
    pRect->top  = max(pRect->top, (long) lTopMonitor);

    if ( (pRect->left + dlgWidth) > lLeftMonitor + lWidthMonitor)
    {
        pRect->left = lLeftMonitor + lWidthMonitor - dlgWidth;
    }
    if ( (pRect->top + dlgHeight) > lTopMonitor + lHeightMonitor )
    {
        pRect->top = lTopMonitor + lHeightMonitor - dlgHeight;
    }

    pRect->right  = pRect->left + dlgWidth;
    pRect->bottom = pRect->top  + dlgHeight;
}


void
CHTMLDlg::MoveStatusWindow()
{
    RECT    rcStatus;
    RECT    rc;

    Assert(_hwndStatus);

    GetClientRect(_hwnd, &rc);
    GetWindowRect(_hwndStatus, &rcStatus);

    MoveWindow(
            _hwndStatus,
            0,
            rc.bottom - (rcStatus.bottom - rcStatus.top),
            rc.right - rc.left,
            rc.bottom,
            TRUE);

    DividePartsInStatusWindow();
}


void
CHTMLDlg::DividePartsInStatusWindow()
{
    RECT        rc;
    UINT        cxZone;

    Assert(_hwndStatus);
    GetClientRect(_hwndStatus, &rc);

    cxZone = (rc.right > (DIALOG_ZONE_WIDTH + DIALOG_STATUS_MIN) )
            ? DIALOG_ZONE_WIDTH: (rc.right /2);

    INT aWidths[] = {rc.right - cxZone, -1 };

    // Create 2 parts: URL text, zone information
    SendMessage(_hwndStatus, SB_SETPARTS, 2, (LPARAM)aWidths);
}


//+=========================================================
HRESULT
CHTMLDlg::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

void
CHTMLDlg::CacheZonesIcons()
{
    IInternetZoneManager * pizm = NULL;
    DWORD dwZoneCount = 0;

    // Create ZoneManager
    CoInternetCreateZoneManager(NULL, &pizm, 0);

    if (pizm)
    {
        DWORD dwZoneEnum;

        if (SUCCEEDED(pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0)))
        {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};
                WORD            iIcon=0;
                HICON           hIcon = NULL;

                pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                pizm->GetZoneAttributes(dwZone, &za);

                // Zone icons are in two formats.
                // wininet.dll#1200 where 1200 is the res id.
                // or foo.ico directly pointing to an icon file.
                // search for the '#'
                LPWSTR pwsz = StrChrW(za.szIconPath, L'#');

                if (pwsz)
                {
                    // if we found it, then we have the foo.dll#00001200 format
                    pwsz[0] = L'\0';
                    iIcon = (WORD)StrToIntW(pwsz+1);
                    ExtractIconExW(za.szIconPath,(UINT)(-1*iIcon), NULL, &hIcon, 1 );
                }
                else
                    hIcon = (HICON)ExtractAssociatedIconW(g_hInstCore, za.szIconPath, (LPWORD)&iIcon);

                if (nIndex < MAX_NUM_ZONES_ICONS)
                     g_arhiconZones[nIndex] = hIcon;

            }
            pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }

    ReleaseInterface(pizm);
}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitHTMLDialogs
//
//  Synopsis:   Clears global created by find dialogs "memory"
//
//--------------------------------------------------------------------------

void
DeinitHTMLDialogs()
{
    extern  BSTR    g_bstrFindText;
    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::AccessAllowed()
//
//  Synopsis:   Checks if the dialog did not leave the original URL domain 
//              (via redirection or META-REFRESH for example). This is to prevent
//              security hole when dialogArguments and other values get cached during
//              cross-domain redirection and can be used by gullable target html dialog.
//
//---------------------------------------------------------------------------

BOOL
CHTMLDlg::AccessAllowed()
{
    
    BOOL     retVal = FALSE;
    CDoc    *pDoc;
    CMarkup *pDlgMarkup;
    LPTSTR   pchUrl = NULL;

    if(!_pUnkObj || !_pOriginalMoniker)
        goto Cleanup;
     
    //get dialog's primary markup
    if(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc))
        goto Cleanup;

    pDlgMarkup = pDoc->PrimaryMarkup();
    if(!pDlgMarkup)
        goto Cleanup;

    //get original URL that was passed into createXXXDialog(...)
    if(_pOriginalMoniker->GetDisplayName(NULL, NULL, &pchUrl))
        goto Cleanup;

    //check access - no access would mean that we left appropriate
    retVal = pDlgMarkup->AccessAllowed(pchUrl);

Cleanup:

    if(pchUrl)
        CoTaskMemFree(pchUrl);

    return retVal;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnReadyStateChange
//
//  Synopsis:   Handle changes in readystate of document
//
//---------------------------------------------------------------------------

void
CHTMLDlg::OnReadyStateChange()
{
    HRESULT     hr;
    CVariant    Var;
    IDispatch * pDisp = NULL;
    long        lReadyState;
    LPTSTR      pszTitle  = NULL;
    BSTR        bstrTitle = NULL;

    if (_fPropPageMode) // Readystate changes are not interesting if proppage
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IDispatch, (void **)&pDisp));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_READYSTATE,
            g_lcidUserDefault,
            &Var,
            NULL));
    if (hr)
        goto Cleanup;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        lReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        lReadyState = V_I2(&Var);
    }
    else
    {
        Assert(0 && "Bad VT for readystate");
        goto Cleanup;
    }

    //readyState goes back to loaded or unloaded when redirection or HTTP-EQUIV="Refresh" happens
    //should reset interactive flag to update all things later again.
    if (lReadyState < READYSTATE_INTERACTIVE)
        _fInteractive = FALSE;

    if (lReadyState >= READYSTATE_INTERACTIVE && !_fInteractive)
    {
        HTMLDlgCenter        attrCenter;

        _fInteractive = TRUE;

        BOOL        fRightToLeft = FALSE;
        CDoc      * pDoc;

        hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
        if (hr)
            goto Cleanup;

        Assert(pDoc);
        Assert(pDoc->_pWindowPrimary);
        Assert(pDoc->_pWindowPrimary->Document());
        
        pDoc->_pWindowPrimary->Document()->GetDocDirection(&fRightToLeft);
        
        // if the document is RTL change the window's extended style 
        // so the caption is right aligned.
        if(fRightToLeft)
        {
            LONG lExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);
            // (paulnel) We need to conditionally set WS_EX_LAYOUTRTL here. Due to the way
            //           it is designed we do not want to set WS_EX_RIGHT or WS_EX_RTLREADING
            //           if we have mirrored support.
            //           The document takes care of WS_EX_LEFTSCROLLBAR | WS_EX_RTLREADING
            //           internally.
            if(!g_fMirroredBidiLayout)
                lExStyle |= WS_EX_RIGHT | WS_EX_RTLREADING;
            else
                lExStyle |= WS_EX_LAYOUTRTL;
            SetWindowLong(_hwnd, GWL_EXSTYLE, lExStyle);
        }

        //
        // Set the title of the window to be the document's title
        //

        hr = THR(GetDocumentTitle(&bstrTitle));
        if (!hr)
        {
            if (!_fTrusted)
            {
                hr = Format(FMT_OUT_ALLOC,
                            &pszTitle,
                            0,
                            _T("<0s><1i>"),
                            bstrTitle,
                            GetResourceHInst(), IDS_WEBPAGEDIALOG);
                if (hr)
                    goto Cleanup;
            }
            SetWindowText(_hwnd, _fTrusted ? bstrTitle : pszTitle);
        }

        // Update Status Bar to reflect correct URL and Zone
        {
            const TCHAR * pchUrl = pDoc->GetPrimaryUrl();

            Assert(pchUrl);

            // Set URL text
            SendMessage(_hwndStatus, SB_SETTEXT, 0, (LPARAM) pchUrl);

            IInternetZoneManager * pizm = NULL;
            IInternetSecurityManager * pism = NULL;

            CoInternetCreateSecurityManager(NULL, &pism, 0);
            CoInternetCreateZoneManager(NULL, &pizm, 0);

            if (pism && pizm)
            {
                DWORD dwZone = 0;
                ZONEATTRIBUTES za = {sizeof(za)};
                HICON hIcon = NULL;

                pism->MapUrlToZone(pchUrl, &dwZone, 0);
                pizm->GetZoneAttributes(dwZone, &za);

                if(!g_arhiconZones[0])
                {
                    CacheZonesIcons();
                }
                hIcon = g_arhiconZones[dwZone];

                // Set zone information
                SendMessage(_hwndStatus, SB_SETTEXTW, 1, (LPARAM)za.szDisplayName);

                if (hIcon)
                    SendMessage(_hwndStatus, SB_SETICON, 1, (LPARAM)hIcon);
            }
            ReleaseInterface(pizm);
            ReleaseInterface(pism);

        }
        
        // handle setting the Center value
        attrCenter = GetAAcenter();
        if (HTMLDlgCenterParent == attrCenter || HTMLDlgCenterDesktop == attrCenter)
        {
            HWND        hwndParent;
            CUnitValue  cuvParam;
            RECT        r;

            hwndParent = (HTMLDlgCenterParent == attrCenter && _hwndTopParent) ?
                        _hwndTopParent : GetDesktopWindow();

            Assert (hwndParent);
            GetWindowRect (hwndParent, &r);

            //
            //  check if left/top value has been set to no default value,
            //  if so, do not move to center.
            //

            if (!_pAA || _pAA->FindAAIndex(s_propdescCHTMLDlgdialogLeft.a.GetDispid(),
                                  CAttrValue::AA_Attribute) == AA_IDX_UNKNOWN)
            {
                cuvParam.SetValue (r.left + (r.right - r.left - GetWidth()) / 2, CUnitValue::UNIT_PIXELS);
                SetAAdialogLeft(cuvParam);
            }

            if (!_pAA || _pAA->FindAAIndex(s_propdescCHTMLDlgdialogTop.a.GetDispid(),
                                  CAttrValue::AA_Attribute) == AA_IDX_UNKNOWN)
            {
                cuvParam.SetValue (r.top  + (r.bottom - r.top - GetHeight()) / 2, CUnitValue::UNIT_PIXELS);
                SetAAdialogTop(cuvParam);
            }
        }
        OnPropertyChange(STDPROPID_XOBJ_WIDTH, 0, (PROPERTYDESC *)&s_propdescCHTMLDlgdialogWidth);

        //
        // If Activate has already been called, go ahead and do a show now.
        //

        if (_fActive)
        {
            Show(SW_SHOW);
        }
    }

Cleanup:
    delete pszTitle;
    FormsFreeString(bstrTitle);
    ReleaseInterface(pDisp);
}












//
// Do NOT under any circumstances move this part above.  We don't
// want to contaminate any other part of the dialog with private
// knowledge of the document. (anandra)
//

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnPropertyChange
//
//  Synopsis:   Set the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );

    if (!_fPropPageMode)
    {
        //
        // If we're in dialog mode, then let the top/left/width/height change
        // trigger a resize of the frame window.
        //

        switch (dispid)
        {
        case DISPID_READYSTATE:
            OnReadyStateChange();
            break;

        case STDPROPID_XOBJ_WIDTH:
        case STDPROPID_XOBJ_HEIGHT:
        case STDPROPID_XOBJ_TOP:
        case STDPROPID_XOBJ_LEFT:
        case DISPID_A_FONT :
        case DISPID_A_FONTSIZE :
        case DISPID_A_FONTWEIGHT :
        case DISPID_A_FONTFACE :
        case DISPID_A_FONTSTYLE :
        case DISPID_A_FONTVARIANT :
            {
                // invalidate the HTML element's CFPF since getCascaded* needs to
                // pick up this change.
                CElement *pHtml = GetHTML();
                if (pHtml)
                    pHtml->GetFirstBranch()->VoidCachedInfo();

                RECT rect;

                rect.top    = GetTop();
                rect.left   = GetLeft();
                rect.bottom = rect.top + GetHeight();
                rect.right  = rect.left + GetWidth();

                // We need to pass a _hwnd that is used for multimonitor systems to determine
                // which monitor to use for restricting the dialog
                if (_fVerifyRect)
                    VerifyDialogRect(&rect, _hwndTopParent);

                MoveWindow(_hwnd,
                           rect.left,
                           rect.top,
                           rect.right-rect.left,
                           rect.bottom-rect.top,
                           TRUE);
                if ((!_fTrusted && !!_enumfStatus) ||
                    (_fTrusted && _enumfStatus==HTMLDlgFlagYes))
                {
                    MoveStatusWindow();
                }

                // we also want to invalidate the caches on the doc at this point...
            }
            break;

        case DISPID_CHTMLDlg_dialogHide:
            return THR(onDialogHide());
            break;
        }
    }

    RRETURN(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
}


//
//   Get*()  helper functions. These are responsible for
//      returning the appropriate value for the property
//   GetFontSize() returns the size in TWIPS
//
//   Height, Width, Top, Left, and Font (size)
//
//===========================================================

CElement *
CHTMLDlg::GetHTML()
{
    HRESULT    hr;
    CDoc     * pDoc;
    CElement * pElemRet = NULL;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;
    
    if (pDoc && pDoc->PrimaryMarkup())
    {
        pElemRet = pDoc->PrimaryMarkup()->GetHtmlElement();
    }

Cleanup:
    return pElemRet;
}

long
CHTMLDlg::GetFontSize(CElement * pHTML)
{
    long   lFontSize = 0;

    if (!pHTML)
        pHTML = GetHTML();

    if (pHTML)
    {
        lFontSize = pHTML->GetFirstBranch()->GetParaFormat()->_lFontHeightTwips;

        if (lFontSize <=0)
        {
            lFontSize = _lDefaultFontSize*20;
            goto Cleanup;
        }
    }

Cleanup:
    return lFontSize;
}


long
CHTMLDlg::GetTop()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvTop = GetAAdialogTop();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvTop.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvTop.SetRawValue(s_propdescCHTMLDlgdialogTop.a.ulTagNotPresentDefault);

        return cuvTop.YGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetLeft()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvLeft = GetAAdialogLeft();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvLeft.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvLeft.SetRawValue(s_propdescCHTMLDlgdialogLeft.a.ulTagNotPresentDefault);

        return cuvLeft.XGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetWidth()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvWidth = pElem->GetFirstBranch()->GetCascadedwidth();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvWidth.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvWidth.SetRawValue(s_propdescCHTMLDlgdialogWidth.a.ulTagNotPresentDefault);

        return cuvWidth.XGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetHeight()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvHeight = pElem->GetFirstBranch()->GetCascadedheight();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvHeight.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvHeight.SetRawValue(s_propdescCHTMLDlgdialogHeight.a.ulTagNotPresentDefault);

        return cuvHeight.YGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::LoadDocSynchronous
//
//  Synopsis:   Load the inner document synchronously.  Lovely hack, huh?
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::LoadDocSynchronous(IStream *pStm, TCHAR *pchUrl)
{
    HRESULT     hr;
    CDoc *      pDoc;
    TCHAR *     pchCodePage = NULL;
    CODEPAGE    cp = 0;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    //
    // Again, just a reminder that the only reason this call
    // exists is to force the doc to have a valid base url set in
    // the synchronous load case.  Since we use IPersistStreamInit
    // to load, the doc will never know how to resolve relative
    // references unless we do this or a base tag exists in
    // the html.  We don't want to force everyone to have a base
    // tag, hence this hack.
    //

    hr = THR(pDoc->SetUrl(pDoc->PrimaryMarkup(), pchUrl));
    if (hr)
        goto Cleanup;

    if (_fPropPageMode)
    {
        //
        // In proppage mode, just go load up the codepage from the
        // resource dll and convert it to a dwCodePage.  Use this
        // to prime the parser.  This is acceptable because we don't
        // expose any mechanism for third parties to create property
        // pages using trident.
        //

        hr = THR(Format(
                FMT_OUT_ALLOC,
                &pchCodePage,
                0,
                MAKEINTRESOURCE(IDS_CODEPAGE)));
        if (hr)
            goto Cleanup;

        cp = CodePageFromString(pchCodePage, FALSE);
    }

    hr = THR(pDoc->LoadFromStream(pStm, TRUE, cp));
    if (hr)
        goto Cleanup;

Cleanup:
    delete pchCodePage;
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetFlagsOnDoc
//
//  Synopsis:   Set various CDoc flags, including _fInTrustedHTMLDlg
//              (based on the trusted state of the dialog).
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetFlagsOnDoc(HTMLDLGINFO * pdlginfo)
{
    HRESULT hr;
    CDoc *  pDoc;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    pDoc->_fInTrustedHTMLDlg = _fTrusted;

    // Also set the flag that indicates that the document is a dialog
    // We need to set this so the size is applyed correctly
    pDoc->_fInHTMLDlg = TRUE;
    pDoc->_fInHTMLPropPage = pdlginfo->fPropPage;

    // Also set the flags on the doc indicating whether we're a print template,
    // and whether we're previewing.
    if ( pdlginfo->dwFlags & HTMLDLG_PRINT_TEMPLATE )
    {
        CMarkup *pMarkup = pDoc->PrimaryMarkup();
        
        // Ensure security manager for printing.  This must happen before
        // the CDoc of the dialog has IOleSite::SetClientSite() called on it,
        // otherwise the when the printing security manager calls SetSecuritySite(),
        // it will hook up to the dialog's implementation of IInternetSecurityManager,
        // which is precisely what we want to avoid.  (KTam)
        pDoc->EnsureSecurityManager( TRUE );
        pDoc->_fIsPrintTemplate = TRUE;
        if ( pdlginfo->dwFlags & HTMLDLG_NOUI )
        {
            pDoc->_fIsPrintWithNoUI = TRUE;
        }

        if (pMarkup)
        {
            pMarkup->SetPrintTemplate(TRUE);
            pMarkup->SetPrintTemplateExplicit(TRUE);
        }

        // If we're in a print dialog, we need to fire an event
        // back on the browse doc that we have finished building
        // the print template.
        FirePrintTemplateEvent(IDM_FIRE_PRINTTEMPLATEUP);
    }
    
    // don't fire webOC ewents for documents created this way 
    // this is undone in CMarkup::OnLoadStatusDone
    pDoc->_fDontFireWebOCEvents = TRUE;

Cleanup:
    RRETURN(hr);
}

extern const TCHAR *s_aachPrintType[];


HRESULT
CHTMLDlg::FirePrintTemplateEvent(DWORD nCmdId)
{
    HRESULT             hr;
    CDoc                * pDoc          = NULL;
    IHTMLEventObj2      * pevDlgArgs    = NULL;
    IOleCommandTarget   * pioct         = NULL;
    BSTR                bstrTarget      = NULL;
    BSTR                bstrPrintType   = NULL;
    VARIANT             var;
    int                 i;

    VariantInit(&var);

    // Our dialogArguments should be an IHTMLEventObj2 
    if (    V_VT(&_varArgIn) != VT_UNKNOWN
        ||  !V_UNKNOWN(&_varArgIn)           )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = V_UNKNOWN(&_varArgIn)->QueryInterface(IID_IHTMLEventObj2, (void**)&pevDlgArgs);
    if (hr)
        goto Cleanup;
    Assert(pevDlgArgs);

    //  We should only fire print events for printing.
    //  PageSetup is a print template, but we should not fire an event for it.

    //  Find out what kind of print template we are...
    bstrPrintType = SysAllocString(_T("__IE_PrintType"));
    if (!bstrPrintType)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pevDlgArgs->getAttribute(bstrPrintType, 0, &var);
    if (    hr
        ||  V_VT(&var) != VT_BSTR
        || !V_BSTR(&var)        )
    {
        hr = S_OK;
        goto Cleanup;
    }

    // Lookup the string in our table
    for (i=0; (i < PRINTTYPE_LAST) && (_tcsicmp(s_aachPrintType[i], V_BSTR(&var)) != 0); i++);

    if (    i != PRINTTYPE_PREVIEW
        &&  i != PRINTTYPE_PRINT
        &&  i != PRINTTYPE_PRINTNOUI)
    {
        goto Cleanup;
    }

    //
    // (greglett) If we could directly store a reference to the host and use it (rather than IOCT),
    //            that would be k3wl.  Remember, though, that we may be on another thread...
    //
    
    // Get a reference to the browse doc, if one exists.
    bstrTarget = SysAllocString(_T("__IE_BrowseDocument"));
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pevDlgArgs->getAttribute(bstrTarget, 0, &var);
    if (    hr
        ||  V_VT(&var) != VT_UNKNOWN
        || !V_UNKNOWN(&var)        )
    {
        hr = S_OK;
        goto Cleanup;
    }

    

    // Get an IOCT reference to the browse doc...
    hr = V_UNKNOWN(&var)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);
    VariantClear(&var);

    // Get the Primary IHTMLWindow2 to send with the event
    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;
    Assert(pDoc);
    Assert(pDoc->_pWindowPrimary);

    
    // Send the browse doc notification that it should fire the event.
    // Pass it the window of the dlg as an argument.
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = (IUnknown *)(IHTMLWindow2*)pDoc->_pWindowPrimary;
    hr = pioct->Exec(&CGID_MSHTML, nCmdId, 0, &var, 0);
    VariantInit(&var);  // DONT clear.

Cleanup:
    SysFreeString(bstrPrintType);
    SysFreeString(bstrTarget);
    ReleaseInterface(pevDlgArgs);
    ReleaseInterface(pioct);
    RRETURN(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::EnsureLayout
//
//  Synopsis:   Ensure view is ready before clearing _fInitializing
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::EnsureLayout()
{
    HRESULT hr;
    CDoc *  pDoc;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    pDoc->GetView()->EnsureView(LAYOUT_SYNCHRONOUS);

Cleanup:
    RRETURN(hr);
    
}

BOOL
CHTMLDlg::IsPrintingDialog()
{
    BOOL    bRet = FALSE;

    if (_pUnkObj)
    {
        CDoc *  pDoc;

        HRESULT hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
        if (hr)
            goto Cleanup;
        bRet = pDoc->IsPrintDialog();
    }

Cleanup:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\dlgsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsite.cxx
//
//  Contents:   Implementation of the site for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef __mshtmcid_h__
#include "mshtmcid.h"       // for IDM_IME_ENABLE_RECONVERSION
#endif


#define SID_SOmWindow IID_IHTMLWindow2

// TODO need to move the CMDID_SCRIPTSITE_HTMLDLGTRUST definition from formkrnl.hxx
// to a header file visible here or include formkrnl.hxx here
#define CMDID_SCRIPTSITE_HTMLDLGTRUST 1

DeclareTag(tagHTMLDlgSiteMethods, "HTML Dialog Site", "Methods on the html dialog site")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLDlgSite, CHTMLDlg, HTMLDlg, _Site);

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else if (iid == IID_ITargetFrame)
    {
        *ppv = (ITargetFrame *)this;
    }
    else if (iid == IID_ITargetFrame2)
    {
        *ppv = (ITargetFrame2 *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IInternetSecurityManager)
    {
        *ppv = (IInternetSecurityManager *) this ;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::SaveObject()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::SaveObject"));
    
    // TODO: (anandra) Possibly call the apply method?
    return S_OK;    // Fail silently
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::GetMoniker"));

    //lookatme
    *ppmk = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::GetContainer"));
    
    *ppContainer = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ShowObject()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::ShowObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::OnShowWindow"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::RequestNewObjectLayout( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::RequestNewObjectLayout"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetWindow(HWND * phwnd)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleWindow::GetWindow"));

    *phwnd = HTMLDlg()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::CanInPlaceActivate()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::CanInPlaceActivate"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnInPlaceActivate()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnInPlaceActivate"));
    
    HRESULT     hr;

    hr = THR(HTMLDlg()->_pOleObj->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &HTMLDlg()->_pInPlaceObj));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnUIActivate( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnUIActivate"));
    
    // Clean up any of our ui.
    IGNORE_HR(HTMLDlg()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::GetWindowContext"));
    
    *ppFrame = &HTMLDlg()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

#ifndef WIN16
    HTMLDlg()->GetViewRect(prcPosRect);
#else
    RECTL rcView;
    HTMLDlg()->GetViewRect(&rcView);
    CopyRect(prcPosRect, &rcView);
#endif
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = HTMLDlg()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::Scroll(OLESIZE scrollExtent)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::Scroll"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnUIDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnUIDeactivate"));
    
    // Set focus back to the frame.
    SetFocus(HTMLDlg()->_hwnd);

    // Clean up any of our ui.
    IGNORE_HR(HTMLDlg()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnInPlaceDeactivate( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnInPlaceDeactivate"));
    
    ClearInterface(&HTMLDlg()->_pInPlaceObj);
    ClearInterface(&HTMLDlg()->_pInPlaceActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::DiscardUndoState( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::DiscardUndoState"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::DeactivateAndUndo( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::DeactivateAndUndo"));
    
    RRETURN(THR(HTMLDlg()->_pInPlaceObj->UIDeactivate()));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnPosRectChange"));
    
    Assert(FALSE);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnControlInfoChanged
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnControlInfoChanged()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::OnControlInfoChanged"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::LockInPlaceActive
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::LockInPlaceActive"));
    
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetExtendedControl
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetExtendedControl(IDispatch **ppDispCtrl)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::GetExtendedControl"));
    
    RRETURN(HTMLDlg()->QueryInterface(IID_IDispatch, (void **)ppDispCtrl));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::TransformCoords
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TransformCoords(
    POINTL* pptlHimetric,
    POINTF* pptfContainer,
    DWORD dwFlags)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::TransformCoords"));
    
    //lookatme
    // This tells the object that we deal entirely with himetric
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::TranslateAccelerator
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TranslateAccelerator(LPMSG lpmsg, DWORD grfModifiers)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::TranslateAccelerator"));

    HRESULT hr;
    
    //
    // Pass this on up to the property frame thru the page site, if one
    // exists.
    //

    if (HTMLDlg()->_pPageSite)
    {
        hr = THR(HTMLDlg()->_pPageSite->TranslateAccelerator(lpmsg));
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnFocus
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::OnFocus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ShowPropertyFrame
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ShowPropertyFrame()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::ShowPropertyFrame"));
    
    // To disallow control showing prop-pages
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetTypeInfo
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** ppTypeInfo)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetTypeInfo"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetTypeInfoCount
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetTypeInfoCount(UINT * pctinfo)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetTypeInfoCount"));
    
    *pctinfo = 0;
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetIDsOfNames
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR * rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID * rgdispid)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetIDsOfNames"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::Invoke
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::Invoke"));
    
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        VariantInit(pvarResult);

        switch (dispidMember)
        {
        case DISPID_AMBIENT_SHOWHATCHING:
        case DISPID_AMBIENT_SHOWGRABHANDLES:
            //
            // We don't want the ui-active control to show standard ole
            // hatching or draw grab handles.
            //

            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)0;
            hr = S_OK;
            break;
            
        case DISPID_AMBIENT_LOCALEID:
            hr = S_OK;
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = HTMLDlg()->_lcid;
            break;
        }
    }
    
Cleanup:    
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (NULL != HTMLDlg()->_pHostServiceProvider)
    {
        hr = HTMLDlg()->_pHostServiceProvider->QueryService(sid, iid, ppv);
        
        if (!hr)
        {
            return hr;
        }
    }

    if (sid == IID_ITargetFrame || sid == IID_ITargetFrame2)
    {
        hr = THR_NOTRACE(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLDialog)
    {
        hr = THR(HTMLDlg()->QueryInterface(iid, ppv));
    }
    else if ( sid == IID_IInternetSecurityManager)
    {
        //
        // marka - if we are in a trusted Dialog
        // We then provide our own custom security manager (that allows everything)
        // otherwise - we don't provide this service. 
        //
        if ( HTMLDlg()->_fTrusted )
            hr = THR_NOTRACE( QueryInterface( iid, ppv ));
        else
        {    
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }                
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetFrameOptions
//
//  Synopsis:   per ITargetFrame
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetFrameOptions(DWORD *pdwFlags)
{
    *pdwFlags = HTMLDlg()->_dwFrameOptions;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetFrameMargins
//
//  Synopsis:   per ITargetFrame
//              Dialogs return 0 frame margins for compat w/ <= IE5.0
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetFrameMargins(DWORD *pdwWidth, DWORD *pdwHeight)
{
    if ( !pdwWidth || !pdwHeight )
        return E_POINTER;

    *pdwWidth = 0;
    *pdwHeight = 0;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryStatus
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryStatus(
                const GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP ;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::Exec
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::Exec(
                const GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT  hr = S_OK;

    if(!pguidCmdGroup)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }


    if(CLSID_HTMLDialog == *pguidCmdGroup)
    {
        // we should only get this message
        // when onload is fired.  It uses nCmdID == 0
        // so any other command is an error.
        Assert(nCmdID == 0);

        if(HTMLDlg()->_fAutoExit)
        {
            HTMLDlg()->close();
        }
        else
        {
            hr = OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (CGID_ScriptSite == *pguidCmdGroup)
    {
        switch (nCmdID)
        {
        case CMDID_SCRIPTSITE_HTMLDLGTRUST:
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
    
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = HTMLDlg()->_fTrusted;

            break;

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
        hr = OLECMDERR_E_UNKNOWNGROUP;


Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetHostInfo
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    HRESULT hr = S_OK;
    DWORD   dwInherit = 0;
    
    Assert(pInfo);

    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO)) 
        return E_INVALIDARG;

    //
    // HACKHACK: We need to inherit IME reconversion flag
    // from the main host 
    // We cannot QI IDocHostUIHandler from main host since
    // it is not marshallable
    //
    if (VT_DISPATCH == V_VT(&(HTMLDlg()->_varArgIn)))
    {
        IDispatch            *pDisp = NULL;
        IHTMLOptionsHolder   *pOptions  = NULL;
        IHTMLDocument2       *pDoc2 = NULL;
        IOleCommandTarget    *pCmdTarget = NULL;

        //
        // _varArgIn points to the main CDoc instance
        //
        pDisp = V_DISPATCH(&(HTMLDlg()->_varArgIn));
        if (pDisp)
        {
            hr = THR(pDisp->QueryInterface(IID_IHTMLOptionsHolder, (void **)&pOptions));
            if (pOptions)
            {
                Assert(SUCCEEDED(hr));
                hr = THR(pOptions->get_document(&pDoc2));
            }
            else 
            {
                hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2));
            }

            if (pDoc2 && SUCCEEDED(THR(pDoc2->QueryInterface(IID_IOleCommandTarget, (void **)&pCmdTarget))))
            {
                OLECMD  rgCmds[] = { {IDM_IME_ENABLE_RECONVERSION, 0} };
                hr = pCmdTarget->QueryStatus(&CGID_MSHTML, 
                                            1,
                                            rgCmds,
                                            NULL
                                            );
                if (SUCCEEDED(hr))
                {
                    dwInherit = (rgCmds[0].cmdf == MSOCMDSTATE_UP) ? DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION : 0;
                }
            }

            ReleaseInterface(pDoc2);
            ReleaseInterface(pOptions);
            ReleaseInterface(pCmdTarget);
        }
    }

    pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | dwInherit;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetExternal
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetExternal(IDispatch **ppDisp)
{
    HRESULT hr;

    if (!ppDisp)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = THR(HTMLDlg()->QueryInterface(IID_IDispatch, (void **)ppDisp));
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::TranslateUrl
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TranslateUrl(
    DWORD dwTranslate, 
    OLECHAR *pchURLIn, 
    OLECHAR **ppchURLOut)
{
    HRESULT hr;

    if (!ppchURLOut)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::FilterDataObject
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    HRESULT     hr;

    if (!ppDORet)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppDORet = NULL;
        hr = S_OK;
    }
   
    RRETURN(hr);
}


//+=======================================================================
//
//
// IInternetSecurityManager Methods
//
// marka - CHTMLDlgSite now implements an IInternetSecurityManager
// this is to BYPASS the normal Security settings for a trusted HTML Dialog in a "clean" way
//
// QueryService - for IID_IInternetSecurity Manager - will return that interface
// if we are a _trusted Dialog. Otherwise we fail this QueryService and use the "normal"
// security manager.
//
// RATIONALE:
//
//    - Moving dialog code to mshtmled.dll requires implementing COptionsHolder as an
//      embedded object. Hence if we were honoring the user's Security Settings - if they had 
//    ActiveX turned off - they could potentially break dialogs.
//
//  - If you're in a "trusted" HTML dialog (ie invoked via C-code), your potential to do
//      anything "unsafe" is infinite - so why not allow all security actions ?
//
//
//
//==========================================================================


//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::SetSecuritySite
//
//    Implementation of IInternetSecurityManager::SetSecuritySite
//
//  Synopsis:   Sets the Security Site Manager
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::SetSecuritySite( IInternetSecurityMgrSite *pSite )
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::GetSecuritySite
//
//    Implementation of IInternetSecurityManager::GetSecuritySite
//
//  Synopsis:   Returns the Security Site Manager
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetSecuritySite( IInternetSecurityMgrSite **ppSite )
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::MapURLToZone
//
//    Implementation of IInternetSecurityManager::MapURLToZone
//
//  Synopsis:   Returns the ZoneIndex for a given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::MapUrlToZone(
                        LPCWSTR     pwszUrl,
                        DWORD*      pdwZone,
                        DWORD       dwFlags
                    )
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::ProcessURLAction
//
//    Implementation of IInternetSecurityManager::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//                (marka) We assume that for HTML Dialogs - a Security Manager is *ONLY*
//                created if we are in a Trusted Dialog ( see QueryService above)
//
//                Hence we then allow *ALL* actions
//
//                (michdav - Windows 556900) We don't actually allow all
//                actions. If there is a frame with security="restricted", we
//                have to respect that.  In addition, IFrames also use the
//                default security manager unless they have
//                "application='yes'". This puts dialogs in line with HTA
//                content. This affects all trusted dialogs, including those
//                used by editing.
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::ProcessUrlAction(
                        LPCWSTR     pwszUrl,
                        DWORD       dwAction,
                        BYTE*   pPolicy,    // output buffer pointer
                        DWORD   cbPolicy,   // output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwFlags,    // See enum PUAF for details.
                        DWORD   dwReserved)
{

    // Normal HTML dialogs: Allow everything in trusted scenarios; need to
    // return special code for Java permissions.  Note we can't allow Java if
    // the size of the context is smaller than a DWORD, since allowable values
    // are all DWORDs.

    if (dwFlags & PUAF_ENFORCERESTRICTED || (!(dwFlags & PUAF_TRUSTED)))
        return INET_E_DEFAULT_ACTION;
    else if (cbPolicy == sizeof(DWORD))
        *(DWORD*)pPolicy = ( (dwAction == URLACTION_JAVA_PERMISSIONS) ? URLPOLICY_JAVA_HIGH : URLPOLICY_ALLOW );
    else if (cbPolicy == sizeof(WORD))
        *(WORD*)pPolicy = URLPOLICY_ALLOW;
    else // BYTE or unknown type
        *pPolicy = URLPOLICY_ALLOW;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetSecurityID
//
//    Implementation of IInternetSecurityManager::GetSecurityID
//
//  Synopsis:   Retrieves the Security Identification of the given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetSecurityId( 
            LPCWSTR pwszUrl,
            BYTE __RPC_FAR *pbSecurityId,
            DWORD __RPC_FAR *pcbSecurityId,
            DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::SetZoneMapping
//
//    Implementation of IInternetSecurityManager::SetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::SetZoneMapping  (
                    DWORD   dwZone,        // absolute zone index
                    LPCWSTR lpszPattern,   // URL pattern with limited wildcarding
                    DWORD   dwFlags       // add, change, delete
)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryCustomPolicy
//
//    Implementation of IInternetSecurityManager::QueryCustomPolicy
//
//  Synopsis:   Retrieves the custom policy associated with the URL and
//                specified key in the given context
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryCustomPolicy (
                        LPCWSTR     pwszUrl,
                        REFGUID     guidKey,
                        BYTE**  ppPolicy,   // pointer to output buffer pointer
                        DWORD*  pcbPolicy,  // pointer to output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwReserved )
 {
    return INET_E_DEFAULT_ACTION;
 }
                        
//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetZoneMappings
//
//    Implementation of IInternetSecurityManager::GetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetZoneMappings (
                    DWORD   dwZone,        // absolute zone index
                    IEnumString  **ppenumString,   // output buffer size
                    DWORD   dwFlags        // reserved, pass 0
)
{
    return INET_E_DEFAULT_ACTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\makefile.inc ===
!include $(ROOT)\commonmk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\htmlpop.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       htmlpop.cxx
//
//  Contents:   Implementation of the CHtmlPopup
//
//  History:    05-27-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif


#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>
#endif

#ifndef X_MULTIMON_H_
#define X_MULTIMON_H_
#include <multimon.h>
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#define WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"    // for MAKEUNITVALUE macro.
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"     // for propdesc components
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"    // for CSSParser
#endif

// True if we run on unicode operating system
extern BOOL g_fUnicodePlatform;

#define _cxx_
#include "htmlpop.hdl"

DeclareTag(tagHTMLPopupMethods, "HTML Popup", "Methods on the html popup")
MtDefine(Popup, Mem, "Popup")
MtDefine(CHTMLPopup, Popup, "CHTMLPopup")
MtDefine(CHTMLPopupFactory, Popup, "CHTMLPopupFactory")

const CBase::CLASSDESC CHTMLPopup::s_classdesc =
{
    &CLSID_HTMLPopup,               // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLPopup,                // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


MtDefine(CHTMLPopup_s_aryStackPopup_pv, CHTMLPopup, "CHTMLPopup::_aryStackPopup::_pv");

HHOOK CHTMLPopup::s_hhookMouse = 0;

// REVIEW alexmog: this calls a global constructor. Can we avoid it?
CStackAryPopup CHTMLPopup::s_aryStackPopup;

typedef HMONITOR (WINAPI* PFNMONITORFROMPOINT)(POINT, DWORD);
typedef BOOL     (WINAPI* PFNGETMONITORINFO)(HMONITOR, LPMONITORINFO);

PFNMONITORFROMPOINT g_pfnMonitorFromPoint = NULL;
PFNGETMONITORINFO   g_pfnGetMonitorInfo = NULL;
BOOL                g_fMutlimonInitialized = FALSE;

BOOL
InitMultimonFuncs()
{
    if (g_fMutlimonInitialized)
        return g_pfnGetMonitorInfo != NULL;

    g_pfnGetMonitorInfo = (PFNGETMONITORINFO)GetProcAddress(GetModuleHandleA("user32"), "GetMonitorInfoA");
    if (g_pfnGetMonitorInfo != NULL)
    {
        g_pfnMonitorFromPoint = (PFNMONITORFROMPOINT)GetProcAddress(GetModuleHandleA("user32"), "MonitorFromPoint");
        if (g_pfnMonitorFromPoint == NULL)
        {
            g_pfnGetMonitorInfo = NULL;
        }
    }

    g_fMutlimonInitialized = TRUE;
    return g_pfnGetMonitorInfo != NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   PopupMouseProc
//
//  Synopsis:   
//--------------------------------------------------------------------------

static LRESULT CALLBACK 
PopupMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    if (nCode < 0)  /* do not process the message */
        goto Cleanup;

    if (nCode == HC_ACTION)
    {
        Assert(CHTMLPopup::s_aryStackPopup.Size());
        MOUSEHOOKSTRUCT *   pmh = (MOUSEHOOKSTRUCT *) lParam;
        int i;

        if (    wParam != WM_LBUTTONDOWN
            &&  wParam != WM_MBUTTONDOWN
            &&  wParam != WM_RBUTTONDOWN
            &&  wParam != WM_NCLBUTTONDOWN
            &&  wParam != WM_NCMBUTTONDOWN
            &&  wParam != WM_NCRBUTTONDOWN
            )
            goto Cleanup;

        for (i = CHTMLPopup::s_aryStackPopup.Size() - 1; i >= 0; i --)
        {
            if (PtInRect(&CHTMLPopup::s_aryStackPopup[i]->_rcView, pmh->pt))
                break;

            CHTMLPopup::s_aryStackPopup[i]->hide();
        }
    }

Cleanup:
    return CallNextHookEx(CHTMLPopup::s_hhookMouse, nCode, wParam, lParam);
}


CBase *
CreateHTMLPopup(IUnknown *pUnkOuter)
{
    return new CHTMLPopup(pUnkOuter);
}

CHTMLPopupFactory g_cfHTMLPopup   (CreateHTMLPopup);

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CHTMLPopup::CHTMLPopup(IUnknown *pUnkOuter) //, BOOL fTrusted, IUnknown *pUnkHost)
         : CBase()
{
    TraceTag((tagHTMLPopupMethods, "constructing CHTMLPopup"));
    _fIsOpen = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     ~CHTMLPopup
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CHTMLPopup::~CHTMLPopup( )
{
    Assert(!s_hhookMouse);
    TraceTag((tagHTMLPopupMethods, "destroying CHTMLPopup"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::hide
//
//  Synopsis:   Show Window
//
//  Arguments:
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::hide()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = NULL;

    if (!_fIsOpen || !_pOleObj)
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
    if (FAILED(hr) || _pWindowParent->Doc()->_pDocPopup != pDoc)
        goto Cleanup;

    hr = THR(_pOleObj->DoVerb(
            OLEIVERB_HIDE,
            NULL,
            &_Site,
            0,
            0, //GetDesktopWindow(),
            ENSUREOLERECT(&_rcView)));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::Show
//
//  Synopsis:   Show Window
//
//  Arguments: 
//
//      x,y,w,h:    position and size of the window
//      pElement:   IUnknown of the element, optional, if none, position abs
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::show( long x, long y, long w, long h, VARIANT *pElement)
{
    HRESULT         hr = S_OK;
    SIZEL           sizel;
    CDoc           *pDocPopup = NULL;
    RECT            rcDesktop;
    BOOL            fPosRelative =      pElement->vt == VT_UNKNOWN 
                                    ||  pElement->vt == VT_DISPATCH;

    HMONITOR        hMonitor;
    MONITORINFO     mi;
    IOleWindow     *pIOleWnd = NULL;

    if (!_pUnkObj)
    {
        hr = THR(CreatePopupDoc());
        if (FAILED(hr))
            goto Cleanup;
    }

    Assert(_pOleObj);
    Assert(_pWindowParent && _pWindowParent->Doc());

    if (!_pWindowParent->Doc()->InPlace())
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    //
    // if there is a popup window on the parant doc, hide it
    //

    if (_pWindowParent->Doc()->_pDocPopup && pDocPopup != _pWindowParent->Doc()->_pDocPopup)
    {
        IGNORE_HR(_pWindowParent->Doc()->_pDocPopup->DoVerb(OLEIVERB_HIDE,
                                    NULL,
                                    _pWindowParent->Doc()->_pDocPopup->_pClientSite,
                                    0,
                                    NULL,
                                    NULL));
    }

    sizel.cx = HimetricFromHPix(w);
    sizel.cy = HimetricFromVPix(h);

    IGNORE_HR(_pOleObj->SetExtent(DVASPECT_CONTENT, &sizel));

    if (fPosRelative && pElement->punkVal)
    {
        CElement*       pElem = NULL;
        CRect           rc;
        GetWindowRect(_pWindowParent->Doc()->InPlace()->_hwnd, &rc);

        x = x + rc.left;
        y = y + rc.top;

        hr = THR(pElement->punkVal->QueryInterface(CLSID_CElement, (void**)&pElem));
        if (FAILED(hr))
            goto Cleanup;
        hr = THR(pElem->GetBoundingRect(&rc, RFE_SCREENCOORD));
        if (FAILED(hr))
            goto Cleanup;
        x = x + rc.left;
        y = y + rc.top;
    }

    if (InitMultimonFuncs())
    {
        hMonitor   = g_pfnMonitorFromPoint(CPoint(x, y), MONITOR_DEFAULTTONEAREST);
        mi.cbSize  = sizeof(mi);
        g_pfnGetMonitorInfo(hMonitor, &mi);
        rcDesktop = mi.rcMonitor;
    }
    else
    {
        GetWindowRect(GetDesktopWindow(), &rcDesktop);
    }

    //
    // if the popup window goes out of desktop window space
    // display it inside
    //

    if (x < rcDesktop.left)
    {
        x = rcDesktop.left;
    }
    if (y < rcDesktop.top)
    {
        y = rcDesktop.top;
    }
    if (x + w > rcDesktop.right)
    {
        x = rcDesktop.right - w;
    }

    if (y + h > rcDesktop.bottom)
    {
        y = rcDesktop.bottom - h;
    }

    _rcView.left = x;
    _rcView.top  = y;

    _rcView.right   = x + w;
    _rcView.bottom  = y + h;

    if (    _fIsOpen
        &&  _pWindowParent->Doc()->_pDocPopup
        &&  _pWindowParent->Doc()->_pDocPopup == pDocPopup)
    {
        pDocPopup->SetObjectRects(ENSUREOLERECT(&_rcView), ENSUREOLERECT(&_rcView));
    }
    else
    {
        _pWindowParent->Doc()->_pDocPopup = pDocPopup;

        hr = THR(_pOleObj->DoVerb(
                        OLEIVERB_SHOW,
                        NULL,
                        &_Site,
                        0,
                        0, //GetDesktopWindow(),
                        ENSUREOLERECT(&_rcView)));

        if (FAILED(hr))
            goto Cleanup;
    }

    hr = THR(_pUnkObj->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd));

    if (FAILED(hr))
        goto Cleanup;

    IGNORE_HR(pIOleWnd->GetWindow(&_hwnd));

    ReleaseInterface(pIOleWnd);

    if (!s_hhookMouse)
    {
        s_hhookMouse = SetWindowsHookEx( WH_MOUSE,
                                        PopupMouseProc,
                                        (HINSTANCE) NULL, GetCurrentThreadId());
    }

    if (!_fIsOpen)
    {
        s_aryStackPopup.Append(this);

        _fIsOpen = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT CHTMLPopup::CreatePopupDoc()
{
    HRESULT             hr    = S_OK;
    IPersistMoniker     *pPMk = NULL;
    IMoniker            *pMk  = NULL;
    IPersistStreamInit  *pPSI = NULL;


    TCHAR               *pBaseUrl;
    CElement            *pElementBase = NULL;
    BOOL                fDefault;
    CDoc                *pDocPopup = NULL;
    
    IHTMLElement        *pIBody = NULL;
    IHTMLStyle          *pIStyleBody = NULL;
    IHTMLDocument2      *pIDoc2 = NULL;

    Assert(_pWindowParent && _pWindowParent->Doc());

    hr = THR(CoCreateInstance(CLSID_HTMLPopupDoc,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void **) &_pUnkObj));

    if (FAILED(hr))
        goto Cleanup;

    //
    //  initialize CBase members
    //

    hr = THR(DefaultMembers());
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IOleObject, (void **) &_pOleObj));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pOleObj->SetClientSite(&_Site));
    if (FAILED(hr))
        goto Cleanup;

    hr = _pUnkObj->QueryInterface(IID_IPersistStreamInit,(void**)&pPSI);
    if (FAILED(hr))
        goto Cleanup;

    hr = pPSI->InitNew();
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(CMarkup::GetBaseUrl(
                                 _pWindowParent->Markup(),
                                 &pBaseUrl,
                                 pElementBase,
                                 &fDefault,
                                 NULL));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IHTMLDocument2, (void**)&pIDoc2));
    if (FAILED(hr))
        goto Cleanup;

    pDocPopup->_pPopupParentWindow = _pWindowParent;
    pDocPopup->SetPrimaryUrl(pBaseUrl);
    pDocPopup->PrimaryMarkup()->UpdateSecurityID();

    //
    // set the default style on the body
    //

    hr = pIDoc2->get_body(&pIBody);
    if (FAILED(hr))
        goto Cleanup;

    if (!pIBody)
        goto Cleanup;

    hr = pIBody->get_style(&pIStyleBody);
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_border(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_margin(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_padding(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_overflow(_T("hidden"));
    if (FAILED(hr))
       goto Cleanup;

Cleanup:
    ClearInterface(&pIDoc2);
    ClearInterface(&pIBody);
    ClearInterface(&pIStyleBody);
    ClearInterface(&pMk);
    ClearInterface(&pPMk);
    ClearInterface(&pPSI);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::Passivate
//
//  Synopsis:   1st stage destruction
//
//-------------------------------------------------------------------------

void
CHTMLPopup::Passivate()
{
    if (_fIsOpen && _pOleObj)
    {
        hide();
    }

    if (!_pWindowParent->IsShuttingDown())
    {
        CDoc *pDoc = NULL;
        HRESULT hr = S_OK;
        hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
        if (SUCCEEDED(hr) && pDoc == _pWindowParent->Doc()->_pDocPopup)
        {
            _pWindowParent->Doc()->_pDocPopup = NULL;
        }
    }
    ClearInterface(&_pOleObj);
    ClearInterface(&_pUnkObj);
    _pWindowParent->Release();
    _pWindowParent = NULL;

    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::GetViewRect
//
//  Synopsis:   Get the rectangular extent of the window.
//
//-------------------------------------------------------------------------

void
CHTMLPopup::GetViewRect(RECT *prc)
{
    *prc = _rcView;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::get_document
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::get_document(IHTMLDocument ** ppDoc)
{
    HRESULT hr = S_OK;
    CDoc   *pDocPopup = NULL;

    Assert (ppDoc);

    *ppDoc = NULL;

    //
    // if there is no doc create the doc
    //

    if (!_pUnkObj)
    {
        hr = THR(CreatePopupDoc());

        if (FAILED(hr))
            goto Cleanup;
    }

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    if (!pDocPopup->PrimaryMarkup()->AccessAllowed(_pWindowParent->Markup()))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    hr = THR(_pUnkObj->QueryInterface(IID_IHTMLDocument, (void**)ppDoc));

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::get_isOpen
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::get_isOpen(VARIANT_BOOL * pfIsOpen)
{
    *pfIsOpen = _fIsOpen ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IHTMLPopup, NULL)

        default:
            if (iid == CLSID_HTMLPopup)
            {
                *ppv = this;
                goto Cleanup;
            }
            break;
    }

    if (!*ppv)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}

void
CHTMLPopup::ClearPopupInParentDoc()
{
    if (!_fIsOpen)
        return;

    _fIsOpen = FALSE;

    if (_pWindowParent && _pWindowParent->Doc())
    {
        _pWindowParent->Doc()->_pDocPopup = NULL;
    }

    if (s_hhookMouse)
    {
        int iSizeStack = s_aryStackPopup.Size();
        int i;

        Assert(iSizeStack);

        for (i = iSizeStack - 1; i >= 0; i --)
        {
            // BOOL fFound = s_aryStackPopup[i] == this;


            if (s_aryStackPopup[i] == this)
            {
                s_aryStackPopup.Delete(i);
                break;
            }
        }

        if (!s_aryStackPopup.Size())
        {
            UnhookWindowsHookEx(s_hhookMouse);
            s_hhookMouse = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\modeless.cxx ===
//=============================================================================
//
//  File  : modeless.cxx
//
//  Sysnopsis : modeless dialog helper functinos and support classes
//
//=============================================================================
#include "headers.hxx"

#if defined(UNIX) 
#include "window.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifdef NO_MARSHALLING

#include "unixmodeless.cxx"

#endif

//----------------------------------------------------------
// CTOR
//----------------------------------------------------------
CThreadDialogProcParam::CThreadDialogProcParam(IMoniker * pmk,
                                               VARIANT  * pvarArgIn) :
        _ulRefs(1), 
        _pMarkup(NULL)
{
    if (pvarArgIn)
        _varParam.Copy(pvarArgIn);

    Assert(pmk);
    _pmk = pmk;
    _pmk->AddRef(); 
}

//----------------------------------------------------------
// DTOR
//----------------------------------------------------------
CThreadDialogProcParam::~CThreadDialogProcParam ()
{
    ClearInterface (&_pmk);
    if (_pMarkup)
    {
        _pMarkup->Release();
        _pMarkup = NULL;
    }
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_parameters(VARIANT * pvar)
{
    if (!pvar)
        return E_POINTER;

    return VariantCopy(pvar, &_varParam);
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_optionString (VARIANT * pvar)
{
    if (!pvar)
        return E_POINTER;

    return VariantCopy(pvar, &_varOptions);
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_moniker(IUnknown ** ppUnk)
{
    if (!ppUnk)
        return E_POINTER;

    *ppUnk = NULL;

    if (_pmk)
    {
        HRESULT hr = _pmk->QueryInterface(IID_IUnknown, (void**)ppUnk);
        return hr;
    }
    else
        return S_FALSE;
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_document(IUnknown ** ppUnk)
{
    if (!ppUnk)
        return E_POINTER;

    *ppUnk = NULL;
    
    return(!_pMarkup) ? S_FALSE :
                    (_pMarkup->Window()->Document()->QueryInterface(IID_IUnknown, (void**)ppUnk));
    
}
//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL; 

    if (iid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (iid == IID_IHTMLModelessInit)
        *ppv = (IHTMLModelessInit*)this;
    else if (iid== IID_IDispatch)
        *ppv = (IDispatch *)this;

    if (*ppv)
    {
       ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
     return E_NOINTERFACE;
}

//==========================================================
//  Forward declarations & Helper functions
//==========================================================
DWORD WINAPI CALLBACK ModelessThreadProc( void * pv);
HRESULT               ModelessThreadInit( ThreadProcParam * pParam, 
                                          CHTMLDlg ** ppDlg);
HRESULT CreateModelessDialog(IHTMLModelessInit * pMI, 
                             IMoniker * pMoniker,
                             DWORD      dwFlags,
                             HWND       hwndParent,
                             CHTMLDlg **ppDialog);

HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo, CHTMLDlg ** ppDlgRet );

//+---------------------------------------------------------
//
//  Helper function : InternalModelessDialog
//
//  Synopsis: spin off a thread, and cause the dialog to be brought up
//
//----------------------------------------------------------
HRESULT
InternalModelessDialog( HTMLDLGINFO * pdlgInfo )
{
    HRESULT         hr = S_OK;
    THREAD_HANDLE   hThread = NULL;
    EVENT_HANDLE    hEvent = NULL;
    LPSTREAM        pStm = NULL;
    LPSTREAM        pStmParam = NULL;
    DWORD           idThread;
    ThreadProcParam tppBundle;

    // we are pushing a msgLoop, make sure this sticks around
    if (pdlgInfo->pMarkup)
        pdlgInfo->pMarkup->AddRef();

    if (pdlgInfo->ppDialog)
         *(pdlgInfo->ppDialog) = NULL;
         
    CThreadDialogProcParam *ptpp = new CThreadDialogProcParam(pdlgInfo->pmk, pdlgInfo->pvarArgIn);
    if (!ptpp)
        return E_OUTOFMEMORY;

#ifndef NO_MARSHALLING
    hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
    {
        delete ptpp;
        RRETURN(GetLastWin32Error());
    }
#endif

    // populate more of the ThreadProc sturcture
    //------------------------------------------
    if (pdlgInfo->pvarOptions)
        ptpp->_varOptions.Copy(pdlgInfo->pvarOptions);

    if (pdlgInfo->pMarkup)
    {
        ptpp->_pMarkup = pdlgInfo->pMarkup;
        pdlgInfo->pMarkup->AddRef();
    }

#ifndef NO_MARSHALLING
    // now put the threadprocParam into a marshallable place
    //------------------------------------------------------
    hr = THR(CoMarshalInterThreadInterfaceInStream(
                    IID_IHTMLModelessInit,
                    (LPUNKNOWN)ptpp,
                    &pStmParam ));
    if (hr)
        goto Cleanup;

    // Create the new thread
    //-----------------------
    tppBundle._hEvent = hEvent;
    tppBundle._pParamStream = pStmParam;
    tppBundle._ppStm = &pStm;
    tppBundle._hwndDialog = NULL;
    tppBundle._pMK = pdlgInfo->pmk;
    tppBundle._dwFlags = pdlgInfo->dwFlags;
    tppBundle._hwndParent = pdlgInfo->hwndParent;
    tppBundle._fModal = !pdlgInfo->fModeless;

    hThread = CreateThread(NULL, 
                           0,
                           ModelessThreadProc, 
                           &tppBundle, 
                           0, 
                           &idThread);
    if (hThread == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
#else //no_marshalling
    ptpp->AddRef();
    tppBundle._hEvent = NULL;
    tppBundle._pParamStream = (LPSTREAM)ptpp;
    tppBundle._ppStm = &pStm;
    tppBundle._hwndDialog = NULL;
    tppBundle._pMK = pdlgInfo->pmk;
    tppBundle._dwFlags = pdlgInfo->dwFlags;
    tppBundle._hwndParent = pdlgInfo->hwndParent;
    tppBundle._fModal = !pdlgInfo->fModeless;

    ModelessThreadProc((void*) &tppBundle); 
#endif //no_marshalling
    {
        // the modeless dialog may have a statusbar window.
        // In this case, the activate() of the dialog and the CreateWindowEX for the status
        // window will thread block with the primary thread .  Instead of just
        // doing a WaitForSIngleEvent, we want to keep our message loop spining,
        // but we don't really want much to happen.  If there is a parentDoc (script
        // rasied dlg) then we make it temporarily modal while the modeless dialog is 
        // initialized and raised.  In the case of an API call, we do our best, but
        // let the message pump spin.

#ifndef NO_MARSHALLING
        // the faster this is the faster the dialog comes up
        while (WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)
        {
            MSG  msg;

            if (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
#endif
    }

    // and finally deal with the return IHTMLWindow2 pointer
    //-------------------------------------------------
    if (pStm && pdlgInfo->ppDialog)
    {
#ifndef NO_MARSHALLING
        hr = THR(CoGetInterfaceAndReleaseStream(pStm, 
                                            IID_IHTMLWindow2, 
                                            (void **) (pdlgInfo->ppDialog)));
#else
        hr = S_OK;
        *(pdlgInfo->ppDialog) = (IHTMLWindow2*)pStm;
#endif

        //
        // don't add print templates to this list, we WANT the spooling 
        // to continue even if the main document gets navigated away, or 
        // closed.
        //
        if (   pdlgInfo->pMarkup 
            && tppBundle._hwndDialog
            && !(pdlgInfo->dwFlags & HTMLDLG_PRINT_TEMPLATE))
        {
            HWND * pHwnd;
            Assert(pdlgInfo->pMarkup->Document()->Window());
            pHwnd = pdlgInfo->pMarkup->Document()->Window()->_aryActiveModeless.Append();
            if (pHwnd)
                *pHwnd = tppBundle._hwndDialog;
        }
    }
    
Cleanup:

#ifndef NO_MARSHALLING
    CloseEvent(hEvent);
#endif

    ptpp->Release();
    if (pdlgInfo->pMarkup)
        pdlgInfo->pMarkup->Release();

    if(hThread)
    {
        CloseHandle(hThread);
    }

    RRETURN( hr );
}

//+--------------------------------------------------------------------------
//
//  Function : ModlessThreadProc - 
//
//  Synopsis : responsible for the thread administation
//
//--------------------------------------------------------------------------

DWORD WINAPI CALLBACK
ModelessThreadProc( void * pv )
{
    HRESULT    hr;
    MSG        msg;
    CHTMLDlg * pDlg = NULL;

    ITypeLib * pMSHTMLTypeLib = NULL;

#ifndef NO_MARSHALLING
    hr = THR(OleInitialize(NULL));
    if (FAILED(hr))
        goto Cleanup;
#else
    CDoc* pDoc = NULL;
#endif


    // This is an attempt to force the MSHTML.TLB to stay cached 

    // TODO: Version independent and/or localized version of loading the type library is needed

    if (FAILED(LoadTypeLib(TEXT("MSHTML.TLB"),&pMSHTMLTypeLib)))
    {
        // If we have not loaded the type library then we haven't cached the file.
        Assert(0);
    }

    // Nop or start a message Q
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // post ourselves a message to initialize
    PostThreadMessage(GetCurrentThreadId(), WM_USER+1, (LPARAM)pv, 0);

    // process message queue:
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.hwnd ==NULL && msg.message==WM_USER+1)
        {
            // do my initialization work here...
            hr = ModelessThreadInit((ThreadProcParam *)msg.wParam,
                                     &pDlg);
#ifdef NO_MARSHALLING
            if (hr)
                break;
            else
            {
                pDoc = (CDoc *)((ThreadProcParam*)msg.wParam)->_hEvent;
            }
#endif
        }
        else
        {
            if (msg.message < WM_KEYFIRST ||
                msg.message > WM_KEYLAST  ||
                ( pDlg &&
                  THR(pDlg->TranslateAccelerator(&msg)) != S_OK))
            {
               // Process all messages in the message queue.
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

#ifdef NO_MARSHALLING
            if (pDoc && pDoc->LoadStatus() >= LOADSTATUS_PARSE_DONE)
            {
                break;
            }
#endif
        }
    }

Cleanup:

    // This is an attempt to force the MSHTML.TLB to stay cached
    
    if (pMSHTMLTypeLib)
    {
        pMSHTMLTypeLib->Release();
    }

    return (0);
}


//+-------------------------------------------------------------------------
//
//  Function:   ModelessThreadInit
//
//  Synopsis:   Creates a new modeless dialog on this new thread
//
//--------------------------------------------------------------------------

HRESULT 
ModelessThreadInit(ThreadProcParam * pParam, CHTMLDlg ** ppDlg)
{
    CHTMLDlg          * pDlg = NULL;
    EVENT_HANDLE        hEvent= pParam->_hEvent;
    HRESULT             hr;
    IHTMLModelessInit * pMI = NULL;

    Assert (ppDlg);
    *ppDlg = NULL;

#ifndef NO_MARSHALLING
    // get the initialization interface from the marshalling place
    //------------------------------------------------------------------
    hr = THR(CoGetInterfaceAndReleaseStream(pParam->_pParamStream, 
                                            IID_IHTMLModelessInit, 
                                            (void**) & pMI));

#else
    hr = S_OK;
    pMI = (IHTMLModelessInit*)pParam->_pParamStream;
#endif

   if (hr)
        goto Cleanup;

    // Create the dialog
    //------------------------------------------------
    if (pParam->_fModal)
    {
        HTMLDLGINFO dlginfo;
        CVariant    cvarTransfer;
        CVariant    cvarArgs;

        dlginfo.hwndParent = pParam->_hwndParent;
        dlginfo.pmk        = pParam->_pMK;
        dlginfo.fModeless  = TRUE;
        dlginfo.fPropPage  = FALSE;
        dlginfo.dwFlags    = pParam->_dwFlags;
        dlginfo.pvarArgIn  = &cvarArgs;

        pMI->get_parameters( dlginfo.pvarArgIn);

        hr = pMI->get_optionString( &cvarTransfer );
        if (hr==S_OK )
        {
            if (V_VT(&cvarTransfer)==VT_BSTR )
                dlginfo.pvarOptions = &cvarTransfer;
        }

        // show modal and trusted dialog.
        hr = THR(InternalShowModalDialog( &dlginfo, &pDlg ));
    }
    else
    {
        hr = THR(CreateModelessDialog(pMI, 
                                      pParam->_pMK, 
                                      pParam->_dwFlags, 
                                      pParam->_hwndParent, 
                                      &pDlg));
    }
    if (hr)
        goto Cleanup;

    *ppDlg = pDlg;

#ifdef NO_MARSHALLING
    g_Modeless.Append(pDlg);
#endif

    // we need to return a window parameter. to do this we check
    // for a strm pointer in the init-structure, and if it is there
    // then we use it to marshal the ITHMLWindow2 into. The caller 
    //  thread will unmarshal from here and release the stream.
    if (pParam->_ppStm && pDlg)
    {
        CDoc     * pDoc = NULL;

        hr = THR(pDlg->_pUnkObj->QueryInterface(CLSID_HTMLDocument, 
                                            (void **)&pDoc));
        if (SUCCEEDED(hr) && pDoc) //  && pDoc->_pPrimaryMarkup)
        {

#ifndef NO_MARSHALLING
            hr = THR(CoMarshalInterThreadInterfaceInStream(
                        IID_IUnknown,
                        (IUnknown *)(IPrivateUnknown *)pDoc->_pWindowPrimary,
                        pParam->_ppStm));
#else
            hr = S_OK;
            pDoc->_pWindowPrimary->AddRef();
            *pParam->_ppStm = (LPSTREAM)((IHTMLWindow2*)pDoc->_pWindowPrimary);
            pParam->_hEvent = (EVENT_HANDLE)pDoc;
#endif

            if (hr==S_OK)
                pParam->_hwndDialog = pDlg->_hwnd;
        }
    }

Cleanup:
#ifndef NO_MARSHALLING
    if (hEvent)
        SetEvent(hEvent);
#endif

    ReleaseInterface (pMI);

    if (hr)
    {
        if (pDlg)
        {
            pDlg->Release();
            *ppDlg = NULL;
        }

#ifndef NO_MARSHALLING
        OleUninitialize();
#endif
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  Method : CreateModelessDialog
//
//  Synopsis : does the actual creation of hte modeless dialog. this
//      code parallels the logic in internalShowModalDialog.
//
//------------------------------------------------------------------

HRESULT 
CreateModelessDialog(IHTMLModelessInit * pMI, 
                     IMoniker * pMoniker,
                     DWORD      dwFlags,
                     HWND       hwndParent,
                     CHTMLDlg **ppDialog) 
{
    HRESULT        hr;
    HTMLDLGINFO    dlginfo;
    CHTMLDlg     * pDlg = NULL;
    RECT           rc;
    TCHAR        * pchOptions = NULL;
    CVariant       cvarTransfer;

    Assert(ppDialog);
    Assert(pMI);
    Assert(pMoniker);

    // set the nonpropdesc options, these should match the defaults
    //------------------------------------------------------------
    dlginfo.fPropPage  = FALSE;
    dlginfo.pmk        = pMoniker;
    dlginfo.hwndParent = hwndParent;
    dlginfo.fModeless  = TRUE;
    dlginfo.dwFlags    = dwFlags;

    // Actually create the dialog
    //---------------------------
    pDlg = new CHTMLDlg(NULL, !(dwFlags & HTMLDLG_DONTTRUST), NULL);
    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now set appropriate binding info and other dialog member variables
    //-------------------------------------------------------------------
    hr = pMI->get_parameters( &(pDlg->_varArgIn));
    if (hr)
    {
        VariantInit(&(pDlg->_varArgIn));
    }

    pDlg->_lcid = g_lcidUserDefault;
    pDlg->_fKeepHidden = dwFlags & HTMLDLG_NOUI ? TRUE : FALSE;
    pDlg->_fAutoExit = dwFlags & HTMLDLG_AUTOEXIT ? TRUE : FALSE;

    hr = pMI->get_optionString( &cvarTransfer );
    if (hr==S_OK )
    {
        pchOptions = (V_VT(&cvarTransfer)==VT_BSTR ) ? V_BSTR(&cvarTransfer) : NULL;
    }

    if (pchOptions)
        dlginfo.pvarOptions = &cvarTransfer;
    
    hr = THR(pDlg->Create(&dlginfo));
    if (hr)
        goto Cleanup;

    rc.left   = pDlg->GetLeft();
    rc.top    = pDlg->GetTop();
    rc.right  = rc.left + pDlg->GetWidth();
    rc.bottom = rc.top  + pDlg->GetHeight();

    if (pDlg->_fVerifyRect)
    {
        // Dialog width and heght each have a minimum size and no bigger than screen size
        // and the dialog Must be all on the screen
        // We need to pass a hwndParent that is used for multimonitor systems to determine
        // which monitor to use for restricting the dialog
        pDlg->VerifyDialogRect(&rc, dlginfo.hwndParent);
    }

    hr = THR(pDlg->Activate(dlginfo.hwndParent, &rc, FALSE));

    *ppDialog = pDlg;

Cleanup:
    if (hr && pDlg)
    {
        pDlg->Release();
        *ppDialog = NULL;
    }

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\popsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       popsite.cxx
//
//  Contents:   Implementation of the site for hosting html popups
//
//  History:    05-28-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#define SID_SOmWindow IID_IHTMLWindow2

// to a header file visible here or include formkrnl.hxx here
#define CMDID_SCRIPTSITE_HTMLPOPTRUST 1

DeclareTag(tagHTMLPopupSiteMethods, "HTML Popup Site", "Methods on the html popup site")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLPopupSite, CHTMLPopup, HTMLPopup, _Site);

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else if (iid == IID_ITargetFrame)
    {
        *ppv = (ITargetFrame *)this;
    }
    else if (iid == IID_ITargetFrame2)
    {
        *ppv = (ITargetFrame2 *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IInternetSecurityManager)
    {
        *ppv = (IInternetSecurityManager *) this ;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::SaveObject()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::SaveObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::GetMoniker"));

    //lookatme
    *ppmk = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::GetContainer"));
    
    *ppContainer = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ShowObject()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::ShowObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::OnShowWindow"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::RequestNewObjectLayout( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::RequestNewObjectLayout"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetWindow(HWND * phwnd)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleWindow::GetWindow"));

    *phwnd = NULL;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::CanInPlaceActivate()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::CanInPlaceActivate"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnInPlaceActivate()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnInPlaceActivate"));
    
    HRESULT     hr;

    hr = THR(HTMLPopup()->_pOleObj->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &HTMLPopup()->_pInPlaceObj));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnUIActivate( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnUIActivate"));
    
    // Clean up any of our ui.
    // IGNORE_HR(HTMLPopup()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::GetWindowContext"));
    
    *ppFrame = &HTMLPopup()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

#ifndef WIN16
    HTMLPopup()->GetViewRect(prcPosRect);
#else
    RECTL rcView;
    HTMLPopup()->GetViewRect(&rcView);
    CopyRect(prcPosRect, &rcView);
#endif
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = HTMLPopup()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::Scroll(OLESIZE scrollExtent)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::Scroll"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnUIDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnUIDeactivate"));

    HTMLPopup()->ClearPopupInParentDoc();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnInPlaceDeactivate( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnInPlaceDeactivate"));
    
    ClearInterface(&HTMLPopup()->_pInPlaceObj);
    ClearInterface(&HTMLPopup()->_pInPlaceActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::DiscardUndoState( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::DiscardUndoState"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::DeactivateAndUndo( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::DeactivateAndUndo"));
    
    RRETURN(THR(HTMLPopup()->_pInPlaceObj->UIDeactivate()));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnPosRectChange"));
    
    Assert(FALSE);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnControlInfoChanged
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnControlInfoChanged()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::OnControlInfoChanged"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::LockInPlaceActive
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::LockInPlaceActive"));
    
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetExtendedControl
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetExtendedControl(IDispatch **ppDispCtrl)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::GetExtendedControl"));
    
    RRETURN(HTMLPopup()->QueryInterface(IID_IDispatch, (void **)ppDispCtrl));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::TransformCoords
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TransformCoords(
    POINTL* pptlHimetric,
    POINTF* pptfContainer,
    DWORD dwFlags)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::TransformCoords"));
    
    //lookatme
    // This tells the object that we deal entirely with himetric
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::TranslateAccelerator
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TranslateAccelerator(LPMSG lpmsg, DWORD grfModifiers)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::TranslateAccelerator"));

    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnFocus
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::OnFocus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ShowPropertyFrame
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ShowPropertyFrame()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::ShowPropertyFrame"));
    
    // To disallow control showing prop-pages
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetTypeInfo
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** ppTypeInfo)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetTypeInfo"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetTypeInfoCount
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetTypeInfoCount(UINT * pctinfo)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetTypeInfoCount"));
    
    *pctinfo = 0;
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetIDsOfNames
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR * rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID * rgdispid)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetIDsOfNames"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::Invoke
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::Invoke"));
    
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        VariantInit(pvarResult);

        switch (dispidMember)
        {
        case DISPID_AMBIENT_SHOWHATCHING:
        case DISPID_AMBIENT_SHOWGRABHANDLES:
            //
            // We don't want the ui-active control to show standard ole
            // hatching or draw grab handles.
            //

            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)0;
            hr = S_OK;
            break;
            
        }
    }
    
Cleanup:    
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (sid == IID_IHTMLPopup)
    {
        hr = THR(HTMLPopup()->QueryInterface(iid, ppv));
    }
    else if (!HTMLPopup()->_pWindowParent)
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = THR(HTMLPopup()->_pWindowParent->Document()->QueryService(sid, iid, ppv));
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetFrameOptions
//
//  Synopsis:   per ITargetFrame
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetFrameOptions(DWORD *pdwFlags)
{
    //*pdwFlags = HTMLPopup()->_dwFrameOptions;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryStatus
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryStatus(
                const GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP ;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::Exec
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::Exec(
                const GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT  hr = S_OK;

    if(!pguidCmdGroup)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    hr = OLECMDERR_E_UNKNOWNGROUP;


Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetHostInfo
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    Assert(pInfo);
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr =  THR(pHostUIHandler->GetHostInfo(pInfo));
        }
        else
        {
            pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG;
            pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
            hr =  S_OK;
        }
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ShowUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ShowUI(DWORD dwID, IOleInPlaceActiveObject * pActiveObject, IOleCommandTarget * pCommandTarget, IOleInPlaceFrame * pFrame, IOleInPlaceUIWindow * pDoc)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc));
    }
    
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::HideUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::HideUI(void)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->HideUI());
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::UpdateUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::UpdateUI(void)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->UpdateUI());
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::EnableModeless
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::EnableModeless(BOOL fEnable)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->EnableModeless(fEnable));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::OnDocWindowActivate
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::OnDocWindowActivate(BOOL fActivate)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->OnDocWindowActivate(fActivate));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::OnFrameWindowActivate
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::OnFrameWindowActivate(BOOL fActivate)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->OnFrameWindowActivate(fActivate));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ResizeBorder
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow * pUIWindow, BOOL fRameWindow)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ResizeBorder(prcBorder, pUIWindow, fRameWindow));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ShowContextMenu
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ShowContextMenu(DWORD dwID, POINT * pptPosition, IUnknown * pcmdtReserved, IDispatch * pDispatchObjectHit)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ShowContextMenu(dwID, pptPosition, pcmdtReserved, pDispatchObjectHit));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::TranslateAccelerator
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::TranslateAccelerator(LPMSG lpMsg, const GUID * pguidCmdGroup, DWORD nCmdID)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetOptionKeyPath
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->GetOptionKeyPath(ppchKey, dw));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetDropTarget
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->GetDropTarget(pDropTarget, ppDropTarget));
    }

    RRETURN1(hr, S_FALSE);
}
//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetExternal
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetExternal(IDispatch **ppDisp)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->GetExternal(ppDisp));
        }
        else
        {
            hr = THR(HTMLPopup()->QueryInterface(IID_IDispatch, (void **)ppDisp));
        }
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::TranslateUrl
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TranslateUrl(
    DWORD dwTranslate, 
    OLECHAR *pchURLIn, 
    OLECHAR **ppchURLOut)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (!ppchURLOut)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut));
        }
        else
        {
            *ppchURLOut = NULL;
            hr = S_OK;
        }
    }
    
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::FilterDataObject
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT     hr = S_OK;
    
    if (!ppDORet)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->FilterDataObject(pDO, ppDORet));
        }
        else
        {
            *ppDORet = NULL;
            hr = S_OK;
        }
    }
   
    RRETURN(hr);
}


//+=======================================================================
//
//
// IInternetSecurityManager Methods
//
// marka - CHTMLPopupSite now implements an IInternetSecurityManager
// this is to BYPASS the normal Security settings for a trusted HTML Popup in a "clean" way
//
// QueryService - for IID_IInternetSecurity Manager - will return that interface
// if we are a _trusted Popup. Otherwise we fail this QueryService and use the "normal"
// security manager.
//
// RATIONALE:
//
//    - Moving popup code to mshtmled.dll requires implementing COptionsHolder as an
//      embedded object. Hence if we were honoring the user's Security Settings - if they had 
//    ActiveX turned off - they could potentially break popups.
//
//  - If you're in a "trusted" HTML popup (ie invoked via C-code), your potential to do
//      anything "unsafe" is infinite - so why not allow all security actions ?
//
//
//
//==========================================================================


//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::SetSecuritySite
//
//    Implementation of IInternetSecurityManager::SetSecuritySite
//
//  Synopsis:   Sets the Security Site Manager
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::SetSecuritySite( IInternetSecurityMgrSite *pSite )
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::GetSecuritySite
//
//    Implementation of IInternetSecurityManager::GetSecuritySite
//
//  Synopsis:   Returns the Security Site Manager
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetSecuritySite( IInternetSecurityMgrSite **ppSite )
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::MapURLToZone
//
//    Implementation of IInternetSecurityManager::MapURLToZone
//
//  Synopsis:   Returns the ZoneIndex for a given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::MapUrlToZone(
                        LPCWSTR     pwszUrl,
                        DWORD*      pdwZone,
                        DWORD       dwFlags
                    )
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::ProcessURLAction
//
//    Implementation of IInternetSecurityManager::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//                (marka) We assume that for HTML Popups - a Security Manager is *ONLY*
//                created if we are in a Trusted Popup ( see QueryService above)
//
//                Hence we then allow *ALL* actions
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::ProcessUrlAction(
                        LPCWSTR     pwszUrl,
                        DWORD       dwAction,
                        BYTE*   pPolicy,    // output buffer pointer
                        DWORD   cbPolicy,   // output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwFlags,    // See enum PUAF for details.
                        DWORD   dwReserved)
{
    if (cbPolicy == sizeof(DWORD))
        *(DWORD*)pPolicy = URLPOLICY_ALLOW;
    else if (cbPolicy == sizeof(WORD))
        *(WORD*)pPolicy = URLPOLICY_ALLOW;
    else // BYTE or unknown type
        *pPolicy = URLPOLICY_ALLOW;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetSecurityID
//
//    Implementation of IInternetSecurityManager::GetSecurityID
//
//  Synopsis:   Retrieves the Security Identification of the given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetSecurityId( 
            LPCWSTR pwszUrl,
            BYTE __RPC_FAR *pbSecurityId,
            DWORD __RPC_FAR *pcbSecurityId,
            DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::SetZoneMapping
//
//    Implementation of IInternetSecurityManager::SetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::SetZoneMapping  (
                    DWORD   dwZone,        // absolute zone index
                    LPCWSTR lpszPattern,   // URL pattern with limited wildcarding
                    DWORD   dwFlags       // add, change, delete
)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryCustomPolicy
//
//    Implementation of IInternetSecurityManager::QueryCustomPolicy
//
//  Synopsis:   Retrieves the custom policy associated with the URL and
//                specified key in the given context
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryCustomPolicy (
                        LPCWSTR     pwszUrl,
                        REFGUID     guidKey,
                        BYTE**  ppPolicy,   // pointer to output buffer pointer
                        DWORD*  pcbPolicy,  // pointer to output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwReserved )
 {
    return INET_E_DEFAULT_ACTION;
 }
                        
//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetZoneMappings
//
//    Implementation of IInternetSecurityManager::GetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetZoneMappings (
                    DWORD   dwZone,        // absolute zone index
                    IEnumString  **ppenumString,   // output buffer size
                    DWORD   dwFlags        // reserved, pass 0
)
{
    return INET_E_DEFAULT_ACTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\popframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       popframe.cxx
//
//  Contents:   Implementation of the frame for hosting html popup
//
//  History:    05-28-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

DeclareTag(tagHTMLPopupFrameMethods, "HTML Dialog Frame", "Methods on the html dialog frame")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLPopupFrame, CHTMLPopup, HTMLPopup, _Frame);


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::GetWindow(HWND * phWnd)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleWindow::GetWindow"));
    
    *phWnd = HTMLPopup()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::GetBorder(LPOLERECT prcBorder)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::GetBorder"));

#ifndef WIN16    
    HTMLPopup()->GetViewRect(prcBorder);
#else
    RECTL rcBorder;
    HTMLPopup()->GetViewRect(&rcBorder);
    CopyRect(prcBorder, &rcBorder);
#endif
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::RequestBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::SetBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::SetActiveObject"));
    
    ReplaceInterface(&HTMLPopup()->_pInPlaceActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::InsertMenus"));
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::SetMenu"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::RemoveMenus(HMENU hmenuShared)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::RemoveMenus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetStatusText(LPCTSTR szStatusText)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::SetStatusText"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::EnableModeless(BOOL fEnable)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::EnableModeless"));
    
    //  TODO: (anandra) should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::TranslateAccelerator"));
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\htmldlg\unixmodeless.cxx ===
//+------------------------------------------------------------------------
//
//  File:       unixmodeless.cxx
//
//  Contents:   unix function handling modeless dialog messages
//
//  History:
//
//-------------------------------------------------------------------------

#ifdef NO_MARSHALLING
#include <unixmodeless.hxx>

CUnixModeless g_Modeless;

extern "C"
HRESULT TranslateModelessAccelerator(MSG* pmsg, HWND hWnd)
{
    HWND hTarget = (hWnd ? hWnd : pmsg->hwnd);

    if (hTarget)
    {
        for (CHTMLDlg* pdlg = g_Modeless.GetFirstDlg(); pdlg; ) 
        {
            if (hTarget == pdlg->_hwnd || (hWnd ? 0 : IsChild(pdlg->_hwnd, hTarget)))
            {
                return pdlg->TranslateAccelerator(pmsg);
            } 
            pdlg = g_Modeless.GetNextDlg();
        }
    }
    return S_FALSE;  
}

CUnixModeless::CUnixModeless()
{
    m_iUsed = m_iSize = m_iCurrent = 0;
    m_pHead = NULL;
}

CUnixModeless::~CUnixModeless()
{
    if (m_pHead)
    {
        free(m_pHead);
    }
}

BOOL CUnixModeless::Append(CHTMLDlg* pdlg)
{
    if (m_iUsed==m_iSize)
    {
	    void* p=realloc((void*)m_pHead, sizeof(CHTMLDlg*) * (m_iSize+10));
        if(!p)
        {
            return FALSE;
        } 
	    m_pHead = (CHTMLDlg**)p;
        m_iSize += 10;
    }
    m_pHead[m_iUsed] = pdlg;
    m_iUsed++;
    return TRUE;
} 

BOOL CUnixModeless::Remove(CHTMLDlg* pdlg)
{
    for(int i=0; i<m_iUsed; i++)
    {
        if (pdlg == m_pHead[i])
        {
            for (int j=i; j<m_iUsed-1; j++) // Remove this HWND...
            {
                m_pHead[j] = m_pHead[j+1];
            }
            if (m_iCurrent && m_iCurrent == i)
            {
                m_iCurrent--; // So that GetNext can point to correct HWND
            }
            m_iUsed --;
            return TRUE;
        }
    }
    return FALSE;
}

CHTMLDlg* CUnixModeless::GetFirstDlg()
{
    m_iCurrent = 0;
    return (m_pHead ? m_pHead[0] : NULL);
}

CHTMLDlg* CUnixModeless::GetNextDlg()
{
    if (m_iCurrent + 1 < m_iUsed)
    {
        return m_pHead[ ++m_iCurrent ];
    }
    return NULL;
}            

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\empty.cxx ===
#include <headers.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\otherrc.h ===
To be removed

//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       otherrc.h
//
//  Contents:   Resource identifiers for Form project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//  See corerc.h for a complete listing of ranges used in Forms3.
//
//  05000 - 07999    Other miscellaneous
//
//----------------------------------------------------------------------------

#ifndef __OTHERRC_H__
#define __OTHERRC_H__

#define IDC_STATIC              -1      // all static controls, lifted from AFXRES.H


//----------------------------------------------------------------------------
//
// Strings (50xx)
//
//----------------------------------------------------------------------------

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011


//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDD_GENERICPAGE             5202
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210
#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\framet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       framet.h
//
//  Contents:   Frame Targeting function prototypes, definitions, etc.
//
//----------------------------------------------------------------------------


#ifndef __FRAMET_H__
#define __FRAMET_H__

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif

interface IBrowserBand;
class     CDwnBindInfo;

// PLEASE PROPOGATE ANY CHANGES TO THESE ENUMS TO \mshtml\iextag\httpwfh.h
enum TARGET_TYPE
{
    TARGET_FRAMENAME,  // Normal frame target
    TARGET_SELF,       // Current window
    TARGET_PARENT,     // Parent of the current window.
    TARGET_BLANK,      // New window
    TARGET_TOP,        // Top-level window
    TARGET_MAIN,       // Main window if in search band, self otherwise.
    TARGET_SEARCH,     // Open and navigate in search band.
    TARGET_MEDIA,      // Open and navigate in media band.
};

struct TARGETENTRY
{
    TARGET_TYPE eTargetType;
    LPCOLESTR   pszTargetName;
};

static const TARGETENTRY targetTable[] =
{
    { TARGET_SELF,     _T("_self")    },
    { TARGET_PARENT,   _T("_parent")  },
    { TARGET_TOP,      _T("_top")     },
    { TARGET_MAIN,     _T("_main")    },
    { TARGET_SEARCH,   _T("_search")  },
    { TARGET_BLANK,    _T("_blank")   },
    { TARGET_MEDIA,    _T("_media")   },
    { TARGET_SELF,     NULL           }
};

TARGET_TYPE GetTargetType(LPCOLESTR pszTargetName);

// Function Prototypes
HRESULT GetTargetWindow(IHTMLWindow2  * pWindow,
                        LPCOLESTR       pszTargetName,
                        BOOL          * pfIsCurProcess,
                        IHTMLWindow2 ** ppTargetWindow);
                        
HRESULT FindWindowInContext(IHTMLWindow2  * pWindow,
                            LPCOLESTR       pszTargetName,
                            IHTMLWindow2  * pWindowCtx,
                            IHTMLWindow2 ** ppTargetWindow);
                            
HRESULT SearchChildrenForWindow(IHTMLWindow2  * pWindow,
                                LPCOLESTR       pszTargetName,
                                IHTMLWindow2  * pWindowCtx,
                                IHTMLWindow2 ** ppTargetWindow);
                                
HRESULT SearchParentForWindow(IHTMLWindow2  * pWindow,
                              LPCOLESTR       pszTargetName,
                              IHTMLWindow2 ** ppTargetWindow);
                              
HRESULT SearchBrowsersForWindow(LPCOLESTR       pszTargetName,
                                IWebBrowser2  * pThisBrwsr,
                                IHTMLWindow2 ** ppTargetWindow);
                             
HRESULT OpenInNewWindow(const TCHAR    * pchUrl,
                        const TCHAR    * pchTarget,
                        CDwnBindInfo *    pDwnBindInfo,
                        IBindCtx       * pBindCtx,
                        COmWindowProxy * pWindow,
                        BOOL             fReplace,
                        IHTMLWindow2  ** ppHTMLWindow2);
                        
HRESULT GetWindowByType(TARGET_TYPE     eTargetType,
                        IHTMLWindow2  * pWindow,
	                    IHTMLWindow2 ** ppTargHTMLWindow,
                        IWebBrowser2 ** ppTopWebOC);

HRESULT GetMainWindow(IHTMLWindow2  * pWindow,
                      IHTMLWindow2 ** ppTargHTMLWindow,
                      IWebBrowser2 ** ppTopWebOC);

HRESULT NavigateInBand(IHTMLDocument2 * pDocument,
                       IHTMLWindow2   * pOpenerWindow,
                       REFCLSID         clsid,
                       LPCTSTR          pszOriginalUrl,
                       LPCTSTR          pszExpandedUrl,
                       IHTMLWindow2  ** ppBandWindow);
                        
HRESULT GetBandWindow(IBrowserBand  * pBrowserBand,
                      IHTMLWindow2 ** ppBandWindow);

HRESULT GetBandCmdTarget(IHTMLDocument2     * pDocument,
                         IOleCommandTarget ** ppCmdTarget);

HRESULT GetDefaultSearchUrl(IBrowserBand * pBrowserBand,
                            BSTR         * pbstrUrl);

#endif  // __FRAMET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\othrdisp.h ===
/**************************************************************************************


  (rgardner) This file is obsolete - please put all changes in COREDISP.H
  It will be delfile'd shortly in a cleanup pass
                                                

 **************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\othrguid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       othrguid.h
//
//  History:    06-Jun-96   anandra     Created
//
//  Contents:   extern references for site guids and manifest constants
//              for dispids
//
//----------------------------------------------------------------------------

//
// Reserve 10000 GUID entries beginning 3050f160-98b5-11cf-bb82-00aa00bdce0b
// and ending at 30c38c70-98b5-11cf-bb82-00aa00bdce0b.
//
// See the next available GUID in ...\src\guids.txt
// Check procedure for using next available GUID with F3 procedures handbook
//

#ifndef __OTHRGUID_H__
#define __OTHRGUID_H__

// Use PUBLIC_GUID for GUIDs used outside FORMS3.DLL.
// Use PRIVATE_GUID for all other GUIDS.

#ifndef PUBLIC_GUID
#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

#ifndef PRIVATE_GUID
#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif



// Property Pages
#ifndef NO_PROPERTY_PAGE
PRIVATE_GUID(CLSID_CBackgroundPropertyPage,     0x3050f232, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CCDGenericPropertyPage,      0x3050f17f, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CCDAnchorPropertyPage,       0x3050f1fc, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CInlineStylePropertyPage,    0x3050f296, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CAnchorBrowsePropertyPage,   0x3050f3BB, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CImageBrowsePropertyPage,    0x3050f3B3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CDocBrowsePropertyPage,      0x3050f3B4, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
#endif // NO_PROPERTY_PAGE
PRIVATE_GUID(SID_SHTMLProperyPageArg,           0x3050f404, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(CLSID_CDwnBindInfo,                0x3050f3c2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(  IID_IDwnBindInfo,                0x3050f3c3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(IID_IHistoryBindInfo,              0x3050f403, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PUBLIC_GUID(SID_GetCaller,                      0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9)
PUBLIC_GUID(CGID_ScriptSite,                    0x3050f3f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CGID_DownloadObjectBindContext,    0x3050f3df, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(SID_QIClientSite,                  0x3050f803, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PUBLIC_GUID(CLSID_JSProtocol,                   0x3050f3B2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_ResProtocol,                  0x3050f3bc, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_MailtoProtocol,               0x3050f3da, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_ViewSourceProtocol,           0x3050f400, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_AboutProtocol,                0x3050f406, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_SysimageProtocol,             0x76E67A63, 0x06E9, 0x11D2, 0xA8, 0x40, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82)

PRIVATE_GUID(CLSID_CHook,                       0x3050f500, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(CGID_JavaParambagCompatHack,       0x3050F405, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)

////////////////////////////////////////////////////////////////////////////////
//
// Scriptoid handlers:
//
////////////////////////////////////////////////////////////////////////////////

// {5AAF51B1-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CCSSFilterHandler,            0x5aaf51b1, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {5AAF51B2-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CPeerHandler,                 0x5aaf51b2, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {5AAF51B3-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CHiFiUses,                    0x5aaf51b3, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {3050f4f0-98b5-11cf-bb82-00aa00bdce0b}
PUBLIC_GUID(CLSID_CSvrOMUses,                   0x3050f4f0, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(IID_IScriptletHandler,             0xa001a870, 0xa7df, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletHandlerConstructor,  0xa3d52a50, 0xb7ff, 0x11d1, 0xa3, 0x5a, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(SID_ScriptletSite,                 0x22a98050, 0xa65d, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletError,               0xdf9f3d20, 0xa670, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletSite,                0xc5f21c30, 0xa7df, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)

PUBLIC_GUID(CLSID_HTADoc,		                0x3050f5c8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_HTMLPopupDoc,	                0x3050f67D, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// Service ID that handlers ask for on the scriptlet object to get at the
// internal IDispatchEx namespace.
PUBLIC_GUID(SID_ScriptletDispatch,              0x66289210, 0x6b18, 0x11d1, 0x8c, 0xac, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0)
PRIVATE_GUID(SID_SServerOM,                     0x3050f4f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// shdocvw guids
PRIVATE_GUID(SID_STopFrameBrowser, 0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0,  0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
PRIVATE_GUID(IID_IBrowserService,  0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0,  0xc0, 0x4f, 0xc9, 0xb3, 0x1f);
PRIVATE_GUID(IID_ITravelLogEx,     0x3050f679, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITravelLogClient, 0x3050f67a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITridentService,  0x3050f801, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITridentService2, 0xf62d9369, 0x75ef, 0x4578, 0x88, 0x56, 0x23, 0x28, 0x02, 0xc7, 0x64, 0x68);
PRIVATE_GUID(CLSID_SearchBand,     0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0,  0xc0, 0x4f, 0xd5, 0xae, 0x38);
PRIVATE_GUID(CLSID_MediaBand,      0x32683183, 0x48a0, 0x441b, 0xa3, 0x42, 0x7c, 0x2a, 0x44, 0x0a, 0x94, 0x78);
PRIVATE_GUID(SID_SProxyBrowser,    0x20C46561, 0x8491, 0x11CF, 0x96, 0x0C, 0x0,  0x80, 0xC7, 0xF4, 0xEE, 0x85);
PRIVATE_GUID(IID_IBrowserBand,     0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0,  0xc0, 0x4f, 0x8e, 0xea, 0x99);
PRIVATE_GUID(SID_SExplorerToolbar, 0x8455f0c1, 0x158f, 0x11d0, 0x89, 0xae, 0x0,  0xa0, 0xc9, 0x0a, 0x90, 0xac);
PRIVATE_GUID(IID_ISearchItems,     0x830abff0, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x0,  0xa0, 0xc9, 0x8b, 0xc5, 0x47);
PRIVATE_GUID(CGID_DocHostCmdPriv,  0x000214D4, 0x0000, 0x0000, 0xc0, 0x00, 0x0,  0x00, 0x00, 0x00, 0x00, 0x46);
PRIVATE_GUID(IID_IWebBrowserPriv,  0x3050f804, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);

PRIVATE_GUID(IID_IInitViewLinkedWebOC,0xe787f2c0,0x3d21,0x4d98,0x85,0xc8,0xa0,0x38,0x19,0x5b,0xa6,0x49);

//ATL 
DEFINE_GUID(IID_IAxWinHostWindow,  0xb6ea2050, 0x48a,  0x11d1, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0xb9, 0x94, 0x2e);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\browsersvc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : browsersvc.cxx
//
//  Contents: IBrowserService interface implementation.
//
//  Author  : Scott Roberts (scotrobe)  01/18/2000
//
//----------------------------------------------------------------------------

#include "headers.hxx"

// Prototypes
//
HRESULT PidlFromUrl(LPCTSTR pszUrl, LPITEMIDLIST * ppidl);
UINT    GetUrlScheme(const TCHAR * pchUrlIn);
HRESULT IEParseDisplayNameWithBCW(UINT uiCP,      LPCWSTR pwszPath,
                                  IBindCtx * pbc, LPITEMIDLIST * ppidlOut);
#ifndef DLOAD1
LPITEMIDLIST SHSimpleIDListFromPathPriv(LPCTSTR pszPath);
#endif

DeclareTag(tagIBrowserService, "IBrowserService implementation", "Trace WebOC Events")

#define NOTIMPL_METHOD(base, fn, FN, args) \
    HRESULT base::fn args \
    { \
        AssertSz(0, FN " should not have been called."); \
        return E_NOTIMPL; \
    }
    
// NOTIMPL_METHOD_NUM works with returns values
// that accept a number - int, long, DWORD, etc.
//
#define NOTIMPL_METHOD_NUM(base, fn, FN, ret, args) \
    ret base::fn args \
    { \
        AssertSz(0, FN " should not have been called."); \
        return 0; \
    }

// Tearoff Table Declaration
//
BEGIN_TEAROFF_TABLE(CDocument, IBrowserService)
    TEAROFF_METHOD(CDocument, GetParentSite, getparentsite, (IOleInPlaceSite** ppipsite))
    TEAROFF_METHOD(CDocument, SetTitle, settitle, (IShellView* psv, LPCWSTR pszName))
    TEAROFF_METHOD(CDocument, GetTitle, gettitle, (IShellView* psv, LPWSTR pszName, DWORD cchName))
    TEAROFF_METHOD(CDocument, GetOleObject, getoleobject, (IOleObject** ppobjv))
    TEAROFF_METHOD(CDocument, GetTravelLog, gettravellog, (ITravelLog** pptl))
    TEAROFF_METHOD(CDocument, ShowControlWindow, showcontrolwindow, (UINT id, BOOL fShow))
    TEAROFF_METHOD(CDocument, IsControlWindowShown, iscontrolwindowshown, (UINT id, BOOL *pfShown))
    TEAROFF_METHOD(CDocument, IEGetDisplayName, iegetdisplayname, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags))
    TEAROFF_METHOD(CDocument, IEParseDisplayName, ieparsedisplayname, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut))
    TEAROFF_METHOD(CDocument, DisplayParseError, displayparseerror, (HRESULT hres, LPCWSTR pwszPath))
    TEAROFF_METHOD(CDocument, NavigateToPidl, navigatetopidl, (LPCITEMIDLIST pidl, DWORD grfHLNF))
    TEAROFF_METHOD(CDocument, SetNavigateState, setnavigatestate, (BNSTATE bnstate))
    TEAROFF_METHOD(CDocument, GetNavigateState, getnavigatestate, (BNSTATE * pbnstate))
    TEAROFF_METHOD(CDocument, NotifyRedirect, notifyredirect, (IShellView* psv, LPCITEMIDLIST pidl, BOOL * pfDidBrowse))
    TEAROFF_METHOD(CDocument, UpdateWindowList, updatewindowlist, ())
    TEAROFF_METHOD(CDocument, UpdateBackForwardState, updatebackforwardstate, ())
    TEAROFF_METHOD(CDocument, SetFlags, setflags, (DWORD dwFlags, DWORD dwFlagMask))
    TEAROFF_METHOD(CDocument, GetFlags, getflags, (DWORD *pdwFlags))
    TEAROFF_METHOD(CDocument, CanNavigateNow, cannavigatenow, ())

    TEAROFF_METHOD(CDocument, GetPidl, getpidl, (LPITEMIDLIST *ppidl))

    TEAROFF_METHOD(CDocument, SetReferrer, setreferrer, (LPITEMIDLIST pidl))
    TEAROFF_METHOD_(CDocument, GetBrowserIndex, getbrowserindex, DWORD, ())
    TEAROFF_METHOD(CDocument, GetBrowserByIndex, getbrowserbyindex, (DWORD dwID, IUnknown **ppunk))
    TEAROFF_METHOD(CDocument, GetHistoryObject, gethistoryobject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc))
    TEAROFF_METHOD(CDocument, SetHistoryObject, sethistoryobject, (IOleObject *pole, BOOL fIsLocalAnchor))
    TEAROFF_METHOD(CDocument, CacheOLEServer, cacheoleserver, (IOleObject *pole))
    TEAROFF_METHOD(CDocument, GetSetCodePage, getsetcodepage, (VARIANT* pvarIn, VARIANT* pvarOut))
    TEAROFF_METHOD(CDocument, OnHttpEquiv, onhttpequiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut))
    TEAROFF_METHOD(CDocument, GetPalette, getpalette, (HPALETTE * hpal ))
    TEAROFF_METHOD(CDocument, RegisterWindow, registerwindow, (BOOL fUnregister, int swc))
END_TEAROFF_TABLE()

NOTIMPL_METHOD(CDocument, GetParentSite, "GetParentSite", (IOleInPlaceSite** ppipsite)) 
NOTIMPL_METHOD(CDocument, SetTitle, "SetTitle", (IShellView* psv, LPCWSTR pszName))
NOTIMPL_METHOD(CDocument, GetTitle, "GetTitle", (IShellView* psv, LPWSTR pszName, DWORD cchName))
NOTIMPL_METHOD(CDocument, GetOleObject, "GetOleObject", (IOleObject** ppobjv))
NOTIMPL_METHOD(CDocument, GetTravelLog, "GetTravelLog", (ITravelLog** pptl))
NOTIMPL_METHOD(CDocument, ShowControlWindow, "ShowControlWindow", (UINT id, BOOL fShow))
NOTIMPL_METHOD(CDocument, IsControlWindowShown, "IsControlWindowShown", (UINT id, BOOL *pfShown))
NOTIMPL_METHOD(CDocument, IEGetDisplayName, "IEGetDisplayName", (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags))
NOTIMPL_METHOD(CDocument, IEParseDisplayName, "IEParseDisplayName", (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut))
NOTIMPL_METHOD(CDocument, DisplayParseError, "DisplayParseError", (HRESULT hres, LPCWSTR pwszPath))
NOTIMPL_METHOD(CDocument, NavigateToPidl, "NavigateToPidl", (LPCITEMIDLIST pidl, DWORD grfHLNF))
NOTIMPL_METHOD(CDocument, SetNavigateState, "SetNavigateState", (BNSTATE bnstate))
NOTIMPL_METHOD(CDocument, GetNavigateState, "GetNavigateState", (BNSTATE * pbnstate))
NOTIMPL_METHOD(CDocument, NotifyRedirect, "NotifyRedirect", (IShellView * psv, LPCITEMIDLIST pidl, BOOL * pfDidBrowse))
NOTIMPL_METHOD(CDocument, UpdateWindowList, "UpdateWindowList", ())
NOTIMPL_METHOD(CDocument, UpdateBackForwardState, "UpdateBackForwardState", ())
NOTIMPL_METHOD(CDocument, SetFlags, "SetFlags", (DWORD dwFlags, DWORD dwFlagMask))
NOTIMPL_METHOD(CDocument, GetFlags, "GetFlags", (DWORD * pdwFlags))
NOTIMPL_METHOD(CDocument, CanNavigateNow, "CanNavigateNow", ())
NOTIMPL_METHOD(CDocument, SetReferrer, "SetReferrer", (LPITEMIDLIST pidl))
NOTIMPL_METHOD_NUM(CDocument, GetBrowserIndex, "GetBrowserIndex", DWORD, ())
NOTIMPL_METHOD(CDocument, GetBrowserByIndex, "GetBrowserByIndex", (DWORD dwID, IUnknown **ppunk))
NOTIMPL_METHOD(CDocument, GetHistoryObject, "GetHistoryObject", (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc))
NOTIMPL_METHOD(CDocument, SetHistoryObject, "SetHistoryObject", (IOleObject *pole, BOOL fIsLocalAnchor))
NOTIMPL_METHOD(CDocument, CacheOLEServer, "CacheOLEServer", (IOleObject *pole))
NOTIMPL_METHOD(CDocument, GetSetCodePage, "GetSetCodePage", (VARIANT* pvarIn, VARIANT* pvarOut))
NOTIMPL_METHOD(CDocument, OnHttpEquiv, "OnHttpEquiv", (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut))
NOTIMPL_METHOD(CDocument, GetPalette, "GetPalette", (HPALETTE * hpal ))
NOTIMPL_METHOD(CDocument, RegisterWindow, "RegisterWindow", (BOOL fUnregister, int swc))

//+-------------------------------------------------------------------------
//
//  Method   : GetPidl
//
//  Synopsis : Returns the current URL in ITEMIDLIST (pidl) format.
//
//  Output   : ppidl - the pidl that contains the current URL.
//
//--------------------------------------------------------------------------

HRESULT
CDocument::GetPidl(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    BSTR    bstrUrl;

    if (!ppidl)
        return E_POINTER;

    hr = get_URLUnencoded(&bstrUrl);
    if (hr)
        goto Cleanup;

    hr = PidlFromUrl(bstrUrl, ppidl);

Cleanup:
    SysFreeString(bstrUrl);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : PidlFromUrl
//
//  Synopsis : Converts an URL to a PIDL. This method handles the case
//             where IEParseDisplayNameWithBCW fails because it can't 
//             handle URLs with fragment identifiers (#, ?, etc.)
//
//  Input    : cstrUrl - the URL to convert to a PIDL.
//  Output   : ppdil   - the pidl.
//
//--------------------------------------------------------------------------

HRESULT
PidlFromUrl(LPCTSTR pszUrl, LPITEMIDLIST * ppidl)
{
    HRESULT hr = IEParseDisplayNameWithBCW(CP_ACP, pszUrl, NULL, ppidl);
    if (hr)
        goto Cleanup;

    // IEParseDisplayNameWithBCW will return a null pidl if 
    // the URL has any kind of fragment identifier at the
    // end - #, ? =, etc.
    //    
    if (!*ppidl) 
    {
        TCHAR szPath[INTERNET_MAX_URL_LENGTH];
        DWORD cchBuf = ARRAY_SIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        // Otherwise, if it's not a file URL or if it is
        // and the conversion fails, just copy the given URL
        // to szPath so it can be easily converted to a Pidl.
        //
        if ( (GetUrlScheme(pszUrl) != URL_SCHEME_FILE)
          || SUCCEEDED(PathCreateFromUrl(pszUrl, szPath, &cchBuf, 0)))
        {
            StrCpyN(szPath, pszUrl, ARRAY_SIZE(szPath));
        }

#ifndef DLOAD1
        *ppidl = SHSimpleIDListFromPathPriv(szPath);
#else
        *ppidl = SHSimpleIDListFromPath(szPath);
#endif
        if (!*ppidl)
            hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\framet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       framet.cxx
//
//  Contents:   Frame Targeting Support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

LONG   g_lNoNameWindowCounter;

#define SID_SOmWindow IID_IHTMLWindow2

DeclareTag(tagFrameT, "FrameT", "Frame targeting methods")

//+--------------------------------------------------------------------------------------
//
//  Function  : GetTargetWindow
//  
//  Synopsis  : This method calls FindWindowInContext() to search the current process
//              for the specified target window. If the target window cannot be found
//              in the current process, SearchHostsForWindow() is called to search
//              other processes for the target window.
//
//  Input     : pWindow            - the window to search.
//              pszTargetName      - the name of the window to locate.
//  Ouput     : pfIsCurProcess     - TRUE if the window was found in the current process.
//              ppTargetWindow     - the IHTMLWindow2 of the found window or
//                                   NULL if the window is not found.//
//  Returns   : S_OK if found, OLE error code otherwise.
//---------------------------------------------------------------------------------------

HRESULT
GetTargetWindow(IHTMLWindow2  * pWindow,
                LPCOLESTR       pszTargetName, 
                BOOL          * pfIsCurProcess,
                IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT hr;
    IHTMLDocument2   * pDocument   = NULL;
    IServiceProvider * pSvcPrvdr   = NULL;
    IWebBrowser2     * pWebBrowser = NULL;
    
    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(pfIsCurProcess);
    Assert(ppTargetWindow);

    *ppTargetWindow = NULL;
    *pfIsCurProcess = FALSE;

    hr = FindWindowInContext(pWindow, pszTargetName, pWindow, ppTargetWindow);

    if (!hr)
    {
        *pfIsCurProcess = TRUE;
    }
    else  // Not found
    {
        Assert(!*ppTargetWindow);
       
        *pfIsCurProcess = FALSE;
        
        // Get the WebOC of the parent.
        //
        IGNORE_HR(GetParentWebOC(pWindow, &pWebBrowser));
        
        // pWebBrowser can be NULL
        //
        hr = SearchBrowsersForWindow(pszTargetName, pWebBrowser, ppTargetWindow);
    }
    
    ReleaseInterface(pDocument);
    ReleaseInterface(pSvcPrvdr);
    ReleaseInterface(pWebBrowser);

    TraceTag((tagFrameT, "FrameT: GetTargetWindow returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------------------------------
//
//  Function  : FindWindowInContext
//  
//  Synopsis  : This method searches the current process for the specified target
//              window. It first calls SearchChildrenForWindow() to search all
//              children of the current window for the target window name.
//              (SearchChildrenForWindow() checks the given window first before
//              searching the children.) If the target window name is not found in 
//              the current window or its children, SearchParentForWindow() is 
//              called to search the parent window and all of its children 
//              for the target window. SearchParentForWindow() recursively calls
//              this function in order to search all children and parent windows
//              until all windows in this process have been searched or the
//              window has been found.
//              The context window is used to indicate a window (and its children)
//              that has already been searched. SearchChildrenForWindow() will not
//              search a child window whose window matches the context window.
//
//  Input     : pWindow        - the window to search.
//              pszTargetName  - the name of the window to locate.
//              pWindowCtx     - context window. This is the IHTMLWindow2 of a 
//                               window that has already been searched (including its
//                               children).
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//---------------------------------------------------------------------------------------

HRESULT
FindWindowInContext(IHTMLWindow2  * pWindow,
                    LPCOLESTR       pszTargetName,
                    IHTMLWindow2  * pWindowCtx,
                    IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT hr;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);

    hr = SearchChildrenForWindow(pWindow, pszTargetName, pWindowCtx, ppTargetWindow);

    // Don't search the parent if we found the window.
    //
    if (hr)
    {
        hr = SearchParentForWindow(pWindow, pszTargetName, ppTargetWindow);
    }
    
    TraceTag((tagFrameT, "FrameT: FindWindowInContext returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function  : SearchChildrenForWindow
//
//  Synopsis  : Returns the window with the given name. This method first
//              checks to see if the name of the given window matches
//              pszTargetName. If it does not, it performs a depth-first
//              search of all the children of the given window for the given
//              target window name. (See FindWindowInContext for more info
//              about the context window.)
//
//  Input     : pWindow        - the window whose children should be searched.
//              pszTargetName  - the name of the window to locate.
//              pWindowCtx     - context window. This is the IHTMLWindow2 of a 
//                               window that has already been searched (including its
//                               children).
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//-----------------------------------------------------------------------------

HRESULT
SearchChildrenForWindow(IHTMLWindow2  * pWindow,
                        LPCOLESTR       pszTargetName,
                        IHTMLWindow2  * pWindowCtx,
                        IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT        hr = E_FAIL;
    HRESULT        hr2;
    long           cFrames;
    long           nItem;
    BSTR           bstrName = NULL;
    VARIANT        varItem;
    VARIANT        varFrame;
    IHTMLWindow2 * pFrameWindow = NULL;
    IHTMLFramesCollection2 * pFrames = NULL;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);

    VariantInit( &varItem );
    VariantInit( &varFrame );
    
    hr2 = pWindow->get_name(&bstrName);

    // Note that get_name returns the name
    // even though access is denied. E_ACCESSDENIED
    // is returned in the case of cross-browser targeting.
    //
    if (hr2 && hr2 != E_ACCESSDENIED)
    {
        goto Cleanup;
    }
        
    if (pszTargetName && bstrName && !StrCmpW(pszTargetName, bstrName))
    {
        *ppTargetWindow = pWindow;
        (*ppTargetWindow)->AddRef();

        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        // Do not set hr to the return value of any method except
        // SearchChildrenForWindow. The return value from this method
        // must only reflect whether or not the window was found.
        //
        if (pWindow->get_frames(&pFrames))
        {
            goto Cleanup;
        }
            
        if (pFrames->get_length(&cFrames))
        {
            goto Cleanup;
        }

        V_VT(&varItem) = VT_I4;
        
        // Depth-first search of children via frames collection
        //
        for (nItem = 0; nItem < cFrames; nItem++)
        {
            V_I4(&varItem) = nItem;
                
            if (pFrames->item(&varItem, &varFrame))
            {
               goto LoopCleanup; // Error retrieving item at index nItem.
            }

            if (VT_DISPATCH == V_VT(&varFrame) && V_DISPATCH(&varFrame))
            {
                if (V_DISPATCH(&varFrame)->QueryInterface(IID_IHTMLWindow2,
                                                          (void**) &pFrameWindow))
                {
                    goto LoopCleanup;
                }

                {
                    COmWindowProxy * pOmWindowProxy;

                    if (    S_OK == pFrameWindow->QueryInterface(CLSID_HTMLWindowProxy, (void **) &pOmWindowProxy)
                        &&  pOmWindowProxy->_pCWindow)
                    {
                        pOmWindowProxy->_pCWindow->AddRef();
                        pFrameWindow->Release();
                        pFrameWindow = pOmWindowProxy->_pCWindow;
                    }
                }

                if (!IsSameObject(pWindowCtx, pFrameWindow))
                {
                    hr = SearchChildrenForWindow(pFrameWindow,
                                                 pszTargetName,
                                                 NULL,
                                                 ppTargetWindow);
                }

LoopCleanup:
                VariantClear(&varFrame);
                ClearInterface(&pFrameWindow);
                
                // Found it!!
                if (S_OK == hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    VariantClear(&varItem);
    SysFreeString(bstrName);    
    ReleaseInterface(pFrames);
    
    TraceTag((tagFrameT, "FrameT: SearchChildrenForWindow returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function  : SearchParentForWindow
//
//  Synopsis  : Searches the parent window (and its children) of the given 
//              window for the window with the specified target window name.
//
//  Input     : pWindow        - the window whose parent should be searched.
//              pszTargetName  - the name of the window to locate.
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//-----------------------------------------------------------------------------

HRESULT
SearchParentForWindow(IHTMLWindow2  * pWindow,
                      LPCOLESTR       pszTargetName,
                      IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT        hr = E_FAIL;
    IHTMLWindow2 * pWindowParent = NULL;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);
    
    if (pWindow->get_parent(&pWindowParent))
    {
        goto Cleanup;
    }

    // The parent of the top window is the window itself - check identity
    //
    if (!IsSameObject(pWindow, pWindowParent))
    {
        // Call FindWindowInContext on the parent window 
        // passing in this window as the context.
        //
        hr = FindWindowInContext(pWindowParent,
                                 pszTargetName,
                                 pWindow,
                                 ppTargetWindow);
    }
        
Cleanup:
    ReleaseInterface(pWindowParent);
    
    TraceTag((tagFrameT, "FrameT: SearchParentForWindow returning 0x%X", hr));
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function  : SearchBrowsersForWindow
//
//  Synopsis  : Searches all browser windows (that are registered with 
//              ShellWindows) for the given target name. 
//              This method uses the ShellWindows enumeration to locate 
//              registered shell windows. When a shell window is found,
//              the IWebBrowser2 interface ptr of the shell window is
//              retrieved. If the shell window implements IWebBrowser2,
//              the IHTMLWindow2 pointer of the top-level window object is 
//              retrieved and then FindWindowInContext is called to search
//              all child windows for the target window name. This process 
//              is performed for all registered shell windows on the system.
//
//  Input     : pszTargetName  - the name of the window to locate.
//              pThisBrwsr     - the IWebBrowser2 of the the current browser.
//  Output    : ppTargetWindow - the IHTMLWindow2  of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
SearchBrowsersForWindow(LPCOLESTR       pszTargetName,
                        IWebBrowser2  * pThisBrwsr,
                        IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT         hr;
    VARIANT         VarResult;
    BOOL            fDone = FALSE;
    IShellWindows * pShellWindows = NULL;
    IUnknown      * pUnkEnum      = NULL;
    IEnumVARIANT  * pEnumVariant  = NULL;
    IWebBrowser2  * pWebBrowser   = NULL;
    IHTMLWindow2  * pTargWindow   = NULL;
    
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);
    
    hr = CoCreateInstance(CLSID_ShellWindows,
                          NULL,
                          CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                          IID_IShellWindows,
                          (void**)&pShellWindows);
    if (hr)
        goto Cleanup;

    hr = pShellWindows->_NewEnum(&pUnkEnum);
    if (hr)
        goto Cleanup;

    hr = pUnkEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pEnumVariant);
    
    if (hr)
        goto Cleanup;

    VariantInit(&VarResult);
    
    // Search all ShellWindows for the target window.
    //
    while (!fDone && S_OK == hr)
    {
        hr = pEnumVariant->Next(1, &VarResult, NULL);
        if (hr)
            goto LoopCleanup;
            
        if (VT_DISPATCH == V_VT(&VarResult) && V_DISPATCH(&VarResult))
        {
            // Get the IWebBrowser2 of the browser so that we
            // can find the top level window object. This QI
            // will fail if we aren't in the browser (e.g., HTA).
            //
            if (V_DISPATCH(&VarResult)->QueryInterface(IID_IWebBrowser2,
                                                       (void**)&pWebBrowser))
            {
                goto LoopCleanup;
            }
            
            // We don't want to search any shell windows more than once.
            //
            if (!IsSameObject(pWebBrowser, pThisBrwsr))
            {
                // Get the top window object of the host.
                //
                if (S_OK == GetWebOCWindow(pWebBrowser, TRUE, &pTargWindow))
                {
                    // Search the top window and its children for the target window.
                    //
                    if (S_OK == FindWindowInContext(pTargWindow,
                                             pszTargetName,
                                             pTargWindow,
                                             ppTargetWindow))
                    // Found it!!
                    {
                        fDone = TRUE;
                    }
                }
            }
        }

LoopCleanup:
        ClearInterface(&pWebBrowser);
        ClearInterface(&pTargWindow);
        VariantClear(&VarResult);
        
    }  // while
                    
Cleanup:
    ReleaseInterface(pUnkEnum);
    ReleaseInterface(pEnumVariant);
    ReleaseInterface(pShellWindows);

    // Do not release pTargWindow. It's not AddRef'ed

    TraceTag((tagFrameT, "FrameT: SearchBrowsersForWindow returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : GenerateUniqueWindowName
//
//  Synopsis  : Creates a unique window name.  
//
//--------------------------------------------------------------------------

HRESULT
GenerateUniqueWindowName(TCHAR ** ppchUniqueWindowName)
{
    InterlockedIncrement(&g_lNoNameWindowCounter);

    // Choose a name the user isn't likely to type.
    RRETURN(Format(FMT_OUT_ALLOC, ppchUniqueWindowName, 0, _T("_No__Name:<0d>"), g_lNoNameWindowCounter));
}


//+--------------------------------------------------------------------------------------
//
//  Method    : ShellExecURL
//
//  Synopsis  : Opens the specified URL in a new *default browser* window.
//              **This code has been copied from \nt\shell\shdocvw\iedisp.cpp
//              **Refer to the HLinkFrameNavigateNHL() function for more info.
//              We' are punting the FILE: case for IE 4 unless the extension
//              is .htm or .html (all that Netscape 3.0 registers for) we'll go 
//              with ShellExecute if IE is not the default browser.  
//              NOTE: this means POST will not be supported and pszTargetFrame will be 
//              ignored we don't shellexecute FILE: url's because URL.DLL doesn't give 
//              a security warning for .exe's etc.
//
//----------------------------------------------------------------------------------------

HRESULT ShellExecURL(const TCHAR    * pchUrl)
{
    HINSTANCE   hinstRet;
    TCHAR     * pszExt = NULL;
    BOOL        bSafeToExec = TRUE;
    
    //Initialize to E_FAIL, will be set to S_OK only if we ShellExecute successfully
    HRESULT     hr = E_FAIL;

    if (URL_SCHEME_FILE == GetUrlScheme(pchUrl))
    {
        TCHAR szContentType[MAX_PATH] = _T("");
        DWORD dwSize = MAX_PATH;

        bSafeToExec = FALSE;
        // Get Content type.
        pszExt = PathFindExtension(pchUrl);
        HRESULT hLocal;

        hLocal = AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExt, NULL, szContentType, &dwSize);
        if (SUCCEEDED(hLocal))
        {
            bSafeToExec = ( 0 == _tcsicmp(szContentType, _T("text/html")) );
        }
    }

    if (bSafeToExec)
    {
        hinstRet = ShellExecute(NULL, NULL, pchUrl, NULL, NULL, SW_SHOWNORMAL);
        hr = ((UINT_PTR)hinstRet) <= 32 ? E_FAIL:S_OK;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method    : OpenInNewWindow
//
//  Synopsis  : Opens the specified URL in a new browser window..  
//
//--------------------------------------------------------------------------

BOOL IsIEDefaultBrowser();

HRESULT
OpenInNewWindow(const TCHAR    * pchUrl,
                const TCHAR    * pchTarget,
                CDwnBindInfo   * pDwnBindInfo,
                IBindCtx       * pBindCtx,
                COmWindowProxy * pWindow,
                BOOL             fReplace,
                IHTMLWindow2  ** ppHTMLWindow2)
{
    Assert(pchUrl);
    Assert(pBindCtx);

    HRESULT hr;

    TCHAR             * pchUniqueWindowName = NULL;
    ITargetNotify2    * pNotify = NULL;
    ITargetFramePriv  * pTargFrmPriv = NULL;
    CWindow           * pCWindow  =  NULL;
    IWebBrowser2      * pTopWebOC =  NULL;

    if (!pWindow || !pWindow->Window() || !pWindow->Window()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        pCWindow  = pWindow->Window();
        pTopWebOC = pCWindow->Doc()->_pTopWebOC;
    }

    if (ppHTMLWindow2)
        *ppHTMLWindow2 = NULL;

    // If we don't have a window name, then we can pass in a generic name to make 
    // it possible for shdocvw to track this window later. However, we don't have
    // to search for an existing window, if the name is empty or "_blank"

    if (!pchTarget || !*pchTarget || (*pchTarget && !StrCmpW(pchTarget, _T("_blank"))))
    {
        // If the name passed was "_blank", then free the bstr we received and reuse it 
        // for the unique name we will get from shdocvw.
        hr = THR(GenerateUniqueWindowName(&pchUniqueWindowName));
        if (hr)
            goto Cleanup;
    }

    Assert(pCWindow);

    if (pTopWebOC)
    {
        hr = pTopWebOC->QueryInterface(IID_ITargetFramePriv, (void**)&pTargFrmPriv);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // We come thru here only for direct Trident hosts and if the host did not
        // implement the IHLinkFrame interface. We need to launch the default browser
        // for all cases except window.open since we need to set the opener property for
        // the window.open case.

        // If we are not in a window.open call, call ShellExecute so that we launch the default browser
        // If we determine it's not safe to launch the url, we will create IE by default 
        // (behavior since IE 4)
        if (!(pCWindow->_fOpenInProgress) && !(pCWindow->Doc()->_fInHTMLDlg || pCWindow->Doc()->IsHostedInHTA()) && !IsIEDefaultBrowser())
        {
            hr = THR(ShellExecURL(pchUrl));
            return hr;
        }

        // If this is a window.open call, will fall thru to this
        // to create a new IE window
#ifdef NO_MARSHALLING
        hr = THR(CoCreateInternetExplorer(IID_ITargetFramePriv,
                                          CLSCTX_LOCAL_SERVER,
                                          (void**)&pTargFrmPriv));
#else  // NO_MARSHALLING
        hr = THR(CoCreateInstance(CLSID_InternetExplorer,
                                  NULL,
                                  CLSCTX_LOCAL_SERVER,
                                  IID_ITargetFramePriv,
                                  (void**)&pTargFrmPriv));        
#endif  
        if (hr)
            goto Cleanup;
    }

    pTopWebOC = NULL;  // This ptr should not be released.

    // Register the notification handler on an ITargetNotify2. It does not matter
    // which window's implementation, since the ITargetNotify2::OnCreate only works 
    // with parameters

    hr = THR(pCWindow->QueryInterface(IID_ITargetNotify2, (void**)&pNotify));
    if (hr)
        goto Cleanup;

    hr = THR(pBindCtx->RegisterObjectParam(TARGET_NOTIFY_OBJECT_NAME, pNotify));
    Assert(SUCCEEDED(hr));

    // Do stuff with the URL...
    const TCHAR * pszFindLoc;

    // Separate the base URL from the location (hash)
    pszFindLoc = StrChrW(pchUrl, '#');

    if (pszFindLoc)
    {
        const TCHAR * pszTemp = StrChrW(pszFindLoc, '/');
        if (!pszTemp)
            pszTemp = StrChrW(pszFindLoc, '\\');

        // no delimiters past this # marker... we've found a location.
        // break out
        if (pszTemp)
            pszFindLoc = NULL;
    }

    TCHAR szBaseURL[pdlUrlLen+1];
    TCHAR szLocation[pdlUrlLen+1];

    if (pszFindLoc)
    {
        // StrCpyNW alway null terminates to we need to copy len+1
        StrCpyNW(szBaseURL, pchUrl, (int) (pszFindLoc - pchUrl + 1));
        StrCpyNW(szLocation, pszFindLoc, pdlUrlLen);
    }
    else
    {
        StrCpyNW(szBaseURL, pchUrl, pdlUrlLen);
        szLocation[0] = 0;
    }

    hr = pTargFrmPriv->NavigateHack(HLNF_OPENINNEWWINDOW | (fReplace ? HLNF_CREATENOHISTORY : 0),
                                    pBindCtx,
                                    pDwnBindInfo,
                                    pchUniqueWindowName ? pchUniqueWindowName : pchTarget,
                                    szBaseURL,
                                    pszFindLoc ? szLocation : NULL);
    if (hr)
        goto Cleanup;

    if (pCWindow->_pOpenedWindow)
    {
        DISPPARAMS dispparams = g_Zero.dispparams;
        CVariant   cvarWindow;

        //
        // this window might not implement IHTMLWindow2, thus we ignore the HR
        //

        hr = pCWindow->_pOpenedWindow->Invoke(DISPID_WINDOWOBJECT,
                                              IID_NULL,
                                              0,
                                              DISPATCH_PROPERTYGET,
                                              &dispparams,
                                              &cvarWindow,
                                              NULL,
                                              NULL);

        if (hr)
        {
            //hacking around for the non webview folder view case
            V_DISPATCH(&cvarWindow) = pCWindow->_pOpenedWindow;
            V_VT(&cvarWindow) = VT_DISPATCH;
            
            // protect against the auto release of the variant variable.
            pCWindow->_pOpenedWindow->AddRef();

            hr = S_OK;
        }

        if (ppHTMLWindow2)
        {

            IGNORE_HR((V_DISPATCH(&cvarWindow))->QueryInterface(IID_IHTMLWindow2, (void**)ppHTMLWindow2));
        }
    }

Cleanup:
    // take the information off of the bind context, since the bind context
    // will be released by the callers of this function
    pBindCtx->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);
    pBindCtx->RevokeObjectParam(SZ_DWNBINDINFO_OBJECTPARAM);

    // Clean the buffer variable _pOpenedWindow for following uses.
    // No need to clean the callback flag, since it gets reset on each call.
    
    if (pCWindow)
    {
        ClearInterface(&pCWindow->_pOpenedWindow);
    }

    ReleaseInterface(pTargFrmPriv);
    ReleaseInterface(pNotify);

    if(pchUniqueWindowName)
    {
        MemFreeString(pchUniqueWindowName);
    }

    TraceTag((tagFrameT, "FrameT: OpenInNewWindow returning 0x%X", hr));
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method    : GetWindowByType
//
//  Synopsis  : Returns the window for the given target type.  
//
//  Input     : eTargetType      - the type of window to retrieve.
//              pWindow          - the window to use to find the target.
//  Output    : ppTargHTMLWindow - the IHTMLWindow2 of the target window.
//              ppTopWebOC       - the WebOC of the top-level browser. This
//                                 is set if there is a failure retrieving
//                                 the main window.
//
//  Returns   : S_OK    - window found.
//              S_FALSE - open new browser window.
//              OLE error code - error or window not found.
//
//--------------------------------------------------------------------------

HRESULT
GetWindowByType(TARGET_TYPE     eTargetType,
                IHTMLWindow2  * pWindow,
                IHTMLWindow2 ** ppTargHTMLWindow,
                IWebBrowser2 ** ppTopWebOC)
{
    HRESULT hr = S_OK;
    
    Assert(pWindow);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;
    
    switch(eTargetType)
    {
        case TARGET_SELF:
            hr = pWindow->get_self(ppTargHTMLWindow);
            break;
            
        case TARGET_PARENT:
            hr = pWindow->get_parent(ppTargHTMLWindow);
            break;
            
        case TARGET_TOP:
            hr = pWindow->get_top(ppTargHTMLWindow);
            break;
        case TARGET_MAIN:
            hr = GetMainWindow(pWindow, ppTargHTMLWindow, ppTopWebOC);
            break;

        // TARGET_BLANK is the same as open in new window.
        // Therefore, return S_FALSE to cause a new browser
        // window to be opened.
        //
        case TARGET_BLANK:
            hr = S_FALSE;
            break;
            
        case TARGET_SEARCH:  // Handled in FollowHyperlink
        case TARGET_MEDIA:   // Handled in FollowHyperlink
        default:
            hr = E_FAIL;
            break;
    }

    TraceTag((tagFrameT, "FrameT: GetWindowByType returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : GetMainWindow
//
//  Synopsis  : Returns the IHTMLWindow2 of the main browser window.  
//
//  Input     : pWindow          - the window to use to find the target.
//  Output    : ppTargHTMLWindow - the IHTMLWindow2 of the target window.
//              ppTopWebOC       - the WebOC of the top-level browser. This
//                                 is set if there is a failure retrieving
//                                 the main window.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
GetMainWindow(IHTMLWindow2  * pWindow,
              IHTMLWindow2 ** ppTargHTMLWindow,
              IWebBrowser2 ** ppTopWebOC)
{
    HRESULT hr;
    IHTMLDocument2   * pDocument   = NULL;
    IWebBrowser2     * pWebBrowser = NULL;
    IShellBrowser    * pShlBrowser = NULL;

    Assert(pWindow);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;
    
    hr = pWindow->get_document(&pDocument);
    if (hr)
        goto Cleanup;
        
    // Check to see if we are in a band object
    //
    hr = IUnknown_QueryService(pDocument,
                               SID_SProxyBrowser,
                               IID_IShellBrowser,
                               (void**)&pShlBrowser);

    // If we are in a band object, get the WebOC of its host.
    // Otherwise, just return the current window.
    //
    if (!hr)
    {
        // Get the top-level browser object.
        //
        hr = IUnknown_QueryService(pShlBrowser,
                                   SID_SWebBrowserApp,
                                   IID_IWebBrowser2,
                                   (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        hr = GetWebOCWindow(pWebBrowser, FALSE, ppTargHTMLWindow);

        // If there was a failure retrieving the window, we call
        // IWebBrowser2::Navigate on the main window instead.
        // This can happen if the main window contains a non-html file.
        //
        if (hr && ppTopWebOC)
        {
            *ppTopWebOC = pWebBrowser;
            pWebBrowser = NULL;  // Don't release.
        }
    }
    else  // Not in a band
    {
        hr = pWindow->get_self(ppTargHTMLWindow);
    }
    

Cleanup:
    ReleaseInterface(pDocument);
    ReleaseInterface(pWebBrowser);
    ReleaseInterface(pShlBrowser);
    
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : NavigateInBand
//
//  Synopsis  : Navigates to a URL in the specified browser band.  
//
//  Input     : pDocument      - the current document. This is needed in order
//                               to access the top-level browser.
//              clsid          - the clsid of the band to open and navigate.
//              pszOriginalUrl - The original (unexpanded) URL. If this URL
//                               is empty, the band will be opened but
//                               not navigated.
//              pszExpandedUrl - the URL to navigate to.
//
//  Output    : ppBandWindow   - the IHTMLWindow2 of the band.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//-----------------------------------------------------------------------------

HRESULT
NavigateInBand(IHTMLDocument2 * pDocument,
               IHTMLWindow2   * pOpenerWindow,
               REFCLSID         clsid,
               LPCTSTR          pszOriginalUrl,
               LPCTSTR          pszExpandedUrl,
               IHTMLWindow2  ** ppBandWindow)
{
    HRESULT  hr;
    VARIANT  varClsid = {0};  // Don't use CVariant. See Cleanup for details.
    CVariant cvarBandUnk;
    CVariant cvarUrl(VT_BSTR);
    IOleCommandTarget * pCmdTarget  = NULL;
    IBrowserBand      * pBrowserBand = NULL;

    Assert(pDocument);
    Assert(clsid != CLSID_NULL);
    Assert(pszOriginalUrl);
    Assert(pszExpandedUrl);

    hr = GetBandCmdTarget(pDocument, &pCmdTarget);
    if (hr)
        goto Cleanup;

    // Show the band
    //
    V_VT(&varClsid) = VT_BSTR;
    
    hr = StringFromCLSID(clsid, &V_BSTR(&varClsid));
    if (hr)
        goto Cleanup;

    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_SHOWBROWSERBAR,
                          1,
                          &varClsid,
                          NULL);
    if (hr)
        goto Cleanup;
        
    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_GETBROWSERBAR,
                          NULL,
                          NULL, 
                          &cvarBandUnk);

    if (hr || (VT_UNKNOWN != V_VT(&cvarBandUnk)) || (NULL == V_UNKNOWN(&cvarBandUnk)))
    {
        goto Cleanup;
    }
    
    hr = V_UNKNOWN(&cvarBandUnk)->QueryInterface(IID_IBrowserBand, (LPVOID*)&pBrowserBand);
    if (hr)
        goto Cleanup;
        
    // If the original URL is empty, we need
    // to navigate to the default search page.
    // Get the default search URL.
    //
    if (!*pszOriginalUrl
        && S_FALSE == IUnknown_Exec(pBrowserBand, &CLSID_SearchBand, SBID_HASPIDL, 0, NULL, NULL))
    {
        GetDefaultSearchUrl(pBrowserBand, &V_BSTR(&cvarUrl));
    }
    else
    {
        if (!*pszOriginalUrl)
        {
            V_BSTR(&cvarUrl) = SysAllocString(TEXT(""));
        }
        else
        {
            V_BSTR(&cvarUrl) = SysAllocString(pszExpandedUrl);
        }
    }

    if (NULL == V_BSTR(&cvarUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_NAVIGATEBBTOURL,
                          NULL,
                          &cvarUrl,
                          NULL);
    
    if (hr)
        goto Cleanup;

    // Get the the band window if one is needed
    // (i.e., ppBandWindow != NULL. This is usually
    // the case when we are called as the result of 
    // a call to window.open().
    //
    if (ppBandWindow)
    {
        hr = GetBandWindow(pBrowserBand, ppBandWindow);

        if (!hr && pOpenerWindow)
        {
            // Set the opener window
            //
            CVariant cvarOpener(VT_DISPATCH);

            hr = pOpenerWindow->QueryInterface(IID_IDispatch, (void**)&V_DISPATCH(&cvarOpener));
            if (hr)
                goto Cleanup;

            hr = (*ppBandWindow)->put_opener(cvarOpener);
        }
    }

Cleanup:
    ReleaseInterface(pCmdTarget);
    ReleaseInterface(pBrowserBand);

    // Do not VariantClear varClsid. The BSTR in varClsid
    // must be freed using CoTaskMemFree since it was 
    // allocated by StringFromCLSID using CoTaskMemAlloc.
    // Using VariantClear causes a crash in ntdll.
    // CVariant uses VariantClear. That is why VARIANT
    // is used instead.
    //
    CoTaskMemFree(V_BSTR(&varClsid));

    TraceTag((tagFrameT, "FrameT: NavigateInBand returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetBandWindow
//
//  Synopsis  : Retrieves the IHTMLWindow2 of a band. This method assumes that
//              the band has already been opened.
//
//  Input     : pBrowserBand - the IBrowserBand of the band.
//  Output    : ppBandWindow - the IHTMLWindow2 of the band.
//
//-----------------------------------------------------------------------------

HRESULT
GetBandWindow(IBrowserBand  * pBrowserBand,
              IHTMLWindow2 ** ppBandWindow)
{
    HRESULT  hr;
    IWebBrowser2     * pBandWebOC = NULL;
    IDispatch        * pDispatch  = NULL;
    IHTMLDocument2   * pDocument  = NULL;
    ITargetFramePriv * pFramePriv = NULL;

    Assert(pBrowserBand);
    Assert(ppBandWindow);
    Assert(!*ppBandWindow);

    *ppBandWindow = NULL;
    
    hr = pBrowserBand->GetObjectBB(IID_IWebBrowser2, (LPVOID*)&pBandWebOC);
    if (hr)
        goto Cleanup;

    hr = pBandWebOC->get_Document(&pDispatch);
    if (hr)
        goto Cleanup;

    // get_Document will return hr == S_OK with a NULL
    // IDispatch if the document has not yet been navigated.
    // If get_Document returns an IDispatch, get the window
    // from the returned ptr, otherwise, retrieve the
    // ITargetFramePriv of the band and get the window
    // from ITargetFramePriv.
    //
    if (pDispatch)
    {
        hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
        if (hr)
            goto Cleanup;
        
        hr = pDocument->get_parentWindow(ppBandWindow);
    }
    else
    {
        hr = pBandWebOC->QueryInterface(IID_ITargetFramePriv, (void**)&pFramePriv);
        if (hr)
            goto Cleanup;

        hr = IUnknown_QueryService(pFramePriv,
                                   SID_SOmWindow,
                                   IID_IHTMLWindow2,
                                   (void**)ppBandWindow);
    }

Cleanup:
    ReleaseInterface(pBandWebOC);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDocument);
    ReleaseInterface(pFramePriv);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetBandCmdTarget
//
//  Synopsis  : Retrieves the IOleCommandTarget of a band. 
//
//  Input     : pDocument   - the current document. 
//  Output    : ppCmdTarget - the IOleCommandTarget of the band.
//
//-----------------------------------------------------------------------------

HRESULT
GetBandCmdTarget(IHTMLDocument2     * pDocument,
                 IOleCommandTarget ** ppCmdTarget)
{
    HRESULT hr;
    IServiceProvider * pSvcPrvdr   = NULL;
    IShellBrowser    * pShlBrowser = NULL;

    Assert(pDocument);
    Assert(ppCmdTarget);

    // Get the top-level browser object.
    //
    hr = pDocument->QueryInterface(IID_IServiceProvider, (void**)&pSvcPrvdr);
    if (hr)
        goto Cleanup;

    // Check to see if we are in a band object. If we are, get its 
    // IShellBrowser. If not, retrieve the IShellBrowser of the 
    // current browser window.
    //
    hr = pSvcPrvdr->QueryService(SID_SProxyBrowser,
                                 IID_IShellBrowser,
                                 (void**)&pShlBrowser);

    if (hr != S_OK) // Not in band object
    {
        hr = pSvcPrvdr->QueryService(SID_SShellBrowser,
                                     IID_IShellBrowser,
                                     (void**)&pShlBrowser);
        if (hr)
            goto Cleanup;
    }

    // Get the IOleCommandTarget of the shell browser
    // in order to show and navigate the band.
    //
    hr = pShlBrowser->QueryInterface(IID_IOleCommandTarget, (void**)ppCmdTarget);

Cleanup:
    ReleaseInterface(pSvcPrvdr);
    ReleaseInterface(pShlBrowser);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetDefaultSearchUrl
//
//  Synopsis  : Retrieves the default search url to be loaded into the 
//              search band.
//
//  Input     : pBrowserBand - the IBrowserBand of the band.
//  Output    : pbstrUrl     - the default search URL.
//
//-----------------------------------------------------------------------------

HRESULT
GetDefaultSearchUrl(IBrowserBand * pBrowserBand,
                    BSTR         * pbstrUrl)
{
    HRESULT hr;
    TCHAR   szSearchUrl[INTERNET_MAX_URL_LENGTH];
    ISearchItems * pSearchItems = NULL;

    Assert(pBrowserBand);
    Assert(pbstrUrl);

    *pbstrUrl = NULL;

    hr = IUnknown_QueryService(pBrowserBand,
                               SID_SExplorerToolbar,
                               IID_ISearchItems,
                               (void**)&pSearchItems);
    if (hr)
        goto Cleanup;

    // Get the default search url
    
    hr = pSearchItems->GetDefaultSearchUrl(szSearchUrl, ARRAY_SIZE(szSearchUrl));
    if (hr)
        goto Cleanup;

    *pbstrUrl = SysAllocString(szSearchUrl);

Cleanup:
    ReleaseInterface(pSearchItems);

    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  Function  : GetTargetType
//
//  Synopsis  : Returns the type of target window for the given target name.
//
//  Input     : pszTargetName - the target window name.
//
//  Returns   : TARGET_TYPE corresponding to the give window name.
//
//---------------------------------------------------------------------------

TARGET_TYPE 
GetTargetType(LPCOLESTR pszTargetName)
{
    const TARGETENTRY * pEntry = targetTable;

    if (!pszTargetName || pszTargetName[0] != '_')
    {
        goto Cleanup;
    }
        
    while (pEntry->pszTargetName)
    {
        // Remember: magic names are case-sensitive.
        //
        if (!StrCmpW(pszTargetName, pEntry->pszTargetName))
        {
            return pEntry->eTargetType;
        }
        
        pEntry++;
    }

Cleanup:
    // Treat unknown magic targets as regular
    // frame name for NETSCAPE compatibility.
    //
    return TARGET_FRAMENAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\include\webocutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       webocutil.h
//
//  Contents:   WebBrowser control utility functions
//
//----------------------------------------------------------------------------

#ifndef __WEBOCUTIL_H__
#define __WEBOCUTIL_H__

#ifndef X_EXDISPID_H_
#define X_EXDISPID_H_
#include "exdispid.h"
#endif

class CBase;

// Function Prototypes
HRESULT GetParentWebOC(IHTMLWindow2  * pWindow,
                       IWebBrowser2 ** ppWebBrowser);

HRESULT GetWebOCWindow(IWebBrowser2  * pWebBrowser,
                       BOOL            fGetWindowObject,
                       IHTMLWindow2 ** ppWindow);

void InvokeSink(IConnectionPoint * pConnPt,
                DISPID             dispidEvent,
                DISPPARAMS       * pDispParams);

void InvokeEventV(IConnectionPoint * pConnPt,
                  CBase            * pFrameSite,
                  DISPID             dispidEvent, 
                  int                cArgs,
                  ...);
                  
HRESULT FormatUrlForDisplay(LPCTSTR lpszIn,
                            LPTSTR  lpszOut,
                            LPDWORD pcchOut);

HRESULT FormatUrl(LPCTSTR lpszUrl,    LPCTSTR lpszLocation,
                  LPTSTR  lpszUrlOut, DWORD   cchUrl);

HRESULT GetWebOCDocument(IUnknown * pUnk, IDispatch ** pDispatch);
          
HRESULT NavigateWebOCWithBindCtx(IWebBrowser2 * pWebBrowser,
                                 VARIANT      * pvarUrl,
                                 VARIANT      * pvarFlags,
                                 VARIANT      * pvarFrameName,
                                 VARIANT      * pvarPostData,
                                 VARIANT      * pvarHeaders,
                                 IBindCtx     * pBindCtx,
                                 LPCTSTR        pchLocation);
#endif  // __WEBOCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\hlinkfrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       hlinkfrm.h
//
//  Contents:   IHlinkFrame implementation for the CWindow class.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef _X_FRMSITE_H_
#define _X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

DeclareTag(tagHlinkFrame, "CWindow::IHlinkFrame", "Trace IHlinkFrame Methods")
DeclareTag(tagTargetFrame, "CWindow::ITargetFrame", "Trace ITargetFrame Methods")


#define SZ_HTMLLOADOPTIONS_OBJECTPARAM  _T("__HTMLLOADOPTIONS")

#define ReturnTraceNotImpl(str) \
{ \
    TraceTag((tagHlinkFrame, str)); \
    return E_NOTIMPL; \
}

#define HDR_LANGUAGE     TEXT("Accept-Language:")
#define CRLF             TEXT("\x0D\x0A")

HRESULT
CFrameWebOC::SetBrowseContext(IHlinkBrowseContext * pihlbc)
{
    ReturnTraceNotImpl("SetBrowseContext");
}

HRESULT
CFrameWebOC::GetBrowseContext(IHlinkBrowseContext ** ppihlbc)
{
    ReturnTraceNotImpl("GetBrowseContext");
}

HRESULT
CFrameWebOC::Navigate(DWORD grfHLNF,
                      LPBC  pbc,
                      IBindStatusCallback * pibsc,
                      IHlink * pihlNavigate)
{
    HRESULT    hr = E_FAIL;
    IMoniker * pmkTarget = NULL;
    IBindCtx * pbcLocal  = NULL;
    LPOLESTR   pstrUrl   = NULL;
    BSTR       bstrUrl   = NULL;
    BSTR       bstrShortcut  = NULL;
    LPOLESTR   pstrLocation  = NULL;
    LPOLESTR   pstrFrameName = NULL;
    BSTR       bstrFrameName = NULL;
    BSTR       bstrLocation = NULL;
    DWORD      dwFlags = DOCNAVFLAG_DOCNAVIGATE;

    TraceTag((tagHlinkFrame, "Navigate"));

    // We may need to support grfHLNF, pbc, pibsc, and pihlNavigate)
    //
    if (pihlNavigate && ((IHlink *)-1) != pihlNavigate)
    {
        IGNORE_HR(pihlNavigate->GetTargetFrameName(&pstrFrameName));

        //
        // Note that we are discarding "relative" portion.
        //
        hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmkTarget, &pstrLocation);
        if (hr)
            goto Cleanup;

        if (pbc) 
        {
            IUnknown         * pUnk = NULL;
            IHtmlLoadOptions * pHtmlLoadOptions  = NULL;

            pbcLocal = pbc;
            pbcLocal->AddRef();

            //
            // at this point extract information from the BindCtx that was passed in.
            // currently (bug 98431) the internet shortcut is the only one required.
            //
            // NOTE, ProcessHTMLLoadOptions deals with other LoadOption values.
            //  they are not yet implemented here.
            //
            pbcLocal->GetObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM, &pUnk);

            if (pUnk)
            {
                pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **)&pHtmlLoadOptions);

                if (pHtmlLoadOptions)
                {
                    TCHAR    achCacheFile[MAX_PATH];
                    ULONG    cchCacheFile = ARRAY_SIZE(achCacheFile);

                    // now determine if this is a shortcut-initiated load
                    hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                           &achCacheFile,
                                                           &cchCacheFile));
                    if (   hr == S_OK
                        && cchCacheFile)
                    {
                        bstrShortcut  = SysAllocString(achCacheFile);
                    }
                }
            }

            ReleaseInterface(pHtmlLoadOptions);
            ReleaseInterface(pUnk);
        }
        else 
        {
            hr = CreateBindCtx(0, &pbcLocal);
            if (hr)
                goto Cleanup;
        }

        hr = pmkTarget->GetDisplayName(pbcLocal, NULL, &pstrUrl);
        if (hr)
            goto Cleanup;

        bstrUrl       = SysAllocString(pstrUrl);
        bstrFrameName = SysAllocString(pstrFrameName);
        bstrLocation = SysAllocString(pstrLocation);

        if (grfHLNF & HLNF_OPENINNEWWINDOW)
            dwFlags |= DOCNAVFLAG_OPENINNEWWINDOW;

        DWORD grfBINDF;
        BINDINFO binfo = {0};
        SAFEARRAY * psaPostData = NULL;
        VARIANT vaPostData = {0};
        VARIANT vaHeaders = {0};
        IHttpNegotiate *pinegotiate;
        BSTR bstrHeaders = NULL;

        binfo.cbSize = sizeof(binfo);

        if( pibsc && SUCCEEDED(pibsc->GetBindInfo(&grfBINDF, &binfo)))
        {
            if(binfo.stgmedData.tymed == TYMED_HGLOBAL && binfo.stgmedData.hGlobal && binfo.cbstgmedData) 
            {
                // make a SAFEARRAY for post data
                psaPostData = SafeArrayCreateVector(VT_UI1, 0, binfo.cbstgmedData);
                if (psaPostData)
                {
                    memcpy(psaPostData->pvData, binfo.stgmedData.hGlobal, binfo.cbstgmedData);                
                    V_VT(&vaPostData) = VT_ARRAY | VT_UI1;
                    V_ARRAY(&vaPostData) = psaPostData;
                }
            }
            
        }

        if ( pibsc && SUCCEEDED(pibsc->QueryInterface(IID_IHttpNegotiate, (LPVOID *)&pinegotiate)) )
        {
            WCHAR *pwzAdditionalHeaders = NULL;

            hr=pinegotiate->BeginningTransaction(NULL, NULL, 0, &pwzAdditionalHeaders);
            if (SUCCEEDED(hr) && pwzAdditionalHeaders)
            {

                LPTSTR pszNext;
                LPTSTR pszLine;
                LPTSTR pszLast;

                pszLine = pwzAdditionalHeaders;
                pszLast = pwzAdditionalHeaders + lstrlen(pwzAdditionalHeaders);
                while (pszLine < pszLast)
                {
                    pszNext = StrStrI(pszLine, CRLF);
                    if (pszNext == NULL)
                    {
                        // All Headers must be terminated in CRLF!
                        pszLine[0] = '\0';
                        break;
                    }
                    pszNext += 2;
                    if (!StrCmpNI(pszLine,HDR_LANGUAGE,16))
                    {
                        MoveMemory(pszLine, pszNext, ((pszLast - pszNext) + 1)*sizeof(TCHAR));
                        break;
                    }
                    pszLine = pszNext;
                }
                // Don't include empty headers
                if (pwzAdditionalHeaders[0] == '\0')
                {
                    CoTaskMemFree(pwzAdditionalHeaders);
                    pwzAdditionalHeaders = NULL;
                }

            }


            if (pwzAdditionalHeaders && pwzAdditionalHeaders[0])
            {
                bstrHeaders = SysAllocString(pwzAdditionalHeaders);
                V_VT(&vaHeaders) = VT_BSTR;
                V_BSTR(&vaHeaders) = bstrHeaders;
            }

            pinegotiate->Release();
            CoTaskMemFree(pwzAdditionalHeaders);
        }


        hr = _pWindow->SuperNavigate(bstrUrl,
                                     bstrLocation,
                                     bstrShortcut,
                                     bstrFrameName,
                                     &vaPostData,
                                     &vaHeaders,
                                     dwFlags);
        if (psaPostData)
        {
            SafeArrayDestroy(psaPostData); 
        }

        if (bstrHeaders)
        {
            SysFreeString(bstrHeaders);
        }

        ReleaseBindInfo(&binfo);
    }

Cleanup:
    ReleaseInterface(pmkTarget);
    ReleaseInterface(pbcLocal);

    TaskFreeString(pstrUrl);
    TaskFreeString(pstrLocation);
    TaskFreeString(pstrFrameName);

    SysFreeString(bstrUrl);
    SysFreeString(bstrFrameName);
    SysFreeString(bstrShortcut);
    SysFreeString(bstrLocation);

    return hr;
}

HRESULT
CFrameWebOC::OnNavigate(DWORD      grfHLNF,
                        IMoniker * pimkTarget,
                        LPCWSTR    pwzLocation,
                        LPCWSTR    pwzFriendlyName,
                        DWORD      dwreserved)
{
    ReturnTraceNotImpl("OnNavigate");
}

HRESULT
CFrameWebOC::UpdateHlink(ULONG      uHLID,
                         IMoniker * pimkTarget,
                         LPCWSTR    pwzLocation,
                         LPCWSTR    pwzFriendlyName)
{
    ReturnTraceNotImpl("UpdateHlink");
}

HRESULT
CFrameWebOC::SetFrameName(LPCWSTR pszFrameName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName = NULL;
    
    TraceTag((tagTargetFrame, "SetFrameName"));

    FRAME_WEBOC_PASSIVATE_CHECK(hr);
    
    FRAME_WEBOC_VERIFY_WINDOW(hr);

    bstrName = SysAllocString(pszFrameName);
    
    if (bstrName)
    {
        hr = _pWindow->put_name(bstrName);
    }

    SysFreeString(bstrName);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFrameName(LPWSTR * ppszFrameName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName = NULL;

    TraceTag((tagTargetFrame, "GetFrameName"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    hr = _pWindow->get_name(&bstrName);
    if (hr)
        goto Cleanup;
    
    hr = TaskAllocString(bstrName, ppszFrameName);

Cleanup:
    SysFreeString(bstrName);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetParentFrame(IUnknown ** ppunkParent)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 * pHTMLWindow = NULL;
    TraceTag((tagTargetFrame, "GetParentFrame"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    hr = _pWindow->get_parent(&pHTMLWindow);
    if (hr)
        goto Cleanup;

    hr = pHTMLWindow->QueryInterface(IID_IUnknown, (void **) ppunkParent);

Cleanup:
    ReleaseInterface(pHTMLWindow);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::FindFrame(LPCWSTR pszTargetName,
                       IUnknown * ppunkContextFrame,
                       DWORD dwFlags,
                       IUnknown ** ppunkTargetFrame)
{
    HRESULT             hr                      = E_FAIL;
    COmWindowProxy *    pTargetOmWindowProxy;
    IHTMLWindow2   *    pTargetHTMLWindow       = NULL;
    IWebBrowser2    *   pWebBrowser             = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    TraceTag((tagTargetFrame, "FindFrame"));

    if (!ppunkTargetFrame)
        goto Cleanup;

    *ppunkTargetFrame = NULL;

    hr = _pWindow->FindWindowByName(pszTargetName, &pTargetOmWindowProxy, &pTargetHTMLWindow);
    if (hr)
        goto Cleanup;

    if (pTargetHTMLWindow)
    {
        IServiceProvider * pServiceProvider;
        hr = THR(pTargetHTMLWindow->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider));
        if (hr)
            goto Cleanup;
        hr = THR(pServiceProvider->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **) &pWebBrowser));
        ReleaseInterface(pServiceProvider);
    }  
    else if (pTargetOmWindowProxy)
    {
        hr = THR(pTargetOmWindowProxy->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **) &pWebBrowser));
    }
    if (hr)
        goto Cleanup;
    hr = THR(pWebBrowser->QueryInterface(IID_IUnknown, (void **) ppunkTargetFrame));

Cleanup:
    ReleaseInterface(pWebBrowser);
    ReleaseInterface(pTargetHTMLWindow);

    // Return E_FAIL if a matching frame is not found
    return (S_OK == hr) ? S_OK : E_FAIL;
}

HRESULT
CFrameWebOC::SetFrameSrc(LPCWSTR pszFrameSrc)
{
    HRESULT hr = E_FAIL;
    BSTR bstrSrc = NULL;
    IHTMLFrameBase * pHTMLFrameBase = NULL;

    TraceTag((tagTargetFrame, "SetFrameSrc"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);

    bstrSrc = SysAllocString(pszFrameSrc);
    
    if (bstrSrc)
    {
        hr = _pWindow->get_frameElement(&pHTMLFrameBase);
        if (!pHTMLFrameBase)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pHTMLFrameBase->put_src(bstrSrc);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pHTMLFrameBase);
    SysFreeString(bstrSrc);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFrameSrc(LPWSTR * ppszFrameSrc)
{
    HRESULT hr = E_FAIL;
    BSTR bstrSrc = NULL;
    IHTMLFrameBase * pHTMLFrameBase = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);

    TraceTag((tagTargetFrame, "GetFrameSrc"));

    hr = _pWindow->get_frameElement(&pHTMLFrameBase);

    if (!pHTMLFrameBase)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pHTMLFrameBase->get_src(&bstrSrc);
    if (hr)
        goto Cleanup;
    
    hr = TaskAllocString(bstrSrc, ppszFrameSrc);

Cleanup:
    ReleaseInterface(pHTMLFrameBase);
    SysFreeString(bstrSrc);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFramesContainer(IOleContainer ** ppContainer)
{
    TraceTag((tagTargetFrame, "GetFramesContainer"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::SetFrameOptions(DWORD dwFlags)
{
    TraceTag((tagTargetFrame, "SetFrameOptions"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::GetFrameOptions(DWORD * pdwFlags)
{
    TraceTag((tagTargetFrame, "GetFrameOptions"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    TraceTag((tagTargetFrame, "SetFrameMargins"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::GetFrameMargins(DWORD * pdwWidth, DWORD * pdwHeight)
{
    TraceTag((tagTargetFrame, "GetFrameMargins"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::RemoteNavigate(ULONG cLength, ULONG * pulData)
{
    TraceTag((tagTargetFrame, "RemoteNavigate"));

    return E_FAIL;
}

HRESULT
CFrameWebOC::OnChildFrameActivate(IUnknown * pUnkChildFrame)
{
    TraceTag((tagTargetFrame, "OnChildFrameActivate"));

    return S_OK;
}

HRESULT
CFrameWebOC::OnChildFrameDeactivate(IUnknown * pUnkChildFrame)
{
    TraceTag((tagTargetFrame, "OnChildFrameDeactivate"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\othridpr.c ===
/*
   formidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <othrguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\otherid.c ===
/*
   formid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
#include <othrguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\frameweboc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : frameweboc.cxx
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

extern BOOL OLECMDIDFromIDM(int idm, ULONG *pulCmdID);

MtDefine(CFrameWebOC, ObjectModel, "CFrameWebOC");

HRESULT
CWindow::EnsureFrameWebOC()
{
    HRESULT hr = S_OK;

    if (!_pFrameWebOC)
    {
        _pFrameWebOC = new CFrameWebOC(this);
        if (!_pFrameWebOC)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

const CONNECTION_POINT_INFO CFrameWebOC::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_DWebBrowserEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_DWebBrowserEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CFrameWebOC::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IWebBrowser2,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CFrameWebOC::CFrameWebOC(CWindow * pWindow)
{
    _pWindow = pWindow;
    _pWindowForReleasing = pWindow;
    
    if (pWindow)
    {
        pWindow->SubAddRef();
    }
    else
    {
        AssertSz(0,"Someone is passing NULL to the constructor of CFrameWebOC");
    }
}

CFrameWebOC::~CFrameWebOC()
{
    if (_pWindowForReleasing != NULL)
    {
        _pWindowForReleasing->SubRelease();
        _pWindowForReleasing = NULL;
    }
}

HRESULT
CFrameWebOC::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
#if DBG==1
    char *pchIIDName = NULL;
#endif

    *ppv = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    switch (iid.Data1)
    {
    QI_INHERITS2(this, IUnknown, IWebBrowser2)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_INHERITS(this,  IWebBrowser2)
    QI_INHERITS2(this, IWebBrowser, IWebBrowser2)
    QI_INHERITS2(this, IWebBrowserApp, IWebBrowser2)
    QI_TEAROFF(this,  IHlinkFrame, NULL)
    QI_TEAROFF(this,  ITargetFrame, NULL)
    QI_TEAROFF(this,  IServiceProvider, NULL)
    QI_TEAROFF(this,  IPersistHistory, NULL)
    QI_TEAROFF2(this, IPersist, IPersistHistory, NULL)
    QI_TEAROFF(this, IOleCommandTarget, NULL)
    QI_TEAROFF(this, IExternalConnection, NULL)
    QI_TEAROFF(this, IProvideClassInfo2, NULL)
    QI_TEAROFF2(this, IProvideClassInfo, IProvideClassInfo2, NULL)
    QI_TEAROFF(this, IOleWindow, NULL)
    QI_CASE(IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) =
                new CConnectionPointContainer(this, NULL);

        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
        
        SetFrameWebOCEventsShouldFire();
        break;
    }

    // NOTE: If we had implemented the FrameWebOC in the early days of NativeFrames
    // then this itf would be important for shdocvw frame targetting. However,
    // we have worked around this problem in shdocvw, and hence we should never
    // implement this itf on this object.
    QI_CASE(ITargetFramePriv)
    {
        RRETURN(E_NOINTERFACE);
        break;
    }

#if DBG==1 
#define QI_CRASH(itfName1__, itfName2__) case Data1_##itfName1__: if (iid == IID_##itfName1__) {pchIIDName = #itfName1__;goto handle_##itfName2__;} else break; 
    QI_CRASH(IDataObject, IViewObject2)
    QI_CRASH(IInternetSecurityMgrSite, IViewObject2)
    QI_CRASH(IObjectSafety, IViewObject2)
    QI_CRASH(IOleControl, IViewObject2)
    QI_CRASH(IOleInPlaceActiveObject, IViewObject2)
    QI_CRASH(IOleInPlaceObject, IViewObject2)
    QI_CRASH(IOleObject, IViewObject2)
    QI_CRASH(IPersistPropertyBag, IViewObject2)
    QI_CRASH(IPersistStorage, IViewObject2)
    QI_CRASH(IPersistStream, IViewObject2)
    QI_CRASH(IPersistStreamInit, IViewObject2)
    QI_CRASH(ITargetEmbedding, IViewObject2)
    QI_CRASH(ITargetFrame2, IViewObject2)
    QI_CRASH(ITargetNotify, IViewObject2)
    QI_CRASH(IUrlHistoryNotify, IViewObject2)
    QI_CRASH(IViewObject, IViewObject2)
    case Data1_IViewObject2:
    {
        if (iid == IID_IViewObject2)
        {
            pchIIDName = "IViewObject2";
            
handle_IViewObject2:

            if (pchIIDName)
            {
                char mes[2000];
                mes[0] = 0;
                strcat(mes, "Need to implement interface: ");
                strcat(mes, pchIIDName);
                AssertSz(0, &mes[0]);
            }
        }
        break;
    }
#undef QI_CRASH
#endif // DBG==1
    }
    
    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//
// IDispatch[Ex] methods
//
//========================================================

HRESULT
CFrameWebOC::FrameOCGetDispid(  REFIID      riid,
                             LPOLESTR  * rgszNames,
                             UINT        cNames,
                             LCID        lcidParam,
                             DISPID    * rgdispid)
{
    HRESULT hr = E_INVALIDARG;
    BSTR    bstrName = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!IsEqualIID(riid, IID_NULL) || !rgdispid)
        goto Cleanup;

    bstrName = SysAllocString(rgszNames[0]);
    if ( bstrName )
    {
        hr = GetWebOCDispID(bstrName, fdexFromGetIdsOfNames, rgdispid);
    
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = super::GetIDsOfNames(riid, rgszNames, cNames, lcidParam, rgdispid);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
Cleanup:
    SysFreeString(bstrName);
    return hr;
}

HRESULT
CFrameWebOC::FrameOCInvoke(DISPID       dispidMember,
                    REFIID       riid,
                    LCID         lcid,
                    WORD         wFlags,
                    DISPPARAMS * pdispparams,
                    VARIANT    * pvarResult,
                    EXCEPINFO  * pexcepinfo,
                    UINT       * puRet)
{
    HRESULT  hr = E_INVALIDARG;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!IsEqualIID(riid, IID_NULL))
        goto Cleanup;

    hr = InvokeWebOC(this, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL);
    if (FAILED(hr))
    {
        hr = super::Invoke(dispidMember, riid, lcid, wFlags, 
                           pdispparams, pvarResult, pexcepinfo, puRet);
    }
    
Cleanup:
    return hr;
}



HRESULT
CFrameWebOC::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(GetWebOCDispID(bstrName, (grfdex & fdexNameCaseSensitive), pid));
}

HRESULT
CFrameWebOC::InvokeEx(DISPID dispidMember,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      IServiceProvider * pSrvProvider)
{
    HRESULT hr = E_FAIL;
    
    FRAME_WEBOC_PASSIVATE_CHECK(hr);
        
    hr = InvokeWebOC(this, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    RRETURN(hr);
}


BEGIN_TEAROFF_TABLE(CFrameWebOC, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(CFrameWebOC, super::GetTypeInfoCount, super::gettypeinfocount, (unsigned int *))
    TEAROFF_METHOD(CFrameWebOC, super::GetTypeInfo, super::gettypeinfo, (unsigned int, unsigned long, ITypeInfo **))
    TEAROFF_METHOD(CFrameWebOC, FrameOCGetDispid, FrameOCGetDispid, (REFIID, LPOLESTR *, unsigned int, LCID, DISPID *))
    TEAROFF_METHOD(CFrameWebOC, FrameOCInvoke, FrameOCInvoke, (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *))
    //  IDispatchEx methods
    TEAROFF_METHOD(CFrameWebOC, GetDispID, getdispid, (BSTR,DWORD,DISPID*))
    TEAROFF_METHOD(CFrameWebOC, InvokeEx, invokeex, (DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*))
    TEAROFF_METHOD(CFrameWebOC, super::DeleteMemberByName, super::deletememberbyname, (BSTR,DWORD))
    TEAROFF_METHOD(CFrameWebOC, super::DeleteMemberByDispID, super::deletememberbydispid, (DISPID))
    TEAROFF_METHOD(CFrameWebOC, super::GetMemberProperties, super::getmemberproperties, (DISPID,DWORD,DWORD*))
    TEAROFF_METHOD(CFrameWebOC, super::GetMemberName, super::getmembername, (DISPID,BSTR*))
    TEAROFF_METHOD(CFrameWebOC, super::GetNextDispID, super::getnextdispid, (DWORD,DISPID,DISPID*))
    TEAROFF_METHOD(CFrameWebOC, super::GetNameSpaceParent, super::getnamespaceparent, (IUnknown**))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IHlinkFrame)
    TEAROFF_METHOD(CFrameWebOC, SetBrowseContext, setbrowsecontext, (IHlinkBrowseContext * pihlbc))
    TEAROFF_METHOD(CFrameWebOC, GetBrowseContext, getbrowsecontext, (IHlinkBrowseContext ** ppihlbc))
    TEAROFF_METHOD(CFrameWebOC, Navigate, navigate, (DWORD grfHLNF, LPBC pbc, IBindStatusCallback * pibsc, IHlink * pihlNavigate))
    TEAROFF_METHOD(CFrameWebOC, OnNavigate, onnavigate, (DWORD grfHLNF, IMoniker * pimkTarget,
                                                     LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved))
    TEAROFF_METHOD(CFrameWebOC, UpdateHlink, updatehlink, (ULONG uHLID, IMoniker * pimkTarget,
                                                       LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, ITargetFrame)
    TEAROFF_METHOD(CFrameWebOC, SetFrameName, setframename, (LPCWSTR pszFrameName))
    TEAROFF_METHOD(CFrameWebOC, GetFrameName, getframename, (LPWSTR * ppszFrameName))
    TEAROFF_METHOD(CFrameWebOC, GetParentFrame, getparentframe, (IUnknown ** ppunkParent))
    TEAROFF_METHOD(CFrameWebOC, FindFrame, findframe, (LPCWSTR pszTargetName,
                                                   IUnknown * ppunkContextFrame,
                                                   DWORD dwFlags,
                                                   IUnknown ** ppunkTargetFrame))
    TEAROFF_METHOD(CFrameWebOC, SetFrameSrc, setframesrc, (LPCWSTR pszFrameSrc))
    TEAROFF_METHOD(CFrameWebOC, GetFrameSrc, getframesrc, (LPWSTR * ppszFrameSrc))
    TEAROFF_METHOD(CFrameWebOC, GetFramesContainer, getframescontainer, (IOleContainer ** ppContainer))
    TEAROFF_METHOD(CFrameWebOC, SetFrameOptions, setframeoptions, (DWORD dwFlags))
    TEAROFF_METHOD(CFrameWebOC, GetFrameOptions, getframeoptions, (DWORD * pdwFlags))
    TEAROFF_METHOD(CFrameWebOC, SetFrameMargins, setframemargins, (DWORD dwWidth, DWORD dwHeight))
    TEAROFF_METHOD(CFrameWebOC, GetFrameMargins, getframemargins, (DWORD * pdwWidth, DWORD * pdwHeight))
    TEAROFF_METHOD(CFrameWebOC, RemoteNavigate, remotenavigate, (ULONG cLength, ULONG * pulData))
    TEAROFF_METHOD(CFrameWebOC, OnChildFrameActivate, onchildframeactivate, (IUnknown * pUnkChildFrame))
    TEAROFF_METHOD(CFrameWebOC, OnChildFrameDeactivate, onchildframedeactivate, (IUnknown * pUnkChildFrame))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IServiceProvider)
    TEAROFF_METHOD(CFrameWebOC, QueryService, queryservice, (REFGUID guidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CFrameWebOC, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CFrameWebOC, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CFrameWebOC, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CFrameWebOC, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CFrameWebOC, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IOleCommandTarget)
    TEAROFF_METHOD(CFrameWebOC,  QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CFrameWebOC,  Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IExternalConnection)
    TEAROFF_METHOD(CFrameWebOC, AddConnection, addconnection, ( DWORD extConn, DWORD dwReserved))
    TEAROFF_METHOD(CFrameWebOC, ReleaseConnection, releaseconnection, ( DWORD extConn, DWORD dwReserved, BOOL fLastReleaseCloses))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IProvideClassInfo2)
    TEAROFF_METHOD(CFrameWebOC, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CFrameWebOC, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IOleWindow)
    TEAROFF_METHOD(CFrameWebOC, GetWindow, getwindow, (HWND * lphwnd))
    TEAROFF_METHOD(CFrameWebOC, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
END_TEAROFF_TABLE()
            
#define DELEGATE_METHOD(klass, fn, args1, args2)\
    HRESULT\
    klass::fn##args1\
    {\
        RRETURN(_pWindow->##fn##args2);\
    }\

// IPersist methods
DELEGATE_METHOD(CFrameWebOC, GetClassID, (LPCLSID lpClassID), (lpClassID))

// IPersistHistory methods
DELEGATE_METHOD(CFrameWebOC, LoadHistory, (IStream *pStream, IBindCtx *pbc), (pStream, pbc))
DELEGATE_METHOD(CFrameWebOC, SaveHistory, (IStream *pStream), (pStream))
DELEGATE_METHOD(CFrameWebOC, SetPositionCookie, (DWORD dwCookie), (dwCookie))
DELEGATE_METHOD(CFrameWebOC, GetPositionCookie, (DWORD *pdwCookie), (pdwCookie))

//
// This array MUST be kept in sorted order. The
// binary search in GetWebOCDispID() depends on it
//
// NOTE : FOR COMPAT WITH 50 and earlier, the dispidID must be consistent
// with what was in the typelib for the WebOC
//
typedef struct {
    const TCHAR  * pchName;
    DISPID         dispidID;
} mapNameToDispID ;

static mapNameToDispID g_rgWebOCDispIDs[] = {
     _T("AddressBar"),         WEBOC_DISPID_ADDRESSBAR,
     _T("Application"),        WEBOC_DISPID_APPLICATION ,
     _T("Busy"),               WEBOC_DISPID_BUSY ,
     _T("ClientToWindow"),     WEBOC_DISPID_CLIENTTOWINDOW ,
     _T("Container"),          WEBOC_DISPID_CONTAINER,
     _T("Document"),           WEBOC_DISPID_DOCUMENT,
     _T("ExecWB"),             WEBOC_DISPID_EXECWB,
     _T("FullName"),           WEBOC_DISPID_FULLNAME,
     _T("FullScreen"),         WEBOC_DISPID_FULLSCREEN,
     _T("GetProperty"),        WEBOC_DISPID_GETPROPERTY,
     _T("GoBack"),             WEBOC_DISPID_GOBACK,
     _T("GoForward"),          WEBOC_DISPID_GOFORWARD,
     _T("GoHome"),             WEBOC_DISPID_GOHOME,
     _T("GoSearch"),           WEBOC_DISPID_GOSEARCH,
     _T("Height"),             WEBOC_DISPID_HEIGHT,
     _T("HWND"),               WEBOC_DISPID_HWND,
     _T("Left"),               WEBOC_DISPID_LEFT,
     _T("LocationName"),       WEBOC_DISPID_LOCATIONNAME,
     _T("LocationURL"),        WEBOC_DISPID_LOCATIONURL,
     _T("MenuBar"),            WEBOC_DISPID_MENUBAR,
     _T("Name"),               WEBOC_DISPID_NAME,
     _T("Navigate"),           WEBOC_DISPID_NAVIGATE,
     _T("Navigate2"),          WEBOC_DISPID_NAVIGATE2,
     _T("Offline"),            WEBOC_DISPID_OFFLINE,
     _T("Parent"),             WEBOC_DISPID_PARENT,
     _T("Path"),               WEBOC_DISPID_PATH,
     _T("PutProperty"),        WEBOC_DISPID_PUTPROPERTY,
     _T("QueryStatusWB"),      WEBOC_DISPID_QUERYSTATUSWB,
     _T("Quit"),               WEBOC_DISPID_QUIT,
     _T("ReadyState"),         WEBOC_DISPID_READYSTATE,
     _T("Refresh"),            WEBOC_DISPID_REFRESH,
     _T("Refresh2"),           WEBOC_DISPID_REFRESH2,
     _T("RegisterAsBrowser"),  WEBOC_DISPID_REGISTERASBROWSER,
     _T("RegisterAsDropTarget"),  WEBOC_DISPID_REGISTERASDROPTARGET,
     _T("Resizable"),          WEBOC_DISPID_RESIZABLE,
     _T("ShowBrowserBar"),     WEBOC_DISPID_SHOWBROWSERBAR,
     _T("Silent"),             WEBOC_DISPID_SILENT,
     _T("StatusBar"),          WEBOC_DISPID_STATUSBAR,
     _T("StatusText"),         WEBOC_DISPID_STATUSTEXT,
     _T("Stop"),               WEBOC_DISPID_STOP,
     _T("TheaterMode"),        WEBOC_DISPID_THEATERMODE,
     _T("ToolBar"),            WEBOC_DISPID_TOOLBAR,
     _T("Top"),                WEBOC_DISPID_TOP,
     _T("TopLevelContainer"),  WEBOC_DISPID_TOPLEVELCONTAINER,
     _T("Type"),               WEBOC_DISPID_TYPE,
     _T("Visible"),            WEBOC_DISPID_VISIBLE,
     _T("Width"),              WEBOC_DISPID_WIDTH,
};

//+-------------------------------------------------------------------------
//
//  Method   : GetWebOCDispID
//
//  Synopsis : Returns the DISPID of the specified WebOC method.
//
//  Input    : bstrName       - the name of the WebOC method.
//             fCaseSensitive - TRUE if the check should be case sensitive.
//
//  Output   : pDispID  - the DISPID of the WebOC method.
//
//--------------------------------------------------------------------------

HRESULT
GetWebOCDispID(BSTR bstrName, BOOL fCaseSensitive, DISPID * pDispID)
{
    int  nCmp;
    LONG i;
    LONG l = 0;
    LONG r = ARRAY_SIZE(g_rgWebOCDispIDs) - 1;

    Assert(pDispID);

    *pDispID = NULL;

    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;

    // Binary Search
    //
    while (r >= l)
    {
        i = (r + l) / 2;
        nCmp = pfnCompareString(bstrName, g_rgWebOCDispIDs[i].pchName);

        if (0 == nCmp)  // Found it
        {
            *pDispID = g_rgWebOCDispIDs[i].dispidID; // WEBOC_DISPIDBASE + i;
            return S_OK;
        }

        if (nCmp < 0)
            r = i - 1;
        else
            l = i + 1;
    }

    return DISP_E_UNKNOWNNAME;
}

VARIANT *DerefVariant(VARIANT *pVarIn)
{
    VARIANT *pVar = pVarIn;

    if ((VT_VARIANT|VT_BYREF) == V_VT(pVarIn))
        pVar = V_VARIANTREF(pVarIn);

    Assert(pVar);
    return pVar;
}

//+-------------------------------------------------------------------------
//
//  Method   : InvokeWebOC
//
//  Synopsis : Invokes the WebOC method for the given DISPID.
//
//--------------------------------------------------------------------------

HRESULT
InvokeWebOC(CFrameWebOC * pFrameWebOC,
            DISPID        dispidMember,
            LCID          lcid,
            WORD          wFlags,
            DISPPARAMS *  pDispParams,
            VARIANT    *  pvarResult,
            EXCEPINFO  *  pExcepInfo,
            IServiceProvider * pSrvProvider)
{
    HRESULT hr = E_FAIL;
    VARIANT *pVar0 = NULL;
    VARIANT varI4;
    
    if (pDispParams && pDispParams->cArgs > 0)
    {
        pVar0 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 1]);
        if (VT_I2 == V_VT(pVar0))
        {
            VariantInit(&varI4);
            if (!VariantChangeType(&varI4, pVar0, 0, VT_I4))
                pVar0 = &varI4;
        }
    }

    switch(dispidMember)
    {
    case WEBOC_DISPID_ADDRESSBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_AddressBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                Assert(pVar0);
                hr = pFrameWebOC->put_AddressBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_APPLICATION:

        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Application(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_BUSY:

        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = pFrameWebOC->get_Busy(&pvarResult->boolVal);
        }

        break;

    case WEBOC_DISPID_CLIENTTOWINDOW:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            VARIANT *pVar1 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 2]);
;
            Assert(pVar0);
            Assert(pVar1);
            if (V_VT(pVar1) != VT_I4 && V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->ClientToWindow(reinterpret_cast<int*>(&(pVar0->lVal)),
                                                 reinterpret_cast<int*>(&(pVar1->lVal)));
            }
        }

        break;

    case WEBOC_DISPID_CONTAINER:     
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Container(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_DOCUMENT:          
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Document(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_EXECWB:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else 
        {
            VARIANT *pVar1 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 2]);
       
            Assert(pVar0);
            Assert(pVar1);

            if (V_VT(pVar0) != VT_I4 || V_VT(pVar1) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                CVariant      cvarIn;
                VARIANT     * pvarOut = NULL;
                OLECMDID      nCmdID      = static_cast<OLECMDID>(V_I4(pVar0)); 
                OLECMDEXECOPT nCmdExecOpt = static_cast<OLECMDEXECOPT>(V_I4(pVar1));
                VARIANT *pVar2;

                switch(pDispParams->cArgs)
                {
                case 4:
                    pvarOut = &pDispParams->rgvarg[pDispParams->cArgs - 4];
                    // Intentional fall-through

                case 3:
                    pVar2 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 3]);
                    VariantCopy(&cvarIn, pVar2);
                    // Intentional fall-through

                default:
                    break;
                }

                hr = pFrameWebOC->ExecWB(nCmdID, nCmdExecOpt, &cvarIn, pvarOut);
            }
        }

        break;

    case WEBOC_DISPID_FULLNAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_FullName(&pvarResult->bstrVal);
        }
        break;

    case WEBOC_DISPID_FULLSCREEN:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_FullScreen(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_FullScreen(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_GETPROPERTY:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult || !pDispParams || pDispParams->cArgs == 0)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            hr = pFrameWebOC->GetProperty(V_BSTR(pVar0), pvarResult);
        }

        break;

    case WEBOC_DISPID_GOBACK:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoBack();
        }

        break;

    case WEBOC_DISPID_GOFORWARD:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoForward();
        }

        break;

    case WEBOC_DISPID_GOHOME:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoHome();
        }

        break;

    case WEBOC_DISPID_GOSEARCH:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoSearch();
        }

        break;

    case WEBOC_DISPID_HEIGHT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Height(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Height(V_I4(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_HWND:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
#ifdef _WIN64
           V_VT(pvarResult) = VT_I8;
           hr = pFrameWebOC->get_HWND((LONG_PTR*) &pvarResult->llVal);                        
#else
           V_VT(pvarResult) = VT_I4;
           hr = pFrameWebOC->get_HWND(&pvarResult->lVal);            
#endif
        }

        break;

    case WEBOC_DISPID_LEFT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Left(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Left(V_I4(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_LOCATIONNAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_LocationName(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_LOCATIONURL:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_LocationURL(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_MENUBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_MenuBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_MenuBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_NAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Name(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_NAVIGATE:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            CVariant cvarFlags;
            CVariant cvarFrameName;
            CVariant cvarPostData;
            CVariant cvarHeaders;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 5:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarHeaders, prefVar);
                pvar++;
                // Intentional fall-through

            case 4:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarPostData, prefVar);
                pvar++;
                // Intentional fall-through

            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFrameName, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFlags, prefVar);
                pvar++;
                break;

            default:
                break;
            }

            hr = pFrameWebOC->Navigate(V_BSTR(pVar0), &cvarFlags, &cvarFrameName, &cvarPostData, &cvarHeaders);
        }

        break;

    case WEBOC_DISPID_NAVIGATE2:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            CVariant cvarFlags;
            CVariant cvarFrameName;
            CVariant cvarPostData;
            CVariant cvarHeaders;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 5:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarHeaders, prefVar);
                pvar++;
                // Intentional fall-through

            case 4:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarPostData, prefVar);
                pvar++;
                // Intentional fall-through

            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFrameName, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFlags, prefVar);
                pvar++;
                break;

            default:
                break;
            }

            hr = pFrameWebOC->Navigate2(pVar0, &cvarFlags, &cvarFrameName, &cvarPostData, &cvarHeaders);
        }

        break;

    case WEBOC_DISPID_OFFLINE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Offline(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Offline(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_PARENT:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Parent(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_PATH:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Path(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_PUTPROPERTY:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            hr = pFrameWebOC->PutProperty(V_BSTR(pVar0), pDispParams->rgvarg[pDispParams->cArgs - 2]);
        }
        break;

    case WEBOC_DISPID_QUERYSTATUSWB:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult || !pDispParams || pDispParams->cArgs == 0)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_I4)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            OLECMDID nCmdID = static_cast<OLECMDID>(V_I4(pVar0)); 
            V_VT(pvarResult) = VT_I4;
            hr = pFrameWebOC->QueryStatusWB(nCmdID, reinterpret_cast<OLECMDF*>(&pvarResult->lVal));
        }

        break;

    case WEBOC_DISPID_QUIT:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Quit();
        }

        break;

    case WEBOC_DISPID_READYSTATE:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_I4;
            hr = pFrameWebOC->get_ReadyState(reinterpret_cast<READYSTATE*>(&pvarResult->lVal));
        }

        break;

    case WEBOC_DISPID_REFRESH:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Refresh();
        }

        break;

    case WEBOC_DISPID_REFRESH2:
        if (wFlags & DISPATCH_METHOD)
        {
            // The parameter is optional.
            //
            hr = pFrameWebOC->Refresh2(pVar0);
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_REGISTERASBROWSER:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_RegisterAsBrowser(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_RegisterAsBrowser(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_REGISTERASDROPTARGET:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_RegisterAsDropTarget(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_RegisterAsDropTarget(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_RESIZABLE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Resizable(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Resizable(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_SHOWBROWSERBAR:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            CVariant cvarShow;
            CVariant cvarSize;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarSize, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarShow, prefVar);
                pvar++;
                // Intentional fall-through

            default:
                break;
            }

            hr = pFrameWebOC->ShowBrowserBar(pVar0, &cvarShow, &cvarSize);
        }

        break;

    case WEBOC_DISPID_SILENT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Silent(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Silent(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STATUSBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_StatusBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_StatusBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STATUSTEXT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BSTR;
                hr = pFrameWebOC->get_StatusText(&pvarResult->bstrVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BSTR)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_StatusText(V_BSTR(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STOP:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Stop();
        }
        break;

    case WEBOC_DISPID_THEATERMODE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_TheaterMode(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_TheaterMode(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOOLBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_ToolBar(reinterpret_cast<int*>(&pvarResult->lVal));
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_ToolBar(static_cast<int>(V_I4(pVar0)));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOP:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Top(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Top(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOPLEVELCONTAINER:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = pFrameWebOC->get_TopLevelContainer(&pvarResult->boolVal);
        }

        break;

    case WEBOC_DISPID_TYPE:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Type(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_VISIBLE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Visible(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Visible(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_WIDTH:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Width(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Width(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    default:
        hr = THR(pFrameWebOC->_pWindow->Document()->InvokeEx(dispidMember, lcid, wFlags, pDispParams,
                                pvarResult, pExcepInfo, pSrvProvider));
        break;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : QueryService
//
//  Interface : IServiceProvider
//
//  Synopsis  : Per IServiceProvider::QueryService.
//
//--------------------------------------------------------------------------

HRESULT
CFrameWebOC::QueryService(REFGUID guidService,
                          REFIID  riid,
                          void ** ppvObject)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_NOINTERFACE;

    if (   IsEqualGUID(guidService, SID_STopFrameBrowser)
        || IsEqualGUID(guidService, SID_STopLevelBrowser))
    {
        return Doc()->QueryService(guidService, riid, ppvObject);
    }
    else if (IsEqualGUID(guidService, SID_SWebBrowserApp))
    {
        return PrivateQueryInterface(riid, ppvObject);
    }

    return E_NOINTERFACE;
}

// IOleCommandTarget methods
HRESULT CFrameWebOC::QueryStatus(GUID * pguidCmdGroup,
                    ULONG cCmds,
                    MSOCMD rgCmds[],
                    MSOCMDTEXT * pcmdtext)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD * pCmd = NULL;
    HRESULT hr = S_OK;
    UINT        uPropName;
    VARTYPE     vt = VT_EMPTY;
    int         c;
    int         idm;
    GUID *      pguidControl;
    ULONG       ulCmdID;
    CFrameSite *pFrameSite = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (_pWindow->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFrameSite = _pWindow->GetFrameSite();
    
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        Assert(!pCmd->cmdf);

        // Disable Office documents in frameset from showing/hiding toolbars.
        if (pguidCmdGroup == NULL && pCmd->cmdID == OLECMDID_HIDETOOLBARS)
        {
            pCmd->cmdID = MSOCMDSTATE_DISABLED;
            continue;
        }

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);

        uPropName = 0;

        switch (idm)
        {
        case IDM_FONTNAME:
            uPropName = IDS_DISPID_FONTNAME;
            vt = VT_BSTR;
            break;

        case IDM_FONTSIZE:
            uPropName = IDS_DISPID_FONTSIZE;
            vt = VT_CY;
            break;

        case IDM_SUPERSCRIPT:
            uPropName = IDS_DISPID_FONTSUPERSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_SUBSCRIPT:
            uPropName = IDS_DISPID_FONTSUBSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_BOLD:
            uPropName = IDS_DISPID_FONTBOLD;
            vt = VT_BOOL;
            break;

        case IDM_ITALIC:
            uPropName = IDS_DISPID_FONTITAL;
            vt = VT_BOOL;
            break;

        case IDM_UNDERLINE:
            uPropName = IDS_DISPID_FONTUNDER;
            vt = VT_BOOL;
            break;

        case IDM_BACKCOLOR:
            uPropName = IDS_DISPID_BACKCOLOR;
            vt = VT_I4;
            break;

        case IDM_FORECOLOR:
            if (pFrameSite)
            {
                // TODO (jenlc)
                // this is just a transition code, will be changed later for
                // QueryStatus/Exec architecture rework.
                //
                CVariant varargOut;
                DISPID     dispidProp;
                HRESULT    hr;

                dispidProp = DISPID_A_COLOR;
                vt         = VT_I4;
                V_VT(&varargOut) = VT_I4;
                hr = THR_NOTRACE(pFrameSite->ExecSetGetKnownProp(NULL, &varargOut, dispidProp, vt));
                pCmd->cmdf = (hr) ? (MSOCMDSTATE_DISABLED) : (MSOCMDSTATE_UP);
            }
            break;
            
        case IDM_BORDERCOLOR:
            uPropName = IDS_DISPID_BORDERCOLOR;
            vt = VT_I4;
            break;

        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_JUSTIFYGENERAL:
        case IDM_JUSTIFYFULL:
            uPropName = IDS_DISPID_TEXTALIGN;
            vt = VT_I4;
            break;

        case IDM_FLAT:
        case IDM_RAISED:
        case IDM_SUNKEN:
            uPropName = IDS_DISPID_SPECIALEFFECT;
            vt = VT_I4;
            break;

        default:
            //
            // Do a reverse lookup to try and match into the standard cmd set.
            //
            if (OLECMDIDFromIDM(idm, &ulCmdID))
            {
                pguidControl = NULL;
                pCmd->cmdID = ulCmdID;
            }
            else
            {
                pguidControl = pguidCmdGroup;
            }

            if (  !pguidControl
                || pguidControl == (GUID *)&CGID_MSHTML
               )
            {
                hr = THR(_pWindow->Document()->QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));

                // NOTE: hr should be ignored, because we _have_ to process all
                // the cmd's in the array. We will return only the last hr.
                continue;
            }
        }

        if(uPropName && pFrameSite)
        {
            Assert(vt != VT_EMPTY);
            hr = THR_NOTRACE(pFrameSite->QueryStatusProperty(pCmd, uPropName, vt));
        }
        
        if(   (   hr == S_OK
               || hr == OLECMDERR_E_NOTSUPPORTED
              )
           && !pCmd->cmdf
           && pFrameSite
          )
        {
            hr = THR_NOTRACE(pFrameSite->QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}

HRESULT CFrameWebOC::Exec(GUID * pguidCmdGroup,
                          DWORD nCmdID,
                          DWORD nCmdexecopt,
                          VARIANTARG * pvarargIn,
                          VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    UINT            uPropName;
    VARTYPE         vt = VT_EMPTY;
    DWORD           dwValue;
    int             idm;
    DISPID          dispidProp;
    CParentUndoUnit *pCPUU = NULL;
    GUID *          pguidControl;
    ULONG           ulCmdID;
    CFrameSite *    pFrameSite = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
            
    if (_pWindow->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFrameSite = _pWindow->GetFrameSite();
    if (!pFrameSite)
        goto Cleanup;
    
    // Disable Office documents in frameset from showing/hiding toolbars.
    if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        RRETURN(OLECMDERR_E_DISABLED);
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // If the idm represents an undoable property change, open
    // a parent undo unit.

#ifndef NO_EDIT
    if (idm != IDM_UNDO && idm != IDM_REDO)
    {
        pCPUU = pFrameSite->OpenParentUnit(this, IDS_UNDOPROPCHANGE);
    }
#endif // NO_EDIT
    
    switch (idm)
    {
    case IDM_FONTNAME:
        uPropName = IDS_DISPID_FONTNAME;
        vt = VT_BSTR;
        goto ExecSetGetProperty;

    case IDM_FONTSIZE:
    {
        CVariant varTemp;
        CY      cy;

        V_VT(&varTemp) = VT_CY;
        // Need to do convert from long (twips) to CURRENCY for font size
        if (pvarargIn)
        {
            cy.Lo = V_I4(pvarargIn)/20 * 10000;
            cy.Hi = 0;
            V_CY(&varTemp) = cy;
        }

        hr = THR_NOTRACE(pFrameSite->ExecSetGetProperty(
                                            pvarargIn ? &varTemp: NULL,
                                            pvarargOut ? &varTemp : NULL ,
                                            IDS_DISPID_FONTSIZE,
                                            VT_CY));

        if (!hr && pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            cy = V_CY(&varTemp);
            V_I4(pvarargOut) = cy.Lo /10000*20;
        }
        goto Cleanup;
    }

    case IDM_SUPERSCRIPT:
        uPropName = IDS_DISPID_FONTSUPERSCRIPT;
        goto ExecToggleCmd;

    case IDM_SUBSCRIPT:
        uPropName = IDS_DISPID_FONTSUBSCRIPT;
        goto ExecToggleCmd;

    case IDM_BOLD:
        uPropName = IDS_DISPID_FONTBOLD;
        goto ExecToggleCmd;

    case IDM_ITALIC:
        uPropName = IDS_DISPID_FONTITAL;
        goto ExecToggleCmd;

    case IDM_UNDERLINE:
        uPropName = IDS_DISPID_FONTUNDER;
        goto ExecToggleCmd;

    case IDM_BACKCOLOR:
        uPropName = IDS_DISPID_BACKCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_FORECOLOR:
        dispidProp = DISPID_A_COLOR;
    // for this color we need to swap
        if (pvarargIn)
        {
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;
        }
        vt = VT_I4;
        goto ExecKnownDispidProperty;

    case IDM_BORDERCOLOR:
        uPropName = IDS_DISPID_BORDERCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_RAISED:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleRaised;
        goto ExecSetPropertyCmd;

    case IDM_SUNKEN:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleSunken;
        goto ExecSetPropertyCmd;

    default:
        //
        // Do a reverse lookup to try and match into the standard cmd set.
        //
        if (OLECMDIDFromIDM(idm, &ulCmdID))
        {
            pguidControl = NULL;
        }
        else
        {
            pguidControl = pguidCmdGroup;
            ulCmdID = nCmdID;
        }


        if (   !pguidCmdGroup
            || IsEqualGUID(CGID_MSHTML, *pguidCmdGroup)
           )
        {
            OPTIONSETTINGS *pos = Doc()->_pOptionSettings;

            if ((   idm == IDM_IMAGE
                 || (   (   idm == IDM_PASTE
                         || idm == IDM_CUT
                         || idm == IDM_COPY
                        )
                     && (   !pos
                         || !pos->fAllowCutCopyPaste
                        )
                    )
                )
                && !AccessAllowed()
               )
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
            
            hr = THR(_pWindow->Document()->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
        }
        break;
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
    {
        hr = THR(pFrameSite->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
    }
    
    goto Cleanup;

ExecKnownDispidProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(pFrameSite->ExecSetGetKnownProp(pvarargIn,pvarargOut,dispidProp, vt));
    goto Cleanup;

ExecSetGetProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(pFrameSite->ExecSetGetProperty(pvarargIn,pvarargOut,uPropName,vt));
    goto Cleanup;

ExecToggleCmd:
    hr = THR_NOTRACE(pFrameSite->ExecToggleCmd(uPropName));
    goto Cleanup;

ExecSetPropertyCmd:
    hr = THR_NOTRACE(pFrameSite->ExecSetPropertyCmd(uPropName, dwValue));
    goto Cleanup;

Cleanup:
#ifndef NO_EDIT
    if (pFrameSite)
       pFrameSite->CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    
    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------
//
// Member:      CFrameWebOC::AccessAllowed
//
// Synopsis:    Return TRUE if it's ok to access the object model
//              of the dispatch passed in.
//
//---------------------------------------------------------------

BOOL
CFrameWebOC::AccessAllowed()
{
    Assert(!_pWindow->IsPassivated());

    FRAME_WEBOC_PASSIVATE_CHECK(FALSE);
    
    FRAME_WEBOC_VERIFY_WINDOW(FALSE);
    
    if (_pWindow->_pWindowParent)
        return _pWindow->Markup()->AccessAllowed(_pWindow->_pWindowParent->Markup());
    else
        return FALSE;
}


//+---------------------------------------------------------------
//
//   Member : AddConnection, IExternalConnection
//
//----------------------------------------------------------------
HRESULT
CFrameWebOC::AddConnection(DWORD extconn, DWORD reserved)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (extconn & EXTCONN_STRONG)
    {
        return PrivateAddRef();
    }

    //
    // TODO: Change return 0 to return S_OK
    //
    return 0;
}
        

//+---------------------------------------------------------------
//
//  Member : ReleaseConnection, IExternalConnection
//
//----------------------------------------------------------------
HRESULT
CFrameWebOC::ReleaseConnection( DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    //
    // TODO: Change return 0 to return S_OK
    //
    if (!(extconn & EXTCONN_STRONG))
    {
        return 0;
    }

    // in 5.0 releaseConnection only closed the topLevel OC, and then only if it 
    // was hidden.
    // 
    // since we *know* that as a framewebOC we are not the top level, there is nothing
    // that we need to do here.
    /*  code for shdocvw iedisp.cpp:
    _cLocks--;

    if (   _cLocks == 0
        && fLastReleaseCloses)
    {
        VARIANT_BOOL fVisible;
        get_Visible(&fVisible);
        if (!fVisible)
        {
            HWND hwnd = _GetHWND();
            //
            // Notice that we close it only if that's the top level browser
            // to avoid closing a hidden WebBrowserOC by mistake.
            //
            if (hwnd && _psbTop == _psb && !IsNamedWindow(hwnd, c_szShellEmbedding))
            {
                // The above test is necessary but not sufficient to determine if the item we're looking
                // at is the browser frame or the WebBrowserOC.
                TraceMsg(TF_SHDAUTO, "CIEFrameAuto::ReleaseConnection posting WM_CLOSE to %x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
    */
    return PrivateRelease();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameWebOC:GetClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetClassInfo(ITypeInfo ** ppTI)
{
    HRESULT hr = E_FAIL;
    IProvideClassInfo2 *pPCI2 = NULL;
    IWebBrowser2 *pTopWebOC;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    if (_pWindow->IsPassivated())
        goto Cleanup;
    
    pTopWebOC = Doc()->_pTopWebOC;
    if (pTopWebOC)
    {
        hr = THR(pTopWebOC->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI2));
        if (hr)
            goto Cleanup;
        hr = THR(pPCI2->GetClassInfo(ppTI));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pPCI2);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetGUID
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    HRESULT hr = E_FAIL;
    IProvideClassInfo2 *pPCI2 = NULL;
    IWebBrowser2 *pTopWebOC;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (_pWindow->IsPassivated())
        goto Cleanup;

    pTopWebOC = Doc()->_pTopWebOC;
    if (pTopWebOC)
    {
        hr = THR(pTopWebOC->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI2));
        if (hr)
            goto Cleanup;
        hr = THR(pPCI2->GetGUID(dwGuidKind, pGUID));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pPCI2);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetWindow(HWND * phwnd)
{
    HRESULT hr = S_OK;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (!phwnd)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    *phwnd = Doc()->GetHWND();

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::DetachFromWindow
//
//  Synopsis:   Window is passivating or otherwise invalid
//
//--------------------------------------------------------------------------

void CFrameWebOC::DetachFromWindow()
{
    _pWindow = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\shelprot.cxx ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\webocutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       webocutil.cxx
//
//  Contents:   WebBrowser control utility functions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#define MAX_ARGS  10

#define SID_SOmWindow IID_IHTMLWindow2
//+-------------------------------------------------------------------------
//
//  Method    : GetParentWebOC
//
//  Synopsis  : Retrieves the parent IWebBrowser2 of the given window.
//
//  Input     : pWindow      - the given window.
//  Output    : ppWebBrowser - the parent IWebBrowser2 of the given window.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
GetParentWebOC(IHTMLWindow2 * pWindow, IWebBrowser2 ** ppWebBrowser)
{
    HRESULT hr;
    IHTMLDocument2 * pDocument   = NULL;

    Assert(pWindow);
    Assert(ppWebBrowser);

    hr = pWindow->get_document(&pDocument);
    if (hr)
        goto Cleanup;
        
    // Get the parent browser object.
    //
    hr = IUnknown_QueryService(pDocument, 
                               SID_SWebBrowserApp,
                               IID_IWebBrowser2,
                               (void**)ppWebBrowser);
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pDocument);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function  : GetWebOCWindow
//
//  Synopsis  : Returns the IHTMLWindow2 window object of the given 
//              IWebBrowser2 interface.
//
//  Input     : pWebBrowser      - the IWebBrowser2 interface to use
//                                 to retrieve the window object.
//              fGetWindowObject - TRUE indicates that the IHTMLWindow2
//                                 returned should be a CWindow object.
//  Output    : ppWindow         - the retrieved window object.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
GetWebOCWindow(IWebBrowser2  * pWebBrowser,
               BOOL            fGetWindowObject,
               IHTMLWindow2 ** ppWindow)
{
    HRESULT hr;
    IDispatch      * pDispatch = NULL;
    IHTMLDocument2 * pDocument = NULL;
    DISPPARAMS     dispparams  = g_Zero.dispparams;
    CVariant       var;

    Assert(pWebBrowser);
    Assert(ppWindow);

    hr = pWebBrowser->get_Document(&pDispatch);

    // The WebOC sometimes returns hr = S_OK
    // with a null IDispatch.
    //
    if (!pDispatch)
        hr = E_FAIL;

    if (hr)
        goto Cleanup;

    // If the object we got back is a Trident document , then proceed to get
    // its window and use it.
    // Otherwise, we are most likely dealing with a shell window and we should 
    // get IHTMLWindow2 pointer from that window using a QueryService call.
    //
    hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
    if (!hr)
    {
        hr = pDocument->get_parentWindow(ppWindow);
        if (hr)
            goto Cleanup;

        if (fGetWindowObject)
        {
            hr = (*ppWindow)->Invoke(DISPID_WINDOWOBJECT,
                                     IID_NULL,
                                     0,
                                     DISPATCH_PROPERTYGET,
                                     &dispparams,
                                     &var,
                                     NULL,
                                     NULL);
            (*ppWindow)->Release();
            if (hr)
                goto Cleanup;

            hr = (V_DISPATCH(&var))->QueryInterface(IID_IHTMLWindow2, (void**)ppWindow);
         }
    }
    else
    {
        hr = IUnknown_QueryService(pWebBrowser, SID_SOmWindow, IID_IHTMLWindow2, (void**)ppWindow);
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDocument);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method    : InvokeSink
//
//  Synopsis  : Enums the event sink for the given connection points and
//              calls Invoke for each sink.
//
//  Input     : pConnPt     - the connection point whose sinks should
//                            be enumerated and invoked.
//              dispidEvent - the dispid of the event to send to Invoke.
//              pDispParams - the parameters to send to invoke.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

void
InvokeSink(IConnectionPoint * pConnPt,
           DISPID             dispidEvent,
           DISPPARAMS       * pDispParams)
{
    HRESULT     hr;
    CONNECTDATA cd = {0};
    ULONG       cFetched;
    IEnumConnections * pEnumConn = NULL;
    IDispatch        * pDispConn = NULL;

    Assert(pConnPt);
    Assert(pDispParams);
    
    hr = pConnPt->EnumConnections(&pEnumConn);
    if (hr)
        goto Cleanup;

    hr = pEnumConn->Next(1, &cd, &cFetched);
    
    while (S_OK == hr)
    {
        Assert(1 == cFetched);
        Assert(cd.pUnk);

        hr = cd.pUnk->QueryInterface(IID_IDispatch, (void**)&pDispConn);
        if (hr)
            goto Cleanup;

        pDispConn->Invoke(dispidEvent,
                          IID_NULL,
                          LOCALE_USER_DEFAULT,
                          DISPATCH_METHOD,
                          pDispParams,
                          NULL,
                          NULL,
                          NULL);
        ClearInterface(&pDispConn);
        ClearInterface(&cd.pUnk);
        
        hr = pEnumConn->Next(1, &cd, &cFetched);
    }

Cleanup:
    ReleaseInterface(pEnumConn);
    ReleaseInterface(pDispConn);
    ReleaseInterface(cd.pUnk);
}

//+-------------------------------------------------------------------------
//
//  Method   : InvokeEventV
//
//  Synopsis : Invokes the given event sink. This function takes a variable
//             number of arguments and will pack them into a DISPARAMS
//             structure before invoking the event sink.
//
//  Input    : pConnPt     - the connection point to invoke. (Must be NULL
//                           if pBase is set.)
//             pBase       - the object to use for firing events. (Must be
//                           NULL if pConnPt is set.)
//             dispidEvent - the event to fire
//             cArgs       - the number of arguments to send with the event.
//             ...         - variable list of arguments to send with the
//                           event. This argument list must contain the 
//                           type of data preceding each data item.
//
//--------------------------------------------------------------------------

void
InvokeEventV(IConnectionPoint * pConnPt,
             CBase            * pBase,
             DISPID             dispidEvent, 
             int                cArgs,
             ...)
{
    HRESULT    hr;
    DISPPARAMS dispParams = g_Zero.dispparams;
    VARIANTARG rgvarArgList[MAX_ARGS] = {0};

#ifdef DBG
    if (!pConnPt)
        Assert(pBase);
    else
        Assert(!pBase);
#endif
 
    va_list vaArgList;
    va_start(vaArgList, cArgs);

    hr = THR(SHPackDispParamsV(&dispParams, rgvarArgList, cArgs, vaArgList));

    va_end(vaArgList);

    if (!hr)
    {
        if (pConnPt)
        {
            InvokeSink(pConnPt, dispidEvent, &dispParams);
        }
        else 
        {
            pBase->InvokeEvent(dispidEvent, DISPID_UNKNOWN,
                               NULL, NULL, &dispParams);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrlForDisplay
//
//  Synopsis : Formats an URL for display purposes.
//
//  Input    : lpszIn  - the URL to format.
//  Output   : lpszOut - the formatted URL.
//
//--------------------------------------------------------------------------

HRESULT
FormatUrlForDisplay(LPCTSTR lpszIn,
                    LPTSTR  lpszOut,
                    LPDWORD pcchOut)
{
    HRESULT hr;

    Assert(lpszIn);
    Assert(lpszOut);

    if (GetUrlScheme(lpszIn) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(lpszIn, lpszOut, pcchOut, 0));
    }
    else
    {
        hr = THR(UrlUnescape(const_cast<LPTSTR>(lpszIn), lpszOut, pcchOut, 0));
    }
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrl
//
//  Synopsis : Formats an URL for display or parsing.
//
//  Input    : lpszUrl      - the URL to format.
//             lpszLocation - the bookmark location name.
//  Output   : lpszUrl     - the formatted URL.
//
//--------------------------------------------------------------------------

HRESULT
FormatUrl(LPCTSTR lpszUrl,    LPCTSTR lpszLocation,
          LPTSTR  lpszUrlOut, DWORD   cchUrl)
{
    HRESULT hr;
    DWORD   cchOut = cchUrl;
    
    Assert(lpszUrl);
    Assert(lpszUrlOut);

    hr = FormatUrlForDisplay(lpszUrl, lpszUrlOut, &cchOut);
    if (hr)
        goto Cleanup;

    if (lpszLocation && *lpszLocation
        && (cchOut + _tcslen(lpszLocation) + 2) < cchUrl)
    {
        if (*lpszLocation != _T('#'))
        {
            lpszUrlOut[cchOut]   = _T('#');
            lpszUrlOut[++cchOut] = 0;
        }

        _tcscat(lpszUrlOut, lpszLocation);
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method   : GetWebOCDocument
//
//  Synopsis : Returns the IDispatch of the Document contained in the
//             given WebOC instance..
//
//  Input    : pUnk      - the IUnknown of the WebOC.
//  Output   : pDispatch - the IDispatch of the document.
//
//--------------------------------------------------------------------------

HRESULT GetWebOCDocument(IUnknown * pUnk, IDispatch ** ppDispatch)
{
    HRESULT hr;
    IWebBrowser2 * pWebOC = NULL;

    Assert(pUnk);
    Assert(ppDispatch);

    hr = pUnk->QueryInterface(IID_IWebBrowser2, (void**)&pWebOC);
    if (hr)
        goto Cleanup;

    hr = pWebOC->get_Document(ppDispatch);

    // get_Document can return S_OK with a NULL IDispatch.
    //
    if (S_OK == hr && !*ppDispatch)
    {
        hr = E_FAIL;
    }

Cleanup:
    ReleaseInterface(pWebOC);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member   : NavigateWebOCWithBindCtx
//
//  Synopsis : Navigates the WebOC using the given bind context.
//
//----------------------------------------------------------------------------

HRESULT
NavigateWebOCWithBindCtx(IWebBrowser2 * pWebBrowser,
                         VARIANT      * pvarUrl,
                         VARIANT      * pvarFlags,
                         VARIANT      * pvarFrameName,
                         VARIANT      * pvarPostData,
                         VARIANT      * pvarHeaders,
                         IBindCtx     * pBindCtx,
                         LPCTSTR        pchLocation)
{
    Assert(pWebBrowser);

    HRESULT hr;
    BSTR    bstrLocation = NULL;
    IWebBrowserPriv * pWebBrowserPriv = NULL;

    hr = pWebBrowser->QueryInterface(IID_IWebBrowserPriv, (void**)&pWebBrowserPriv);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchLocation, &bstrLocation);
    if (hr)
        goto Cleanup;

    hr = pWebBrowserPriv->NavigateWithBindCtx(pvarUrl, pvarFlags, pvarFrameName,
                                              pvarPostData, pvarHeaders, pBindCtx, bstrLocation);

Cleanup:
    ReleaseInterface(pWebBrowserPriv);
    FormsFreeString(bstrLocation);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\mailprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       mailprot.cxx
//
//  Contents:   Implementation of the mailto protocol
//
//  History:    04-26-97    Yin XIE     Created
//              06-20-97    Yin XIE     Added cc;bcc;body;to
//              06-29-97    Yin XIE     Added non MAPI mail client support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MAPI_H_
#define X_MAPI_H_
#include <mapi.h>
#endif

#ifndef X_MAILPROT_HXX_
#define X_MAILPROT_HXX_
#include "mailprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include <intlcore.hxx>
#endif

#define URL_KEYWL_MAILTO      7           // length of "mailto:"

MtDefine(CMailtoProtocol, Protocols, "CMailtoProtocol")
MtDefine(CMailtoProtocolPostData, CMailtoProtocol, "CMailtoProtocol::_postData")
MtDefine(CMailtoProtocolRecips, CMailtoProtocol, "CMailtoProtocol mailmsg.lpRecips")
MtDefine(CMailtoProtocolNoteText, CMailtoProtocol, "CMailtoProtocol mailmsg.lpszNoteText")
MtDefine(CMailtoProtocolFileDesc, CMailtoProtocol, "CMailtoProtocol MapiFileDesc")
MtDefine(CMailtoProtocolMbfwc, CMailtoProtocol, "CMailtoProtocol::MultiByteFromWideChar")
MtDefine(CMailtoFactory, Protocols, "CMailtoFactory")

//+---------------------------------------------------------------------------
//
//  Function:   CreateMailtoProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateMailtoProtocol(IUnknown *pUnkOuter)
{
    return new CMailtoProtocol(pUnkOuter);
}

const CBase::CLASSDESC CMailtoProtocol::s_classdesc =
{
    &CLSID_MailtoProtocol,          // _pclsid
};

//+---------------------------------------------------------------------------
//
//  Mailto Class Factory
//
//+---------------------------------------------------------------------------

CMailtoFactory g_cfMailtoProtocol   (CreateMailtoProtocol);

// IOInetProtocolInfo methods
HRESULT
CMailtoFactory::QueryInfo(LPCWSTR         pwzUrl,
                          QUERYOPTION     QueryOption,
                          DWORD           dwQueryFlags,
                          LPVOID          pBuffer,
                          DWORD           cbBuffer,
                          DWORD *         pcbBuf,
                          DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch ( QueryOption )
    {
    case QUERY_CAN_NAVIGATE:

        // Need at least a DWORD
        if (cbBuffer < 4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pcbBuf)
        {
            *pcbBuf = 4; // 4 bytes needed for DWORD
        }

        *((DWORD *)pBuffer) = 0; // make sure we return false (0) for mailto prot.
        hr = S_OK;
        break;

    default:
        hr = THR(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pBuffer,
                cbBuffer,
                pcbBuf,
                dwReserved));
        break;
    }

Cleanup:
    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::CMailtoProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CMailtoProtocol::CMailtoProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::~CMailtoProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CMailtoProtocol::~CMailtoProtocol()
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CMailtoProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
#ifdef  NEVER
    TCHAR           ach[pdlUrlLen];
#endif
    DWORD           dwSize;
    
    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    if ((_grfBindF & BINDF_NO_UI) || (_grfBindF & BINDF_SILENTOPERATION))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pOIBindInfo->GetBindString(BINDSTRING_POST_DATA_MIME, &_pszMIMEType, 1, &dwSize));
    // It can fail, but _pszMIMEType will be NULL.
    Assert( !hr || (hr && _pszMIMEType == NULL));

    _cp = _bindinfo.dwCodePage ? _bindinfo.dwCodePage : g_cpDefault;

#ifdef  NEVER
    //
    //  no need to unescape the URL at all
    // 

    //
    // First get the basic url.  Unescape it first.
    //
    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

#endif
    hr = THR(_cstrURL.Set(pchUrl));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }
    
    switch (_bindinfo.dwBindVerb)
    {
    case    BINDVERB_POST:
        void *pData;
        _cPostData = _bindinfo.cbstgmedData;

        if (!_cPostData)
            break;

        _postData = (BYTE *)MemAlloc(Mt(CMailtoProtocolPostData), _cPostData);

        Assert(_bindinfo.stgmedData.tymed == TYMED_HGLOBAL);

        pData = GlobalLock(_bindinfo.stgmedData.hGlobal);
        if (pData)
        {
            memcpy(_postData, pData, _cPostData);
            GlobalUnlock(_bindinfo.stgmedData.hGlobal);
        }
        else
        {
            _cPostData = 0;
        }
        break;
    default:
        _cPostData = 0;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //
    
    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }

Cleanup:
    RRETURN(hr);
}

// keep to,cc,bcc at begining, because we use this in loop
static const MAILTOURLSTRUCT   aURLInfo[]=
{
    {_T("to="),      3,    _T(" ")},
    {_T("cc="),      3,    _T(" ")},
    {_T("bcc="),     4,    _T(" ")},
    {_T("subject="), 8,    NULL},
    {_T("body="),    5,    NULL},
};

TCHAR *
CMailtoProtocol::GetNextRecipient(TCHAR * lptszRecipients)
{
    // get ride of all the spaces first,
    while (*lptszRecipients && *lptszRecipients == _T(' '))
        lptszRecipients++;

    while (*lptszRecipients && *lptszRecipients != _T(' ') && *lptszRecipients != _T(';'))
        lptszRecipients++;

    if (*lptszRecipients)
        return (lptszRecipients);

    return(NULL);
}

HRESULT
CMailtoProtocol::ParseMailToAttr()
{
    HRESULT hr = S_OK;
    int     i = 0;
    int     l = 0;
    TCHAR * pch = NULL;
    TCHAR * pch2 = NULL;

    //
    // The url is of the following syntax:
    // mailto:<email address>?subject=<subject>
    //
    
    Assert(_tcsnipre(TEXT("mailto:"), URL_KEYWL_MAILTO, _cstrURL, -1));

    for (i=0; i<mailtoAttrNUM; i++)
    {
        hr = THR(_aCStrAttr[i].Set(0));
        if (hr)
            goto Cleanup;
    }

    // parse recipients

    pch  = _tcschr(_cstrURL, _T('?'));
    if (pch)
    {
        hr = THR(_aCStrAttr[mailtoAttrTO].Set(_cstrURL+URL_KEYWL_MAILTO, pch-_cstrURL-URL_KEYWL_MAILTO));
    }
    else
    {
        hr = THR(_aCStrAttr[mailtoAttrTO].Set(_cstrURL+URL_KEYWL_MAILTO));
    }
    if (hr)
        goto Cleanup;

    if (!_aCStrAttr[mailtoAttrTO].IsNull() && _aCStrAttr[mailtoAttrTO].Length())
    {
        // append seperator to allow "to:"
        hr  = THR(_aCStrAttr[mailtoAttrTO].Append(aURLInfo[mailtoAttrTO].lptszSep, 1));
        if (hr)
            goto Cleanup;
    }

    // parse attributes

    while (pch)
    {
        pch++;
        for (i = 0; i < mailtoAttrNUM; i ++)
        {
            if (_tcsnipre(aURLInfo[i].lptszAttr, aURLInfo[i].attrLen, pch, -1))
            {
                pch     = _tcschr(pch, _T('='));
                if (!pch)
                    break;

                pch2    = _tcschr(pch, _T('&'));
                if (!pch2)
                {
                    // if no more subject, the next item is the end of URL
                    l = _tcslen(pch) - 1;
                }
                else
                {
                    l = pch2 - pch - 1;    
                }

                if (l <= 0)
                    break;

                hr  = THR(_aCStrAttr[i].Append(++pch, l));
                if (hr)
                    goto Cleanup;

                // append the seperator, if needed

                if (aURLInfo[i].lptszSep)
                {
                    hr  = THR(_aCStrAttr[i].Append(aURLInfo[i].lptszSep, 1));
                    if (hr)
                        goto Cleanup;
                }
                break;
            }
        }

        if (!pch || !*pch)
        {
            // we are at the end of URL
            // let's break
            break;
        }
        pch = _tcschr(pch, _T('&'));
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CMailtoProtocol::ParseAndBind()
{
    CLock           Lock(this);

    HRESULT         hr = S_OK;

    TCHAR *         pch = NULL;

#ifndef UNIX
    HMODULE         hMail = 0;

    TCHAR           aSubject[pdlUrlLen];
#endif

    TCHAR           aRecips[pdlUrlLen];
    TCHAR *         pRecipsPtr[] = {NULL, NULL, NULL};
    int             pRecipsNum[] = {0, 0, 0};
    char            *aBuffer=NULL;
    LPTSTR          pEnd = 0;

    UINT            nRecips = 0;
    UINT            cUnicode = 0;
    UINT            cAnsi = 0;
    UINT            l = 0;

    int             i;

    LPMAPISENDMAIL pfnSendMail = 0;

#ifndef UNIX
    MapiMessage	    mapimsg;
    memset(&mapimsg, 0 , sizeof(mapimsg));

    // speed up mail client launch
    if (!_cPostData)
    {
        hr = RunMailClient();
        if (!_fAborted && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 1, 1);
            _pProtSink->ReportResult(hr, 0, 0);
        }
        goto Cleanup;
    }
#endif

    hr = THR(ParseMailToAttr());
    if (hr)
        goto Cleanup;

    l = pdlUrlLen; 
    pch = aRecips;
    for (i = mailtoAttrTO; i <= mailtoAttrBCC; i++)
    {
        pRecipsPtr[i] = pch;
        cUnicode = _aCStrAttr[i].Length();
        if (cUnicode > l)
        {
            // if too big, truncate
            _tcsncpy(pch, (LPTSTR)_aCStrAttr[i], l-1);
            pch[l-1] = 0;
            pEnd = pch + l;
        }
        else if (cUnicode > 0)
        {
            _tcscpy(pch, (LPTSTR)_aCStrAttr[i]);
            pEnd = pch + cUnicode;
        }
        else
        {
            break;
        }

        while (pch < pEnd)
        {
            pch = GetNextRecipient(pch);
            if (!pch)
                break;
            // if found seperator, and the mail address is good
            *pch = 0;
            pch ++;
            nRecips ++;
            pRecipsNum[i] ++;
        }

        pch = pEnd;
    }

#ifndef UNIX
    if (nRecips)
    {
        mapimsg.lpRecips = (MapiRecipDesc *)MemAlloc(Mt(CMailtoProtocolRecips), nRecips * sizeof(MapiRecipDesc));
        memset(mapimsg.lpRecips, 0 , nRecips * sizeof(MapiRecipDesc));
        if (!mapimsg.lpRecips)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    for (i = mailtoAttrTO; i <= mailtoAttrBCC; i++)
    {
        if (pRecipsNum[i])
        {
            hr = THR(SetMAPIRecipients(&mapimsg, pRecipsPtr[i],
                                                pRecipsNum[i], i));

            if (FAILED(hr))
                goto Cleanup;
            mapimsg.nRecipCount += pRecipsNum[i];
        }
    }

    if (_pszMIMEType && StrCmpIC(_pszMIMEType, CFSTR_MIME_TEXT ) == 0)
    {   
        // This is always 8-bit ASCII because that is what
        // text/plain MIME encoding is!
        LPSTR pszText = (LPSTR) MemAlloc(Mt(CMailtoProtocolNoteText), _cPostData + 1);
        if (pszText)
        {
            memcpy(pszText, _postData, _cPostData);
            pszText[_cPostData] = 0; // terminate.
            mapimsg.lpszNoteText = pszText;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
    {
        hr = THR(SetMAPIAttachement(&mapimsg));

        if (FAILED(hr))
            goto Cleanup;
    }

    cUnicode = _aCStrAttr[mailtoAttrSUBJECT].Length();
    if (!cUnicode && _postData)
    {
        // there is no subject, let's add the default one
        LoadString(GetResourceHInst(), IDS_MAILTO_DEFAULTSUBJECT,
                                aSubject, ARRAY_SIZE(aSubject));
        hr  = THR(_aCStrAttr[mailtoAttrSUBJECT].Set(aSubject));
        if (hr)
            goto Cleanup;
        cUnicode = _aCStrAttr[mailtoAttrSUBJECT].Length();
    }
    if (cUnicode)
    {
        hr = THR(MultiByteFromWideChar((WCHAR *)_aCStrAttr[mailtoAttrSUBJECT],
                                        cUnicode, &aBuffer, &cAnsi));

        if (FAILED(hr))
            goto Cleanup;

        mapimsg.lpszSubject = aBuffer;
        mapimsg.lpszConversationID = aBuffer;
    }

    // KB: Netscape ignore body attribute when there is post data
    // 
    if (!_cPostData || 
       (_pszMIMEType && StrCmpIC(_pszMIMEType, CFSTR_MIME_TEXT ) != 0) )
    {   
        cUnicode = _aCStrAttr[mailtoAttrBODY].Length();
        if (cUnicode)
        {
            hr = THR(MultiByteFromWideChar((WCHAR *)_aCStrAttr[mailtoAttrBODY],
                                            cUnicode, &aBuffer, &cAnsi));

            if (FAILED(hr))
                goto Cleanup;

            mapimsg.lpszNoteText = aBuffer;
        }
    }

    if (_cPostData)
    {
        // for performance reason, we prefer command line
        // we only load the DLLs when this is a form submission
        // and there is a postdata
        hr = LoadMailProvider(&hMail);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (hMail)
    {
        pfnSendMail = (LPMAPISENDMAIL)GetProcAddress(hMail, "MAPISendMail");

        if (!pfnSendMail)
            goto Cleanup;
    }
#endif // !UNIX

    if (!_fAborted && _pProtSink)
    {
        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, 1, 1);
        _pProtSink->ReportResult(hr, 0, 0);
    }

#ifndef UNIX
    if (hMail)
    {
        // this is going to generate memory leak
        DbgMemoryTrackDisable(TRUE);

        pfnSendMail(0,
                    (ULONG)HandleToLong(GetActiveWindow()),
                    &mapimsg,
                    _cPostData ? MAPI_LOGON_UI : (MAPI_LOGON_UI | MAPI_DIALOG),
                    0);
        DbgMemoryTrackDisable(FALSE);
    }
    else
    {
        // need to execute Shell command
        // no form submission supported
        hr = RunMailClient();
    }
#else
    hr = LaunchUnixClient(aRecips, nRecips);
#endif // !UNIX

Cleanup:
    for (i=0; i<mailtoAttrNUM; i++)
    {
        _aCStrAttr[i].Free();
    }

    _cstrURL.Free();

#ifndef UNIX
    ReleaseMAPIMessage(&mapimsg);
    if (hMail)
    {
        FreeLibrary(hMail);
    }
#endif // !UNIX

    if (_postData)
    {
        MemFree(_postData);
        _postData=NULL;
        _cPostData = 0;
    }

    if (_pszMIMEType)
    {
        CoTaskMemFree(_pszMIMEType);
        _pszMIMEType = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::RunMailClient
//
//  Synopsis:   Load mail client in case we can not support form submission
//
//  Returns:    HMODULE
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::RunMailClient()
{
    HRESULT     hr = E_FAIL;
    char        *lpszShellCmd=0;
    UINT        cAnsi = 0;
    HINSTANCE   hinst=0;
    TCHAR       aCaption[64];
    TCHAR       aText[128];

    hr = THR(MultiByteFromWideChar((WCHAR *)_cstrURL, _tcslen(_cstrURL),
                                    &lpszShellCmd, &cAnsi));
    if (FAILED(hr))
        goto Cleanup;
    hinst = ShellExecuteA(  GetActiveWindow(),
                            NULL,
                            lpszShellCmd,
                            NULL,
                            NULL,
                            SW_SHOWNORMAL);

    if ((DWORD_PTR) hinst <= 32)
    {
        hr = GetLastWin32Error();

        if (hr)
        {
            LoadString(GetResourceHInst(), IDS_MESSAGE_BOX_TITLE, aCaption, 64);
            LoadString(GetResourceHInst(), IDS_MAILTO_MAILCLIENTNOTFOUND,
                                            aText, 128);
            MessageBox(
                    GetActiveWindow(),
                    aText,
                    aCaption,  
                    MB_OK | MB_TASKMODAL
                    );
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:

    if (lpszShellCmd)
        MemFree(lpszShellCmd);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::LoadMailProvider
//
//  Synopsis:   Load mail provider MAPI DLL
//
//  Returns:    HMODULE
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::LoadMailProvider(HMODULE *pHMod)
{
    HRESULT hr = S_OK;
    TCHAR   szMAPIDLL[MAX_PATH];
    TCHAR   aBuffer[MAX_PATH];
    DWORD   cb = MAX_PATH;
    HKEY    hkey;
    LONG    lSuccess;
    BOOL    fReadFromHKCU = TRUE;

    *pHMod = NULL;

    lSuccess = RegQueryValue(HKEY_CURRENT_USER,
                            TEXT("Software\\Clients\\Mail"),
                            szMAPIDLL,
                            (LONG *)&cb);

    if (lSuccess != ERROR_SUCCESS || cb <= sizeof(TCHAR))
    {
        fReadFromHKCU = FALSE;
        cb = MAX_PATH;
        lSuccess = RegQueryValue(HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Clients\\Mail"),
                            szMAPIDLL,
                            (LONG *)&cb);
    }

    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    _tcscpy(aBuffer, TEXT("Software\\Clients\\Mail\\"));
    _tcscat(aBuffer, szMAPIDLL);

    lSuccess = RegOpenKeyEx(fReadFromHKCU
                                    ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
                                aBuffer, NULL, KEY_QUERY_VALUE, &hkey);

    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    cb = MAX_PATH;
    lSuccess = RegQueryValueEx(hkey, TEXT("DLLPath"), 0, NULL, (LPBYTE)szMAPIDLL, &cb);

    RegCloseKey(hkey);
    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    cb = ExpandEnvironmentStrings(szMAPIDLL, aBuffer, MAX_PATH);
    if (!cb || (cb > MAX_PATH))
        goto Cleanup;

    *pHMod = LoadLibraryEx(aBuffer, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::SetMAPIRecipients
//
//  Synopsis:   set recipients in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::SetMAPIRecipients(MapiMessage *pmm, LPTSTR lpszRecips, UINT uiNumRecips, int iClass)
{
    HRESULT         hr = S_OK;
    TCHAR           *pNextRecip=0;
    int             i=0, l= uiNumRecips + pmm->nRecipCount;
    UINT            cAnsi = MAX_PATH;

    Assert(l);

    Assert(     iClass==mailtoAttrTO
            ||  iClass==mailtoAttrBCC
            ||  iClass==mailtoAttrCC);

    pNextRecip = lpszRecips;

    for (i = pmm->nRecipCount; i < l; i++)
    {
        hr = THR(MultiByteFromWideChar((WCHAR *)pNextRecip,
                    _tcslen(pNextRecip), &pmm->lpRecips[i].lpszName, &cAnsi));
        if (FAILED(hr))
            goto Cleanup;

        // NOTE (yinxie)
        // Setting address seems to cause MAPI32 to put quote around the
        // well formed adress which causes mail provider to fail the delivery
        // BUG 43627 - need to understand better how to set this field.
        /* comment this out, outlook does not work with address set
        hr = THR(MultiByteFromWideChar((WCHAR *)pNextRecip,
                    _tcslen(pNextRecip), &pmm->lpRecips[i].lpszAddress,&cAnsi));
        if (FAILED(hr))
            goto Cleanup;
        */

        switch(iClass)
        {
        case    mailtoAttrTO:
            pmm->lpRecips[i].ulRecipClass = MAPI_TO;
            break;
        case    mailtoAttrCC:
            pmm->lpRecips[i].ulRecipClass = MAPI_CC;
            break;
        case    mailtoAttrBCC:
            pmm->lpRecips[i].ulRecipClass = MAPI_BCC;
            break;
        }

        pNextRecip = pNextRecip + _tcslen(pNextRecip) + 1;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::SetMAPIAttachement
//
//  Synopsis:   set attachement in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::SetMAPIAttachement(MapiMessage *pmm)
{
    HRESULT     hr = E_FAIL;
    HANDLE      hFile=INVALID_HANDLE_VALUE;
    TCHAR       achTempPath[MAX_PATH];
    UINT        cb = 0;
    ULONG       lcb = 0;
    MapiFileDesc    *pMFD=0;

    if (!_cPostData)
    {
        hr = S_OK;
        goto Cleanup;
    }
    if (!GetTempPath( MAX_PATH, achTempPath ))
        goto Cleanup;
    if (!GetTempFileName( achTempPath, TEXT("ATT"), 0, _achTempFileName ))
        goto Cleanup;

#ifdef  NEVER
    // this is not very safe, let's hold on this.
    TCHAR       *pch=0;
    pch = _tcschr(_achTempFileName, _T('.'));
    _tcscpy(pch, TEXT(".ATT"));
#endif

    hFile = CreateFile(
                        _achTempFileName,
                        GENERIC_READ|GENERIC_WRITE,     // access rights
                        0,                              // share mode
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile==INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    if (!WriteFile(hFile, _postData, _cPostData, &lcb, NULL))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    Assert(_cPostData == lcb);

    pMFD = (MapiFileDesc *)MemAlloc(Mt(CMailtoProtocolFileDesc), sizeof(MapiFileDesc));
    if (!pMFD)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(pMFD, 0 , sizeof(MapiRecipDesc));

    pmm->lpFiles = pMFD;
    pmm->nFileCount = 1;

    hr = THR(MultiByteFromWideChar((WCHAR *)_achTempFileName,
                                    _tcslen(_achTempFileName),
                                    &pMFD->lpszPathName,
                                    &cb));
    if (FAILED(hr))
        goto Cleanup;

    pMFD->lpszFileName = "POSTDATA.ATT";
    pMFD->nPosition = (UINT) -1;                // OS will figure out where to start

Cleanup:
    if (hFile!=INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            hr = E_FAIL;
        }
    }
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::ReleaseMAPIMessage
//
//  Synopsis:   release memory allocations in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

void CMailtoProtocol::ReleaseMAPIMessage(MapiMessage *pmm)
{
    if (!pmm)
        return;
    if (pmm->lpFiles)
    {
        if (pmm->lpFiles->lpszPathName)
        {
            DeleteFile(_achTempFileName);
            MemFree(pmm->lpFiles->lpszPathName);
        }
        MemFree(pmm->lpFiles);
    }
    if (pmm->lpRecips)
    {
        for (int i=0; i < (int)pmm->nRecipCount; i++)
        {
            if (pmm->lpRecips[i].lpszAddress)
            {
                MemFree(pmm->lpRecips[i].lpszAddress);
            }
            if (pmm->lpRecips[i].lpszName)
            {
                MemFree(pmm->lpRecips[i].lpszName);
            }
        }
        MemFree(pmm->lpRecips);
    }
    if (pmm->lpszSubject)
        MemFree(pmm->lpszSubject);
    if (pmm->lpszNoteText)
        MemFree(pmm->lpszNoteText);
}


//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::MultiByteFromWideChar
//
//  Synopsis:   unicode to multibyte conversion
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CMailtoProtocol::MultiByteFromWideChar(WCHAR *lpwcsz, UINT cwc, LPSTR *lppsz, UINT *pcb)
{
    HRESULT hr = S_OK;

    // allocate a buffer which is twice as big as the unicode one (should always enough)
    *pcb = (cwc << 1) + 2;
    *lppsz = (LPSTR)MemAlloc(Mt(CMailtoProtocolMbfwc), *pcb);
    if (!*lppsz)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        DWORD dwState = 0;
        CODEPAGE cp = (_cp == CP_UTF_7) ? CP_UTF_8 : _cp;

        hr = THR(mlang().ConvertStringFromUnicode(&dwState, cp, lpwcsz, &cwc, *lppsz, pcb));
    }

    if (FAILED(hr))
    {
        *pcb = WideCharToMultiByte(CP_ACP, 0, lpwcsz, cwc, *lppsz, *pcb, NULL, NULL);
        if (!*pcb)
        {
            hr = E_FAIL;
        }
    }

Cleanup:

    if (FAILED(hr))
    {
        if (*lppsz)
        {
            MemFree(*lppsz);
            *lppsz = NULL;
        }
    }
    else
    {
        hr = S_OK;
        (*lppsz)[*pcb] = 0;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\misc\weboc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : weboc.h
//
//  Contents: WebOC interface implementations and other WebOC helpers.
//
//  Author  : Scott Roberts (scotrobe)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WEBOC_HXX_
#define X_WEBOC_HXX_
#include "weboc.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_EXDISPID_H_
#define X_EXDISPID_H_
#include "exdispid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_ROOTELEMENT_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

DeclareTag(tagWebOCNavEvents, "WebOC Navigation Events", "Trace WebOC Navigation Events")
DeclareTag(tagWebOCEvents, "WebOC Non-Navigation Events", "Trace WebOC Non-Navigation Events")
ExternTag(tagSecurityContext);
#define DELEGATE_WB_METHOD(base, docptr, fn, args, nargs) \
    HRESULT base::fn args \
    { \
        if (_pWindow->IsPassivated()) \
            return E_FAIL; \
        Assert(docptr); \
        IWebBrowser2 * pTopWebOC = docptr->_pTopWebOC;\
        if (pTopWebOC) \
            return pTopWebOC->fn nargs; \
        return E_FAIL; \
    }
    
//+-------------------------------------------------------------------------
//
//  Method   : NavigateComplete2
//
//  Synopsis : Fires the NavigateComplete2 event to all DWebBrowserEvents2
//             connection points and the FrameNavigateComplete event to all
//             the DWebBrowserEvents connection points of the WebOC.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::NavigateComplete2(COmWindowProxy * pWindowProxy) const
{ 
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());

    DWORD    dwFlags = 0;
    CDoc   * pDoc    = pWindowProxy->Markup()->Doc();
    CVariant cvarWindow(VT_UNKNOWN);
    BOOL     fPrimaryMarkup = pWindowProxy->Markup()->IsPrimaryMarkup();

    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInObjectTag
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    TraceTag((tagWebOCNavEvents, "NavigateComplete2"));
    TraceTag((tagSecurityContext, "NavigateComplete2"));

    // Fire the event to the parent first and then the top-level object.
    //
    if (!fPrimaryMarkup)
    {
        FrameNavigateComplete2(pWindowProxy);
    }

    if (pDoc->_pTridentSvc)
    {
        if (pDoc->_fDontUpdateTravelLog)
            dwFlags |= NAVDATA_DONTUPDATETRAVELLOG;

        if (!fPrimaryMarkup)
            dwFlags |= NAVDATA_FRAMEWINDOW;

        if (pWindowProxy->Window()->_fNavFrameCreation)
           dwFlags |= NAVDATA_FRAMECREATION;

        if (pWindowProxy->Window()->_fRestartLoad)
           dwFlags |= NAVDATA_RESTARTLOAD;

        pDoc->_pTridentSvc->FireNavigateComplete2(pWindowProxy, dwFlags);
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameNavigateComplete2
//
//  Synopsis : Fires the NavigateComplete2 to all DWebBrowserEvents2 
//             connection points and the FrameNavigateComplete event
//             to all the DWebBrowserEvents connection points of WebOC 
//             sinks for a frame.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameNavigateComplete2(COmWindowProxy * pWindowProxy) const
{
    Assert(pWindowProxy);

    HRESULT        hr;
    CVariant       cvarUrl;
    CMarkup      * pMarkup     = pWindowProxy->Markup();
    IWebBrowser2 * pWebBrowser = NULL;

    Assert(pMarkup);

    Assert(!pMarkup->IsPrimaryMarkup());
    Assert(!pMarkup->Doc()->_fDontFireWebOCEvents);
    Assert(!pMarkup->Doc()->_fPopupDoc);
    Assert(!pMarkup->Doc()->_fViewLinkedInWebOC);
    Assert(!pMarkup->Doc()->_fInWebOCObjectTag);
    
    if (   !pWindowProxy->Window()->_pFrameWebOC 
        || !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        return;
    }

    hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                    IID_IWebBrowser2,
                                    (void**)&pWebBrowser);
    if (hr)
        goto Cleanup;

    FormatUrlForEvent(CMarkup::GetUrl(pMarkup),
                      CMarkup::GetUrlLocation(pMarkup),
                      &cvarUrl);

    // Fire the IE4+ event.
    //
    InvokeEventV(NULL,
                 pWindowProxy->Window()->_pFrameWebOC,
                 DISPID_NAVIGATECOMPLETE2, 2,
                 VT_DISPATCH, pWebBrowser,
                 VT_VARIANT|VT_BYREF, &cvarUrl);

    // Fire the IE3 event.
    //
    InvokeEventV(NULL,
                 pWindowProxy->Window()->_pFrameWebOC,
                 DISPID_FRAMENAVIGATECOMPLETE, 1,
                 VT_VARIANT|VT_BYREF, &cvarUrl);

Cleanup:
    ReleaseInterface(pWebBrowser);
}


//+-------------------------------------------------------------------------
//
//  Method   : DocumentComplete
//
//  Synopsis : Fires the DocumentComplete event to all DWebBrowserEvents2
//             connection points of the WebOC.
//
//  Input    : pWindowProxy - the current window's proxy.
//             lpszUrl      - the URL to which we just navigated.
//             lpszLocation - the bookmark location name.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::DocumentComplete(COmWindowProxy * pWindowProxy,
                               LPCTSTR lpszUrl,
                               LPCTSTR lpszLocation /* = NULL */) const
{
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());
    Assert(lpszUrl);

    HRESULT        hr = S_OK;
    CVariant       cvarUrl;
    IWebBrowser2 * pWebBrowser    = NULL;
    CDoc         * pDoc           = pWindowProxy->Markup()->Doc();
    BOOL           fPrimaryMarkup = pWindowProxy->Markup()->IsPrimaryMarkup();

    // Quick return
    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }
        
    TraceTag((tagWebOCNavEvents, "DocumentComplete: Url - %ls Location - %ls",
              lpszUrl, lpszLocation));

    // If this is the top-level window, we must pass the IDispatch of
    // the top-level WebOC with the DocumentComplete event.
    //
    if (!fPrimaryMarkup)
    {
        FormatUrlForEvent(lpszUrl, lpszLocation, &cvarUrl);

        // If this is a frame, we must use the IWebBrowser2 of the
        // CFrameWebOC of the window when firing the event, whether
        // the event is fired to the frame sinks or to the top-level 
        // sinks below.
        //
        hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        if (   pWindowProxy->Window()->_pFrameWebOC
            && pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
        {
            // Fire the event to any direct frame sinks
            //
            InvokeEventV(NULL,
                         pWindowProxy->Window()->_pFrameWebOC,
                         DISPID_DOCUMENTCOMPLETE, 2,
                         VT_DISPATCH, pWebBrowser,
                         VT_VARIANT|VT_BYREF, &cvarUrl);
        }
    }

    if (pDoc->_pTridentSvc)
    {
        pDoc->_pTridentSvc->FireDocumentComplete(pWindowProxy,
                                                 fPrimaryMarkup ? 0 : NAVDATA_FRAMEWINDOW);
    }

Cleanup:
    ReleaseInterface(pWebBrowser);
}

//+-------------------------------------------------------------------------
//
//  Method   : BeforeNavigate2
//
//  Synopsis : Fires the BeforeNavigate2 event to all DWebBrowserEvents2
//             connection points and the FrameBeforeNavigate event to all
//             the DWebBrowserEvents connection points of the WebOC. This
//             method assumes that it is being called in a frame.
//
//  Input    : pWindowProxy  - the current window's proxy.
//             lpszUrl       - the URL to which we are navigating.
//             lpszLocation  - the bookmark location name.
//             lpszFrameName - the target frame name.
//             pPostData     - post data to send with the event.
//             cbPostData    - post data size
//             lpszHeaders   - headers to send with the event.
//  Output   : pfCancel      - TRUE if the operation should be canceled.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::BeforeNavigate2(COmWindowProxy * pWindowProxy,
                              BOOL    * pfCancel,
                              LPCTSTR   lpszUrl,
                              LPCTSTR   lpszLocation,  /* = NULL  */
                              LPCTSTR   lpszFrameName, /* = NULL  */ 
                              BYTE    * pPostData,     /* = NULL  */
                              DWORD     cbPostData,    /* = 0     */
                              LPCTSTR   lpszHeaders,   /* = NULL  */
                              BOOL      fPlayNavSound  /* = FALSE */) const
{
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());
    Assert(pfCancel);
    Assert(lpszUrl);
    Assert(*lpszUrl);

    HRESULT        hr;
    CDoc         * pDoc        = pWindowProxy->Markup()->Doc();
    IWebBrowser2 * pWebBrowser = NULL;
    DWORD          cchOut      = INTERNET_MAX_URL_LENGTH;
    TCHAR          szEvtUrl[INTERNET_MAX_URL_LENGTH];
    DWORD          cchUrl = _tcslen(lpszUrl);

    TraceTag((tagWebOCNavEvents, "BeforeNavigate2: Url - %ls Location - %ls",
              lpszUrl, lpszLocation));

    // Quick return
    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    *pfCancel = FALSE;

    _tcsncpy(szEvtUrl, lpszUrl, ARRAY_SIZE(szEvtUrl) - 1);

    if (lpszLocation && *lpszLocation
        && (cchUrl + _tcslen(lpszLocation) + 2) < ARRAY_SIZE(szEvtUrl))
    {
        if (*lpszLocation != _T('#'))
        {
            szEvtUrl[cchUrl]   = _T('#');
            szEvtUrl[++cchUrl] = 0;
        }

        _tcscat(szEvtUrl, lpszLocation);
    }

    // For compat (see #102943 -- breaks Encarta), we need to canonicalize the url.
    // This will convert some protocols to lower-case). 
    if (FAILED(UrlCanonicalize(szEvtUrl, szEvtUrl, &cchOut, URL_ESCAPE_SPACES_ONLY)))
        goto Cleanup;

    // Fire the event to the parent first and then the top-level object.
    //
    if (!pWindowProxy->Markup()->IsPrimaryMarkup())
    {
        // If this is a frame, we must use the IWebBrowser2 of the
        // CFrameWebOC of the window when firing the event, whether
        // the event is fired to the frame sinks or to the top-level 
        // sinks below.
        //
        hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        if (    pWindowProxy->Window()->_pFrameWebOC
            &&  pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
        {
            FrameBeforeNavigate2(pWindowProxy, pWebBrowser, szEvtUrl, 0,
                                 lpszFrameName, pPostData, cbPostData, lpszHeaders, pfCancel);

            if (*pfCancel)
                goto Cleanup;
        }
    }

    if (pDoc->_pTridentSvc)
    {
        // Fire the event to the top-level object.
        //
        pDoc->_pTridentSvc->FireBeforeNavigate2(pWebBrowser, szEvtUrl, 0, lpszFrameName,
                                                pPostData, cbPostData, lpszHeaders, fPlayNavSound, pfCancel);
    }

Cleanup:
    ReleaseInterface(pWebBrowser);
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameBeforeNavigate2
//
//  Synopsis : Fires the BeforeNavigate2 event to all DWebBrowserEvents2
//             connection points and the FrameBeforeNavigate event to all
//             the DWebBrowserEvents connection points of the frame. This
//             method assumes that it is being called in a frame.
//
//  Input    : pWindowProxy  - the current window's proxy.
//             pDispWindow   - the IDispatch of the current window.
//             cvarUrl       - the URL to which we are navigating.
//             cvarLocation  - the bookmark location name.
//             cvarFrameName - the target frame name.
//             cvarPostData  - post data to send with the event.
//             cvarHeaders   - headers to send with the event.
//  Output   : pfCancel      - TRUE if the operation should be canceled.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameBeforeNavigate2(COmWindowProxy * pWindowProxy,
                                   IWebBrowser2   * pWebBrowser,
                                   LPCTSTR          lpszUrl,
                                   DWORD            dwFlags,
                                   LPCTSTR          lpszFrameName,
                                   BYTE           * pPostData,
                                   DWORD            cbPostData,
                                   LPCTSTR          lpszHeaders,
                                   BOOL           * pfCancel) const
{
    Assert(pWindowProxy);

    CWindow  *  pWindow = pWindowProxy->Window();
    CVariant    cvarUrl(VT_BSTR);
    CVariant    cvarFrameName(VT_BSTR);
    CVariant    cvarFlags(VT_I4);
    CVariant    cvarHeaders(VT_BSTR);
    CVariant    cvarPostData(VT_VARIANT | VT_BYREF);
    VARIANT     varPostDataArray;
    SAFEARRAY * psaPostData = NULL;

    Assert(pWindowProxy->Markup());
    Assert(!pWindowProxy->Markup()->IsPrimaryMarkup());
    Assert(pWebBrowser);
    Assert(pfCancel);

    Assert(!pWindowProxy->Markup()->Doc()->_fDontFireWebOCEvents);
    Assert(!pWindowProxy->Markup()->Doc()->_fPopupDoc);
    Assert(!pWindowProxy->Markup()->Doc()->_fViewLinkedInWebOC);
    Assert(!pWindowProxy->Markup()->Doc()->_fInWebOCObjectTag);

    if (   !pWindow->_pFrameWebOC
        || !pWindow->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        return;
    }

    *pfCancel = FALSE;

    V_BSTR(&cvarUrl) = SysAllocString(lpszUrl);
    V_BSTR(&cvarFrameName) = SysAllocString(lpszFrameName);

    V_I4(&cvarFlags) = dwFlags;

    if (lpszHeaders && *lpszHeaders)
    {
        V_BSTR(&cvarHeaders) = SysAllocString(lpszHeaders);    
    }

    V_VT(&varPostDataArray)    = VT_ARRAY | VT_UI1;
    psaPostData = SafeArrayCreateVector(VT_UI1, 0, cbPostData);
    V_ARRAY(&varPostDataArray) = psaPostData;

    if (!psaPostData)
        goto Cleanup;

    memcpy(psaPostData->pvData, pPostData, cbPostData);

    V_VARIANTREF(&cvarPostData) = &varPostDataArray;

    InvokeEventV(NULL,
                 pWindow->_pFrameWebOC,
                 DISPID_BEFORENAVIGATE2, 7,
                 VT_DISPATCH, pWebBrowser,
                 VT_VARIANT | VT_BYREF, &cvarUrl,
                 VT_VARIANT | VT_BYREF, &cvarFlags,
                 VT_VARIANT | VT_BYREF, &cvarFrameName,
                 VT_VARIANT | VT_BYREF, &cvarPostData,
                 VT_VARIANT | VT_BYREF, &cvarHeaders,
                 VT_BOOL    | VT_BYREF, pfCancel);

    if (*pfCancel)
        goto Cleanup;

    // Fire the IE3 FrameBeforeNavigate event.
    //
    InvokeEventV(NULL,
                 pWindow->_pFrameWebOC,
                 DISPID_FRAMEBEFORENAVIGATE, 6,
                 VT_BSTR, V_BSTR(&cvarUrl),
                 VT_I4,   V_I4(&cvarFlags),
                 VT_BSTR, V_BSTR(&cvarFrameName),
                 VT_VARIANT | VT_BYREF, &varPostDataArray, // cvarPostDataArray instead of cvarPostData for compatibility
                 VT_BSTR, V_BSTR(&cvarHeaders),
                 VT_BOOL | VT_BYREF, pfCancel);

Cleanup:
    if (V_ARRAY(&varPostDataArray))
    {
        SafeArrayDestroy(V_ARRAY(&varPostDataArray));  // CVariant won't destroy the safearray.

        // Don't VariantClear varPostDataArray
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : FireDownloadEvents
//
//  Synopsis : Fires the DownloadBegin and DownloadComplete events. 
//
//  Input    : pWindowProxy  - the current window's proxy.
//
//----------------------------------------------------------------------------

void
CWebOCEvents::FireDownloadEvents(COmWindowProxy    * pWindowProxy,
                                 DOWNLOADEVENTTYPE   eDLEventType) const
{
    Assert(pWindowProxy);
    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);

    // Quick return
    if (   pMarkup->Doc()->_fDontFireWebOCEvents
        || pMarkup->Doc()->_fPopupDoc
        || pMarkup->Doc()->_fViewLinkedInWebOC
        || pMarkup->Doc()->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    // Fire the event to the parent first and then the top-level object.
    //
    FireFrameDownloadEvent(pWindowProxy, eFireDownloadBegin);
    FireFrameDownloadEvent(pWindowProxy, eFireDownloadComplete);

    if (pMarkup->Doc()->_pTopWebOC && pMarkup->Doc()->_pTridentSvc)
    {
        switch(eDLEventType)
        {
        case eFireBothDLEvents:
        case eFireDownloadBegin:
            pMarkup->Doc()->_pTridentSvc->FireDownloadBegin();

            TraceTag((tagWebOCNavEvents, "DownloadBegin"));

            if (eDLEventType != eFireBothDLEvents)
            {
                break;
            }
            // else intentional fall-through

        case eFireDownloadComplete:
            pMarkup->Doc()->_pTridentSvc->FireDownloadComplete();

            TraceTag((tagWebOCNavEvents, "DownloadComplete"));
            break;

        default:
            Assert(0);
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : FireFrameDownloadEvents
//
//  Synopsis : Fires the DownloadBegin if fBegin is TRUE or the 
//             DownloadComplete event if fBegin is FALSE. 
//
//  Input    : pWindowProxy  - the current window's proxy.
//             fBegin        - TRUE for DownloadBegin and FALSE for
//                             DownloadComplete
//
//----------------------------------------------------------------------------

void
CWebOCEvents::FireFrameDownloadEvent(COmWindowProxy    * pWindowProxy,
                                     DOWNLOADEVENTTYPE   eDLEventType) const
{
    Assert(pWindowProxy);
    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);

    // Quick return
    if (    !pWindowProxy->Window()->_pFrameWebOC    
        ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
        ||  pMarkup->IsPrimaryMarkup())
    {
        return;
    }

    switch(eDLEventType)
    {
    case eFireBothDLEvents:
    case eFireDownloadBegin:
        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_DOWNLOADBEGIN, 0);
        TraceTag((tagWebOCNavEvents, "DownloadBegin for Frame Sink"));

        if (eDLEventType != eFireBothDLEvents)
        {
            break;
        }
        // else intentional fall-through

    case eFireDownloadComplete:
        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_DOWNLOADCOMPLETE, 0);
        TraceTag((tagWebOCNavEvents, "DownloadComplete for Frame Sink"));
        break;

    default:
        Assert(0);
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : NavigateError
//
//  Synopsis : Fires the NavigateError event to all DWebBrowserEvents2
//             connection points of the WebOC.
//
//  Input    : pMarkup  - the current markup.
//             hrReason - the binding or WinInet error.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::NavigateError(CMarkup * pMarkup, HRESULT hrReason) const
{
    Assert(!IsBadReadPtr(pMarkup, sizeof(CMarkup)));
    Assert(hrReason != S_OK);

    if (pMarkup && pMarkup->Doc()->_pTridentSvc)
    {
        ITridentService2 * pTridentSvc2;

        HRESULT hr = pMarkup->Doc()->_pTridentSvc->QueryInterface(IID_ITridentService2,
                                                                  (void**)&pTridentSvc2);
        if (S_OK == hr)
        {
            BOOL             fCancel        = FALSE;
            BSTR             bstrFrameName  = NULL;
            BSTR             bstrUrl        = SysAllocString(CMarkup::GetUrl(pMarkup));

            IHTMLWindow2   * pHTMLWindow    = NULL;
            COmWindowProxy * pWindowPending = pMarkup->GetWindowPending();

            Assert(bstrUrl && *bstrUrl);

            if (pWindowPending)
            {
                Assert(!IsBadReadPtr(pWindowPending->Window(), sizeof(CWindow)));
                Assert(!IsBadReadPtr(pWindowPending->Markup(), sizeof(CMarkup)));

                pWindowPending->Window()->get_name(&bstrFrameName);

                // If this is a frame, we pass the IHTMLWindow2
                // ptr of the frame to the FireNavigateError method.
                // Otherwise, we pass NULL in which case the IDispatch
                // passed to the event handler will be the IDispatch
                // of the top-level browser object.
                // 
                if (  pWindowPending->Markup()
                   && !pWindowPending->Markup()->IsPrimaryMarkup())
                {
                    pHTMLWindow = pWindowPending->_pWindow;
                    Assert(!IsBadReadPtr(pHTMLWindow, sizeof(IHTMLWindow2)));

                    pHTMLWindow->AddRef();
                }
            }
            else
            {
                Assert(pMarkup->Window());
                bstrFrameName=SysAllocString(pMarkup->Window()->Window()->_cstrName);
            }

            pTridentSvc2->FireNavigateError(pHTMLWindow, bstrUrl, bstrFrameName,
                                            hrReason, &fCancel);
            pTridentSvc2->Release();

            SysFreeString(bstrUrl);
            SysFreeString(bstrFrameName);
            ReleaseInterface(pHTMLWindow);
        }
    }
}

//+-----------------------------------------------------------------------------
//
//  Method   : WindowClosing
//
//  Synopsis : Fires the WindowClosing event. 
//
//  Input    : pTopWebOC - the top-level WebBrowser control.
//             fIsChild  - TRUE if the window is a child window.
//  Output   : pfCancel  - TRUE is the closing of the window should be canceled.
//
//------------------------------------------------------------------------------

void
CWebOCEvents::WindowClosing(IWebBrowser2 * pTopWebOC,
                            BOOL           fIsChild,
                            BOOL         * pfCancel) const
{
    Assert(pfCancel);

    *pfCancel = FALSE;

    if (pTopWebOC)
    {
        IConnectionPoint * pConnPtTopWB2 = NULL;

        HRESULT hr = GetWBConnectionPoints(pTopWebOC, NULL, &pConnPtTopWB2);

        if (S_OK == hr)
        {
            InvokeEventV(pConnPtTopWB2, NULL, DISPID_WINDOWCLOSING, 2,
                         VT_BOOL, fIsChild,
                         VT_BOOL | VT_BYREF, pfCancel);

            pConnPtTopWB2->Release();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameProgressChange
//
//  Synopsis : Fires the ProgressChange event to all direct frame sinks 
//             of DWebBrowserEvents2
//
//  Input    : pWindowProxy  - the current window's proxy.
//             dwProgressVal - the current progress value. These values
//                             are based on the current state in 
//                             CDwnBindData::OnProgress.
//             dwMaxVal      - the maximum that dwProgressVal can be.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameProgressChange(COmWindowProxy * pWindowProxy,
                                  DWORD            dwProgressVal,
                                  DWORD            dwMaxVal) const
{
    Assert(pWindowProxy);

    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);
    Assert(!pMarkup->IsPrimaryMarkup());

    if (   pMarkup->Doc()->_fDontFireWebOCEvents
        || pMarkup->Doc()->_fPopupDoc
        || pMarkup->Doc()->_fViewLinkedInWebOC
        || pMarkup->Doc()->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    DWORD dwProgress = (_dwProgressMax/dwMaxVal) * dwProgressVal;

    if (   pWindowProxy->Window()->_pFrameWebOC
        && pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        TraceTag((tagWebOCEvents, "FrameProgressChange: dwProgress - %ld dwProgressMax - %ld",
                  dwProgress, _dwProgressMax));

        InvokeEventV(NULL,
                     pWindowProxy->Window()->_pFrameWebOC,
                     DISPID_PROGRESSCHANGE,
                     2,
                     VT_I4, dwProgress,
                     VT_I4, _dwProgressMax);
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameTitleChange
//
//  Synopsis : Fires the TitleChange event to all direct 
//             DWebBrowserEvents2 frame sinks.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameTitleChange(COmWindowProxy * pWindowProxy) const
{
    if (pWindowProxy)
    {
        CMarkup * pMarkup = pWindowProxy->Markup();

        Assert(pMarkup);

        if (    pMarkup->Doc()->_fDontFireWebOCEvents
            ||  pMarkup->IsPrimaryMarkup()
            ||  !pWindowProxy->Window()->_pFrameWebOC
            ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
            ||  pMarkup->Doc()->_fPopupDoc
            ||  pMarkup->Doc()->_fViewLinkedInWebOC
            ||  pMarkup->Doc()->_fInWebOCObjectTag
            ||  pWindowProxy->Window()->_fCreateDocumentFromUrl)
        {
            return;
        }

        // Get the title
        //
        CTitleElement * pTitleElement = pMarkup->GetTitleElement();

        if (pTitleElement && pTitleElement->Length())
        {
            BSTR    bstrTitle = NULL;
            LPCTSTR lpszTitle = pTitleElement->GetTitle();

            if (NULL == lpszTitle)
            {
                bstrTitle = SysAllocString(_T(""));
            }
            else
            {
                bstrTitle = SysAllocString(lpszTitle);
            }

            InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_TITLECHANGE, 1,
                         VT_BSTR, bstrTitle);

            SysFreeString(bstrTitle);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameStatusTextChange
//
//  Synopsis : Fires the StatusTextChange event to all direct
//             DWebBrowserEvents2 frame sinks.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameStatusTextChange(COmWindowProxy * pWindowProxy,
                                    LPCTSTR          lpszStatusText) const
{
    if (pWindowProxy)
    {
        CMarkup * pMarkup = pWindowProxy->Markup();
        BSTR      bstrStatusText = NULL;

        if (    pMarkup->Doc()->_fDontFireWebOCEvents
            ||  pMarkup->IsPrimaryMarkup()
            ||  !pWindowProxy->Window()->_pFrameWebOC
            ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
            ||  pMarkup->Doc()->_fPopupDoc
            ||  pMarkup->Doc()->_fViewLinkedInWebOC
            ||  pMarkup->Doc()->_fInWebOCObjectTag
            ||  pWindowProxy->Window()->_fCreateDocumentFromUrl)
        {
            return;
        }

        Assert(pMarkup);

        if (NULL == lpszStatusText)
        {
            bstrStatusText = SysAllocString(_T(""));
        }
        else
        {
            bstrStatusText = SysAllocString(lpszStatusText);
        }

        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_STATUSTEXTCHANGE, 1,
                     VT_BSTR, bstrStatusText);

        SysFreeString(bstrStatusText);
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : GetWBConnectionPoints
//
//  Synopsis  : Retrieves the DWebBrowserEvents and/or the
//              DWebBrowserEvents2 connections points of the given
//              WebBrowser interface. 
//
//  Input     : pTopWebOC    - the top-level WebBrowser object.
//  Output    : ppConnPtWBE  - the DWebBrowserEvents connection point.
//              ppConnPtWBE2 - the DWebBrowserEvents2 connection point.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
CWebOCEvents::GetWBConnectionPoints(IWebBrowser2      * pWebBrowser,
                                    IConnectionPoint ** ppConnPtWBE,
                                    IConnectionPoint ** ppConnPtWBE2) const
{
    HRESULT hr;
    IConnectionPointContainer * pConnPtCont = NULL;

    Assert(pWebBrowser);
    Assert(ppConnPtWBE || ppConnPtWBE2);  // Must pass one.

    // Get the connection points for
    // DWebBrowserEvents and DWebBrowserEvents2
    //
    hr = pWebBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnPtCont);
    if (hr)
        goto Cleanup;

    if (ppConnPtWBE)
    {
        hr = pConnPtCont->FindConnectionPoint(DIID_DWebBrowserEvents, ppConnPtWBE);
        if (hr)
            goto Cleanup;
    }

    if (ppConnPtWBE2)
    {
        hr = pConnPtCont->FindConnectionPoint(DIID_DWebBrowserEvents2, ppConnPtWBE2);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pConnPtCont);
    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrlForEvent
//
//  Synopsis : Formats an URL for use in a WebOC event.
//
//  Input    : lpszUrl      - the URL to format.
//             lpszLocation - the bookmark location name.
//  Output   : pcvarUrl     - the formatted URL.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FormatUrlForEvent(LPCTSTR    lpszUrl,
                                LPCTSTR    lpszLocation,
                                CVariant * pcvarUrl)
{
    HRESULT hr;
    TCHAR   szOut[INTERNET_MAX_URL_LENGTH];
    
    Assert(lpszUrl);
    Assert(pcvarUrl);

    hr = FormatUrl(lpszUrl, lpszLocation, szOut, ARRAY_SIZE(szOut));

    if (S_OK == hr)
        lpszUrl = szOut;

    V_VT(pcvarUrl)   = VT_BSTR;
    V_BSTR(pcvarUrl) = SysAllocString(lpszUrl);
}

// IWebBrowser2, IWebBrowserApp, and IWebBrowser
// method implementations.
//

STDMETHODIMP
CFrameWebOC::GoBack()
{
    IOmHistory * pHistory = NULL;
    HRESULT hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!_pWindow)
    {
        goto Cleanup;
    }

    hr = _pWindow->get_history(&pHistory);

    if (hr)
    {
        goto Cleanup;
    }

    pHistory->back(NULL);

Cleanup:

    ReleaseInterface(pHistory);
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CFrameWebOC::GoForward()
{
    IOmHistory * pHistory = NULL;
    HRESULT hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!_pWindow)
    {
        goto Cleanup;
    }

    hr = _pWindow->get_history(&pHistory);

    if (hr)
    {
        goto Cleanup;
    }

    pHistory->forward(NULL);

Cleanup:

    ReleaseInterface(pHistory);
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CFrameWebOC::GoHome()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    return GoStdLocation(eHomePage, _pWindow);
}

STDMETHODIMP
CFrameWebOC::GoSearch()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    return GoStdLocation(eSearchPage, _pWindow);
}

STDMETHODIMP
CFrameWebOC::Navigate(BSTR bstrUrl,
                      VARIANT * pvarFlags,
                      VARIANT * pvarFrameName,
                      VARIANT * pvarPostData,
                      VARIANT * pvarHeaders)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (_pWindow)
    {
        DWORD dwFlags = DOCNAVFLAG_DOCNAVIGATE ; 
        
        //
        // marka - I've added some of the flags that we have equivalents for
        // we don't have equivalents for write/read to cache
        // 
        if ( pvarFlags )
        {
            DWORD dwInFlags = 0 ;
            
            if (pvarFlags->vt == VT_I4)
            {
                dwInFlags = pvarFlags->lVal;
            }
            else if (pvarFlags->vt == VT_I2)
            {
                dwInFlags = pvarFlags->iVal;
            }

            if (dwInFlags & navOpenInNewWindow)
            {
                dwFlags |= DOCNAVFLAG_OPENINNEWWINDOW ;
            }        
            
            if (dwInFlags & navNoHistory)
            {
                dwFlags |= DOCNAVFLAG_DONTUPDATETLOG;
            }
        }
        
        BSTR    bstrFramename = NULL;
        if(pvarFrameName)
        {
            bstrFramename = ((V_VT(pvarFrameName) == VT_BSTR) ? V_BSTR(pvarFrameName) : NULL);
        }
        
        RRETURN(_pWindow->SuperNavigate(bstrUrl,
                                        NULL,
                                        NULL,
                                        bstrFramename,
                                        pvarPostData,
                                        pvarHeaders,
                                        dwFlags));
    }

    RRETURN(E_FAIL);
}
                  
STDMETHODIMP
CFrameWebOC::Refresh()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    CVariant cvarLevel(VT_I4);

    V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE;
    
    RRETURN(Refresh2(&cvarLevel));
}

STDMETHODIMP
CFrameWebOC::Refresh2(VARIANT * pvarLevel)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    long lLevel = OLECMDIDF_REFRESH_NO_CACHE;
    
    if (pvarLevel)
    {
        VARTYPE vt = V_VT(pvarLevel);
        if (VT_I4 == vt)
            lLevel = V_I4(pvarLevel);
        else if (VT_I2 == vt)
            lLevel = (long)V_I2(pvarLevel);
    }
    
    RRETURN(GWPostMethodCall(_pWindow->_pMarkup->Window(),
            ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                          lLevel, FALSE,
                          "COmWindowProxy::ExecRefreshCallback"));
}

STDMETHODIMP
CFrameWebOC::Stop()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    Assert(_pWindow->_pMarkup);
    return _pWindow->_pMarkup->ExecStop(FALSE, FALSE);
}

STDMETHODIMP
CFrameWebOC::get_Document(IDispatch ** ppDisp)
{
    HRESULT hr;
    IHTMLDocument2 * pHTMLDocument = NULL;

    Assert(ppDisp);

    *ppDisp = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (IsPassivated() || IsPassivating())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = _pWindow->get_document(&pHTMLDocument);
    if (hr)
        goto Cleanup;

    hr = pHTMLDocument->QueryInterface(IID_IDispatch, (void **) ppDisp);

Cleanup:
    ReleaseInterface(pHTMLDocument);
    return hr;
}

CFrameSite *
CWindow::GetFrameSite()
{
    if (Doc()->_fViewLinkedInWebOC && IsPrimaryWindow())
    {
        COmWindowProxy * pOmWindowProxy = Doc()->GetOuterWindow();

        if (pOmWindowProxy)
            return pOmWindowProxy->Window()->GetFrameSite();
    }

    {
        CRootElement * pRoot = _pMarkup->Root();
        CElement * pMasterElement;

        if (pRoot == NULL)
            return NULL;

        if (!pRoot->HasMasterPtr())
            return NULL;

        pMasterElement = pRoot->GetMasterPtr();
        if (    pMasterElement->Tag() != ETAG_IFRAME
            &&  pMasterElement->Tag() != ETAG_FRAME)
            return NULL;

        return DYNCAST(CFrameSite, pMasterElement);
    }
}

COmWindowProxy *
CWindow::GetInnerWindow()
{
    IDispatch * pDispatch = NULL;
    CMarkup * pMarkup = NULL;
    HRESULT hr;

    Assert(_punkViewLinkedWebOC);

    hr = GetWebOCDocument(_punkViewLinkedWebOC, &pDispatch);
    if (hr)
        goto Cleanup;

    hr = pDispatch->QueryInterface(CLSID_CMarkup, (void **) &pMarkup);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);

    if (pMarkup)
        return pMarkup->Window();
    else
        return NULL;
}

HRESULT
SetPositionAbsolute(CElement * pElement, CStyle ** ppStyle)
{
    HRESULT hr;
    CAttrArray **ppAA;
    BSTR bstrAbsolute = SysAllocString(_T("absolute"));

    if (!pElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!bstrAbsolute)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElement->GetStyleObject(ppStyle);
    if (hr)
       goto Cleanup;

    ppAA = (*ppStyle)->GetAttrArray();
    if (!ppAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = (*ppStyle)->put_StringHelper(bstrAbsolute, &s_propdescCStyleposition.a, ppAA);

Cleanup:
    SysFreeString(bstrAbsolute);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//  Method   : get_Left
//
//  Synopsis : Get the left of the current weboc
//
//  Output   : The left of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Left(long * plLeft)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plLeft = g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetPositionLeft());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Left(long * plLeft)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Left(plLeft);
}

//+-------------------------------------------------------------------------
//  Method   : put_Left
//
//  Synopsis : Put the left of the current weboc
//
//  Output   : The left of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Left(long lLeft)
{
    HRESULT hr;
    CStyle * pStyle;

    hr = SetPositionAbsolute(GetFrameSite(), &pStyle);
    if (hr)
        goto Cleanup;

    hr = pStyle->put_pixelLeft(g_uiDisplay.DeviceFromDocPixelsX(lLeft));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Left(long lLeft)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Left(lLeft);
}

//+-------------------------------------------------------------------------
//  Method   : get_Top
//
//  Synopsis : Get the top of the current weboc
//
//  Output   : The top of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Top(long * plTop)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plTop = pLayout->GetPositionTop();

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Top(long * plTop)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Top(plTop);
}

//+-------------------------------------------------------------------------
//  Method   : put_Top
//
//  Synopsis : Put the top of the current weboc.
//
//  Output   : The top of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Top(long lTop)
{
    HRESULT hr;
    CStyle * pStyle;

    hr = SetPositionAbsolute(GetFrameSite(), &pStyle);
    if (hr)
        goto Cleanup;

    hr = pStyle->put_pixelTop(lTop);
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Top(long lTop)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    
    return _pWindow->put_Top(lTop);
}

//+-------------------------------------------------------------------------
//  Method   : get_Width
//
//  Synopsis : Get the width of the current weboc
//
//  Output   : The width of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Width(long * plWidth)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plWidth = g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetWidth());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Width(long * plWidth)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Width(plWidth);
}

//+-------------------------------------------------------------------------
//  Method   : put_Width
//
//  Synopsis : Put the width of the current weboc.
//
//  Output   : The width of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Width(long lWidth)
{
    HRESULT hr;
    CStyle * pStyle;
    CElement * pElement = GetFrameSite();

    if (!pElement)
        return E_FAIL;

    hr = pElement->GetStyleObject(&pStyle);
    if (hr)
       goto Cleanup;

    hr = pStyle->put_pixelWidth(g_uiDisplay.DeviceFromDocPixelsX(lWidth));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Width(long lWidth)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Width(lWidth);
}

//+-------------------------------------------------------------------------
//  Method   : get_Height
//
//  Synopsis : Get the height of the current weboc
//
//  Output   : The height of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Height(long * plHeight)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plHeight = g_uiDisplay.DocPixelsFromDeviceY(pLayout->GetHeight());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Height(long * plHeight)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Height(plHeight);
}

//+-------------------------------------------------------------------------
//
//  Method   : put_Height
//
//  Synopsis : Put the height of the current weboc.
//
//  Output   : The height of the current weboc.
//
//  First implementation mwatt
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Height(long lHeight)
{
    HRESULT hr;
    CStyle * pStyle;
    CElement * pElement = GetFrameSite();

    if (!pElement)
        return E_FAIL;

    hr = pElement->GetStyleObject(&pStyle);
    if (hr)
       goto Cleanup;

    hr = pStyle->put_pixelHeight(g_uiDisplay.DeviceFromDocPixelsY(lHeight));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Height(long lHeight)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Height(lHeight);
}

STDMETHODIMP 
CFrameWebOC::get_LocationName(BSTR * pbstrLocationName)
{
    HRESULT  hr = E_FAIL;
    LPOLESTR lpszLocationName = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    hr = _pWindow->GetTitle(&lpszLocationName);
    if (hr)
        goto Cleanup;

    *pbstrLocationName = SysAllocString(lpszLocationName);

Cleanup:

    if (lpszLocationName)
    {
        CoTaskMemFree(lpszLocationName);
    }
    
    return hr;
}

STDMETHODIMP
CFrameWebOC::get_LocationURL(BSTR * pbstrLocationURL)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    Assert(pbstrLocationURL);
    *pbstrLocationURL = SysAllocString(CMarkup::GetUrl(_pWindow->_pMarkup));
    
    return (*pbstrLocationURL ? S_OK : E_FAIL);
}

STDMETHODIMP
CFrameWebOC::get_Busy(VARIANT_BOOL * pvfBusy)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
  
    *pvfBusy = _pWindow->_pMarkup->GetLoaded() ? VARIANT_FALSE
                                     : VARIANT_TRUE;
    
    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_HWND(LONG_PTR* plHWND)
{
    Assert(plHWND);
    *plHWND = NULL;
    
    return E_FAIL;
}

// Copied from shell\lib\varutilw.cpp
LPCTSTR
VariantToStrCast(const VARIANT *pvar)
{
    LPCTSTR psz = NULL;

    if (pvar->vt == (VT_BYREF | VT_VARIANT) && pvar->pvarVal)
        pvar = pvar->pvarVal;

    if (pvar->vt == VT_BSTR)
        psz = pvar->bstrVal;
    return psz;
}

STDMETHODIMP
CFrameWebOC::Navigate2(VARIANT * pvarUrl,
                       VARIANT * pvarFlags,
                       VARIANT * pvarFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders)
{
    HRESULT         hr = E_FAIL;
    CMarkup *       pMarkupNew  = NULL;
    const TCHAR *   pszUrl      = NULL;
    
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    if (_pWindow->IsPassivated())
    {
        goto Cleanup;
    }

    if (pvarUrl)
    {
        pszUrl = VariantToStrCast(pvarUrl);
    }

    if (pszUrl)
    {
        hr = Navigate(BSTR(pszUrl),
                      pvarFlags,
                      pvarFrameName,
                      pvarPostData,
                      pvarHeaders);
        goto Cleanup;
    }

    // Trying to navigate to a pidl or something that we don't know how
    // to navigate to. Viewlink to WebOC and delegate the navigation to it.
    hr = Doc()->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, _pWindow->_pWindowProxy);
    if (hr)
        goto Cleanup;
    _pWindow->ClearMetaRefresh();
    hr = pMarkupNew->ViewLinkWebOC(pvarUrl, pvarFlags, pvarFrameName, pvarPostData, pvarHeaders);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::get_Parent(IDispatch ** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (!ppDisp)
        return E_POINTER;

    *ppDisp = NULL;

    if (_pWindow->IsPassivated())
        return E_FAIL;

    // If we are in a frame, we return the IDispatch of the containing window object.
    // Otherwise, delegate to the top-level WebOC if there is one.
    //
    if (_pWindow->_pWindowParent)
    {
        HRESULT hr;
        IHTMLWindow2   * pHTMLWindow   = NULL;
        IHTMLDocument2 * pHTMLDocument = NULL;

        hr = _pWindow->get_parent(&pHTMLWindow);
        if (hr)
            goto Cleanup;

        hr = DYNCAST(CWindow, pHTMLWindow)->get_document(&pHTMLDocument);
        if (hr)
            goto Cleanup;

        hr = pHTMLDocument->QueryInterface(IID_IDispatch, (void **) ppDisp);

    Cleanup:
        ReleaseInterface(pHTMLWindow);
        ReleaseInterface(pHTMLDocument);
        return hr;
    }
    else
    {
        IWebBrowser2 * pTopWebOC = Doc()->_pTopWebOC;

        if (pTopWebOC)
            return pTopWebOC->get_Parent(ppDisp);

        return E_FAIL;
    }
}

STDMETHODIMP 
CFrameWebOC::get_Container(IDispatch ** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    // Container property is same as the parent unless 
    // there is no parent. In either case, delegate to get_Parent.
    //
    return get_Parent(ppDisp);
}

STDMETHODIMP
CFrameWebOC::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    if (!pBool)
        return E_POINTER;

    *pBool = VARIANT_FALSE;

    if (_pWindow->IsPassivated())
        return E_FAIL;

    // If we are in a frame, return FALSE. Otherwise,
    // delegate to the top-level WebOC object.
    //
    if (!_pWindow->_pWindowParent)
    {
        IWebBrowser2 * pTopWebOC = Doc()->_pTopWebOC;

        if (pTopWebOC)
            return pTopWebOC->get_TopLevelContainer(pBool);
    }

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_ReadyState(READYSTATE * plReadyState)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    if (!plReadyState)
        return E_POINTER;

    *plReadyState = (READYSTATE) _pWindow->Document()->GetDocumentReadyState();

    return S_OK;
}

//+-------------------------------------------------------------------
//
// For 5.0 compat, this code was transplanted from shv.ocx
//
//--------------------------------------------------------------------
STDMETHODIMP 
CFrameWebOC::ExecWB ( OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT * pvaIn, VARIANT * pvaOut)
{
    HRESULT    hr = E_FAIL;
    BSTR       bstrUrl = NULL;
    CElement * pElement = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);

    pElement = _pWindow->GetFrameSite();
    
    if ( pElement->IsDesignMode() )
        goto Cleanup;

    // If the optional argument pvargin is not specified make it VT_EMPTY.
    if (   pvaIn 
        && (V_VT(pvaIn) == VT_ERROR) 
        && (V_ERROR(pvaIn) == DISP_E_PARAMNOTFOUND))
    {
        V_VT(pvaIn) = VT_EMPTY;
        V_I4(pvaIn) = 0;
    }

    // If the optional argument pvargin is not specified make it VT_EMPTY.
    if (   pvaOut 
        && (V_VT(pvaOut) == VT_ERROR) 
        && (V_ERROR(pvaOut) == DISP_E_PARAMNOTFOUND))
    {
        V_VT(pvaOut) = VT_EMPTY;
        V_I4(pvaOut) = 0;
    }

    if (   cmdID == OLECMDID_PASTE
        || cmdID == OLECMDID_COPY
        || cmdID == OLECMDID_CUT
        || cmdID == OLECMDID_PRINT)
    {
        if (SUCCEEDED(get_LocationURL(&bstrUrl)))
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            ZoneCheckUrlEx(bstrUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                           URLACTION_SCRIPT_SAFE_ACTIVEX, 0, NULL);

            if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
            {
                if (cmdID == OLECMDID_PRINT)
                {
                    // (if the UI-less- request flag is set we need to unset it.)
                    if (cmdexecopt == OLECMDEXECOPT_DONTPROMPTUSER)
                        cmdexecopt = OLECMDEXECOPT_DODEFAULT;
                }
                else
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
            else if (cmdID != OLECMDID_PRINT)
            {
                ZoneCheckUrlEx(bstrUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_SCRIPT_PASTE, 0, NULL);

                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }

    // now pass along the call into our Doc (not to the topOC)
    if (_pWindow->Document())
        hr = _pWindow->Document()->Exec(NULL, cmdID, cmdexecopt, pvaIn, pvaOut); 

Cleanup:
    if (bstrUrl)
        SysFreeString(bstrUrl);

    return hr;
}

STDMETHODIMP 
CFrameWebOC::QueryStatusWB (OLECMDID cmdID, OLECMDF * pcmdf)
{
    CElement * pElement = _pWindow->GetFrameSite();
    OLECMD     rgcmd;
    HRESULT    hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (pElement->IsDesignMode())
        goto Cleanup;

    rgcmd.cmdID = cmdID;
    rgcmd.cmdf = *pcmdf;

    if (_pWindow->Document())
        hr = _pWindow->Document()->QueryStatus(NULL, 1, &rgcmd, NULL);

    *pcmdf = (OLECMDF) rgcmd.cmdf;
    
Cleanup:
    return hr;
}

// These methods maintain a status variable but not action is taken as defined by the current design

#ifndef BOOL_TO_VARIANTBOOL
#define BOOL_TO_VARIANTBOOL(b) ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#endif

#ifndef VARIANTBOOL_TO_BOOL
#define VARIANTBOOL_TO_BOOL(vb) ((vb == VARIANT_FALSE) ? FALSE : TRUE)
#endif

HRESULT  
CFrameWebOC::ClientToWindow(int * pcx, int * pcy)
{
    // For compatibility with IE5, we return E_FAIL;
    return E_FAIL;
}

HRESULT  
CFrameWebOC::get_Visible(VARIANT_BOOL * pvfVisible)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pvfVisible==NULL) 
       return E_INVALIDARG;

    *pvfVisible = BOOL_TO_VARIANTBOOL(_fVisible);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_Visible(VARIANT_BOOL vfVisible)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    _fVisible = VARIANTBOOL_TO_BOOL(vfVisible);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_StatusBar(VARIANT_BOOL * pvfStatusBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfStatusBar==NULL) 
       return E_INVALIDARG; 

    *pvfStatusBar = BOOL_TO_VARIANTBOOL(_fStatusBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_StatusBar(VARIANT_BOOL vfStatusBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fStatusBar = VARIANTBOOL_TO_BOOL(vfStatusBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_StatusText(BSTR * pbstrStatusText)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pbstrStatusText==NULL) 
       return E_INVALIDARG;

    pbstrStatusText = NULL;
    return E_FAIL;
}

HRESULT  
CFrameWebOC::put_StatusText(BSTR bstrStatusText)
{
    return E_FAIL;
}

HRESULT  
CFrameWebOC::get_ToolBar(int * pnToolBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pnToolBar==NULL) 
       return E_INVALIDARG;

    *pnToolBar = BOOL_TO_VARIANTBOOL(_fToolBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_ToolBar(int nToolBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fToolBar = BOOL_TO_VARIANTBOOL(nToolBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_MenuBar(VARIANT_BOOL * pvfMenuBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfMenuBar==NULL) 
       return E_INVALIDARG;

    *pvfMenuBar = BOOL_TO_VARIANTBOOL(!_fMenuBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_MenuBar(VARIANT_BOOL vfMenuBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fMenuBar = !(VARIANTBOOL_TO_BOOL(vfMenuBar));
    return S_OK;
}

HRESULT  
CFrameWebOC::get_FullScreen(VARIANT_BOOL *pvfFullScreen)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfFullScreen==NULL) 
       return E_INVALIDARG;

    *pvfFullScreen = BOOL_TO_VARIANTBOOL(_fFullScreen);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_FullScreen(VARIANT_BOOL vfFullScreen)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fFullScreen = VARIANTBOOL_TO_BOOL(vfFullScreen);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_TheaterMode(VARIANT_BOOL * pvfTheaterMode)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfTheaterMode==NULL) 
       return E_INVALIDARG;

    *pvfTheaterMode = BOOL_TO_VARIANTBOOL(_fTheaterMode);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_TheaterMode(VARIANT_BOOL vfTheaterMode)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    _fTheaterMode = VARIANTBOOL_TO_BOOL(vfTheaterMode);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_AddressBar(VARIANT_BOOL * pvfAddressBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pvfAddressBar==NULL) 
       return E_INVALIDARG;

    *pvfAddressBar = BOOL_TO_VARIANTBOOL(_fAddressBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_AddressBar(VARIANT_BOOL vfAddressBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fAddressBar = VARIANTBOOL_TO_BOOL(vfAddressBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_Resizable(VARIANT_BOOL * pvfResizable)
{
    // For compatibility with IE5, we return E_NOTIMPL;
    return E_NOTIMPL;
}

HRESULT 
CFrameWebOC::put_Resizable(VARIANT_BOOL vfResizable)
{
    return E_NOTIMPL;
}


HRESULT
CFrameWebOC::get_RegisterAsBrowser(VARIANT_BOOL * pfRegister)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    *pfRegister = BOOL_TO_VARIANTBOOL(_fShouldRegisterAsBrowser);

    return S_OK;
}

HRESULT
CFrameWebOC::put_RegisterAsBrowser(VARIANT_BOOL fRegister)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(fRegister);

    return S_OK;
}

HRESULT 
CFrameWebOC::get_Application(IDispatch** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    (*ppDisp) = this;
    AddRef();

    return S_OK;
}

HRESULT
CFrameWebOC::Quit()
{
    return E_FAIL;
}

DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Type, (BSTR * pbstrType), (pbstrType))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), PutProperty, (BSTR bstrProperty, VARIANT varValue), (bstrProperty, varValue))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), GetProperty, (BSTR bstrProperty, VARIANT * pvarValue), (bstrProperty, pvarValue))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Name, (BSTR * pbstrName), (pbstrName))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_FullName, (BSTR * pbstrFullName), (pbstrFullName))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Path, (BSTR * pbstrPath), (pbstrPath))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), ShowBrowserBar, (VARIANT * pvarClsid, VARIANT * pvarShow, VARIANT * pvarSize),
                                                   (pvarClsid, pvarShow, pvarSize))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Offline, (VARIANT_BOOL * pvfOffline), (pvfOffline))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_Offline, (VARIANT_BOOL vfOffline), (vfOffline))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Silent, (VARIANT_BOOL * pvfSilent), (pvfSilent))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_Silent, (VARIANT_BOOL vfSilent), (vfSilent))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_RegisterAsDropTarget, (VARIANT_BOOL * pvfRegister), (pvfRegister))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_RegisterAsDropTarget, (VARIANT_BOOL vfRegister), (vfRegister))

// Helper Functions
//

//+-------------------------------------------------------------------------
//
//  Method   : GetStdLocation
//
//  Synopsis : Retrieves the URL of the given standard location type.
//
//  Input    : eLocation - the standard location.
//  Output   : bstrUrl   - the URL of the standard location.
//
//--------------------------------------------------------------------------

HRESULT
GetStdLocation(STDLOCATION eLocation, BSTR * bstrUrl)
{
    HRESULT hr = E_FAIL;
    LPCTSTR lpszName = NULL;
    WCHAR   szPath[INTERNET_MAX_URL_LENGTH];
    DWORD   cbSize = sizeof(szPath);
    DWORD   dwType;
    HKEY    hkey = NULL;

    Assert(bstrUrl);

    // We are currently retrieving the home page from 
    // HKCU. If the user hasn't set a home
    // page yet, we must get the home page from 
    // HKEY_LOCAL_MACHINE: "Default_Page_URL" or "Start Page".
    //
    switch(eLocation)
    {
        case eHomePage:
            lpszName = _T("Start Page");
            break;

        case eSearchPage:
            lpszName = _T("Search Page");
            break;
            
        default:
            goto Cleanup;
    }
    
    hr = RegOpenKey(HKEY_CURRENT_USER,
                    _T("Software\\Microsoft\\Internet Explorer\\Main"),
                    &hkey);
    if (hr)
        goto Cleanup;

    hr = RegQueryValueEx(hkey, lpszName,
                         0, &dwType, (LPBYTE)szPath, &cbSize);
    if (hr)
        goto Cleanup;

    *bstrUrl = SysAllocString(szPath);
    
Cleanup:    
    if (hkey)
        RegCloseKey(hkey);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : GoStdLocation
//
//  Synopsis : Navigates to a standard location - home, search, etc.
//
//  Input    : eLocation - the standard location.
//  Output   : pWindow   - the window to use when navigating.
//
//--------------------------------------------------------------------------

HRESULT
GoStdLocation(STDLOCATION eLocation, CWindow * pWindow)
{
    HRESULT hr;
    BSTR    bstrUrl = NULL;

    Assert(pWindow);
    
    hr = GetStdLocation(eLocation, &bstrUrl);   
    if (hr)
        goto Cleanup;

    hr = pWindow->navigate(bstrUrl);

Cleanup:
    SysFreeString(bstrUrl);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\unixprot.cxx ===
#include "headers.hxx"
#ifndef X_INETREG_H_
#define X_INETREG_H_
#include "inetreg.h"
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_MAPI_H_
#define X_MAPI_H_
#include <mapi.h>
#endif

#ifndef X_MAILPROT_HXX_
#define X_MAILPROT_HXX_
#include "mailprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#define URL_KEYWL_MAILTO      7           // length of "mailto:"
#define MAILTO_OPTION         TEXT(" mailto ")

#define OE_MAIL_COMMAND_KEY TEXT("Software\\Clients\\Mail\\Outlook Express\\shell\\open\\command")
#define OE_URL_COMMAND_NAME TEXT("URLCommand")
#define MAILTO_URL_HEADER TEXT("mailto:")
#define IE_HOME_ENVIRONMENT TEXT("MWDEV")

HRESULT _UnixLaunchOE(TCHAR *pszRecips, UINT nRecips)
{
    HRESULT     hr = S_OK;
    TCHAR       *tszCommand = NULL;
    TCHAR       tszIEHome[MAX_PATH];
    DWORD       cchIEHome;
    DWORD       cchCommand;
    DWORD       dwDisposition;
    TCHAR       *pchPos;
    BOOL        bMailed;
    STARTUPINFO stInfo;
    HKEY        hkey = NULL;
    int         i;

    cchIEHome = GetEnvironmentVariable(IE_HOME_ENVIRONMENT, tszIEHome, MAX_PATH);
    if (cchIEHome)
    {
        _tcscat(tszIEHome, TEXT("/bin"));
    }
    else
    {
        return E_FAIL;
    }

    hr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, OE_MAIL_COMMAND_KEY, 0, NULL, 0, KEY_READ, NULL, &hkey, &dwDisposition);
    if (hr != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)NULL, &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    cchCommand += _tcslen(tszIEHome) + _tcslen(MAILTO_URL_HEADER) + _tcslen(pszRecips) + 1;
    tszCommand = new TCHAR[cchCommand];

    _tcscpy(tszCommand, tszIEHome);
    _tcscat(tszCommand, TEXT("/"));
    dwDisposition = _tcslen(tszCommand);

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)(&tszCommand[dwDisposition]), &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    _tcscat(tszCommand, MAILTO_URL_HEADER);

    for (i = 1; i < nRecips; i ++)
        *(pszRecips + _tcslen(pszRecips)) = TEXT(';');
    _tcscat(tszCommand, pszRecips);


    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcess(NULL, tszCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);

Cleanup:
    if ( hkey != NULL )
        RegCloseKey(hkey);

    if (tszCommand)
        delete(tszCommand);

    return hr;
}

HRESULT
CMailtoProtocol::LaunchUnixClient(TCHAR *aRecips, UINT nRecips)
{
    HRESULT         hr = S_OK;

    TCHAR           tszCommand[pdlUrlLen];
    TCHAR           tszExpandedCommand[pdlUrlLen];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey = NULL;
    DWORD   dw;
    TCHAR *pchPos;
     BOOL bMailed;
    STARTUPINFO stInfo;

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwUseOEMail;

    hr = SHGetValue(IE_USE_OE_MAIL_HKEY, IE_USE_OE_MAIL_KEY, IE_USE_OE_MAIL_VALUE, 
                    &dwType, (void*)&dwUseOEMail, &dwSize);
    if ((hr) && (dwType != REG_DWORD))
    {
        // The default value for mail is FALSE
        dwUseOEMail = FALSE;
    }
    if (dwUseOEMail)
    {
        return _UnixLaunchOE(aRecips, nRecips);
    }

    tszCommand[0] = 0;

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAILCLIENTS, 0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;
    dw = pdlUrlLen;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, pdlUrlLen);
    if (!dw)
     {
        _tcscpy(tszExpandedCommand, tszCommand);
     }
    _tcscpy(tszCommand, TEXT("X "));
    _tcscat(tszCommand, tszExpandedCommand);
    for (i = _tcslen(tszCommand); i > 0; i--)
	if (tszCommand[i] == '/')
	{
	    tszCommand[i] = '\0';
	    break;
	}
    _tcscat(tszCommand, MAILTO_OPTION);
    nCommandSize = _tcslen(tszCommand);
    for (i = 1; i < nRecips; i ++)
	*(aRecips + _tcslen(aRecips)) = ' ';
    _tcscat(tszCommand, aRecips);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcess(tszExpandedCommand, tszCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);
 
Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\abtprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       abtprot.cxx
//
//  Contents:   Implementation of the about protocol
//
//  History:    07-23-97    krisma     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_ABTPROT_HXX_
#define X_ABTPROT_HXX_
#include "abtprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

MtDefine(Protocols, Mem, "Protocols")
MtDefine(CAboutProtocol, Protocols, "CAboutProtocol")

// Some Static strings that we use to read from the registry
static TCHAR szAboutKey[] = 
    _T("SOFTWARE\\Microsoft\\Internet Explorer\\AboutURLs");

extern BOOL g_fInIexplorer;
extern BOOL g_fInExplorer;

//+---------------------------------------------------------------------------
//
//  Function:   CreateAboutProtocol
//
//  Synopsis:   Creates an about Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateAboutProtocol(IUnknown *pUnkOuter)
{
    return new CAboutProtocol(pUnkOuter);
}

CAboutProtocolCF   g_cfAboutProtocol(CreateAboutProtocol);


#define GetStdLocationORD   150
typedef HRESULT (APIENTRY* PFNGETSTDLOCATION)(LPTSTR pszPath, DWORD cchPath, UINT id);

HRESULT GetShellStdLocation(LPTSTR lpszBuffer, DWORD cchBuffer, DWORD dwID)
{
    HRESULT hres = E_FAIL;
    HINSTANCE hinst;

    if (0 < cchBuffer)
        *lpszBuffer = 0;
        
    hinst = LoadLibrary(TEXT("shdocvw.dll"));
    if (hinst)
    {
        PFNGETSTDLOCATION pfn = (PFNGETSTDLOCATION)GetProcAddress(hinst, MAKEINTRESOURCEA(GetStdLocationORD));

        if (pfn)
        {
            hres = pfn(lpszBuffer, cchBuffer, dwID);
        }
        FreeLibrary(hinst);
    }

    return hres;
}

HRESULT
CAboutProtocolCF::QueryInfo(
    LPCWSTR       pwzUrl, 
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID        pvBuffer,
    DWORD         cbBuffer,
    DWORD  *      pcbBuffer,
    DWORD         dwReserved)
{
    HRESULT     hr;
    HKEY        hkey = NULL;
    TCHAR *     szRegValue;
    LONG        lRegErrorValue;
    TCHAR       szBuffer[pdlUrlLen];
    DWORD       dwType;
    DWORD       cbData = sizeof(szBuffer);
    DWORD       dwRetval;

    //
    // Before resolving through registry, see if the \1 part forces the URL to be unsecure
    //

    if (QueryOption == QUERY_IS_SECURE && !HasSecureContext(pwzUrl))
    {
        dwRetval = FALSE;
        goto ReturnDword;
    }

    szRegValue = _tcschr(pwzUrl, ':');

    szRegValue += 1;
    
    lRegErrorValue = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, szAboutKey, NULL, KEY_READ,
        &hkey);
    if (lRegErrorValue != ERROR_SUCCESS)
    {
        hr = INET_E_DEFAULT_ACTION;
        goto Cleanup;
    }

    lRegErrorValue = SHQueryValueEx(hkey, szRegValue, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
    if (lRegErrorValue == ERROR_SUCCESS)
    {
        // If the value is in the registry as a DWORD then it must be a special Shell location.  Map the ID to the URL
        // by passing it to GetStdLocation.
        if (dwType == REG_DWORD)
        {
            if (FAILED(GetShellStdLocation(szBuffer, ARRAY_SIZE(szBuffer), *((LPDWORD)szBuffer))))
            {
                hr = INET_E_DEFAULT_ACTION;
                goto Cleanup;
            }
        }
        hr = THR(CoInternetQueryInfo(szBuffer, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved));
    }
    else
    {
        switch (QueryOption)
        {
        case QUERY_USES_NETWORK:
        case QUERY_IS_CACHED:
            dwRetval = FALSE;
            goto ReturnDword;
            
        case QUERY_IS_SECURE:
            dwRetval = TRUE;
            goto ReturnDword;
            
        default:
            hr = INET_E_DEFAULT_ACTION;
            break;
        }
    }

Cleanup:
    if (hkey)
        RegCloseKey(hkey);
    RRETURN1(hr, INET_E_DEFAULT_ACTION);

ReturnDword:
    if (!pvBuffer || cbBuffer < sizeof(DWORD))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pcbBuffer)
    {
        *pcbBuffer = sizeof(DWORD);
    }
    
    *(DWORD *)pvBuffer = dwRetval;
    hr = S_OK;

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo. Reads new URL from 
//              registry and replaces the about: URL.
//
//----------------------------------------------------------------------------

HRESULT
CAboutProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr        cstr;
    HRESULT     hr = INET_E_DEFAULT_ACTION;
    HKEY        hkey = NULL;
    TCHAR      *szRegValue;
    TCHAR      *pchSourceUrl = NULL;
    LONG        lRegErrorValue;
    DWORD       dwType;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_CANONICALIZE)
    {
        static TCHAR       szBuffer[pdlUrlLen];
        DWORD       cbData = sizeof(szBuffer);

        //
        // Search for an embedded \1.  If it's found, then strip it
        // out because that's the source url of this protocol.
        //
        pchSourceUrl = _tcschr(pwzUrl, _T('\1'));
        hr = pchSourceUrl ? 
                THR(cstr.Set(pwzUrl, pchSourceUrl - pwzUrl)) : 
                THR(cstr.Set(pwzUrl));

        szRegValue = _tcschr(cstr, ':');
        szRegValue += 1;

        //
        //  Special case for about:blank so
        //  we don't lose security info
        //
        if (!_tcsicmp(_T("blank"), szRegValue))
        {
            hr = THR(super::ParseUrl(
                pwzUrl,
                ParseAction,
                dwFlags,
                pwzResult,
                cchResult,
                pcchResult,
                dwReserved));
            goto Cleanup;
        }


        lRegErrorValue = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, szAboutKey, NULL, KEY_READ,
            &hkey);
        if (lRegErrorValue != ERROR_SUCCESS)
        {
            hr=INET_E_DEFAULT_ACTION;
            goto Cleanup;
        }

        lRegErrorValue = SHQueryValueEx(
            hkey, szRegValue, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
        if (lRegErrorValue == ERROR_SUCCESS)
        {
            // If the value is in the registry as a DWORD then it must be a special Shell location.  Map the ID to the URL
            // by passing it to GetStdLocation.
            if (dwType == REG_DWORD)
            {
                if (FAILED(GetShellStdLocation(szBuffer, ARRAY_SIZE(szBuffer), *((LPDWORD)szBuffer))))
                {
                    hr = INET_E_DEFAULT_ACTION;
                    goto Cleanup;
                }
            }
        }
        else
        {
            //
            //  If the registry value does not exist, procede as 
            //  normal (write the string to the document).
            //
            //  [kusumav] 03/07/2002 - Disabled about protocol except for ones we register
            //  We now navigate to about:NavigationCanceled for any about URL except
            //  the ones in HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\AboutURLs
            //  This is the first place where we block non-blessed about urls.
            //  If we don't find the NavigationCanceled key, then our protocol handler will
            //  be called and we return E_ACCESSDENIED in the Start method which will 
            //  effectively block whatever slips through this check
            //
            //
            lRegErrorValue = SHQueryValueEx(
                hkey, L"NavigationCanceled", NULL, &dwType, (LPBYTE)szBuffer, &cbData);
            
            if ((!g_fInExplorer && !g_fInIexplorer) || (lRegErrorValue != ERROR_SUCCESS && (dwType != REG_SZ)))
            {
                hr = THR(super::ParseUrl(
                    pwzUrl,
                    ParseAction,
                    dwFlags,
                    pwzResult,
                    cchResult,
                    pcchResult,
                    dwReserved));
                goto Cleanup;
            }
        }
        
        *pcchResult = cchResult;
        hr = UrlCanonicalize(szBuffer, pwzResult, pcchResult, dwFlags);

    }
    else if (ParseAction == PARSE_SECURITY_URL)
    {
        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;
        
        *pcchResult = cstr.Length() + 1;
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room, so fill in *pcchResult with size we need
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcscpy(pwzResult, cstr);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }
    
Cleanup:
    if (hkey)
        RegCloseKey(hkey);

    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CAboutProtocol::s_classdesc =
{
    &CLSID_AboutProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::CAboutProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CAboutProtocol::CAboutProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::~CAboutProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CAboutProtocol::~CAboutProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CAboutProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;
    
    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        if ((g_fInExplorer || g_fInIexplorer) && _tcsicmp(_T("about:blank"), pchUrl))
        {
            // Block all about urls. Return E_ACCESSDENIED instead of E_FAIL
            // since Trident doesn't handle all errors, it will handle this one correctly
            // We will never come to this codepath for the blessed about urls 
            // since we map them to res:// urls in our ParseAndBind method above
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //
    
    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

void
CAboutProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}

HRESULT
CAboutProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchBuf = NULL;
    CStr            cstrBuf;
    ULONG           cb = NULL;
    CROStmOnBuffer *prostm = NULL;
    HINSTANCE       hInst = NULL;

    //
    // The url is of the following syntax:
    // about:<name>
    //
    
    Assert(_tcsnipre(_T("about:"), 6, _cstrURL, -1));

    //
    // Do the binding.
    //

    pch = _tcschr(_cstrURL, ':');
    if (!pch)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    pch++;

    {
        TCHAR szBuf[] = _T(" <HTML>");
        szBuf[0] = NATIVE_UNICODE_SIGNATURE;

        hr = THR(cstrBuf.Set(szBuf));
    }

    if (hr)
        goto Cleanup;

    //
    //  Special case for about:blank. Just show a blank page.
    //
    if (_tcsicmp(_T("blank"), pch))
    {
        hr = THR(cstrBuf.Append(pch));
        if (hr)
            goto Cleanup;
    }

    hr = THR(cstrBuf.Append(_T("</HTML>")));
    if (hr)
        goto Cleanup;

    pchBuf = cstrBuf;
    cb = (cstrBuf.Length() + 1) * sizeof(TCHAR);

    hr = THR(_pProtSink->ReportProgress(
            BINDSTATUS_MIMETYPEAVAILABLE, 
            _T("text/html")));
    if (hr)
        goto Cleanup;

    Assert(pchBuf);
    
    // cb includes the null terminator
    
    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    _pStm = (IStream *)prostm;
    _pStm->AddRef();
        
Cleanup:
    if (!_fAborted)
    {
        if (!hr)
        {
            _ReportData(cb);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }
    
    if (hInst)
    {
        FreeLibrary(hInst);
    }
    if (prostm)
    {
        prostm->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       resprot.cxx
//
//  Contents:   Implementation of the resource protocol
//
//  History:    02-12-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "resprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

#if DBG==1
#define TID GetCurrentThreadId()
#endif

MtDefine(CResProtocol, Protocols, "CResProtocol")
MtDefine(CResProtocolDoParseAndBind_pb, Protocols, "CResProtocol::DoParseAndBind pb")
MtDefine(CViewSourceProtocol, Protocols, "CViewSourceProtocol")

//+---------------------------------------------------------------------------
//
//  Function:   CreateResProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateResProtocol(IUnknown *pUnkOuter)
{
    return new CResProtocol(pUnkOuter);
}

CResProtocolCF   g_cfResProtocol(CreateResProtocol);


//+---------------------------------------------------------------------------
//
//  Method:     CrackResUrl
//
//  Synopsis:   Breaks res: URL into its component strings.
//              NOTE: pcstrResName and pcstrRID are allowed to be NULL.
//                    The caller needs only to pass in CStr*'s for the
//                    components they want.
//
//
//  Arguments:  pchURL          Url of the following syntax:
//
//              res://<dll name and location>[/<resource type>]/<resource id>
//
//              pcstrResName    CStr to hold <dll name and location>
//                              The path may not contain '/' characters
//              pcstrResType    CStr to hold <resource type>
//              pcstrRID        CStr to hold <resource id>
//
//----------------------------------------------------------------------------

HRESULT
CrackResUrl(const TCHAR* pchURL, CStr* pcstrResName, CStr* pcstrResType, CStr* pcstrRID)
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchNext = NULL;
    TCHAR           achURL[pdlUrlLen];
    DWORD           cchURL;

    Assert (pchURL && _tcsnipre(_T("res:"), 4, pchURL, -1));

    //
    // NOTENOTE: pchstrResName, pcstrResType, and pcstrRID are
    //           allowed to be NULL!
    //

    // Unescape the URL.
    hr = THR(CoInternetParseUrl(
            pchURL,
            PARSE_ENCODE,
            0,
            achURL,
            ARRAY_SIZE(achURL),
            &cchURL,
            0));
    if (hr)
        goto Cleanup;

    pch = _tcschr(achURL, _T(':'));
    if (!pch)
    {
        goto SyntaxError;
    }

    if (!(_tcsnipre(_T("://"), 3, pch, -1)))
    {
        goto SyntaxError;
    }

    pch += 3;

    //
    // Now look for the dll name.  Basically find the next '/'.
    // Everything to the left of this is the dll name.
    //

    pchNext = _tcschr(pch, _T('/'));
    if (!pchNext)
    {
        goto SyntaxError;
    }

    if (pcstrResName)
    {
        hr = THR(pcstrResName->Set(pch, pchNext - pch));
        if (hr)
            goto Cleanup;
    }

    pch = pchNext + 1;
    pchNext = _tcschr(pch, _T('/'));

    if (pchNext)
    {
        //
        // We've found a second '/', which means that the URL
        // contains both a resource-ID and resource type.
        //

        if (pcstrResType)
        {
            hr = THR(pcstrResType->Set(pch, pchNext - pch));
            if (hr)
                goto Cleanup;

            LONG lTemp;
            HRESULT hr2 = THR_NOTRACE(ttol_with_error(*pcstrResType, &lTemp));

            if (SUCCEEDED(hr2))
            {
                // 
                // Only accept numbers that are max 16 bits.  FindResource
                // can only accept such numbers.  
                //

                if (lTemp & 0xFFFF0000)
                    goto SyntaxError;
                    
                hr = pcstrResType->Set(_T("#"));
                if (hr)
                    goto Cleanup;

                hr = pcstrResType->Append(pch, pchNext - pch);
                if (hr)
                    goto Cleanup;
            }
            else if (hr2 != E_INVALIDARG)
            {
                hr = hr2;
                goto Cleanup;
            }
        }

        pch = pchNext + 1;
    }
    else if (pcstrResType)
    {
        hr = THR(pcstrResType->Set(_T("")));
    }

    if (pcstrRID)
    {
        LONG lTemp;
        HRESULT hr2 = THR_NOTRACE(ttol_with_error(pch, &lTemp));
        if (SUCCEEDED(hr2))
        {
            // 
            // Only accept numbers that are max 16 bits.  FindResource
            // can only accept such numbers.  
            //

            if (lTemp & 0xFFFF0000)
                goto SyntaxError;
                
            hr = THR(pcstrRID->Set(_T("#")));
            if (hr)
                goto Cleanup;
                
            hr = THR(pcstrRID->Append(pch));
            if (hr)
                goto Cleanup;
        }
        else if (hr2 == E_INVALIDARG)
        {
            hr = THR(pcstrRID->Set(pch));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = hr2;
            goto Cleanup;
        }
    }


Cleanup:
    RRETURN(hr);

SyntaxError:
    hr = MK_E_SYNTAX;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

#define FILEPROT_PREFIX_LEN 7

HRESULT
CResProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ParseAction == PARSE_SECURITY_URL)
    {
        CStr            cstrResName;
        DWORD           cchNewUrlLen;
        TCHAR           achFullResourceName [pdlUrlLen];

        *pcchResult = FILEPROT_PREFIX_LEN;

        hr = THR(CrackResUrl (pwzUrl, &cstrResName, NULL, NULL));
        if (hr)
            goto Cleanup;

#ifndef WIN16
        {
            CStrIn  strinResName ((LPWSTR)cstrResName);
            CStrOut stroutFile (achFullResourceName, pdlUrlLen);
            char *  pstrFileName;

            cchNewUrlLen = ::SearchPathA (NULL,
                                          strinResName,
                                          NULL,
                                          pdlUrlLen,
                                          stroutFile,
                                          &pstrFileName);
        }
#else
        {
            char *  pstrFileName;
            cchNewUrlLen = ::SearchPathA (NULL,
                                          cstrResName,
                                          NULL,
                                          pdlUrlLen,
                                          achFullResourceName,
                                          &pstrFileName);
        }
#endif // WIN16

        //
        // The returned path is now stored as a TCHAR in achFullResourceName.
        //

        if (!cchNewUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        *pcchResult += cchNewUrlLen + 1; // total mem needed includes \0 terminator

        if (*pcchResult > pdlUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        if (*pcchResult > cchResult)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcsncpy(pwzResult, _T("file://"), FILEPROT_PREFIX_LEN);
        _tcscpy(pwzResult + FILEPROT_PREFIX_LEN, achFullResourceName);

        Assert (_tcslen(pwzResult) + 1 == *pcchResult);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CResProtocol::s_classdesc =
{
    &CLSID_ResProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::QueryInfo
//
//  Synopsis:   for QUERY_IS_SAFE
//
//----------------------------------------------------------------------------
HRESULT
CResProtocolCF::QueryInfo(
    LPCWSTR       pwzUrl, 
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID        pvBuffer,
    DWORD         cbBuffer,
    DWORD  *      pcbBuffer,
    DWORD         dwReserved)
{
    //
    // intercept is-safe
    //

    if (QueryOption == QUERY_IS_SAFE)
    {
        if (!pvBuffer || cbBuffer < sizeof(DWORD))
            return E_FAIL;

        if (pcbBuffer)
            *pcbBuffer = sizeof(DWORD);
        
        *(DWORD *)pvBuffer = TRUE;
        return S_OK;
    }
    else
    {
        RRETURN(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pvBuffer,
                cbBuffer,
                pcbBuffer,
                dwReserved));
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CResProtocol::CResProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CResProtocol::~CResProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;

    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //

    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::ParseAndBind()
{
    RRETURN(DoParseAndBind(_cstrURL, _cstrResName, _cstrResType, _cstrRID, &_pStm, this));
}


void
CResProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::DoParseAndBind
//
//  Synopsis:   Static helper to actually perform the binding of protocol.
//
//  Arguments:  pchURL          Url to bind to [needed]
//              cstrRID         Resource id extracted from url [needed]
//              cstrResName     Resource dll name extracted from url [needed]
//              ppStm           Stream of data from resource [needed]
//              pProt           Protocol object that's involved [optional]
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::DoParseAndBind(
    TCHAR *pchURL, 
    CStr &cstrResName,
    CStr &cstrResType,
    CStr &cstrRID,
    IStream **ppStm,
    CResProtocol *pProt)
{
    HRESULT         hr = S_OK;
    TCHAR *         pchBuf = NULL;
    ULONG           cb = 0;
    CROStmOnBuffer *prostm = NULL;
    HINSTANCE       hInst = NULL;
    BYTE *          pb = NULL;
    IBindCtx *      pBCtx = NULL;
    TCHAR *         pchMime = NULL;
    
    hr = THR(CrackResUrl (pchURL, &cstrResName, &cstrResType, &cstrRID));
    if (hr)
        goto Cleanup;

    //
    // Do the binding.
    //

    Assert((TCHAR *)cstrResName && (TCHAR *)cstrRID);

    if (cstrResName.Length() >= MAX_PATH)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hInst = LoadLibraryEx(
                cstrResName, 
                NULL, 
                DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);
    if (!hInst)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    if (cstrResType.Length())
    {
        pchBuf = (TCHAR *)GetResource(
            hInst,
            cstrRID,
            cstrResType,
            &cb);
    }
    else
    {
        pchBuf = (TCHAR *)GetResource(
            hInst,
            cstrRID,
            MAKEINTRESOURCE(RT_HTML),
            &cb);
        //
        //  dialog resource type may be RT_FILE
        //
        if (!pchBuf)
        {
            pchBuf = (TCHAR *)GetResource(
                hInst,
                cstrRID,
                MAKEINTRESOURCE(RT_FILE),
                &cb);
        }
    }

    if (!pchBuf)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
            
    }
    
    Assert(pchBuf);

    // ISSUE - res: bitmap hack (t-chrisr)
    //
    // We want to be able to load bitmaps from resource files.  The problem is
    // that resource files don't store bitmaps quite like .bmp files store bitmaps
    // (resource files lack the BITMAPFILEHEADER header).  So we'll construct a
    // "real" bitmap here.
    //
    // <HACK>

    if (_tcsequal(cstrResType, _T("#2")))
    {
        BITMAPFILEHEADER  bmfh;
        PBITMAPINFOHEADER pbmih = NULL;
        PBITMAPCOREHEADER pbmch = NULL;
        DWORD             dwClrTblSize = 0;
        DWORD             dwClrUsed;
        DWORD             dwCompression;
        WORD              wBitCount;
        WORD              wPlanes;

        pbmih = (PBITMAPINFOHEADER)pchBuf;
        if (pbmih->biSize == sizeof(BITMAPINFOHEADER))
        {
            dwClrUsed     = pbmih->biClrUsed;
            dwCompression = pbmih->biCompression;
            wBitCount     = pbmih->biBitCount;
            wPlanes       = pbmih->biPlanes;
        }
        else if (pbmih->biSize == sizeof(BITMAPCOREHEADER))
        {
            pbmch = (PBITMAPCOREHEADER)pchBuf;

            dwClrUsed     = 0;
            dwCompression = BI_RGB;
            wBitCount     = pbmch->bcBitCount;
            wPlanes       = pbmch->bcPlanes;
        }
        else
        {
            // we don't have a bitmap that we understand
            goto EndHack;
        }

        //
        // Calculate the size of the bitmap's color table
        //

        if (wBitCount <= 8)
        {
            dwClrTblSize = dwClrUsed ? dwClrUsed : (1 << wBitCount);
            dwClrTblSize *= sizeof(RGBQUAD);
        }
        else if ((dwCompression == BI_BITFIELDS) &&
            ((wBitCount == 16) || (wBitCount == 32)))
        {
            dwClrTblSize = 3 * sizeof(DWORD);
        }


        //
        // Fabricate the missing header.  Remember, pbmih might
        // really be a PBITMAPCOREHEADER.  But pbmih->biSize will
        // always be the right size, either way.
        //

#ifdef BIG_ENDIAN
        bmfh.bfType = (WORD)0x424D;         // 0x42 = "B", 0x4D = "M"
#else
        bmfh.bfType = (WORD)0x4D42;         // 0x42 = "B", 0x4D = "M"
#endif
        bmfh.bfSize = sizeof(bmfh) + cb;
        bmfh.bfReserved1 = 0;
        bmfh.bfReserved2 = 0;
        bmfh.bfOffBits = sizeof(bmfh) + pbmih->biSize + dwClrTblSize;

        //
        // Put this sandwich together and make it be pchBuf
        //
        pb = new(Mt(CResProtocolDoParseAndBind_pb)) BYTE [bmfh.bfSize];
        if (!pb)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        MemSetName((pb, "Resprot Bitmap Buffer"));

        memcpy (pb, &bmfh, sizeof(bmfh));
        memcpy (pb + sizeof(bmfh), pchBuf, cb);

        pchBuf = (TCHAR *)pb;
        cb = bmfh.bfSize;
    }
    // </HACK>

EndHack:
    //
    // Try and retrieve a mime type from the resource name and
    // report that if available.
    //

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
    if (hr)
        goto Cleanup;
        
    if (pProt &&
        OK(THR(FindMimeFromData(
            pBCtx, 
            pProt->_cstrURL, 
            NULL, 0, NULL, 0, &pchMime, 0))))
    {
        hr = THR(pProt->_pProtSink->ReportProgress(
                BINDSTATUS_MIMETYPEAVAILABLE,
                pchMime));
        if (hr)
            goto Cleanup;
    }
    
    // cb includes the null terminator

    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    *ppStm = (IStream *)prostm;
    (*ppStm)->AddRef();

Cleanup:
    if (pProt)
    {
        if (!pProt->_fAborted)
        {
            if (!hr)
            {
                pProt->_ReportData(cb);
            }
            if (pProt->_pProtSink)
            {
                pProt->_pProtSink->ReportResult(hr, 0, 0);
            }
        }
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }
    if (prostm)
    {
        prostm->Release();
    }
    ReleaseInterface(pBCtx);
    delete [] pb;
    CoTaskMemFree(pchMime);
    
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateResourceMoniker
//
//  Synopsis:   Creates a new moniker based off a resource file & rid
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT 
CreateResourceMoniker(
    HINSTANCE hInst, 
    TCHAR *pchRID, 
    IMoniker **ppmk)
{
    HRESULT         hr = S_OK;
    TCHAR           ach[pdlUrlLen];
    
    _tcscpy(ach, _T("res://"));

    if (!GetModuleFileName(
            hInst, 
            ach + _tcslen(ach), 
            pdlUrlLen - _tcslen(ach) - 1))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(ach, _T('/'));
        if (p)
	{
            int iLen = _tcslen(++p);
            memmove(ach + 6, p, sizeof(TCHAR) * iLen);
            ach[6 + iLen] = _T('\0');
	}
    }
#endif

    _tcscat(ach, _T("/"));
    _tcscat(ach, pchRID);

    hr = THR(CreateURLMoniker(NULL, ach, ppmk));
    if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateViewSourceProtocol
//
//  Synopsis:   Creates a view-source: Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateViewSourceProtocol(IUnknown *pUnkOuter)
{
    return new CViewSourceProtocol(pUnkOuter);
}


CViewSourceProtocolCF   g_cfViewSourceProtocol(CreateViewSourceProtocol);

const CBase::CLASSDESC CViewSourceProtocol::s_classdesc =
{
    &CLSID_ViewSourceProtocol,             // _pclsid
};

// IOInetProtocolInfo methods
HRESULT CViewSourceProtocolCF::QueryInfo(LPCWSTR         pwzUrl,
                                         QUERYOPTION     QueryOption,
                                         DWORD           dwQueryFlags,
                                         LPVOID          pBuffer,
                                         DWORD           cbBuffer,
                                         DWORD *         pcbBuf,
                                         DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch (QueryOption)
    {
    case QUERY_CAN_NAVIGATE:

        // Need at least a DWORD
        if (cbBuffer < sizeof(DWORD))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pcbBuf)
        {
            *pcbBuf = sizeof(DWORD); // 4 bytes needed for DWORD
        }

        *((DWORD *)pBuffer) = 0; // make sure we return false (0) for view-source prot.
        hr = S_OK;
        break;

    default:
        hr = THR(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pBuffer,
                cbBuffer,
                pcbBuf,
                dwReserved));
        break;
    }

Cleanup:
    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}

HRESULT DisplaySource(LPCTSTR tszSourceName)
{
    // Attempt to read a registry key

    HKEY    hKeyEditor = NULL;
    long    lRet;
    TCHAR   tszEditorName[MAX_PATH];
    LPCTSTR tszDefaultEditorName = _T("notepad");
    long    dwSize = sizeof(tszEditorName);
    SHELLEXECUTEINFO ei = {0};
    BOOL    fSuccess;

    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer\\View Source Editor", 0, KEY_READ, &hKeyEditor);
    if(lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValue(hKeyEditor, _T("Editor Name"), tszEditorName, &dwSize);
        RegCloseKey(hKeyEditor);
    }

    // If key doesn't exist, fails to open or query fails, open default editor

    if(lRet != ERROR_SUCCESS)
    {
        _tcscpy(tszEditorName, tszDefaultEditorName);
    }

    // If named editor fails to execute, open default editor   

    // (rodc) Disable leak tracking because ShellExecute leaks.

    ei.cbSize = sizeof(ei);
    ei.lpVerb = _T("open");
    ei.lpFile = tszEditorName;
    ei.lpParameters = tszSourceName;
    ei.nShow = SW_SHOWNORMAL;

    DbgMemoryTrackDisable(TRUE);
    fSuccess = ShellExecuteEx(&ei);
    DbgMemoryTrackDisable(FALSE);

    if (!fSuccess)
    {
        ei.lpFile = tszDefaultEditorName;

        DbgMemoryTrackDisable(TRUE);
        fSuccess = ShellExecuteEx(&ei);
        DbgMemoryTrackDisable(FALSE);

        if (!fSuccess)
            RRETURN( GetLastWin32Error());
    }

    return S_OK;
}

HRESULT CopySource(IStream *pStmSrc, IStream *pStmDest)
{
    STATSTG statStm;
    BYTE abBuf[4096];   // copy in chunks of 4K
    ULONG cb = 0;
    ULONG cbCopied = 0;
    LONG cbToCopy;
    BYTE *pbStart;
    BYTE *pbEnd;
    BYTE bLast = 0;
    HRESULT hr;

    hr = pStmSrc->Stat(&statStm, STATFLAG_NONAME);
    if (hr)
        goto Cleanup;

#ifdef UNIX
    cb = statStm.cbSize.LowPart;  // get size of bit stream
#else
    cb = statStm.cbSize.u.LowPart;  // get size of bit stream
#endif
    while (cbCopied < cb)
    {
        cbCopied += sizeof(abBuf);
        // bytes to be copied is 4K or remainder (if last chunk)
        if (cbCopied > cb)
            cbToCopy= cb % sizeof(abBuf);
        else
            cbToCopy= sizeof(abBuf);

        hr = pStmSrc->Read(abBuf, (ULONG)cbToCopy, NULL);
        if (hr)
            goto Cleanup;

        pbStart = pbEnd = abBuf;

        while(cbToCopy > 0)
        {
            // keep going until CR, LF (i.e end of line) or End of current chunk
            while (*pbEnd != '\r' && *pbEnd != '\n' && pbEnd-pbStart<cbToCopy)
                pbEnd++;

            // write out what we have so far
            hr = THR(pStmDest->Write(pbStart, pbEnd-pbStart, NULL));
            if (hr)
                goto Cleanup;

            // if first byte of new chunk is not LF, clear the last byte. so 
            // that there is no confusion if tht last byte of previous chunk
            // was a CR
            if (pbStart != pbEnd)
                bLast = 0;

            if (pbEnd-pbStart == cbToCopy)  // bailout if at end of 4K chunk
                break;

            // If LF is found and previous char is CR, 
            // then we don't write, Otherwise, write CR & LF to temp file.

            if (!(*pbEnd == '\n' && bLast == '\r')) 
            {
                hr = THR(pStmDest->Write("\r\n", 2, NULL));
                if (hr)
                    goto Cleanup;
            }

            bLast = *pbEnd; // remember last char (CR or LF)
            cbToCopy -= (LONG)(pbEnd - pbStart + 1); // adjust bytes to be copied
            pbStart = ++pbEnd;  // adjust pts to start of new line
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::OnDwnChan
//
//-------------------------------------------------------------------------

void CViewSourceProtocol::OnDwnChan()
{
    ULONG       ulState = _pBitsCtx->GetState();
    IStream *   pStm = NULL;
    IStream *   pStmFile = NULL;
    TCHAR achFileName[MAX_PATH];
    HRESULT hr = S_OK;
    
    if (ulState & DWNLOAD_COMPLETE)
    {
        _pBitsCtx->GetStream(&pStm);
        if (pStm)
        {
            achFileName[0] = 0;
            if (!CreateUrlCacheEntry(_cstrURL, 0, NULL, achFileName, 0))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            hr = THR(CreateStreamOnFile(
                     achFileName,
                     STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
                     &pStmFile));

            if (hr)
                goto Cleanup;

            hr = CopySource(pStm, pStmFile);    // insert CR\LF if reqd.
            if (hr)
                goto Cleanup;

            hr = CloseStreamOnFile(pStmFile);
            if (hr)
                goto Cleanup;

            FILETIME fileTime;
            fileTime.dwLowDateTime = 0;
            fileTime.dwHighDateTime = 0;
            if (!CommitUrlCacheEntry(_cstrURL,
                                     achFileName,
                                     fileTime,
                                     fileTime,
                                     NORMAL_CACHE_ENTRY,
                                     NULL,
                                     0,
                                     NULL,
                                     0))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            hr = DisplaySource(achFileName);
        }
        goto Cleanup;
    }
    else if (ulState & DWNLOAD_ERROR)
    {
        goto Cleanup;
    }

    return;

Cleanup:
    if (!_fAborted)
    {
        if (_pBitsCtx)
        {
            // if aborted, kill the bits ctx if started
            _pBitsCtx->Disconnect();
            _pBitsCtx->Release();
            _pBitsCtx = NULL;
        }

        // tell urlmon that we are done
        if (!hr && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 0, 0);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    ReleaseInterface(pStm);
    ReleaseInterface(pStmFile);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::ParseAndBind
//
//  Synopsis:   Actually get the source stream and display it in notepad.
//
//----------------------------------------------------------------------------

HRESULT CViewSourceProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pchSourceUrl = NULL;
    DWNLOADINFO     dwnloadinfo = {0};
    URL_COMPONENTS  uc;
    TCHAR           achPath[pdlUrlLen];

    // skip protocol part
    pchSourceUrl = _tcschr(_cstrURL, ':');
    if (!pchSourceUrl)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    // Go past the :
    pchSourceUrl++;

    memset(&uc, 0, sizeof(uc));

    uc.dwStructSize = sizeof(uc);
    uc.lpszUrlPath = achPath;
    uc.dwUrlPathLength = ARRAY_SIZE(achPath);

    // Only file://, http:// and https:// supported
    if (pchSourceUrl && InternetCrackUrl(pchSourceUrl, _tcslen(pchSourceUrl), 0, &uc))
    {
        switch (uc.nScheme)
        {
            case INTERNET_SCHEME_HTTP:
            case INTERNET_SCHEME_HTTPS:
                dwnloadinfo.pDwnDoc = new CDwnDoc();
    
                if (dwnloadinfo.pDwnDoc)
                    dwnloadinfo.pDwnDoc->SetRefresh(IncrementLcl());
    
                dwnloadinfo.pchUrl = pchSourceUrl;

                Assert(!_pBitsCtx);

                // Get the bits context
                hr = THR(::NewDwnCtx(DWNCTX_BITS, TRUE, &dwnloadinfo, (CDwnCtx **)&_pBitsCtx));
                if (hr)
                    break;

                if (_pBitsCtx)
                {
                    // if bits already got, call the callback
                    if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR))
                        OnDwnChan();
                    else    // register the callback
                    {
                        _pBitsCtx->SetCallback(OnDwnChanCallback, this);
                        _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
                    }
                }

                if (dwnloadinfo.pDwnDoc)
                    dwnloadinfo.pDwnDoc->Release();
            
                RRETURN(hr);

            // just display file if file:// protocol
            case INTERNET_SCHEME_FILE:
                hr = DisplaySource(uc.lpszUrlPath);
                // fall through

            default:
                break;
        }
    }
        
Cleanup:
    // tell urlmon that we are done
    if (!_fAborted)
    {
        if (!hr && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 0, 0);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::Abort
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT CViewSourceProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }

    return super::Abort(hrReason, dwOptions);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::Passivate
//
//  Synopsis:   1st stage dtor. Need to override so that the BitsCtx can be
//              killed if started and then aborted before OnDwnChan CB is called
//
//----------------------------------------------------------------------------

void
CViewSourceProtocol::Passivate()
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }
    
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\proppage\allpage.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       allpage.cxx
//
//  Contents:   Generic TypeInfo-based property page
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#if DBG==1    

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"
#endif

#ifndef X_ALLPAGE_HXX_
#define X_ALLPAGE_HXX_
#include "allpage.hxx"
#endif

#ifndef X_ELEMENT_H_
#define X_ELEMENT_H_
#include "element.h"  // for IElement->GetSTYLE(..)
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);


#define WM_DEFERUPADTE  WM_APP + 1   // This is only used in AllPage
#define WM_CBSELCHANGED  WM_APP + 2   // This is only used in AllPage

const CBase::CLASSDESC CAllPage::s_classdesc = { 0 };

DeclareTag(tagAsyncPict, "AllPage", "Async Picture Loading")

MtDefine(CAllPage, Dialogs, "CAllPage")
MtDefine(CAllPage_aryObjs_pv, CAllPage, "CAllPage::_aryObjs::_pv")
MtDefine(CAllPageParseValue_pchString, Dialogs, "CAllPage::ParseValue pchString")

//+------------------------------------------------------------------------
//
//  Function:   CreateGenericPropertyPage
//
//  Synopsis:   Creates a new generic page.  Called from the generic
//              page's class factory
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateGenericPropertyPage(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    *ppUnk = new CAllPage(FALSE, IDS_PPG_GENERIC);
    return *ppUnk ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CreateInlineStylePropertyPage(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    *ppUnk = new CAllPage(TRUE, IDS_PPG_INLINE_STYLE);
    return *ppUnk ? S_OK : E_OUTOFMEMORY;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::CAllPage
//
//  Synopsis:   Constructor
//
//-------------------------------------------------------------------------
CAllPage::CAllPage(BOOL fStyle, UINT idrTitleString)
    : _aryObjs(Mt(CAllPage_aryObjs_pv))
{
    _fStyle = fStyle;
    _idrTitleString = idrTitleString;
    _hWndPage = NULL;
    _hWndEdit = NULL;
    _hWndButton = NULL;
    _hWndList = NULL;
    _dyEdit = 0;
    _pPageSite = NULL;
    _pEngine = NULL;
    _pHolder = NULL;
    _emode = EMODE_Edit;

    _fDirty =
    _fInUpdateEditor =
    _fInApply = FALSE;

#ifndef NO_EDIT
    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT
#ifdef _MAC
    _hfontDlg = CreateFont(9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        FF_DONTCARE, _T("Geneva"));
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::~CAllPage
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

void
CAllPage::Passivate()
{
    Deactivate();
    ClearInterface(&_pPageSite);
    ClearInterface(&_pUndoMgr);
    ReleaseObjects();
    CBase::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::~CAllPage
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

CAllPage::~CAllPage( )
{
    ReleaseInterface(_pUndoMgr);
    ReleaseObjects();

#ifdef _MAC
    DeleteObject (_hfontDlg);
#endif
}


STDMETHODIMP_(ULONG)
CAllPage::AddRef( )
{
    return PrivateAddRef();
}


STDMETHODIMP_(ULONG)
CAllPage::Release( )
{
    return PrivateRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::QueryInterface
//
//  Synopsis:   The generic page supports the following interfaces:
//
//                  IUnknown
//                  IPropertyPage
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IPropertyPage)
    {
        *ppv = (IPropertyPage *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetPageSite
//
//  Synopsis:   Replaces the current page site, which might be NULL
//
//  Arguments:  [pPageSite]     New page site
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::SetPageSite(IPropertyPageSite * pPageSite)
{
    if (_pPageSite && pPageSite)
        RRETURN(E_UNEXPECTED);

    ReplaceInterface(&_pPageSite, pPageSite);
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Activate
//
//  Synopsis:   Creates the window for this page.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Activate(
        HWND hWndParent,
        const RECT * prc,
        BOOL fModal)
{
    RECT    rc;
    HRESULT hr;

    Assert(_hWndPage == NULL);

    //
    // Verify that we have a commit holder
    //

    hr = THR(EnsureCommitHolder((DWORD_PTR)hWndParent, &_pHolder));
    if (hr)
        goto Cleanup;

    //
    // Now let commit engine know about objects
    //

    hr = THR(_pHolder->GetEngine(_aryObjs.Size(), _aryObjs, &_pEngine));
    if (hr)
        goto Cleanup;

    _hWndPage = CreateDialogParam(
                    GetResourceHInst(),
                    MAKEINTRESOURCE(IDD_GENERICPAGE),
                    hWndParent,
                    PageWndProc,
                    (LPARAM) this);
    if (!_hWndPage)
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));


    _emode = EMODE_Edit;

    ::GetWindowRect(_hWndEdit, &rc);
    _dyEdit = rc.bottom - rc.top;

    Verify(!Move(prc));
    hr = THR(UpdatePage());
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Deactivate
//
//  Synopsis:   Destroys the window for the page
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Deactivate( )
{
    if (_hWndPage)
    {
        Verify(DestroyWindow(_hWndPage));
        _hWndPage = NULL;
        Assert(!_hWndPage);
    }

    if (_pHolder)
    {
        _pHolder->Release();
        _pHolder = NULL;
    }
    _pEngine = NULL;


    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::GetPageInfo
//
//  Synopsis:   Returns page description information
//
//  Arguments:  [pppi]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::GetPageInfo(LPPROPPAGEINFO pppi)
{
    HRESULT hr;
    DWORD   dw;
    TCHAR   szTitle[FORMS_BUFLEN + 1];

#if DBG == 1
    //
    // This function should fail if pppi->cb != sizeof(PROPPAGEINFO),
    // but we ignore it because the CDK  property frame does not set
    // this member.
    //
    if (pppi->cb != sizeof(PROPPAGEINFO))
    {
        TraceTag((tagWarning, "PROPPAGEINFO with bad cb (CDK prop frame known to do this)"));
#if 0
        RRETURN(E_FAIL);
#endif  // 0
    }
#endif  // DBG == 1

    memset(
            (BYTE *) pppi + sizeof(ULONG),
            0,
            sizeof(PROPPAGEINFO) - sizeof(ULONG));



    if (!LoadString(GetResourceHInst(), _idrTitleString, szTitle, FORMS_BUFLEN))
        return HRESULT_FROM_WIN32(GetLastError());

    dw = GetDialogBaseUnits();
    pppi->size.cx = 171 * LOWORD(dw) / 4;
    pppi->size.cy = 90 * HIWORD(dw) / 8;

    hr = TaskAllocString(szTitle, &pppi->pszTitle);
    if (hr)
        goto Error;

    // pppi->pszDocString not filled in
    // pppi->pszHelpFile not filled in
    // pppi->dwHelpContext not filled in

Cleanup:
    RRETURN(hr);

Error:
    TaskFreeString(pppi->pszTitle);
    goto Cleanup;
}



HRESULT
CAllPage::UpdatePage( )
{
    if (_hWndList)
    {
        SendMessage(_hWndList, WM_SETREDRAW, FALSE, 0);
        SendMessage(_hWndList, LB_RESETCONTENT, 0, 0);
    }

    UpdateList();

    if (_hWndList)
    {
        SendMessage(_hWndList, WM_SETREDRAW, TRUE, 0);
    }

    UpdateEditor(NULL);
    UpdateEngine();

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetObjects
//
//  Synopsis:   Releases the old set of objects, and makes a new set
//              current.  The TypeInfo's for the objects are examined, a
//              shared subset of properties is determined, then the
//              common values for these properties are retrieved.
//
//  Arguments:  [cObjects]
//              [apUnk]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::SetObjects(ULONG cObjects, IUnknown ** apUnk)
{
    HRESULT         hr;
    int             i;
    IUnknown  **    ppUnk     = NULL;
    IDispatch **    ppDisp    = NULL;

    if (TLS(prop.fModalDialogUp))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Flush the new values to the existing objects first.
    //

    if (_fDirty)
    {
        Apply();
    }

    ReleaseObjects();

    hr = THR(_aryObjs.EnsureSize(cObjects));
    if (hr)
        goto Error;

    for (i = 0, ppUnk = apUnk, ppDisp = _aryObjs;
         i < (int) cObjects;
         ppUnk++, ppDisp++)
    {

        if (_fStyle)
        {
            IHTMLStyle *pStyle;

            hr = THR((*ppUnk)->QueryInterface(IID_IHTMLElement, (void **) ppDisp));
            if (hr)
            {
                ClearInterface(ppDisp);
                goto Error;
            }

            hr = THR(  (  (IHTMLElement*)  *ppDisp)->get_style(&pStyle));
            ClearInterface(ppDisp);
            if (hr)
            {
                goto Error;
            }
            *ppDisp = pStyle;
        }
        else
        {
            hr = THR((*ppUnk)->QueryInterface(IID_IDispatch, (void **) ppDisp));
        }

        //ISSUE: TODO: --This looks fishy.  Shouldn't this be if(hr) ???
        if (!hr)
        {
            //if this fails we still want to the other object's pages
            //  or a blank page
            _aryObjs.SetSize(++i);
        }
        hr = S_OK;
    }


Cleanup:
    RRETURN(hr);

Error:
    ReleaseObjects();
    goto Cleanup;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Show
//
//  Synopsis:   Shows the property page
//
//  Arguments:  [nCmdShow]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Show(UINT nCmdShow)
{
    ShowWindow(_hWndPage, nCmdShow);
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Move
//
//  Synopsis:   Moves the property page window.  The child windows are
//              repositioned to match.
//
//  Arguments:  [prc]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Move(const RECT * prc)
{
    MoveWindow(
            _hWndPage,
            prc->left,
            prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            TRUE);

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::IsPageDirty
//
//  Synopsis:   Returns S_OK if this page is dirty, S_FALSE otherwise.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::IsPageDirty( )
{
    return (_fDirty) ? S_OK : S_FALSE;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Apply
//
//  Synopsis:   Applies any pending changes from the page.  The UI is
//              updated to pick up the new value.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Apply( )
{
    HRESULT     hr;

    if (!_fDirty || _fInApply)
        return S_OK;

    _fInApply = TRUE;

    hr = THR(_pEngine->Commit());
    if (hr)
        goto Cleanup;

    SetDirty(FALSE);

Cleanup:
    _fInApply = FALSE;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OnButtonClick
//
//  Synopsis:   Called when ... Button is clicked. It opens Font/Picture
//              Dialog.
//
//  Returns:    None
//
//-------------------------------------------------------------------------
#ifndef NO_PROPERTY_PAGE
void
CAllPage::OnButtonClick(void)
{
    Assert(_pDPDCur);

    TLS(prop.fModalDialogUp) = TRUE;

    if (_pDPDCur->fSpecialCaseFont)
    {
        BOOL fRet;

        OpenFontDialog(
                this,
                _hWndEdit,
                _aryObjs.Size(),
                (IUnknown **)(IDispatch **) _aryObjs,
                &fRet);
        if (fRet)
        {
            // Open change font/ForeColor proeprty, update edit box
            UpdateEditor(_pDPDCur);
        }
    }
    else if (_pDPDCur->fSpecialCaseColor)
    {
        OpenColorDialog();
    }
    else
    {
        OpenPictureDialog(_pDPDCur->fSpecialCaseMouseIcon);
    }

    TLS(prop.fModalDialogUp) = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OpenPictureDialog
//
//  Synopsis:   Opens Picture Dialog. If successful, Update edit box
//              and save the change
//
//  Returns:    None
//
//-------------------------------------------------------------------------

void
CAllPage::OpenPictureDialog(BOOL fMouseIcon)
{
    HRESULT hr = E_FAIL;
    TCHAR achFile[MAX_PATH];

    achFile[0] = 0;

    hr = THR(FormsGetFileName(
			      FALSE, // indicates OpenFileName
                    _hWndPage,
                    fMouseIcon  ? IDS_PROPERTYOPENMOUSEICON
                                : IDS_PROPERTYOPENPICTURE,
                    achFile,
                    ARRAY_SIZE(achFile), (LPARAM)0));

    if (!hr)
    {
        // Update edit box and save the change
        SetWindowText(_hWndEdit, achFile);
        _fDirty = 1;
        Apply();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OpenColorDialog
//
//  Synopsis:   Opens Color Dialog. If successful, Update edit box
//              and save the change
//
//  Returns:    None
//
//-------------------------------------------------------------------------

void
CAllPage::OpenColorDialog()
{
    HRESULT     hr;
    BOOL        fRet;
    CHOOSECOLOR cc;
    COLORREF    aclr[16];
    int         i;
    VARIANT     var;

    //
    // initialize CHOOSECOLOR structure
    //

    memset((void *)&cc, 0, sizeof(CHOOSECOLOR));

    for (i = ARRAY_SIZE(aclr) - 1; i >= 0; i--)
    {
        aclr[i] = RGB(255, 255, 255);
    }

    VariantInit(&var);

    // Find the current color
    hr = THR_NOTRACE(GetCommonPropertyValue(
            _pDPDCur->dispid,
            _aryObjs.Size(),
            _aryObjs,
            &var));

    // If there is common color, set it as default selection
    if (hr == S_OK)
    {
        Assert(V_VT(&var) == VT_I4);
        cc.rgbResult = ColorRefFromOleColor(V_I4(&var));
        // set it be the first custom color
        aclr[0] = cc.rgbResult;
    }

    cc.lStructSize      = sizeof(CHOOSECOLOR);
    cc.hwndOwner        = _hWndPage;
    cc.hInstance        = NULL;     // no template; this is ignored
    cc.Flags            = CC_RGBINIT;
    cc.lpCustColors     = aclr;
    cc.lpfnHook         = NULL;
    cc.lpTemplateName   = NULL;


    fRet = ChooseColor(&cc);

    if (fRet)
    {

        V_VT(&var) = VT_I4;
        V_I4(&var) = cc.rgbResult;

#ifndef NO_EDIT
        CParentUndoUnit * pCPUU;

        pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT
        hr = THR(SetCommonPropertyValue(
                _pDPDCur->dispid,
                _aryObjs.Size(),
                _aryObjs,
                &var));

        // ISSUE: Is this still being called? New ShowLastErrorInfo
        // requires CDoc or CElement pointer.
        // ShowLastErrorInfo(NULL, hr);       
        Assert(FALSE);
#ifndef NO_EDIT
        hr = CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    }
}
#endif // NO_PROPERTY_PAGE



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Help
//
//  Synopsis:   NYI
//
//  Arguments:  [szHelpDir]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Help(LPCTSTR szHelpDir)
{
    RRETURN(E_NOTIMPL);
}





//+------------------------------------------------------------------------
//
//  Member:     CAllPage::TranslateAccelerator
//
//  Synopsis:   Handles the keyboard interface for the page.
//
//  Arguments:  [pmsg]      Message to translate
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::TranslateAccelerator(LPMSG pmsg)
{
    if (_hWndPage && (pmsg->hwnd == _hWndPage || IsChild(_hWndPage, pmsg->hwnd)))
    {
        HRESULT     hr;

        if (pmsg->hwnd == _hWndList || IsChild(_hWndList, pmsg->hwnd))
        {
            hr = THR(_pPageSite->TranslateAccelerator(pmsg));
            if (hr != S_FALSE)
                return hr;
        }

        if (pmsg->message == WM_KEYDOWN &&
            pmsg->wParam == VK_DELETE && pmsg->hwnd == _hWndEdit )
        {
            // We use delete key to set NULL picture
            if (_pDPDCur && _pDPDCur->fSpecialCasePicture)
            {
                // Delete key is used to NULL picture
                SetWindowText(_hWndEdit, _T("NULL"));
                _fDirty = 1;
                Apply();
            }
        }
    }
    else if (pmsg->message == WM_KEYDOWN &&
             pmsg->wParam == VK_TAB &&
             GetKeyState(VK_CONTROL) >= 0)
    {
        HWND    hWndFoc;
        BOOL    fPrev = !!(GetKeyState(VK_SHIFT) & 0x8000);

        hWndFoc = GetNextDlgTabItem(
            _hWndPage,
            fPrev ? _hWndEdit : _hWndList,
            fPrev);

        if (hWndFoc)
        {
            SetFocus(hWndFoc);
            return S_OK;
        }
    }

    return S_FALSE;
}




//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ReleaseObjects
//
//  Synopsis:   Releases the current set of objects.  Also releases the
//              current set of property descriptors and cached values.
//
//-------------------------------------------------------------------------

void
CAllPage::ReleaseObjects( )
{
    _aryObjs.ReleaseAll();

    ReleaseVars();
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ReleaseVars
//
//  Synopsis:   Releases the current set of property descriptors and
//              cached values.
//
//-------------------------------------------------------------------------

void
CAllPage::ReleaseVars( )
{
    _pDPDCur = NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateList
//
//  Synopsis:   Update the owner-draw listbox with the property names.
//              Note that even though we do all the drawing for the list,
//              we still pass in strings, so that we can use the listbox
//              window's prefix matching.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateList( )
{
    int             i;
    DPD *           pDPD;
    int             index;
    CDataAry<DPD> * paryDPD;

    if (!_hWndPage)
        return;

    paryDPD = _pEngine->GetDPDs();

    for (i = 0, pDPD = *paryDPD;
         i < paryDPD->Size();
         i++, pDPD++)
    {
        // Do not display member not found property or read-only property
        if (pDPD->fMemberNotFound || pDPD->fReadOnly)
        {
            continue;
        }

        // If an item with the same name already exists in the list,
        // skip adding the duplicate
        // (Even though it refers to a different property, only the
        //  first instance seen "wins" and should be exposed)
        index = (int) SendMessage(
                            _hWndList,
                            LB_FINDSTRINGEXACT,
                            (WPARAM) -1,
                            (LPARAM) pDPD->bstrName);
        if (index != LB_ERR)
        {
            continue;
        }

        // Add the item to the list
        index = (int) SendMessage(
                            _hWndList,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) pDPD->bstrName);
        if (index == LB_ERR)
            continue;

        SendMessage(_hWndList, LB_SETITEMDATA, (WPARAM) index, (LPARAM) i);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateEngine
//
//  Synopsis:   Updates the engine based on the current prop value.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateEngine()
{
    HRESULT     hr;
    VARIANT     var;

    VariantInit(&var);

    if (_pDPDCur)
    {
        hr = THR(ParseValue(&var));
        if (hr)
            goto Cleanup;

        _pEngine->SetProperty(_pDPDCur->dispid, &var);
    }

    if (_hWndPage)
    {
        Assert(_hWndList);
        InvalidateRect(_hWndList, (GDIRECT *)NULL, FALSE);
    }

Cleanup:
    VariantClear(&var);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateEditor
//
//  Synopsis:   Updates the editor window to match the currently selected
//              property.  This may require creating a new editor window,
//              filling any drop-down list, and always includes updating
//              the window's value.
//
//  Arguments:  [pDPDSource]    The source of the property update.
//                              If non-NULL, then the editor is assumed
//                              to match the property in all ways
//                              except the property value.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateEditor(DPD * pDPDSource)
{
    DPD *       pDPD;
    int         i, j;
    BOOL        fEnableEditor;
    EMODE       emode;
    DWORD       dwStyle;
    RECT        rcEdit;
    RECT        rcButton;
    EVAL *      pEVAL;
    HFONT       hFont;
    VARIANT     var;
    LPTSTR      szValue;
    TCHAR       ach[FORMS_BUFLEN + 1];
    LPTSTR      szValueEnum;
    TCHAR       achEnum[FORMS_BUFLEN + 1];
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();

    _fInUpdateEditor = TRUE;

    pDPD = pDPDSource;
    if (!pDPD)
    {
        i = SendMessage(_hWndList, LB_GETCURSEL, 0, 0);
        if (i != LB_ERR)
        {
            j = SendMessage(_hWndList, LB_GETITEMDATA, i, 0);

            Assert(j >= 0);
            // ISSUE: ChrisF: remove assert on Julia's advise
            // but don't understand it !
            Assert(j < paryDPD->Size());

            pDPD = &(*paryDPD)[j];
        }
    }

    if (pDPD == NULL)
    {
        szValue = _T("");
        emode = EMODE_Edit;

        fEnableEditor = FALSE;
    }
    else
    {
        fEnableEditor = FormatValue(
                            &pDPD->var,
                            pDPD,
                            ach,
                            ARRAY_SIZE(ach),
                            &szValue);

        // Find out what the mode should be
        if (fEnableEditor && pDPD->pAryEVAL != NULL)
        {
            if (pDPD->fSpecialCaseColor)
            {
                emode = EMODE_ComboButton;
            }
            else
            {
                emode = EMODE_StaticCombo;
            }
        }
        else if(pDPD->fSpecialCasePicture || pDPD->fSpecialCaseFont )
        {
            emode = EMODE_EditButton;
        }
        else
        {
            emode = EMODE_Edit;
        }

    }

    ::GetWindowRect(_hWndEdit, &rcEdit);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.right);

    if (_hWndButton)
    {
        ::GetWindowRect(_hWndButton, &rcButton);
        ScreenToClient(_hWndPage, (LPPOINT) &rcButton.right);
        rcEdit.right = rcButton.right;
    }

    if (emode != _emode)
    {
        Assert(!pDPDSource);

        //
        // Destory old windows
        //

        SetWindowPos(
                _hWndEdit,
                NULL,
                0, 0, 0, 0,
                SWP_HIDEWINDOW | SWP_NOMOVE |
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW);

        Verify(DestroyWindow(_hWndEdit));
        _hWndEdit = NULL;

        if (_hWndButton)
        {
            SetWindowPos(
                    _hWndButton,
                    NULL,
                    0, 0, 0, 0,
                    SWP_HIDEWINDOW | SWP_NOMOVE |
                        SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW);

            Verify(DestroyWindow(_hWndButton));
            _hWndButton = NULL;
        }

        //
        // Create new windows
        //
        if ((emode == EMODE_EditButton) || (emode == EMODE_ComboButton))
        {
            if (emode == EMODE_EditButton)
            {
                // Create read-only edit widnow
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | ES_READONLY;
            }
            else
            {
                // Create dropdown combo widnow
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWN;
            }

            _hWndEdit = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    (emode == EMODE_EditButton)
#ifndef WIN16
                        ? _T("EDIT")
#else
                        ? "EDIT32"
#endif
                        : _T("COMBOBOX"),
                    szValue,
                    dwStyle,
                    rcEdit.left,
                    rcEdit.top,
                    rcEdit.right - rcEdit.left - _dyEdit,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDE_PROPVALUE,
                    g_hInstCore,
                    NULL);

            // Create button
            dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP
                        | BS_PUSHBUTTON;

            _hWndButton = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    _T("BUTTON") ,
                    _T("..."), //szValue,
                    dwStyle,
                    rcEdit.right - _dyEdit,
                    rcEdit.top,
                    _dyEdit,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDB_OPENDLG,
                    g_hInstCore,
                    NULL);
        }
        else
        {
            if (emode == EMODE_Edit)
            {
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL;
            }
            else if (emode == EMODE_StaticCombo)
            {
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWNLIST;
            }
            else
            {
                // For emode == EMODE_EditCombo
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWN;
            }

            _hWndEdit = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    (emode == EMODE_Edit)
#ifndef WIN16
                        ? _T("EDIT")
#else
                        ? "EDIT32"
#endif
                        : _T("COMBOBOX"),
                    szValue,
                    dwStyle,
                    rcEdit.left,
                    rcEdit.top,
                    rcEdit.right - rcEdit.left,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDE_PROPVALUE,
                    g_hInstCore,
                    NULL);
        }

        hFont = (HFONT) SendMessage(_hWndList, WM_GETFONT, 0, 0);
        SendMessage(_hWndEdit, WM_SETFONT, (WPARAM) hFont, FALSE);

        _emode = emode;
    }

    if (!pDPDSource && IsComboMode(emode))
    {
        while (SendMessage(_hWndEdit, CB_DELETESTRING, 0, 0) > 0)
            ;

        VariantInit(&var);

        for (i = pDPD->pAryEVAL->Size(), pEVAL = *pDPD->pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            var.vt = VT_I4;
            V_I4(&var) = pEVAL->value;

            FormatValue(
                    &var,
                    pDPD,
                    achEnum,
                    ARRAY_SIZE(achEnum),
                    &szValueEnum);

            SendMessage(_hWndEdit, CB_ADDSTRING, 0, (LPARAM) szValueEnum);

            //  Resize the dropdown appropriately

            SetWindowPos(
                    _hWndEdit,
                    NULL,
                    0, 0, 0, 0,
                    SWP_HIDEWINDOW | SWP_NOMOVE | SWP_NOZORDER |
                        SWP_NOSIZE | SWP_NOREDRAW);

            SetWindowPos(
                    _hWndEdit,
                    NULL,
                    0,
                    0,
                    (emode == EMODE_ComboButton)
                        ? rcEdit.right - rcEdit.left - _dyEdit
                        : rcEdit.right - rcEdit.left,
                    _dyEdit + HIWORD(GetDialogBaseUnits()) *
		    min((int)8, pDPD->pAryEVAL->Size()) + 2,    // IEUNIX : (long) -> (int) due to Size() change
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW);
        }
    }

    if (emode != EMODE_EditCombo && emode != EMODE_ComboButton )
    {
        SendMessage(
                _hWndEdit,
                IsComboMode(emode) ? CB_SELECTSTRING : WM_SETTEXT,
                0,
                (LPARAM) szValue);
    }
    else
    {
        // For EMODE_EditCombo, if value is in list, select it
        // Otherwise, set user defined value into editbox
        if (CB_ERR == SendMessage(
                _hWndEdit,
                 CB_SELECTSTRING ,
                0,
                (LPARAM) szValue))
        {
            SendMessage(
                    _hWndEdit,
                    WM_SETTEXT,
                    0,
                    (LPARAM) szValue);

        }
    }

    EnableWindow(_hWndEdit, fEnableEditor);
    ShowWindow(_hWndEdit, SW_SHOWNA);

    if (_hWndButton)
    {
        EnableWindow(_hWndButton, fEnableEditor);
        ShowWindow(_hWndButton, SW_SHOWNA);
    }

    _pDPDCur = pDPD;

    _fInUpdateEditor = FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CAllPage::IsComboMode
//
//  Synopsis:   Check if emode is for combo
//
//  Arguments:  EMDOE emode
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
CAllPage::IsComboMode(EMODE emode)
{
    if (emode == EMODE_EditCombo || emode == EMODE_StaticCombo ||
            emode == EMODE_ComboButton)
        return TRUE;
    else
        return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CAllPage::NameOfType
//
//  Synopsis:   Hard-wired lookup of type name based on VT
//
//  Arguments:  [pDPD]
//
//  Returns:    TCHAR *
//
//-------------------------------------------------------------------------

TCHAR *
CAllPage::NameOfType(DPD * pDPD)
{
    int     i;

    //  This page will not ship, and therefore does not need to
    //    be localized

    static struct tagTYPEANDNAME
    {
        VARTYPE vt;
        TCHAR * szName;
    }
    s_VarTypes[] =
    {
        VT_I2,          _T("I2"),
        VT_I4,          _T("I4"),
        VT_R4,          _T("R4"),
        VT_R8,          _T("R8"),
        VT_BOOL,        _T("BOOL"),
        VT_ERROR,       _T("ERROR"),
        VT_CY,          _T("CY"),
        VT_DATE,        _T("DATE"),
        VT_BSTR,        _T("BSTR"),
        VT_UNKNOWN,     _T("UNKNOWN"),
        VT_DISPATCH,    _T("DISPATCH"),
        VT_VARIANT,     _T("VARIANT"),
        VT_USERDEFINED, _T("USERDEF"),
        VT_FILETIME,    _T("FILETIME"),
        VT_NULL,        _T("NULL"),
        VT_PTR,         _T("POINTER"),
        0,              _T("error"),
    };

    for (i = 0; i < ARRAY_SIZE(s_VarTypes) - 1; i++)
    {
        if (pDPD->vt == s_VarTypes[i].vt)
            break;
    }

    return s_VarTypes[i].szName;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::FormatValue
//
//  Synopsis:   Formats a value for display, either in the summary list
//              or in the editor.
//
//  Arguments:  [pvar]      Value to format
//              [pDPD]      Property descriptor
//              [ach]       Buffer to use if necessary
//              [cch]       ditto
//              [ppstr]     String pointer returned in *ppstr
//
//  Returns:    BOOL; FALSE if the editor window should be disabled.
//
//-------------------------------------------------------------------------

BOOL
CAllPage::FormatValue(
        VARIANT * pvar,
        DPD * pDPD,
        TCHAR * ach,
        int cch,
        TCHAR ** ppstr)
{
    int     i;
    EVAL *  pEVAL;
    TCHAR * pstrFriendly;
    TCHAR * pstr;
    int     value;
    HRESULT hr;
    BSTR    bstr    = NULL;

    if (pDPD->fMemberNotFound)
    {
        *ppstr = _T("");
        return FALSE;
    }

    if (pDPD->fSpecialCaseFont)
    {
        IFont *     pFont   = NULL;
        CY          cy;
        BOOL        fBold;
        BOOL        fItalic;
        BOOL        fUnderline;
        BOOL        fStrikethrough;

        if (pvar->vt == VT_UNKNOWN || pvar->vt == VT_DISPATCH)
        {
            IGNORE_HR(V_UNKNOWN(pvar)->QueryInterface(
                    IID_IFont,
                    (void **) &pFont));
        }

        if (pFont)
        {
            pFont->get_Name(&bstr);
            pFont->get_Size(&cy);
            pFont->get_Bold(&fBold);
            pFont->get_Italic(&fItalic);
            pFont->get_Underline(&fUnderline);
            pFont->get_Strikethrough(&fStrikethrough);

            Assert(cy.Hi == 0);

            Format( 0,
                    ach, cch,
                    _T("<0d>pt <1s><2s><3s><4s><5s>"),
                    (long) ((cy.Lo + 5000) / 10000),
                    bstr ? bstr: _T(""),
                    (fBold) ? _T(", Bold") : _T(""),
                    (fItalic) ? _T(", Italic") : _T(""),
                    (fUnderline) ? _T(", Underline") : _T(""),
                    (fStrikethrough) ? _T(", Strikethrough") : _T(""));

            *ppstr = ach;

            FormsFreeString(bstr);
            pFont->Release();
        }
        else
        {
            *ppstr = _T("(Error)");
        }
    }
    else if (pDPD->fSpecialCasePicture)
    {
        SHORT sPicType = PICTYPE_NONE;

        //
        // Because VB does not accept NULL value for picture property,
        // there is Empty picture with PICTTYPE_NONE type, so need
        // distingish it from real picture.
        //
        if (V_DISPATCH(&(pDPD->var)))
        {
            IPicture *  pPicture = NULL;
            if (!V_DISPATCH(&(pDPD->var))->QueryInterface(
                    IID_IPicture,
                    (void **) &pPicture))
            {
                pPicture->get_Type(&sPicType);
            }
            ReleaseInterface(pPicture);
        }

        if (sPicType == PICTYPE_NONE)
        {
            *ppstr = _T("(None)");
        }
        else
        {
            *ppstr = _T("(Picture)");
        }
    }
    else if (pDPD->pAryEVAL)
    {
        pstrFriendly = _T("Unknown");

        switch (pvar->vt)
        {
        case VT_BOOL:
        case VT_I2:
            value = V_I2(pvar);
            break;

        case VT_I4:
            value = V_I4(pvar);
            break;

        default:
            *ppstr = _T("Type mismatch");
            return FALSE;
        }

        for (i = pDPD->pAryEVAL->Size(), pEVAL = *pDPD->pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            if (pEVAL->value == value)
            {
                pstrFriendly = pEVAL->bstr;
                break;
            }
        }

        Format(
                0,
                ach, cch,
                (pDPD->fSpecialCaseColor) ?
                    _T("<0x> - <1s>") :
                    _T("<0d> - <1s>"),
                (long)value,
                pstrFriendly);

        *ppstr = ach;
    }
    else
    {
        *ppstr = ach;

        switch (pvar->vt)
        {
        case VT_BSTR:
            *ppstr = V_BSTR(pvar);
            if (!*ppstr)
                *ppstr = _T("");
            break;

        case VT_I2:
            _ltot(V_I2(pvar), ach, 10);
            break;

        case VT_I4:
            _ltot(V_I4(pvar), ach, 10);
            break;

        case VT_R4:
            hr = THR(VarBstrFromR4(
                            V_R4(pvar),
                            g_lcidUserDefault,
                            0,
                            &bstr));
            if (hr)
            {
                *ppstr = _T("");
            }
            else
            {
                _tcsncpy(ach, bstr, cch);
                FormsFreeString(bstr);
            }
            break;

        case VT_R8:
            hr = THR(VarBstrFromR8(
                            V_R8(pvar),
                            g_lcidUserDefault,
                            0,
                            &bstr));
            if (hr)
            {
                *ppstr = _T("");
            }
            else
            {
                _tcsncpy(ach, bstr, cch);
                FormsFreeString(bstr);
            }
            break;

        case VT_CY:
#ifdef NEVER
            _ltot((int) (V_CY(pvar).int64 / 10000), ach, 10);
            pstr = _tcschr(ach, 0);
            _ltot((int) (V_CY(pvar).int64 % 10000) / 100 + 100, pstr, 10);
#endif // NEVER
            Assert(V_CY(pvar).Hi == 0);

            _ltot((int) (V_CY(pvar).Lo / 10000), ach, 10);
            pstr = _tcschr(ach, 0);
            _ltot((int) (V_CY(pvar).Lo % 10000) / 100 + 100, pstr, 10);

            *pstr = _T('.');
            break;

        case VT_BOOL:
            if (V_BOOL(pvar))
                *ppstr = _T("True");
            else
                *ppstr = _T("False");
            break;

        case VT_NULL:
            *ppstr = _T("");
            break;

        default:
            *ppstr = _T("");
            return FALSE;
        }
    }

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ParseValue
//
//  Synopsis:   Parses the value currently in the editing window, based
//              on the property descriptor last used to fill in the
//              editor.
//
//  Arguments:  [pvar]      Parsed value returned in *pvar.  Note that
//                          pvar->vt may not match _pDPDCur->vt; this
//                          method relies on normal OLE Automation practice
//                          to coerce the value to its final type.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

#if defined(DEBUG) && !defined(MAC) 
STDAPI OleLoadPicturePath( LPOLESTR szUrl, LPUNKNOWN punkCaller, DWORD dwFlags,
                           OLE_COLOR clrBackgnd, REFIID, LPVOID * );
#endif

HRESULT
CAllPage::ParseValue(VARIANT * pvar)
{
    HRESULT     hr;
    int         i;
    int         cch;
    int         cch2;
    FONTDESC    fd;
    TCHAR *     pch;
    TCHAR *     pch2;
    TCHAR *     pchN;
    TCHAR *     pchString = NULL;

    if (_emode != EMODE_StaticCombo )
    {
        cch = SendMessage(_hWndEdit, WM_GETTEXTLENGTH, 0, 0);
        pchString = new(Mt(CAllPageParseValue_pchString)) TCHAR[cch + 1];
        if (pchString == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        SendMessage(
                _hWndEdit,
                WM_GETTEXT,
                cch + 1,
                (LPARAM) pchString);

        hr = E_INVALIDARG;

        if (_pDPDCur->fSpecialCaseFont)
        {
            pch = _tcsstr(pchString, _T("pt"));
            if (pch)
            {
                memset(&fd, 0, sizeof(FONTDESC));

                fd.cbSizeofstruct = sizeof(FONTDESC);
                fd.sWeight = 400;
                fd.sCharset = DEFAULT_CHARSET;

                *pch = 0;
#if !defined(_MAC) && !defined(UNIX)
                fd.cySize.int64 = _ttol(pchString) * 10000;
#else
                IGNORE_HR(ttol_with_error(pchString, (long *) &fd.cySize.Lo));
                fd.cySize.Lo *= 10000;
                fd.cySize.Hi = 0;
#endif
                pch += 2;
                pch += _tcsspn(pch, _T(" "));

                pch2 = _tcschr(pch, _T(','));
                if (pch2)
                    *pch2 = 0;

                fd.lpstrName = pch;

                while (pch2)
                {
                    pch2++;
                    pch2 += _tcsspn(pch2, _T(" "));
                    pchN  = _tcschr(pch2, _T(','));
                    cch2  = pchN ? pchN - pch2 : _tcslen(pch2);

                    if (_tcsnipre(_T("bold"), 4, pch2, cch2))
                    {
                        fd.sWeight = 700;
                    }
                    else if (_tcsnipre(_T("ital"), 4, pch2, cch2))
                    {
                        fd.fItalic = TRUE;
                    }
                    else if (_tcsnipre(_T("under"), 5, pch2, cch2))
                    {
                        fd.fUnderline = TRUE;
                    }
                    else if (_tcsnipre(_T("strike"), 6, pch2, cch2))
                    {
                        fd.fStrikethrough = TRUE;
                    }

                    pch2 = pchN;
                }

                hr = THR(OleCreateFontIndirect(
                        &fd,
                        IID_IFont,
                        (void **) &V_UNKNOWN(pvar)));
                if (!hr)
                    pvar->vt = VT_UNKNOWN;
            }
        }
        else if (_pDPDCur->fSpecialCasePicture)
        {
            IStream *   pStm;

            if (StrCmpIC(pchString, _T("NULL")) == 0)
            {
                pvar->vt = VT_UNKNOWN;
                V_UNKNOWN(pvar) = NULL;
                hr = S_OK;
            }
            else
            {
#if defined(DEBUG) && !defined(_MAC) && !defined(WINCE)
#define OPCTPATH_DEFAULTS    0 // SYNC | AUTHORTIME | OPAQUE
#define OPCTPATH_ASYCHRONOUS 1
#define OPCTPATH_RUNTIME     2
#define OPCTPATH_RESERVED1   4
                if (IsTagEnabled(tagAsyncPict))
                {
                    // exercise async picture loading thru the new API
                    pStm = pStm;
                    pch2 = new TCHAR[cch + 6];
                    if (pch2 == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                    _tcscpy(pch2, _T("FILE:"));
                    _tcscat(pch2, pchString);

                    hr = THR(OleLoadPicturePath(
                            pch2,
                            NULL,
                            OPCTPATH_ASYCHRONOUS,
                            (OLE_COLOR)RGB(255,0,0),
                            IID_IPicture,
                            (void **) &V_UNKNOWN(pvar)));
                    delete[] pch2;
                    if (!hr)
                        pvar->vt = VT_UNKNOWN;
                }
                else
#endif // defined(DEBUG) && !defined(_MAC) && !defined(WINCE)
                {
                    hr = THR(CreateStreamOnFile(
                            pchString,
                            STGM_SHARE_DENY_WRITE,
                            &pStm));
                    if (!hr)
                    {
                        hr = THR(OleLoadPicture(
                                pStm,
                                0,
                                FALSE,
                                IID_IPicture,
                                (void **) &V_UNKNOWN(pvar)));
                        if (!hr)
                            pvar->vt = VT_UNKNOWN;

                        pStm->Release();
                    }
                }
            }
        }
        else if (_pDPDCur->fSpecialCaseColor)
        {
            // NULL string is not allowed for color value
            if (!*pchString)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            V_I4(pvar) = _tcstoul(pchString, NULL, 16);
            if (V_I4(pvar) != ULONG_MAX)
            {
                pvar->vt = VT_I4;
                hr = S_OK;
            }
        }
        else
        {
            // If property value is numberic, and there is nothing in editbox
            // set default value be 0.
            if (!_tcslen(pchString) && ( (_pDPDCur->vt == VT_I2) ||
                    (_pDPDCur->vt == VT_I4) || (_pDPDCur->vt == VT_R4) ||
                    (_pDPDCur->vt == VT_R8) ))
            {
                hr = THR(FormsAllocString(_T("0"), &V_BSTR(pvar)));
            }
            else
            {
                hr = THR(FormsAllocString(pchString, &V_BSTR(pvar)));
            }
            if (!hr)
            {
                pvar->vt = VT_BSTR;
            }
        }
    }
    else
    {
        //
        //  This assumes that the combobox edit field is read-only
        //  (ie, the combobox is CBS_DROPDOWNLIST).
        //
        i = SendMessage(_hWndEdit, CB_GETCURSEL, 0, 0);
        if (i == CB_ERR)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            pvar->vt = VT_I4;
            Assert(_pDPDCur && _pDPDCur->pAryEVAL);
            V_I4(pvar) = (*_pDPDCur->pAryEVAL)[i].value;

            hr = S_OK;
        }
    }

Cleanup:
    if ( pchString )
        delete[] pchString;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::DrawItem
//
//  Synopsis:   Renders a line in the owner-draw listbox.
//
//  Arguments:  [pdis]
//
//-------------------------------------------------------------------------

void
CAllPage::DrawItem(DRAWITEMSTRUCT * pdis)
{
    DPD *       pDPD;
    DWORD       dw;
    int         cch;
    int         dxName;
    GDIRECT     rc;
    LPTSTR      szValue;
    TCHAR       ach[FORMS_BUFLEN + 1];
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();
    ULONG       cElem = paryDPD->Size();
#ifdef _MAC
    HFONT       hfontOld=NULL;
#endif

    HPEN        hPen = NULL;
    HPEN        hPenOld = NULL;

    //
    // See if there's anything in the array.  If not then skip to exit
    // code, as the only thing that can happen here is to draw the
    // focus rect.
    //

    if (!cElem)
        goto ExitCode;

    dw = GetDialogBaseUnits();
    cch = (pdis->rcItem.right - pdis->rcItem.left) / LOWORD(dw);

    dxName = LOWORD(dw) * cch * 4 / 10;

    if (pdis->itemState & ODS_SELECTED)
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }

    Assert(cElem > pdis->itemData);
    pDPD = &(*paryDPD)[pdis->itemData];

    if (pDPD->fMemberNotFound)
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_GRAYTEXT));
    }
#ifdef _MAC
    if (_hfontDlg)
        hfontOld = (HFONT)SelectObject(pdis->hDC, _hfontDlg);
#endif
    rc = pdis->rcItem;
    rc.right = rc.left + dxName;

    ExtTextOut(
            pdis->hDC,
            rc.left  + 1,
            rc.top + 1,
            ETO_OPAQUE,
            &rc,
            pDPD->bstrName,
            FormsStringLen(pDPD->bstrName),
            NULL);

    // Create Grey Color Pen
    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_GRAYTEXT));
    hPenOld = (HPEN) SelectObject(pdis->hDC, hPen);

    // Draw vertical grid line
    MoveToEx(pdis->hDC, rc.right, rc.top, (POINT *)NULL);
    LineTo(pdis->hDC, rc.right, rc.bottom);

    rc.left = rc.right + 1;
    rc.right = pdis->rcItem.right;

    if (pDPD->fNoMatch)
    {
        szValue = _T("(mixed)");
    }
    else if (pDPD->fMemberNotFound)
    {
        szValue = _T("(not found)");
    }
    else
    {
        FormatValue(
                &pDPD->var,
                pDPD,
                ach,
                ARRAY_SIZE(ach),
                &szValue);
    }

    ExtTextOut(
            pdis->hDC,
            rc.left  + 1,
            rc.top + 1,
            ETO_OPAQUE,
            &rc,
            szValue,
            _tcslen(szValue),
            NULL);

    // Draw horizontal grid line
    MoveToEx(pdis->hDC, pdis->rcItem.left, pdis->rcItem.bottom - 1, (POINT *)NULL);
    LineTo(pdis->hDC, pdis->rcItem.right, pdis->rcItem.bottom -1);

ExitCode:
    if (pdis->itemState & ODS_FOCUS)
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
#ifdef _MAC
    if (hfontOld)
        SelectObject(pdis->hDC, hfontOld);
#endif

    SelectObject(pdis->hDC, hPenOld);
    DeleteObject(hPen);
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetDirty
//
//  Synopsis:   Changes the dirty status for the page.
//
//  Arguments:  [dw]        Combination of PROPPAGESTATUS_* values
//
//-------------------------------------------------------------------------

void
CAllPage::SetDirty(DWORD dw)
{
    _fDirty = (dw & PROPPAGESTATUS_DIRTY) != 0;
#ifndef PRODUCT_96
    _pPageSite->OnStatusChange(dw | PROPPAGESTATUS_DIRTY);
#endif
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OnSize
//
//  Synopsis:   Called when the page changes size; the size of child
//              control is adjusted to match.
//
//-------------------------------------------------------------------------

void
CAllPage::OnSize( )
{
    RECT    rc;
    RECT    rcList;
    RECT    rcEdit;
    int     cy;
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();

    GetClientRect(_hWndPage, &rc);

    ::GetWindowRect(_hWndList, &rcList);
    ScreenToClient(_hWndPage, (LPPOINT) &rcList.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcList.right);

    ::GetWindowRect(_hWndEdit, &rcEdit);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.right);

    MoveWindow(
            _hWndList,
            rcList.left,
            rcList.top,
            (rc.right - rc.left) - 2 * rcList.left,
            (rc.bottom - rc.top) - rcList.top - rcEdit.top,
            TRUE);

    //  Since the columns are proportionately sized, we need to
    //    invalidate on the size done above

    Assert(_hWndList);
    InvalidateRect(_hWndList, (GDIRECT *)NULL, FALSE);

    // Now move on to resizing the editor
    cy = rcEdit.bottom - rcEdit.top;    //(it equals _dyEdit)
    if (IsComboMode(_emode))
    {
        DPD *   pDPD = NULL;
        int     i;
        int     j;

        // If this is in combo box mode then add the size of the list
        // to the y axis
        i = SendMessage(_hWndList, LB_GETCURSEL, 0, 0);
        if (i != LB_ERR)
        {
            j = SendMessage(_hWndList, LB_GETITEMDATA, i, 0);

            Assert((j >= 0) && (j < paryDPD->Size()));
            pDPD = &(*paryDPD)[j];
        }

        Assert(NULL != pDPD);
        // Allow a max of 8 items on the combo box.
        cy += HIWORD(GetDialogBaseUnits()) * min((int)8, pDPD->pAryEVAL->Size()) + 2;
    }

    if (!_hWndButton)
    {
        MoveWindow(
                _hWndEdit,
                rcEdit.left,
                rcEdit.top,
                (rc.right - rc.left) - rcList.left - rcEdit.left,
                cy,
                TRUE);
    }
    else
    {
        MoveWindow(
                _hWndEdit,
                rcEdit.left,
                rcEdit.top,
                (rc.right - rc.left) - rcList.left - rcEdit.left - _dyEdit,
                cy,
                TRUE);

        MoveWindow(
                _hWndButton,
                rc.right- rc.left - rcList.left - _dyEdit,
                rcEdit.top,
                _dyEdit,
                _dyEdit,
                TRUE);
    }

    //  Combo boxes do not invalidate correctly when resized, so
    //    we need to force the invalidation manually

    Assert(_hWndEdit);
    RedrawWindow(
            _hWndEdit,
            (GDIRECT *)NULL,
            NULL,
            RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Refresh
//
//  Synopsis:   Clear old values and update new values in both listbox and
//              Edit window. If dispid is DISPID_UNKNOW, update everything,
//              otherwise, update specify proprety.
//
//  Arguments:  [dispid]
//
//-------------------------------------------------------------------------

HRESULT
CAllPage::Refresh(DISPID dispid)
{
    UpdateEditor(NULL);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Function:   PageWndProc
//
//  Synopsis:   Page window proc.
//
//  Arguments:  [hWnd]
//              [msg]
//              [wParam]
//              [lParam]
//
//  Returns:    long
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK
PageWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAllPage *  pAllPg = (CAllPage *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (msg)
    {
#ifdef _MAC
    case WM_MACINTOSH:
        switch (LOWORD(wParam))
        {
            case WLM_SETMENUBAR:
            // dont change the menu bar
                return TRUE;
        }
        break;
#endif
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, GWLP_USERDATA, lParam);

        pAllPg = (CAllPage *)lParam;
        pAllPg->_hWndEdit = GetDlgItem(hWnd, IDE_PROPVALUE);
        pAllPg->_hWndList = GetDlgItem(hWnd, IDC_PROPNAME);

        if (pAllPg->_hWndList)
        {
            // NOTE: we could put a Verify() around this line, but it may fail
            // if "no-one" has the focus currently.
            ::SetFocus(pAllPg->_hWndList);
        }
        break;

#ifndef WINCE
    case WM_NCDESTROY:
#else
    case WM_DESTROY:
#endif
        pAllPg->_hWndPage =
        pAllPg->_hWndEdit =
        pAllPg->_hWndButton =
        pAllPg->_hWndList = NULL;
        break;

    case WM_DRAWITEM:
        pAllPg->DrawItem((DRAWITEMSTRUCT *) lParam);
        return TRUE;

    case WM_SIZE:
        pAllPg->OnSize();
        break;

   case WM_SHOWWINDOW:
        // Only do something if the message is sent because of
        // a call to the ShowWindow function;
        if (! (int)lParam)
        {
            if (wParam)
            {
                IGNORE_HR(pAllPg->UpdatePage());
            }
            else
            {
                pAllPg->ReleaseVars();
            }
        }
        break;

    case WM_DEFERUPADTE:
        if (IsWindowVisible(hWnd))
        {
            pAllPg->Refresh(0);
        }
        break;

    case WM_CBSELCHANGED:
        pAllPg->UpdateEngine();
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_PROPNAME)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                pAllPg->UpdateEditor(NULL);
                pAllPg->UpdateEngine();
                break;

            case LBN_DBLCLK:
                if (pAllPg->_pDPDCur)
                {
                    switch (pAllPg->_emode)
                    {
                    case CAllPage::EMODE_Edit:
                        // set focus to the edit window and select all to start typing
                        SetFocus(pAllPg->_hWndEdit);
                        SendMessage(pAllPg->_hWndEdit, EM_SETSEL, 0, -1);
                        break;

                    case CAllPage::EMODE_StaticCombo:
                    case CAllPage::EMODE_EditCombo:
                        // advance the combo list to the next enum element, wrapping around 0
                        {
                            long cnt = SendMessage(pAllPg->_hWndEdit, CB_GETCOUNT, 0, 0);
                            long sel = SendMessage(pAllPg->_hWndEdit, CB_GETCURSEL, 0, 0);
                            if (sel != CB_ERR)
                            {
                                if (++sel >= cnt)
                                    sel = 0;
                                SendMessage(pAllPg->_hWndEdit, CB_SETCURSEL, sel, 0);
                                goto ComboSelectChanged;
                            }
                        }
                        break;

                    case CAllPage::EMODE_EditButton:
                    case CAllPage::EMODE_ComboButton:
                        // do the button action (bring up the picker)
                        pAllPg->OnButtonClick();
                        break;
                    }
                }
                break;
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_PROPVALUE &&
                 !pAllPg->_fInUpdateEditor)
        {
            if (pAllPg->_emode == CAllPage::EMODE_Edit)
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case EN_CHANGE:
                    pAllPg->UpdateEngine();
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY);
                    break;
                }
            }
            else
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case CBN_EDITCHANGE:
                    pAllPg->UpdateEngine();
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY);
                    break;

ComboSelectChanged:
                case CBN_SELCHANGE:
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE);
                    PostMessage(pAllPg->_hWndPage, WM_CBSELCHANGED, 0, 0);
                    break;
                }
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDB_APPLY)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                pAllPg->Apply();
                break;
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDB_OPENDLG)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                pAllPg->OnButtonClick();
                break;
            }
        }
        break;
    }

    return FALSE;
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\moniker\simgprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       resprot.cxx
//
//  Contents:   Implementation of the sysimage protocol
//
//  History:    06-15-98    dli     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "simgprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_SHLWAPIP_H_
#define X_SHLWAPIP_H_
#include "shlwapip.h"  // for the definition of Shell_GetCachedImageIndexWrap
#endif

// The following data structures are standard icon file structures
typedef struct tagICONDIRENTRY
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} ICONDIRENTRY;

typedef struct tagICONDIR
{
    WORD iReserved;
    WORD iResourceType;
    WORD cresIcons;
} ICONDIR;


MtDefine(CSysimageProtocol, Protocols, "CSysimageProtocol")
MtDefine(CSysimageProtocolDoParseAndBind_pb, Protocols, "CSysimageProtocol::DoParseAndBind pb")
MtDefine(CSysimageProtocolDoParseAndBind_pbMask, Protocols, "CSysimageProtocol::DoParseAndBind pbMask")

//+---------------------------------------------------------------------------
//
//  Function:   CreateSysimageProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateSysimageProtocol(IUnknown *pUnkOuter)
{
    return new CSysimageProtocol(pUnkOuter);
}

CSysimageProtocolCF   g_cfSysimageProtocol(CreateSysimageProtocol);

//+---------------------------------------------------------------------------
//
//  Method:     CrackSysimageUrl
//
//  Synopsis:   Breaks res: URL into its component strings.
//              NOTE: pcstrSysimageType is allowed to be NULL.
//                    The caller needs only to pass in CStr*'s for the
//                    components they want.
//
//
//  Arguments:  pchURL          Url of the following syntax:
//
//              sysimage://<filename>[,icon index]>[/<small> | <large>]
//
//              pcstrModule     CStr to hold <dll name and location> or the sys_image_list_index
//                              The path may not contain '/' characters
//              pcstrSysimageType    CStr to hold <resource type>
//              pcstrRID        CStr to hold <resource id>
//
//----------------------------------------------------------------------------

HRESULT
CrackSysimageUrl(const TCHAR* pchURL, CStr* pcstrModule, CStr* pcstrSize, CStr* pcstrSelected)
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchNext = NULL;
    TCHAR           achURL[pdlUrlLen];
    DWORD           cchURL;
    //    BOOL            bGetIndex = FALSE;
            
    Assert (pchURL && _tcsnipre(_T("sysimage:"), 9, pchURL, -1));

    if (pcstrSize)
        hr = THR(pcstrSize->Set(_T("")));

    if (pcstrSelected)
        hr = THR(pcstrSelected->Set(_T("")));
    

    // Unescape the URL.
    hr = THR(CoInternetParseUrl(
            pchURL,
            PARSE_ENCODE,
            0,
            achURL,
            ARRAY_SIZE(achURL),
            &cchURL,
            0));
    if (hr)
        goto Cleanup;

    pch = _tcschr(achURL, _T(':'));
    if (!pch)
    {
        goto SyntaxError;
    }

    if (!(_tcsnipre(_T("://"), 3, pch, -1)))
    {
        goto SyntaxError;
    }

    pch += 3;

    //
    // Now look for the executable name
    //

    // we currently do not support index, yet
    //    pchNext = _tcschr(pch, _T(','));
    //    if (!pchNext)
    //    {
    pchNext = _tcschr(pch, _T('/'));
    if (!pchNext)
        goto SyntaxError;
    //    }
    //    else
    //        bGetIndex = TRUE;

    if (pcstrModule)
    {
        hr = THR(pcstrModule->Set(pch, pchNext - pch));
        if (hr)
            goto Cleanup;
    }


    // skip the '/'
    pchNext++;
    
    if (pcstrSize)
    {
        hr = THR(pcstrSize->Set(pchNext));
        if (hr)
            goto Cleanup;
    }

 /*  Add this in when we support index
  if (pchNext)
    {
        // Yes
        //
        // We've found a second '/', which means that the URL
        // contains the <small> | <large> indicator
        //
        if (pcstrSize)
        {
            hr = THR(pcstrSize->Set(pch, pchNext - pch));
            if (hr)
                goto Cleanup;
        }

        // Do we need the selected info?
        if (pcstrSelected)
        {
            // Yes, search for the next '/'
            pch = pchNext + 1;
            pchNext = _tcschr(pch, _T('/'));

            // Found one
            if (pchNext)
            {
                hr = THR(pcstrSize->Set(pch, pchNext - pch));
                if (hr)
                    goto Cleanup;
            }
        }
    }*/

Cleanup:
    RRETURN(hr);

SyntaxError:
    hr = MK_E_SYNTAX;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

#define FILEPROT_PREFIX_LEN 7

HRESULT
CSysimageProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ParseAction == PARSE_SECURITY_URL)
    {
        CStr            cstrModule;
        DWORD           cchNewUrlLen;
        TCHAR           achFullResourceName [pdlUrlLen];
        
        *pcchResult = FILEPROT_PREFIX_LEN;

        hr = THR(CrackSysimageUrl (pwzUrl, &cstrModule, NULL, NULL));
        if (hr)
            goto Cleanup;
        
#ifndef WIN16
        {
            CStrIn  strinResName ((LPWSTR)cstrModule);
            CStrOut stroutFile (achFullResourceName, pdlUrlLen);
            char *  pstrFileName;

            cchNewUrlLen = ::SearchPathA (NULL,
                                          strinResName,
                                          NULL,
                                          pdlUrlLen,
                                          stroutFile,
                                          &pstrFileName);
        }
#else
        {
            char *  pstrFileName;
            cchNewUrlLen = ::SearchPathA (NULL,
                                          cstrModule,
                                          NULL,
                                          pdlUrlLen,
                                          achFullResourceName,
                                          &pstrFileName);
        }
#endif // WIN16

        //
        // The returned path is now stored as a TCHAR in achFullResourceName.
        //

        if (!cchNewUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        *pcchResult += cchNewUrlLen + 1; // total mem needed includes \0 terminator

        if (*pcchResult > pdlUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        if (*pcchResult > cchResult)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcsncpy(pwzResult, _T("file://"), FILEPROT_PREFIX_LEN);
        _tcscpy(pwzResult + FILEPROT_PREFIX_LEN, achFullResourceName);

        Assert (_tcslen(pwzResult) + 1 == *pcchResult);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
                                         pwzUrl,
                                         ParseAction,
                                         dwFlags,
                                         pwzResult,
                                         cchResult,
                                         pcchResult,
                                         dwReserved));
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CSysimageProtocol::s_classdesc =
{
    &CLSID_SysimageProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::CSysimageProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CSysimageProtocol::CSysimageProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
    TCHAR szWindows[MAX_PATH];
    SHFILEINFO sfi = {0};
    GetWindowsDirectory(szWindows, ARRAY_SIZE(szWindows));
    _himglSmall = (HIMAGELIST)SHGetFileInfo(szWindows, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
    _himglLarge = (HIMAGELIST)SHGetFileInfo(szWindows, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_LARGEICON);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::~CSysimageProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CSysimageProtocol::~CSysimageProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    DWORD           dwSize;
    TCHAR *pchBuf = new TCHAR[pdlUrlLen];

    if (pchBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, pchBuf, pdlUrlLen, &dwSize, 0));
    if (hr)
        goto Cleanup;

    hr = THR(_cstrURL.Set(pchBuf));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //

    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    if (pchBuf != NULL)
        delete pchBuf;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::ParseAndBind()
{
    RRETURN(DoParseAndBind(_cstrURL, _cstrModule, _cstrSize, _cstrSelected, &_pStm, this));
}


void
CSysimageProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::DoParseAndBind
//
//  Synopsis:   Static helper to actually perform the binding of protocol.
//
//  Arguments:  pchURL          Url to bind to [needed]
//              cstrRID         Resource id extracted from url [needed]
//              cstrModule     Resource dll name extracted from url [needed]
//              ppStm           Stream of data from resource [needed]
//              pProt           Protocol object that's involved [optional]
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::DoParseAndBind(
    TCHAR *pchURL, 
    CStr &cstrModule,
    CStr &cstrSize,
    CStr &cstrSelected,                                  
    IStream **ppStm,
    CSysimageProtocol *pProt)
{
    HRESULT         hr = S_OK;
    TCHAR *         pchBuf = NULL;
    CROStmOnBuffer *prostm = NULL;
    ULONG           cbmi=0;
    ULONG           cb=0;
    ULONG           cbM=0;
    BYTE *          pb = NULL;
    BYTE *          pbMask = NULL;
//    TCHAR *         pch = NULL;
    SHFILEINFO      sfi = {0};
    DWORD           dwShgfi = 0;
    UNALIGNED void * pvdBitsXOR = NULL;
    UNALIGNED void * pvdBitsAND = NULL;
    HDC             hdcT  = NULL;
    UNALIGNED BITMAPINFO *    pbmi = NULL;
    BITMAPINFO *    pbmiMask = NULL;
    ICONDIR *       pifh = NULL;
    ICONINFO        iconinfo = {0};
    BITMAP          bm = {0};
    BITMAP          bmMask = {0};
    DWORD           cbDib;
    DWORD           cbMask;
    UNALIGNED ICONDIRENTRY *  pide;
    int             nColors = 0;
    TCHAR           achFullModuleName [MAX_PATH];
    TCHAR        *  pstrFileName;
    int             iIconIndex = 0;
    
    // for icon # feature
    // int             iModuleIndex;

    hr = THR(CrackSysimageUrl (pchURL, &cstrModule, &cstrSize, &cstrSelected));
    if (hr)
        goto Cleanup;

    // got to have a real module to load icon from
    Assert((TCHAR *)cstrModule);

    if (cstrModule.Length() >= MAX_PATH)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // determine the icon size to load 
    dwShgfi = SHGFI_ICON | SHGFI_SHELLICONSIZE;
    if (cstrSize.Length())
    {
        if (_tcsequal(cstrSize, _T("small")))
            dwShgfi |= SHGFI_SMALLICON;
        if (_tcsequal(cstrSize, _T("large")))
            dwShgfi |= SHGFI_LARGEICON;
    }

    iIconIndex = PathParseIconLocation(cstrModule);
    
    // get the full path of the module, in case of failure, use the windows directory
    if (0 == SearchPath(NULL, cstrModule, NULL, MAX_PATH, achFullModuleName, &pstrFileName))
    {
        GetWindowsDirectory(achFullModuleName, ARRAY_SIZE(achFullModuleName));
        iIconIndex = 0;
    }
    
    // get the icon
    if (iIconIndex != 0)
    {
        iIconIndex = Shell_GetCachedImageIndexWrap(achFullModuleName, iIconIndex, 0);
        sfi.hIcon = ImageList_GetIcon((dwShgfi & SHGFI_SMALLICON) ? pProt->_himglSmall : pProt->_himglLarge, iIconIndex, 0);
    }
    else
        SHGetFileInfo((TCHAR *)achFullModuleName, 0, &sfi, sizeof(sfi), dwShgfi);

    if (!sfi.hIcon)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get icon info
    if (!GetIconInfo(sfi.hIcon, &iconinfo) && iconinfo.fIcon)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get bitmap information on this icon 
    if (!GetObject(iconinfo.hbmColor, sizeof(bm), &bm) || !GetObject(iconinfo.hbmMask, sizeof(bmMask), &bmMask))
    {
    hr = E_FAIL;
        goto Cleanup;
    }

    // if this the most efficient way to round up to 4?
    cbDib = (bm.bmWidthBytes + 3) / 4 * 4 * bm.bmHeight;
    cbMask = (bmMask.bmWidthBytes + 3) / 4 * 4 * bm.bmHeight;

    // Compute the number of colors using BitsPixel only if BitsPixel is no
    // greater than 8 
    if (bm.bmBitsPixel <= 8)
        nColors = 1 << bm.bmBitsPixel;

    // Allocate the maximum possible memory 
    cbmi = sizeof( BITMAPINFOHEADER ) + nColors * sizeof( RGBQUAD );
    cb = cbDib + cbMask + cbmi + sizeof(ICONDIR) + sizeof(ICONDIRENTRY);

    pb = new(Mt(CSysimageProtocolDoParseAndBind_pb)) BYTE [cb];
    
    if (!pb)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    cbM = sizeof(BITMAPINFOHEADER) + (2 * sizeof(RGBQUAD)); // we need two quads for 1 bit color     	 
    pbMask = new(Mt(CSysimageProtocolDoParseAndBind_pbMask)) BYTE [cbM];
    
    if (!pbMask)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pbmiMask = (BITMAPINFO *) pbMask;

    // zero initialize
    ZeroMemory(pb, cb);
    ZeroMemory(pbMask, cbM);
    
    // Set up the icon file header
    pifh = (ICONDIR *)pb;
    pifh->iReserved = 0;
    pifh->iResourceType = 1;
    pifh->cresIcons = 1;

    // ICONDIRENTRY
    pide = (UNALIGNED ICONDIRENTRY *)(pb + sizeof(ICONDIR)); 
    pide->cx = bm.bmWidth;
    pide->cy = bm.bmHeight;
    pide->nColors = (BYTE)nColors;
    pide->cbDIB = cbDib;
    pide->offsetDIB = sizeof(ICONDIR) + sizeof(ICONDIRENTRY);

    // BITMAPINFOHEADER
    pbmi = (UNALIGNED BITMAPINFO *)(pb + sizeof(ICONDIR) + sizeof(ICONDIRENTRY));
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = bm.bmWidth;
    pbmi->bmiHeader.biHeight         = bm.bmHeight;
    pbmi->bmiHeader.biPlanes         = 1;
    pbmi->bmiHeader.biBitCount       = bm.bmBitsPixel;

    pvdBitsXOR = (UNALIGNED void *)(pb + sizeof(ICONDIR) + sizeof(ICONDIRENTRY) + cbmi);
    hdcT = CreateCompatibleDC(NULL);
    {
        // we have to cook up an aligned BITMAPINFO and lpvoid for GetDIBits to fill, then copy the results over
        BITMAPINFO  *   pbmiTemp = NULL;
        void        *   pvdBitsXORTemp = NULL;

        pbmiTemp = (BITMAPINFO *)MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbmi );
        if( !pbmiTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error1;
        }

        pvdBitsXORTemp = MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbDib );
        if( !pvdBitsXORTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error1;
        }

        // Set up our temporary aligned copies of people
        memcpy( pbmiTemp, pbmi, cbmi );
        ZeroMemory( pvdBitsXORTemp, cbDib );

        if (!GetDIBits(hdcT, iconinfo.hbmColor, 0, bm.bmHeight, pvdBitsXORTemp, pbmiTemp, DIB_RGB_COLORS))
        {
            hr = S_FALSE;
            goto Error1;
        }

        // Copy the results back
        memcpy( pbmi, pbmiTemp, cbmi );
        memcpy( pvdBitsXOR, pvdBitsXORTemp, cbDib );

Error1:
        MemFree( pbmiTemp );
        MemFree( pvdBitsXORTemp );
        if( hr )
        {
            hr = ( hr == S_FALSE ) ? S_OK : hr;
            goto Cleanup;
        }
    }
    
    pvdBitsAND = (BYTE *)pvdBitsXOR + cbDib;
    *pbmiMask = *pbmi;
    pbmiMask->bmiHeader.biBitCount = 1;
    {
        // we have to cook up an aligned BITMAPINFO and lpvoid for GetDIBits to fill, then copy the results over
        BITMAPINFO  *   pbmiMaskTemp = NULL;
        void        *   pvdBitsANDTemp = NULL;

        pbmiMaskTemp = (BITMAPINFO *)MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbM );
        if( !pbmiMaskTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error2;
        }

        pvdBitsANDTemp = MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbMask );
        if( !pvdBitsANDTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error2;
        }

        // Set up our temporary aligned copies of people
        memcpy( pbmiMaskTemp, pbmiMask, cbM );
        ZeroMemory( pvdBitsANDTemp, cbMask );

        if (!GetDIBits(hdcT, iconinfo.hbmMask, 0, bmMask.bmHeight, pvdBitsANDTemp, pbmiMaskTemp, DIB_RGB_COLORS))
        {
            hr = S_FALSE;
            goto Error2;
        }

        // Copy the results back
        memcpy( pbmiMask, pbmiMaskTemp, cbM );
        memcpy( pvdBitsAND, pvdBitsANDTemp, cbMask );

Error2:
        MemFree( pbmiMaskTemp );
        MemFree( pvdBitsANDTemp );
        if( hr )
        {
            hr = ( hr == S_FALSE ) ? S_OK : hr;
            goto Cleanup;
        }
    }

    // set the height to be twice the real image height, this is icon file standard
    pbmi->bmiHeader.biHeight = bm.bmHeight * 2;

    // tell URLMON we have an ICON image
    pchBuf = (TCHAR *)pb;
    hr = THR(pProt->_pProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, TEXT("image/x-icon")));
    if (hr)
        goto Cleanup;

    // cb includes the null terminator
    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    *ppStm = (IStream *)prostm;
    (*ppStm)->AddRef();

Cleanup:
    if (pProt)
    {
        if (!pProt->_fAborted)
        {
            if (!hr && cb > 0)
            {   
                pProt->_ReportData(cb);
            }
            if (pProt->_pProtSink)
            {
                pProt->_pProtSink->ReportResult(hr, 0, 0);
            }
        }
    }

    if (hdcT)
        DeleteDC(hdcT);

    if (prostm)
    {
        prostm->Release();
    }

    delete [] pb;
    delete [] pbMask;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\project.inc ===
# project.inc - project specific settings

SITE_INC_DIRS = $(SRCROOT)\site\include $(SRCROOT)\core\include 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\f3\include $(SDKDIR) 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(BLDROOT)\types $(SRCROOT)\core\types 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\f3\types $(SRCROOT)\f3\ocx96
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\site\types
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\other\include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\other\proppage\commit.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Micros oft Corporation, 1996
//
//  File:       commit.cxx
//
//  Contents:   Implementation of the proppage commit engine
//
//  History:    07-05-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"
#endif

MtDefine(EnsureCommitHolder_paryHolder, Dialogs, "EnsureCommitHolder paryHolder")
MtDefine(EnsureCommitHolder_paryHolder_pv, Dialogs, "EnsureCommitHolder paryHolder::_pv")
MtDefine(CCommitHolder, Dialogs, "CCommitHolder")
MtDefine(CCommitHolder_aryEngine_pv, CCommitHolder, "CCommitHolder::_aryEngine::_pv")
MtDefine(CCommitEngine, Dialogs, "CCommitEngine")
MtDefine(CCommitEngine_aryObjs_pv, CCommitEngine, "CCommitEngine::_aryObjs::_pv")
MtDefine(CCommitEngine_aryDPD_pv, CCommitEngine, "CCommitEngine::_aryDPD::_pv")
MtDefine(CCommitEngine_dpdBool_pAryEVAL, CCommitEngine, "CCommitEngine::_dpdBool.pAryEVAL")
MtDefine(CCommitEngine_dpdBool_pAryEVAL_pv, CCommitEngine, "CCommitEngine::_dpdBool.pAryEVAL_pv")
MtDefine(CCommitEngine_dpdColor_pAryEVAL, CCommitEngine, "CCommitEngine::_dpdColor.pAryEVAL")
MtDefine(CCommitEngine_dpdColor_pAryEVAL_pv, CCommitEngine, "CCommitEngine::_dpdColor.pAryEVAL_pv")
MtDefine(CCommitEngineParseUserDefined_pDPD_pAryEVAL, Dialogs, "CCommitEngine::ParseUserDefined pDPD->pAryEVAL")
MtDefine(CCommitEngineParseUserDefined_pDPD_pAryEVAL_pv, Dialogs, "CCommitEngine::ParseUserDefined pDPD->pAryEVAL::_pv")

void    
DeinitCommitHolder(THREADSTATE *pts)
{
    if (pts->prop.paryCommitHolder)
    {
        delete pts->prop.paryCommitHolder;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCommitHolder
//
//  Synopsis:   Creator of commit holder
//
//  Arguments:  dwID    Some identification of the object
//                      requesting the ensure.  This id is the same
//                      across all objects wanting to link to the 
//                      same commit holder.
//
//  Notes:      Property pages that want to sync contents need to call
//              this function very early on.  This is because some frames
//              may delay calling functions such as SetObjects and
//              Activate until late.  Typically this is done as soon
//              as the pagesite is set on the proppage.
//
//-------------------------------------------------------------------------

HRESULT 
EnsureCommitHolder(DWORD_PTR dwID, CCommitHolder **ppHolder)
{
    HRESULT                     hr = S_OK;
    CPtrAry<CCommitHolder *> *  paryHolder = TLS(prop.paryCommitHolder);
    CCommitHolder *             pHolderNew = NULL;
    long                        i;

    if (!paryHolder)
    {
        paryHolder = new(Mt(EnsureCommitHolder_paryHolder)) CPtrAry<CCommitHolder *>(Mt(EnsureCommitHolder_paryHolder_pv));
        if (!paryHolder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        TLS(prop.paryCommitHolder) = paryHolder;
    }
    
    Assert(paryHolder);

    //
    // Check the global holders first and see if the id's match.
    // If so, then we can bail out right here.
    //

    for (i = 0; i < paryHolder->Size(); i++)
    {
        if ((*paryHolder)[i]->_dwID == dwID)
        {
            (*paryHolder)[i]->AddRef();
            *ppHolder = (*paryHolder)[i];
            goto Cleanup;
        }
    }

    //
    // If we're here then either there is no holder in global memory or
    // there is a global holder but someone wants to 
    // create another holder.  Either way, we can just forget about
    // the existing global commit holder.
    //
    
    pHolderNew = new CCommitHolder(dwID);
    if (!pHolderNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(paryHolder->Append(pHolderNew));
    if (hr)
        goto Error;
        
    *ppHolder = pHolderNew;
    
Cleanup:
    RRETURN(hr);

Error:
    delete pHolderNew;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::CCommitHolder
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCommitHolder::CCommitHolder(DWORD_PTR dwID)
    : _aryEngine(Mt(CCommitHolder_aryEngine_pv))
{
    _aryEngine.SetSize(0);
    _ulRefs = 1;
    _dwID = dwID;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::~CCommitHolder
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CCommitHolder::~CCommitHolder()
{
    CPtrAry<CCommitHolder *> *  paryHolder = TLS(prop.paryCommitHolder);
    long                        i;
    
    Assert(paryHolder);

    for (i = 0; i < _aryEngine.Size(); i++)
    {
        delete _aryEngine[i];
    }
    
    _aryEngine.DeleteAll();
    paryHolder->DeleteByValue(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCommitHolder::AddRef
//
//  Synopsis:   Ref counting
//
//----------------------------------------------------------------------------

ULONG
CCommitHolder::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCommitHolder::Release
//
//  Synopsis:   Ref counting
//
//----------------------------------------------------------------------------

void
CCommitHolder::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::GetEngine
//
//  Synopsis:   Get a commit engine based on objects being set.
//
//  Arguments:  cObj        Count of objects
//              ppDisp      Array of dispatch ptrs
//              ppEngine    Engine that is returned.
//
//-------------------------------------------------------------------------

HRESULT
CCommitHolder::GetEngine(
    long cObj, 
    IDispatch **ppDisps, 
    CCommitEngine **ppEngine)
{
    CCommitEngine **    ppEng = NULL;
    long                i;
    IUnknown *          pUnk = NULL;
    IUnknown *          pUnkObj = NULL;
    long                cEngObjs;
    HRESULT             hr = S_OK;
    
    Assert( ppEngine != NULL );
    *ppEngine = NULL;  // for safety.

    // 
    // First search among existing engines to see if one fits the bill
    //

    for (i = _aryEngine.Size(), ppEng = _aryEngine; i > 0; i--, ppEng++)
    {
        cEngObjs = (*ppEng)->_aryObjs.Size();
        if (cEngObjs > 0)
        {
            //
            // It is sufficient to just check only the first dispatch
            // coming in because some set of objects can only be
            // in one commit engine.  
            //
            
            Verify(!(*ppEng)->_aryObjs[0]->QueryInterface(
                IID_IUnknown, 
                (void **)&pUnk));
            Verify(!(*ppDisps)->QueryInterface(IID_IUnknown, (void **)&pUnkObj));
            if (pUnk == pUnkObj)
            {
                //
                // Yay!  We found a match, bail out.
                //
                
                *ppEngine = *ppEng;
                goto Cleanup;
            }
        }
        ClearInterface(&pUnk);
        ClearInterface(&pUnkObj);
    }

    //
    // The fact that we got here implies that no suitable commit engine
    // was found.  So create one up and return it.
    //

    Assert(!*ppEngine);
    *ppEngine = new CCommitEngine();
    if (!*ppEngine)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(_aryEngine.Append(*ppEngine));
    if (hr)
        goto Error;

    hr = THR((*ppEngine)->SetObjects(cObj, ppDisps));
    if (hr)
        goto Error;
        
Cleanup:
    ClearInterface(&pUnk);
    ClearInterface(&pUnkObj);
    RRETURN(hr);

Error:
    if (_aryEngine.Find(*ppEngine) != -1)
        _aryEngine.DeleteByValue(*ppEngine);
    delete *ppEngine;
    *ppEngine = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     DPD::AppendEnumValue
//
//  Synopsis:   Adds a new enumerated value to the list maintained by
//              this property descriptor.
//
//  Arguments:  [pstr]      Friendly name
//              [value]     Value
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
DPD::AppendEnumValue(TCHAR * pstr, int value)
{
    HRESULT hr;
    EVAL    eval;

    Assert(pAryEVAL);
    Assert(fOwnEVAL);

    hr = THR(FormsAllocString(pstr, &eval.bstr));
    if (!hr)
    {
        eval.value = value;

        hr = THR(pAryEVAL->AppendIndirect(&eval));
        if (hr)
            FormsFreeString(eval.bstr);
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     DPD::Free
//
//  Synopsis:   Frees any resources attached to this property descriptor
//
//-------------------------------------------------------------------------

void
DPD::Free( )
{
    int     i;
    EVAL *  pEVAL;

    FormsFreeString(bstrName);
    bstrName = NULL;
    FormsFreeString(bstrType);
    bstrType = NULL;

    VariantClear(&var);
    if (fOwnEVAL && pAryEVAL)
    {
        for (i = pAryEVAL->Size(), pEVAL = *pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            FormsFreeString(pEVAL->bstr);
        }

        delete pAryEVAL;
        pAryEVAL = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::CCommitEngine
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCommitEngine::CCommitEngine()
    : _aryObjs(Mt(CCommitEngine_aryObjs_pv)),
      _aryDPD(Mt(CCommitEngine_aryDPD_pv))
{
    long    i;
    
    //  TODO: May want to do this in SetObjects, so we can return errors...

    static EVALINIT s_aevalBool[] =
    {
        { _T("True"), -1 },
        { _T("False"), 0 },
    };

    static EVALINIT s_aevalColor[] =
    {
        { _T("Scrollbar"), OLECOLOR_FROM_SYSCOLOR(0) },
        { _T("Background"), OLECOLOR_FROM_SYSCOLOR(1) },
        { _T("Active Caption"), OLECOLOR_FROM_SYSCOLOR(2) },
        { _T("Inactive Caption"), OLECOLOR_FROM_SYSCOLOR(3) },
        { _T("Menu"), OLECOLOR_FROM_SYSCOLOR(4) },
        { _T("Window"), OLECOLOR_FROM_SYSCOLOR(5) },
        { _T("Window Frame"), OLECOLOR_FROM_SYSCOLOR(6) },
        { _T("Menu Text"), OLECOLOR_FROM_SYSCOLOR(7) },
        { _T("Window Text"), OLECOLOR_FROM_SYSCOLOR(8) },
        { _T("Caption Text"), OLECOLOR_FROM_SYSCOLOR(9) },
        { _T("Active Border"), OLECOLOR_FROM_SYSCOLOR(10) },
        { _T("Inactive Border"), OLECOLOR_FROM_SYSCOLOR(11) },
        { _T("App Work Space"), OLECOLOR_FROM_SYSCOLOR(12) },
        { _T("Highlight"), OLECOLOR_FROM_SYSCOLOR(13) },
        { _T("Highlight Text"), OLECOLOR_FROM_SYSCOLOR(14) },
        { _T("Button Face"), OLECOLOR_FROM_SYSCOLOR(15) },
        { _T("Button Shadow"), OLECOLOR_FROM_SYSCOLOR(16) },
        { _T("Gray Text"), OLECOLOR_FROM_SYSCOLOR(17) },
        { _T("Button Text"), OLECOLOR_FROM_SYSCOLOR(18) },
        { _T("Inactive Caption Text"), OLECOLOR_FROM_SYSCOLOR(19) },
        { _T("Button Highlight"), OLECOLOR_FROM_SYSCOLOR(20) },
        { _T("3D Dark"), OLECOLOR_FROM_SYSCOLOR(21) },
        { _T("3D Light"), OLECOLOR_FROM_SYSCOLOR(22) },
        { _T("Info Text"), OLECOLOR_FROM_SYSCOLOR(23) },
        { _T("Info Background"), OLECOLOR_FROM_SYSCOLOR(24) },
    };

    _aryObjs.SetSize(0);
    _aryDPD.SetSize(0);
    memset(&_dpdBool, 0, sizeof(DPD));
    _dpdBool.pAryEVAL = new(Mt(CCommitEngine_dpdBool_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngine_dpdBool_pAryEVAL_pv));
    _dpdBool.fOwnEVAL = TRUE;

    for (i = 0; i < ARRAY_SIZE(s_aevalBool); i++)
    {
        IGNORE_HR(_dpdBool.AppendEnumValue(
                s_aevalBool[i].pstr,
                s_aevalBool[i].value));
    }

    memset(&_dpdColor, 0, sizeof(DPD));
    _dpdColor.pAryEVAL = new(Mt(CCommitEngine_dpdColor_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngine_dpdColor_pAryEVAL_pv));
    _dpdColor.fOwnEVAL = TRUE;

    for (i = 0; i < ARRAY_SIZE(s_aevalColor); i++)
    {
        IGNORE_HR(_dpdColor.AppendEnumValue(
                s_aevalColor[i].pstr,
                s_aevalColor[i].value));
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::~CCommitEngine
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CCommitEngine::~CCommitEngine()
{
    ReleaseObjects();
    _dpdBool.Free();
    _dpdColor.Free();
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::SetObjects
//
//  Synopsis:   Set the objects for this commit engine
//
//  Arguments:  cObj        Count of objects
//              ppDisp      Array of dispatch ptrs
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::SetObjects(long cObj, IDispatch **ppDisps)
{
    long        i;
    IDispatch **ppDisp;
    HRESULT     hr;
    
    if (_aryObjs.Size() != 0)
    {
#if DBG == 1
        //
        // The incoming objects better be the same as the ones
        // we have.
        //

        IDispatch **    ppDisp2;
        IUnknown *      pUnk;
        IUnknown *      pUnk2;
        
        Assert(cObj == _aryObjs.Size());
        for (i = cObj, ppDisp = _aryObjs, ppDisp2 = ppDisps;
                i > 0; i--, ppDisp++, ppDisp2++)
        {
            Verify(!(*ppDisp)->QueryInterface(IID_IUnknown, (void **)&pUnk));
            Verify(!(*ppDisp2)->QueryInterface(IID_IUnknown, (void **)&pUnk2));
            Assert(pUnk == pUnk2);
            ReleaseInterface(pUnk);
            ReleaseInterface(pUnk2);
        }
#endif

        return S_OK;
    }

    //
    // First cache a ptr to the dispatches handed in
    //
   
    hr = THR(_aryObjs.EnsureSize(cObj));
    if (hr)
        goto Cleanup;
        
    for (i = cObj, ppDisp = ppDisps; i > 0; i--, ppDisp++)
    {
        hr = THR(_aryObjs.Append(*ppDisp));
        if (hr)
            goto Error;

        (*ppDisp)->AddRef();
    }

    //
    // Now interrogate the dispatches to fill up the property
    // descriptor list.
    //
    
    hr = THR(CreatePropertyDescriptor());
    if (hr)
        goto Error;

    UpdateValues();
        
Cleanup:
    RRETURN(hr);

Error:
    _aryObjs.ReleaseAll();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ReleaseObjects
//
//  Synopsis:   Frees the objects for this commit engine
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ReleaseObjects()
{
    _aryObjs.ReleaseAll();
    RRETURN(ReleasePropertyDescriptor());
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::Commit
//
//  Synopsis:   Commit any dirty properties into the object(s) below.
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::Commit()
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->fReadOnly)
            continue;

        if (pDPD->fDirty)
        {
            if ( pDPD -> fSpecialCaseUnitMeasurement )
            {
                hr = THR(SetCommonSubObjectPropertyValue(
                        pDPD->dispid,
                        3, // Should be dispid of unit meas sub-object Text property
                        _aryObjs.Size(),
                        _aryObjs,
                        &(pDPD->var)));
            }
            else
            {
                hr = THR(SetCommonPropertyValue(
                        pDPD->dispid,
                        _aryObjs.Size(),
                        _aryObjs,
                        &(pDPD->var)));
            }
            if (hr)
                goto Cleanup;

            pDPD->fDirty = 0;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::GetProperty
//
//  Synopsis:   Get the value of some property
//
//  Arguments:  dispid      Dispid to query
//              pvar        Resultant variant
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::GetProperty(DISPID dispid, VARIANT *pvar)
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;

    //
    // First find property descriptor
    //
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->dispid == dispid)
            break;
    }

    if (i <= 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now get property
    //

    VariantInit(pvar);
    hr = THR(VariantCopy(pvar, &(pDPD->var)));
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::SetProperty
//
//  Synopsis:   Set the value of some property
//
//  Arguments:  dispid      Dispid to query
//              pvar        Variant coming in
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::SetProperty(DISPID dispid, VARIANT *pvar)
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;
    
    //
    // First find property descriptor
    //
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->dispid == dispid)
            break;
    }

    if (i <= 0 || pDPD->fReadOnly)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now set property and mark as dirty
    //

    VariantClear(&(pDPD->var));
    hr = THR(VariantCopy(&(pDPD->var), pvar));
    if (hr)
        goto Cleanup;

    pDPD->fDirty = 1;
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::CreatePropertyDescriptor
//
//  Synopsis:   Create property descriptor list based on set objects
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::CreatePropertyDescriptor()
{
    BSTR                        bstr;
    DPD *                       pDPD = NULL;
    DPD *                       pDPD2;
    UINT                        ucNames;
    int                         i, j, k;
    ULONG                       iTI, cTI;
    IDispatch **                ppDisp;
    IProvideMultipleClassInfo * pPMCI   = NULL;
    ITypeInfo *                 pTI     = NULL;
    TYPEATTR *                  pTA     = NULL;
    VARDESC *                   pVD     = NULL;
    FUNCDESC *                  pFD     = NULL;
    HRESULT                     hr      = S_OK;
    BOOL                        fGot;
    BOOL                        fReadOnly = FALSE;

    Assert(_aryDPD.Size() == 0);

    for (i = 0, ppDisp = _aryObjs;
         i < _aryObjs.Size();
         i++, ppDisp++)
    {
        // Determine if the object supports multiple ITypeInfos
        hr = THR_NOTRACE((*ppDisp)->QueryInterface(
                                       IID_IProvideMultipleClassInfo,
                                       (void **)&pPMCI));
        if (!hr)
        {
            hr = THR(pPMCI->GetMultiTypeInfoCount(&cTI));
            if (hr)
                goto Error;
        }
        else
        {
            cTI = 1;
        }

        // If this is not the first object (in the selection), mark each property
        // as "not seen" so those which are not common between all objects may
        // be removed
        if (i > 0)
        {
            for (k = _aryDPD.Size(), pDPD = _aryDPD;
                 k > 0;
                 k--, pDPD++)
            {
                pDPD->fVisit = FALSE;
            }
        }

        // For each ITypeInfo, retrieve the appropriate members
        for (iTI=0; iTI < cTI; iTI++)
        {
            // If the object supports multiple ITypeInfos, retrieve the ITypeInfo by index
            if (pPMCI)
            {
                ITypeInfo * pTICoClass;

                hr = THR(pPMCI->GetInfoOfIndex(iTI,
                                               MULTICLASSINFO_GETTYPEINFO,
                                               &pTICoClass,
                                               NULL, NULL, NULL, NULL));
                if (hr)
                {
                    hr = S_OK;
                    continue;
                }

                hr = THR(GetTypeInfoFromCoClass(pTICoClass, FALSE, &pTI, NULL));
                ReleaseInterface(pTICoClass);
                if (hr)
                    goto Error;
            }

            // Otherwise, obtain the ITypeInfo available through IDispatch
            else
            {
                Assert(cTI == 1);
                Assert(iTI == 0);
                hr = THR((*ppDisp)->GetTypeInfo(0, g_lcidUserDefault, &pTI));
                if (hr)
                {
                    hr = S_OK;
                    continue;
                }
            }

            hr = THR(pTI->GetTypeAttr(&pTA));
            if (hr)
                goto Error;

            if ((pTA->cVars == 0) && (pTA->cFuncs == 0))
                continue;

            // If this is on the first object (in the selection), ensure the array
            // is large enough to hold all the elements
            // (If the object supports multiple ITypeInfos, the array will be grown
            //  by the amount each ITypeInfo contributes)
            if (i == 0)
            {
                int cDPD = _aryDPD.Size();

                hr = THR(_aryDPD.EnsureSize(cDPD + pTA->cVars + pTA->cFuncs));
                if (hr)
                    goto Error;

                pDPD = (DPD *)_aryDPD + cDPD;
            }

            // First, obtain all property descriptions
            for (j = 0; j < pTA->cVars; j++)
            {
                hr = THR(pTI->GetVarDesc(j, &pVD));
                if (hr)
                    goto Error;

                // Do not display non-browsable, or hidden properties
                if (!(pVD->wVarFlags & (VARFLAG_FNONBROWSABLE |
                                        VARFLAG_FHIDDEN)))
                {
                    hr = THR(pTI->GetNames(pVD->memid, &bstr, 1, &ucNames));
                    if (hr)
                        goto Error;

                    if (i == 0)
                    {
                        memset(pDPD, 0, sizeof(DPD));

                        pDPD->dispid = pVD->memid;
                        pDPD->vt = (VARENUM) pVD->elemdescVar.tdesc.vt;
                        pDPD->bstrName = bstr;
                        pDPD->fReadOnly = (pVD->wVarFlags & VARFLAG_FREADONLY) ?
                                (TRUE) : (FALSE);
                        VariantInit(&pDPD->var);

                        if (pDPD->vt == VT_BOOL)
                        {
                            pDPD->pAryEVAL = _dpdBool.pAryEVAL;
                        }
                        else if (pDPD->vt == VT_USERDEFINED || pDPD->vt == VT_PTR)
                        {
                            hr = THR(ParseUserDefined(pTI, pVD, pDPD, TRUE));
                            if (hr)
                            {
                                pDPD->Free();
                                goto Cleanup;
                            }
                        }
                        else if (pDPD->vt == VT_UNKNOWN)
                        {
                            hr = THR ( ParseUnknown(pTI, pDPD) );
                            if ( hr )
                            {
                                pTI->ReleaseVarDesc(pVD);
                                continue;
                            }
                        }

                        pDPD++;
                        _aryDPD.SetSize(_aryDPD.Size() + 1);
                    }
                    else
                    {
                        for (k = _aryDPD.Size(), pDPD = _aryDPD;
                             k > 0;
                             k--, pDPD++)
                        {
                            if (pDPD->dispid == pVD->memid &&
                                pDPD->vt == (VARENUM) pVD->elemdescVar.tdesc.vt &&
                                !FormsStringCmp(pDPD->bstrName, bstr))
                            {
                                pDPD->fVisit = TRUE;
                                break;
                            }
                        }

                        FormsFreeString(bstr);
                    }
                }
                pTI->ReleaseVarDesc(pVD);
                pVD = NULL;
            }

            // Next, obtain all property function descriptions
            for ( ; j < pTA->cVars + pTA->cFuncs; j++)
            {
                hr = THR(pTI->GetFuncDesc(j - pTA->cVars, &pFD));
                if (hr)
                    goto Error;

                fReadOnly = (pFD->invkind == INVOKE_PROPERTYGET) ?
                        (TRUE) : (FALSE);
                fGot = FALSE;

                // Do We have a sub-object
				if (!(pFD->wFuncFlags & 
                        (FUNCFLAG_FRESTRICTED|FUNCFLAG_FNONBROWSABLE|FUNCFLAG_FHIDDEN)) &&
					pFD->funckind == FUNC_DISPATCH &&
					pFD->invkind  == INVOKE_PROPERTYGET &&
					pFD->elemdescFunc.tdesc.vt == VT_PTR &&
					pFD->elemdescFunc.tdesc.lptdesc->vt == VT_USERDEFINED )
                {
                    fGot = TRUE;
                }
                else if// Do not display non-browsable or hidden properties
                    ((pFD->invkind == INVOKE_PROPERTYPUT   ||
                        pFD->invkind == INVOKE_PROPERTYGET ||
                        pFD->invkind == INVOKE_PROPERTYPUTREF ) &&
                        !(pFD->wFuncFlags & (FUNCFLAG_FNONBROWSABLE |
                                         FUNCFLAG_FHIDDEN)))
                {
                    DISPID  dispid = pFD->memid;

                    pTI->ReleaseFuncDesc(pFD);
                    pFD = NULL;

                    // Locate the "get" method for the property
                    hr = FindReadPropFuncDesc(
                                    pTI,
                                    dispid,
                                    j - pTA->cVars + 1,
                                    pTA->cFuncs,
                                    &pFD);
                    // If no "get" method exists, skip the property
                    if (!hr)
                    {
                        fGot = TRUE;
                    }
                }

                if ( fGot )
                {
                    hr = THR(pTI->GetNames(pFD->memid, &bstr, 1, &ucNames));
                    if (hr)
                        goto Error;

                    if (i == 0)
                    {
                        memset(pDPD, 0, sizeof(DPD));

                        pDPD->dispid = pFD->memid;
                        pDPD->fReadOnly = fReadOnly;
#if 1
                        pDPD->vt = (VARENUM) pFD->elemdescFunc.tdesc.vt;
#else
                        if(pFD->funckind == FUNC_PUREVIRTUAL)
                        {
                            pDPD->vt = (VARENUM) pFD->lprgelemdescParam->tdesc.lptdesc->vt;
                        }
                        else
                        {
                            pDPD->vt = (VARENUM) pFD->elemdescFunc.tdesc.vt;
                        }
#endif
                        pDPD->bstrName = bstr;
                        VariantInit(&pDPD->var);

                        if (pDPD->dispid == DISPID_FONT)
                            i = 0;

                        if (pDPD->vt == VT_BOOL)
                        {
                            pDPD->pAryEVAL = _dpdBool.pAryEVAL;
                        }
                        else if (pDPD->vt == VT_USERDEFINED || pDPD->vt == VT_PTR)
                        {
                            hr = THR(ParseUserDefined(pTI, pFD, pDPD, FALSE));
                            if (hr)
                            {
                                pDPD->Free();
                                goto Cleanup;
                            }
                        }
                        else if (pDPD->vt == VT_UNKNOWN)
                        {
                            ParseUnknown(pTI, pDPD);
                        }

                        pDPD++;
                        _aryDPD.SetSize(_aryDPD.Size() + 1);
                    }
                    else
                    {
                        for (k = _aryDPD.Size(), pDPD = _aryDPD;
                             k > 0;
                             k--, pDPD++)
                        {
                            if (pDPD->dispid == pFD->memid &&
                                pDPD->vt == (VARENUM) pFD->elemdescFunc.tdesc.vt &&
                                !FormsStringCmp(pDPD->bstrName, bstr))
                            {
                                pDPD->fVisit = TRUE;
                                break;
                            }
                        }

                        FormsFreeString(bstr);
                    }
                }

                pTI->ReleaseFuncDesc(pFD);
                pFD = NULL;
            }

            pTI->ReleaseTypeAttr(pTA);
            pTA = NULL;

            ClearInterface(&pTI);
        }

        // Remove entries which do not occur on all objects in the selection
        if (i > 0)
        {
            for (k = _aryDPD.Size(), pDPD2 = pDPD = _aryDPD;
                 k > 0;
                 k--, pDPD++)
            {
                if (pDPD->fVisit)
                {
                    if (pDPD != pDPD2)
                        memcpy(pDPD2, pDPD, sizeof(DPD));

                    pDPD2++;
                }
                else
                {
                    pDPD->Free();
                    _aryDPD.SetSize(_aryDPD.Size() - 1);
                }
            }
        }

        ClearInterface(&pPMCI);
    }

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);
    if (pVD)
        pTI->ReleaseVarDesc(pVD);
    if (pFD)
        pTI->ReleaseFuncDesc(pFD);
    ReleaseInterface(pTI);
    ReleaseInterface(pPMCI);

    RRETURN(hr);

Error:
    ReleasePropertyDescriptor();
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ParseUserDefined
//
//  Synopsis:   Parses a user-defined type in an object's TypeInfo.  Called
//              from ExamineObjects.
//
//  Arguments:  [pTIObject]     Object's TypeInfo
//              [pVDObject]     VARDESC for user-defined prop
//              [pDPD]          Descriptor to fill in
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ParseUserDefined(
        ITypeInfo * pTIObject,
        void * pv,
        DPD * pDPD,
        BOOL fVar)
{
    HRESULT             hr;
    TYPEDESC *          ptdesc;
    ITypeInfo *         pTI     = NULL;
    TYPEATTR *          pTA     = NULL;
    VARDESC *           pVD     = NULL;
    BSTR                bstr    = NULL;
    CDataAry<EVAL> *    pAryEVAL;
    int                 i;
    EVAL                eval;

//#ifndef _MAC
#if 1
    ptdesc = fVar ? &((VARDESC *) pv)->elemdescVar.tdesc :
                    &((FUNCDESC *) pv)->elemdescFunc.tdesc;
    if (ptdesc->vt == VT_PTR)
#else
    ptdesc = fVar ? &((VARDESC *) pv)->elemdescVar.tdesc :
                    &((FUNCDESC *) pv)->lprgelemdescParam->tdesc;
    while (ptdesc->vt == VT_PTR)

#endif
    {
        ptdesc = ptdesc->lptdesc;
        pDPD->fIndirect = TRUE;
    }
    if (ptdesc->vt != VT_USERDEFINED)
        return S_OK;

    hr = THR(pTIObject->GetRefTypeInfo(
            ptdesc->hreftype,
            &pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetTypeAttr(&pTA));
    if (hr)
        goto Cleanup;

    //
    // Skip aliases here except for the color
    //

    while (TKIND_ALIAS == pTA->typekind && pTA->guid != GUID_COLOR
        && pTA->tdescAlias.vt == VT_USERDEFINED && pTA->tdescAlias.hreftype != NULL)
    {
        ITypeInfo * pTIAlias = NULL;
        
        Assert(pTA->tdescAlias.vt == VT_USERDEFINED);
        
        hr = THR(pTI->GetRefTypeInfo(pTA->tdescAlias.hreftype, &pTIAlias));
        if (hr)
            goto Cleanup;

        pTI->ReleaseTypeAttr(pTA);
        
        hr = THR(pTIAlias->GetTypeAttr(&pTA));

        ReleaseInterface(pTI);
        pTI = pTIAlias;
        if (hr)
            goto Cleanup;
    }
        
    hr = THR(pTI->GetDocumentation(-1, &bstr, NULL, NULL, NULL));
    if (hr)
        goto Cleanup;

    Assert(pDPD->bstrType == NULL);
    pDPD->bstrType = bstr;
    bstr = NULL;

    switch (pTA->typekind)
    {
    case TKIND_ENUM:
        {
            pAryEVAL = pDPD->pAryEVAL = new(Mt(CCommitEngineParseUserDefined_pDPD_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngineParseUserDefined_pDPD_pAryEVAL_pv));
            if (!pAryEVAL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pDPD->fOwnEVAL = TRUE;

            for (i = 0; i < pTA->cVars; i++)
            {
                hr = THR(pTI->GetVarDesc(i, &pVD));
                if (hr)
                    goto Cleanup;
                Assert(pVD->varkind == VAR_CONST);

                hr = THR(pTI->GetDocumentation(pVD->memid, NULL, &bstr, NULL, NULL));
                if (hr)
                    goto Cleanup;
#ifdef _MAC
                // ISSUE: pTI->GetDocumentation returns a bogus BSTR that is not
                //      NULL terminated and with a byteswapped length.  Temporarily
                //      we get around this by making our own BSTR...
                UINT len = SysStringLen(bstr);
                if(len > 256)  // we don't have any helpstrings bigger than 256 bytes
                {
                    eval.bstr = SysAllocStringLen(bstr,len));
                    SysFreeString(bstr);
                }
                else
                {
                    eval.bstr = bstr;
                }
#else

                eval.bstr = bstr;
#endif
                eval.value = V_I4(pVD->lpvarValue);

                hr = THR(pAryEVAL->AppendIndirect(&eval));
                if (hr)
                    goto Cleanup;

                bstr = NULL;

                pTI->ReleaseVarDesc(pVD);
                pVD = NULL;
            }
        }
        break;

    case TKIND_DISPATCH:
        IGNORE_HR( ParseUnknown(pTI, pDPD));
        break;

    case TKIND_ALIAS:
        if (pTA->guid == GUID_COLOR)
        {
            pDPD->fSpecialCaseColor = TRUE;
            pDPD->pAryEVAL = _dpdColor.pAryEVAL;
        }
        break;
    }

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);
    if (pVD)
        pTI->ReleaseVarDesc(pVD);
    ReleaseInterface(pTI);
    FormsFreeString(bstr);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  M