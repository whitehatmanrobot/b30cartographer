AILSPECIALFOLDER tySpecial);
    BOOL _LoadSpecialFolderName(SPECIALFOLDER tySpecial, LPSTR pszName, DWORD cbBuffer);

    HRESULT _CopyMoveNextMessage(void);

    HRESULT _CopyMoveLocalMessage(MESSAGEID idMessage, 
                              IMessageFolder* pDestFolder,
                              LPSTR pszUrl,
                              BOOL fMoveSource);

    HRESULT _MarkMessageRead(MESSAGEID id, BOOL fRead);

    void _FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult);

    // ----------------------------------------------------------------------------
    // URL Manipulations
    // ----------------------------------------------------------------------------
    HRESULT _BuildUrl(LPCSTR pszFolderComponent, LPCSTR pszNameComponent, LPSTR *ppszUrl);
    HRESULT _BuildMessageUrl(LPCSTR pszFolderUrl, LPSTR pszNameComponent, LPSTR *ppszUrl);

private:
    LONG                            m_cRef;
    HWND                            m_hwnd;
    IMessageStore                   *m_pStore;
    IMessageFolder                  *m_pFolder;
    IHTTPMailTransport              *m_pTransport;
    LPSTR                           m_pszFldrLeafName;
    LPSTR                           m_pszMsgFolderRoot;
    FOLDERID                        m_idServer;
    FOLDERID                        m_idFolder;
    SPECIALFOLDER                   m_tySpecialFolder;
    LPSTR                           m_pszFolderUrl;
    BOOL                            m_fConnected;
    HTTPOPERATION                   m_op;
    INETSERVER                      m_rInetServerInfo;
    char                            m_szAccountName[CCHMAX_ACCOUNT_NAME];
    char                            m_szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount                     *m_pAccount;
    IHTTPMailTransport2             *m_pTransport2;

#ifdef DEBUG
    DWORD                           m_dwThreadId;
#endif // DEBUG
};

HRESULT CreateHTTPMailStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // _HTTPSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\http\httpserv.cpp ===
/*
 *  h t t p s e r v . cpp
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Derives from IMessageServer to implement HTTPMail-specific 
 *           store communication.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "httpserv.h"
#include "httputil.h"
#include "storutil.h"
#include "serverq.h"
#include "tmap.h"
#include "acctcach.h"
#include "urlmon.h"
#include "useragnt.h"
#include "spoolapi.h"
#include "demand.h"

#define CCHMAX_RES 255

static const char s_szHTTPMailServerWndClass[] = "HTTPMailWndClass";

#define AssertSingleThreaded AssertSz(m_dwThreadId == GetCurrentThreadId(), "Multi-threading makes me sad.")

// explicit template instantiations
template class TMap<FOLDERID, CSimpleString>;
template class TPair<FOLDERID, CSimpleString>;

const UINT WM_HTTP_BEGIN_OP = WM_USER;

// SOT_SYNCING_STORE
static const HTTPSTATEFUNCS c_rgpfnSyncStore[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::ListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL }
};

// SOT_SYNC_FOLDER
static const HTTPSTATEFUNCS c_rgpfnSyncFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::ListHeaders, &CHTTPMailServer::HandleListHeaders },
    { &CHTTPMailServer::PurgeMessages, NULL },
    { &CHTTPMailServer::ResetMessageCounts, NULL }
};

// SOT_GET_MESSAGE
static const HTTPSTATEFUNCS c_rgpfnGetMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::GetMessage, &CHTTPMailServer::HandleGetMessage }
};

// SOT_CREATE_FOLDER
static const HTTPSTATEFUNCS c_rgpfnCreateFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::CreateFolder, &CHTTPMailServer::HandleCreateFolder }
};

// SOT_RENAME_FOLDER
static const HTTPSTATEFUNCS c_rgpfnRenameFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::RenameFolder, &CHTTPMailServer::HandleRenameFolder }
};

// SOT_DELETE_FOLDER
static const HTTPSTATEFUNCS c_rgpfnDeleteFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::DeleteFolder, &CHTTPMailServer::HandleDeleteFolder }
};

// SOT_SET_MESSAGEFLAGS
static const HTTPSTATEFUNCS c_rgpfnSetMessageFlags[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::SetMessageFlags, &CHTTPMailServer::HandleMemberErrors},
    { &CHTTPMailServer::ApplyFlagsToStore, NULL }
};

// SOT_DELETING_MESSAGES
static const HTTPSTATEFUNCS c_rgpfnDeleteMessages[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::DeleteMessages, &CHTTPMailServer::HandleMemberErrors },
    { &CHTTPMailServer::DeleteFallbackToMove, &CHTTPMailServer::HandleDeleteFallbackToMove },
    { &CHTTPMailServer::PurgeDeletedFromStore, NULL }
};

// SOT_PUT_MESSAGE
static const HTTPSTATEFUNCS c_rgpfnPutMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::PutMessage, &CHTTPMailServer::HandlePutMessage },
    { &CHTTPMailServer::AddPutMessage, NULL }
};

// SOT_COPYMOVE_MESSAGES (copying or moving one message)
static const HTTPSTATEFUNCS c_rgpfnCopyMoveMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::CopyMoveMessage, &CHTTPMailServer::HandleCopyMoveMessage }
};

// SOT_COPYMOVE_MESSAGES (moving multiple messages)
static const HTTPSTATEFUNCS c_rgpfnBatchCopyMoveMessages[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::BatchCopyMoveMessages, &CHTTPMailServer::HandleBatchCopyMoveMessages},
    { &CHTTPMailServer::FinalizeBatchCopyMove, NULL }
};

// SOT_GET_ADURL (gets ad url from Hotmail)
static const HTTPSTATEFUNCS c_rgpfnGetAdUrl[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetAdBarUrlFromServer, NULL }
};


// SOT_GET_HTTP_MINPOLLINGINTERVAL (gets Minimum polling interval from http server)
static const HTTPSTATEFUNCS c_rgpfnGetMinPollingInterval[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMinPollingInterval, NULL }
};

class CFolderList
{
public:
    // Public factory function.
    static HRESULT Create(IMessageStore *pStore, FOLDERID idRoot, CFolderList **ppFolderList);

private:
    // Constructor is private. Use "Create" to instantiate.
    CFolderList();
    ~CFolderList();

private:
    // unimplemented copy constructor/assignment operator
    CFolderList(const CFolderList& other);
    CFolderList& operator=(const CFolderList& other);

public:
    ULONG   AddRef(void);
    ULONG   Release(void);

    FOLDERID    FindAndRemove(LPSTR pszUrlComponent, DWORD *pcMessages, DWORD *pcUnread);
    FOLDERID    FindAndRemove(SPECIALFOLDER tySpecial, DWORD *pcMessages, DWORD *pcUnread);

    void    PurgeRemainingFromStore(void);
private:
    typedef struct tagFOLDERLISTNODE
    {
        LPSTR               pszUrlComponent;
        FLDRFLAGS           dwFlags;
        FOLDERID            idFolder;
        SPECIALFOLDER       tySpecial;
        DWORD               cMessages;
        DWORD               cUnread;
        tagFOLDERLISTNODE   *pflnNext;
    } FOLDERLISTNODE, *LPFOLDERLISTNODE;

    LPFOLDERLISTNODE _AllocNode(void)
    {
        LPFOLDERLISTNODE pflnNode = new FOLDERLISTNODE;
        if (pflnNode)
        {
            pflnNode->pszUrlComponent = NULL;
            pflnNode->dwFlags = 0;
            pflnNode->idFolder = FOLDERID_INVALID;
            pflnNode->tySpecial = FOLDER_NOTSPECIAL;
            pflnNode->cMessages = 0;
            pflnNode->cUnread = 0;
            pflnNode->pflnNext = NULL;
        }
        return pflnNode;
    }
    
    HRESULT HrInitialize(IMessageStore *pStore, FOLDERID idRoot);

    void _FreeNode(LPFOLDERLISTNODE pflnNode)
    {
        if (pflnNode)
        {
            SafeMemFree(pflnNode->pszUrlComponent);
            delete pflnNode;
        }
    }

    void _FreeList(void);

private:
    ULONG               m_cRef;
    IMessageStore       *m_pStore;
    LPFOLDERLISTNODE    m_pflnList;
};

//----------------------------------------------------------------------
// CFolderList::Create
//----------------------------------------------------------------------

HRESULT CFolderList::Create(IMessageStore *pStore, FOLDERID idRoot, CFolderList **ppFolderList)
{
    HRESULT     hr = S_OK;
    CFolderList *pFolderList = NULL;

    if (NULL == pStore || FOLDERID_INVALID == idRoot || NULL == ppFolderList)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    *ppFolderList = NULL;
    pFolderList = new CFolderList();
    if (!pFolderList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    IF_FAILEXIT(hr = pFolderList->HrInitialize(pStore, idRoot));

    *ppFolderList = pFolderList;
    pFolderList = NULL;

exit:

    SafeRelease(pFolderList);
    return hr;
}

//----------------------------------------------------------------------
// CFolderList::CFolderList
//----------------------------------------------------------------------
CFolderList::CFolderList(void) :
    m_cRef(1),
    m_pStore(NULL),
    m_pflnList(NULL)
{
    // nothing to do
}

//----------------------------------------------------------------------
// CFolderList::~CFolderList
//----------------------------------------------------------------------
CFolderList::~CFolderList(void)
{    
    _FreeList();
    SafeRelease(m_pStore);
}

//----------------------------------------------------------------------
// CFolderList::AddRef
//----------------------------------------------------------------------
ULONG CFolderList::AddRef(void)
{
    return (++m_cRef);
}

//----------------------------------------------------------------------
// CFolderList::Release
//----------------------------------------------------------------------
ULONG CFolderList::Release(void)
{
    if (0 == --m_cRef)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}

//----------------------------------------------------------------------
// CFolderList::_FreeList
//----------------------------------------------------------------------
void CFolderList::_FreeList(void)
{
    LPFOLDERLISTNODE pflnDeleteMe;

    while (m_pflnList)
    {
        pflnDeleteMe = m_pflnList;
        m_pflnList = m_pflnList->pflnNext;

        _FreeNode(pflnDeleteMe);
    }
}

//----------------------------------------------------------------------
// CFolderList::HrInitialize
//----------------------------------------------------------------------
HRESULT CFolderList::HrInitialize(IMessageStore *pStore, FOLDERID idRoot)
{
    HRESULT				hr=S_OK;
	IEnumerateFolders	*pFldrEnum = NULL;
    FOLDERINFO			fi;
    FOLDERLISTNODE      flnDummyHead= { NULL, 0, 0, NULL };
    LPFOLDERLISTNODE    pflnTail = &flnDummyHead;
    LPFOLDERLISTNODE    pflnNewNode = NULL;

    if (NULL == pStore)
    {
        hr = TraceResult(E_INVALIDARG);
        return hr;
    }
    
    if (NULL != m_pflnList)
    {
        hr = TraceResult(ERROR_ALREADY_INITIALIZED);
        return hr;
    }

    m_pStore = pStore;
    m_pStore->AddRef();

    // this function assumes that the folder list is flat.
    // it needs to be modified to support a hierarchical store.

    IF_FAILEXIT(hr = pStore->EnumChildren(idRoot, FALSE, &pFldrEnum));

    pFldrEnum->Reset();
    
    // build a linked list of folder nodes
    while (S_OK == pFldrEnum->Next(1, &fi, NULL))
    {
        pflnNewNode = _AllocNode();
        if (NULL == pflnNewNode)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            pStore->FreeRecord(&fi);
            _FreeList();
            goto exit;
        }
        
        pflnNewNode->pszUrlComponent = PszDupA(fi.pszUrlComponent);
        pflnNewNode->dwFlags = fi.dwFlags;
        pflnNewNode->idFolder = fi.idFolder;
        pflnNewNode->tySpecial = fi.tySpecial;
        pflnNewNode->cMessages = fi.cMessages;
        pflnNewNode->cUnread = fi.cUnread;

        pflnTail->pflnNext = pflnNewNode;
        pflnTail = pflnNewNode;
        pflnNewNode = NULL;

        pStore->FreeRecord(&fi);
    }

    m_pflnList = flnDummyHead.pflnNext;

exit:
    ReleaseObj(pFldrEnum);
    return hr;
}

//----------------------------------------------------------------------
// CFolderList::FindAndRemove
//----------------------------------------------------------------------
FOLDERID CFolderList::FindAndRemove(LPSTR pszUrlComponent,
                                    DWORD *pcMessages, 
                                    DWORD *pcUnread)
{
    LPFOLDERLISTNODE    pflnPrev = NULL;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    FOLDERID            idFound = FOLDERID_INVALID;

    if (NULL == pszUrlComponent)
        return FOLDERID_INVALID;

    if (pcMessages)
        *pcMessages = 0;
    if (pcUnread)
        *pcUnread = 0;

    while (pflnCur)
    {
        if ((NULL != pflnCur->pszUrlComponent) && (0 == lstrcmp(pflnCur->pszUrlComponent, pszUrlComponent)))
        {
            if (NULL == pflnPrev)
                m_pflnList = pflnCur->pflnNext;
            else
                pflnPrev->pflnNext = pflnCur->pflnNext;

            idFound = pflnCur->idFolder;
            if (pcMessages)
                *pcMessages = pflnCur->cMessages;
            if (pcUnread)
                *pcUnread = pflnCur->cUnread;

            _FreeNode(pflnCur);
            break;
        }
        
        pflnPrev = pflnCur;
        pflnCur = pflnCur->pflnNext;
    }

    return idFound;
}

//----------------------------------------------------------------------
// CFolderList::FindAndRemove
//----------------------------------------------------------------------
FOLDERID CFolderList::FindAndRemove(SPECIALFOLDER tySpecial,
                                    DWORD *pcMessages, 
                                    DWORD *pcUnread)
{
    LPFOLDERLISTNODE    pflnPrev = NULL;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    FOLDERID            idFound = FOLDERID_INVALID;

    if (FOLDER_NOTSPECIAL == tySpecial)
        return FOLDERID_INVALID;

    if (pcMessages)
        *pcMessages = 0;
    if (pcUnread)
        *pcUnread = 0;

    while (pflnCur)
    {
        if (pflnCur->tySpecial == tySpecial)
        {
            if (NULL == pflnPrev)
                m_pflnList = pflnCur->pflnNext;
            else
                pflnPrev->pflnNext = pflnCur->pflnNext;

            idFound = pflnCur->idFolder;
            if (pcMessages)
                *pcMessages = pflnCur->cMessages;
            if (pcUnread)
                *pcUnread = pflnCur->cUnread;

            _FreeNode(pflnCur);
            break;
        }
        
        pflnPrev = pflnCur;
        pflnCur = pflnCur->pflnNext;
    }

    return idFound;
}

//----------------------------------------------------------------------
// CFolderList::PurgeRemainingFromStore
//----------------------------------------------------------------------
void CFolderList::PurgeRemainingFromStore(void)
{
    HRESULT             hr = S_OK;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    LPFOLDERLISTNODE    pflnDeleteMe = NULL;

    // take ownership of the list
    m_pflnList = NULL;

    while (pflnCur)
    {
        m_pStore->DeleteFolder(pflnCur->idFolder, DELETE_FOLDER_DELETESPECIAL | DELETE_FOLDER_NOTRASHCAN, NULL);
        pflnDeleteMe = pflnCur;
        pflnCur = pflnCur->pflnNext;
        
        _FreeNode(pflnDeleteMe);
    }
}

//----------------------------------------------------------------------
// FreeNewMessageInfo
//----------------------------------------------------------------------
static void __cdecl FreeNewMessageInfo(LPVOID pnmi)
{
    Assert(NULL != pnmi);

    SafeMemFree(((LPNEWMESSAGEINFO)pnmi)->pszUrlComponent);

    MemFree(pnmi);
}

#ifndef NOHTTPMAIL

//----------------------------------------------------------------------
// CreateHTTPMailStore (factory function)
//----------------------------------------------------------------------
HRESULT CreateHTTPMailStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr = S_OK;

    // Trace
    TraceCall("CreateHTTPMailStore");

    // Invalid Args
    Assert(NULL != ppUnknown);
    if (NULL == ppUnknown)
        return E_INVALIDARG;

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHTTPMailServer *pNew = new CHTTPMailServer();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    //*ppUnknown = SAFECAST(pNew, IMessageServer *);
 
    hr = CreateServerQueue(pNew, (IMessageServer **)ppUnknown);
    pNew->Release(); // Since we're not returning this ptr, bump down refcount


    // Done
    return hr;
}

#endif

//----------------------------------------------------------------------
// CHTTPMailServer::CHTTPMailServer
//----------------------------------------------------------------------
CHTTPMailServer::CHTTPMailServer(void) :
    m_cRef(1),
    m_hwnd(NULL),
    m_pStore(NULL),
    m_pFolder(NULL),
    m_pTransport(NULL),
    m_pszFldrLeafName(NULL),
    m_pszMsgFolderRoot(NULL),
    m_idServer(FOLDERID_INVALID),
    m_idFolder(FOLDERID_INVALID),
    m_tySpecialFolder(FOLDER_NOTSPECIAL),
    m_pszFolderUrl(NULL),
    m_fConnected(FALSE),
    m_pTransport2(NULL),
    m_pAccount(NULL)
{
    _FreeOperation(FALSE);

    ZeroMemory(&m_rInetServerInfo, sizeof(INETSERVER));

    m_szAccountName[0] = '\0';
    m_szAccountId[0] = '\0';

    m_op.pszAdUrl = NULL;

#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif // DEBUG
}

//----------------------------------------------------------------------
// CHTTPMailServer::~CHTTPMailServer
//----------------------------------------------------------------------
CHTTPMailServer::~CHTTPMailServer(void)
{
    // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
    SafeRelease(m_pTransport);
    SafeRelease(m_pTransport2);
    SafeRelease(m_pAccount);

    SafeMemFree(m_pszFldrLeafName);
    SafeMemFree(m_pszMsgFolderRoot);
    SafeMemFree(m_pszFolderUrl);
}

//----------------------------------------------------------------------
// IUnknown Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::QueryInterface
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    TraceCall("CHTTPMailServer::QueryInterface");
    
    if (NULL == ppv)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (IID_IUnknown == riid || IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_ITransportCallback == riid)
        *ppv = (ITransportCallback *)this;
    else if (IID_IHTTPMailCallback == riid)
        *ppv = (IHTTPMailCallback *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // the interface was found. addref it
    ((IUnknown *)*ppv)->AddRef();

exit:
    // done
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddRef
//----------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailServer::AddRef(void)
{
    TraceCall("CHTTPMailServer::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddRef
//----------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailServer::Release(void)
{
    TraceCall("CHTTPMailServer::Release");
    ULONG cRef = InterlockedDecrement(&m_cRef);

    Assert(((LONG)cRef) >= 0);
    if (0 == cRef)
        delete this;
    return cRef;
}

//----------------------------------------------------------------------
// IMessageServer Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::Initialize
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Initialize(   IMessageStore   *pStore, 
                                            FOLDERID        idStoreRoot, 
                                            IMessageFolder  *pFolder, 
                                            FOLDERID        idFolder)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;

    AssertSingleThreaded;

    if (NULL == pStore || FOLDERID_INVALID == idStoreRoot)
        return TraceResult(E_INVALIDARG);

    if (!_CreateWnd())
        return E_FAIL;

    m_idServer = idStoreRoot;
    m_idFolder = idFolder;

    ReplaceInterface(m_pFolder, pFolder);
    ReplaceInterface(m_pStore, pStore);

    if (FAILED(hr = m_pStore->GetFolderInfo(idStoreRoot, &fi)))
        goto exit;

    Assert(!!(fi.dwFlags & FOLDER_SERVER));
    lstrcpy(m_szAccountId, fi.pszAccountId);
    
    m_pStore->FreeRecord(&fi);

    // if we were passed a valid folder id, check to see if this folder is special?
    // we might get passed a bad folder id when we are syncing the store.
    if (FOLDERID_INVALID != idFolder)
    {
        if (FAILED(hr = m_pStore->GetFolderInfo(idFolder, &fi)))
            goto exit;
    
        m_tySpecialFolder = fi.tySpecial;
        m_pStore->FreeRecord(&fi);
    }

exit:
    return hr;
}

STDMETHODIMP CHTTPMailServer::ResetFolder(  IMessageFolder  *pFolder, 
                                            FOLDERID        idFolder)
{
    return(E_NOTIMPL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetIdleCallback
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SynchronizeFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SynchronizeFolder(
                                    SYNCFOLDERFLAGS dwFlags, 
                                    DWORD cHeaders, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SynchronizeFolder");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_SYNC_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnSyncFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncFolder);
    m_op.dwSyncFlags = dwFlags;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMessage 
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetMessage(
                                MESSAGEID idMessage, 
                                IStoreCallback  *pCallback)
{
    HRESULT hr = S_OK;

    TraceCall("CHTTPMailServer::GetMessage");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pMessageStream, &m_op.faStream)))
        goto exit;

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.idMessage = idMessage;

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PutMessage
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::PutMessage(
                                    FOLDERID idFolder, 
                                    MESSAGEFLAGS dwFlags, 
                                    LPFILETIME pftReceived, 
                                    IStream  *pStream, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::PutMessage");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pStream || NULL == pCallback)
        return E_INVALIDARG;

    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    m_op.tyOperation = SOT_PUT_MESSAGE;
    m_op.pfnState = c_rgpfnPutMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnPutMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.idFolder = idFolder;
    m_op.pMessageStream = pStream;
    m_op.pMessageStream->AddRef();
    m_op.dwMsgFlags = dwFlags;

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::CopyMessages
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::CopyMessages(
                                    IMessageFolder *pDest, 
                                    COPYMESSAGEFLAGS dwOptions, 
                                    LPMESSAGEIDLIST pList, 
                                    LPADJUSTFLAGS pFlags, 
                                    IStoreCallback  *pCallback)
{
    HRESULT         hr = S_OK;
    FOLDERID        idFolder;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    
    
    TraceCall("CHTTPMailServer::CopyMessages");

    if (NULL == pDest)
        return E_INVALIDARG;

    Assert(NULL != m_pStore);

    // disallow moving or copying into the msn promo folder
    IF_FAILEXIT(hr = pDest->GetFolderId(&idFolder));
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(idFolder, &fi));
    
    pfiFree = &fi;

    if (FOLDER_MSNPROMO == fi.tySpecial)
    {
        hr = TraceResult(SP_E_HTTP_CANTMODIFYMSNFOLDER);
        goto exit;
    }
    // convert moves out of the promo folder into copies
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        dwOptions = (dwOptions & ~COPY_MESSAGE_MOVE);

    hr = _DoCopyMoveMessages(SOT_COPYMOVE_MESSAGE, pDest, dwOptions, pList, pCallback);
exit:
    if (NULL != pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteMessages
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
                                             LPMESSAGEIDLIST pList, 
                                             IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::DeleteMessages");

    AssertSingleThreaded;
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    // we don't allow messages to be deleted out of the msnpromo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
    {
        // this is a hack. we test this flag to determine that the
        //operation is being performed as the last phase of a move
        // into a local folder. when this is the case, we fail
        // silently.
        if (!!(DELETE_MESSAGE_MAYIGNORENOTRASH & dwOptions))
            return S_OK;
        else
            return SP_E_HTTP_CANTMODIFYMSNFOLDER;
    }

    if ((NULL !=pList && 0 == pList->cMsgs) || NULL == pCallback)
        return E_INVALIDARG;

    HRESULT         hr = S_OK;
    IMessageFolder  *pDeletedItems = NULL;

    m_op.dwDelMsgFlags = dwOptions;

    // if the current folder is the deleted items folder, then delete the
    // messages, otherwise move them to deleted items
    if (FOLDER_DELETED != m_tySpecialFolder && !(dwOptions & DELETE_MESSAGE_NOTRASHCAN))
    {
        // find the deleted items folder
        if (SUCCEEDED(m_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems)) && NULL != pDeletedItems)
        {
            hr = _DoCopyMoveMessages(SOT_DELETING_MESSAGES, pDeletedItems, COPY_MESSAGE_MOVE, pList, pCallback);
            goto exit;
        }
    }
    
    // handle the case where the messages are not in the deleted items folder
    // if pList is null, apply the operation to the entire folder
    if (NULL != pList)
        hr = CloneMessageIDList(pList, &m_op.pIDList);
    else
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &m_op.hRowSet);

    if (FAILED(hr))
        goto exit;

    m_op.tyOperation = SOT_DELETING_MESSAGES;
    m_op.pfnState = c_rgpfnDeleteMessages;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnDeleteMessages);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    hr = _BeginDeferredOperation();

exit:
    SafeRelease(pDeletedItems);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetMessageFlags
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SetMessageFlags(
                                        LPMESSAGEIDLIST pList, 
                                        LPADJUSTFLAGS pFlags, 
                                        SETMESSAGEFLAGSFLAGS dwFlags,
                                        IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SetMessageFlags");

    AssertSingleThreaded;
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(NULL != pCallback);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pStore != NULL);

    if ((NULL !=pList && 0 == pList->cMsgs) || NULL == pFlags || NULL == pCallback)
        return E_INVALIDARG;

    // the only remote flag supported by httpmail is the "read" flag
    // it is an error to attempt to set or unset any other flag
    Assert(0 == (pFlags->dwRemove & ~ARF_READ));
    Assert(0 == (pFlags->dwAdd & ~ARF_READ));
    Assert((ARF_READ == (ARF_READ & pFlags->dwRemove)) || (ARF_READ == (ARF_READ & pFlags->dwAdd)));
 
    HRESULT     hr = S_OK;

    // if pList is null, apply the operation to the entire folder
    if (NULL != pList)
        hr = CloneMessageIDList(pList, &m_op.pIDList);
    else
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &m_op.hRowSet);

    if (FAILED(hr))
        return hr;

    m_op.tyOperation = SOT_SET_MESSAGEFLAGS;
    m_op.pfnState = c_rgpfnSetMessageFlags;
    m_op.cState = ARRAYSIZE(c_rgpfnSetMessageFlags);
    m_op.iState = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.fMarkRead = !!(pFlags->dwAdd & ARF_READ);
    m_op.dwSetFlags = dwFlags;
    
    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetServerMessageFlags
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    if (NULL == pFlags)
        return E_INVALIDARG;

    *pFlags = ARF_READ;
    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SynchronizeStore
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SynchronizeStore(
                                    FOLDERID idParent, 
                                    SYNCSTOREFLAGS dwFlags, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SynchronizeStore");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pStore != NULL);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation =  SOT_SYNCING_STORE;
    m_op.pfnState = c_rgpfnSyncStore;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncStore);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::CreateFolder(
                                    FOLDERID idParent, 
                                    SPECIALFOLDER tySpecial, 
                                    LPCSTR pszName, 
                                    FLDRFLAGS dwFlags, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::CreateFolder");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(NULL != m_pStore);

    // why would we be called to create a special folder?
    Assert(FOLDER_NOTSPECIAL == tySpecial);

    if (NULL == pCallback || NULL == pszName)
        return E_INVALIDARG;

    // hotmail doesn't support hierarchical folders.
    Assert(m_idServer == idParent);
    if (m_idServer != idParent)
        return E_FAIL;

    m_op.pszFolderName = PszDupA(pszName);
    if (NULL == m_op.pszFolderName)
        return E_OUTOFMEMORY;

    m_op.tyOperation = SOT_CREATE_FOLDER;
    m_op.pfnState = c_rgpfnCreateFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnCreateFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.dwFldrFlags = dwFlags;

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::MoveFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::RenameFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::RenameFolder(FOLDERID idFolder, 
                                           LPCSTR pszName, 
                                           IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::RenameFolder");
    
    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);
    Assert(NULL != pszName);

    // don't allow the user to rename the promo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    if (NULL == pszName || NULL == pCallback)
        return E_INVALIDARG;

    m_op.pszFolderName = PszDupA(pszName);
    if (NULL == m_op.pszFolderName)
    {
        TraceResult(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    m_op.idFolder = idFolder;

    m_op.tyOperation = SOT_RENAME_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnRenameFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnRenameFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::DeleteFolder(FOLDERID idFolder, 
                                           DELETEFOLDERFLAGS dwFlags, 
                                           IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::DeleteFolder");
    
    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);
    Assert(FOLDERID_INVALID != idFolder);

    // don't allow the user to delete the msn promo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    // we don't support hierarchical folders - if we are asked to delete
    // the children of a folder, just return immediately
    if (!!(DELETE_FOLDER_CHILDRENONLY & dwFlags))
        return S_OK;

    if (NULL == pCallback || FOLDERID_INVALID == idFolder)
        return E_INVALIDARG;

    m_op.idFolder = idFolder;

    m_op.tyOperation = SOT_DELETE_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnDeleteFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnDeleteFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
} 

//----------------------------------------------------------------------
// CHTTPMailServer::SubscribeToFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::Close
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Close(DWORD dwFlags)
{
    // if we are processing a command, cancel it
    Cancel(CT_CANCEL);

    if (dwFlags & MSGSVRF_DROP_CONNECTION)
        _SetConnected(FALSE);

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_pTransport->DropConnection();
            m_pTransport->HandsOffCallback();
            m_pTransport->Release(); 
            m_pTransport = NULL;
        }
    }
    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetFolderCounts
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetNewGroups
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnLogonPrompt
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    HRESULT     hr = S_OK;
    LPSTR       pszCachedPassword = NULL;
    INETSERVER  rInetServer;

    TraceCall("CHTTPMailServer::OnLogonPrompt");

    AssertSingleThreaded;
    Assert(pInetServer != NULL);
    Assert(pTransport != NULL);
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    // pull password out of the cache
    GetAccountPropStrA(m_szAccountId, CAP_PASSWORD, &pszCachedPassword);
    if (NULL != pszCachedPassword && 0 != lstrcmp(pszCachedPassword, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, pszCachedPassword, sizeof(pInetServer->szPassword));
        goto exit;
    }
    
    hr = m_op.pCallback->OnLogonPrompt(pInetServer, IXP_HTTPMail);
    if (S_OK == hr)
    {
        // cache the password
        HrCacheAccountPropStrA(m_szAccountId, CAP_PASSWORD, pInetServer->szPassword);

        // copy the new username and password into our local server info
        lstrcpyn(m_rInetServerInfo.szPassword, pInetServer->szPassword, sizeof(m_rInetServerInfo.szPassword));
        lstrcpyn(m_rInetServerInfo.szUserName, pInetServer->szUserName, sizeof(m_rInetServerInfo.szUserName));
    }

exit:
    SafeMemFree(pszCachedPassword);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnPrompt
//----------------------------------------------------------------------
STDMETHODIMP_(INT) CHTTPMailServer::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return 0;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnStatus
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport)
{
        // Stack
    TraceCall("CHTTPMailServer::OnStatus");

    AssertSingleThreaded;

    // If we were disconnected, then clean up some internal state.
    if (IXP_DISCONNECTED == ixpstatus)
    {
        if (m_op.tyOperation != SOT_INVALID)
        {
            Assert(m_op.pCallback != NULL);
        
            if (m_op.fCancel && !m_op.fNotifiedComplete)
            {
                IXPRESULT   rIxpResult;

                // Fake an IXPRESULT
                ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                rIxpResult.hrResult = STORE_E_OPERATION_CANCELED;

                // Return meaningful error information
                _FillStoreError(&m_op.error, &rIxpResult);
                Assert(STORE_E_OPERATION_CANCELED == m_op.error.hrResult);

                m_op.fNotifiedComplete = TRUE;
                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);
                _FreeOperation();
            }
        }

        m_fConnected = FALSE;
    }

    return(S_OK);
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnError
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnProgress
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnCommand
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnTimeout
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnResponse
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnResponse(
            LPHTTPMAILRESPONSE      pResponse)
{
    HRESULT     hr = S_OK;
    HRESULT     hrResponse;
    HRESULT     hrSaved;
    BOOL        fInvokeResponseHandler = TRUE;

    AssertSingleThreaded;

    Assert(SOT_INVALID != m_op.tyOperation);

    if (!m_op.fCancel && !m_op.fNotifiedComplete && 
        (SOT_GET_ADURL == m_op.tyOperation  || SOT_GET_HTTP_MINPOLLINGINTERVAL == m_op.tyOperation))
    {
        STOREOPERATIONINFO  StoreInfo = {0};

        m_op.fNotifiedComplete = TRUE;

        if (SOT_GET_ADURL == m_op.tyOperation)
        {
            StoreInfo.pszUrl = pResponse->rGetPropInfo.pszProp;

            pResponse->rGetPropInfo.pszProp = NULL;
        }

        if (SOT_GET_HTTP_MINPOLLINGINTERVAL == m_op.tyOperation)
        {
            StoreInfo.dwMinPollingInterval = pResponse->rGetPropInfo.dwProp;
        }

        m_op.pCallback->OnComplete(m_op.tyOperation, pResponse->rIxpResult.hrResult, &StoreInfo, NULL);
        _FreeOperation();

        MemFree(StoreInfo.pszUrl);
        
        goto cleanup;

    }

    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        Assert(pResponse->fDone);

        // Hotmail hack. Hotmail does not support deleting message. This interferes with operations
        // such as moving messages from a hotmail folder into the local store. we attempt to send
        // a delete to the server, since we don't know whether or not the server supports the command.
        // if it fails, we check the delete messages flag to determine if we are allowed to fallback
        // to a move operation.
        if (SOT_DELETING_MESSAGES == m_op.tyOperation && 
            (HTTPMAIL_DELETE == pResponse->command || HTTPMAIL_BDELETE == pResponse->command) && 
            IXP_E_HTTP_METHOD_NOT_ALLOW == pResponse->rIxpResult.hrResult &&
            FOLDER_DELETED != m_tySpecialFolder &&
            !!(m_op.dwDelMsgFlags & DELETE_MESSAGE_MAYIGNORENOTRASH))
        {
            m_op.fFallbackToMove = TRUE;
            fInvokeResponseHandler = FALSE;
            // cache the fact that this acct doesn't support msg delete so we don't
            // have to go through this nonsense again
            HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPNOMESSAGEDELETES, "TRUE");
        }
        else
        {
            hrSaved = pResponse->rIxpResult.hrResult;

            if (IXP_E_HTTP_ROOT_PROP_NOT_FOUND == hrSaved)
                pResponse->rIxpResult.hrResult = SP_E_HTTP_SERVICEDOESNTWORK;
            else if ((HTTPMAIL_DELETE == pResponse->command || HTTPMAIL_BDELETE == pResponse->command) && IXP_E_HTTP_METHOD_NOT_ALLOW == hrSaved)
                pResponse->rIxpResult.hrResult = SP_E_HTTP_NODELETESUPPORT;
        
            _FillStoreError(&m_op.error, &pResponse->rIxpResult);

            pResponse->rIxpResult.hrResult = hrSaved;
            
            if (!m_op.fNotifiedComplete)
            {
                m_op.fNotifiedComplete = TRUE;
                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);
                _FreeOperation();
            }

            return S_OK;
        }
    }

    Assert(NULL != m_op.pfnState[m_op.iState].pfnResp);

    // by default, state advances occur when the the response indicates
    // that io is done. response functions can override this behavior
    // by setting fStateWillAdvance to FALSE to maintain the current state.
    m_op.fStateWillAdvance = pResponse->fDone;

    // invoke the response function
    if (fInvokeResponseHandler)
        hr = (this->*(m_op.pfnState[m_op.iState].pfnResp))(pResponse);

cleanup:
    
    if (FAILED(hr))
    {
        if (_FConnected())
        {
            m_pTransport->DropConnection();
            m_pTransport->HandsOffCallback();
            SafeRelease(m_pTransport);
        }

        if (!m_op.fNotifiedComplete)
        {
            m_op.fNotifiedComplete = TRUE;
            m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, NULL);

            _FreeOperation();
        }
    }
    else if (SUCCEEDED(hr) && m_op.fStateWillAdvance)
    {
        m_op.iState++;
        _DoOperation();
    }

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetParentWindow
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetParentWindow(HWND *phwndParent)
{
    HRESULT     hr = E_FAIL;

    AssertSingleThreaded;

    if (m_op.tyOperation != SOT_INVALID && NULL != m_op.pCallback)
        hr = m_op.pCallback->GetParentWindow(0, phwndParent);

    return hr;
}

//----------------------------------------------------------------------
// IOperationCancel Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::Cancel
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Cancel(CANCELTYPE tyCancel)
{
    if (m_op.tyOperation != SOT_INVALID)
    {
        m_op.fCancel = TRUE;
        _Disconnect();
    }

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer Implementation
//----------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailServer::_CreateWnd
// --------------------------------------------------------------------------------
BOOL CHTTPMailServer::_CreateWnd()
{
    WNDCLASS wc;

    IxpAssert(!m_hwnd);
    if (m_hwnd)
        return TRUE;

    if (!GetClassInfo(g_hInst, s_szHTTPMailServerWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc          = CHTTPMailServer::_WndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hInst;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szHTTPMailServerWndClass;
        
        RegisterClass(&wc);
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST,
                        s_szHTTPMailServerWndClass,
                        s_szHTTPMailServerWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hInst,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailServer::_WndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK CHTTPMailServer::_WndProc(HWND hwnd,
                                         UINT msg,
                                         WPARAM wParam,
                                         LPARAM lParam)
{
    CHTTPMailServer     *pThis = (CHTTPMailServer*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    LRESULT             lr = 0;

    switch (msg)
    {
    case WM_NCCREATE:
        IxpAssert(!pThis);
        pThis = (CHTTPMailServer*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
        lr = DefWindowProc(hwnd, msg, wParam, lParam);       
        break;
    
    case WM_HTTP_BEGIN_OP:
        IxpAssert(pThis);
        pThis->_DoOperation();
        break;
        
    default:
        lr = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BeginDeferredOperation
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BeginDeferredOperation(void)
{
    return (PostMessage(m_hwnd, WM_HTTP_BEGIN_OP, 0, 0) ? E_PENDING : E_FAIL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleGetMsgFolderRoot
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleGetMsgFolderRoot(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT     hr      = S_OK;
    
    Assert(HTTPMAIL_GETPROP == pResponse->command);
    Assert(NULL == m_pszMsgFolderRoot);
    Assert(HTTPMAIL_PROP_MSGFOLDERROOT == pResponse->rGetPropInfo.type);

    if (NULL == pResponse->rGetPropInfo.pszProp)
    {
        hr = E_FAIL;
        goto exit;
    }

    m_pszMsgFolderRoot = pResponse->rGetPropInfo.pszProp;
    pResponse->rGetPropInfo.pszProp = NULL;

    // add it to the account data cache
    HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, m_pszMsgFolderRoot);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleListFolders(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                         hr = S_OK;
    SPECIALFOLDER                   tySpecial = FOLDER_NOTSPECIAL;
    FOLDERINFO                      fiNewFolder;
    FOLDERID                        idFound = FOLDERID_INVALID;
    LPHTTPMEMBERINFOLIST            pMemberList = &pResponse->rMemberInfoList;
    LPHTTPMEMBERINFO                pMemberInfo;
    CHAR                            szUrlComponent[MAX_PATH];
    DWORD                           dwUrlComponentLen;
    CHAR                            szSpecialFolder[CCHMAX_STRINGRES];
    DWORD                           cMessages;
    DWORD                           cUnread;
    FOLDERINFO                      fi = {0};

    for (ULONG ulIndex = 0; ulIndex < pMemberList->cMemberInfo; ++ulIndex)
    {
        idFound = FOLDERID_INVALID;

        pMemberInfo = &pMemberList->prgMemberInfo[ulIndex];

        // skip anything that isn't a folder
        if (!pMemberInfo->fIsFolder)
            continue;
        
        dwUrlComponentLen = ARRAYSIZE(szUrlComponent);
        IF_FAILEXIT(hr = Http_NameFromUrl(pMemberInfo->pszHref, szUrlComponent, &dwUrlComponentLen));

        // [shaheedp] Bug# 84477
        // If szUrlComponent is null, then we should not be adding this folder to the store. 
        if (!(*szUrlComponent))
        {
            hr = E_FAIL;
            goto exit;
        }


        // if we've found a reserved folder, translate the httpmail
        // special folder constant into the equivalent oe store
        // special folder type.
    
        tySpecial =  _TranslateHTTPSpecialFolderType(pMemberInfo->tySpecial);
        if (FOLDER_NOTSPECIAL != tySpecial)
            idFound = m_op.pFolderList->FindAndRemove(tySpecial, &cMessages, &cUnread);

        // if the folder wasn't found, try to find it by name
        if (FOLDERID_INVALID == idFound)
        {
            idFound = m_op.pFolderList->FindAndRemove(szUrlComponent, &cMessages, &cUnread);

            // if it still wasn't found, then add it
            if (FOLDERID_INVALID == idFound)
            {
                // fill in the folderinfo
                ZeroMemory(&fiNewFolder, sizeof(FOLDERINFO));
                fiNewFolder.idParent = m_idServer;
                fiNewFolder.tySpecial = tySpecial;
                fiNewFolder.tyFolder = FOLDER_HTTPMAIL;
                fiNewFolder.pszName = pMemberInfo->pszDisplayName;
                if (FOLDER_NOTSPECIAL != tySpecial)
                {
                    if (_LoadSpecialFolderName(tySpecial, szSpecialFolder, sizeof(szSpecialFolder)))
                        fiNewFolder.pszName = szSpecialFolder;
                }

                fiNewFolder.pszUrlComponent = szUrlComponent;
                fiNewFolder.dwFlags = (FOLDER_SUBSCRIBED | FOLDER_NOCHILDCREATE);

                // message counts
                fiNewFolder.cMessages = pMemberInfo->dwVisibleCount;
                fiNewFolder.cUnread = pMemberInfo->dwUnreadCount;
          
                if (tySpecial == FOLDER_INBOX)
                    fiNewFolder.dwFlags |= FOLDER_DOWNLOADALL;

                // Add the folder to the store
                IF_FAILEXIT(hr = m_pStore->CreateFolder(NOFLAGS, &fiNewFolder, NULL));
            }
        }
        
        // if the folder was found, update its message counts
        if (FOLDERID_INVALID != idFound)
        {
            if (SUCCEEDED(hr = m_pStore->GetFolderInfo(idFound, &fi)))
            {
                BOOL    bUpdate = FALSE;

                // only update folders that changed. always update the MSN_PROMO folder.

                // [shaheedp] Bug# 84477 
                // If the folder's pszUrlComponent was null or it is different, then reset it.
                if ((fi.pszUrlComponent == NULL) || 
                   (lstrcmpi(fi.pszUrlComponent, szUrlComponent)))
                {
                    bUpdate = TRUE;
                    fi.pszUrlComponent  = szUrlComponent;
                }

                if ((FOLDER_MSNPROMO == tySpecial) || 
                    (cMessages != pMemberInfo->dwVisibleCount) ||  
                    (cUnread != pMemberInfo->dwUnreadCount))
                {

                    fi.cMessages = pMemberInfo->dwVisibleCount;

                    // special handling for the promo folder - messages on the
                    // server are never marked unread.
                    if (FOLDER_MSNPROMO == fi.tySpecial)
                    {
                        // we attempt to approximate the number of unread msgs in
                        // the promo folder. we assume that the server will not track
                        // the read/unread state of promo messages. we figure out how
                        // many messages were read before we got the new counts, and
                        // subtract that number from the current number of visible
                        // messages to get the unread count. this number will not always
                        // be accurate, but since all we know is the counts, and we
                        // don't know how the count changed (additions vs deletions),
                        // this is the best we can do and it always errors on the side
                        // of a too-small count to avoid bothering the user with
                        // unread counts when no unread msgs exist.
                        DWORD dwReadMessages = cMessages - cUnread;

                        if (fi.cMessages > dwReadMessages)
                            fi.cUnread = fi.cMessages - dwReadMessages;
                        else
                            fi.cUnread = 0;
                    }
                    else
                        fi.cUnread = pMemberInfo->dwUnreadCount;
            
                        if (cMessages != fi.cMessages || cUnread != fi.cUnread)
                            bUpdate = TRUE;

                }

                if (bUpdate)
                    m_pStore->UpdateRecord(&fi);

                m_pStore->FreeRecord(&fi);
            }
        }

        // if we are syncing the store, notify the client of our progress
        if (SOT_SYNCING_STORE == m_op.tyOperation && NULL != m_op.pCallback)
            m_op.pCallback->OnProgress(
                            SOT_SYNCING_STORE, 
                            0,
                            0,
                            m_rInetServerInfo.szServerName);
    }

    IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_ROOTTIMESTAMP, pMemberList->pszRootTimeStamp));
    IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_ROOTINBOXTIMESTAMP, pMemberList->pszFolderTimeStamp));
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleGetMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleGetMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr;
    
    IF_FAILEXIT(hr = m_op.pMessageStream->Write(
                        pResponse->rGetInfo.pvBody,
                        pResponse->rGetInfo.cbIncrement,
                        NULL));


    if (m_op.pCallback && pResponse->rGetInfo.cbTotal > 0)
    {
        m_op.pCallback->OnProgress(m_op.tyOperation, 
                                   pResponse->rGetInfo.cbCurrent,
                                   pResponse->rGetInfo.cbTotal,
                                   NULL);
    }

    // if not done yet, bail out
    if (!pResponse->fDone)
        goto exit;

    // we're done...write the stream out
    hr = Http_SetMessageStream(m_pFolder, m_op.idMessage, m_op.pMessageStream, &m_op.faStream, FALSE);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_DoOperation
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_DoOperation(void)
{
    HRESULT hr = S_OK;
    STOREOPERATIONINFO  soi = { sizeof(STOREOPERATIONINFO), MESSAGEID_INVALID };
    STOREOPERATIONINFO  *psoi = NULL;
    BOOL                fCallComplete = TRUE;

    if (m_op.tyOperation == SOT_INVALID)
        return E_FAIL;

    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pfnState != NULL);
    Assert(m_op.cState > 0);
    Assert(m_op.iState <= m_op.cState);

    if (m_op.iState == 0)
    {
        if (m_op.tyOperation == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.idMessage = m_op.idMessage;
            psoi = &soi;
        }

        if (m_op.tyOperation == SOT_GET_ADURL)
            m_op.pszAdUrl = NULL;

        m_op.pCallback->OnBegin(m_op.tyOperation, psoi, (IOperationCancel *)this);
    }

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState].pfnOp))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if ((m_op.iState == m_op.cState) || (FAILED(hr) && hr != E_PENDING))
    {
        LPSTOREERROR    perr = NULL;

        // provide message id 
        if (m_op.tyOperation == SOT_PUT_MESSAGE && MESSAGEID_INVALID != m_op.idPutMessage)
        {
            soi.idMessage = m_op.idPutMessage;
            psoi = &soi;
        }

        switch (m_op.tyOperation)
        {
            case SOT_GET_ADURL:
            {
                if (SUCCEEDED(hr))
                {
                    psoi = &soi;
                    psoi->pszUrl = m_op.pszAdUrl;
                }
                else
                {
                    psoi          = NULL;
                    fCallComplete = FALSE;
                }

                perr = NULL;
                break;
            }

            case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            {
                if (SUCCEEDED(hr))
                {
                    psoi = &soi;
                    psoi->dwMinPollingInterval = m_op.dwMinPollingInterval;
                }
                else
                {
                    psoi            = NULL;
                    fCallComplete   = FALSE;

                }

                perr = NULL;
                break;
            }

            default:
            {
                if (FAILED(hr))
                {
                    IXPRESULT   rIxpResult;

                    // Fake an IXPRESULT
                    ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                    rIxpResult.hrResult = hr;

                    // Return meaningful error information
                    _FillStoreError(&m_op.error, &rIxpResult);
                    Assert(m_op.error.hrResult == hr);
                }
                else
                    m_op.error.hrResult = hr;

                if (!m_op.fNotifiedComplete)
                    perr = &m_op.error;
                
                break;
            }

        }

        if (!m_op.fNotifiedComplete && fCallComplete)
        {
            m_op.fNotifiedComplete = TRUE;
            m_op.pCallback->OnComplete(m_op.tyOperation, hr, psoi, perr);
            _FreeOperation();
        }
    }

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_FreeOperation
//----------------------------------------------------------------------
void CHTTPMailServer::_FreeOperation(BOOL fValidState)
{
    if (fValidState)
    {
        if (m_op.pCallback != NULL)
            m_op.pCallback->Release();
        if (m_op.pFolderList != NULL)
            m_op.pFolderList->Release();
        if (m_op.pMessageFolder)
            m_op.pMessageFolder->Release();

        SafeMemFree(m_op.pszProblem);

        if (0 != m_op.faStream)
        {
            Assert(m_pFolder);
            m_pFolder->DeleteStream(m_op.faStream);
        }
        if (m_op.pMessageStream)
            m_op.pMessageStream->Release();
        if (m_op.pmapMessageId)
            delete m_op.pmapMessageId;
        if (m_op.psaNewMessages)
            delete m_op.psaNewMessages;

        if (m_op.pPropPatchRequest)
            m_op.pPropPatchRequest->Release();

        SafeMemFree(m_op.pszDestFolderUrl);
        SafeMemFree(m_op.pszDestUrl);

        SafeMemFree(m_op.pIDList);
        if (NULL != m_op.hRowSet)
            m_pFolder->CloseRowset(&m_op.hRowSet);

        SafeMemFree(m_op.pszFolderName);

        if (m_op.pTargets)
            Http_FreeTargetList(m_op.pTargets);

        SafeMemFree(m_op.pszAdUrl);

    }

    ZeroMemory(&m_op, sizeof(HTTPOPERATION));

    m_op.tyOperation = SOT_INVALID;
    m_op.idPutMessage = MESSAGEID_INVALID;
}

//----------------------------------------------------------------------
// CHTTPMailServer::Connect
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::Connect()
{
    HRESULT     hr = S_OK;
    INETSERVER  rInetServerInfo;
    BOOL        fInetInit = FALSE;
    LPSTR       pszCache = NULL;

    AssertSingleThreaded;
    Assert(m_op.pCallback != NULL);

    if (!m_pAccount)
    {
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &m_pAccount));
        IF_FAILEXIT(hr = _LoadAccountInfo(m_pAccount));
    }

    if (_FConnected())
    {
        Assert(m_pTransport != NULL);

        IF_FAILEXIT(hr = m_pTransport->InetServerFromAccount(m_pAccount, &rInetServerInfo));

        // compare the current account from the account whose data we saved.
        // if the account has changed, drop the connection, and reconnect
        Assert(m_rInetServerInfo.szServerName[0] != 0);
        if (m_rInetServerInfo.rasconntype == rInetServerInfo.rasconntype &&
            m_rInetServerInfo.dwPort == rInetServerInfo.dwPort &&
            m_rInetServerInfo.fSSL == rInetServerInfo.fSSL &&
            m_rInetServerInfo.fTrySicily == rInetServerInfo.fTrySicily &&
            m_rInetServerInfo.dwTimeout == rInetServerInfo.dwTimeout &&
            0 == lstrcmp(m_rInetServerInfo.szUserName, rInetServerInfo.szUserName) &&
            ('\0' == rInetServerInfo.szPassword[0] ||
                0 == lstrcmp(m_rInetServerInfo.szPassword, rInetServerInfo.szPassword)) &&
            0 == lstrcmp(m_rInetServerInfo.szServerName, rInetServerInfo.szServerName) &&
            0 == lstrcmp(m_rInetServerInfo.szConnectoid, rInetServerInfo.szConnectoid))
        {
            goto exit;
        }

        fInetInit = TRUE;

        // synchronously drop the connection
        m_pTransport->DropConnection();
    }

    hr = m_op.pCallback->CanConnect(m_szAccountId, NOFLAGS);
    if (S_OK != hr)
    {
        if (hr == S_FALSE)
            hr = HR_E_USER_CANCEL_CONNECT;
        goto exit;
    }
    

    if (NULL == m_pTransport)
        IF_FAILEXIT(hr = _LoadTransport());

    // initialize the server info if we haven't already
    if (!fInetInit)
        IF_FAILEXIT(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rInetServerInfo));
    else
        CopyMemory(&m_rInetServerInfo, &rInetServerInfo, sizeof(INETSERVER));

    GetAccountPropStrA(m_szAccountId, CAP_PASSWORD, &pszCache);
    if (NULL != pszCache)
    {
        lstrcpyn(m_rInetServerInfo.szPassword, pszCache, sizeof(m_rInetServerInfo.szPassword));
        SafeMemFree(pszCache);
    }

    // connect to the server. the transport won't actually connect until
    // a command is issued.
    IF_FAILEXIT(hr = m_pTransport->Connect(&m_rInetServerInfo, TRUE, FALSE));

    _SetConnected(TRUE);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMsgFolderRoot
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetMsgFolderRoot(void)
{
    HRESULT     hr      = S_OK;
    
    // bail if we've already got it
    if (NULL != m_pszMsgFolderRoot)
        goto exit;

    // try to pull it out of the account data cache
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, &m_pszMsgFolderRoot))
        goto exit;
    
    if (SUCCEEDED(hr = m_pTransport->GetProperty(HTTPMAIL_PROP_MSGFOLDERROOT, &m_pszMsgFolderRoot)))
    {
        Assert(NULL != m_pszMsgFolderRoot);
        if (NULL == m_pszMsgFolderRoot)
        {
            hr = E_FAIL;
            goto exit;
        }

        // add it to the account data cache
        HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, m_pszMsgFolderRoot);
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::BuildFolderUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::BuildFolderUrl(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    fiFree = NULL;

    // just bail if we've already got it
    if (NULL != m_pszFolderUrl)
        goto exit;

    Assert(NULL != m_pszMsgFolderRoot);
    if (NULL == m_pszMsgFolderRoot)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    if (FAILED(hr = m_pStore->GetFolderInfo(m_idFolder, &fi)))
        goto exit;

    fiFree = &fi;

    Assert(fi.pszUrlComponent);
    hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_pszFolderUrl);

exit:
    if (fiFree)
        m_pStore->FreeRecord(fiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ListFolders(void)
{
    HRESULT     hr = S_OK;
    CHAR        szRootTimeStamp[CCHMAX_RES];
    CHAR        szInboxTimeStamp[CCHMAX_RES];

    Assert(NULL == m_op.pFolderList);

    // cache a value that the account has been synced.
    HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPAUTOSYNCEDFOLDERS, c_szTrue);

    // build the folder list
    IF_FAILEXIT(hr = CFolderList::Create(m_pStore, m_idServer, &m_op.pFolderList));

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_ROOTTIMESTAMP, szRootTimeStamp, ARRAYSIZE(szRootTimeStamp));
    if (FAILED(hr))
        *szRootTimeStamp = 0;

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_ROOTINBOXTIMESTAMP, szInboxTimeStamp, ARRAYSIZE(szInboxTimeStamp));
    if (FAILED(hr))
        *szInboxTimeStamp = 0;

    // execute the listfolders command
    IF_FAILEXIT(hr = m_pTransport2->RootMemberInfo(m_pszMsgFolderRoot, HTTP_MEMBERINFO_FOLDERPROPS, 
                                                   1, FALSE, 0, szRootTimeStamp, szInboxTimeStamp));

    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AutoListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::AutoListFolders(void)
{
    LPSTR   pszAutoSynced = NULL;
    HRESULT hr = S_OK;

    // look for a cached property that indicates that the folder list
    // for this server has been synchronized at least once this session
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPAUTOSYNCEDFOLDERS, &pszAutoSynced))
        goto exit;

    // initiate the sync
    hr = ListFolders();

exit:
    SafeMemFree(pszAutoSynced);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ListHeaders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ListHeaders(void)
{
    HRESULT     hr = S_OK;
    TABLEINDEX  index;
    CHAR        szTimeStamp[CCHMAX_RES];

    Assert(NULL != m_pszFolderUrl);
    Assert(NULL != m_pTransport);
    Assert(NULL != m_pStore);
    Assert(NULL == m_op.psaNewMessages);

    // look for an index on pszMessageID
    if ( FAILED(m_pFolder->GetIndexInfo(IINDEX_HTTPURL, NULL, &index)) ||
         (CompareTableIndexes(&index, &g_HttpUrlIndex) != S_OK) )
    {
        // the index didn't exist - create it
        IF_FAILEXIT(hr = m_pFolder->ModifyIndex(IINDEX_HTTPURL, NULL, &g_HttpUrlIndex));
    }

    IF_FAILEXIT(hr = _CreateMessageIDMap(&m_op.pmapMessageId));

    IF_FAILEXIT(hr = CSortedArray::Create(NULL, FreeNewMessageInfo, &m_op.psaNewMessages));

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_INBOXTIMESTAMP, szTimeStamp, ARRAYSIZE(szTimeStamp));
    if (FAILED(hr))
        *szTimeStamp = 0;

    // For now we are passing in null folder name. This is meant for future purposes.
    IF_FAILEXIT(hr = m_pTransport2->FolderMemberInfo(m_pszFolderUrl, HTTP_MEMBERINFO_MESSAGEPROPS, 
                                               1, FALSE, 0, szTimeStamp, NULL));

    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleListHeaders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleListHeaders(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                                 hr = S_OK;
    LPHTTPMEMBERINFOLIST                    pMemberList = &pResponse->rMemberInfoList;
    LPHTTPMEMBERINFO                        pMemberInfo;
    TPair<CSimpleString, MARKEDMESSAGE>     *pFoundPair = NULL;
    CSimpleString                           ss;
    char                                    szUrlComponent[MAX_PATH];
    DWORD                                   dwUrlComponentLen;

    Assert(NULL != m_op.pmapMessageId);

    for (ULONG ulIndex = 0; ulIndex < pMemberList->cMemberInfo; ++ulIndex)
    {
        pMemberInfo = &pMemberList->prgMemberInfo[ulIndex];

        // skip folders
        if (pMemberInfo->fIsFolder)
            continue;

        dwUrlComponentLen = MAX_PATH;
        if (FAILED(hr = Http_NameFromUrl(pMemberInfo->pszHref, szUrlComponent, &dwUrlComponentLen)))
            goto exit;

        // look for the message by its server-assigned id in the local map
        if (FAILED(hr = ss.SetString(szUrlComponent)))
            goto exit;

        pFoundPair = m_op.pmapMessageId->Find(ss);

        // if the message was found, synchronize its read state, otherwise
        // add the new message to the store
        if (pFoundPair)
        {
            pFoundPair->m_value.fMarked = TRUE;

            // if not syncing the msn promo folder, adopt the server's read state
            if (FOLDER_MSNPROMO != m_tySpecialFolder)
            {
                if ((!!(pFoundPair->m_value.dwFlags & ARF_READ)) != pMemberInfo->fRead)
                    hr = _MarkMessageRead(pFoundPair->m_value.idMessage, pMemberInfo->fRead);
            }
        }
        else
        {
            if (FAILED(hr = Http_AddMessageToFolder(m_pFolder, 
                                                    m_szAccountId, 
                                                    pMemberInfo,
                                                    FOLDER_DRAFT == m_tySpecialFolder ? ARF_UNSENT : NOFLAGS,
                                                    pMemberInfo->pszHref, 
                                                    NULL)))
            {
                if (DB_E_DUPLICATE == hr)
                    hr = S_OK;
                else
                    goto exit;
            }
        }
        
        // update our message and unread message counts
        m_op.cMessages++;

        // if syncing the promo folder, no headers on the server will
        // ever appear to be read.
        if (FOLDER_MSNPROMO == m_tySpecialFolder)
        {
            if (!pFoundPair || !(pFoundPair->m_value.dwFlags & ARF_READ))
                m_op.cUnread++;
        }
        else if (!pMemberInfo->fRead)
            m_op.cUnread++;
    }

    if (pMemberList->pszFolderTimeStamp)
    {
        IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_INBOXTIMESTAMP, pMemberList->pszFolderTimeStamp));
    }
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_Disconnect
//----------------------------------------------------------------------
void CHTTPMailServer::_Disconnect(void)
{
    if (m_pTransport)
        m_pTransport->DropConnection();
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BuildUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BuildUrl(LPCSTR pszFolderComponent, 
                                   LPCSTR pszNameComponent, 
                                   LPSTR *ppszUrl)
{
    HRESULT     hr = S_OK;
    DWORD       cchMsgFolderRoot = 0;
    DWORD       cchFolderComponent = 0;
    DWORD       cchNameComponent = 0;
    DWORD       cchWritten = 0;
    LPSTR       pszUrl = NULL;
    CHAR        chSlash = '/';

    Assert(NULL != m_pszMsgFolderRoot);
    Assert(NULL != ppszUrl);

    *ppszUrl = NULL;

    if (NULL == m_pszMsgFolderRoot)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    cchMsgFolderRoot = lstrlen(m_pszMsgFolderRoot);
    if (pszFolderComponent)
        cchFolderComponent = lstrlen(pszFolderComponent);
    if (pszNameComponent)
        cchNameComponent = lstrlen(pszNameComponent);

    // add three bytes - two for trailing slashes and one for the eos
    if (!MemAlloc((void **)&pszUrl, cchMsgFolderRoot + cchFolderComponent + cchNameComponent + 3))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *ppszUrl = pszUrl;

    CopyMemory(pszUrl, m_pszMsgFolderRoot, cchMsgFolderRoot);
    cchWritten = cchMsgFolderRoot;
    // make sure the msg folder root is terminated with a '/'
    if (chSlash != pszUrl[cchWritten - 1])
        pszUrl[cchWritten++] = chSlash;

    if (cchFolderComponent)
    {
        CopyMemory(&pszUrl[cchWritten], pszFolderComponent, cchFolderComponent);
        cchWritten += cchFolderComponent;
        if (chSlash != pszUrl[cchWritten - 1])
            pszUrl[cchWritten++] = chSlash;
    }

    if (cchNameComponent)
    {
        CopyMemory(&pszUrl[cchWritten], pszNameComponent, cchNameComponent);
        cchWritten += cchNameComponent;
    }

    // null terminate the string
    pszUrl[cchWritten] = 0;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BuildMessageUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BuildMessageUrl(LPCSTR pszFolderUrl, 
                                          LPSTR pszNameComponent, 
                                          LPSTR *ppszUrl)
{
    DWORD   cchFolderUrlLen;
    DWORD   cchNameComponentLen;

    if (NULL != ppszUrl)
        *ppszUrl = NULL;

    if (NULL == pszFolderUrl || NULL == pszNameComponent || NULL == ppszUrl)
        return E_INVALIDARG;
    
    cchFolderUrlLen = lstrlen(pszFolderUrl);
    cchNameComponentLen = lstrlen(pszNameComponent);

    // allocate two extra bytes - one for the '/' delimeter and one for the eos
    if (!MemAlloc((void **)ppszUrl, cchFolderUrlLen + cchNameComponentLen + 2))
        return E_OUTOFMEMORY;

    if ('/' == pszFolderUrl[cchFolderUrlLen - 1])
        wsprintf(*ppszUrl, "%s%s", pszFolderUrl, pszNameComponent);
    else
        wsprintf(*ppszUrl, "%s/%s", pszFolderUrl, pszNameComponent);

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_MarkMessageRead
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_MarkMessageRead(MESSAGEID id, BOOL fRead)
{
    HRESULT         hr;
    MESSAGEINFO     mi = {0};
    BOOL            fFoundRecord = FALSE;

    ZeroMemory(&mi, sizeof(MESSAGEINFO));
    mi.idMessage = id;

    // find the message in the database
    if (FAILED(hr = GetMessageInfo(m_pFolder, id, &mi)))
        goto exit;

    fFoundRecord = TRUE;

    if (fRead)
        mi.dwFlags |= ARF_READ;
    else
        mi.dwFlags &= ~ARF_READ;

    hr = m_pFolder->UpdateRecord(&mi);

exit:
    if (fFoundRecord)
        m_pFolder->FreeRecord(&mi);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CreateFolder(void)
{
    HRESULT     hr = S_OK;
    CHAR        szEncodedName[MAX_PATH];
    DWORD       cb = sizeof(szEncodedName);

    Assert(NULL != m_pTransport);
    Assert(NULL != m_op.pszFolderName);

    IF_FAILEXIT(hr = UrlEscapeA(m_op.pszFolderName, 
                                szEncodedName, 
                                &cb, 
                                URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT | URL_ESCAPE_SEGMENT_ONLY));
    
    IF_FAILEXIT(hr = _BuildUrl(szEncodedName, NULL, &m_op.pszDestFolderUrl));

    IF_FAILEXIT(hr = m_pTransport->CommandMKCOL(m_op.pszDestFolderUrl, 0));
    
    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::RenameFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::RenameFolder(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszSourceUrl = NULL;
    LPSTR           pszDestUrl = NULL;
    CHAR            szEncodedName[MAX_PATH];
    DWORD           cb = sizeof(szEncodedName);

    // build the source url
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi));

    pfiFree = &fi;

    IF_FAILEXIT(hr = _BuildUrl(fi.pszUrlComponent, NULL, &pszSourceUrl));

    // escape the new folder name
    IF_FAILEXIT(hr = UrlEscapeA(m_op.pszFolderName, 
                                szEncodedName, 
                                &cb, 
                                URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT | URL_ESCAPE_SEGMENT_ONLY));

    // build the destination url
    IF_FAILEXIT(hr = _BuildUrl(szEncodedName, NULL, &pszDestUrl));

    // send the MOVE command to the transport
    IF_FAILEXIT(hr = m_pTransport->CommandMOVE(pszSourceUrl, pszDestUrl, TRUE, 0));

    hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);
    SafeMemFree(pszSourceUrl);
    SafeMemFree(pszDestUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteFolder(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszUrl = NULL;

    // build the folder's url
    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
        goto exit;

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &pszUrl)))
        goto exit;

    // send the delete command to the transport
    hr = m_pTransport->CommandDELETE(pszUrl, 0);
    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);
    SafeMemFree(pszUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleCreateFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleCreateFolder(LPHTTPMAILRESPONSE pResponse)
{
    FOLDERINFO  fi;
    CHAR        szUrlComponent[MAX_PATH];
    DWORD       dwUrlComponentLen = MAX_PATH;
    HRESULT     hr = pResponse->rIxpResult.hrResult;

    if (SUCCEEDED(hr))
    {
        // if the server specified a location, use it. otherwise, use
        // the url that we included in the request
        if (NULL != pResponse->rMkColInfo.pszLocation)
            IF_FAILEXIT(hr = Http_NameFromUrl(pResponse->rMkColInfo.pszLocation, szUrlComponent, &dwUrlComponentLen));
        else
            IF_FAILEXIT(hr = Http_NameFromUrl(m_op.pszDestFolderUrl, szUrlComponent, &dwUrlComponentLen));

        // [shaheedp] Bug# 84477
        // If szUrlComponent is null, then we should not be adding this folder to the store. 
        if (!(*szUrlComponent))
        {
            hr = E_FAIL;
            goto exit;
        }

        ZeroMemory(&fi, sizeof(FOLDERINFO));

        fi.idParent = m_idServer;
        fi.tySpecial = FOLDER_NOTSPECIAL;
        fi.tyFolder = FOLDER_HTTPMAIL;
        fi.pszName = m_op.pszFolderName;
        fi.pszUrlComponent = szUrlComponent;
        fi.dwFlags = (FOLDER_SUBSCRIBED | FOLDER_NOCHILDCREATE);

        m_pStore->CreateFolder(NOFLAGS, &fi, NULL);
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleRenameFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleRenameFolder(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr = S_OK;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;

    // REVIEW: if the server doesn't return a response, return an error
    Assert(NULL != pResponse->rCopyMoveInfo.pszLocation);
    if (NULL != pResponse->rCopyMoveInfo.pszLocation)
    {
        if (FAILED(hr = Http_NameFromUrl(pResponse->rCopyMoveInfo.pszLocation, szUrlComponent, &dwUrlComponentLen)))
            goto exit;
        
        if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
            goto exit;

        pfiFree = &fi;

        fi.pszName = m_op.pszFolderName;
        fi.pszUrlComponent = szUrlComponent;

        hr = m_pStore->UpdateRecord(&fi);
    }

exit:
    if (NULL != pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleDeleteFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleDeleteFolder(LPHTTPMAILRESPONSE pResponse)
{
    return m_pStore->DeleteFolder(m_op.idFolder, DELETE_FOLDER_NOTRASHCAN, NULL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeFolders(void)
{
    // the folder list will be null if we didn't need
    // to do an auto-sync
    if (NULL != m_op.pFolderList)
        m_op.pFolderList->PurgeRemainingFromStore();

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeMessages(void)
{
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    MESSAGEID                               idMessage = MESSAGEID_INVALID;
    MESSAGEIDLIST                           rIdList = { 1, 1, &idMessage }; 
    Assert(NULL != m_op.pmapMessageId);

    long lMapLength = m_op.pmapMessageId->GetLength();
    for (long lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        if (NULL != pPair && !pPair->m_value.fMarked)
        {
            idMessage = pPair->m_value.idMessage;
            m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rIdList, NULL, NULL /* m_op.pCallback */);
        }
    }

    // don't need the map anymore
    SafeDelete(m_op.pmapMessageId);

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ResetMessageCounts
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ResetMessageCounts(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    pfiFree = NULL;

    // find the folder
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idFolder, &fi));

    pfiFree = &fi;

    // update the counts
    if (fi.cMessages != m_op.cMessages || fi.cUnread != m_op.cUnread)
    {
        fi.cMessages = m_op.cMessages;
        fi.cUnread = m_op.cUnread;
    }

    hr = m_pStore->UpdateRecord(&fi);

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetMessage(void)
{
    HRESULT             hr = S_OK;
    MESSAGEINFO         mi = {0};
    BOOL                fFoundRecord = FALSE;
    LPCSTR              rgszAcceptTypes[] = { c_szAcceptTypeRfc822, c_szAcceptTypeWildcard, NULL };
    LPSTR               pszUrl = NULL;
    TCHAR               szRes[CCHMAX_STRINGRES];

    // pull the message info out of the store
    if (FAILED(hr = GetMessageInfo(m_pFolder, m_op.idMessage, &mi)))
        goto exit;

    fFoundRecord = TRUE;
    Assert(mi.pszUrlComponent);

    if (FAILED(hr =_BuildMessageUrl(m_pszFolderUrl, mi.pszUrlComponent, &pszUrl)))
        goto exit;

    AthLoadString(idsRequestingArt, szRes, ARRAYSIZE(szRes));
    
    if (m_op.pCallback)
        m_op.pCallback->OnProgress(m_op.tyOperation, 0, 0, szRes);

    if (FAILED(hr = m_pTransport->CommandGET(pszUrl, rgszAcceptTypes, FALSE, 0)))
        goto exit;

    hr = E_PENDING;
    
exit:
    if (fFoundRecord)
        m_pFolder->FreeRecord(&mi);

    SafeMemFree(pszUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateSetFlagsRequest
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CreateSetFlagsRequest(void)
{
    HRESULT     hr;

    hr = CoCreateInstance(CLSID_IPropPatchRequest, NULL, CLSCTX_INPROC_SERVER, IID_IPropPatchRequest, (LPVOID *)&m_op.pPropPatchRequest);
    if (FAILED(hr))
        goto exit;

    if (m_op.fMarkRead)
        hr = m_op.pPropPatchRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "1");
    else
        hr = m_op.pPropPatchRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "0");

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetMessageFlags
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::SetMessageFlags(void)
{
    HRESULT             hr = S_OK;
    LPHTTPTARGETLIST    pTargets = NULL;
    LPSTR               pszMessageUrl = NULL;
    ADJUSTFLAGS         af;

    af.dwAdd = m_op.fMarkRead ? ARF_READ : 0;
    af.dwRemove = !m_op.fMarkRead ? ARF_READ : 0;
    
    // if we have a rowset, we shouldn't have an ID List.
    Assert(NULL == m_op.hRowSet || NULL == m_op.pIDList);
    IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, m_op.hRowSet, &af, m_op.dwSetFlags, &m_op.pmapMessageId, &pTargets));

    // if the folder is the msnpromo folder, advance to the next state.
    // don't actually send the command to the server
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        goto exit;

    // if there is only one target, build a complete url for the target
    // and invoke the non-batch version of the command. if there are no targets,
    // return S_OK, and don't send any commands to the xport
    if (1 == pTargets->cTarget)
    {
        IF_FAILEXIT(hr = _BuildMessageUrl(m_pszFolderUrl, const_cast<char *>(pTargets->prgTarget[0]), &pszMessageUrl));
        IF_FAILEXIT(hr = m_pTransport->MarkRead(pszMessageUrl, NULL, m_op.fMarkRead, 0));

        hr = E_PENDING;
    }
    else if (pTargets->cTarget > 0)
    {
        IF_FAILEXIT(hr = m_pTransport->MarkRead(m_pszFolderUrl, pTargets, m_op.fMarkRead, 0));

        hr = E_PENDING;
    }

exit:
    if (pTargets)
        Http_FreeTargetList(pTargets);
    SafeMemFree(pszMessageUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ApplyFlagsToStore
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ApplyFlagsToStore(void)
{
    HRESULT                                 hr = S_OK;
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    long                                    lMapLength = m_op.pmapMessageId->GetLength();
    ADJUSTFLAGS                             af;
    BOOL                                    fFoundMarked = FALSE;
    long                                    lIndex;

    af.dwAdd = m_op.fMarkRead ? ARF_READ : 0;
    af.dwRemove = !m_op.fMarkRead ? ARF_READ : 0;
    
    // if the operation was requested on the entire folder,
    // check to see if anything failed. if it did, then
    // build up an IDList so we can mark only the msgs that
    // were successfully modified
    if (NULL != m_op.hRowSet)
    {
        Assert(NULL == m_op.pIDList);
        for (lIndex = 0; lIndex < lMapLength && !fFoundMarked; lIndex++)
        {
            pPair = m_op.pmapMessageId->GetItemAt(lIndex);
            Assert(NULL != pPair);
            if (pPair && pPair->m_value.fMarked)
                fFoundMarked = TRUE;
        }
        
        // if no messages were marked, apply the operation to the entire folder
        if (!fFoundMarked)
        {
            hr = m_pFolder->SetMessageFlags(NULL, &af, NULL, NULL);
            // we're done
            goto exit;
        }

        // if one or more msgs were marked, allocate an idlist
        if (fFoundMarked)
        {
            // allocate the list structure
            if (!MemAlloc((void **)&m_op.pIDList, sizeof(MESSAGEIDLIST)))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            ZeroMemory(&m_op.pIDList, sizeof(MESSAGEIDLIST));

            // allocate storage
            if (!MemAlloc((void **)&m_op.pIDList->prgidMsg, sizeof(MESSAGEID) * lMapLength))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            m_op.pIDList->cAllocated = lMapLength;
            m_op.pIDList->cMsgs = 0;
        }
    }
    

    // we need to apply the setflags operation to the local store. we
    // can't just pass the message id list that we got originally,
    // because some of the operation may have failed. instead, we
    // rebuild the id list (in place, since we know the successful
    // operations will never outnumber the attempted operations),
    // and send that into the store
    Assert(NULL != m_op.pIDList);
    Assert(NULL != m_op.pmapMessageId);
    Assert(m_op.pIDList->cMsgs >= (DWORD)lMapLength);

    m_op.pIDList->cMsgs = 0;

    for (lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        Assert(NULL != pPair);
        // if the item isn't marked, then it was successfully modified
        if (pPair && !pPair->m_value.fMarked)
            m_op.pIDList->prgidMsg[m_op.pIDList->cMsgs++] = pPair->m_value.idMessage;
    }

    // if the resulting id list contains at least one message, perform the operation
    if (m_op.pIDList->cMsgs > 0)
        hr = m_pFolder->SetMessageFlags(m_op.pIDList, &af, NULL, NULL);

    // todo: alert user if the operation failed in part
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleMemberErrors
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleMemberErrors(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                             hr = S_OK;
    LPHTTPMEMBERERROR                   pme = NULL;
    CHAR                                szUrlComponent[MAX_PATH];
    DWORD                               dwComponentBytes;
    CSimpleString                       ss;
    TPair<CSimpleString, MARKEDMESSAGE> *pFoundPair = NULL;

    // loop through the response looking for errors. we ignore
    // per-item success.

    for (DWORD dw = 0; dw < pResponse->rMemberErrorList.cMemberError; dw++)
    {
        pme = &pResponse->rMemberErrorList.prgMemberError[dw];

        if (SUCCEEDED(pme->hrResult))
            continue;

        Assert(NULL != pme->pszHref);
        if (NULL == pme->pszHref)
            continue;

        dwComponentBytes = ARRAYSIZE(szUrlComponent);
        if (FAILED(Http_NameFromUrl(pme->pszHref, szUrlComponent, &dwComponentBytes)))
            continue;

        IF_FAILEXIT(hr = ss.SetString(szUrlComponent));
        
        // find and mark the found message
        pFoundPair = m_op.pmapMessageId->Find(ss);
        Assert(NULL != pFoundPair);
        if (NULL != pFoundPair)
            pFoundPair->m_value.fMarked = TRUE;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteMessages(void)
{
    HRESULT             hr = S_OK;
    LPSTR               pszMessageUrl = NULL;
    LPSTR               pszNoDeleteSupport = NULL;

    // if we have a rowset, we shouldn't have an ID List
    Assert(NULL == m_op.hRowSet || NULL == m_op.pIDList);
    IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, m_op.hRowSet, NULL, 0, &m_op.pmapMessageId, &m_op.pTargets));

    // look for an already cached property that indicates that the server
    // isn't going to support deleting messages (Hotmail doesn't)
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPNOMESSAGEDELETES, &pszNoDeleteSupport))
    {
        if (!!(DELETE_MESSAGE_MAYIGNORENOTRASH & m_op.dwDelMsgFlags))
            m_op.fFallbackToMove = TRUE;
        else
            hr = SP_E_HTTP_NODELETESUPPORT;
        goto exit;
    }

    // if there is only one target, build a complete url for the target,
    // and call the non-batch version of the command. if there are no targets,
    // return S_OK and don't issue any commands
    if (!m_op.pTargets)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (1 == m_op.pTargets->cTarget)
    {
        IF_FAILEXIT(hr = _BuildMessageUrl(m_pszFolderUrl, const_cast<char *>(m_op.pTargets->prgTarget[0]), &pszMessageUrl));
        IF_FAILEXIT(hr = m_pTransport->CommandDELETE(pszMessageUrl, 0));
    }
    else
        IF_FAILEXIT(hr = m_pTransport->CommandBDELETE(m_pszFolderUrl, m_op.pTargets, 0));

    hr = E_PENDING;

exit:
    SafeMemFree(pszNoDeleteSupport);
    SafeMemFree(pszMessageUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFallbackToMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteFallbackToMove(void)
{
    HRESULT             hr = S_OK;
    IMessageFolder      *pDeletedItems = NULL;

    if (!m_op.fFallbackToMove)
        goto exit;

    // find the deleted items folder
    IF_FAILEXIT(hr = m_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems));
    if (NULL == pDeletedItems)
    {
        hr = TraceResult(IXP_E_HTTP_NOT_FOUND);
        goto exit;
    }

    IF_FAILEXIT(hr = pDeletedItems->GetFolderId(&m_op.idFolder));

    Assert(NULL == m_op.pMessageFolder);
    
    // should already have a targets list by this point
    Assert(NULL != m_op.pTargets);

    m_op.pMessageFolder = pDeletedItems;
    pDeletedItems = NULL;

    m_op.dwOptions = COPY_MESSAGE_MOVE;

    if (1 == m_op.pTargets->cTarget)
        hr = CopyMoveMessage();
    else
        hr = BatchCopyMoveMessages();

exit:
    SafeRelease(pDeletedItems);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleDeleteFallbackToMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleDeleteFallbackToMove(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;

    if (1 == m_op.pTargets->cTarget)
        hr = HandleCopyMoveMessage(pResponse);
    else
        hr = HandleBatchCopyMoveMessages(pResponse);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PutMessage(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    pfiFree = NULL;
    
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi));

    pfiFree = &fi;

    IF_FAILEXIT(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl));

    IF_FAILEXIT(hr = m_pTransport->CommandPOST(m_op.pszDestFolderUrl, m_op.pMessageStream, c_szAcceptTypeRfc822, 0));

    hr = E_PENDING;

exit:
    //SafeMemFree(pv);

    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::BatchCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::BatchCopyMoveMessages(void)
{
    HRESULT             hr = S_OK;
    FOLDERINFO          fi = {0};
    LPFOLDERINFO        pfiFree = NULL;
    
    // build the destination folder urls
    IxpAssert(NULL == m_op.pszDestFolderUrl);

    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl)))
        goto exit;

    Assert(NULL == m_op.pTargets || m_op.fFallbackToMove);

    // build the target list and the message id map
    if (NULL == m_op.pTargets)
        IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, NULL, NULL, 0, &m_op.pmapMessageId, &m_op.pTargets));

    if (!!(m_op.dwOptions & COPY_MESSAGE_MOVE))
        hr = m_pTransport->CommandBMOVE(m_pszFolderUrl, m_op.pTargets, m_op.pszDestFolderUrl, NULL, TRUE, 0);
    else
        hr = m_pTransport->CommandBCOPY(m_pszFolderUrl, m_op.pTargets, m_op.pszDestFolderUrl, NULL, TRUE, 0);

    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CopyMoveMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CopyMoveMessage(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;

    // build the destination folder urls
    IxpAssert(NULL == m_op.pszDestFolderUrl);

    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl)))
        goto exit;

    hr = _CopyMoveNextMessage();

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::FinalizeBatchCopyMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::FinalizeBatchCopyMove(void)
{
    HRESULT     hr = S_OK;

    if (NOFLAGS != m_op.dwCopyMoveErrorFlags)
    {
        hr = E_FAIL;
        
        if (HTTPCOPYMOVE_OUTOFSPACE == m_op.dwCopyMoveErrorFlags)
            m_op.pszProblem = AthLoadString(idsHttpBatchCopyNoStorage, NULL, 0);
        else
            m_op.pszProblem = AthLoadString(idsHttpBatchCopyErrors, NULL , 0);
    }

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeDeletedFromStore
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeDeletedFromStore(void)
{
    HRESULT                                 hr = S_OK;
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    long                                    lMapLength = m_op.pmapMessageId->GetLength();
    BOOL                                    fFoundMarked = FALSE;
    long                                    lIndex;

    if (m_op.fFallbackToMove)
        goto exit;

    // if the operation was requested on the entire folder,
    // check to see if anything failed. if it did, then build
    // up an IDList so we can mark only the msgs that were
    // successfully modified
    if (NULL != m_op.hRowSet)
    {
        Assert(NULL == m_op.pIDList);
        for (lIndex = 0; lIndex < lMapLength && !fFoundMarked; lIndex++)
        {
            pPair = m_op.pmapMessageId->GetItemAt(lIndex);
            Assert(NULL != pPair);
            if (pPair && pPair->m_value.fMarked)
                fFoundMarked = TRUE;
        }
        
        // if no messages were marked, apply the operation to the entire folder
        if (!fFoundMarked)
        {
            hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
            // we're done
            goto exit;
        }

        // if one or more msgs were marked, allocate an idlist
        if (fFoundMarked)
        {
            // allocate the list structure
            if (!MemAlloc((void **)&m_op.pIDList, sizeof(MESSAGEIDLIST)))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            ZeroMemory(&m_op.pIDList, sizeof(MESSAGEIDLIST));

            // allocate storage
            if (!MemAlloc((void **)&m_op.pIDList->prgidMsg, sizeof(MESSAGEID) * lMapLength))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            m_op.pIDList->cAllocated = lMapLength;
            m_op.pIDList->cMsgs = 0;
        }
    }

    // apply the delete operation to the local store. we can't just pass
    // the message id list that we got originally, because some of the operation
    // may have failed. instead, we rebuild the id list (in place, since we know
    // the successful operations will never outnumber the attempted operations,
    // and send that to the store.
    Assert(NULL != m_op.pIDList);
    Assert(NULL != m_op.pmapMessageId);
    Assert(m_op.pIDList->cMsgs >= (DWORD)lMapLength);

    // set the idlist count to 0. we will re-populate the
    // idlist with ids from the messageID map. We know that
    // the idlist is the same size as the map, so there won't
    // be an overflow problem.
    m_op.pIDList->cMsgs = 0;

    for (lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        Assert(NULL != pPair);
        // if the item isn't marked, then it was successfully modified
        if (pPair && !pPair->m_value.fMarked)
            m_op.pIDList->prgidMsg[m_op.pIDList->cMsgs++] = pPair->m_value.idMessage;
    }

    // if the resulting id list contains at least one message, perform the operation
    if (m_op.pIDList->cMsgs > 0)
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, m_op.pIDList, NULL, NULL);

    // todo: alert user if the operation failed in part

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandlePutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandlePutMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;

    if (!pResponse->fDone && m_op.pCallback)
    {
        m_op.pCallback->OnProgress(m_op.tyOperation, 
                                   pResponse->rPostInfo.cbCurrent,
                                   pResponse->rPostInfo.cbTotal,
                                   NULL);
    }

    if (pResponse->fDone)
    {
        Assert(NULL != pResponse->rPostInfo.pszLocation);
        if (NULL == pResponse->rPostInfo.pszLocation)
        {
            hr = E_FAIL;
            goto exit;
        }

        // assume ownership of the location url
        m_op.pszDestUrl = pResponse->rPostInfo.pszLocation;
        pResponse->rPostInfo.pszLocation = NULL;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddPutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::AddPutMessage()
{
    HRESULT         hr = S_OK;
    IMessageFolder  *pFolder = NULL;
    MESSAGEID       idMessage;
    MESSAGEFLAGS    dwFlags;
    
    // adopt some of the flags of the message we are putting
    dwFlags = m_op.dwMsgFlags & (ARF_READ | ARF_SIGNED | ARF_ENCRYPTED | ARF_HASATTACH | ARF_VOICEMAIL);

    if (!!(m_op.dwMsgFlags & ARF_UNSENT) || FOLDER_DRAFT == m_tySpecialFolder)
        dwFlags |= ARF_UNSENT;

    IF_FAILEXIT(hr = m_pStore->OpenFolder(m_op.idFolder, NULL, NOFLAGS, &pFolder));
    
    IF_FAILEXIT(hr = Http_AddMessageToFolder(pFolder, m_szAccountId, NULL, dwFlags, m_op.pszDestUrl, &idMessage));
    
    IF_FAILEXIT(hr = Http_SetMessageStream(pFolder, idMessage, m_op.pMessageStream, NULL, TRUE));

    m_op.idPutMessage = idMessage;

exit:
    SafeRelease(pFolder);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleBatchCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleBatchCopyMoveMessages(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                                 hr = S_OK;
    CHAR                                    szUrlComponent[MAX_PATH];
    DWORD                                   dwComponentBytes;
    LPHTTPMAILBCOPYMOVE                     pCopyMove;
    CSimpleString                           ss;
    TPair<CSimpleString, MARKEDMESSAGE>     *pFoundPair = NULL;
    HLOCK                                   hLockNotify = NULL;
    BOOL                                    fDeleteOriginal = !!(m_op.dwOptions & COPY_MESSAGE_MOVE);

    // This forces all notifications to be queued (this is good since you do segmented deletes)
    m_pFolder->LockNotify(0, &hLockNotify);

    for (DWORD dw = 0; dw < pResponse->rBCopyMoveList.cBCopyMove; dw++)
    {
        pCopyMove = &pResponse->rBCopyMoveList.prgBCopyMove[dw];
        
        if (FAILED(pCopyMove->hrResult))
        {
            if (IXP_E_HTTP_INSUFFICIENT_STORAGE == pCopyMove->hrResult)
                m_op.dwCopyMoveErrorFlags |= HTTPCOPYMOVE_OUTOFSPACE;
            else
                m_op.dwCopyMoveErrorFlags |= HTTPCOPYMOVE_ERROR;
            continue;
        }

        Assert(NULL != pCopyMove->pszHref);
        if (pCopyMove->pszHref)
        {
            dwComponentBytes = ARRAYSIZE(szUrlComponent);
            if (FAILED(Http_NameFromUrl(pCopyMove->pszHref, szUrlComponent, &dwComponentBytes)))
                continue;
            
            if (FAILED(ss.SetString(szUrlComponent)))
                goto exit;

            pFoundPair = m_op.pmapMessageId->Find(ss);
            Assert(NULL != pFoundPair);

            if (NULL == pFoundPair)
                continue;
            
            // move the message and, if the move succeeds, mark the success
            if (SUCCEEDED(_CopyMoveLocalMessage(pFoundPair->m_value.idMessage, m_op.pMessageFolder, pCopyMove->pszLocation, fDeleteOriginal)))
                pFoundPair->m_value.fMarked = TRUE;
        }
    }

exit:
    m_pFolder->UnlockNotify(&hLockNotify);

    m_op.lIndex += pResponse->rBCopyMoveList.cBCopyMove;
    if (m_op.pCallback)
        m_op.pCallback->OnProgress(m_op.tyOperation, m_op.lIndex + 1, m_op.pmapMessageId->GetLength(), NULL);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleCopyMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleCopyMoveMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr = S_OK;
    BOOL            fDeleteOriginal = !!(m_op.dwOptions & COPY_MESSAGE_MOVE);

    hr = _CopyMoveLocalMessage(m_op.pIDList->prgidMsg[m_op.dwIndex - 1], 
                        m_op.pMessageFolder, 
                        pResponse->rCopyMoveInfo.pszLocation,
                        fDeleteOriginal);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CopyMoveLocalMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CopyMoveLocalMessage(MESSAGEID    idMessage,
                                           IMessageFolder*  pDestFolder,
                                           LPSTR            pszUrl,
                                           BOOL             fMoveSource)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     miSource, miDest;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    IStream        *pStream = NULL;
    LPMESSAGEINFO   pmiFreeSource = NULL;
    MESSAGEIDLIST   rIdList = { 1, 1, &idMessage }; 

    ZeroMemory(&miDest, sizeof(MESSAGEINFO));

    if (FAILED(hr = GetMessageInfo(m_pFolder, idMessage, &miSource)))
        goto exit;

    pmiFreeSource = &miSource;

    // get the store to generate an id
    if (FAILED(hr = pDestFolder->GenerateId((DWORD *)&miDest.idMessage)))
        goto exit;

    // if the response specified a destination, use it. otherwise, assume
    // that the url component did not change
    if (pszUrl)
    {
        if (FAILED(hr = Http_NameFromUrl(pszUrl, szUrlComponent, &dwUrlComponentLen)))
            goto exit;
    }
    else if (miSource.pszUrlComponent)
    {
        lstrcpy(szUrlComponent, miSource.pszUrlComponent);
    }

    miDest.dwFlags = miSource.dwFlags;
    miDest.dwFlags &= ~(ARF_HASBODY | ARF_DELETED_OFFLINE);
    miDest.pszSubject = miSource.pszSubject;
    miDest.pszNormalSubj = miSource.pszNormalSubj;
    miDest.pszDisplayFrom = miSource.pszDisplayFrom;
    miDest.ftReceived = miSource.ftReceived;
    miDest.pszUrlComponent = szUrlComponent;
    miDest.pszEmailTo = miSource.pszEmailTo;

    // add it to the database
    if (FAILED(hr = m_op.pMessageFolder->InsertRecord(&miDest)))
        goto exit;

    // normalize the result code
    hr = S_OK;

    if (0 != miSource.faStream)
    {
        FILEADDRESS faDst;
        IStream *pStmDst;

        Assert(!!(miSource.dwFlags & ARF_HASBODY));

        if (FAILED(hr = m_pFolder->CopyStream(m_op.pMessageFolder, miSource.faStream, &faDst)))
            goto exit;

        if (FAILED(hr = m_op.pMessageFolder->OpenStream(ACCESS_READ, faDst, &pStmDst)))
            goto exit;

        if (FAILED(hr = m_op.pMessageFolder->SetMessageStream(miDest.idMessage, pStmDst)))
        {
            pStmDst->Release();
            goto exit;
        }

        pStmDst->Release();
    }

    if (fMoveSource)
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rIdList, NULL, NULL);

exit:
    SafeRelease(pStream);
    if (NULL != pmiFreeSource)
        m_pFolder->FreeRecord(pmiFreeSource);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CopyMoveNextMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CopyMoveNextMessage(void)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     mi = {0};
    MESSAGEINFO     *pmiFree = NULL;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    LPSTR           pszSourceUrl = NULL;
    LPSTR           pszDestUrl = NULL;

    // return success when the index meets the count
    if (m_op.dwIndex == m_op.pIDList->cMsgs)
        goto exit;

    if (FAILED(hr = GetMessageInfo(m_pFolder, m_op.pIDList->prgidMsg[m_op.dwIndex], &mi)))
        goto exit;

    pmiFree = &mi;

    ++m_op.dwIndex;

    Assert(mi.pszUrlComponent);
    if (NULL == mi.pszUrlComponent)
    {
        hr = ERROR_INTERNET_INVALID_URL;
        goto exit;
    }

    // build the source url
    if (FAILED(hr = _BuildMessageUrl(m_pszFolderUrl, mi.pszUrlComponent, &pszSourceUrl)))
        goto exit;

    // build the destination url
    if (FAILED(hr = _BuildMessageUrl(m_op.pszDestFolderUrl, mi.pszUrlComponent, &pszDestUrl)))
        goto exit;

    if (!!(m_op.dwOptions & COPY_MESSAGE_MOVE))
        hr = m_pTransport->CommandMOVE(pszSourceUrl, pszDestUrl, TRUE, 0);
    else
        hr = m_pTransport->CommandCOPY(pszSourceUrl, pszDestUrl, TRUE, 0);
    
    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (NULL != pmiFree)
        m_pFolder->FreeRecord(pmiFree);
    SafeMemFree(pszSourceUrl);
    SafeMemFree(pszDestUrl);

    return hr;
    
}

//----------------------------------------------------------------------
// CHTTPMailServer::_DoCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_DoCopyMoveMessages(STOREOPERATIONTYPE sot,
                                                IMessageFolder *pDest,
                                                COPYMESSAGEFLAGS dwOptions,
                                                LPMESSAGEIDLIST pList,
                                                IStoreCallback *pCallback)
{
    HRESULT     hr = S_OK;

    AssertSingleThreaded;

    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if ((NULL == pList) || (0 == pList->cMsgs) || (NULL == pDest) || (NULL == pCallback))
        return E_INVALIDARG;

    if (FAILED(hr = pDest->GetFolderId(&m_op.idFolder)))
        goto exit;

    if (FAILED(hr = CloneMessageIDList(pList, &m_op.pIDList)))
    {
        m_op.idFolder = FOLDERID_INVALID;
        goto exit;
    }
    
    m_op.tyOperation = sot;

    if (1 == pList->cMsgs)
    {
        m_op.pfnState = c_rgpfnCopyMoveMessage;
        m_op.cState = ARRAYSIZE(c_rgpfnCopyMoveMessage);
    }
    else
    {
        m_op.pfnState = c_rgpfnBatchCopyMoveMessages;
        m_op.cState = ARRAYSIZE(c_rgpfnBatchCopyMoveMessages);
    }
    
    m_op.dwOptions = dwOptions;
    m_op.iState = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.pMessageFolder = pDest;
    m_op.pMessageFolder->AddRef();

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadAccountInfo
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_LoadAccountInfo(IImnAccount *pAcct)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    FOLDERINFO      *pfiFree = NULL;;

    Assert(NULL != pAcct);
    Assert(FOLDERID_INVALID != m_idServer);
    Assert(NULL != m_pStore);
    Assert(NULL != g_pAcctMan);

    // free data associated with the account. if we connected to
    // a transport, and then disconnected, we might be reconnecting
    // with stale data left around.
    SafeMemFree(m_pszFldrLeafName);

    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idServer, &fi));
    
    pfiFree = &fi;

    m_pszFldrLeafName = PszDupA(fi.pszName);
    if (NULL == m_pszFldrLeafName)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // failure of the account name is recoverable
    pAcct->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName, sizeof(m_szAccountName));

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadTransport
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_LoadTransport(void)
{
    HRESULT         hr = S_OK;
    char            szLogFilePath[MAX_PATH];
    char            *pszLogFilePath = NULL;
    LPSTR           pszUserAgent = NULL;
    
    Assert(NULL == m_pTransport);

    // Create and initialize HTTPMail transport
    hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&m_pTransport);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    IF_FAILEXIT(hr = m_pTransport->QueryInterface(IID_IHTTPMailTransport2, (LPVOID*)&m_pTransport2));

    // check if logging is enabled
    if (DwGetOption(OPT_MAIL_LOGHTTPMAIL))
    {
        char    szDirectory[MAX_PATH];
        char    szLogFileName[MAX_PATH];

        DWORD   cb;

        *szDirectory = 0;

        // get the log filename
        cb = GetOption(OPT_MAIL_HTTPMAILLOGFILE, szLogFileName, sizeof(szLogFileName) / sizeof(TCHAR));
        if (0 == cb)
        {
            // push the defaults into the registry
            lstrcpy(szLogFileName, c_szDefaultHTTPMailLog);
            SetOption(OPT_MAIL_HTTPMAILLOGFILE,
                (void *)c_szDefaultHTTPMailLog,
                lstrlen(c_szDefaultHTTPMailLog) + sizeof(TCHAR),
                NULL,
                0);                        
        }

        m_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
        PathCombineA(szLogFilePath, szDirectory, szLogFileName);

        pszLogFilePath = szLogFilePath;
    }

    pszUserAgent = GetOEUserAgentString();
    if (FAILED(hr = m_pTransport->InitNew(pszUserAgent, pszLogFilePath, this)))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszUserAgent);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_TranslateHTTPSpecialFolderType
//----------------------------------------------------------------------
SPECIALFOLDER CHTTPMailServer::_TranslateHTTPSpecialFolderType(HTTPMAILSPECIALFOLDER tySpecial)
{
    SPECIALFOLDER tyOESpecial;

    switch (tySpecial)
    {
        case HTTPMAIL_SF_INBOX:
            tyOESpecial = FOLDER_INBOX;
            break;

        case HTTPMAIL_SF_DELETEDITEMS:
            tyOESpecial = FOLDER_DELETED;
            break;

        case HTTPMAIL_SF_DRAFTS:
            tyOESpecial = FOLDER_DRAFT;
            break;

        case HTTPMAIL_SF_OUTBOX:
            tyOESpecial = FOLDER_OUTBOX;
            break;

        case HTTPMAIL_SF_SENTITEMS:
            tyOESpecial = FOLDER_SENT;
            break;

        case HTTPMAIL_SF_MSNPROMO:
            tyOESpecial = FOLDER_MSNPROMO;
            break;

        case HTTPMAIL_SF_BULKMAIL:
            tyOESpecial = FOLDER_BULKMAIL;
            break;

        default:
            tyOESpecial = FOLDER_NOTSPECIAL;
            break;
    }

    return tyOESpecial;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadSpecialFolderName
//----------------------------------------------------------------------
BOOL CHTTPMailServer::_LoadSpecialFolderName(SPECIALFOLDER tySpecial,
                                             LPSTR pszName,
                                             DWORD cbBuffer)
{
    BOOL    fResult = TRUE;
    UINT    uID;

    switch (tySpecial)
    {
        case FOLDER_INBOX:
            uID = idsInbox;
            break;

        case FOLDER_DELETED:
            uID = idsDeletedItems;
            break;

        case FOLDER_DRAFT:
            uID = idsDraft;
            break;

        case FOLDER_OUTBOX:
            uID = idsOutbox;
            break;

        case FOLDER_SENT:
            uID = idsSentItems;
            break;

        case FOLDER_MSNPROMO:
            uID = idsMsnPromo;
            break;

        case FOLDER_BULKMAIL:
            uID = idsJunkFolderName;
            break;

        default:
            fResult = FALSE;
            break;
    }

    if (fResult && (0 == LoadString(g_hLocRes, uID, pszName, cbBuffer)))
        fResult = FALSE;

    return fResult;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CreateMessageIDMap
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CreateMessageIDMap(TMap<CSimpleString, MARKEDMESSAGE> **ppMap)
{
    HRESULT                                 hr = S_OK;
    TMap<CSimpleString, MARKEDMESSAGE>      *pMap = NULL;
    HROWSET                                 hRowSet = NULL;
    MESSAGEINFO                             mi;
    CSimpleString                           ss;
    MARKEDMESSAGE                           markedID = { 0, 0, FALSE };

    if (NULL == m_pStore || NULL == ppMap)
        return E_INVALIDARG;

    *ppMap = NULL;

    pMap = new TMap<CSimpleString, MARKEDMESSAGE>;
    if (NULL == pMap)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(&mi, sizeof(MESSAGEINFO));

    if (FAILED(hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet)))
        goto exit;

    // iterate through the messages
    while (S_OK == m_pFolder->QueryRowset(hRowSet, 1, (LPVOID *)&mi, NULL))
    {
        // add the message's info to the map
        markedID.idMessage = mi.idMessage;
        markedID.dwFlags = mi.dwFlags;

        hr = ss.SetString(mi.pszUrlComponent);
        if (FAILED(hr))
        {
            m_pFolder->FreeRecord(&mi);
            goto exit;
        }

        hr = pMap->Add(ss, markedID);

        // Free
        m_pFolder->FreeRecord(&mi);
        
        if (FAILED(hr))
            goto exit;
    }

    // the map was built successfully
    *ppMap = pMap;
    pMap = NULL;

exit:
    if (NULL != hRowSet)
        m_pFolder->CloseRowset(&hRowSet);

    if (NULL != pMap)
        delete pMap;

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_HrBuildMapAndTargets
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_HrBuildMapAndTargets(LPMESSAGEIDLIST pList,
                                               HROWSET hRowSet,
                                               LPADJUSTFLAGS pFlags,
                                               SETMESSAGEFLAGSFLAGS dwFlags,
                                               TMap<CSimpleString, MARKEDMESSAGE> **ppMap,
                                               LPHTTPTARGETLIST *ppTargets)
{
    HRESULT                                 hr = S_OK;
    TMap<CSimpleString, MARKEDMESSAGE>      *pMap = NULL;
    LPHTTPTARGETLIST                        pTargets = NULL;
    MESSAGEINFO                             mi = { 0 };
    LPMESSAGEINFO                           pmiFree = NULL;
    CSimpleString                           ss;
    MARKEDMESSAGE                           markedID = { 0, 0, FALSE };
    BOOL                                    fSkipRead = (pFlags && !!(pFlags->dwAdd & ARF_READ));
    BOOL                                    fSkipUnread = (pFlags && !!(pFlags->dwRemove & ARF_READ));
    DWORD                                   cMsgs;
    DWORD                                   dwIndex = 0;

    if ((NULL == pList && NULL == hRowSet) || NULL == ppMap || NULL == ppTargets)
        return E_INVALIDARG;

    // expect either a list or a rowset, but not both
    Assert(NULL == pList || NULL == hRowSet);

    // if using a rowset, determine the rowcount
    if (NULL != hRowSet)
    {
        IF_FAILEXIT(hr = m_pFolder->GetRecordCount(0, &cMsgs));

        // seek the first row
        IF_FAILEXIT(hr = m_pFolder->SeekRowset(hRowSet, SEEK_ROWSET_BEGIN, 0, NULL));
    }
    else
        cMsgs = pList->cMsgs;

    *ppMap = NULL;
    *ppTargets = NULL;

    pMap = new TMap<CSimpleString, MARKEDMESSAGE>;
    if (NULL == pMap)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (!MemAlloc((void **)&pTargets, sizeof(HTTPTARGETLIST)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    pTargets->cTarget = 0;
    pTargets->prgTarget = NULL;

    // allocate enough space for all of the targets
    if (!MemAlloc((void **)&pTargets->prgTarget, sizeof(LPCSTR) * cMsgs))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    ZeroMemory(pTargets->prgTarget, sizeof(LPCSTR) * cMsgs);

    while (TRUE)
    {
        // fetch the next message
        if (NULL != pList)
        {
            if (dwIndex == pList->cMsgs)
                break;

            hr = GetMessageInfo(m_pFolder, pList->prgidMsg[dwIndex++], &mi);
            
            // if the record wasn't found, just skip it
            if (DB_E_NOTFOUND == hr)
                goto next;

            if (FAILED(hr))
                break;
        }
        else
        {
            // bail out if the number of targets is the same as the rowcount
            // we expected. this will prevent us from overflowing the target
            // array if the rowcount changes while we are building up our target
            // list.
            if (pTargets->cTarget == cMsgs)
                break;

            if (S_OK != m_pFolder->QueryRowset(hRowSet, 1, (LPVOID *)&mi, NULL))
                break;
        }

        pmiFree = &mi;

        // respect control flags, if they exist
        if (0 == (dwFlags & SET_MESSAGE_FLAGS_FORCE) && ((fSkipRead && !!(mi.dwFlags & ARF_READ)) || (fSkipUnread && !(mi.dwFlags & ARF_READ))))
            goto next;

        Assert(NULL != mi.pszUrlComponent);
        if (NULL == mi.pszUrlComponent)
        {
            hr = TrapError(ERROR_INTERNET_INVALID_URL);
            goto exit;
        }
        
        // add the url component to the target list
        pTargets->prgTarget[pTargets->cTarget] = PszDupA(mi.pszUrlComponent);
        if (NULL == pTargets->prgTarget[pTargets->cTarget])
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        pTargets->cTarget++;

        // add the url and the message id to the map
        markedID.idMessage = mi.idMessage;
        markedID.dwFlags = mi.dwFlags;

        if (FAILED(hr = ss.SetString(mi.pszUrlComponent)))
            goto exit;

        if (FAILED(hr = pMap->Add(ss, markedID)))
            goto exit;

next:
        if (pmiFree)
        {
            m_pFolder->FreeRecord(pmiFree);
            pmiFree = NULL;
        }
        hr = S_OK;
    }
    
    *ppMap = pMap;
    pMap = NULL;

    *ppTargets = pTargets;
    pTargets = NULL;

exit:
    if (pmiFree)
        m_pFolder->FreeRecord(pmiFree);

    if (pTargets)
        Http_FreeTargetList(pTargets);

    SafeDelete(pMap);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_FillStoreError
//----------------------------------------------------------------------
void CHTTPMailServer::_FillStoreError(LPSTOREERROR pErrorInfo, 
                                      IXPRESULT *pResult)
{
    TraceCall("CHTTPMailServer::FillStoreError");

    Assert(m_cRef >= 0); // Can be called during destruction
    Assert(NULL != pErrorInfo);

    //TODO: Fill in pszFolder

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    if (IXP_E_USER_CANCEL == pResult->hrResult)
        pErrorInfo->hrResult = STORE_E_OPERATION_CANCELED;
    else
        pErrorInfo->hrResult = pResult->hrResult;
    pErrorInfo->uiServerError = pResult->uiServerError; 
    pErrorInfo->hrServerError = pResult->hrServerError;
    pErrorInfo->dwSocketError = pResult->dwSocketError; 
    pErrorInfo->pszProblem = (NULL != m_op.pszProblem) ? m_op.pszProblem : pResult->pszProblem;
    pErrorInfo->pszDetails = pResult->pszResponse;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszFolder = NULL;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "HTTPMail";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_HTTPMail;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = 0;
}

STDMETHODIMP    CHTTPMailServer::GetAdBarUrl(IStoreCallback *pCallback)
{
    TraceCall("CHTTPMailServer::GetAdBarUrl");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_GET_ADURL;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnGetAdUrl;
    m_op.cState = ARRAYSIZE(c_rgpfnGetAdUrl);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
    
}

HRESULT CHTTPMailServer::GetAdBarUrlFromServer()
{
    HRESULT     hr = S_OK;
    LPSTR       pszUrl = NULL;

    hr = m_pTransport->GetProperty(HTTPMAIL_PROP_ADBAR, &pszUrl);

    if (hr == S_OK)
        m_op.pszAdUrl = pszUrl;

    return hr;

}

STDMETHODIMP    CHTTPMailServer::GetMinPollingInterval(IStoreCallback *pCallback)
{
    TraceCall("CHTTPMailServer::GetMinPollingInterval");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_GET_HTTP_MINPOLLINGINTERVAL;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnGetMinPollingInterval;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMinPollingInterval);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
    
}

HRESULT CHTTPMailServer::GetMinPollingInterval()
{
    DWORD       dwDone               = FALSE;
    DWORD       dwPollingInterval    = 0;
    HRESULT     hr                   = S_OK;

    hr = m_pTransport->GetPropertyDw(HTTPMAIL_PROP_MAXPOLLINGINTERVAL, &dwPollingInterval);

    if (hr == S_OK)
        m_op.dwMinPollingInterval = dwPollingInterval;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\addrlist.h ===
// =================================================================================
// CAddressList Object Definition
// =================================================================================
#ifndef __ADDRESS_H
#define __ADDRESS_H

template<class TYPE, class ARG_TYPE> class CList;

// =================================================================================
// Internet address definition
// =================================================================================
class CAddress
{
private:
    ULONG       m_ulRef;

public:
    LPTSTR       m_lpszDisplay;
    LPTSTR       m_lpszAddress;
    LPTSTR       m_lpszReject;

public:
    // =================================================================================
    // Constructor / Destructor
    // =================================================================================
    CAddress ();
    ~CAddress ();

    // =================================================================================
    // Reference Counts
    // =================================================================================
    ULONG AddRef ();
    ULONG Release ();

    // =================================================================================
    // Set Props
    // =================================================================================
    void SetReject (LPTSTR lpszReject);
    void SetDisplay (LPTSTR lpszDisplay);
    void SetAddress (LPTSTR lpszAddress);
};

typedef CAddress *LPADDRESS;

// =================================================================================
// CAddressList
// =================================================================================
typedef CList<CAddress, LPADDRESS> CAddrList;
typedef CAddrList *LPADDRLIST;

// =================================================================================
// Useful functions for Address Lists
// =================================================================================
HRESULT HrAddToAddrList (LPADDRLIST lpal, LPTSTR lpszDisplay, LPTSTR lpszAddress);
HRESULT HrAddrListToDisplay (LPADDRLIST lpal, LPTSTR *lppszDisplay);
HRESULT HrCopyAddrList (LPADDRLIST lpalSrc, LPADDRLIST lpalDest);

#endif   //_IADDRESS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\imaildlg.h ===
#define idcMailProgress         1000
#define idcProgAni              1001
#define idsInetMailMsg1         1002
#define idsInetMailMsg2         1003
#define idlvDetails             1004
#define idbInetMailDetails      1005
#define idcIMProgSplitter       1006
#define idsInetMailError        1007
#define ideInetMailDetails      1009
#define IDS_STATIC              -1
#define idlvUnsetMsgs           1010
#define idsSentStatus           1011
#define idbInetProgHide         1012
#define idbInetProgStop         1013
#define idicoIdle               1014
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\cmdtargt.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     CmdTargt.h
//
//  PURPOSE:    Defines the GUIDs and command ID's for the IOleCommandTarget
//              interfaces defined in this program.
//

// Defines the GUID for the IOleCommandTarget's used by the views
DEFINE_GUID(CGID_View,     0x89292110L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);

// GCID_View Command Target ID's
enum {
    VCMDID_NEWMAIL = 0                  // Creates a new mail message
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\listtemp.h ===
// ===========================================================================================
// CList Template Definition
// ===========================================================================================
#ifndef __LISTTEMP_H
#define __LISTTEMP_H

// ===========================================================================================
// Required Inlcudes
// ===========================================================================================
#include "xpcomm.h"

// ===========================================================================================
// abstract iteration listpos
// ===========================================================================================
struct __LISTPOS { int unused; };
typedef __LISTPOS* LISTPOS;

// ===========================================================================================
// CList Class Template 
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
class CList
{
private:
    ULONG       m_ulRef;

protected:
    // ===========================================================================================
    // Double-linked list NODE
    // ===========================================================================================
    struct CNode
    {
	    CNode    *pNext;
	    CNode    *pPrev;
	    ARG_TYPE  data;
    };

public:
    // ===========================================================================================
    // Create, delete
    // ===========================================================================================
    CList ();
    ~CList ();

    // ===========================================================================================
    // Reference Counts
    // ===========================================================================================
    ULONG AddRef ();
    ULONG Release ();

    // ===========================================================================================
    // Counts
    // ===========================================================================================
    INT GetCount () const;
    BOOL IsEmpty () const;

    // ===========================================================================================
    // Peek at head or tail
    // ===========================================================================================
	ARG_TYPE GetHead ();
	ARG_TYPE GetTail ();

    // ===========================================================================================
    // Adding To
    // ===========================================================================================
	ARG_TYPE AddHead ();
	ARG_TYPE AddTail ();
	void AddHead (ARG_TYPE newData);
	void AddTail (ARG_TYPE newData);

    // ===========================================================================================
    // Deletion
    // ===========================================================================================
	void RemoveHead();
	void RemoveTail();
    void Remove (ARG_TYPE oldData);

    // ===========================================================================================
    // Iteration
    // ===========================================================================================
	LISTPOS GetHeadPosition() const;
	LISTPOS GetTailPosition() const;
   	ARG_TYPE GetNext(LISTPOS& Position);
   	void MoveNext(LISTPOS& Position);
	ARG_TYPE GetPrev(LISTPOS& Position);

    // ===========================================================================================
    // Getting and modifying data
    // ===========================================================================================
	ARG_TYPE GetAt(LISTPOS listpos);
	void SetAt(LISTPOS pos, ARG_TYPE newElement);

    // ===========================================================================================
    // Alloc and free
    // ===========================================================================================
    void RemoveAll ();
    void FreeNode (CNode *pNode);
    CNode *NewNode (CNode* pPrev, CNode* pNext, ARG_TYPE data);

protected:
    INT             m_nCount;
    CNode          *m_pHead;
    CNode          *m_pTail;
};

// ===========================================================================================
// CList::CList
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline CList<TYPE, ARG_TYPE>::CList()
{
    m_ulRef = 0;
	m_nCount = 0;
	m_pHead = m_pTail = NULL;
    AddRef ();
}

// ===========================================================================================
// CList::~CList
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll ();
    Assert (m_nCount == 0);
    DOUT ("CList::destructor - Ref Count=%d", m_ulRef);
	Assert (m_ulRef == 0);
}

// ===========================================================================================
// CList::AddRef
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ULONG CList<TYPE, ARG_TYPE>::AddRef()
{
	++m_ulRef; 								  
    DOUT ("CList::AddRef () Ref Count=%d", m_ulRef);
    return m_ulRef; 						  
}

// ===========================================================================================
// CList::Release
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ULONG CList<TYPE, ARG_TYPE>::Release ()
{
    ULONG ulCount = --m_ulRef;
    DOUT ("CList::Release () Ref Count=%d", ulCount);
    if (!ulCount) 
	{ 
	    delete this; 
	}
    return ulCount;
}

// ===========================================================================================
// CList::GetCount
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline INT CList<TYPE, ARG_TYPE>::GetCount() const
{ 
    return m_nCount; 
}

// ===========================================================================================
// CList::IsEmpty
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
{
    return m_nCount == 0; 
}

// ===========================================================================================
// CList::GetHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetHead()
{ 
    Assert (m_pHead != NULL);
    Assert (m_pHead->data);
    m_pHead->data->AddRef();
    return m_pHead->data; 
}

// ===========================================================================================
// CList::GetTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetTail()
{
    Assert (m_pTail != NULL);
    Assert (m_pTail->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (m_pTail->data);
#endif
    return m_pTail->data; 
}

// ===========================================================================================
// CList::AddHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::AddHead()
{
	CNode* pNewNode = NewNode(NULL, m_pHead, NULL);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pHead != NULL)
		m_pHead->pPrev = pNewNode;
	else
		m_pTail = pNewNode;
	m_pHead = pNewNode;
    pNewNode->data->AddRef();
	return pNewNode->data;
}

// ===========================================================================================
// CList::AddTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::AddTail()
{
	CNode* pNewNode = NewNode(m_pTail, NULL, NULL);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pTail != NULL)
		m_pTail->pNext = pNewNode;
	else
		m_pHead = pNewNode;
	m_pTail = pNewNode;
    pNewNode->data->AddRef();
	return pNewNode->data;
}

// ===========================================================================================
// CList::AddHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newData)
{
	CNode* pNewNode = NewNode(NULL, m_pHead, newData);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pHead != NULL)
		m_pHead->pPrev = pNewNode;
	else
		m_pTail = pNewNode;
	m_pHead = pNewNode;
	return;
}

// ===========================================================================================
// CList::AddTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newData)
{
	CNode* pNewNode = NewNode(m_pTail, NULL, newData);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pTail != NULL)
		m_pTail->pNext = pNewNode;
	else
		m_pHead = pNewNode;
	m_pTail = pNewNode;
	return;
}

// ===========================================================================================
// CList::RemoveHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveHead()
{
	Assert (m_pHead != NULL);
	CNode* pOldNode = m_pHead;
	m_pHead = pOldNode->pNext;
	if (m_pHead != NULL)
		m_pHead->pPrev = NULL;
	else
		m_pTail = NULL;
	FreeNode (pOldNode);
	return;
}

// ===========================================================================================
// CList::RemoveTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveTail()
{
	Assert (m_pHead != NULL);
	CNode* pOldNode = m_pTail;
	m_pTail = pOldNode->pPrev;
	if (m_pTail != NULL)
		m_pTail->pNext = NULL;
	else
		m_pHead = NULL;
	FreeNode(pOldNode);
	return;
}

// ===========================================================================================
// CList::Remove
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::Remove(ARG_TYPE oldData)
{
	CList::CNode *pNext, *pPrev = NULL, *pNode = m_pHead;
    Assert (pNode && oldData && m_nCount > 0);
	for (;;)
    {
        if (!pNode) 
            break;
        pNext = pNode->pNext;
        if (pNode->data == oldData)
        {
            if (pPrev == NULL)
            {
                m_pHead = pNext;
                if (pNext)
                    pNext->pPrev = NULL;
                if (m_pHead == NULL)
                    m_pTail = NULL;
            }

            else
            {
                pPrev->pNext = pNext;
                if (pNext)
                    pNext->pPrev = pPrev;
                else
                    m_pTail = m_pTail->pPrev;
            }

            FreeNode (pNode);
            break;
        }
        pPrev = pNode;
        pNode = pNext;
    }
}

// ===========================================================================================
// CList::GetHeadPosition
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline LISTPOS CList<TYPE, ARG_TYPE>::GetHeadPosition() const
{ 
    return (LISTPOS) m_pHead; 
}

// ===========================================================================================
// CList::GetTailPosition
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline LISTPOS CList<TYPE, ARG_TYPE>::GetTailPosition() const
{ 
    return (LISTPOS) m_pTail; 
}

// ===========================================================================================
// CList::MoveNext
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::MoveNext(LISTPOS& rPosition)
{
    CNode* pNode = (CNode*) rPosition;
    Assert (pNode);
    rPosition = (LISTPOS)pNode->pNext;
}

// ===========================================================================================
// CList::GetNext
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetNext(LISTPOS& rPosition)
{

    CNode* pNode = (CNode*) rPosition;
    Assert (pNode);
    rPosition = (LISTPOS)pNode->pNext;
    Assert (pNode->data);
    pNode->data->AddRef();
    return pNode->data; 
}

// ===========================================================================================
// CList::GetPrev
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetPrev(LISTPOS& rPosition)
{ 
    CNode* pNode = (CNode*) rPosition;
	Assert (pNode);
	rPosition = (LISTPOS) pNode->pPrev;
    Assert (pNode->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (pNode->data);
#endif
	return pNode->data; 
}

// ===========================================================================================
// CList::GetAt non-const
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetAt(LISTPOS listpos)
{ 
    CNode* pNode = (CNode*) listpos;
	Assert (pNode);
    Assert (pNode->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (pNode->data);
#endif
    return pNode->data; 
}

// ===========================================================================================
// CList::SetAt
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(LISTPOS pos, ARG_TYPE newElement)
{ 
    CNode* pNode = (CNode*) pos;
	Assert (pNode);
    SafeRelease (pNode->data);
	pNode->data = newElement; 
    if (pNode->data)
        pNode->data->AddRef();
}

// =================================================================================
// CList::FreeNode
// =================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::FreeNode (CList::CNode *pNode)
{
    // Check Param
    Assert (pNode);

    // Free Address Members
    if (pNode->data)
    {
        ULONG ulCount;
        SafeReleaseCnt (pNode->data, ulCount);
        //AssertSz (ulCount == 0, "Linked list items should have ref counts of zero when freed.");
    }
    
    // Free Node
    SafeMemFree (pNode);

    // Dec Count
	m_nCount--;
	Assert (m_nCount >= 0);
}

// =================================================================================
// CList::RemoveAll
// =================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveAll ()
{
	// destroy elements
	CList::CNode *pNext, *pNode = m_pHead;
	for (;;)
    {
        if (!pNode) break;
        pNext = pNode->pNext;
        FreeNode (pNode);
        pNode = pNext;
    }

	m_nCount = 0;
	m_pHead = m_pTail = NULL;
}

// =================================================================================
// CList::NewNode
// =================================================================================
template<class TYPE, class ARG_TYPE>
#ifdef WIN16
inline
#endif
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext, ARG_TYPE data)
{
    // Locals
    CList::CNode* pNode;

    // Allocate Memory
    MemAlloc ((LPVOID *)&pNode, sizeof (CList::CNode));    
    if (pNode)
    {
        if (data == NULL)
        {
            pNode->data = new TYPE;
        }
        else
        {
            pNode->data = data;
            data->AddRef();
        }
	    pNode->pPrev = pPrev;
	    pNode->pNext = pNext;
	    m_nCount++;
	    Assert (m_nCount > 0);  // make sure we don't overflow
    }

	return pNode;
}

#endif // __LISTTEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\imnglobl.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __IMNGLOBL_H
#define __IMNGLOBL_H

////////////////////////////////////////////////////////////////////////////
//
//  F O R W A R D S
//

#ifdef __cplusplus
class CFontCache;
#endif

interface ISpoolerEngine;
interface IImnAccountManager;
class CSubManager;
interface IMimeAllocator;
class CConnectionManager;

////////////////////////////////////////////////////////////////////////////
//
//  E N U M S , D E F I N E S and such
//

/* Identifiers for the section selected for search criteria Combo Box.  The
   number of different selections is defined by NumInOfTypeCB which is the 
   number of items in the combo box labelled "Of Type:".  The apparently random
   location of this enum is due to merging the tabs code with findwnd.cpp.  Note
   that this enum is critical; the ordering here is used throughout the 
   properties set up - see findwnd.cpp. */
typedef enum {Contact = 0, Message, Task, Appointment, NumInOfTypeCB} OFTYPE;


////////////////////////////////////////////////////////////////////////////
//
//  M A C R O S
//

//#define DllAddRef()     _DllAddRef(__FILE__, __LINE__);
//#define DllRelease()    _DllRelease(__FILE__, __LINE__);

////////////////////////////////////////////////////////////////////////////
//
//  I N L I N E S
//

////////////////////////////////////////////////////////////////////////////
//
//  P R O T O T Y P E S
//

//int _DllAddRef(LPTSTR szFile, int nLine);
//int _DllRelease(LPTSTR szFile, int nLine);

// AddRef and Release for SDI windows. They use DllAddRef depeding on
// platform as explorer causes ExitProcess in some instances
//ULONG SDIAddRef();
//ULONG SDIRelease();

////////////////////////////////////////////////////////////////////////////
//
//  E X T E R N S
//

#ifndef WIN16
extern HINSTANCE            g_hRichEditDll;     // athena.cpp
#endif
extern BOOL                 g_fRunDll;
extern HWND                 g_hwndInit;
extern HWND                 g_hwndDlgFocus;
extern UINT                 g_msgMSWheel;
extern HINSTANCE            g_hSicilyDll;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;
extern IMimeAllocator      *g_pMoleAlloc;
extern IImnAccountManager2 *g_pAcctMan;
// bobn: brianv says we have to take this out...
//extern DWORD                g_dwBrowserFlags;
extern DWORD                g_dwNoteThreadID,
                            g_dwBrowserThreadID;
extern DWORD                g_dwAthenaMode;

////////////////////////////////////////////////////////////////////////////
//
//  Flags for g_dwAthenaMode
//


#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\mpropdlg.h ===
#pragma once

#define idchkSaveCopy                   134
#define idcTagHeaders                   135
#define idcTxtHeaders                   136
#define idbMsgSource                    137
#define idcTxtSource                    143
#define idcTxtRecip                     151
#define idcTxtPriority                  155
#define idcTxtAttachFmt                 156
#define idcAddSignature                 157
#define idcSendCert                     158
#define idcChooseCert                   159
#define idcEncryptContents              160
#define idcChooseAlg                    161
#define idcVerifySig                    162
#define idcAddCert                      163
#define idcStaticDigSign                164
#define idcStaticAlter                  165
#define idcStaticTrust                  166
#define idcStaticCertInc                167
#define idcStaticEncrypt                168
#define idcStaticEncAlg                 169
#define idbSecMsgSource                 170
#define IDC_FOLDER_IMAGE                171
#define IDC_MSGSUBJECT                  172
#define IDC_MSGFROM                     173
#define IDC_TYPE_STATIC                 174
#define IDC_MSGSIZE                     175
#define IDC_MSGSIZE_STATIC              176
#define IDC_ATTACHMENTS_STATIC          177
#define IDC_TYPE                        178
#define IDC_MSGFOLDER                   179
#define IDC_ATTACHMENTS                 181
#define IDC_PRIORITY_STATIC             182
#define IDC_PRIORITY                    183
#define IDC_SENT_STATIC                 184
#define IDC_SENT                        185
#define IDC_RECEIVED_STATIC             186
#define IDC_RECEIVED                    187
#define idcStaticRevoked                188
#define idcStaticRevStatus              189
#define idcSecRecLabel                  190
#define idcRetRecReq                    191
#define idcSecLabelStat                 192
#define idcSecLabelText                 193
#define idcViewEncCert                  194
#define idcStaticRecAlg                 195
#define idcStaticEncCertInc             196
#define idcStaticSecReceipt             197
#define idcViewCerts                    198
#define idcAdvanced                     199
#define idcCertHelp                     200
#define idcStaticEncryptionCert         201
#define idcStaticSigningCert            202
#define idcStaticSendersCert            203
#define idcStaticEncryptAlgorithm       204
#define idcViewEncrytionCert            205
#define idcSendersEncryptionCert        206
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\optdlg.h ===
/*
 *	o p t d l g . h
 *	
 *	Purpose: Contains defines and prototypes shared by mail and news
 *           on the options prop sheet.
 */

#ifndef __OPTDLG_H
#define __OPTDLG_H

#define idbtnPlain                  1043
#define idbtnHTML                   1044
#define idrbPlain                   1045
#define idrbHTML                    1046

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__

STR_GLOBAL(c_szHtml_MetaTagf, "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=%s\">\r\n");

MAKEBSTR(c_bstr_Word,       4,  "Word");
MAKEBSTR(c_bstr_Character,  9,  "Character");
MAKEBSTR(c_bstr_StartToEnd, 10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,   8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12,  "StartToStart");
MAKEBSTR(c_bstr_EndToStart, 10, "EndToStart");

MAKEBSTR(c_bstr_OnNewMail,        9, "onNewMail");
MAKEBSTR(c_bstr_OnAccountChange, 15, "onAccountChange");

#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\ourguid.h ===
/************
**  ATHGUID.H
**      Holds the GUIDs for Athena, including
**  those copied from Ren.
**
**  Author:  t-ErikN  (8/22/95)
*/

#ifndef __ATHGUID_H
#define __ATHGUID_H

#include "imnact.h"
#include <shlguidp.h>

////////////////////////////////////////////////////////////////////////
//
//  Athena CLSID
//
//  every OLE2 object class must have a unique CLSID (class id)
//  ours are: 
//  
//      Athena  {89292101-4755-11cf-9DC2-00AA006C2B84}
//      Mail    {89292102-4755-11cf-9DC2-00AA006C2B84}    
//      News    {89292103-4755-11cf-9DC2-00AA006C2B84}
//
//  you get a CLSID by running the guidgen application in the Win96 PDK
//
////////////////////////////////////////////////////////////////////////

DEFINE_GUID(CLSID_Athena,           0x8929210AL, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(CLSID_AddrObject,       0x56AA9BC0L, 0xAB09, 0x11CE, 0xB8, 0x73, 0x0, 0xAA, 0x0, 0x6E, 0xC3, 0x49);

DEFINE_GUID(IID_IIMAPSvrInfo,       0xdb3ba9f8L, 0xe368, 0x11d0, 0x8d, 0x4c, 0x0, 0xc0, 0x4f, 0xb6, 0xfb, 0xfd);
DEFINE_GUID(IID_IServerInfo,        0x89292104L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IAthenaBrowser,     0x89292105L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IAthenaView,        0x89292106L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IStateInfo,         0xd0d8ed41L, 0x2000, 0x11cf, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x6e, 0xb9, 0xf7);
DEFINE_GUID(IID_IGroupInfo,         0x89292107L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_ITreeViewNotify,    0x89292108L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);

// {6152D280-1283-11d0-A56C-00C04FD61319}
DEFINE_GUID(IID_IBodyObj, 0x6152d280, 0x1283, 0x11d0, 0xa5, 0x6c, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x19);

// {2009013E-98D3-11d1-AF06-00C04FA31B90}
DEFINE_GUID(IID_IBodyObj2, 0x2009013e, 0x98d3, 0x11d1, 0xaf, 0x6, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {44BBA840-CC51-11CF-AAFA-00AA00B6015C}
DEFINE_GUID(CLSID_AthenaSetup, 0x44BBA840L, 0xCC51, 0x11CF, 0xAA, 0xFA, 0x0, 0xAA, 0x0, 0xB6, 0x01, 0x5C);

/////////////////////////////////////////////////////////////////////////////
// Beavis's Thumbnail Extractor

DEFINE_GUID( CLSID_HtmlThumbnailExtractor,
    0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3);

// {BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractImage,          0xbb2e617c, 0x920, 0x11d1, 0x9a, 0xb, 
     0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

/////////////////////////////////////////////////////////////////////////////
// For Splash Screen

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
//DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
//DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

/////////////////////////////////////////////////////////////////////////////
// For Envelope Object CommandTarget
// {EB5E6950-4A58-11d1-82D4-00C04FD9753F}
DEFINE_GUID(IID_IHeader, 0xeb5e6950, 0x4a58, 0x11d1, 0x82, 0xd4, 0x0, 0xc0, 0x4f, 0xd9, 0x75, 0x3f);
// {3B963A20-4A59-11d1-82D4-00C04FD9753F}
DEFINE_GUID(IID_IHeaderSite, 0x3b963a20, 0x4a59, 0x11d1, 0x82, 0xd4, 0x00, 0xc0, 0x4f, 0xd9, 0x75, 0x3f);
// {00067298-0000-0000-C000-000000000046}
/////////////////////////////////////////////////////////////////////////////
// New Columns handler

// {1C714A04-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IColumnInfo, 0x1C714A04, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {1C714A03-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(CLSID_ColumnsDlg, 0x1C714A03, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);


/////////////////////////////////////////////////////////////////////////////
// Message View Interface

// {1C714A05-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IMessageWindow, 0x1C714A05, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {1C714A07-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IViewWindow, 0x1C714A07, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {0A776020-3496-11d2-9F03-0000F8058D9F}
DEFINE_GUID(IID_IViewData, 0xa776020, 0x3496, 0x11d2, 0x9f, 0x3, 0x0, 0x0, 0xf8, 0x5, 0x8d, 0x9f);

// ---------------------------------------------------------------------------------------
// Spooler
// ---------------------------------------------------------------------------------------
// {39419C53-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerEngine, 0x39419c53, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C54-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerBindContext, 0x39419c54, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C57-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CInboxRules, 0x39419c57, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C58-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerTask, 0x39419c58, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C59-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerUI, 0x39419c59, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8452-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreInbox, 0x63bf8452, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8453-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreOutbox, 0x63bf8453, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8454-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreSentItems, 0x63bf8454, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {A2F07CA1-C0EF-11d0-85E9-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreDeleted, 0xa2f07ca1, 0xc0ef, 0x11d0, 0x85, 0xe9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {CE4D0F21-BF13-11d0-85E5-00C04FD85AB4}
DEFINE_GUID(IID_CUidlCache, 0xce4d0f21, 0xbf13, 0x11d0, 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6F023F65-F8B1-11d0-8A35-00C04FB951F3}
DEFINE_GUID(IID_CPop3LogFile, 0x6f023f65, 0xf8b1, 0x11d0, 0x8a, 0x35, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// {6F023F66-F8B1-11d0-8A35-00C04FB951F3}
DEFINE_GUID(IID_CSmtpLogFile, 0x6f023f66, 0xf8b1, 0x11d0, 0x8a, 0x35, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// ---------------------------------------------------------------------------------------
// Connection manager
// ---------------------------------------------------------------------------------------
// {D27E30B3-7AF4-11d0-83B5-00C04FD6131A}
DEFINE_GUID(IID_IConnectionNotify, 0xd27e30b3, 0x7af4, 0x11d0, 0x83, 0xb5, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x1a);

// ---------------------------------------------------------------------------------------
// General Note Guids
// ---------------------------------------------------------------------------------------
// {CAE80521-F685-11d1-AF32-00C04FA31B90}
DEFINE_GUID(CLSID_OENote, 0xcae80521, 0xf685, 0x11d1, 0xaf, 0x32, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {CAE80522-F685-11d1-AF32-00C04FA31B90}
DEFINE_GUID(IID_IOENote, 0xcae80522, 0xf685, 0x11d1, 0xaf, 0x32, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {8446AEC0-FBEA-11d1-AF35-00C04FA31B90}
DEFINE_GUID(IID_IOEMsgSite, 0x8446aec0, 0xfbea, 0x11d1, 0xaf, 0x35, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

//+-------------------------------------------------------------------------
// Private GUIDs
//--------------------------------------------------------------------------
// {663921AF-4D57-11d1-8A95-00C04FB951F3}
DEFINE_GUID(IID_CStoreFolder, 0x663921af, 0x4d57, 0x11d1, 0x8a, 0x95, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// {4DB85D00-AD69-11d1-AA67-006097D474C4}
DEFINE_GUID(IID_IEnumSubscription, 0x4db85d00, 0xad69, 0x11d1, 0xaa, 0x67, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// {4DB85D01-AD69-11d1-AA67-006097D474C4}
DEFINE_GUID(IID_ISubscriptionManager, 0x4db85d01, 0xad69, 0x11d1, 0xaa, 0x67, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// {DC0CCB27-BAB7-11d1-9E7A-0000F8058D9F}
DEFINE_GUID(IID_IDropDownFldrBar, 0xdc0ccb27, 0xbab7, 0x11d1, 0x9e, 0x7a, 0x0, 0x0, 0xf8, 0x5, 0x8d, 0x9f);

// {9D239B0F-0788-11d2-ACE4-00C04F8EC8A5}
DEFINE_GUID(IID_IStatusBar, 0x9d239b0f, 0x788, 0x11d2, 0xac, 0xe4, 0x0, 0xc0, 0x4f, 0x8e, 0xc8, 0xa5);

// {626BAFEC-E5D6-11D1-B1DD-006097D503D9}
DEFINE_GUID(IID_IOERuleAddrList, 0X626BAFEC, 0xE5D6, 0X11D1, 0xB1, 0xDD, 0x0, 0x60, 0x97, 0xD5, 0x03, 0xD9);

// --------------------------------------------------------------------------------
// Spooler GUIDS
// --------------------------------------------------------------------------------
// {92FB68A4-D785-11d0-A0D4-00C04FD6131A}
DEFINE_GUID(IID_ITimeoutCallback, 0x92fb68a4, 0xd785, 0x11d0, 0xa0, 0xd4, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x1a);

// {26E79700-FF05-11d1-AAAE-006097D474C4}
DEFINE_GUID(IID_IGroupListAdvise, 0x26e79700, 0xff05, 0x11d1, 0xaa, 0xae, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// --------------------------------------------------------------------------------
// OneStop GUIDS
// --------------------------------------------------------------------------------
// {D2984AB4-F2DE-11d1-AF07-00C04FA35D02}
DEFINE_GUID(CLSID_OEOneStopHandler, 0xd2984ab4, 0xf2de, 0x11d1, 0xaf, 0x7, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x2);

// HACK - Need to get this from somewhere else!
//{3af36230-a269-11d1-b5bf-0000f8051515}
DEFINE_GUID(CLSID_MobilityFeature,   0x3af36230, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

// {279644D0-0C73-11d2-AF3A-00C04FA31B90}
DEFINE_GUID(CMDSETID_OutlookExpress, 0x279644d0, 0xc73, 0x11d2, 0xaf, 0x3a, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// --------------------------------------------------------------------------------
// BA control 
// --------------------------------------------------------------------------------
// {233A9694-667E-11d1-9DFB-006097D50408}
DEFINE_GUID(CLSID_OEBAControl, 0x233a9694, 0x667e, 0x11d1, 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08);

#endif // include //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\msoedisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#pragma once

// hack - from OLE headers
#define DISPID_VALUE                                ( 0 )
#define DISPID_NEWENUM                              ( -4 )

// hack - from OLE headers

#define DISPID_IOESESSION_BASE                      100
#define DISPID_IOEFOLDERCOLLECTION_BASE             200
#define DISPID_IOEFOLDER_BASE                       300
#define DISPID_IOEMESSAGECOLLECTION_BASE            400
#define DISPID_IOEMESSAGE_BASE                      500
#define DISPID_LISTPROP_BASE                        600
#define DISPID_LIST_BASE                            700
#define DISPID_LISTEVENT_BASE                       800
#define DISPID_IOEMSGLIST_BASE                      900
#define DISPID_IOEACCTWIZ_BASE                      1000

//
// DISPID_IOESESSION_*
//
#define DISPID_IOESESSION_FOLDERS                   (DISPID_IOESESSION_BASE + 1)
#define DISPID_IOESESSION_VERSION                   (DISPID_IOESESSION_BASE + 2)
#define DISPID_IOESESSION_CREATEMESSAGE             (DISPID_IOESESSION_BASE + 3)
#define DISPID_IOESESSION_OPENFOLDER                (DISPID_IOESESSION_BASE + 4)
#define DISPID_IOESESSION_OPENMESSAGE               (DISPID_IOESESSION_BASE + 5)
#define DISPID_IOESESSION_INBOX                     (DISPID_IOESESSION_BASE + 6)
//
// DISPID_IOEMSGLIST_*
//
#define DISPID_IOEMSGLIST_SORTCOL                   (DISPID_IOEMSGLIST_BASE + 1)
#define DISPID_IOEMSGLIST_SORTDIR                   (DISPID_IOEMSGLIST_BASE + 2)
#define DISPID_IOEMSGLIST_TEST                      (DISPID_IOEMSGLIST_BASE + 3)

//
// DISPID_IOEFOLDERCOLLECTION_*
//
#define DISPID_IOEFOLDERCOLLECTION_TOSTRING         DISPID_IOEFOLDERCOLLECTION_BASE+1
#define DISPID_IOEFOLDERCOLLECTION_LENGTH           DISPID_IOEFOLDERCOLLECTION_BASE
#define DISPID_IOEFOLDERCOLLECTION__NEWENUM         DISPID_NEWENUM
#define DISPID_IOEFOLDERCOLLECTION_ITEM             DISPID_VALUE
#define DISPID_IOEFOLDERCOLLECTION_TAGS             DISPID_IOEFOLDERCOLLECTION_BASE+2
#define DISPID_IOEFOLDERCOLLECTION_ADD              DISPID_IOEFOLDERCOLLECTION_BASE+3
#define DISPID_IOEFOLDERCOLLECTION_FOLDERS          DISPID_IOEFOLDERCOLLECTION_BASE+4

//
// DISPID_IOEFOLDER_*
//
#define DISPID_IOEFOLDER_NAME                       (DISPID_IOEFOLDER_BASE + 1)
#define DISPID_IOEFOLDER_PARENT                     (DISPID_IOEFOLDER_BASE + 2)
#define DISPID_IOEFOLDER_SIZE                       (DISPID_IOEFOLDER_BASE + 3)
#define DISPID_IOEFOLDER_ID                         (DISPID_IOEFOLDER_BASE + 4)
#define DISPID_IOEFOLDER_UNREAD                     (DISPID_IOEFOLDER_BASE + 5)
#define DISPID_IOEFOLDER_MESSAGES                   (DISPID_IOEFOLDER_BASE + 6)
#define DISPID_IOEFOLDER_FOLDERS                    (DISPID_IOEFOLDER_BASE + 7)
#define DISPID_IOEFOLDER_COUNT                      (DISPID_IOEFOLDER_BASE + 8)

//
// DISPID_IOEMESSAGECOLLECTION_*
//

#define DISPID_IOEMESSAGECOLLECTION_TOSTRING        (DISPID_IOEMESSAGECOLLECTION_BASE + 1)
#define DISPID_IOEMESSAGECOLLECTION_LENGTH          (DISPID_IOEMESSAGECOLLECTION_BASE + 2)
#define DISPID_IOEMESSAGECOLLECTION__NEWENUM        DISPID_NEWENUM
#define DISPID_IOEMESSAGECOLLECTION_ITEM            DISPID_VALUE
#define DISPID_IOEMESSAGECOLLECTION_TAGS            (DISPID_IOEMESSAGECOLLECTION_BASE + 5)



#define DISPID_IOEMESSAGE_SEND                  (DISPID_IOEMESSAGE_BASE + 1)
#define DISPID_IOEMESSAGE_TO                    (DISPID_IOEMESSAGE_BASE + 2)
#define DISPID_IOEMESSAGE_CC                    (DISPID_IOEMESSAGE_BASE + 3)
#define DISPID_IOEMESSAGE_SENDER                (DISPID_IOEMESSAGE_BASE + 4)
#define DISPID_IOEMESSAGE_SUBJECT               (DISPID_IOEMESSAGE_BASE + 5)
#define DISPID_IOEMESSAGE_TEXT                  (DISPID_IOEMESSAGE_BASE + 6)
#define DISPID_IOEMESSAGE_HTML                  (DISPID_IOEMESSAGE_BASE + 7)
#define DISPID_IOEMESSAGE_URL                   (DISPID_IOEMESSAGE_BASE + 8)
#define DISPID_IOEMESSAGE_DATE                  (DISPID_IOEMESSAGE_BASE + 9)

#define DISPID_IOEACCTWIZ_SET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 1)
#define DISPID_IOEACCTWIZ_GET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 2)
#define DISPID_IOEACCTWIZ_CLEAR_PROPS           (DISPID_IOEACCTWIZ_BASE + 3)
#define DISPID_IOEACCTWIZ_CLOSE                 (DISPID_IOEACCTWIZ_BASE + 4)
#define DISPID_IOEACCTWIZ_NEW_HOTMAIL_ACCOUNT   (DISPID_IOEACCTWIZ_BASE + 5)
#define DISPID_IOEACCTWIZ_WIDTH                 (DISPID_IOEACCTWIZ_BASE + 6)
#define DISPID_IOEACCTWIZ_HEIGHT                (DISPID_IOEACCTWIZ_BASE + 7)
#define DISPID_IOEACCTWIZ_SET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 8)
#define DISPID_IOEACCTWIZ_GET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 9)
#define DISPID_IOEACCTWIZ_NEW_ACCOUNT           (DISPID_IOEACCTWIZ_BASE + 10)
#define DISPID_IOEACCTWIZ_RELOAD                (DISPID_IOEACCTWIZ_BASE + 11)

/////////////////////////////////////////////////////////////////////////////
// IOEMessageList
//

// Properties
#define DISPID_LISTPROP_GROUP_MESSAGES          (DISPID_LISTPROP_BASE + 1)
#define DISPID_LISTPROP_EXPAND_GROUPS           (DISPID_LISTPROP_BASE + 2)
#define DISPID_LISTPROP_SELECT_FIRST_UNREAD     (DISPID_LISTPROP_BASE + 3)
#define DISPID_LISTPROP_COLUMN_SET              (DISPID_LISTPROP_BASE + 4)
#define DISPID_LISTPROP_COUNT                   (DISPID_LISTPROP_BASE + 5)
#define DISPID_LISTPROP_SELECTED_COUNT          (DISPID_LISTPROP_BASE + 6)
#define DISPID_LISTPROP_PREVIEW_SRC             (DISPID_LISTPROP_BASE + 7)
#define DISPID_LISTPROP_FOLDER                  (DISPID_LISTPROP_BASE + 8)
#define DISPID_LISTPROP_MESSAGE_TIPS            (DISPID_LISTPROP_BASE + 9)
#define DISPID_LISTPROP_SCROLL_TIPS             (DISPID_LISTPROP_BASE + 10)
#define DISPID_LISTPROP_UNREAD_COUNT            (DISPID_LISTPROP_BASE + 11)
#define DISPID_LISTPROP_FILTER_MESSAGES         (DISPID_LISTPROP_BASE + 12)
#define DISPID_LISTPROP_SHOW_DELETED            (DISPID_LISTPROP_BASE + 13)
#define DISPID_LISTPROP_SHOW_REPLIES            (DISPID_LISTPROP_BASE + 14)

// Methods
#define DISPID_LIST_SETFOLDER                   (DISPID_LIST_BASE + 1)
#define DISPID_LIST_GET_SELECTED_MESSAGE        (DISPID_LIST_BASE + 2)
#define DISPID_LIST_SET_RECT                    (DISPID_LIST_BASE + 3)
#define DISPID_LIST_GET_RECT                    (DISPID_LIST_BASE + 4)
#define DISPID_LIST_MARK_READ                   (DISPID_LIST_BASE + 5)
#define DISPID_LIST_GET_COLUMN_INFO             (DISPID_LIST_BASE + 6)
#define DISPID_LIST_ON_POPUP_MENU               (DISPID_LIST_BASE + 7)
#define DISPID_LIST_CREATE_LIST                 (DISPID_LIST_BASE + 8)
#define DISPID_LIST_SAVE_STATE                  (DISPID_LIST_BASE + 9)

/////////////////////////////////////////////////////////////////////////////
// _MessageListEvents Dispatch IDs
//

#define DISPID_LISTEVENT_SELECTIONCHANGED       (DISPID_LISTEVENT_BASE + 1)
#define DISPID_LISTEVENT_FOCUSCHANGED           (DISPID_LISTEVENT_BASE + 2)
#define DISPID_LISTEVENT_COUNTCHANGED           (DISPID_LISTEVENT_BASE + 3)
#define DISPID_LISTEVENT_UPDATESTATUS           (DISPID_LISTEVENT_BASE + 4)
#define DISPID_LISTEVENT_UPDATEPROGRESS         (DISPID_LISTEVENT_BASE + 5)
#define DISPID_LISTEVENT_ERROR                  (DISPID_LISTEVENT_BASE + 6)
#define DISPID_LISTEVENT_ITEMACTIVATE           (DISPID_LISTEVENT_BASE + 7)
#define DISPID_LISTEVENT_UPDATECOMMANDSTATE     (DISPID_LISTEVENT_BASE + 8)
#define DISPID_LISTEVENT_ONMESSAGEAVAILABLE     (DISPID_LISTEVENT_BASE + 9)
#define DISPID_LISTEVENT_FILTERCHANGED          (DISPID_LISTEVENT_BASE + 10)
#define DISPID_LISTEVENT_ADURL_AVAILABLE        (DISPID_LISTEVENT_BASE + 11)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\papres.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
// Common Papyrus/OE resource IDs
// Created 12/1/97 by YST


#ifndef __PAPRES_H__
#define __PAPRES_H__

#define RESID_START                     22222

#define IDB_PAPLEFT                     22223
#define IDB_PAPRIGHT                    22224
#define IDC_PAPSMALLICON                22225
#define IDC_PAPLARGEICON                22226
#define IDS_PAPFBARFONT                 22227
#define IDS_PAPFBARTEXT                 22228
#define IDB_PAPFLDL			22229
#define IDB_PAPFLDS			22230


#endif // __PAPRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\rasdlgsp.h ===
#define idbDet                          1000
#define idlbDetails                     1001
#define ideProgress                     1002
#define idcSplitter                     1003
#define idchSavePassword                1004
#define ideUserName                     1005
#define idePassword                     1006
#define idePhone                        1007
#define idbEditConnection               1009
#define idrgUseCurrent                  1010
#define idrgDialNew                     1011
#define idcCurrentMsg                   1012
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\rulesdlg.h ===
//
// rulesdlg.h
//
// contains resource identifiers for the rules dialogs
//

#ifndef __RULESDLG_H_
#define __RULESDLG_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

// For Rules Manager
#define idlvRulesList                   128
#define idtbRulesTab                    129
#define idbNewRule                      130
#define idbDeleteRule                   131
#define idbModifyRule                   132
#define idbMoveUpRule                   133
#define idbMoveDownRule                 134
#define idredtRuleDescription           135
#define idbRuleOptions                  136
#define idbRulesApplyTo                 137
#define idbCopyRule                     138
#define idcRuleTitle                    139
#define idhNewRule                      50700
#define idhModifyRule                   50705
#define idhCopyRule                     50710
#define idhRemoveRule                   50715
#define idhRuleApply                    50720
#define idhRuleUp                       50725
#define idhRuleDown                     50730
#define idhRuleDescription              50735

// For Edit Rule dialog
#define idcRuleDir                      128
#define idlvCriteria                    129
#define idlvActions                     130
#define idredtDescription               131
#define idedtRuleName                   132
#define idhCriteriaView                 50600
#define idhDescriptionView              50605
#define idhViewName                     50610
#define idhCriteriaRule                 50740
#define idhActionsRule                  50745
#define idhDescriptionRule              50750
#define idhRuleName                     50755

// For Rename Rule dialog
#define idedtRenameRule                 128

// For Select Text dialog
#define idedtCriteriaText               128

// For Select Address dialog
#define idedtCriteriaAddr               128
#define idbCriteriaAddr                 129

// For Select Account dialog
#define idcCriteriaAcct                 128

// For Select Color dialog
#define idcCriteriaColor                128

// For Select Size dialog
#define idcCriteriaSize                 128
#define idspnCriteriaSize               129

// For Select Lines dialog
#define idcCriteriaLines                128
#define idspnCriteriaLines              129

// For Select Age dialog
#define idcCriteriaAge                  128
#define idspnCriteriaAge                129

// For Select Show dialog
#define idcCriteriaShow                 128
#define idcCriteriaHide                 129

// For Select Secure dialog
#define idcCriteriaSigned               128
#define idcCriteriaEncrypt              129

// For Select Priority dialog
#define idcCriteriaHighPri              128
#define idcCriteriaLowPri               129

// For Select Thread State dialog
#define idcCriteriaWatchThread          128
#define idcCriteriaIgnoreThread         129

// For Select Logic dialog
#define idcCriteriaAnd                  128
#define idcCriteriaOr                   129

// For Select Flag dialog
#define idcCriteriaFlag                 128
#define idcCriteriaNoFlag               129

// For Select Downloaded dialog
#define idcCriteriaDownloaded           128
#define idcCriteriaNotDownloaded        129

// For Select Read dialog
#define idcCriteriaRead                 128
#define idcCriteriaNotRead              129

// For Select Watch dialog
#define idcActionsWatchThread           128
#define idcActionsIgnoreThread          129

// For Block Senders dialog
#define idbAddSender                    128
#define idbRemoveSender                 129
#define idbModifySender                 130
#define idlvSenderList                  131
#define idcSenderTitle                  132
#define idhAddSender                    50820
#define idhModifySender                 50825
#define idhRemoveSender                 50830

// For Select Sender dialog
#define idedtSender                     128
#define idcBlockMail                    129
#define idcBlockNews                    130
#define idcBlockBoth                    131

// For Junk Mail page
#define idcJunkMail                     128
#define idbExceptions                   130
#define idcJunkSliderIcon               131
#define idcJunkSlider                   133
#define idcJunkSliderMore               134
#define idcJunkSliderLess               135
#define idcJunkDeleteIcon               136
#define idcJunkDelete                   137
#define idedtJunkDelete                 138
#define idcJunkDeleteSpin               139
#define idcJunkDays                     140
#define idcJunkTitle                    141
#define idhJunkMail                     50800
#define idhExceptions                   50805
#define idhJunkSlider                   50810
#define idhJunkDelete                   50815

// For Apply Rules dialog
#define idtbRulesApplyTab               128

// For Apply Mail Rules dialog
#define idlvRulesApplyList              128
#define idredtApplyDescription          129
#define idcRulesApplySubfolder          131
#define idcRulesApply                   132
#define idcApplyFolder                  133
#define idcBrowseApplyFolder            134
#define idcApplyRulesAll                135
#define idcApplyRulesNone               136
#define idhRulesList                    50760
#define idhApplyRulesAll                50765
#define idhApplyRulesNone               50770
#define idhApplyDescription             50775
#define idhApplyFolder                  50780
#define idhApplySubfolder               50785
#define idhBrowseApplyFolder            50790
#define idhApplyNow                     50795

// For Views Manager dialog
#define idlvViewsList                   128
#define idbNewView                      129
#define idbModifyView                   130
#define idbRenameView                   131
#define idbCopyView                     132
#define idbDeleteView                   133
#define idbDefaultView                  134
#define idredtViewDescription           135
#define idhNewView                      50860
#define idhModifyView                   50865
#define idhCopyView                     50870
#define idhRemoveView                   50875
#define idhApplyView                    50880
#define idhViewDescription              50885

// For Exceptions List
#define idcExceptionsWAB                128
#define idlvExceptions                  129
#define idcAddException                 130
#define idcRemoveException              131
#define idcModifyException              132

// For Exception Editor
#define idedtException                  128

// For the multiple criteria editor
#define idcCriteriaEdit                 128
#define idcCriteriaAdd                  129
#define idcCriteriaAddrBook             130
#define idcCriteriaRemove               131
#define idcCriteriaOptions              132
#define idcCriteriaList                 150
#define idcCriteriaContains             151
#define idcCriteriaNotCont              152

// For the Apply View dialog
#define idcViewCurrent                  128
#define idcViewAll                      129

#endif // !__RULESDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\tbcustom.h ===
#ifndef      __TBCUSTOM_H
#define     __TBCUSTOM_H

#define     IDC_SHOWTEXT        110
#define     IDC_SMALLICONS      111

#endif //__TBCUSTOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\syncop.h ===
#ifndef _INC_SYNCOP_H
#define _INC_SYNCOP_H

// {26FE9D30-1A8F-11d2-AABF-006097D474C4}
DEFINE_GUID(CLSID_SyncOpDatabase, 0x26fe9d30, 0x1a8f, 0x11d2, 0xaa, 0xbf, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

//------------------------------------------------------------------
// Types
//------------------------------------------------------------------
DECLARE_HANDLE(SYNCOPID);
typedef SYNCOPID *LPSYNCOPID;

//------------------------------------------------------------------
// SYNCOPID Constants
//------------------------------------------------------------------
const SYNCOPID   SYNCOPID_INVALID = (SYNCOPID)-1;

//------------------------------------------------------------------
// SyncOp Database Version
//------------------------------------------------------------------
const DWORD SYNCOP_DATABASE_VERSION = 2;

//------------------------------------------------------------------
// SYNCOPTABLECOLID
//------------------------------------------------------------------
typedef enum tagSYNCOPTABLECOLID {
    OPCOL_ID = 0,
    OPCOL_SERVER,
    OPCOL_FOLDER,
    OPCOL_MESSAGE,
    OPCOL_OPTYPE,
    OPCOL_FLAGS,
    OPCOL_ADD_FLAGS,
    OPCOL_REMOVE_FLAGS,
    OPCOL_FOLDER_DEST,
    OPCOL_MESSAGE_DEST,
    OPCOL_LASTID
} SYNCOPTABLECOLID;

//------------------------------------------------------------------
// SYNCUSERDATA
//------------------------------------------------------------------
typedef struct tagSYNCOPUSERDATA {
    DWORD               fInitialized;                   // 4   Has this folder been initialized yet
    BYTE                rgReserved[248];                // Reserved
} SYNCOPUSERDATA, *LPSYNCOPUSERDATA;

typedef enum tagSYNCOPTYPE {
    SYNC_INVALID        = 0x0000,
    SYNC_SETPROP_MSG    = 0x0001,
    SYNC_CREATE_MSG     = 0x0002,
    SYNC_COPY_MSG       = 0x0004,
    SYNC_MOVE_MSG       = 0x0008,
    SYNC_DELETE_MSG     = 0x0010
} SYNCOPTYPE;

//------------------------------------------------------------------
// SOF_ sync op flags
//------------------------------------------------------------------
typedef DWORD SYNCOPFLAGS;
#define SOF_ALLFLAGS                 0x00000001

//------------------------------------------------------------------
// SYNCOPINFO
//------------------------------------------------------------------
typedef struct tagSYNCOPINFO {
    BYTE               *pAllocated;
    BYTE                bVersion;
    SYNCOPID            idOperation;
    FOLDERID            idServer;
    FOLDERID            idFolder;
    MESSAGEID           idMessage;
    SYNCOPTYPE          tyOperation;
    SYNCOPFLAGS         dwFlags;
    MESSAGEFLAGS        dwAdd;
    MESSAGEFLAGS        dwRemove;
    FOLDERID            idFolderDest;
    MESSAGEID           idMessageDest;
} SYNCOPINFO, *LPSYNCOPINFO;

//------------------------------------------------------------------
// Operation Record Members
//------------------------------------------------------------------
BEGIN_COLUMN_ARRAY(g_rgOpTblColumns, OPCOL_LASTID)
    DEFINE_COLUMN(OPCOL_ID,             CDT_DWORD,    SYNCOPINFO, idOperation)
    DEFINE_COLUMN(OPCOL_SERVER,         CDT_DWORD,    SYNCOPINFO, idServer)
    DEFINE_COLUMN(OPCOL_FOLDER,         CDT_DWORD,    SYNCOPINFO, idFolder)
    DEFINE_COLUMN(OPCOL_MESSAGE,        CDT_DWORD,    SYNCOPINFO, idMessage)
    DEFINE_COLUMN(OPCOL_OPTYPE,         CDT_WORD,     SYNCOPINFO, tyOperation)
    DEFINE_COLUMN(OPCOL_FLAGS,          CDT_DWORD,    SYNCOPINFO, dwFlags)
    DEFINE_COLUMN(OPCOL_ADD_FLAGS,      CDT_DWORD,    SYNCOPINFO, dwAdd)
    DEFINE_COLUMN(OPCOL_REMOVE_FLAGS,   CDT_DWORD,    SYNCOPINFO, dwRemove)
    DEFINE_COLUMN(OPCOL_FOLDER_DEST,    CDT_DWORD,    SYNCOPINFO, idFolderDest)
    DEFINE_COLUMN(OPCOL_MESSAGE_DEST,   CDT_DWORD,    SYNCOPINFO, idMessageDest)
END_COLUMN_ARRAY

//------------------------------------------------------------------
// g_OpTblPrimaryIndex
//------------------------------------------------------------------
BEGIN_TABLE_INDEX(g_OpTblPrimaryIndex, 1)
    DEFINE_KEY(OPCOL_ID,        0,  0)
END_TABLE_INDEX

BEGIN_TABLE_INDEX(g_OpFolderIdIndex, 3)
    DEFINE_KEY(OPCOL_SERVER,    0,  0)
    DEFINE_KEY(OPCOL_FOLDER,    0,  0)
    DEFINE_KEY(OPCOL_ID,        0,  0)
END_TABLE_INDEX

extern const TABLEINDEX g_OpFolderIdIndex;

//------------------------------------------------------------------
// Operation Record Format
//------------------------------------------------------------------
BEGIN_TABLE_SCHEMA(g_SyncOpTableSchema, CLSID_SyncOpDatabase, SYNCOPINFO)
    SCHEMA_PROPERTY(SYNCOP_DATABASE_VERSION)
    SCHEMA_PROPERTY(TSF_RESETIFBADVERSION)
    SCHEMA_PROPERTY(sizeof(SYNCOPUSERDATA))
    SCHEMA_PROPERTY(offsetof(SYNCOPINFO, idOperation))
    SCHEMA_PROPERTY(OPCOL_LASTID)
    SCHEMA_PROPERTY(g_rgOpTblColumns)
    SCHEMA_PROPERTY(&g_OpTblPrimaryIndex)
    SCHEMA_PROPERTY(NULL)
END_TABLE_SCHEMA

extern const TABLESCHEMA g_SyncOpTableSchema;

#endif // _INC_SYNCOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\strconst.h ===
/*----------------------------------------------------------------------------
    strconst.h
        Non-localizable String constant definitions

 ----------------------------------------------------------------------------*/

//////////////////////////// WARNING: PLEASE READ ///////////////////////////
//
// string values that are no longer used are commented out.
// for reg key strings, the commented out keys should not be reused unless
// we can be totally sure that the key value is being persisted the same
// way as before.  when in doubt, use a different key.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _STRCONST_H
#define _STRCONST_H

#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#define STR_REG_PATH_FLAT           "Software\\Microsoft\\Outlook Express"
#define STR_REG_PATH_ROOT           "Software\\Microsoft\\Outlook Express\\5.0"
#define STR_REG_PATH_ROOT_V1        "Software\\Microsoft\\Internet Mail and News"
#define STR_REG_PATH_IE             "Software\\Microsoft\\Internet Explorer"
#define STR_REG_PATH_EMAIL          "Software\\Microsoft\\Email"
#define STR_REG_PATH_NS             "Software\\Netscape"
#define STR_REG_PATH_CLIENTS        "Software\\Clients"
#define STR_REG_PATH_EXPLORER       STR_REG_WIN_ROOT "\\Explorer"
#define STR_FILE_PATH_MAINEXE       "msimn.exe"
#define STR_REG_PATH_IMN            "Internet Mail and News"
#define STR_REG_WAB_FLAT            "Software\\Microsoft\\WAB"
#define STR_REG_WAB_ROOT            STR_REG_WAB_FLAT "\\5.0"
#define STR_REG_IAM_FLAT            "Software\\Microsoft\\Internet Account Manager"
#define STR_REG_WIN_ROOT            "Software\\Microsoft\\Windows\\CurrentVersion"
#define STR_REG_PATH_POLICY         "Software\\Policies\\Microsoft\\Outlook Express"

STR_GLOBAL(c_szIMN,                 STR_REG_PATH_IMN);
STR_GLOBAL(c_szMOE,                 "Outlook Express");
STR_GLOBAL(c_szOutlook,             "Microsoft Outlook");
STR_GLOBAL(c_szNT,                  "Microsoft(R) Windows NT(TM) Operating System");
STR_GLOBAL(c_szMail,                "mail");
STR_GLOBAL(c_szNews,                "news");
STR_GLOBAL(c_szSigs,                "signatures");
STR_GLOBAL(c_szCLSID,               "CLSID");
STR_GLOBAL(c_szNewsCommand,         "\"%s\\" STR_FILE_PATH_MAINEXE "\" /newsurl:%%1");
STR_GLOBAL(c_szOutNewsCommand,      "\"%s\\" STR_FILE_PATH_MAINEXE "\" /outnews /newsurl:%%1");
STR_GLOBAL(c_szMailCommand,         "\"%s\\" STR_FILE_PATH_MAINEXE "\" /mailurl:%%1");
STR_GLOBAL(c_szIMNMailPath,         "Software\\Microsoft\\" STR_REG_PATH_IMN "\\Mail");
STR_GLOBAL(c_szOutlookHotWizHost,    "Outlook HotWizHost");

STR_GLOBAL(c_szRegRoot,             STR_REG_PATH_ROOT);
STR_GLOBAL(c_szRegFlat,             STR_REG_PATH_FLAT);
STR_GLOBAL(c_szInboxRulesPath,      "\\Mail\\Inbox Rules");
STR_GLOBAL(c_szRegRootSubscribe,    STR_REG_PATH_ROOT "\\News\\Subscribe");

STR_GLOBAL(c_szRegRoot_V1,          STR_REG_PATH_ROOT_V1);
STR_GLOBAL(c_szInboxRulesPath_V1,   STR_REG_PATH_ROOT_V1 "\\Mail\\Inbox Rules");

STR_GLOBAL(c_szEnvHostClientPath,   STR_REG_PATH_CLIENTS "\\EnvelopeHost");

STR_GLOBAL(c_szRegOutNews,          "\\Software\\Microsoft\\Office\\8.0\\Outlook\\General");
STR_GLOBAL(c_szRegOutNewsDefault,   "Outlook Newsreader");
STR_GLOBAL(c_szProtocolPath,        STR_REG_PATH_CLIENTS "\\%s\\%s\\Protocols");

STR_GLOBAL(c_szRegIEWebSearch,      STR_REG_WIN_ROOT "\\Explorer\\FindExtensions\\Static\\WebSearch");
STR_GLOBAL(c_szInstallRoot,         "InstallRoot");
STR_GLOBAL(c_szExchangeSetup,       "Software\\Microsoft\\Exchange\\Setup");
STR_GLOBAL(c_szServices,            "Services");
STR_GLOBAL(c_szMAPIRunOnce,         "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
STR_GLOBAL(c_szMAPIRunOnceEntry,    "OE5_0");
STR_GLOBAL(c_szFixMAPI,             "fixmapi.exe");

// new reg paths (relative to outlook express reg root)
STR_GLOBAL(c_szRegJunkMailOn,       "bhgcc");
STR_GLOBAL(c_szRegRTLRichEditHACK,  "rtlreh");
STR_GLOBAL(c_szRegPathNews,         "News");
STR_GLOBAL(c_szRegPathMail,         "Mail");
STR_GLOBAL(c_szRegPathRSList,       "Recent Stationery List");
STR_GLOBAL(c_szRegPathRSWideList,   "Recent Stationery Wide List");
STR_GLOBAL(c_szRegPathColumns,      "Columns");
STR_GLOBAL(c_szRegPathDontShowDlgs, "Dont Show Dialogs");
STR_GLOBAL(c_szRegPathIMAP,         "IMAP");
STR_GLOBAL(c_szRegPathHTTP,         "HTTP");
STR_GLOBAL(c_szRegPathInboxRules,   "Mail\\Inbox Rules");
STR_GLOBAL(c_szRegPathGroupFilters, "News\\Group Filters");
STR_GLOBAL(c_szRegPathSmartLog,     "SmartLog");

STR_GLOBAL(c_szRegPathNoteMail,     "MailNote");
STR_GLOBAL(c_szRegPathNoteNews,     "NewNote");


STR_GLOBAL(c_szRegOpen,             "\\shell\\open\\command");

STR_GLOBAL(c_szRegPathClients,      "Software\\Clients");
STR_GLOBAL(c_szRegPathSpecificClient,"Software\\Clients\\%s\\%s");

STR_GLOBAL(c_szAppPaths,            STR_REG_WIN_ROOT "\\App Paths");
STR_GLOBAL(c_szRegPath,             "Path");
STR_GLOBAL(c_szMainExe,             STR_FILE_PATH_MAINEXE);
STR_GLOBAL(c_szReadme,              "readme.txt");
STR_GLOBAL(c_szIexploreExe,         "iexplore.exe");

STR_GLOBAL(c_szWabRoot,             STR_REG_WAB_FLAT);
STR_GLOBAL(c_szWabFileName,         STR_REG_WAB_FLAT "\\WAB4\\Wab File Name");
STR_GLOBAL(c_szRoamingHive,         "Outlook_Express_Roaming");

STR_GLOBAL(c_szRegFolders,          STR_REG_WIN_ROOT "\\Explorer\\Shell Folders");
STR_GLOBAL(c_szValueAppData,        "AppData");
STR_GLOBAL(c_szValueVersion,        "Version");

STR_GLOBAL(c_szRegStoreRootDir,     "Store Root");
STR_GLOBAL(c_szRegStoreRootDir_V1,  "Store Root v1.0");
STR_GLOBAL(c_szRegDllPath,          "DLLPath");
STR_GLOBAL(c_szMSIMN,               "MSIMN");
STR_GLOBAL(c_szRegRegressStore,     "Regress Store");
STR_GLOBAL(c_szStoreMigratedToOE5,  "StoreMigratedV5");
STR_GLOBAL(c_szConvertedToDBX,      "ConvertedToDBX");
STR_GLOBAL(c_szNewStoreDir,         "New Store Folder");
STR_GLOBAL(c_szMoveStore,           "MoveStore");

STR_GLOBAL(c_szRegDisableHotmail,   "Disable Hotmail");
STR_GLOBAL(c_szRegValNoModifyAccts, "No modify accts");

// Secret key for another user agent
STR_GLOBAL(c_szAgent,   "User String");

// Prefixes for URLs
STR_GLOBAL(c_szURLNews,             "news");
STR_GLOBAL(c_szURLNNTP,             "nntp");
STR_GLOBAL(c_szURLSnews,            "snews");
STR_GLOBAL(c_szURLMailTo,           "mailto");
STR_GLOBAL(c_szURLNetNews,          "netnews");

#define c_szRegNewsURL              c_szURLNews
#define c_szRegNNTPURL              c_szURLNNTP
#define c_szRegMailtoURL            c_szURLMailTo

STR_GLOBAL(c_szPathFileFmt,         "%s\\%s");
STR_GLOBAL(c_szFoldersFile,         "Folders.dbx");
STR_GLOBAL(c_szPop3UidlFile,        "Pop3uidl.dbx");
STR_GLOBAL(c_szOfflineFile,         "Offline.dbx");

// Stationery
STR_GLOBAL(c_szRegStationery,           "SOFTWARE\\Microsoft\\Shared Tools\\Stationery");
STR_GLOBAL_WIDE(c_wszNotepad,           "Notepad.exe");
STR_GLOBAL_WIDE(c_wszValueStationery,   "Stationery Folder");

STR_GLOBAL(c_szRegDefSig,           "Default Signature");
STR_GLOBAL(c_szSigName,             "name");
STR_GLOBAL(c_szSigType,             "type");
STR_GLOBAL(c_szSigText,             "text");
STR_GLOBAL(c_szSigFile,             "file");

// general purpose string constants
STR_GLOBAL(g_szEllipsis,            "...");
STR_GLOBAL(g_szSpace,               " ");
STR_GLOBAL(g_szNewline,             "\n");
STR_GLOBAL(g_szCRLF,                "\r\n");
STR_GLOBAL(g_szCRLF2,               "\r\n\r\n");
STR_GLOBAL(g_szComma,               ",");
STR_GLOBAL(g_szAsterisk,            "*");
STR_GLOBAL(g_szPercent,             "%");
STR_GLOBAL(g_szCurrentDir,          ".");
STR_GLOBAL(g_szParentDir,           "..");
STR_GLOBAL(c_szYes,                 "yes");
STR_GLOBAL(c_szEmpty,               "");
STR_GLOBAL(g_szBackSlash,           "\\");
STR_GLOBAL(g_szQuote,               "\'");
STR_GLOBAL(g_szCommaSpace,          ", ");
STR_GLOBAL(c_szSpaceDashSpace,      " - ");
STR_GLOBAL(c_szDelimiters,          " ,\t;");
STR_GLOBAL(c_szOETopLevel,          "OETLWindow");
STR_GLOBAL(c_szSemiColonSpace,      "; ");
STR_GLOBAL(c_szAt,                  "@");
STR_GLOBAL_WIDE(c_wszEmpty,         "");
STR_GLOBAL_WIDE(g_wszComma,         ",");
STR_GLOBAL_WIDE(g_wszSpace,         " ");
STR_GLOBAL_WIDE(g_wszCRLF,          "\r\n");

//
// registry stuff:
//
STR_GLOBAL(CFSTR_HTML,              "Microsoft Outlook Express HTML Format");
STR_GLOBAL(CFSTR_INETMSG,           "Internet Message (rfc822/rfc1522)");
STR_GLOBAL(CFSTR_ATHENAMAILMESSAGES,"Athena Mail Messages");
STR_GLOBAL(CFSTR_ATHENAMAILFOLDERS, "Athena Mail Folders");
STR_GLOBAL(CFSTR_ATHENAIMAPMESSAGES,"Athena IMAP Messages");
STR_GLOBAL(CFSTR_ATHENACACHEMESSAGES, "Athena Cached Messages");
STR_GLOBAL(CFSTR_OEFOLDER,          "Outlook Express Folder");
STR_GLOBAL(CFSTR_OEMESSAGES,        "Outlook Express Messages");
STR_GLOBAL(CFSTR_OESHORTCUT,        "Outlook Express Shortcut");

// reg keys

STR_GLOBAL(c_szTrident,             "\\Trident");
STR_GLOBAL(c_szTridentIntl,         "\\Trident\\International");
STR_GLOBAL(c_szRegTrident,          STR_REG_PATH_ROOT "\\Trident");               
STR_GLOBAL(c_szRegInternational,    STR_REG_PATH_ROOT "\\Trident\\International");
STR_GLOBAL(c_szRegTriSettings,      STR_REG_PATH_ROOT "\\Trident\\Settings");
STR_GLOBAL(c_szRegTriMain,          STR_REG_PATH_ROOT "\\Trident\\Main");

STR_GLOBAL(c_szRegClientPath,       "shell\\open\\command");
STR_GLOBAL(c_szRegStartPageKey,     "Software\\Microsoft\\Internet Explorer\\Main");
STR_GLOBAL(c_szRegStartPage,        "Start Page");
STR_GLOBAL(c_szRegSmapiDefault,     "SMapi");

STR_GLOBAL(c_szInetAcctMgrRegKey,   STR_REG_IAM_FLAT);

STR_GLOBAL(c_szHTTPMailServiceRoot, "Software\\Microsoft\\Internet Domains");
STR_GLOBAL(c_szHTTPMailEnabled,     "HTTP Mail Enabled");
STR_GLOBAL(c_szHTTPMailServer,      "HTTP Mail Server");
STR_GLOBAL(c_szHTTPMailServiceName, "Friendly Name");
STR_GLOBAL(c_szHTTPMailSignUp,      "SignUp URL");
STR_GLOBAL(c_szHTTPMailConfig,      "Config URL");
STR_GLOBAL(c_szHTTPMailAcctNumber,  "Account Number");
STR_GLOBAL(c_szHTTPMailDomainMSN,   "MSN.COM");
STR_GLOBAL(c_szHTTPMailUseWizard,   "UseWizard");

// reg values
STR_GLOBAL(c_szRegValIMNFontSize,   "IMNFontSize");

// URL Substitution strings
STR_GLOBAL(c_szUrlSubPRD,           "OutlookExpress");
STR_GLOBAL(c_szUrlSubPVER,          "6.0");

// Group Fitlers and Inbox Rules Values
STR_GLOBAL(c_szRulesConfigDirty,    "RulesConfigDirty");
STR_GLOBAL(c_szDisabled,            "Disabled");
STR_GLOBAL(c_szCC,                  "CC");
STR_GLOBAL(c_szTo,                  "To");
STR_GLOBAL(c_szFrom,                "From");
STR_GLOBAL(c_szSubject,             "Subject");
STR_GLOBAL(c_szActionV1,            "Action");
STR_GLOBAL(c_szActions,             "Actions");
STR_GLOBAL(c_szFolderV1,            "Folder");
#ifdef DEBUG
STR_GLOBAL(c_szMoveV1,              "Move");
#endif
STR_GLOBAL(c_szMoveToFolder,        "Move To Folder");
STR_GLOBAL(c_szMoveToHfolder,       "Move To Handle");
STR_GLOBAL(c_szCopyToFolder,        "Copy To Folder");
STR_GLOBAL(c_szCopyToHfolder,       "Copy To Handle");
STR_GLOBAL(c_szFilterOnSize,        "Filter On Size");
STR_GLOBAL(c_szFilterByAccount,     "Filter By Account");
STR_GLOBAL(c_szFilterSize,          "Size");
STR_GLOBAL(c_szFilterAllMessages,   "All Messages");
STR_GLOBAL(c_szForwardTo,           "Forward To");
STR_GLOBAL(c_szReplyWithFile,       "Reply With File");
STR_GLOBAL(c_szFilterOnDate,        "Filter On Date");
STR_GLOBAL(c_szFilterDays,          "Days");
STR_GLOBAL(c_szFilterServer,        "Server");
STR_GLOBAL(c_szFilterGroup,         "Group");
STR_GLOBAL(c_szDisabledReason,      "Disabled Reason");

// common values
//
STR_GLOBAL(c_szMarkPreviewAsRead,   "MarkPreviewAsRead");               // OPT_MARKASREAD
STR_GLOBAL(c_szRegIndentChar,       "Indent Char");                     // OPT_INDENT
STR_GLOBAL(c_szRegAlwaysSuggest,    "SpellDontAlwaysSuggest");          // OPT_SPELLALWAYSSUGGEST
STR_GLOBAL(c_szRegCheckOnSend,      "SpellCheckOnSend");                // OPT_SPELLCHECKONSEND
STR_GLOBAL(c_szRegCheckOnType,      "SpellCheckOnType");                // OPT_SPELLCHECKONTYPE
STR_GLOBAL(c_szRegIgnoreUpper,      "SpellIgnoreUpper");                // OPT_SPELLIGNOREUPPER
STR_GLOBAL(c_szRegIgnoreDBCS,       "SpellDontIgnoreDBCS");             // OPT_SPELLIGNOREDBCS
STR_GLOBAL(c_szRegIgnoreNumbers,    "SpellIgnoreNumbers");              // OPT_SPELLIGNORENUMBER
STR_GLOBAL(c_szRegIgnoreProtect,    "SpellDontIgnoreProtect");          // OPT_SPELLIGNOREPROTECT
STR_GLOBAL(c_szRegIgnoreURL,        "SpellIgnoreURLs");
STR_GLOBAL(c_szRegDigSign,          "Digitally Sign Messages");         // OPT_*_DIGSIGNMESSAGES
STR_GLOBAL(c_szRegEncrypt,          "Encrypt Messages");                // OPT_*_ENCRYPTMESSAGES

#ifdef SMIME_V3
STR_GLOBAL(c_szRegUseLabels,        "Security Label");                  // OPT_USE_LABELS
STR_GLOBAL(c_szRegPolSize,          "Policy size");                     // OPT_POLICYNAME_SIZE
STR_GLOBAL(c_szRegPolData,          "Policy data");                     // OPT_POLICYNAME_DATA
STR_GLOBAL(c_szRegHasClass,         "Classifications");                 // OPT_HAS_CLASSIFICAT
STR_GLOBAL(c_szRegClassData,        "Classifications data");            // OPT_CLASSIFICAT_DATA
STR_GLOBAL(c_szRegPrivSize,         "PrivacyMark size");                // OPT_PRIVACYMARK_SIZE
STR_GLOBAL(c_szRegPrivData,         "PrivacyMark data");                // OPT_PRIVACYMARK_DATA
STR_GLOBAL(c_szRegCategize,         "Category size");                   // OPT_CATEGORY_SIZE
STR_GLOBAL(c_szRegCategData,        "Category data");                   // OPT_CATEGORY_DATA
STR_GLOBAL(c_szRegUseSecRec,        "Security Receipts");               // OPT_SECREC_USE
STR_GLOBAL(c_szRegVerifySecRec,     "Verify Security Receipt");         // OPT_SECREC_VERIFY
STR_GLOBAL(c_szSendSecMDN,          "Send Security Receipt");           // OPT_MDN_SEC_RECEIPT
STR_GLOBAL(c_szRegEncryptSecRec,    "Encrypt Security Receipt");        // OPT_SECREC_ENCRYPT
#endif // SMIME_V3

STR_GLOBAL(c_szRegIncludeCert,      "Include Certificate");             // OPT_*_INCLUDECERT
STR_GLOBAL(c_szRegDefEncryptSymcaps, "Encryption SymCaps");             // OPT_MAIL_DEFENCRYPTSYMCAPS
STR_GLOBAL(c_szRegDialupConnection, "StartConnection");                 // OPT_DIALUP_CONNECTION
STR_GLOBAL(c_szRegWarnSwitch,       "SwitchConnectionPrompt");          // OPT_DIALUP_WARN_SWITCH
STR_GLOBAL(c_szRegHangupDone,       "Hangup After Spool");              // OPT_DIALUP_HANGUP_DONE
STR_GLOBAL(c_szRegDialupLastStart,  "Last Startup Connection");         // OPT_DIALUP_LAST_SART
STR_GLOBAL(c_szRegDefaultConnection, "InternetProfile");                // OPT_DEFAULT_CONNECTION
STR_GLOBAL(c_szRegLaunchInbox,      "Launch Inbox");                    // OPT_LAUNCH_INBOX
//STR_GLOBAL(c_szRegSmallIconsPath,   STR_REG_PATH_EXPLORER "\\SmallIcons");
STR_GLOBAL(c_szRegSmallIconsValue,  "SmallIcons");
STR_GLOBAL(c_szRegSmtpUseIpForHelo, "UseIPForSMTPHELO");                // OPT_SMTPUSEIPFORHELO
STR_GLOBAL(c_szRegExpandUnread,     "Expand Unread");                   // OPT_EXPAND_UNREAD
STR_GLOBAL(c_szRegHangupNoDial,     "Hangup Without Dial 5.0");         // OPT_DIALUP_HANGUP_WITHOUT_DIAL
STR_GLOBAL(c_szRegBodyBarPath,      "BodyBarPath");
STR_GLOBAL(c_szFrontPagePath,       "FrontPagePath");
STR_GLOBAL(c_szRegHelpUrl,          "HelpUrl");
STR_GLOBAL(c_szShowEnvelopes,       "ShowEnvHosts");
STR_GLOBAL(c_szShowBcc,             "ShowBcc");
STR_GLOBAL(c_szSourceEditColoring,  "Show Source Edit Color");
STR_GLOBAL(c_szDefConnPath,         "RemoteAccess");
STR_GLOBAL(c_szEnableAutoDialPath,  STR_REG_WIN_ROOT "\\Internet Settings");
STR_GLOBAL(c_RegKeyEnableAutoDial,  "EnableAutodial");
STR_GLOBAL(c_szRegCheckedAccounts,  "Accounts Checked");

STR_GLOBAL(c_szIncompleteMailAcct,  "Incomplete Mail");
STR_GLOBAL(c_szIncompleteNewsAcct,  "Incomplete News");
STR_GLOBAL(c_szEnableHTTPMail,      "HTTP Mail Enabled");

// IE Link Color
STR_GLOBAL(c_szIESettingsPath,      STR_REG_PATH_IE "\\Settings");
STR_GLOBAL(c_szLinkColorIE,         "Anchor Color");
STR_GLOBAL(c_szLinkVisitedColorIE,  "Anchor Color Visited");

// NS Link Color
STR_GLOBAL(c_szNSSettingsPath,      STR_REG_PATH_NS "\\Netscape Navigator\\Settings");
STR_GLOBAL(c_szLinkColorNS,         "Link Color");
STR_GLOBAL(c_szLinkVisitedColorNS,  "Followed Link Color");

// shared keys
STR_GLOBAL(c_szRasConnDetails,      "RAS Connection Details"); // OPT_RASCONNDETAILS
STR_GLOBAL(c_szRegIncludeMsg,       "Include Reply Msg"); // OPT_INCLUDEMSG, OPT_INCLUDEARTICLE
STR_GLOBAL(c_szOptnSaveInSentItems, "SaveInSentItems"); // OPT_SAVESENTITEMS, OPT_SAVESENTARTICLES
STR_GLOBAL(c_szRegShowHybrid,       "ShowHybridView");  // OPT_MAILHYBRIDVIEW, OPT_NEWSHYBRIDVIEW
STR_GLOBAL(c_szRegShowBtnBar,       "ShowButtonBar");   // OPT_MAILSHOWBTNBAR, OPT_NEWSSHOWBTNBAR
STR_GLOBAL(c_szRegNotePos,          "NotePos");         // OPT_MAILNOTEPOS, OPT_NEWSNOTEPOS
STR_GLOBAL(c_szRegNotePosEx,        "NotePosEx");       // OPT_MAILNOTEPOSEX
STR_GLOBAL(c_szRegSplitHorzPct,     "SplitHorzPct");    // OPT_MAILCYSPLIT, OPT_NEWSCYSPLIT
STR_GLOBAL(c_szRegSplitVertPct,     "SplitVertPct");    // OPT_MAILCXSPLIT, OPT_NEWSCXSPLIT
STR_GLOBAL(c_szRegSplitDir,         "SplitDir");        // OPT_MAILSPLITDIR, OPT_NEWSSPLITDIR
STR_GLOBAL(c_szShowFormatBar,       "ShowFormatBar");   // OPT_SHOWFMTBAR
STR_GLOBAL(c_szShowToolbar,         "ShowToolBar");     // OPT_SHOWTOOLBAR
STR_GLOBAL(c_szShowStatusbar,       "ShowStatusBar");   // OPT_SHOWSTATUSBAR
STR_GLOBAL(c_szAttachViewStyle,     "AttachViewStyle"); // OPT_ATTACH_VIEW_STYLE
STR_GLOBAL(c_szRegSigType,          "Signature Type");  // OPT_MAILSIGTYPE, OPT_NEWSSIGTYPE
STR_GLOBAL(c_szRegSigText,          "Signature Text");  // OPT_MAILSIGTEXT, OPT_NEWSSIGTEXT
STR_GLOBAL(c_szRegSigFile,          "Signature File");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegAttachVCard,      "Attach VCard");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegVCardName,        "VCard Display Name");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegSendInlineImages, "Send Pictures With Document"); //OPT_MAIL_SENDINLINEIMAGES, OPT_NEWS_SENDINLINEIMAGES
STR_GLOBAL(c_szRegCoolbarLayout,    "Layout");
STR_GLOBAL(c_szRegToolbar,          "Saved Toolbar Settings");        // changed from Tools to reset
STR_GLOBAL(c_szRegToolbarText,      "Toolbar Text");
STR_GLOBAL(c_szRegToolbarIconSize,   "Toolbar Icon Size");
STR_GLOBAL(c_szRegMailReadToolbar,  "Read Mail Toolbar Settings");
STR_GLOBAL(c_szRegMailSendToolbar,  "Send Mail Toolbar Settings");
STR_GLOBAL(c_szRegNewsReadToolbar,  "Read News Toolbar Settings");
STR_GLOBAL(c_szRegNewsSendToolbar,  "Read Mail Toolbar Settings");

STR_GLOBAL(c_szRegToolbarVersion,   "Saved Toolbar Settings Version");
STR_GLOBAL(c_szShowToolbarIEAK,     "ShowToolbarIEAK");     //Bug# 67503
STR_GLOBAL(c_szShowTree,            "Tree");     // changed from ShowTree to reset
STR_GLOBAL(c_szShowBodyBar,         "ShowBodyBar");
STR_GLOBAL(c_szBodyBarPos,          "BodyBarPos");
STR_GLOBAL(c_szRegExpungeFolder,    "ExpungeFolders");
STR_GLOBAL(c_szRegHideFolderBar,    "HideFolderBar");
STR_GLOBAL(c_szShowStatus,          "ShowStatus");
STR_GLOBAL(c_szTreeWidth,           "TreeWidth");
STR_GLOBAL(c_szBrowserPos,          "BrowserPos");
STR_GLOBAL(c_szRegSpoolerDlgPos,    "SpoolerDlgPos");   // OPT_SPOOLERDLGPOS
STR_GLOBAL(c_szRegSpoolerTack,      "SpoolerTack");     // OPT_SPOOLERTACK
STR_GLOBAL(c_szRegAutoImageInline,  "Automatically Inline Images");  // OPT_AUTO_IMAGE_INLINE
STR_GLOBAL(c_szRegReplyInOrigFmt,   "Reply To Messages In Original Format");
STR_GLOBAL(c_szRegFontColor,        "Font Color");
STR_GLOBAL(c_szRegFontFace,         "Font Name");
STR_GLOBAL(c_szRegFontSize,         "Font Size");
STR_GLOBAL(c_szRegFontUnderline,    "Font Underline");
STR_GLOBAL(c_szRegFontBold,         "Font Bold");
STR_GLOBAL(c_szRegFontItalic,       "Font Italic");
STR_GLOBAL(c_szRegUseStationery,    "Compose Use Stationery");
STR_GLOBAL(c_szRegStationeryName,   "Stationery Name");
STR_GLOBAL(c_szRegStationeryNameW,  "Wide Stationery Name");
STR_GLOBAL(c_szRegStatNameConverted,"Stationery Name Converted");
STR_GLOBAL(c_szRegIndentReply,      "Indent Reply Text");
STR_GLOBAL(c_szRegHardCodedHdrs,    "Use US Reply Headers");
STR_GLOBAL(c_szRegRtlMsgDir,        "Use RTL Direction");
STR_GLOBAL(c_szIncDefEncode,        "Encode incoming messages");
STR_GLOBAL(c_szRegDialDuringPoll,   "Dial During Poll");            // OPT_DIAL_DURING_POLL
STR_GLOBAL(c_szRegUseAutoComplete,  "Use AutoComplete");
STR_GLOBAL(c_szLastMsg,             "Preview Message");             // OPT_LAST_MESSAGE
STR_GLOBAL(c_szFindPos,             "FindPos");                     // OPT_FINDER_POS
STR_GLOBAL(c_szTestMode,            "TestMode");                    // OPT_TEST_MODE
STR_GLOBAL(c_szDumpFile,            "DumpFile");                    // OPT_DUMP_FILE
STR_GLOBAL(c_szNoSplash,            "NoSplash");                    // OPT_NO_SPLASH
STR_GLOBAL(c_szSigFlags,            "Signature Flags");             // OPT_SIGNATURE_FLAGS
STR_GLOBAL(c_szDefaultCodePage,     "Default_CodePage");
STR_GLOBAL(c_szDefaultEncoding,     "Default_InternetEncoding");
STR_GLOBAL(c_szNoPreview,           "No preview");                  //OPT_NOPREVIEW
STR_GLOBAL(c_szSaveAttachPath,      "Save Attachment Path");
STR_GLOBAL(c_szRegMsgListTips,      "Message List Tips");           // OPT_MESSAGE_LIST_TIPS
STR_GLOBAL(c_szRegSecReadPlainText, "Read in Plain Text only");    // OPT_READ_IN_TEXT_ONLY
STR_GLOBAL(c_szHideMessenger,       "Hide Messenger");
STR_GLOBAL(c_szRegAppSend,          "Warn on Mapi Send");           // OPT_SECURITY_MAPI_SEND
STR_GLOBAL(c_szRegAppSendLocked,    "Warn on Mapi Send Locked");           // OPT_SECURITY_MAPI_SEND_LOCKED
STR_GLOBAL(c_szRegSafeAttachments,  "Safe Attachments");            // OPT_SECURITY_ATTACHMENT
STR_GLOBAL(c_szRegSafeAttachmentsLocked, "Safe Attachments Locked");       // OPT_SECURITY_ATTACHMENT_LOCKED

// mail values
STR_GLOBAL(c_szOptNewMailSound,     "PlaySoundOnNewMail"); // OPT_NEWMAILSOUND
STR_GLOBAL(c_szPurgeWaste,          "Delete Wastebasket On Exit"); // OPT_PURGEWASTE
STR_GLOBAL(c_szRegPollForMail,      "Poll For Mail");   // OPT_POLLFORMAIL
STR_GLOBAL(c_szNeedWelcomeMsg,      "Welcome Message"); // OPT_NEEDWELCOMEMSG
STR_GLOBAL(c_szMailShowHeaderInfo,  "Show Header Info"); // OPT_MAILSHOWHEADERINFO
STR_GLOBAL(c_szRegMailEmptySubj,    "Mail Empty Subject Warning");
STR_GLOBAL(c_szRegNewsEmptySubj,    "News Empty Subject Warning");
STR_GLOBAL(c_szAutoAddToWABOnReply,  "Auto Add Replies To WAB");
STR_GLOBAL(c_szMigrationPerformed,  "Migration Done");
STR_GLOBAL(c_szDSDigSigHelp,        "Digital Signature Help");
STR_GLOBAL(c_szDSEncryptHelp,       "Encryption Help");
STR_GLOBAL(c_szOpaqueSigning,       "Opaque Signing");
STR_GLOBAL(c_szRevokeCheck,         "Revocation checking");
STR_GLOBAL(c_szShowDeleted,         "Show Deleted Messages");
STR_GLOBAL(c_szShowReplies,         "Show Replies To My Messages");
STR_GLOBAL(c_szAutoAddSendersCertToWAB, "Auto Add Senders Cert To WAB");
STR_GLOBAL(c_szViewSrcTabs,         "Show Source Editing");
STR_GLOBAL(c_szEncryptWarnBits,     "Encryption Warning Bits");      // OPT_MAIL_ENCRYPT_WARN_BITS
STR_GLOBAL(c_szSenderName,          "Sender Name");
STR_GLOBAL(c_szDefMailAccount,      "Default Mail Account");
STR_GLOBAL(c_szSMTPDispName,        "SMTP Display Name");

STR_GLOBAL(c_szDontEncryptForSelf,  "Dont Encrypt For Self");
STR_GLOBAL(c_szWindowTitle,         "WindowTitle");             // for branding
STR_GLOBAL(c_szWelcomeHtm,          "WelcomeHtmFile");          // for branding
STR_GLOBAL(c_szWelcomeName,         "WelcomeName");             // for branding
STR_GLOBAL(c_szWelcomeEmail,        "WelcomeEmail");            // for branding

// news values
STR_GLOBAL(c_szCacheDelMsgDays,     "Cache Delete Message Days"); // OPT_CACHEDELETEMSGS
STR_GLOBAL(c_szCacheRead,           "Cache Read Messages"); // OPT_CACHEREAD
STR_GLOBAL(c_szCacheCompactPer,     "Cache Compact Percent"); // OPT_CACHECOMPACTPER
STR_GLOBAL(c_szRegDownload,         "Download at a time"); // OPT_DOWNLOADCHUNKS
STR_GLOBAL(c_szRegAutoExpand,       "Auto Expand Threads"); // OPT_AUTOEXPAND
STR_GLOBAL(c_szRegNotifyNewGroups,  "New group notification"); // OPT_NOTIFYGROUPS
STR_GLOBAL(c_szRegMarkAllRead,      "Mark Read on Exit"); // OPT_MARKALLREAD
STR_GLOBAL(c_szRegViewFiltering,    "News Filter");
STR_GLOBAL(c_szRegLocalFilter,      "Mail Filter");
STR_GLOBAL(c_szRegFindFilter,       "Find Filter");
STR_GLOBAL(c_szRegIMAPFilter,       "IMAP Filter");
STR_GLOBAL(c_szRegThreadArticles,   "ThreadArticles");
STR_GLOBAL(c_szRegFindThread,       "FindThread");
STR_GLOBAL(c_szRegNewsDlgPos,       "News Dialog Position");
STR_GLOBAL(c_szRegNewsDlgColumns,   "News Dialog Columns");
STR_GLOBAL(c_szNewsShowHeaderInfo,  "Show Header Info"); // OPT_NEWSSHOWHEADERINFO
STR_GLOBAL(c_szRegNewsNoteAdvRead,  "Show Advanced Read");
STR_GLOBAL(c_szRegNewsNoteAdvSend,  "Show Advanced Send");
STR_GLOBAL(c_szRegMailNoteAdvRead,  "Show Adv Mail Read");
STR_GLOBAL(c_szRegMailNoteAdvSend,  "Show Adv Mail Send");
STR_GLOBAL(c_szRegNewsModerator,    "Moderator");
STR_GLOBAL(c_szRegNewsControlHeader,"Controller");
STR_GLOBAL(c_szRegNewsFillPreview,  "Auto Fill Preview");
STR_GLOBAL(c_szRegMailColsIn,       "Mail Column Info (In)");
STR_GLOBAL(c_szRegMailColsOut,      "Mail Column Info (Out)");
STR_GLOBAL(c_szRegNewsCols,         "News Column Info");
STR_GLOBAL(c_szRegFindPopCols,      "Find Pop Column Info");
STR_GLOBAL(c_szRegFindNewsCols,     "Find News Column Info");
STR_GLOBAL(c_szRegFolderNewsCols,   "Folder News Column Info");
STR_GLOBAL(c_szRegFolderMailCols,   "Folder Mail Column Info");
STR_GLOBAL(c_szRegIMAPCols,         "IMAP Column Info");
STR_GLOBAL(c_szRegIMAPColsOut,      "IMAP Column Info (Out)");
STR_GLOBAL(c_szRegAccountNewsCols,  "News Account Column Info");
STR_GLOBAL(c_szRegAccountIMAPCols,  "IMAP Account Column Info");
STR_GLOBAL(c_szRegLocalStoreCols,   "Local Store Column Info");
STR_GLOBAL(c_szRegNewsSubCols,      "News Sub Column Info");
STR_GLOBAL(c_szRegImapSubCols,      "IMAP Sub Column Info");
STR_GLOBAL(c_szRegOfflineCols,      "Offline Column Info");
STR_GLOBAL(c_szRegHTTPMailCols,     "HTTPMail Column Info");
STR_GLOBAL(c_szRegHTTPMailSubCols,  "HTTPMail Sub Column Info");
STR_GLOBAL(c_szRegHTTPMailAccountCols,"HTTPMail Account Column Info");
STR_GLOBAL(c_szRegHTTPMailColsOut,  "HTTPMail Column Info (Out)");
STR_GLOBAL(c_szQuoteChars,          ">|:");
STR_GLOBAL(c_szDSHtmlToPlain,       "Html to Plain Warning");
STR_GLOBAL(c_szDSSendMail,          "Send Mail Warning");
STR_GLOBAL(c_szDSSendNews,          "Send News Warning");
STR_GLOBAL(c_szDSCancelNews,        "Cancel News Warning");
STR_GLOBAL(c_szDSHTMLNewsWarning,   "HTML News Warning");
STR_GLOBAL(c_szDSUseMailCertInNews, "Use Mail Cert In News");
STR_GLOBAL(c_szDSChangeNewsServer,  "Warn Change News Server");
STR_GLOBAL(c_szRegSendImmediate,    "Send Mail Immediately");
STR_GLOBAL(c_szRegAskSubscribe,     "Ask Subscribe");
STR_GLOBAL(c_szPosterKeyword,       "poster");
STR_GLOBAL(c_szRegManyMsgWarning,   "Open Messages Warning");
STR_GLOBAL(c_szRegDLDlgPos,         "Download Dialog Position");
STR_GLOBAL(c_szSpecFldrBase,        "special folders");
STR_GLOBAL(c_szDSPostInOutbox,      "Post in Outbox");
STR_GLOBAL(c_szDSSavedInSavedItems, "Saved in Saved Items");
STR_GLOBAL(c_szDSGroupFilters,      "Group Filters Warning");
STR_GLOBAL(c_szRegTooMuchQuoted,    "Too Much Quoted Warning");
STR_GLOBAL(c_szRegWarnDeleteThread, "Delete Thread Warning");
STR_GLOBAL(c_szRegUnsubscribe,      "Unsubscribe Warning");
STR_GLOBAL(c_szRegHide,             "Hide Warning");
STR_GLOBAL(c_szNoCheckDefault,      "No Check Default");
STR_GLOBAL(c_szOERunning,           "Running");
STR_GLOBAL(c_szRegGodMode,          "GodMode");
STR_GLOBAL(c_szDSABDelete,          "Address Book Delete Warning");
STR_GLOBAL(c_szRegFindHistory,      "Find History");
STR_GLOBAL(c_szRegOutlookBar,       "Outlook Bar Settings");
STR_GLOBAL(c_szRegOutlookBarNewsOnly, "Outlook Bar Settings News Only");
STR_GLOBAL(c_szRegShowOutlookBar,   "Show Outlook Bar");
STR_GLOBAL(c_szRegNavPaneWidth,     "Nav Pane Width");
STR_GLOBAL(c_szRegNavPaneSplit,     "Nav Pane Split");
STR_GLOBAL(c_szRegShowContacts,     "Show Contacts");
STR_GLOBAL(c_szRegCheckMailOnStart, "Check Mail on Startup");
STR_GLOBAL(c_szRegBackgroundCompact,"Background Compaction");
STR_GLOBAL(c_szRegFilterJunk,       "Filter Junk");
STR_GLOBAL(c_szRegFilterAdult,      "Filter Adult");
STR_GLOBAL(c_szRegJunkPct,          "Junk Percent");
STR_GLOBAL(c_szRegDeleteJunk,       "Delete Junk");
STR_GLOBAL(c_szRegDeleteJunkDays,   "Delete Junk Days");
STR_GLOBAL(c_szRegColumnHidden,     "Column Hidden Warning");
STR_GLOBAL(c_szBASort,              "Contact Pane Sorting");
STR_GLOBAL(c_szRegWatchedColor,     "Watched Message Color");
STR_GLOBAL(c_szExceptionsWAB,       "Check WAB for Exceptions");
STR_GLOBAL(c_szBLAutoLogon,         "Messenger Auto logon");
STR_GLOBAL(c_szRegSearchBodies,     "Search Message Bodies");
STR_GLOBAL(c_szRegSubjectThreading, "Subject Threading");
STR_GLOBAL(c_szRegGlobalView,       "Global View");

// Spelling values
// Non-localizable string constants, meant to be READ-ONLY
#ifdef WIN32
STR_GLOBAL(c_szRegSpellLangID,          "SpellLangID");
STR_GLOBAL(c_szRegSpellKeyDef,          "Spelling\\%s\\Normal");
STR_GLOBAL(c_szRegSpellKeyDefRoot,      "SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Spelling");
STR_GLOBAL(c_szRegSpellKeyCustom,       "Custom Dictionaries");
STR_GLOBAL(c_szRegSpellProfile,         "SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\");
STR_GLOBAL(c_szRegSpellPath,            "Engine");
STR_GLOBAL(c_szRegSpellPathLex,         "Dictionary");
STR_GLOBAL(c_szRegSpellPathDict,        "1");
STR_GLOBAL(c_szSpellOffice9ProofPath,   "Microsoft\\Proof\\");
STR_GLOBAL(c_szRegSharedTools,          "SOFTWARE\\Microsoft\\Shared Tools\\");
STR_GLOBAL(c_szRegSharedToolsPath,      "SharedFilesDir");
#else
STR_GLOBAL(c_szRegSpellKeyDef,      "Spelling %s,0");
STR_GLOBAL(c_szRegSpellKeyCustom,   "Custom Dict 1");
STR_GLOBAL(c_szRegSpellProfile,     "MS Proofing Tools");
#endif
STR_GLOBAL(c_szRegDefCustomDict,    "\\msapps\\proof\\custom.dic");
STR_GLOBAL(c_szRegDICHandlerKEY,    ".DIC");
STR_GLOBAL(c_szRegDICHandlerDefault,"txtfile");
STR_GLOBAL(c_szRegSecurityZone,     "Email Security Zone");
STR_GLOBAL(c_szRegSecurityZoneLocked, "Security Zone Locked");

// Coolbar Branding
STR_GLOBAL(c_szRegKeyCoolbar,       STR_REG_PATH_IE "\\Toolbar");
STR_GLOBAL(c_szRegKeyIEMain,        STR_REG_PATH_IE "\\Main");
STR_GLOBAL(c_szValueLargeBitmap,    "BigBitmap");
STR_GLOBAL(c_szValueSmallBitmap,    "SmallBitmap");
STR_GLOBAL(c_szValueBrandBitmap,    "BrandBitmap");
STR_GLOBAL(c_szValueBrandHeight,    "BrandHeight");
STR_GLOBAL(c_szValueBrandLeadIn,    "BrandLeadIn");
STR_GLOBAL(c_szValueSmBrandBitmap,  "SmBrandBitmap");
STR_GLOBAL(c_szValueSmBrandHeight,  "SmBrandHeight");
STR_GLOBAL(c_szValueSmBrandLeadIn,  "SmBrandLeadIn");
STR_GLOBAL(c_szValueBackBitmap,     "BackBitmap");
STR_GLOBAL(c_szValueBackBitmapIE5,  "BackBitmapIE5");

// ------------------------------------------------------
// ADM supported values
// ------------------------------------------------------
STR_GLOBAL(c_szBlockAttachments,    "BlockExeAttachments");

// ------------------------------------------------------
// Account Manager Registry Keys
// ------------------------------------------------------
STR_GLOBAL(c_szMigrated,                "Migrated");

// ------------------------------------------------------
// S/MIME things
// ------------------------------------------------------
STR_GLOBAL(c_szWABCertStore,    "AddressBook");
STR_GLOBAL(c_szCACertStore,     "CA");
STR_GLOBAL(c_szMyCertStore,     "My");

// ------------------------------------------------------
// Mail Consts (sbailey)
// ------------------------------------------------------
STR_GLOBAL(c_szSMTP,                     "SMTP");
STR_GLOBAL(c_szAccount,                  "Account");
STR_GLOBAL(c_szPop3LogFile,              "Log File (POP3)");
STR_GLOBAL(c_szSmtpLogFile,              "Log File (SMTP)");
STR_GLOBAL(c_szLogSmtp,                  "Log SMTP (0/1)");
STR_GLOBAL(c_szLogPop3,                  "Log POP3 (0/1)");
STR_GLOBAL(c_szLog,                      "Log");
STR_GLOBAL(c_szPop3Uidl,                 "pop3uidl");
STR_GLOBAL(c_szDefaultSmtpLog,           "Smtp.log");
STR_GLOBAL(c_szDefaultPop3Log,           "Pop3.log");
STR_GLOBAL_ANSI(c_szPrefixRE,            "Re: ");
STR_GLOBAL_ANSI(c_szPrefixFW,            "Fw: ");
STR_GLOBAL(c_szRegImap4LogFile,          "Log File (IMAP4)");
STR_GLOBAL(c_szRegLogImap4,              "Log IMAP4 (0/1)");
STR_GLOBAL(c_szDefaultImap4Log,          "Imap4.log");
STR_GLOBAL(c_szRegLogHTTPMail,           "Log HTTPMail (0/1)");
STR_GLOBAL(c_szRegHTTPMailLogFile,       "Log File (HTTPMAIL)");
STR_GLOBAL(c_szDefaultHTTPMailLog,       "HTTPMail.log");
STR_GLOBAL_WIDE(c_wszSMTP,               "SMTP");

// ------------------------------------------------------

// class names
// Important!!! Office 2000 HARDCODED some of these class names 
// for using with pluggable UI.
// Please, do not modify these names without 150% confidence.
STR_GLOBAL(c_szFolderWndClass,          "FolderWndClass");
STR_GLOBAL(c_szBlockingPaintsClass,     "Ath_PaintBlocker");
STR_GLOBAL(c_szFolderViewClass,         "FolderViewer");
STR_GLOBAL(c_szCacheNotifyWndClass,     "CacheNotifyWindow");
STR_GLOBAL(c_szBrowserWndClass,         "Outlook Express Browser Class");
STR_GLOBAL(c_szAccountViewWndClass,     "Outlook Express AcctView Class");
STR_GLOBAL(c_szIMAPSyncCFSMWndClass,    "Outlook Express IMAP CFSM Class");
STR_GLOBAL_WIDE(c_wszNoteWndClass,      "ATH_Note");
STR_GLOBAL_WIDE(c_wszMEDocHostWndClass, "ME_DocHost");
STR_GLOBAL_WIDE(c_wszDocHostWndClass,   "Ath_DocHost");

// new mail sound stuff
STR_GLOBAL(s_szMailSndKey,          "MailBeep");
STR_GLOBAL(s_szTimeGetTime,         "timeGetTime");

// file extensions
STR_GLOBAL(c_szSubFileExt,          ".sub");
STR_GLOBAL(c_szGrpFileExt,          ".dat");
STR_GLOBAL(c_szDbxExt,              ".dbx");
STR_GLOBAL(c_szMigrationExe,        "oemig50.exe");
STR_GLOBAL(c_szEmlExt,              ".eml");
STR_GLOBAL(c_szNwsExt,              ".nws");
STR_GLOBAL(c_szLogExt,              ".log");
STR_GLOBAL(c_szWabExt,              ".wab");
STR_GLOBAL(c_szWabBack1,            ".wa~");
STR_GLOBAL(c_szWabBack2,            ".w~b");

STR_GLOBAL_WIDE(c_wszEmlExt,        ".eml");
STR_GLOBAL_WIDE(c_wszNwsExt,        ".nws");

STR_GLOBAL(c_szExeExt,              ".exe");
STR_GLOBAL(c_szHtmExt,              ".htm");
STR_GLOBAL(c_szHtmlExt,             ".html");
STR_GLOBAL(c_szTxtExt,              ".txt");

// file names
STR_GLOBAL(c_szGrpFileName,         "grplist.dat");
STR_GLOBAL(c_szSubFileName,         "sublist.dat");
STR_GLOBAL(c_szNewsLogFile,         "inetnews.log");
STR_GLOBAL(c_szWabMigExe,           "wabmig.exe");
STR_GLOBAL(c_szInetcfgDll,          "inetcfg.dll");
STR_GLOBAL(c_szCheckConnWiz,        "CheckConnectionWizard");

// Help file names
STR_GLOBAL(c_szCtxHelpFile,         "msoe.hlp");
STR_GLOBAL(c_szCtxHelpFileHTML,     "%SYSTEMROOT%\\help\\msoe.chm>iedefault");
STR_GLOBAL(c_szCtxHelpFileHTMLCtx,  "%SYSTEMROOT%\\help\\msoe.chm>large_context");
STR_GLOBAL(c_szCtxHelpDefault,      "cool_mail.htm");
#define c_szMailHelpFile            c_szCtxHelpFile
#define c_szNewsHelpFile            c_szCtxHelpFile
#define c_szMailHelpFileHTML        c_szCtxHelpFileHTML
#define c_szNewsHelpFileHTML        c_szCtxHelpFileHTML

// formatting strings
STR_GLOBAL(c_szPathWildAllFmt,      "%s\\*.*");
STR_GLOBAL(c_szPathFileExtFmt,      "%s\\%s%s");
STR_GLOBAL(c_szStrNumFmt,           "%s (%d)");
STR_GLOBAL(c_szSpaceCatFmt,         "%s %s");
STR_GLOBAL_WIDE(c_wszNumberFmt,     "&%d %s");
STR_GLOBAL_WIDE(c_wszNumberFmt10,   "1&0 %s");
STR_GLOBAL_WIDE(c_wszPathWildExtFmt,"%s\\*%s");

STR_GLOBAL(c_szMailDir,             "Mail");
STR_GLOBAL(c_szNewsDir,             "News");
STR_GLOBAL(c_szImapDir,             "Imap");
STR_GLOBAL(c_szMailInitEvt,         "microsoft_thor_init_101469_mail");
STR_GLOBAL(c_szNotifyInfo,          "microsoft_thor_notifyinfo_");
STR_GLOBAL(c_szMailFolderNotify,    "microsoft_thor_folder_notifyinfo_");
STR_GLOBAL(c_szSharedFldInfo,       "microsoft_thor_shared_fld_info_");
STR_GLOBAL(c_szCacheFolderNotify,   "microsoft_thor_cache_notifyinfo_%s");
STR_GLOBAL(c_szStoreTempFilePrefix, "mbx");
STR_GLOBAL(c_szFolderDelNotify,     "microsoft_thor_folder_del");

// Needed for Simple MAPI support
STR_GLOBAL(c_szMAPI,                "MAPI");
STR_GLOBAL(c_szMailIni,             "Mail");
STR_GLOBAL(c_szMAPIDLL,             "MAPI32.DLL");
STR_GLOBAL(c_szMAPILogon,           "MAPILogon");
STR_GLOBAL(c_szMAPILogoff,          "MAPILogoff");
STR_GLOBAL(c_szMAPIFreeBuffer,      "MAPIFreeBuffer");
STR_GLOBAL(c_szMAPIResolveName,     "MAPIResolveName");
STR_GLOBAL(c_szMAPISendMail,        "MAPISendMail");

STR_GLOBAL(c_szImnimpDll,           "oeimport.dll");

STR_GLOBAL(c_szMAPIX,               "MAPIX");
STR_GLOBAL(c_szOne,                 "1");
STR_GLOBAL(c_szWinIni,              "WIN.INI");

// Needed for RAS support
// RAS DLL strings
STR_GLOBAL(szRasDll,                "RASAPI32.DLL");

//Needed for Mobility Pack support
STR_GLOBAL(szSensApiDll,           "SENSAPI.DLL");

//Needed for WinInet Apis
STR_GLOBAL(szWinInetDll,           "WININET.DLL");

STR_GLOBAL(c_szMAPIStub,            "mapistub.dll");

// RAS function strings
#ifdef UNICODE
STR_GLOBAL(szRasDial,               "RasDialW");
STR_GLOBAL(szRasEnumConnections,    "RasEnumConnectionsW");
STR_GLOBAL(szRasEnumEntries,        "RasEnumEntriesW");
STR_GLOBAL(szRasGetConnectStatus,   "RasGetConnectStatusW");
STR_GLOBAL(szRasGetErrorString,     "RasGetErrorStringW");
STR_GLOBAL(szRasHangup,             "RasHangUpW");
STR_GLOBAL(szRasSetEntryDialParams, "RasSetEntryDialParamsW");
STR_GLOBAL(szRasGetEntryDialParams, "RasGetEntryDialParamsW");
STR_GLOBAL(szRasGetEntryProperties, "RasGetEntryPropertiesW");
STR_GLOBAL(szRasEditPhonebookEntry, "RasEditPhonebookEntryW");
#else
STR_GLOBAL(szRasDial,               "RasDialA");
STR_GLOBAL(szRasEnumConnections,    "RasEnumConnectionsA");
STR_GLOBAL(szRasEnumEntries,        "RasEnumEntriesA");
STR_GLOBAL(szRasGetConnectStatus,   "RasGetConnectStatusA");
STR_GLOBAL(szRasGetErrorString,     "RasGetErrorStringA");
STR_GLOBAL(szRasHangup,             "RasHangUpA");
STR_GLOBAL(szRasSetEntryDialParams, "RasSetEntryDialParamsA");
STR_GLOBAL(szRasGetEntryDialParams, "RasGetEntryDialParamsA");
STR_GLOBAL(szRasGetEntryProperties, "RasGetEntryPropertiesA");
STR_GLOBAL(szRasEditPhonebookEntry, "RasEditPhonebookEntryA");
#endif

//Mobility Pack functions
#ifdef UNICODE
STR_GLOBAL(szIsDestinationReachable, "IsDestinationReachableW");
#else
STR_GLOBAL(szIsDestinationReachable, "IsDestinationReachableA");
#endif

STR_GLOBAL(szIsNetworkAlive, "IsNetworkAlive");

//WinInet Api strings
#ifdef UNICODE
STR_GLOBAL(szInternetGetConnectedStateEx, "InternetGetConnectedStateExW");
#else
STR_GLOBAL(szInternetGetConnectedStateEx, "InternetGetConnectedStateExA");
#endif

// -----------------------------------------------------
// V2 - New Options for messages and international stuff
// -----------------------------------------------------
STR_GLOBAL(c_szMsgSendHtml,         "Message Send HTML");
STR_GLOBAL(c_szMsgPlainMime,        "Message Plain Format MIME");
STR_GLOBAL(c_szMsgPlainEncoding,    "Message Plain Encoding Format");
STR_GLOBAL(c_szMsgHTMLEncoding,     "Message HTML Encoding Format");
STR_GLOBAL(c_szMsgPlainLineWrap,    "Message Plain Character Line Wrap");
STR_GLOBAL(c_szMsgHTMLLineWrap,     "Message HTML Character Line Wrap");
STR_GLOBAL(c_szMsgHTMLAllow8bit,    "Message HTML Allow 8bit in Header");
STR_GLOBAL(c_szMsgPlainAllow8bit,   "Message Plain Allow 8bit in Header");
STR_GLOBAL(c_szLangView,            "Language View");
STR_GLOBAL(c_szLangViewSetDefault,  "Language View Reset Default");

// -----------------------------------------------------
// V2 - international stuff ( charset map )
// -----------------------------------------------------
STR_GLOBAL(c_szCharsetMapPathOld,    STR_REG_PATH_EMAIL "\\CharsetMap");
STR_GLOBAL(c_szCharsetMapPath,       STR_REG_PATH_ROOT  "\\CharsetMap");  
STR_GLOBAL(c_szCharsetMapKey,        "Alternative");

// -----------------------------------------------------
// Tip of the day keys and options
// -----------------------------------------------------
STR_GLOBAL(c_szRegTipOfTheDay,      "Tip of the Day");

STR_GLOBAL(c_szInbox,               "Inbox");
STR_GLOBAL(c_szINBOX,               "INBOX");

// -----------------------------------------------------
// S/MIME UI screens
// -----------------------------------------------------
STR_GLOBAL(c_szDigSigHelpHTML,      "sighelp.htm");
STR_GLOBAL(c_szEncryptHelpHTML,     "enchelp.htm");
STR_GLOBAL(c_szSAndEHelpHTML,       "sandehlp.htm");

STR_GLOBAL(c_szMHTMLColon,          "mhtml:");
STR_GLOBAL(c_szMHTMLExt,            ".mhtml");
STR_GLOBAL(c_szFileUrl,             "file://");

STR_GLOBAL(c_szHTMLIDchkShowAgain,  "chkShowAgain");

// -----------------------------------------------------
// Command line switches
// -----------------------------------------------------
STR_GLOBAL_WIDE(c_wszSwitchMailURL,       "/mailurl:");
STR_GLOBAL_WIDE(c_wszSwitchNewsURL,       "/newsurl:");
STR_GLOBAL_WIDE(c_wszSwitchEml,           "/eml:");
STR_GLOBAL_WIDE(c_wszSwitchNws,           "/nws:");
STR_GLOBAL_WIDE(c_wszSwitchMail,          "/mail");
STR_GLOBAL_WIDE(c_wszSwitchDefClient,     "/defclient");
STR_GLOBAL_WIDE(c_wszSwitchNews,          "/news");
STR_GLOBAL_WIDE(c_wszSwitchNewsOnly,      "/newsonly");
STR_GLOBAL_WIDE(c_wszSwitchOutNews,       "/outnews");
STR_GLOBAL_WIDE(c_wszSwitchMailOnly,      "/mailonly");

STR_GLOBAL(c_szMailNewsDllOld,      "mailnews.dll");
STR_GLOBAL(c_szMsimnuiDll,          "msimnui.dll");
STR_GLOBAL(c_szMailNewsExe,         "msimn.exe");
STR_GLOBAL(c_szUrlDll,              "url.dll");
STR_GLOBAL(c_szMailNewsDll,         "MAILNEWS.DLL");
STR_GLOBAL(c_szMailNewsTxt,         "MAILNEWS.TXT");
STR_GLOBAL(c_szMailNewsInf,         "MAILNEWS.INF");
STR_GLOBAL(c_szMailNewsHlp,         "MAILNEWS.HLP");
STR_GLOBAL(c_szMailNewsCnt,         "MAILNEWS.CNT");
STR_GLOBAL(c_szImnImpDll,           "IMNIMP.DLL");
STR_GLOBAL(c_szUninstallKey,        STR_REG_WIN_ROOT "\\Uninstall\\InternetMailNews");
STR_GLOBAL(c_szNewWABKey,           STR_REG_WAB_FLAT "\\WAB4");
STR_GLOBAL(c_szFirstRunValue,       "FirstRun");

// --------------------------------------------------------------------------
// OE Resource DLL name
// --------------------------------------------------------------------------
STR_GLOBAL(c_szLangDll,             "MSOERES.DLL");
STR_GLOBAL(c_szInetcommDll,         "INETCOMM.DLL");
STR_GLOBAL(c_szMsoert2Dll,          "MSOERT2.DLL");
STR_GLOBAL(c_szMsoeAcctDll,         "MSOEACCT.DLL");

// --------------------------------------------------------------------------
// New Rules Stuff
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRules,               "Rules");
STR_GLOBAL(c_szRulesMailBeta2,      "Mail\\Rules");
STR_GLOBAL(c_szRulesMail,           "Rules\\Mail");
STR_GLOBAL(c_szRulesNews,           "Rules\\News");
STR_GLOBAL(c_szRulesFilter,         "Rules\\Filter");
STR_GLOBAL(c_szRulesSenders,        "Rules\\Block Senders");
STR_GLOBAL(c_szRulesJunkMail,       "Rules\\Junk Mail");
#define c_szRulesVersion            c_szValueVersion
STR_GLOBAL(c_szRulesOrder,          "Order");
STR_GLOBAL(c_szRuleName,            "Name");
STR_GLOBAL(c_szRuleEnabled,         "Enabled");
STR_GLOBAL(c_szRuleCriteria,        "Criteria");
STR_GLOBAL(c_szRuleActions,         "Actions");
STR_GLOBAL(c_szRuleMarkStart,       "%M");
STR_GLOBAL(c_szRuleMarkEnd,         "%m");
STR_GLOBAL_WIDE(c_wszRuleMarkStart, "%M");
STR_GLOBAL_WIDE(c_wszRuleMarkEnd,   "%m");
STR_GLOBAL(c_szCriteriaOrder,       "Order");
STR_GLOBAL(c_szCriteriaType,        "Type");
STR_GLOBAL(c_szCriteriaFlags,       "Flags");
STR_GLOBAL(c_szCriteriaValueType,   "ValueType");
STR_GLOBAL(c_szCriteriaValue,       "Value");
STR_GLOBAL(c_szCriteriaLogic,       "Logic");
STR_GLOBAL(c_szActionsOrder,        "Order");
STR_GLOBAL(c_szActionsValueType,    "ValueType");
STR_GLOBAL(c_szActionsFlags,        "Flags");
STR_GLOBAL(c_szActionsType,         "Type");
STR_GLOBAL(c_szActionsValue,        "Value");
STR_GLOBAL(c_szFolderIdChange,      "FolderIdChange"); 
STR_GLOBAL(c_szJunkDll,             "OEJUNK.DLL");
STR_GLOBAL(c_szHrCreateJunkFilter,  "HrCreateJunkFilter");
STR_GLOBAL(c_szJunkFile,            "JUNKMAIL.LKO");
STR_GLOBAL(c_szMRUList,             "MRU List");
STR_GLOBAL(c_szRulesFilterMRU,      "Rules\\Filter\\MRU List");

// --------------------------------------------------------------------------
// Exception List
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRulesExcpts,         "Exceptions");
#define c_szExcptVersion            c_szValueVersion
STR_GLOBAL(c_szExcptFlags,          "Flags");
STR_GLOBAL(c_szException,           "Exception");

// --------------------------------------------------------------------------
// Block Senders
// --------------------------------------------------------------------------
STR_GLOBAL(c_szSenders,             "Block Senders");
STR_GLOBAL(c_szSendersMail,         "Block Senders\\Mail");
STR_GLOBAL(c_szSendersNews,         "Block Senders\\News");
#define c_szSendersVersion          c_szValueVersion
STR_GLOBAL(c_szSendersValue,        "Value");
STR_GLOBAL(c_szSendersFlags,        "Flags");

// --------------------------------------------------------------------------
// Info Column
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegInfoColumn,       "Left Pane");
STR_GLOBAL(c_szRegICBand,           "Band %d");
STR_GLOBAL(c_szRegICBandID,         "ID");
STR_GLOBAL(c_szRegICBandSize,       "Size");
STR_GLOBAL(c_szRegICBandVisible,    "Visible");

//---------------------------------------------------------------------------
// Toolbar stuff
//---------------------------------------------------------------------------
STR_GLOBAL(c_szRegBrowserBands,      "Browser Bands");
STR_GLOBAL(c_szRegNoteBands,         "Note Bands");
STR_GLOBAL(c_szToolbarNotifications, "Toolbar Notifications");
STR_GLOBAL(c_szRegPrevToolbarText,   "PrevToolbarTextStyle");

//---------------------------------------------------------------------------
// HTML Error Pages
//---------------------------------------------------------------------------
STR_GLOBAL(c_szErrPage_NotDownloaded,   "notdown.htm");
STR_GLOBAL(c_szErrPage_Offline,         "msgoff.htm");
STR_GLOBAL(c_szErrPage_DiskFull,        "diskfull.htm");
STR_GLOBAL(c_szErrPage_GenFailure,      "genfail.htm");
STR_GLOBAL(c_szErrPage_MailBomb,        "mailbomb.htm");
STR_GLOBAL(c_szErrPage_Expired,         "expired.htm");
STR_GLOBAL(c_szErrPage_DownloadCanceled,"dlcancel.htm");
STR_GLOBAL(c_szErrPage_FldrFail,        "fldrfail.htm");
STR_GLOBAL(c_szErrPage_SMimeEncrypt,    "smime.htm");
STR_GLOBAL(c_szErrPage_SMimeLabel,      "denied.htm");

// --------------------------------------------------------------------------
// MultiUser
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegCU,               STR_REG_PATH_ROOT);
STR_GLOBAL(c_szUserDirPath,         "Application Data\\Microsoft\\Outlook Express\\User Data\\");
STR_GLOBAL(c_szUsername,            "Current Username");
STR_GLOBAL(c_szUserID,              "UserID");
STR_GLOBAL(c_szUsePassword,         "UsePassword");
STR_GLOBAL(c_szPassword,            "Password");
STR_GLOBAL(c_szTimestamp,           "Timestamp");
STR_GLOBAL(c_szShared,              "Shared");
STR_GLOBAL(c_szIAM,                 "\\Software\\Microsoft\\Internet Account Manager");
STR_GLOBAL(c_szCommon,              "Common");
STR_GLOBAL(c_szRegOE,               "Application Data");
STR_GLOBAL(c_szLastUserID,          "Last User ID");
STR_GLOBAL(c_szLastUserName,        "Last User Name");
STR_GLOBAL(c_szRegDefaultSettings,  STR_REG_PATH_ROOT "\\Default Settings");
STR_GLOBAL(c_szRegForcefulSettings, STR_REG_PATH_ROOT "\\Required Settings");
STR_GLOBAL(c_szRegPreConfigAccts,   STR_REG_IAM_FLAT "\\Preconfigured");
STR_GLOBAL(c_szRegDefaultAccts,     STR_REG_IAM_FLAT "\\Default");
STR_GLOBAL(c_szOEVerStamp,          "VerStamp");

// --------------------------------------------------------------------------
// HTTPMail
// --------------------------------------------------------------------------
// Tokens and strings used to build the OE HTTP user agent

STR_GLOBAL(c_szCompatible,          "compatible");
STR_GLOBAL(c_szEndUATokens,         "TmstmpExt)");
STR_GLOBAL(c_szOEUserAgent,         "Outlook-Express/6.0 (");
STR_GLOBAL(c_szBeginUATokens,       "");

STR_GLOBAL(c_szAcceptTypeRfc822,    "message/rfc822");
STR_GLOBAL(c_szAcceptTypeWildcard,  "*/*");

STR_GLOBAL(c_szTrue,                "true");
// Setup
STR_GLOBAL(c_szRegWABVerInfo,       STR_REG_WAB_FLAT  "\\Version Info");
STR_GLOBAL(c_szRegCurrVer,          "Current");
STR_GLOBAL(c_szRegInterimVer,       "Interim");
STR_GLOBAL(c_szRegPrevVer,          "Previous");

// Connection settings Migration
STR_GLOBAL(c_szIAMAccounts,          "Software\\Microsoft\\Internet Account Manager\\Accounts");
STR_GLOBAL(c_szConnectionType,       "Connection Type");
STR_GLOBAL(c_szConnSettingsMigrated, "ConnectionSettingsMigrated");

//Reg keys for Return Receipts
STR_GLOBAL(c_szRequestMDN,                      "RequestMDN");
STR_GLOBAL(c_szRequestMDNLocked,                "RequestMDNLocked");

STR_GLOBAL(c_szSendMDN,                         "SendMDN");
STR_GLOBAL(c_szSendMDNLocked,                   "SendMDNLocked");

STR_GLOBAL(c_szSendReceiptToList,               "SendReceiptToList");
STR_GLOBAL(c_szSendReceiptToListLocked,         "SendReceiptToListLocked");

//Strings for receipts

STR_GLOBAL(c_szMultiPartReport,                 "multipart/report");
STR_GLOBAL(c_szMessageDispNotification,         "message/disposition-notification");
STR_GLOBAL(c_szDispositionNotification,         "disposition-notification");

//Secure Return Receipts
STR_GLOBAL(c_szSecureRequestMDN,                "SecureRequestMDN");

//Strings for hardcoded english headers
STR_GLOBAL_WIDE(c_wszRe,                        "Re: ");
STR_GLOBAL_WIDE(c_wszFwd,                       "Fw: ");

#endif // _STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\wabp.h ===
#include <wab.h>

// A special little Opie hack
#define MAPI_REPLYTO  1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\workoff.h ===
#ifndef      __WORKOFF_H
#define     __WORKOFF_H

#define     IDWorkOffline   100
#define     IDTryAgain      101

#define     IDHangup        105
#define     IDNoHangup      106
#endif //__WORKOFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\inc\thormsgs.h ===
////////////////////////////////////////////////////////////////////////
//
//  THORMSGS.H
//
//  Internally defined window messages
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_THORMSGS_H
#define _INC_THORMSGS_H

// newsview/mailview common messages
#define CM_OPTIONADVISE             (WM_USER + 1034)
#define WMR_CLICKOUTSIDE            (WM_USER + 1035)
#define WM_UPDATELAYOUT             (WM_USER + 1036)
#define WM_POSTCREATE               (WM_USER + 1037)
#define WM_FINDNEXT                 (WM_USER + 1038)
#define WM_SELECTROW                (WM_USER + 1039)
#define WM_TEST_GETMSGID            (WM_USER + 1040)
#define WM_TEST_SAVEMSG             (WM_USER + 1041)
#define WM_TOGGLE_CLOSE_PIN         (WM_USER + 1042)
#define WM_GET_TITLE_BAR_HEIGHT     (WM_USER + 1043)
#define WM_NEW_MAIL                 (WM_USER + 1044)
#define WM_UPDATE_PREVIEW           (WM_USER + 1045)
#define WM_OE_ENABLETHREADWINDOW    (WM_USER + 10666)
#define WM_OE_ACTIVATETHREADWINDOW  (WM_USER + 10667)
#define WM_OESETFOCUS               (WM_USER + 1046)
#define WM_OE_DESTROYNOTE           (WM_USER + 1047)
#define WM_OENOTE_ON_COMPLETE       (WM_USER + 1048)
#define WM_HEADER_GETFONT           (WM_USER + 1049)

// WMR_CLICKOUTSIDE - Subcodes, passed in the wParam to indicate what action cause this
// message to be sent. If MOUSE, hwnd is in lParam, if KeyBd VK code in  LPARAM
// If deactivate lparam is 0. Also the combination 0,0 may be sent to
// indicate other cases

#define CLK_OUT_MOUSE	0
#define CLK_OUT_KEYBD	1
#define CLK_OUT_DEACTIVATE 2


// newsview-specific messages
#define NVM_INITHEADERS         (WM_USER + 1101)
#define NVM_CHANGESERVERS       (WM_USER + 1104)  // Used in subscr.cpp
#define NVM_GETNEWGROUPS        (WM_USER + 1105)

// mailview-specific messages
#define MVM_REDOCOLUMNS     (WM_USER + 1202)
#define MVM_SPOOLERDELIVERY (WM_USER + 1206)
#define MVM_NOTIFYICONEVENT (WM_USER + 1208)

// note window messages
#define NWM_UPDATETOOLBAR   (WM_USER + 1300)
#define NWM_TESTGETDISP     (WM_USER + 1301)
#define NWM_TESTGETADDR     (WM_USER + 1302)
#define NWM_DROPFILEDESC    (WM_USER + 1303)
#define NWM_SETDROPTARGET   (WM_USER + 1304)
#define NWM_DEFEREDINIT     (WM_USER + 1305)
#define NWM_GETDROPTARGET   (WM_USER + 1306)
#define NWM_FILTERACCELERATOR   (WM_USER + 1307)
#define NWM_SHOWVCARDPROP   (WM_USER + 1308)
#define NWM_PASTETOATTACHMENT (WM_USER + 1309)

// dochost window messages
#define DHM_AUTODETECT       (WM_USER + 1350)

// Font cache notifications
#define FTN_POSTCHANGE      (WM_USER + 1403)
#define FTN_PRECHANGE       (WM_USER + 1404)

// Test team hooks
#define TT_GETCOOLBARFOLDER (WM_USER + 1501)
#define TT_ISTEXTVISIBLE    (WM_USER + 1502)

// INETMAIL Delivery Messages
#define IMAIL_DELIVERNOW        (WM_USER + 1700)
#define IMAIL_UPDATENOTIFYICON  (WM_USER + 1701)
#define IMAIL_POOLFORMAIL       (WM_USER + 1702)
#define IMAIL_WATCHDOGTIMER     (WM_USER + 1703)
#define IMAIL_NEXTTASK          (WM_USER + 1704)
#define IMAIL_SHOWWINDOW        (WM_USER + 1705)
#define IMAIL_SETPROGRESSRANGE  (WM_USER + 1706)
#define IMAIL_UPDATEPROGRESS    (WM_USER + 1707)
#define IMAIL_UPDATEGENERAL     (WM_USER + 1708)

// Spooler Messages
#define SPOOLER_POLLTIMER       (WM_USER + 1750)
#define SPOOLER_DELIVERNOW      (WM_USER + 1751)
#define SPOOLER_APPENDQUEUE     (WM_USER + 1752)
#define SPOOLER_NEXTEVENT       (WM_USER + 1753)

// IInetMsgCont notification messages
#define IMC_UPDATEHDR           (WM_USER + 1800)
#define IMC_ARTICLEPROG         (WM_USER + 1801)
#define IMC_UPDATEANDREFOCUS    (WM_USER + 1802)  
#define IMC_HDRSTATECHANGE      (WM_USER + 1803)
#define IMC_BODYAVAIL           (WM_USER + 1804)
#define IMC_BODYERROR           (WM_USER + 1805)
#define IMC_INSERTROW           (WM_USER + 1806)
#define IMC_DELETEROW           (WM_USER + 1807)
#define IMC_DISKOUTOFSPACE      (WM_USER + 1808)    // Bug #50704 (v-snatar)

// Connection Manager Messages
#define CM_CONNECT              (WM_USER + 2100)    // wParam is an HMENU, lParam is the command ID
#define CM_UPDATETOOLBAR        (WM_USER + 2101)
#define CM_NOTIFY               (WM_USER + 2102)
#define CM_INTERNALRECONNECT    (WM_USER + 2103)

// Spooler task messages
#define NTM_NEXTSTATE           (WM_USER + 2202)
#define NTM_NEXTARTICLESTATE    (WM_USER + 2203)

// Outlook Bar notification message
#define WM_RELOADSHORTCUTS      (WM_USER + 2301)

// OE Rules messages
#define WM_OE_GET_RULES         (WM_USER + 2400)
#define WM_OE_FIND_DUP          (WM_USER + 2401)

//Toolbar notifications
#define WM_OE_TOOLBAR_STYLE     (WM_USER + 2402)
#endif // _INC_THORMSGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\adbar.cpp ===
/*
 *    a d b a r. c p p
 *    
 *    Purpose:
 *        Implementation of CAdBar object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      May '99: shaheedp - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997, 1998, 1999.
 */

#include <pch.hxx>
#include <wininet.h> // INTERNET_MAX_URL_LENGTH
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "adbar.h"
#include "goptions.h"
#include <inpobj.h>


static const TCHAR s_szAdBarWndClass[] = TEXT("ThorAdBarWndClass");

CAdBar::CAdBar()
{
    m_ptbSite = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_cSize = 65;
    m_dwAdBarPos = 0;
    m_pszUrl = NULL;
    m_fFirstPos = TRUE;
    m_fDragging = FALSE;
    m_cRef      = 1;
    m_pMehost   = NULL;
}

CAdBar::~CAdBar()
{
    if (m_ptbSite)
        m_ptbSite->Release();
    
    MemFree(m_pszUrl);
    if(m_pMehost)
        delete m_pMehost;
}

HRESULT CAdBar::HrInit(BSTR     bstr)
{
    HRESULT     hr = S_OK;

    IF_FAILEXIT(hr = HrBSTRToLPSZ(CP_ACP, bstr, &m_pszUrl));

exit:    
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    HRESULT     hr = S_OK;

    if(!lplpObj)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDockingWindow))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IInputObject))
    {
        *lplpObj = (IInputObject *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *lplpObj = (IObjectWithSite *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else
    {
        if (m_pMehost)
        {
            hr = m_pMehost->QueryInterface(riid, lplpObj);
        }
        else
        {
            hr = E_FAIL;
        }

    }
exit:
    return hr;
}

ULONG CAdBar::AddRef()
{
    return (++m_cRef);
}

ULONG CAdBar::Release()
{
    ULONG      ulRet = 0;

    --m_cRef;
    ulRet = m_cRef;

    if (m_cRef == 0)
    {
        delete this;
    }

    return ulRet;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::GetWindow(HWND *phwnd)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->GetWindow(phwnd);

    return hr;

}

HRESULT CAdBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->ContextSensitiveHelp(fEnterMode);

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IDockingWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::ShowDW(BOOL fShow)
{

    // Make sure we have a site pointer first
    if (!m_ptbSite)
        {
        AssertSz(0, _T("CAdBar::ShowDW() - Can't show without calling SetSite() first."));
        return E_FAIL; 
        }

    if (m_hwnd==NULL && fShow==FALSE)   // noop
        return S_OK;

    if (!m_hwnd)
        {
        WNDCLASSEX  wc;
    
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szAdBarWndClass, &wc))
            {
            // We need to register the class
            wc.style            = 0;
            wc.lpfnWndProc      = CAdBar::ExtAdBarWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            // If AdBar is nor resizable then show standard cursor
            wc.hCursor          = LoadCursor(NULL, IDC_ARROW);

            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szAdBarWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;
            
            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
                return E_FAIL;
            }
        
        // Get the handle of the parent window
        if (FAILED(m_ptbSite->GetWindow(&m_hwndParent)))
            return E_FAIL;

        // Create the window
        m_hwnd = CreateWindowEx(0,
                                s_szAdBarWndClass,
                                NULL,
                                WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                                0,
                                0,
                                0,
                                0,
                                m_hwndParent,
                                NULL,
                                g_hInst,
                                (LPVOID)this);
        if (!m_hwnd)
            {
            AssertSz(0, _T("CAdBar::ShowDW() - Failed to create window."));
            return E_FAIL;
            }           
        }
    
    // Show or hide the window and resize the parent windows accordingly
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    ResizeBorderDW(NULL, NULL, FALSE);
    m_fFirstPos = (fShow ? m_fFirstPos : TRUE);
        
    return S_OK;
}

HRESULT CAdBar::CloseDW(DWORD dwReserved)
{
    if (m_pMehost)
    {
        m_pMehost->HrUnloadAll(NULL, 0);
        m_pMehost->HrClose();
    }
    return S_OK;
}

HRESULT CAdBar::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkToolbarSite, BOOL fReserved)
{
    RECT rcRequest = { 0, 0, 0, 0 };
    
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CAdBar::ResizeBorderDW() - Can't resize without calling SetSite() first."));
        return E_FAIL; 
    }

    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
    {
        RECT rcBorder;
        int cTop, cBottom;

        // Calculate position of AdBar window
        cBottom = GetAdBar_Bottom();

        if (!prcBorder)
        {
            // Find out how big our parent's border space is
            m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
        }

        if(!m_fFirstPos || (cBottom <= 0))
        {
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
            cBottom = rcRequest.bottom;

        }
        else
        {
            m_cSize = cBottom;    // set new value for m_cSize.
            cBottom  += GetSystemMetrics(SM_CYFRAME);
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
        }                                                                                                                                               


       SetWindowPos(m_hwnd, NULL, prcBorder->left, cTop,  
                     prcBorder->right - prcBorder->left, cBottom, 
                     SWP_NOACTIVATE|SWP_NOZORDER);

        m_fFirstPos = FALSE;            // AdBar window positioned

        // Set new value for AdBarPos
        m_dwAdBarPos = (DWORD) MAKELONG(cBottom - GetSystemMetrics(SM_CYFRAME), 0);
    }

    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);     
        
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrUIActivate(fActivate);

    return hr;
}

HRESULT CAdBar::HasFocusIO(void)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrHasFocus();

    return hr;
}    
        

HRESULT CAdBar::TranslateAcceleratorIO(LPMSG pMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrTranslateAccelerator(pMsg);

    return hr;
}    

////////////////////////////////////////////////////////////////////////
//
//  IObjectWithSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_ptbSite)
        {
        m_ptbSite->Release();
        m_ptbSite = NULL;
        }
    
    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, (void **)&m_ptbSite)))
            return E_FAIL;
        }
    
    return S_OK;    
}

HRESULT CAdBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleInPlaceSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::OnUIActivate()
{
    HRESULT     hr = E_FAIL;

    if (m_ptbSite)
        UnkOnFocusChangeIS(m_ptbSite, (IInputObject*)this, TRUE);

    if (m_pMehost)
        hr = m_pMehost->OnUIActivate();

    return hr;
}

HRESULT CAdBar::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    return (E_FAIL);
}

/////////////////////////////////////////////////////////////////////////////
//
// private routines
//
/////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CAdBar::ExtAdBarWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CAdBar *pbb;

    if (msg == WM_NCCREATE)
    {
        pbb = (CAdBar *)LPCREATESTRUCT(lp)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pbb);
    }
    else
    {
        pbb = (CAdBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    Assert(pbb);
    return pbb->AdBarWndProc(hwnd, msg, wp, lp);
}

LRESULT CAdBar::AdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);

        case WM_NCDESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            m_hwnd = NULL;
            break;

        case WM_SETFOCUS:
        {
            HWND hwndBody;

            if (m_pMehost && SUCCEEDED(m_pMehost->HrGetWindow(&hwndBody)) && hwndBody && ((HWND)wParam) != hwndBody)
                SetFocus(hwndBody);
        }
            return 0;    
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL CAdBar::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL        fRet = FALSE;

    if (!m_pMehost)
        m_pMehost = new CMimeEditDocHost;

    if (!m_pMehost)
        goto exit;

    if (FAILED(m_pMehost->HrInit(hwnd, 0, NULL)))
        goto exit;

    // We don't care if this fails.
//    TraceResult(m_pMehost->HrEnableScrollBars(FALSE));

    if (FAILED(m_pMehost->HrShow(TRUE)))
        goto exit;

    if (m_pszUrl)
        m_pMehost->HrLoadURL(m_pszUrl);

    fRet = TRUE;

exit:
    return fRet;
}

void CAdBar::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc;
    
    int  cyFrame = GetSystemMetrics(SM_CYFRAME);

    rc.left = 0;
    rc.top = cyFrame;
    rc.right = cxClient;
    rc.bottom = cyClient;

    if (m_pMehost)
        m_pMehost->HrSetSize(&rc);
}

HRESULT CAdBar::SetUrl(LPSTR pszUrl)
{
    HRESULT     hr            = S_OK;
    LPSTR       pszUrlBackup  = m_pszUrl;

    if (pszUrl && *pszUrl)
    {
        IF_NULLEXIT(m_pszUrl = PszDupA(pszUrl));

        if (m_pMehost)
            IF_FAILEXIT(hr = m_pMehost->HrLoadURL(m_pszUrl));
    }
    else
        hr = E_INVALIDARG;

exit:
    if (FAILED(hr))
    {
        m_pszUrl = pszUrlBackup;
    }
    else
    {
        MemFree(pszUrlBackup);
    }
    return hr;

}

BOOL CAdBar::fValidUrl()
{
    BOOL    fRet = FALSE;

    if (m_pszUrl && *m_pszUrl)
        fRet = TRUE;

    return fRet;
}

HRESULT HrProcessAdTokens(LPSTR    pszAdInfo, LPCSTR    pszToken,
                          LPSTR    pszretval, DWORD    cch,
                          DWORD    *pcchCount)
{
    LPSTR       lpSubString  = NULL;
    LPSTR       lpSubString1 = NULL;
    HRESULT     hr           = S_OK;
    DWORD       dwCount      = 0;

    *pszretval = 0;

    lpSubString = StrStr(pszAdInfo, pszToken);

    if (!lpSubString)
        IF_FAILEXIT(hr = E_FAIL);

    lpSubString = StrChr(lpSubString, '=');
    
    if (!lpSubString)
        IF_FAILEXIT(hr = E_FAIL);

    //Skip the equal sign
    ++lpSubString;

    SkipWhitespace(lpSubString, &dwCount);

    lpSubString += dwCount;

    lpSubString1 = lpSubString;

    lpSubString = StrChr(lpSubString, '*');
    if (!lpSubString)
    {

        //If we cannot find a * in it, we assume that this is the last token
        //and copy the entire field in it.
        lpSubString = lpSubString1 + strlen(lpSubString1) + 1;
    }

    if (((DWORD)(lpSubString - lpSubString1 + 1)) > cch)
    {
        IF_FAILEXIT(hr = E_FAIL);
    }

    *pcchCount = 0;
    while(lpSubString1 < lpSubString)
    {
        *pszretval++ = *lpSubString1++;
        (*pcchCount)++;
    }

    *pszretval = '\0';

    (*pcchCount)++; //To account for null

exit:
    return hr;

}

HRESULT HrEscapeOtherAdToken(LPSTR pszAdOther, LPSTR pszEncodedString, DWORD cch, DWORD *cchRetCount)
{
    CHAR     tempchar;
    DWORD    dwTempCount = 1; //Initializing with a null
    LPCSTR   pszTemp = pszAdOther;
    HRESULT  hr = S_OK;

    *cchRetCount = 0;

    while (tempchar = *pszTemp)
    {
        if ((tempchar == '=') || (tempchar == ' ') || (tempchar == '&'))
            dwTempCount += 3;
        else
            dwTempCount++;

        pszTemp++;
    }

    if (dwTempCount > cch)
    {
        IF_FAILEXIT(hr = E_FAIL);
    }

    //We have enough space
    while (tempchar = *pszAdOther)
    {
        if ((tempchar == '=') || (tempchar == '&') || (tempchar == ' '))
        {
            if (tempchar == '=')
            {
                pszTemp = c_szEqualSign;
            }
            else if (tempchar == '&')
            {
                pszTemp = c_szAmpersandSign;
            }
            else if (tempchar == ' ')
            {
                pszTemp = c_szSpaceSign;
            }
            strcpy(pszEncodedString, pszTemp);
            pszEncodedString += 3;
        }
        else
        {
            *pszEncodedString++ = tempchar;
        }
        pszAdOther++;
    }

    *cchRetCount = dwTempCount;
    *pszEncodedString = 0;

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\addrobj.h ===
/*
 *    a d d r o b j . h
 *
 *
 *     Purpose:
 *        implements an Address object. An ole object representation for
 *        a resolved email address. Wraps a CAddress object
 *      also implements an IDataObj for drag-drop
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 *
 *  Owner: brettm
 *
 */

#ifndef _ADDROBJ_H
#define _ADDROBJ_H

#include <richedit.h>
#ifndef _RICHOLE_H                  // richole.h has no #ifdef around it...
#define _RICHOLE_H
#include <richole.h>
#endif

#include <addrlist.h>
#include <ipab.h>

BOOL    FInitAddrObj(BOOL fInit);        // called at init time

class CAddrObj :
    public IOleObject,
    public IViewObject,
    public IPersist,
    public IOleCommandTarget
{
public:

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IOleObject methods:
    HRESULT STDMETHODCALLTYPE SetClientSite(LPOLECLIENTSITE pClientSite);
    HRESULT STDMETHODCALLTYPE GetClientSite(LPOLECLIENTSITE * ppClientSite);
    HRESULT STDMETHODCALLTYPE SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    HRESULT STDMETHODCALLTYPE Close(DWORD dwSaveOption);
    HRESULT STDMETHODCALLTYPE SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk);
    HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk);
    HRESULT STDMETHODCALLTYPE InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved);
    HRESULT STDMETHODCALLTYPE GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject); 
    HRESULT STDMETHODCALLTYPE DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    HRESULT STDMETHODCALLTYPE EnumVerbs(LPENUMOLEVERB * ppEnumOleVerb);
    HRESULT STDMETHODCALLTYPE Update();
    HRESULT STDMETHODCALLTYPE IsUpToDate();
    HRESULT STDMETHODCALLTYPE GetUserClassID(CLSID * pClsid);
    HRESULT STDMETHODCALLTYPE GetUserType(DWORD dwFormOfType, LPOLESTR * pszUserType);
    HRESULT STDMETHODCALLTYPE SetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    HRESULT STDMETHODCALLTYPE GetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    HRESULT STDMETHODCALLTYPE Advise (LPADVISESINK pAdvSink, DWORD * pdwConnection);
    HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwConnection);
    HRESULT STDMETHODCALLTYPE EnumAdvise(LPENUMSTATDATA * ppenumAdvise);
    HRESULT STDMETHODCALLTYPE GetMiscStatus(DWORD dwAspect, DWORD * pdwStatus);
    HRESULT STDMETHODCALLTYPE SetColorScheme(LPLOGPALETTE lpLogpal);


    // IViewObject methods:
    HRESULT STDMETHODCALLTYPE Draw(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                                    DVTARGETDEVICE * ptd, HDC hicTargetDev, HDC hdcDraw, 
                                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                                    BOOL (CALLBACK * pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue);

    HRESULT STDMETHODCALLTYPE GetColorSet(DWORD dwDrawAspect, LONG lindex, void *pvAspect, 
                                            DVTARGETDEVICE *ptd, HDC hicTargetDev, LPLOGPALETTE *ppColorSet);
    HRESULT STDMETHODCALLTYPE Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DWORD * pdwFreeze);
    HRESULT STDMETHODCALLTYPE Unfreeze(DWORD dwFreeze);
    HRESULT STDMETHODCALLTYPE SetAdvise(DWORD aspects, DWORD advf, IAdviseSink * pAdvSnk);
    HRESULT STDMETHODCALLTYPE GetAdvise(DWORD * pAspects, DWORD * pAdvf, IAdviseSink ** ppAdvSnk);

    // IPersit methods:
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    CAddrObj();
    ~CAddrObj();

    HRESULT HrSetAdrInfo(LPADRINFO lpAdrInfo);
    HRESULT HrGetAdrInfo(LPADRINFO *lplpAdrInfo); 

    HRESULT OnFontChange();

private:
    UINT                m_cRef;
    BOOL                m_fUnderline;           // Do we draw the underline?
    LPOLECLIENTSITE     m_lpoleclientsite;
    LPSTORAGE           m_pstg;                // Associated IStorage

    LPADVISESINK        m_padvisesink;
    LPOLEADVISEHOLDER   m_poleadviseholder;

    LPADRINFO           m_lpAdrInfo;
    
    HWND                m_hwndEdit; 

    HFONT _GetFont();
    
};

class CAddrObjData:
    public IDataObject
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IDataObject methods:
    HRESULT STDMETHODCALLTYPE GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);
    HRESULT STDMETHODCALLTYPE GetDataHere(FORMATETC * pformatetc, STGMEDIUM *pmedium);
    HRESULT STDMETHODCALLTYPE QueryGetData(FORMATETC * pformatetc );
    HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut);
    HRESULT STDMETHODCALLTYPE SetData(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
    HRESULT STDMETHODCALLTYPE EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc );
    HRESULT STDMETHODCALLTYPE DAdvise(FORMATETC * pformatetc, DWORD advf, IAdviseSink *pAdvSnk, DWORD * pdwConnection);
    HRESULT STDMETHODCALLTYPE DUnadvise(DWORD dwConnection);
    HRESULT STDMETHODCALLTYPE EnumDAdvise(IEnumSTATDATA ** ppenumAdvise );

public:
    CAddrObjData(LPWABAL lpWabal);

private:
    HRESULT HrGetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
    ~CAddrObjData();    

private:
    ULONG           m_cRef;
    LPWABAL         m_lpWabal;
};


// richedit callback used for addrwells

class CAddrWellCB:
    public IRichEditOleCallback
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // *** IRichEditOleCallback methods ***
    HRESULT STDMETHODCALLTYPE GetNewStorage (LPSTORAGE FAR *);
    HRESULT STDMETHODCALLTYPE GetInPlaceContext(LPOLEINPLACEFRAME FAR *,LPOLEINPLACEUIWINDOW FAR *,LPOLEINPLACEFRAMEINFO);
    HRESULT STDMETHODCALLTYPE ShowContainerUI(BOOL);
    HRESULT STDMETHODCALLTYPE QueryInsertObject(LPCLSID, LPSTORAGE,LONG);
    HRESULT STDMETHODCALLTYPE DeleteObject(LPOLEOBJECT);
    HRESULT STDMETHODCALLTYPE QueryAcceptData(  LPDATAOBJECT,CLIPFORMAT FAR *, DWORD,BOOL, HGLOBAL);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);
    HRESULT STDMETHODCALLTYPE GetClipboardData(CHARRANGE FAR *, DWORD,LPDATAOBJECT FAR *);
    HRESULT STDMETHODCALLTYPE GetDragDropEffect(BOOL, DWORD,LPDWORD);
    HRESULT STDMETHODCALLTYPE GetContextMenu(WORD, LPOLEOBJECT,CHARRANGE FAR *,HMENU FAR *);
    BOOL FInit(HWND hwndEdit);
    
    CAddrWellCB(BOOL fUnderline, BOOL fHasAddrObjs);
    ~CAddrWellCB();

    BOOL        m_fUnderline;

private:
    ULONG       m_cRef;
    HWND        m_hwndEdit;
    BOOL        m_fHasAddrObjs;
};


#ifdef DEBUG
    void AssertValidAddrObject(LPUNKNOWN pUnk);
#endif

#endif // _ADDROBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\adbar.h ===
#ifndef _ADBAR_H
#define _ADBAR_H

#include "mehost.h"

//Util functions used only in Ads
HRESULT HrEscapeOtherAdToken(LPSTR pszAdOther, LPSTR pszEncodedString, DWORD cch, DWORD *cchRetCount);
HRESULT HrProcessAdTokens(LPSTR    pszAdInfo, LPCSTR    pszToken, LPSTR    pszretval, DWORD    cch, DWORD    *pcchCount);

//Strings for Ads
const CHAR c_szAdPaneOn[]           = "On";
const CHAR c_szAdPaneOff[]          = "Off";
const CHAR c_szAdOther[]            = "Other";
const CHAR c_szRedirectAdUrl[]      = "http://services.msn.com/svcs/oe/ads.asp?Version=";
const CHAR c_szAdSvrFormat[]        = "&AdSvr=";
const CHAR c_szAdOtherFormat[]      = "&Other=";
const CHAR c_szAdRedirectFormat[]   = "%s%s%s%s%s%s";

const CHAR c_szAdPane[]             = "AdPane";
const CHAR c_szAdSvr[]              = "AdSvr";
const CHAR c_szEqualSign[]          = "%3d";
const CHAR c_szAmpersandSign[]      = "%20";
const CHAR c_szSpaceSign[]          = "%26";

//Constants used only for Ads
#define CCH_ADPANE_OFF               (sizeof(c_szAdPaneOff) / sizeof(*c_szAdPaneOff))
#define CCH_ADPANE_ON                (sizeof(c_szAdPaneOn) / sizeof(*c_szAdPaneOn))
#define CCH_REDIRECT_ADURL           (sizeof(c_szRedirectAdUrl) / sizeof(*c_szRedirectAdUrl))
#define CCH_ADSVR_TOKEN_FORMAT       (sizeof(c_szAdSvrFormat) / sizeof(*c_szAdSvrFormat))
#define CCH_OTHER_FORMAT             (sizeof(c_szAdOther) / sizeof(*c_szAdOther))
#define CCH_AD_OTHER_FORMAT          (sizeof(c_szAdOtherFormat) / sizeof(*c_szAdOtherFormat))

class CAdBar :
    public IDockingWindow,
    public IObjectWithSite,
    public IInputObject
{
public:
    CAdBar();
    virtual ~CAdBar();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual STDMETHODIMP GetWindow(HWND *phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IDockingWindow
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    // IInputObject
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpmsg);

    // overrides of CBody
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);

    HRESULT HrInit(BSTR     bstr);
    HRESULT SetUrl(LPSTR pszUrl);
    BOOL    fValidUrl();

	int		GetAdBar_Top()			{ return( (int) HIWORD(m_dwAdBarPos));}
	int		GetAdBar_Bottom()			{ return( (int) LOWORD(m_dwAdBarPos));}
	
protected:
    LRESULT AdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK ExtAdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);

private:
    IDockingWindowSite *m_ptbSite;
    HWND                m_hwnd;
    HWND                m_hwndParent;
    int                 m_cSize;
	DWORD				m_dwAdBarPos;
    LPSTR               m_pszUrl;
	BOOL				m_fFirstPos;
    BOOL                m_fDragging;
    ULONG               m_cRef;
    CMimeEditDocHost    *m_pMehost;
};

#endif // _ADBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\addrobj.cpp ===
/*
 *  a d d r o b j . h
 *
 *
 *   Purpose:
 *      implements an Address object. An ole object representation for
 *      a resolved email address. Wraps a CAddress object
 *      also implements an IDataObj for drag-drop
 *
 *  Copyright (C) Microsoft Corp. 1993, 1994.
 *
 *  Owner: brettm
 *
 */

#include <pch.hxx>
#include <resource.h>
#include <addrobj.h>
#include <ourguid.h>    //addr object guid
#include <dragdrop.h>
#include <menuutil.h>
#include <wells.h>
#include <ipab.h>
#include <fonts.h>
#include <oleutil.h>
#include "menures.h"
#include "header.h"
#include "shlwapip.h"
#include "demand.h"

ASSERTDATA

/*
 * c o n s t a n t s
 */
enum
{
    iverbProperties=0,      //OLEIVERB_PRIMARY
    iverbAddToWAB=1,
    iverbFind=2,
    iverbBlockSender=3,
    iverbMax
};

#define CF_ADDROBJ              "Outlook Express Recipients"

/*
 * t y p e d e f s
 */

/*
 * m a c r o s
 */


/*
 * g l o b a l   d a t a 
 */

#pragma BEGIN_CODESPACE_DATA
static char szClipFormatAddrObj[] = CF_ADDROBJ;
#pragma END_CODESPACE_DATA

static FORMATETC rgformatetcADDROBJ[] =
{
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
};

enum 
{
    iFormatAddrObj=0, 
    iFormatText,
    iFormatUnicode,
    cformatetcADDROBJ
};

static BOOL     g_fInited=FALSE;


/*
 * p r o t o t y p e s
 */

HRESULT HrBuildSelectionWabal(HWND hwndRE, CHARRANGE *pchrg, LPWABAL *lplpWabal);
HRESULT HrBuildOneSelWabal(LPADRINFO lpAdrInfo, LPWABAL *lplpWabal);


/*
 * f u n c t i o n s
 */
BOOL FInitAddrObj(BOOL fInit)
{
    if(fInit&&g_fInited)
        return TRUE;

    if(!fInit)
    {
        //de-init stuff
        return TRUE;
    }

    // Register our clipboard formats
    rgformatetcADDROBJ[iFormatAddrObj].cfFormat =
                    (CLIPFORMAT) RegisterClipboardFormat(szClipFormatAddrObj);
    rgformatetcADDROBJ[iFormatText].cfFormat = CF_TEXT;
    rgformatetcADDROBJ[iFormatUnicode].cfFormat = CF_UNICODETEXT;
    
    return g_fInited=TRUE;
}




HRESULT CAddrObj::QueryInterface(REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (void*)this;
    else if (IsEqualIID(riid, IID_IOleObject))
        *ppvObject = (void*)(IOleObject*)this;
    else if (IsEqualIID(riid, IID_IViewObject))
        *ppvObject = (void*)(IViewObject*)this;
    else if (IsEqualIID(riid, IID_IPersist))
        *ppvObject = (void*)(IPersist*)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObject = (void *)(IOleCommandTarget *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrObj::AddRef(void)
{
    return ++m_cRef;
}

ULONG CAddrObj::Release(void)
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IOleObject methods:
HRESULT CAddrObj::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    CAddrWellCB             *pawcb=0;
    IRichEditOleCallback    *prole=0;
    IOleInPlaceSite         *pIPS;
    
    m_hwndEdit = NULL;    
    ReleaseObj(m_lpoleclientsite);
    m_lpoleclientsite=0;

    if (!pClientSite)
        return NOERROR;

    // we do this so when we d-d between notes, read/send etc. the triple inherits the
    // properies of it's callbacks pab and underlining.
    if(!pClientSite->QueryInterface(IID_IRichEditOleCallback, (LPVOID *)&prole))
    {
        pawcb=(CAddrWellCB *)prole;
        m_fUnderline=pawcb->m_fUnderline;
        ReleaseObj(prole);
    }
    
    if(!pClientSite->QueryInterface(IID_IOleInPlaceSite, (LPVOID *)&pIPS))
    {
        pIPS->GetWindow(&m_hwndEdit);
        pIPS->Release();
    }

    pClientSite->AddRef();
    m_lpoleclientsite = pClientSite;
    return NOERROR;

}

HRESULT CAddrObj::GetClientSite(LPOLECLIENTSITE * ppClientSite)
{
    *ppClientSite = m_lpoleclientsite;
    if(m_lpoleclientsite)
        m_lpoleclientsite->AddRef();
    return NOERROR;
}

HRESULT CAddrObj::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    return NOERROR;
}

HRESULT CAddrObj::Close(DWORD dwSaveOption)
{
    return NOERROR;
}

HRESULT CAddrObj::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject)
{
    HRESULT         hr;
    CAddrObjData    *pAddrObjData=0;
    LPWABAL         lpWabal=0;

    Assert(m_lpAdrInfo);

    hr=HrBuildOneSelWabal(m_lpAdrInfo, &lpWabal);
    if(FAILED(hr))
        goto cleanup;

    if(!(pAddrObjData = new CAddrObjData(lpWabal)))
    {
        hr=E_OUTOFMEMORY;
        goto cleanup;
    }

    hr=pAddrObjData->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

cleanup:
    ReleaseObj(lpWabal);
    ReleaseObj(pAddrObjData);
    return hr;
}


HRESULT CAddrObj::DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT         hr=0;
    HWND            hwndUI=GetParent(hwndParent);
    LPWAB           lpWab=0;
    int             idsErr=0;

    Assert(m_lpAdrInfo);

    hr=HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;

    switch(iVerb)
    {
        case iverbBlockSender:
            // hack. send the wm_command to the note to avoid dupe-code, also the note knows
            // if it's news or mail so the correct block sender verb can be applied
            SendMessage(GetTopMostParent(hwndUI), WM_COMMAND, MAKELONG(ID_BLOCK_SENDER, 0), 0);
            break;

        case iverbProperties:
            hr=lpWab->HrDetails(hwndUI, &m_lpAdrInfo);
            if(FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
                idsErr=idsErrAddrProps;
 
            m_padvisesink->OnViewChange(DVASPECT_CONTENT, -1);
            break;

        case iverbAddToWAB:
            if (m_lpAdrInfo->fDistList)
            {
                // $bug: 12298. don't try and add dist-lists
                idsErr=idsErrAddrDupe;
                hr = MAPI_E_COLLISION;
            }
            else
            {
                hr=lpWab->HrAddToWAB(hwndUI, m_lpAdrInfo);
                if(FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
                {
                    if(hr==MAPI_E_COLLISION)
                        idsErr=idsErrAddrDupe;
                    else
                        idsErr=idsErrAddToWAB;
                }
            }
            break;

        case iverbFind:
            hr = lpWab->HrFind(hwndUI, m_lpAdrInfo->lpwszAddress);
            if(FAILED(hr))
                idsErr = idsErrFindWAB;
            break;


        default:
            hr=OLEOBJ_S_INVALIDVERB;
            break;
    }

    if(idsErr)
        AthMessageBoxW(hwndUI, MAKEINTRESOURCEW(idsAthenaMail), 
            MAKEINTRESOURCEW(idsErr), NULL, MB_OK);

error:
    ReleaseObj(lpWab);
    return hr;

}

HRESULT CAddrObj::EnumVerbs(LPENUMOLEVERB * ppEnumOleVerb)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Update()
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::IsUpToDate()
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetUserClassID(CLSID * pClsid)
{
    *pClsid = CLSID_AddrObject;
    return NOERROR;
}


HRESULT CAddrObj::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    TCHAR szT[CCHMAX_STRINGRES];
    WCHAR szWT[CCHMAX_STRINGRES];
    
    AthLoadString((dwFormOfType == USERCLASSTYPE_APPNAME?idsAthena:idsRecipient),szT, 40);
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szT, -1, szWT, 40))
        lstrcpyW(*pszUserType, szWT);
    else
        lstrcpyW(*pszUserType, NULL);

    *pszUserType = PszDupW(szWT);
    return(NOERROR);
}

HRESULT CAddrObj::SetExtent(DWORD dwDrawAspect, LPSIZEL psizel)
{
    // The object's size is fixed
    return E_FAIL;
}

HFONT CAddrObj::_GetFont()
{
    HFONT           hFont=NULL;
    
    // try and get the message-font from the header, if this fails, fall back to the normal font
    if (m_hwndEdit)
        hFont = (HFONT)SendMessage(GetParent(m_hwndEdit), WM_HEADER_GETFONT, m_lpAdrInfo->fDistList, 0);
    
    if (!hFont)
        hFont = HGetSystemFont(m_lpAdrInfo->fDistList?FNT_SYS_ICON_BOLD:FNT_SYS_ICON);
    
    return hFont;
}

HRESULT CAddrObj::OnFontChange()
{
    IAdviseSink     *pAS;

    if (m_lpoleclientsite &&
        m_lpoleclientsite->QueryInterface(IID_IAdviseSink, (LPVOID *)&pAS)==S_OK)
    {
        pAS->OnViewChange(DVASPECT_CONTENT, -1);
        pAS->Release();
    }
    return S_OK;
}

 

HRESULT CAddrObj::GetExtent(DWORD dwDrawAspect, LPSIZEL psizel)
{
    HFONT           hfontOld=NULL;
    HDC             hdc;
    TEXTMETRIC      tm;
    LPWSTR          pwszName;
    SIZE            size;
    SIZEL           sizel;
    DWORD           cch, i;
    int             cx = 0, chcx;

    if (m_hwndEdit)
        hdc = GetWindowDC(m_hwndEdit);
    else
        hdc = GetWindowDC(NULL);

    if(!hdc)
        return E_OUTOFMEMORY;
            
    Assert(m_lpAdrInfo);

    hfontOld = SelectFont(hdc, _GetFont());

    pwszName = m_lpAdrInfo->lpwszDisplay;
    Assert(pwszName);

    GetTextExtentPoint32AthW(hdc, pwszName, lstrlenW(pwszName), &size, DT_NOPREFIX);    
    GetTextMetrics(hdc, &tm);

    sizel.cx = size.cx;
#ifndef DBCS
    sizel.cy = size.cy - tm.tmDescent;      // Same height as normal line (RAID11516 was +1)
#else
    sizel.cy = tm.tmAscent + 2;
#endif
    XformSizeInPixelsToHimetric(hdc, &sizel, psizel);

    if (hfontOld)
        SelectFont(hdc, hfontOld);

    if (m_hwndEdit)
        ReleaseDC(m_hwndEdit, hdc);
    else
        ReleaseDC(NULL, hdc);

    return NOERROR;
}

HRESULT CAddrObj::Advise (LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    if (m_poleadviseholder)
        return m_poleadviseholder->Advise(pAdvSink, pdwConnection);
    else
        return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CAddrObj::Unadvise(DWORD dwConnection)
{
    if (m_poleadviseholder)
        return m_poleadviseholder->Unadvise(dwConnection);
    else
        return E_FAIL;
}

HRESULT CAddrObj::EnumAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    if(m_poleadviseholder)
        return m_poleadviseholder->EnumAdvise(ppenumAdvise);
    else
        return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CAddrObj::GetMiscStatus(DWORD dwAspect, DWORD * pdwStatus)
{
    *pdwStatus = 0;
    return NOERROR;
}

HRESULT CAddrObj::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    return E_NOTIMPL;
}


HRESULT CAddrObj::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    if (pguidCmdGroup == NULL)
        return OLECMDERR_E_UNKNOWNGROUP;

    if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            rgCmds[ul].cmdf = 0;
            switch (rgCmds[ul].cmdID)
            {
                case ID_ADDROBJ_OLE_BLOCK_SENDER:
                    rgCmds[ul].cmdf = (m_lpAdrInfo->lRecipType == MAPI_ORIG) ? OLECMDF_ENABLED|OLECMDF_SUPPORTED : 0;
                    break;                    

                case ID_ADDROBJ_OLE_PROPERTIES:
                    rgCmds[ul].cmdf = OLECMDF_ENABLED|OLECMDF_SUPPORTED;
                    break;

                case ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK:
                case ID_ADDROBJ_OLE_FIND:
                    rgCmds[ul].cmdf = OLECMDF_SUPPORTED;
                    if (m_lpAdrInfo->lpwszAddress)
                        rgCmds[ul].cmdf |= OLECMDF_ENABLED;
                    break;
            }
        }                
        return S_OK;
    }
    else
        return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CAddrObj::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,   VARIANTARG *pvaOut)
{
    // we should use DoVerb for this
    return E_NOTIMPL;
}



// IViewObject methods:
HRESULT CAddrObj::Draw(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                                DVTARGETDEVICE * ptd, HDC hicTargetDev, HDC hdcDraw, 
                                LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                                BOOL (CALLBACK * pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    HFONT           hfontOld=NULL;
    RECT            rect;
    LPWSTR          pwszName;
    TEXTMETRIC      tm;
    HPEN            hPen,
                    hPenOld;
    COLORREF        hColor;
    Assert(m_lpAdrInfo);

    // Need to convert from RECTL to RECT
    rect.left = (INT) lprcBounds->left;
    rect.top = (INT) lprcBounds->top;
    rect.right = (INT) lprcBounds->right;
    rect.bottom = (INT) lprcBounds->bottom;

    hColor = GetSysColor(COLOR_WINDOWTEXT);
    if (m_fUnderline && m_lpAdrInfo->lpwszAddress == NULL && !m_lpAdrInfo->fDistList)
    {
        // if a compose-note, and there is no address then we show recipients with no email in red
        hColor = RGB(0xFF, 0, 0);
        if (GetSysColor(COLOR_WINDOW) == hColor)    // if background is RED, use WHITE
            hColor = RGB(0xFF, 0xFF, 0xFF);
    }

    hfontOld = SelectFont(hdcDraw, _GetFont());

    pwszName = m_lpAdrInfo->lpwszDisplay;
    SetTextAlign(hdcDraw, TA_BOTTOM);
    
    SetTextColor(hdcDraw, hColor);
    ExtTextOutWrapW(hdcDraw, rect.left, rect.bottom, 0, &rect, pwszName, lstrlenW(pwszName), NULL);

    if (hfontOld)
        SelectObject(hdcDraw, hfontOld);

    GetTextMetrics(hdcDraw, &tm);
    if (m_fUnderline)
    {
        // we want this underlined...
        hPen=CreatePen(PS_SOLID, 0, hColor);
        if(!hPen)
            return E_OUTOFMEMORY;
        
        hPenOld=(HPEN)SelectPen(hdcDraw, hPen);
        MoveToEx(hdcDraw, rect.left, rect.bottom - tm.tmDescent + 1, NULL);
        LineTo(hdcDraw, rect.right, rect.bottom - tm.tmDescent + 1);
        SelectPen(hdcDraw, hPenOld);
        DeleteObject(hPen);
    }
    return NOERROR;
}

HRESULT CAddrObj::GetColorSet(DWORD dwDrawAspect, 
                             LONG lindex, 
                             void *pvAspect, 
                             DVTARGETDEVICE *ptd, 
                             HDC hicTargetDev,
                             LPLOGPALETTE *ppColorSet)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DWORD * pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Unfreeze(DWORD dwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::SetAdvise(DWORD aspects, DWORD advf, IAdviseSink * pAdvSnk)
{
    if(m_padvisesink)
        m_padvisesink->Release();

    if(pAdvSnk)
        pAdvSnk->AddRef();
    
    m_padvisesink = pAdvSnk;

    return NOERROR;
}

HRESULT CAddrObj::GetAdvise(DWORD * pAspects, DWORD * pAdvf, IAdviseSink ** ppAdvSnk)
{
    return E_NOTIMPL;
}



// IPersit methods:
HRESULT CAddrObj::GetClassID(CLSID *pClsID)
{
    *pClsID = CLSID_AddrObject;
    return NOERROR;
}



CAddrObj::CAddrObj()
{
    
    m_cRef=1;
    m_fUnderline=TRUE;
    m_lpoleclientsite = 0;
    m_pstg = 0;
    m_padvisesink = 0;
    CreateOleAdviseHolder(&m_poleadviseholder);
    // copy props
    m_lpAdrInfo = NULL;
}

HRESULT CAddrObj::HrSetAdrInfo(LPADRINFO lpAdrInfo)
{
    if(m_lpAdrInfo)
    {
        MemFree(m_lpAdrInfo);
        m_lpAdrInfo=0;
    }
    
    // has to have a valid address, or else be a distlist...
    Assert(lpAdrInfo->lpwszDisplay);
    Assert(lpAdrInfo->lpbEID);
    return HrDupeAddrInfo(lpAdrInfo, &m_lpAdrInfo);
}

HRESULT CAddrObj::HrGetAdrInfo(LPADRINFO *lplpAdrInfo)
{
    Assert(lplpAdrInfo);
    *lplpAdrInfo=m_lpAdrInfo;
    return NOERROR;
};


CAddrObj::~CAddrObj()
{
    ReleaseObj(m_lpoleclientsite);
    ReleaseObj(m_pstg);
    ReleaseObj(m_poleadviseholder);
    ReleaseObj(m_padvisesink);

    // this is our own copy, we must free it!
    if(m_lpAdrInfo)
        MemFree(m_lpAdrInfo);
}




/* 
 * I D a t a  O b j e c t  m e t h o d s:
 *
 * 
 *
 */
HRESULT CAddrObjData::GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium)
{
    return HrGetDataHereOrThere(pformatetcIn, pmedium);
}

HRESULT CAddrObjData::GetDataHere(FORMATETC * pformatetc, STGMEDIUM *pmedium)
{
    return HrGetDataHereOrThere(pformatetc, pmedium);
}

HRESULT CAddrObjData::QueryGetData(FORMATETC * pformatetc )
{
    LONG        iformatetc;
    LPFORMATETC pformatetcT = rgformatetcADDROBJ;
    CLIPFORMAT  cfFormat    = pformatetc->cfFormat;
    DWORD       tymed       = pformatetc->tymed;

    for (iformatetc = 0; iformatetc < cformatetcADDROBJ;
                                ++iformatetc, ++pformatetcT)
    {
        // Stop searching if we have compatible formats and mediums
        if (pformatetcT->cfFormat == cfFormat &&
                    (pformatetcT->tymed & tymed))
            return NOERROR;
    }

    return ResultFromScode(S_FALSE);
}

HRESULT CAddrObjData::GetCanonicalFormatEtc(FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}

HRESULT CAddrObjData::SetData(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

HRESULT CAddrObjData::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc )
{
    return CreateEnumFormatEtc(this, cformatetcADDROBJ, NULL, rgformatetcADDROBJ, ppenumFormatEtc);
}

HRESULT CAddrObjData::DAdvise(FORMATETC * pformatetc, DWORD advf, IAdviseSink *pAdvSnk, DWORD * pdwConnection)
{
    return E_NOTIMPL;
}
HRESULT CAddrObjData::DUnadvise(DWORD dwConnection)
{
return E_NOTIMPL;
}

HRESULT CAddrObjData::EnumDAdvise(IEnumSTATDATA ** ppenumAdvise )
{
    return E_NOTIMPL;
}



HRESULT CAddrObjData::QueryInterface(REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (void*)this;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppvObject = (void*)(IDataObject*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrObjData::AddRef(void)
{
    return ++m_cRef;
}

ULONG CAddrObjData::Release(void)
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



HRESULT CAddrObjData::HrGetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT         hr=NOERROR;
    BOOL            fFound;
    ADRINFO         adrInfo;
    ULONG           cb=0;
    LPBYTE          pDst, pBeg;
    int             cch = 0;
    
    Assert(m_lpWabal);
    
    if (pformatetcIn->cfFormat == rgformatetcADDROBJ[iFormatAddrObj].cfFormat)
    {
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->pUnkForRelease = NULL;
        return m_lpWabal->HrBuildHGlobal(&pmedium->hGlobal);
    }
    else if ((pformatetcIn->cfFormat != rgformatetcADDROBJ[iFormatText].cfFormat) &&
             (pformatetcIn->cfFormat != rgformatetcADDROBJ[iFormatUnicode].cfFormat))
        return DATA_E_FORMATETC;
        
    fFound=m_lpWabal->FGetFirst(&adrInfo);
    while(fFound)
    {
        Assert(adrInfo.lpwszDisplay);
        cb+=(lstrlenW(adrInfo.lpwszDisplay)+2)*sizeof(WCHAR);        // +2 for '; '
        if (adrInfo.lpwszAddress)
            cb+=(lstrlenW(adrInfo.lpwszAddress)+3)*sizeof(WCHAR);        // +3 for ' <>'
        fFound=m_lpWabal->FGetNext(&adrInfo);
    }
    cb+=sizeof(WCHAR);      // null term
    
    if  (pmedium->tymed == TYMED_NULL ||
        (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal == NULL))
    {
        // This is easy, we can quit right after copying stuff
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);
        pmedium->pUnkForRelease = NULL;
    }
    else if (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal != NULL)
    {
        HGLOBAL hGlobal;
        // Caller wants us to fill his hGlobal
        // Realloc the destination to make sure there is enough room
        if (!(hGlobal = GlobalReAlloc(pmedium->hGlobal, cb, 0)))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pmedium->hGlobal = hGlobal;
    }
    else
        goto Cleanup;
    
    if (!pmedium->hGlobal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    cch = (cb/sizeof(WCHAR));
    pBeg = pDst = (LPBYTE)GlobalLock(pmedium->hGlobal);
    fFound=m_lpWabal->FGetFirst(&adrInfo);
    while(fFound)
    {
        cb = lstrlenW(adrInfo.lpwszDisplay) * sizeof(WCHAR);
        if (adrInfo.lpwszAddress)
        {
            cb += (lstrlenW(adrInfo.lpwszAddress) + 3) * sizeof(WCHAR);   //+3 " <>"
        }
        
        if (adrInfo.lpwszAddress)
            AthwsprintfW((LPWSTR)pDst, cch, L"%s <%s>", adrInfo.lpwszDisplay, adrInfo.lpwszAddress);
        else
            StrCpyW((LPWSTR)pDst, adrInfo.lpwszDisplay);

        pDst+=cb;
        
        fFound=m_lpWabal->FGetNext(&adrInfo);
        if(fFound)
        {
            // if more, add a '; '
            *((LPWSTR) pDst) = L';';
            pDst += sizeof(WCHAR);
            *((LPWSTR) pDst) = L' ';
            pDst += sizeof(WCHAR);
            *((LPWSTR) pDst) = L'\0';
        }                
    }

    //From MSDN:
    //   CF_TEXT Specifies the standard American National Standards Institute (ANSI) text format.
    //The string needs to be ANSI...convert it.
    if(pformatetcIn->cfFormat == CF_TEXT)
    {
        WCHAR *pwszDup;
        int cCopied;

        IF_NULLEXIT(pwszDup = StrDupW((LPWSTR)pBeg));
        cCopied = WideCharToMultiByte(CP_ACP, 0, pwszDup, lstrlenW(pwszDup), (LPTSTR)pBeg, cb, NULL, NULL);
        pBeg[cCopied] = '\0';
        MemFree(pwszDup);
    }

    GlobalUnlock(pmedium->hGlobal);
  
exit:    
Cleanup:
    return hr;
}


CAddrObjData::CAddrObjData(LPWABAL lpWabal)
{ 
    m_cRef=1;
    Assert(lpWabal);
    
    m_lpWabal=lpWabal;
    if(lpWabal)
        lpWabal->AddRef();
};


CAddrObjData::~CAddrObjData()
{ 
    ReleaseObj(m_lpWabal);
};

CAddrWellCB::CAddrWellCB(BOOL fUnderline, BOOL fHasAddrObjs)
{
    m_cRef=1;
    m_hwndEdit = 0;
    m_fUnderline = fUnderline;
    m_fHasAddrObjs=fHasAddrObjs;
}

CAddrWellCB::~CAddrWellCB()
{
}


BOOL CAddrWellCB::FInit(HWND hwndEdit)
{
    // make sure addrobj's DD guid's are registered
    if(!FInitAddrObj(TRUE))
        return FALSE;

    if(!IsWindow(hwndEdit))
        return FALSE;
    
    m_hwndEdit = hwndEdit;
    return TRUE;
}


HRESULT CAddrWellCB::QueryInterface(REFIID riid, LPVOID FAR * lplpObj)
{
    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (void*)(IUnknown*)this;
    else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        *lplpObj = (void*)(IRichEditOleCallback*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrWellCB::AddRef()
{
    return ++m_cRef;
}

ULONG CAddrWellCB::Release()
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}

HRESULT CAddrWellCB::GetNewStorage (LPSTORAGE FAR * ppstg)
{
    if (*ppstg)
        ppstg=NULL;
    
    AssertSz(FALSE, "this code should not get hit for OE");
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::GetInPlaceContext(   LPOLEINPLACEFRAME FAR * lplpFrame,
                                            LPOLEINPLACEUIWINDOW FAR * lplpDoc,
                                            LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::ShowContainerUI(BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::QueryInsertObject(LPCLSID lpclsid, 
                                       LPSTORAGE lpstg,
                                       LONG cp)
{
    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    if (IsEqualIID(*lpclsid, CLSID_AddrObject))
        return NOERROR;
    else
        return E_FAIL;
}

HRESULT CAddrWellCB::DeleteObject(LPOLEOBJECT lpoleobj)
{
    return NOERROR;
}


HRESULT CAddrWellCB::QueryAcceptData(LPDATAOBJECT   pdataobj,
                                     CLIPFORMAT FAR *pcfFormat, 
                                     DWORD          reco,
                                     BOOL           fReally, 
                                     HGLOBAL        hMetaPict)
{
    HRESULT         hr;
    STGMEDIUM       stgmedium;
    LPWABAL         lpWabal=0;
    ADRINFO         adrInfo;
    
    if(!m_fHasAddrObjs)
    {
        // of we're a regular callback, take TEXTONLY
        *pcfFormat=CF_TEXT;
        return NOERROR;
    }
    
    if (!*pcfFormat)
    {
        // default to text
        *pcfFormat = CF_TEXT;
        
        // Cool, it's one of ours...
        if(pdataobj->QueryGetData(&rgformatetcADDROBJ[iFormatAddrObj])==NOERROR)
            *pcfFormat = rgformatetcADDROBJ[iFormatAddrObj].cfFormat;
    }
    else
    {
        if (*pcfFormat != rgformatetcADDROBJ[iFormatAddrObj].cfFormat
            && *pcfFormat != rgformatetcADDROBJ[iFormatText].cfFormat)
            return DATA_E_FORMATETC;
    }
    
    if (*pcfFormat==CF_TEXT)  // let the richedit take care of text
        return NOERROR;
    
    // If I'm read-only, return Success and Richedit won't do anything
    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        return NOERROR;
    
    if (!fReally)   // return that we'll import it ourselves
        return ResultFromScode(S_FALSE);
    
    hr=pdataobj->GetData(&rgformatetcADDROBJ[iFormatAddrObj], &stgmedium);
    if(FAILED(hr))
        goto Cleanup;
    
    hr=HrCreateWabalObjectFromHGlobal(stgmedium.hGlobal, &lpWabal);
    if(FAILED(hr))
        goto Cleanup;
    
    if(lpWabal->FGetFirst(&adrInfo))
    {
        // don't add semi colon before first entry!
        HrAddRecipientToWell(m_hwndEdit, (LPADRINFO)&adrInfo);
        while(lpWabal->FGetNext(&adrInfo))
        {
            HdrSetRichEditText(m_hwndEdit, L"; ", TRUE);
            HrAddRecipientToWell(m_hwndEdit, (LPADRINFO)&adrInfo);
        }
    }
    
    // free the hglobal
    GlobalFree(stgmedium.hGlobal);
    ReleaseObj(lpWabal);
    hr = ResultFromScode(S_FALSE);
    
Cleanup:
    return hr;
}


HRESULT CAddrWellCB::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::GetClipboardData(CHARRANGE FAR * pchrg,
                                        DWORD reco,
                                        LPDATAOBJECT FAR * ppdataobj)
{
    HRESULT         hr;
    CAddrObjData    *lpAddrObjData=0;
    LPWABAL         lpWabal=0;
    ULONG           uSelType;

    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    Assert(ppdataobj);
    *ppdataobj=0;

    // Need to prevent cut on read only
    if (reco == RECO_CUT &&
        (GetWindowStyle(m_hwndEdit)&ES_READONLY))
        return E_NOTIMPL;


    // if there is only text in the selection, let the richedit take care of it!
    uSelType= (ULONG) SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0);
    if(!(uSelType&SEL_OBJECT))
        return E_NOTIMPL;

    hr=HrBuildSelectionWabal(m_hwndEdit, pchrg, &lpWabal);
    if(FAILED(hr))
        return E_FAIL;
    
    // this will gobble up the pal so I don't want to free it
    if(!(lpAddrObjData= new CAddrObjData(lpWabal)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }
    
    hr=lpAddrObjData->QueryInterface(IID_IDataObject, (LPVOID *)ppdataobj);
    ReleaseObj(lpAddrObjData);

error:
    ReleaseObj(lpWabal);
    return hr;
}

HRESULT CAddrWellCB::GetDragDropEffect(BOOL fDrag, 
                                       DWORD grfKeyState,
                                       LPDWORD pdwEffect)
{
    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    if (fDrag)          // use the default
        return NOERROR;

    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        *pdwEffect = DROPEFFECT_NONE;
    else
    {
        if ((grfKeyState & MK_CONTROL) || !(*pdwEffect & DROPEFFECT_MOVE))
            *pdwEffect = DROPEFFECT_COPY;
        else 
            *pdwEffect = DROPEFFECT_MOVE;
    }
    return NOERROR;
}

HRESULT CAddrWellCB::GetContextMenu(WORD            seltype, 
                                    LPOLEOBJECT     pOleObject,
                                    CHARRANGE FAR   *pchrg,
                                    HMENU FAR       *phMenu)
{

    HMENU               hMenu=0;
    DWORD               dwFlags=0;
    IOleCommandTarget   *pCmdTarget;
    OLECMD              rgCmds[] = {
                                        {ID_ADDROBJ_OLE_FIND, 0},
                                        {ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK, 0},
                                        {ID_ADDROBJ_OLE_PROPERTIES, 0},
                                        {ID_ADDROBJ_OLE_BLOCK_SENDER, 0}};


    if (!(hMenu=LoadPopupMenu(IDR_ADDRESS_POPUP)))
        return E_OUTOFMEMORY;

    if (!m_fHasAddrObjs || pOleObject==NULL)
    {
        // if this RICHEDIT control does not care about ADDROBJECT or if there is
        // no addr object selected, then just return a 
        // regular cut|copy|paste menu
        
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_FIND, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_BLOCK_SENDER, MF_BYCOMMAND);
        
        RemoveMenu(hMenu, ID_SEPARATOR_1, MF_BYCOMMAND);
        
        RemoveMenu(hMenu, ID_SEPARATOR_3, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_PROPERTIES, MF_BYCOMMAND);
        
    }
    else
    {
        // if we get this far, then we have an ole object, make sure it's one we know
        // about if we're an addrobj well
#ifdef DEBUG        
        AssertValidAddrObject(pOleObject);
#endif
        
        // try and see if the object can handle the commands
        if (pOleObject->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
            if (pCmdTarget->QueryStatus(&CMDSETID_OutlookExpress, ARRAYSIZE(rgCmds), rgCmds, NULL)==S_OK)
            {
                for(ULONG ul=0; ul<sizeof(rgCmds)/sizeof(OLECMD); ul++)
                {
                    EnableMenuItem(hMenu, rgCmds[ul].cmdID, (rgCmds[ul].cmdf&OLECMDF_ENABLED ? MF_ENABLED: MF_GRAYED)|MF_BYCOMMAND);
                    if (!(rgCmds[ul].cmdf&OLECMDF_SUPPORTED))
                        RemoveMenu(hMenu, rgCmds[ul].cmdID, MF_BYCOMMAND);
                }
            }
            pCmdTarget->Release();
        }
        
        // if an Object has focus, then we show the commands before the separator
        // if there is an object in selction, remove SelectAll
        RemoveMenu(hMenu, ID_SEPARATOR_2, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_SELECT_ALL, MF_BYCOMMAND);
        
        if (SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0) != SEL_OBJECT)
        {
            // multiple objects selected, let's grey out addrobj commands
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_PROPERTIES,        MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK,  MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_FIND,              MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_BLOCK_SENDER,      MF_GRAYED|MF_BYCOMMAND);
        } 
    }
    
    // if we are a readonly edit, then remove cut and paste
    if (FReadOnlyEdit(m_hwndEdit))
    {
        // remove cut and past if readonly
        RemoveMenu(hMenu, ID_CUT, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_PASTE, MF_BYCOMMAND);
    }
    
    MenuUtil_SetPopupDefault(hMenu, ID_ADDROBJ_OLE_PROPERTIES);
    
    GetEditDisableFlags(m_hwndEdit, &dwFlags);
    EnableDisableEditMenu(hMenu, dwFlags);
    *phMenu=hMenu;
    return S_OK;
}



#ifdef DEBUG        
void AssertValidAddrObject(LPUNKNOWN pUnk)
{    
    BOOL        fValid=FALSE;
    LPOLEOBJECT pOleObject;
    CLSID       clsid;

    Assert(pUnk);
    if(!pUnk->QueryInterface(IID_IOleObject, (LPVOID *)&pOleObject))
    {
        if((pOleObject->GetUserClassID(&clsid)==NOERROR) &&
            IsEqualCLSID(clsid, CLSID_AddrObject))
            fValid=TRUE;
        ReleaseObj(pOleObject);
    }

    AssertSz(fValid, "WHOA! This is not an AddrObject!");
}
#endif


HRESULT HrBuildSelectionAddrInfoList(HWND hwndRE, CHARRANGE *pchrg, LPADRINFOLIST *lplpAdrInfoList)
{

    return NOERROR;
}

HRESULT HrBuildOneSelWabal(LPADRINFO lpAdrInfo, LPWABAL *lplpWabal)
{
    LPWABAL lpWabal=0;
    HRESULT hr;

    if(!lplpWabal)
        return E_INVALIDARG;

    hr=HrCreateWabalObject(&lpWabal);
    if(FAILED(hr)) 
        goto error;

    hr=lpWabal->HrAddEntry(lpAdrInfo);
    if(FAILED(hr)) 
        goto error;

    *lplpWabal=lpWabal;
    lpWabal->AddRef();
    
error:
    ReleaseObj(lpWabal);        
    return hr;
}



#define iswhite(_ch)   (_ch==' ' || _ch=='\t' || _ch=='\n' || _ch=='\r')


/*
 *    ScBuildSelectionAdrlist
 *    
 *    Purpose:
 *        This function will add all the resolved and unresolved
 *        names from the selection in an edit control to an ADRLIST
 *    
 *    Parameters:
 *        ppal            pointer to pointer to ADRLIST
 *        hwndEdit        hwnd of the edit control
 *        pchrg            CHARRANGE of the selection
 *    
 *    Returns:
 *        sc
 */
HRESULT HrBuildSelectionWabal(HWND hwndRE, CHARRANGE *pchrg, LPWABAL *lplpWabal)
{
    ULONG               iOb,
                        cOb,
                        cb,
                        cchBuf = 0,
                        cchSel;
    LPRICHEDITOLE       preole;
    REOBJECT            reobj = {0};
    LPWABAL             lpWabal = NULL;
    HRESULT             hr;
    WCHAR               rgch[cchUnresolvedMax];
    LPWSTR              pbStart = NULL,
                        pbSel;
    BOOL                fTruncated = FALSE;
    PHCI                phci;
    
    Assert(pchrg);
    cchSel = pchrg->cpMax-pchrg->cpMin;

    // Add all the resolved names (stored as OLE objects) from
    // hwndEdit to the ADRLIST
    reobj.cbStruct = sizeof(REOBJECT);
    
    if(!MemAlloc((LPVOID *)&pbStart, (cchSel+1)*sizeof(WCHAR)))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pbSel = pbStart;
    
    hr=HrCreateWabalObject(&lpWabal);
    if(FAILED(hr))
        goto Cleanup;
    
    // if we're building a Wabal, there MUST be some object in the selection!
    Assert((SendMessage(hwndRE, EM_SELECTIONTYPE, 0, 0)&SEL_OBJECT));
    
    phci = (HCI*)GetWindowLongPtr(hwndRE, GWLP_USERDATA);
    AssertSz(phci, "How did we get a richedit without a phci???");
    
    preole = phci->preole;
    AssertSz(preole, "How did we get a phci without a preole???");
    
    // count up the number of objects in the selction, and the number of
    // bytes in them...
    cOb = preole->GetObjectCount();
    for (iOb = 0; iOb < cOb; iOb++)
    {
        hr=preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ);
        if(FAILED(hr))
            goto Cleanup;
        
        if (reobj.cp >= pchrg->cpMax) // out of the selrange...
            break;
        
        if (reobj.cp >= pchrg->cpMin)
        {
            LPPERSIST   ppersist = NULL;
            LPADRINFO   lpAdrInfo = 0;
            
            if (FAILED(hr = reobj.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&ppersist)))
                goto Cleanup;
            
            hr = ((CAddrObj *)ppersist)->HrGetAdrInfo(&lpAdrInfo);
            lpWabal->HrAddEntry(lpAdrInfo);

            ReleaseObj(ppersist);
            if(FAILED(hr))
                goto Cleanup;
        }
        ReleaseObj(reobj.poleobj);
        reobj.poleobj = NULL;
    }
    
    // walk the unresolved text, and parse it up into unresolved names...
    cb = HdrGetRichEditText(hwndRE, pbSel, cchSel, TRUE) + 1;
    //$ BUG - broken for Unicode
    
    // The algorithm below will strip spaces off of the
    // beginning and end of each name
    while (cb--)
    {
        if (*pbSel == L'\t')
            *pbSel = L' ';
        
        if ((*pbSel == L'\0') || (*pbSel == L';') || (*pbSel == L'\r'))
        {
            if(cchBuf)
            {
                LPWSTR psz = rgch + cchBuf - 1;
                while(cchBuf > 0)
                {
                    // Exchange #10168.
                    if((*psz == L' ') || (*psz == L'\t'))
                    {
                        cchBuf--;
                        psz--;
                    }
                    else
                        break;
                }    
            }
            
            if (cchBuf)
            {
                rgch[cchBuf] = L'\0';
                lpWabal->HrAddUnresolved(rgch, (ULONG)-1);
                cchBuf = 0;
            }
        }
        else
        {
            if (((*pbSel != L' ') && (*pbSel != L'\n') && (*pbSel != L'\r')) || cchBuf > 0)
            {
                if (cchBuf < cchUnresolvedMax - 1)
                    rgch[cchBuf++] = *pbSel;
                else
                    fTruncated = TRUE;
            }
        }
        ++pbSel;
    }
    
    
    *lplpWabal=lpWabal;
    lpWabal->AddRef();
    
Cleanup:
    MemFree(pbStart);

    ReleaseObj(lpWabal);
    ReleaseObj(reobj.poleobj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\bodybar.cpp ===
/*
 *    b o d y b a r. c p p
 *    
 *    Purpose:
 *        Implementation of CBodyBar object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      February '97: erican - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#include <pch.hxx>
#include <wininet.h> // INTERNET_MAX_URL_LENGTH
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "bodybar.h"
#include "goptions.h"
#include <inpobj.h>

static const TCHAR s_szBodyBarWndClass[] = TEXT("ThorBodyBarWndClass");

CBodyBar::CBodyBar()
{
    m_ptbSite = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_cSize = 50;
    m_dwBodyBarPos = 0;
    m_pszURL = NULL;
    m_fFirstPos = TRUE;
    m_fDragging = FALSE;
    m_pMehost   = NULL;
    m_cRef      = 1;
}

CBodyBar::~CBodyBar()
{
    if (m_ptbSite)
        m_ptbSite->Release();
    MemFree(m_pszURL);

    MemFree(m_pMehost);
}

HRESULT CBodyBar::HrInit(LPBOOL pfShow)
{
    HKEY    hkey;
    HRESULT hr    = NOERROR;
    BOOL    fShow = FALSE;

    if (AthUserOpenKey(NULL, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
        {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH + 1];
        DWORD cbData = sizeof(szURL);

        szURL[0] = 0;
        if (RegQueryValueEx(hkey, c_szRegBodyBarPath, NULL, NULL, (LPBYTE)szURL, &cbData) == ERROR_SUCCESS && *szURL)
            {
            m_pszURL = StringDup(szURL);
            if (!m_pszURL)
                hr = E_OUTOFMEMORY;
            else
                fShow = TRUE;
            }

        RegCloseKey(hkey);
        }

    m_dwBodyBarPos = DwGetOption(OPT_BODYBARPOS);

    *pfShow = fShow;
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    HRESULT     hr = S_OK;

    if(!lplpObj)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDockingWindow))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IInputObject))
    {
        *lplpObj = (IInputObject *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *lplpObj = (IObjectWithSite *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else
    {
        if (m_pMehost)
            hr = m_pMehost->QueryInterface(riid, lplpObj);
        else
            hr = E_FAIL;
    }

exit:
    return hr;
}

ULONG CBodyBar::AddRef()
{
    return (++m_cRef);
}

ULONG CBodyBar::Release()
{
    ULONG      ulRet = 0;

    --m_cRef;
    ulRet = m_cRef;

    if (m_cRef == 0)
    {
        delete this;
    }

    return ulRet;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::GetWindow(HWND *phwnd)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->GetWindow(phwnd);

    return hr;
}

HRESULT CBodyBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->ContextSensitiveHelp(fEnterMode);

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IDockingWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::ShowDW(BOOL fShow)
{
    HRESULT     hr = S_OK;

    // Make sure we have a site pointer first
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CBodyBar::ShowDW() - Can't show without calling SetSite() first."));
        hr = E_FAIL;
        goto exit;
    }

    if (m_hwnd==NULL && fShow==FALSE)   // noop
    {
        hr = S_OK;
        goto exit;
    }

    if (!m_hwnd)
    {
        WNDCLASSEX  wc;
    
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szBodyBarWndClass, &wc))
        {
            // We need to register the class
            wc.style            = 0;
            wc.lpfnWndProc      = CBodyBar::ExtBodyBarWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            // If BodyBar is nor resizable then show standard cursor
            wc.hCursor          = LoadCursor(NULL, IDC_SIZENS);

            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szBodyBarWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;
            
            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            {
                hr = E_FAIL;
                goto exit;
            }
        }
        
        // Get the handle of the parent window
        IF_FAILEXIT(hr = m_ptbSite->GetWindow(&m_hwndParent));

        // Create the window
        m_hwnd = CreateWindowEx(0,
                                s_szBodyBarWndClass,
                                NULL,
                                WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                                0,
                                0,
                                0,
                                0,
                                m_hwndParent,
                                NULL,
                                g_hInst,
                                (LPVOID)this);
        if (!m_hwnd)
        {
            AssertSz(0, _T("CBodyBar::ShowDW() - Failed to create window."));
            hr = E_FAIL;
            goto exit;
        }           
    }

    // Show or hide the window and resize the parent windows accordingly
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    ResizeBorderDW(NULL, NULL, FALSE);
    m_fFirstPos = (fShow ? m_fFirstPos : TRUE);

exit:    
    return hr;
}

HRESULT CBodyBar::CloseDW(DWORD dwReserved)
{
    // save BodyBar position, if BodyBar was not set from Extension
    SetOption(OPT_BODYBARPOS, &m_dwBodyBarPos, sizeof(m_dwBodyBarPos), NULL, 0);

    if (m_pMehost)
    {
        m_pMehost->HrUnloadAll(NULL, 0);

        m_pMehost->HrClose();
    }
    return S_OK;
}

HRESULT CBodyBar::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkToolbarSite, BOOL fReserved)
{
    RECT rcRequest = { 0, 0, 0, 0 };
    
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CBodyBar::ResizeBorderDW() - Can't resize without calling SetSite() first."));
        return E_FAIL; 
    }

    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
    {
        RECT rcBorder;
        int cTop, cBottom;

        // Calculate position of BodyBar window
        cBottom = GetBodyBar_Bottom();

        if (!prcBorder)
        {
            // Find out how big our parent's border space is
            m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
        }

        if(!m_fFirstPos || (cBottom <= 0))
        {
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
            cBottom = rcRequest.bottom;

        }
        else
        {
            m_cSize = cBottom;    // set new value for m_cSize.
            cBottom  += GetSystemMetrics(SM_CYFRAME);
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
        }                                                                                                                                               



        SetWindowPos(m_hwnd, NULL, prcBorder->left, cTop,  
                     prcBorder->right - prcBorder->left, cBottom, 
                     SWP_NOACTIVATE|SWP_NOZORDER/*|SWP_DRAWFRAME*/);


        m_fFirstPos = FALSE;            // BodyBar window positioned

        // Set new value for BodyBarPos
        m_dwBodyBarPos = (DWORD) MAKELONG(cBottom - GetSystemMetrics(SM_CYFRAME), 0);
    }
    
    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);     
        
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrUIActivate(fActivate);

    return hr;

}

HRESULT CBodyBar::HasFocusIO(void)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrHasFocus();

    return hr;
}    
        

HRESULT CBodyBar::TranslateAcceleratorIO(LPMSG pMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrTranslateAccelerator(pMsg);

    return hr;
}    

////////////////////////////////////////////////////////////////////////
//
//  IObjectWithSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_ptbSite)
        {
        m_ptbSite->Release();
        m_ptbSite = NULL;
        }
    
    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, (void **)&m_ptbSite)))
            return E_FAIL;
        }
    
    return S_OK;    
}

HRESULT CBodyBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleInPlaceSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::OnUIActivate()
{
    HRESULT     hr = E_FAIL;

    if (m_ptbSite)
        UnkOnFocusChangeIS(m_ptbSite, (IInputObject*)this, TRUE);

    if (m_pMehost)
        hr = m_pMehost->OnUIActivate();

    return hr;
}

HRESULT CBodyBar::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    return (E_FAIL);
}

/////////////////////////////////////////////////////////////////////////////
//
// private routines
//
/////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CBodyBar::ExtBodyBarWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CBodyBar *pbb;

    if (msg == WM_NCCREATE)
        {
        pbb = (CBodyBar *)LPCREATESTRUCT(lp)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pbb);
        }
    else
        {
        pbb = (CBodyBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        }

    Assert(pbb);
    return pbb->BodyBarWndProc(hwnd, msg, wp, lp);
}

LRESULT CBodyBar::BodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    OnLButtonDown);                
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      OnMouseMove);                
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      OnLButtonUp);                
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);

        case WM_NCDESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            m_hwnd = NULL;
            break;

        case WM_SETFOCUS:
        {
            HWND hwndBody;

            if (m_pMehost && SUCCEEDED(m_pMehost->HrGetWindow(&hwndBody)) && hwndBody && ((HWND)wParam) != hwndBody)
                SetFocus(hwndBody);
        }
            return 0;    
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL CBodyBar::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL        fRet = FALSE;

    if (!m_pMehost)
        m_pMehost = new CMimeEditDocHost;

    if (!m_pMehost)
        goto exit;

    if (FAILED(m_pMehost->HrInit(hwnd, 0, NULL)))
        goto exit;

    if (FAILED(m_pMehost->HrShow(TRUE)))
        goto exit;

    if (m_pszURL)
        m_pMehost->HrLoadURL(m_pszURL);

    fRet = TRUE;

exit:
    return fRet;
}

void CBodyBar::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc;
    
    int  cyFrame = GetSystemMetrics(SM_CYFRAME);

    rc.left = 0;
    rc.top = cyFrame;
    rc.right = cxClient;
    rc.bottom = cyClient;

    if (m_pMehost)
        m_pMehost->HrSetSize(&rc);
}

void CBodyBar::OnLButtonDown(HWND hwnd, 
                              BOOL fDoubleClick, 
                              int  x, 
                              int  y, 
                              UINT keyFlags)
{
    // Capture the mouse
    SetCapture(m_hwnd);

    // Start dragging
    m_fDragging = TRUE;
}

void CBodyBar::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    RECT rcClient;

    // If we're dragging, update the the window sizes
    if (m_fDragging)
    {
        GetClientRect(m_hwnd, &rcClient);

        // Make sure the tree is still a little bit visible
        if (rcClient.bottom - pt.y > 32)
        {
            m_cSize = rcClient.bottom - pt.y;
            ResizeBorderDW(0, 0, FALSE);
        }
    }

}

void CBodyBar::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    if (m_fDragging)
    {
        ReleaseCapture();
        m_fDragging = FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\bodyutil.h ===
/*
 *    b o d y u t i l . h
 *    
 *    Purpose:
 *        Utility functions for body
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BODYUTIL_H
#define _BODYUTIL_H

interface IHTMLDocument2;
interface IHTMLElement;
interface IOleCommandTarget;

HRESULT HrCmdTgtUpdateToolbar(IOleCommandTarget *pCmdTarget, HWND hwndToolbar);
HRESULT HrConvertHTMLToPlainText(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf);
HRESULT HrCheckForFramesets(LPMIMEMESSAGE pMsg, BOOL fWarnUser);
HRESULT HrStripHTMLClipboardHeader(LPSTREAM pstm, BOOL *pfIsRealCFHTML);
HRESULT HrGetSetCheck(BOOL fSet, IHTMLElement *pElem, VARIANT_BOOL *pfValue);

struct URLSUB {
    LPCTSTR pszId;
    UINT    ids;    
};

HRESULT SubstituteURLs(IHTMLDocument2 *pDoc, const URLSUB *rgUrlSub, int cUrlSub);

#endif //_BODYUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\bodybar.h ===
#ifndef _BODYBAR_H
#define _BODYBAR_H

#include "mehost.h"

// for IBodyOptions
#include "ibodyopt.h"

class CBodyBar :
    public IDockingWindow,
    public IObjectWithSite,
    public IInputObject
{
public:
    CBodyBar();
    virtual ~CBodyBar();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual STDMETHODIMP GetWindow(HWND *phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IDockingWindow
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    // IInputObject
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpmsg);

    // overrides of CBody
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);

    HRESULT HrInit(LPBOOL pfShow);

	int		GetBodyBar_Top()			{ return( (int) HIWORD(m_dwBodyBarPos));}
	int		GetBodyBar_Bottom()			{ return( (int) LOWORD(m_dwBodyBarPos));}
	
protected:
    LRESULT BodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ExtBodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void    OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);

private:
    IDockingWindowSite *m_ptbSite;
    HWND                m_hwnd;
    HWND                m_hwndParent;
    int                 m_cSize;
	DWORD				m_dwBodyBarPos;
    LPTSTR              m_pszURL;
	BOOL				m_fFirstPos;
    BOOL                m_fDragging;
    CMimeEditDocHost    *m_pMehost;
    ULONG               m_cRef;
};

#endif // _BODYBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\bodyutil.cpp ===
/*
 *    b o d y u t i l . c p p
 *    
 *    Purpose:
 *        utility functions for body
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "demand.h"
#include <resource.h>
#include "note.h"
#include "htmlstr.h"
#include "bodyutil.h"
#include "mshtmcid.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "oleutil.h"
#include "shlwapi.h"
#include "error.h"
#include "url.h"
#include "menures.h"

ASSERTDATA


/*
 *  t y p e d e f s
 */


/*
 *  m a c r o s
 */


/*
 *  c o n s t a n t s
 */


/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
BOOL FrameWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


/*
 *  f u n c t i o n s
 */

HRESULT HrCmdTgtUpdateToolbar(LPOLECOMMANDTARGET pCmdTarget, HWND hwndToolbar)
{
    HRESULT hr;
    OLECMD  rgEditCmds[]={{OLECMDID_CUT, 0},
                          {OLECMDID_COPY, 0},
                          {OLECMDID_COPY, 0},
                          {OLECMDID_PASTE, 0},
                          {OLECMDID_SELECTALL, 0},
                          {OLECMDID_UNDO, 0},
                          {OLECMDID_REDO, 0}};

    int     rgids[]     ={  ID_CUT,
                            ID_NOTE_COPY,
                            ID_COPY,
                            ID_PASTE,
                            ID_SELECT_ALL,
                            ID_UNDO,
                            ID_REDO};    

    if (!pCmdTarget || !hwndToolbar)
        return E_INVALIDARG;
    
    hr=pCmdTarget->QueryStatus(NULL, sizeof(rgEditCmds)/sizeof(OLECMD), rgEditCmds, NULL);
    if (!FAILED(hr))
        {
        for(int i=0; i<sizeof(rgEditCmds)/sizeof(OLECMD); i++)
            SendMessage(hwndToolbar, TB_ENABLEBUTTON, rgids[i], MAKELONG(rgEditCmds[i].cmdf & OLECMDF_ENABLED,0));
        }   
    return hr;
}

HRESULT HrConvertHTMLToPlainText(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf)
{
    HRESULT     hr;
    LPUNKNOWN   pUnkTrident=0;
    LPSTREAM    pstmPlain=0;
    
    if (!ppstm)
        return E_INVALIDARG;

    hr = MimeEditDocumentFromStream(pstmHtml, IID_IUnknown, (LPVOID *)&pUnkTrident);
    if (FAILED(hr))
        goto error;

    hr = HrGetDataStream(pUnkTrident, cf, &pstmPlain);
    if (FAILED(hr))
        goto error;

    *ppstm = pstmPlain;
    pstmPlain->AddRef();

error:
    ReleaseObj(pUnkTrident);
    ReleaseObj(pstmPlain);
    return hr;
}





#define CCHMAX_FRAMESEARCH  4096

HRESULT HrCheckForFramesets(LPMIMEMESSAGE pMsg, BOOL fWarnUser)
{
    TCHAR       rgchHtml[CCHMAX_FRAMESEARCH + 1];
    TCHAR       rgchWarn[CCHMAX_STRINGRES];
    LPSTREAM    pstmHtml=0,
                pstmWarning=0;
    ULONG       cb=0;    
    HRESULT     hr=S_OK;
    HBODY       hBody;

    if (!pMsg)      // no work
        return S_OK;

    pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstmHtml, &hBody);

    if (pstmHtml==NULL)
        goto cleanup;

    HrRewindStream(pstmHtml);

    pstmHtml->Read(rgchHtml, CCHMAX_FRAMESEARCH, &cb);
    rgchHtml[cb]=0;

    if (!StrStrIA(rgchHtml, _TEXT("<FRAMESET")))
        goto cleanup;

    if (fWarnUser)
        {
        // if send current document or forwarding, then we give the user a chance
        if (DialogBox(g_hLocRes, MAKEINTRESOURCE(iddFrameWarning), g_hwndInit, (DLGPROC)FrameWarnDlgProc)==IDOK)
            {
            hr = S_READONLY;
            goto cleanup;
            }
        }

    // if the body contains a frameset tag, let's make this an attachment
    // and set the body to some warning
    hr = MimeOleCreateVirtualStream(&pstmWarning);
    if (FAILED(hr))
        goto cleanup;

    if (!LoadString(g_hLocRes, idsHtmlNoFrames, rgchWarn, ARRAYSIZE(rgchWarn)))
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    hr = pstmWarning->Write(rgchWarn, lstrlen(rgchWarn), NULL);
    if (FAILED(hr))
        goto cleanup;

    hr = pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmWarning, NULL);
    if (FAILED(hr))
        goto cleanup;

    hr = pMsg->AttachObject(IID_IStream, pstmHtml, &hBody);
    if (FAILED(hr))
        goto cleanup;

    hr = MimeOleSetBodyPropA(pMsg, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, STR_MIME_TEXT_HTML);
    if (FAILED(hr))
        goto cleanup;

cleanup:
    ReleaseObj(pstmHtml);
    ReleaseObj(pstmWarning);
    return hr;
}



BOOL FrameWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_COMMAND)
        {
        int id = GET_WM_COMMAND_ID(wParam, lParam);

        if (id == IDOK || id  == IDCANCEL)
            {
            EndDialog(hwnd, id);
            return TRUE;
            }
        }
    return FALSE;
}


static const CHAR c_szStartHTML[] = "StartHTML:";

HRESULT HrStripHTMLClipboardHeader(LPSTREAM pstm, BOOL *pfIsRealCFHTML)
{
    CHAR    rgch[4096];
    LPSTR   lpsz;
    ULONG   cb,
            uPosRead,
            uPosWrite,
            cbNewSize;
    ULARGE_INTEGER  ui;
    HRESULT hr=S_OK;

    // scan the first 200 bytes for "StartHTML:" in the pre-block
    *rgch=0;
    pstm->Read(rgch, 200, &cb);
    rgch[cb] = 0;

    if (pfIsRealCFHTML)
        *pfIsRealCFHTML = FALSE;
    
    HrGetStreamSize(pstm, &cbNewSize);

    lpsz = StrStrIA(rgch, c_szStartHTML);
    if (!lpsz)
        return S_OK;

    cb = StrToIntA(lpsz + ARRAYSIZE(c_szStartHTML)-sizeof(CHAR));
    if (cb==0 || cb > cbNewSize)   // sanity check. Offset can't be bigger than the stream!
        return S_OK;

    if (pfIsRealCFHTML)
        *pfIsRealCFHTML = TRUE;

    // cb contains the offset of the HTML. Start shifting the data left
    uPosRead = cb;
    uPosWrite = 0;
    cbNewSize-=cb;  // calc new length of stream

    while(cb)
        {
        hr = HrStreamSeekSet(pstm, uPosRead);
        if (FAILED(hr))
            goto error;

        hr = pstm->Read(rgch, ARRAYSIZE(rgch), &cb);
        if (FAILED(hr))
            goto error;

        hr = HrStreamSeekSet(pstm, uPosWrite);
        if (FAILED(hr))
            goto error;

        hr = pstm->Write(rgch, cb, NULL);
        if (FAILED(hr))
            goto error;

        uPosRead+=cb;
        uPosWrite+=cb;
        }

    // force the new stream length
    ui.LowPart = cbNewSize;
    ui.HighPart = 0;
    
    hr = pstm->SetSize(ui);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}



HRESULT SubstituteURLs(IHTMLDocument2 *pDoc, const URLSUB *rgUrlSub, int cUrlSub)
{
    IHTMLElement        *pElem;
    IHTMLAnchorElement  *pAnchor;
    BSTR                 bstr;
    TCHAR                szURL[INTERNET_MAX_URL_LENGTH];
    int                  i;
    HRESULT              hr = S_OK;

    for (i = 0; i < cUrlSub; i++)
        {
        if (SUCCEEDED(hr = URLSubLoadStringA(rgUrlSub[i].ids, szURL, ARRAYSIZE(szURL), URLSUB_ALL, NULL)))
            {
            if (SUCCEEDED(hr = HrLPSZToBSTR(szURL, &bstr)))
                {
                if (SUCCEEDED(hr = HrGetElementImpl(pDoc, rgUrlSub[i].pszId, &pElem)))
                    {
                    if (SUCCEEDED(hr = pElem->QueryInterface(IID_IHTMLAnchorElement, (LPVOID*)&pAnchor)))
                        {
                        hr = pAnchor->put_href(bstr);
                        pAnchor->Release();
                        }
                    pElem->Release();
                    }
                SysFreeString(bstr);
                }
            }
        }
    return hr;
}

HRESULT HrGetSetCheck(BOOL fSet, IHTMLElement *pElem, VARIANT_BOOL *pfValue)
{
    HRESULT                     hr;
    IHTMLOptionButtonElement   *pCheck = NULL;

    Assert(pfValue);

    pElem->QueryInterface(IID_IHTMLOptionButtonElement, (LPVOID*)&pCheck);
    if (pCheck)
        {
        if (fSet)
            {
            hr = pCheck->put_checked(*pfValue);
            }
        else
            {
            hr = pCheck->get_checked(pfValue);
            }
        pCheck->Release();
        }
    else
        hr = E_FAIL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\frntbody.h ===
#ifndef _FRNTBODY_H
#define _FRNTBODY_H

// for IBodyOptions
#include "mehost.h"
#include "hlink.h"

interface INotify;
interface IAthenaBrowser;
class COETag;

class CFrontBody :
    public CMimeEditDocHost,
    public IHlinkFrame,
    public IServiceProvider,
    public IElementBehaviorFactory
{
public:
    CFrontBody(FOLDERTYPE ftType, IAthenaBrowser *pBrowser);
    virtual ~CFrontBody();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IHlinkFrame
    virtual HRESULT STDMETHODCALLTYPE SetBrowseContext(LPHLINKBROWSECONTEXT phlbc);
    virtual HRESULT STDMETHODCALLTYPE GetBrowseContext(LPHLINKBROWSECONTEXT  *pphlbc);
    virtual HRESULT STDMETHODCALLTYPE Navigate(DWORD grfHLNF, LPBC pbc, LPBINDSTATUSCALLBACK pbsc, LPHLINK phlNavigate);
    virtual HRESULT STDMETHODCALLTYPE OnNavigate(DWORD grfHLNF, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    virtual HRESULT STDMETHODCALLTYPE UpdateHlink(ULONG uHLID, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // IOleInPlaceFrame
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR pszW);

    // CDocHost overrides
    virtual void OnDocumentReady();
    virtual HRESULT STDMETHODCALLTYPE HrClose();

    // IElementBehaviorFactory
    virtual HRESULT STDMETHODCALLTYPE FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior);

    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);

    HRESULT HrInit(HWND hwnd);
    HRESULT HrLoadPage();

private:
    IAthenaBrowser      *m_pBrowser;
    LPHLINKBROWSECONTEXT m_phlbc;
    HWND                 m_hwndOwner;
    DWORD                m_dwAdvise;
    COETag              *m_pTag;
    BOOL                m_fOEFrontPage;

    HRESULT _CreateNewAccount(BOOL fMail);
};

#endif // _FRNTBODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\header.h ===
#ifndef _HEADER_H
#define _HEADER_H


#include <richedit.h>
#ifndef _RICHOLE_H //hack as richole.h has no #ifdef around it
#define _RICHOLE_H
#include <richole.h>
#endif


#include <mimeole.h>
#include <wells.h>
#include <addrobj.h>
#include "iheader.h"
#include <envelope.h>
#include <mso.h>
#include "secutil.h"
#include "tom.h"
#include "reutil.h"

//
// Forwards
//
interface IImnAccount;

class CAttMan;
//
// Structures and other defintions
//

enum
{   // templates for types of note (defines header layout)
    NT_SENDNOTE=0,
    NT_READNOTE,
    NT_NOTECOUNT
};

enum
{
    VCardFALSE=0,
    VCardTRUE,
    VCardDONTKNOW
};

BOOL FHeader_Init(BOOL fInit);
HRESULT CreateInstance_Envelope(IUnknown* pUnkOuter,  IUnknown** ppUnknown);

void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace);
DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection);


// enumeration of icons in the button image list
enum
{
    iimlHdrAddrRolodex=0,
    iimlHdrNewsRolodex,
    //iimlHdrNext,
};


enum    // HCINFO.dwFlags
{
    HCF_MULTILINE   =0x0001,
    HCF_READONLY    =0x0002,
    HCF_HASBUTTON   =0x0004,
    HCF_ADVANCED    =0x0008,
    HCF_ADDRWELL    =0x0010,
    HCF_USECHARSET  =0x0020,
    HCF_OPTIONAL    =0x0040,
    HCF_HIDDEN      =0x0080,
    HCF_COMBO       =0x0100,
    HCF_BORDER      =0x0200,
    HCF_ATTACH      =0x0400,
    HCF_ADDRBOOK    =0x0800,
    HCF_NEWSPICK    =0x1000,
};

enum
{
    AC_IGNORE       =0x01,
    AC_SELECTION    =0x02
};

// header control info structure
typedef struct tagHCI
{
    DWORD           dwFlags,
                    dwOpt;                      // valid if HCF_OPTIONAL
    int             idEdit,                     // id of well
                    idBtn,                      // id of button (if 
                    idsLabel,                   // id used for label of well
                    idsEmpty,                   // id of string used for empty well
                    idsTT;                      // string for tooltip of the well

    DWORD           dwACFlags;                  // valid if HCF_ADDRWELL
    BOOL            fEmpty;                     // state info

    LPRICHEDITOLE   preole;                     // oleinterface; MUST ZeroInit
    ITextDocument  *pDoc;                       // RichEdit interface for text document
    int             cy,                         // y pos of the control (and hence the label)
                    height,                     // y size of control (used when growing control)
                    strlen,                     // strlen of label
                    strlenEmpty;                // strlen of the empty string
    WCHAR           sz[cchHeaderMax+1],         // string for label
                    szEmpty[cchHeaderMax+1];    // string for empty state
} HCI, *PHCI;

class CNoteHdr :
    public IPersistMime,
    public IOleCommandTarget,
    public IHeader,
    public IMsoEnvelope,
    public IMsoComponent,
    public IDropTarget,
    public IFontCacheNotify
{
public:
    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IPersistMime
    HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE);
    HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE, DWORD);
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IHeader
    HRESULT STDMETHODCALLTYPE Init(IHeaderSite* pHeaderSite, HWND hwndParent);
    HRESULT STDMETHODCALLTYPE SetRect(LPRECT);
    HRESULT STDMETHODCALLTYPE GetRect(LPRECT);
    HRESULT STDMETHODCALLTYPE SetPriority(UINT pri);
    HRESULT STDMETHODCALLTYPE GetPriority(UINT* ppri);
    HRESULT STDMETHODCALLTYPE ShowAdvancedHeaders(BOOL fOn);
    HRESULT STDMETHODCALLTYPE FullHeadersShowing(void);
    HRESULT STDMETHODCALLTYPE ChangeLanguage(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE GetTitle(LPWSTR lpszTitle, ULONG cch);
    HRESULT STDMETHODCALLTYPE UpdateRecipientMenu(HMENU hmenu);
    HRESULT STDMETHODCALLTYPE SetInitFocus(BOOL fSubject);
    HRESULT STDMETHODCALLTYPE SetVCard(BOOL fFresh);
    HRESULT STDMETHODCALLTYPE IsSecured();
    HRESULT STDMETHODCALLTYPE IsHeadSigned();
    HRESULT STDMETHODCALLTYPE ForceEncryption(BOOL *fEncrypt, BOOL fSet);
    HRESULT STDMETHODCALLTYPE AddRecipient(int idOffset);
    HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    HRESULT STDMETHODCALLTYPE SetFlagState(MARK_TYPE markType);
    HRESULT STDMETHODCALLTYPE WMCommand(HWND, int, WORD);
    HRESULT STDMETHODCALLTYPE OnDocumentReady(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE DropFiles(HDROP hDrop, BOOL fMakeLinks);
    HRESULT STDMETHODCALLTYPE HrGetAttachCount(ULONG *pcAttMan);
    HRESULT STDMETHODCALLTYPE HrIsDragSource();
    HRESULT STDMETHODCALLTYPE HrGetAccountInHeader(IImnAccount **ppAcct);

    // IDropTarget
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IMsoEnvelope
    HRESULT STDMETHODCALLTYPE Init(IUnknown* punk, IMsoEnvelopeSite* pesit, DWORD grfInit);
    HRESULT STDMETHODCALLTYPE SetParent(HWND hwndParent);
    HRESULT STDMETHODCALLTYPE Resize(LPCRECT prc);
    HRESULT STDMETHODCALLTYPE Show(BOOL fShow);
    HRESULT STDMETHODCALLTYPE SetHelpMode(BOOL fEnter);
    HRESULT STDMETHODCALLTYPE Save(IStream* pstm, DWORD grfSave);
    HRESULT STDMETHODCALLTYPE GetAttach(const WCHAR* wszName,IStream** ppstm);
    HRESULT STDMETHODCALLTYPE SetAttach(const WCHAR* wszName,const WCHAR* szFile,IStream** ppstm,DWORD* pgrfAttach);
    HRESULT STDMETHODCALLTYPE NewAttach(const WCHAR* pwzName,DWORD grfAttach);
    HRESULT STDMETHODCALLTYPE SetFocus(DWORD grfFocus);
    HRESULT STDMETHODCALLTYPE GetHeaderInfo(ULONG dispid, DWORD grfHeader, void **ppv);
    HRESULT STDMETHODCALLTYPE SetHeaderInfo(ULONG dispid, const void *pv);
        
    HRESULT STDMETHODCALLTYPE IsDirty();
    HRESULT STDMETHODCALLTYPE GetLastError(HRESULT hr, WCHAR __RPC_FAR *wszBuf, ULONG cchBuf);
    HRESULT STDMETHODCALLTYPE DoDebug(DWORD grfDebug);

    // IMsoComponent
    BOOL STDMETHODCALLTYPE FDebugMessage(HMSOINST, UINT, WPARAM, LPARAM);
    BOOL STDMETHODCALLTYPE FPreTranslateMessage(MSG *);
    void STDMETHODCALLTYPE OnEnterState(ULONG, BOOL);
    void STDMETHODCALLTYPE OnAppActivate(BOOL, DWORD);
    void STDMETHODCALLTYPE OnLoseActivation();
    void STDMETHODCALLTYPE OnActivationChange(IMsoComponent *, BOOL, const MSOCRINFO *, BOOL, const MSOCHOSTINFO *, DWORD);
    BOOL STDMETHODCALLTYPE FDoIdle(DWORD grfidlef);
    BOOL STDMETHODCALLTYPE FContinueMessageLoop(ULONG, void *, MSG *);
    BOOL STDMETHODCALLTYPE FQueryTerminate(BOOL);
    void STDMETHODCALLTYPE Terminate();
    HWND STDMETHODCALLTYPE HwndGetWindow(DWORD, DWORD);

    // IFontCacheNotify
    HRESULT STDMETHODCALLTYPE OnPreFontChange(void);
    HRESULT STDMETHODCALLTYPE OnPostFontChange(void);

    static LRESULT EXPORT_16 CALLBACK ExtCNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK EditSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK BtnSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK IMESubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PHCI phci);

    CNoteHdr();
    virtual ~CNoteHdr();

private:
    ULONG           m_cRef,
                    m_cHCI,
                    m_cAccountIDs,
                    m_cxLeftMargin;
    BOOL            m_fSendImmediate,//as opposed to sendlater.
                    m_fAdvanced,
                    m_fInSize,
                    m_fDirty,
                    m_fVCard,
                    m_fVCardSave,
                    m_fAutoComplete,
                    m_fMail,
                    m_fSecurityInited,
                    m_fThisHeadDigSigned,
                    m_fThisHeadEncrypted,
                    m_fSignTrusted,
                    m_fEncryptionOK,
                    m_fDigSigned,
                    m_fEncrypted,
                    m_fFlagged,
                    m_fOfficeInit,
                    m_fUIActive,
                    m_fResizing,
                    m_fHandleChange,
                    m_fAddressesChanged,
                    m_fForceEncryption,
                    m_fSkipLayout,
                    m_fStillLoading,
                    m_fDropTargetRegister,
                    m_fShowedUnicodeDialog;
    HWND            m_hwndToolbar,
                    m_hwnd,
                    m_hwndParent,
                    m_hwndTT,
                    m_hwndLastFocus,
                    m_hwndRebar;
    UINT            m_ntNote;
	DWORD           m_dwComponentMgrID,
                    m_dwFontNotify,
                    m_dwIMEStartCount;
    RECT            m_rcCurrentBtn;
    HWND            m_hwndOldCapture;
    WORD            m_wNoteType;
    INT             m_dxTBOffset;
    int             m_pri,
                    m_iCurrComboIndex,
                    m_iUnicodeDialogResult;
    LPSTR          *m_ppAccountIDs;
    LPWSTR          m_lpszSecurityField,
                    m_pszRefs;
    TCHAR           m_szLastLang[cchHeaderMax+1];
    PHCI            m_rgHCI;
    CAddrWells     *m_pAddrWells;
    LPWABAL         m_lpWabal;
    SECSTATE        m_SecState;
    HCHARSET        m_hCharset;
    LPMAPITABLE     m_pTable;
    LPWAB           m_lpWab;
    CAttMan        *m_lpAttMan;
    MARK_TYPE       m_MarkType;

    CLIPFORMAT      m_cfAccept;
    DWORD           m_dwDragType,
                    m_grfKeyState,
                    m_dwCurrentBtn,
                    m_dwClickedBtn,
                    m_cCapture,
                    m_dwEffect;


    IHeaderSite            *m_pHeaderSite; // valid if athena hosts header
    IMsoEnvelopeSite       *m_pEnvelopeSite; // valid if Office hosts header
    IImnAccount            *m_pAccount;
    HINITREF                m_hInitRef;     // Application reference count
    IMsoComponentManager   *m_pMsoComponentMgr;
    IMimeMessage           *m_pMsgSend,
                           *m_pMsg;
    HIMAGELIST              m_himl;
    BOOL                    m_fPoster;
private:
    LRESULT CALLBACK CNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL IsReplyNote();
    BOOL WMCreate();
    BOOL WMNotify(WPARAM wParam, LPARAM lParam);
    void WMPaint();
    void OnDestroy();
    void OnNCDestroy();
    BOOL PostWMCreate();
    void OnButtonClick(int idBtn);
    void SetReferences(LPMIMEMESSAGE pMsg);
    void HrPickGroups(int idWell, BOOL fFollowUpTo);

    // VCard
    HRESULT HrShowVCardProperties(HWND hwnd);
    HRESULT HrShowVCardCtxtMenu(int x, int y);
    HRESULT HrGetVCardName(LPTSTR pszName, DWORD cch);
    HRESULT HrOnOffVCard();
    HRESULT _AttachVCard(IMimeMessage *pMsg);

    HRESULT HrInit(IMimeMessage *pMsg);
    HRESULT HrFShowHeader(PHCI phci);
    HRESULT HrAutoComplete(HWND hwnd, PHCI pHCI);
    HRESULT HrUpdateCharSetFonts(HCHARSET hCharset, BOOL fUpdateFields);
    HRESULT HrInitFieldList();
    HRESULT HrFreeFieldList();
    HRESULT HrCheckNames(BOOL fSilent, BOOL fSetCheckedFlag);
    HRESULT HrClearUndoStack();
    HRESULT HrNewsSave(LPMIMEMESSAGE pMsg, CODEPAGEID cpID, BOOL fCheckConflictOnly);
    HRESULT HrCopyNonRecipientHeaders(LPMIMEMESSAGE pMsg);
    HRESULT HrOfficeLoad();
    HRESULT HrAutoAddToWAB();
    HRESULT HrSetPri(LPMIMEMESSAGE pMsg);
    HRESULT HrSetupNote(LPMIMEMESSAGE pMsg);
    HRESULT HrSetMailRecipients(LPMIMEMESSAGE pMsg);
    HRESULT HrSetNewsRecipients(LPMIMEMESSAGE pMsg);
    HRESULT HrSetNewsWabal(LPMIMEMESSAGE pMsg, LPWSTR   pwszCC);
    HRESULT HrSetReplySubject(LPMIMEMESSAGE pMsg, BOOL fReply);
    HRESULT HrQueryToolbarButtons(DWORD dwFlags, const GUID *pguidCmdGroup, OLECMD* pOleCmd);
    HRESULT HrGetFieldText(LPWSTR* ppszText, int idHdrCtrl);
    HRESULT HrGetFieldText(LPWSTR* ppszText, HWND hwnd);
    HRESULT ResolveGroupNames(HWND hwnd, int idField, FOLDERID idServer, BOOL fPosterAllowed, BOOL *fOneOrMoreNames);
    HRESULT HrAddSender();
    HRESULT HrAddAllOnToList();
    HRESULT HrCheckGroups(BOOL fPosting);
    HRESULT HrSend();
    HRESULT HrIsCoolToSendHTML();
    HRESULT HrCheckSubject(BOOL fMail);
    HRESULT HrCheckSendInfo();
    HRESULT HrFillMessage(IMimeMessage *pMsg);
    HRESULT HrPickNames(int iwell);
    HRESULT HrUpdateCachedHeight(HWND hwndEdit, RECT *prc);
    HRESULT HrUpdateTooltipPos();
    HRESULT HrOfficeInitialize(BOOL fInit);
    HRESULT HrGetVCardState(ULONG* pCmdf);
    HRESULT HrFillToolbarColor(HDC hdc);
    HRESULT HrViewContacts();

    void    HeaderCapture();
    void    HeaderRelease(BOOL fForce);
    void    ShowControls();
    void    RelayToolTip(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    void    SetPosOfControls(int headerWidth, BOOL fChangeVisibleStates);
    void    SetDirtyFlag();
    int     GetRightMargin(BOOL fMax);
    BOOL    IsReadOnly();


    // security
    HRESULT HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType);
    HRESULT HrInitSecurity();
    HRESULT HrHandleSecurityIDMs(BOOL fDigsign);
    HRESULT HrSaveSecurity(LPMIMEMESSAGE pMsg);
    HRESULT HrUpdateSecurity(LPMIMEMESSAGE pMsg=NULL);

    LPWSTR  SzGetDisplaySec(LPMIMEMESSAGE pMsg, int *pidsLabel);
    HACCEL  GetAcceleratorTable();
    BOOL    FDoCutCopyPaste(int wmCmd);

    HRESULT ShowEnvOptions();
    void    ReLayout();
    HRESULT UnloadAll();
    void    InvalidateRightMargin(int additionalWidth);
    void    InvalidateStatus();
    DWORD   GetButtonUnderMouse(int x, int y);
    void    GetButtonRect(DWORD iBtn, RECT *prc);
    int     BeginYPos();
    void    HandleButtonClicks(int x, int y, int iBtn);
    void    _UpdateTextFields(BOOL fSetWabal);
    void    _SetEmptyFieldStrings(void);
    void    _AddRecipTypeToMenu(HMENU hmenu);
    HRESULT _CreateEnvToolbar();
    HRESULT _LoadFromStream(IStream *pstm);
    HRESULT _SetButtonText(int idmCmd, LPSTR pszText);
    HRESULT _ConvertOfficeCmdIDToOE(LPDWORD pdwCmdId);
    HRESULT _UIActivate(BOOL fActive, HWND hwndFocus);
    HWND _GetNextDlgTabItem(HWND hwndDlg, HWND hwndFocus, BOOL fShift);
    HRESULT _HandsOffComponentMgr();    
    int _GetLeftMargin();
    HIMAGELIST _CreateToolbarBitmap(int idb, int cx);
    HRESULT _ClearDirtyFlag();
    HRESULT _RegisterAsDropTarget(BOOL fOn);
    HRESULT _RegisterWithFontCache(BOOL fOn);
    HRESULT _RegisterWithComponentMgr(BOOL fOn);
    HRESULT _GetMsoBody(ULONG uBody, LPSTREAM *ppstm);
#ifdef YST
    HRESULT _CheckMsoBodyCharsetConflict(CODEPAGEID cpID);
#endif
    HRESULT _UnicodeSafeSave(IMimeMessage *pMsg, BOOL fCheckConflictOnly);
};

void GetUSKeyboardLayout(HKL *phkl);

// note header WM_COMMAND parent notifications
#define NHD_FIRST           0
#define NHD_SIZECHANGE      (NHD_FIRST + 1)

#endif //_HEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\frntbody.cpp ===
/*
 *    f r n t b o d y . c p p
 *    
 *    Purpose:
 *        Implementation of CFrontBody object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      April '97: erican - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#include <pch.hxx>
#include <wininet.h>
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "browser.h"
#include "frntbody.h"
#include <wininet.h>
#include <mshtml.h>
#include <goptions.h>
#include <thormsgs.h>
#include <spoolapi.h>
#include <notify.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "url.h"
#include "bodyutil.h"
#include "mimeutil.h"
#include "instance.h"
#include "storutil.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"
#include "htmlhelp.h"
#include "shared.h"
#include "oetag.h"
#include "subscr.h"

#define IsBrowserMode() ( g_dwBrowserFlags & 0x07 )

CFrontBody::CFrontBody(FOLDERTYPE ftType, IAthenaBrowser *pBrowser) : CMimeEditDocHost( /*MEBF_NOSCROLL*/ 0)  //$27661: turn off noscroll
{

    if (pBrowser)
    {
        m_pBrowser = pBrowser;
        m_pBrowser->AddRef();
    }

    m_phlbc = NULL;
    m_hwndOwner = NULL;
    m_pTag = 0;
    m_fOEFrontPage = TRUE;
}

CFrontBody::~CFrontBody()
{
    if (m_pTag)
    {
        m_pTag->OnFrontPageClose();
        m_pTag->Release();
        m_pTag = NULL;
    }
    SafeRelease(m_pBrowser);
    SafeRelease(m_phlbc);
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IHlinkFrame))
        {
        *lplpObj = (IHlinkFrame *)this;
        AddRef();
        return NOERROR;
        }

    if (IsEqualIID(riid, IID_IServiceProvider))
        {
        *lplpObj = (IServiceProvider *)this;
        AddRef();
        return NOERROR;
        }

    if (IsEqualIID(riid, IID_IElementBehaviorFactory))
        {
        *lplpObj = (IElementBehaviorFactory *)this;
        AddRef();
        return NOERROR;
        }

    return CMimeEditDocHost::QueryInterface(riid, lplpObj);
}

ULONG CFrontBody::AddRef()
{
    return CMimeEditDocHost::AddRef();
}

ULONG CFrontBody::Release()
{
    return CMimeEditDocHost::Release();
}


////////////////////////////////////////////////////////////////////////
//
//  IHlinkFrame
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::SetBrowseContext(LPHLINKBROWSECONTEXT phlbc)
{
    ReplaceInterface(m_phlbc, phlbc);
    return NOERROR;
}

HRESULT CFrontBody::GetBrowseContext(LPHLINKBROWSECONTEXT  *pphlbc)
{
    if (pphlbc == NULL)
        return E_INVALIDARG;

    *pphlbc = m_phlbc;
    if (m_phlbc)
        m_phlbc->AddRef();
    return NOERROR;
}

static const struct {
    LPCWSTR pwszCmd;
    UINT    uCmd;
} s_rgCmdLookup[] = 
{
    { L"readMail",       ID_GO_INBOX },
    { L"newMessage",     ID_NEW_MSG_DEFAULT },
    { L"readNews",       ID_GO_NEWS },
    { L"subscribeNews",  ID_NEWSGROUPS },
    { L"addrBook",       ID_ADDRESS_BOOK },
    { L"findAddr",       ID_FIND_PEOPLE },
    { L"newNewsAccount", ID_CREATE_NEWS_ACCOUNT },
    { L"newMailAccount", ID_CREATE_MAIL_ACCOUNT },
    { L"help",           ID_HELP_CONTENTS},
    { L"newNewsMessage", ID_NEW_NEWS_MESSAGE},
    { L"newUser",        ID_NEW_IDENTITY},
    { L"switchUser",     ID_SWITCH_IDENTITY},
    { L"noop",           ID_NOOP},
    { L"findMessage",    ID_FIND_MESSAGE},
    { L"logoff",         ID_LOGOFF_IDENTITY},
    { L"manageUser",     ID_MANAGE_IDENTITIES},

};

HRESULT CFrontBody::Navigate(DWORD grfHLNF, LPBC pbc, LPBINDSTATUSCALLBACK pbsc, LPHLINK phlNavigate)
{ 
    HRESULT         hr;
    LPWSTR          pwszURL = NULL,
                    pwszCmd = NULL;
    HINSTANCE       hInst;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszErr[CCHMAX_STRINGRES+INTERNET_MAX_URL_LENGTH+1];
    CStringParser   sp;

    IF_FAILEXIT(hr = phlNavigate->GetStringReference(HLINKGETREF_ABSOLUTE, &pwszURL, NULL));
    if (pwszURL)
    {
        if (!StrCmpNIW(pwszURL, L"oecmd:", 6))
        {
            pwszCmd = pwszURL + 6;
            for (int i = 0; i < ARRAYSIZE(s_rgCmdLookup); i++)
            {
                if (!StrCmpNIW(pwszCmd, s_rgCmdLookup[i].pwszCmd, lstrlenW(s_rgCmdLookup[i].pwszCmd)))
                {
                    switch (s_rgCmdLookup[i].uCmd)
                    {
                        case ID_HELP_CONTENTS:
                        {
                            LPSTR pszCmd = NULL;

                            pwszCmd += ARRAYSIZE(s_rgCmdLookup[i].pwszCmd);
                            IF_NULLEXIT(pszCmd = PszToANSI(CP_ACP, pwszCmd));

                            sp.Init(pszCmd, lstrlen(pszCmd), 0);
                            sp.ChParse("(");
                            sp.ChParse(")");
                            OEHtmlHelp(GetTopMostParent(m_hwnd), c_szCtxHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (sp.CchValue() ? sp.PszValue() : NULL));
                            MemFree(pszCmd);
                            break;
                        }
                        
                        case ID_CREATE_MAIL_ACCOUNT:
                        case ID_CREATE_NEWS_ACCOUNT:
                            _CreateNewAccount(s_rgCmdLookup[i].uCmd == ID_CREATE_MAIL_ACCOUNT);
                            // handle account creation internally
                            break;
                        
                        default:
                            PostMessage(m_hwndOwner, WM_COMMAND, s_rgCmdLookup[i].uCmd, 0L);
                    }
                    
                    SetStatusText(NULL);
                    hr = S_OK;
                    goto exit;
                }
            }
            AssertSz(0, "Navigation request to unknown oecmd link");
            hr = E_FAIL;
        }
        else
        {
            LPSTR   pszURL = NULL;
            TCHAR   sz[CCHMAX_STRINGRES],
                    szErr[CCHMAX_STRINGRES+INTERNET_MAX_URL_LENGTH+1];

            IF_NULLEXIT(pszURL = PszToANSI(CP_ACP, pwszURL));

            hInst = ShellExecute(m_hwndOwner, NULL, pszURL, NULL, NULL, SW_SHOW);
            if (hInst <= (HINSTANCE)HINSTANCE_ERROR)
            {
                LoadString(g_hLocRes, idsErrURLExec, sz, ARRAYSIZE(sz));
                wsprintf(szErr, sz, pszURL);
                
                // load title into wsz. We don't use AthMsgBox as our string maybe too long. AthMsgBox
                // will truncate at CCHMAX_STRINGRES.
                LoadString(g_hLocRes, idsAthena, sz, ARRAYSIZE(sz));
                MessageBox(m_hwndOwner, szErr, sz, MB_OK);
            }
            MemFree(pszURL);
        }
    }

exit:
    if (pwszURL)
        CoTaskMemFree(pwszURL);
    return hr;
}

HRESULT CFrontBody::OnNavigate(DWORD grfHLNF, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    return E_NOTIMPL;
}

HRESULT CFrontBody::UpdateHlink(ULONG uHLID, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL;
}
 
////////////////////////////////////////////////////////////////////////
//
//  IServiceProvider
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IHlinkFrame))
        return QueryInterface(riid, ppvObject);

    if (IsEqualGUID(guidService, IID_IHlinkFrame))
        return QueryInterface(riid, ppvObject);

    if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
        return QueryInterface(riid, ppvObject);

    return E_NOINTERFACE;
}

////////////////////////////////////////////////////////////////////////
//
//  CDocHost
//
////////////////////////////////////////////////////////////////////////

void CFrontBody::OnDocumentReady()
{
    URLSUB rgUrlSub[] = { 
                        { "msnlink", idsHelpMSWebHome }
                        };

    // turn on link-tabbing for the front-page
    if (m_pCmdTarget)
    {
        VARIANTARG  va;

        va.vt = VT_BOOL;
        va.boolVal = VARIANT_TRUE;

        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_TABLINKS, 0, &va, NULL);
    }

    // #42164
    // we defer-show the OE-front page via script. If an IEAK person overrides this
    // with a custom front-page, then we show as soon as we go document ready
    if (!m_fOEFrontPage)
        HrShow(TRUE);
    else
    {
        // if is is the std. OE page, then replace URL's
        SubstituteURLs(m_pDoc, rgUrlSub, ARRAYSIZE(rgUrlSub));
    }
}

////////////////////////////////////////////////////////////////////////
//
//  PUBLIC
//
////////////////////////////////////////////////////////////////////////

HRESULT CFrontBody::HrInit(HWND hwnd)
{
    m_hwndOwner = hwnd;
    return CMimeEditDocHost::HrInit(hwnd, IBOF_TABLINKS, NULL);
}

HRESULT CFrontBody::HrLoadPage()
{
    HRESULT             hr = S_OK;
    
    // bobn: brianv says we have to take this out...
    /*if (IsBrowserMode())
    {
        hr = HrLoadURL("res://msoeres.dll/example.eml");
        m_fOEFrontPage = FALSE;
        g_dwBrowserFlags = 0;
    }
    else*/
    {
        DWORD               cbData;
        TCHAR               szURL[INTERNET_MAX_URL_LENGTH + 1];
        TCHAR               *pszUrl;
        LPSTR               pszUrlFree=NULL;

        *szURL = 0;
        cbData = sizeof(szURL);
        AthUserGetValue(NULL, c_szFrontPagePath, NULL, (LPBYTE)szURL, &cbData);
        if (*szURL)
        {
            pszUrl = szURL;
            m_fOEFrontPage = FALSE;
        }
        else
        {
            pszUrlFree = PszAllocResUrl(g_dwAthenaMode & MODE_NEWSONLY ? "frntnews.htm" : "frntpage.htm");
            pszUrl = pszUrlFree;
        }

        hr = HrLoadURL(pszUrl);

        SafeMemFree(pszUrlFree);
    }
    return hr;
}



HRESULT CFrontBody::SetStatusText(LPCOLESTR pszW)
{
    WCHAR   wszRes[CCHMAX_STRINGRES];
    LPWSTR  pszStatusW=0;
    HRESULT hr;

    if (pszW && !StrCmpNIW(pszW, L"oecmd:", 6))
    {
        for (int i = 0; i < ARRAYSIZE(s_rgCmdLookup); i++)
        {
            if (!StrCmpNIW(pszW+6, s_rgCmdLookup[i].pwszCmd, lstrlenW(s_rgCmdLookup[i].pwszCmd)))
            {
                *wszRes = 0;
                LoadStringWrapW(g_hLocRes, MH(s_rgCmdLookup[i].uCmd), wszRes, ARRAYSIZE(wszRes));

                // If this fails, worse that happens is that the status text is nulled.
                pszStatusW = PszDupW(wszRes);
                pszW = pszStatusW;
                break;
            }
        }
    }

    hr = CMimeEditDocHost::SetStatusText(pszW);
    MemFree(pszStatusW);
    return hr;
}





HRESULT CFrontBody::_CreateNewAccount(BOOL fMail)
{
    IImnAccount     *pAcct=0,
                    *pAcctDef;
    FOLDERID        id;
    DWORD           dwServer=0;
    CHAR            rgch[CCHMAX_ACCOUNT_NAME];
    HRESULT         hr;
    DWORD           dwPropGet,
                    dwPropSet;

    // create a new account object
    hr = g_pAcctMan->CreateAccountObject(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If creating a new news account, try and use default-mail information. If creating a new mail account, try
    // and use default-news information (if any). We don't use def-mail for mail accounts as the front-page only shows 
    // links for account-creation if there are 0 accounts of that type. 
    if (g_pAcctMan->GetDefaultAccount(fMail ? ACCT_NEWS : ACCT_MAIL, &pAcctDef)==S_OK)
    {
        dwPropGet = fMail ? AP_NNTP_DISPLAY_NAME : AP_SMTP_DISPLAY_NAME;
        dwPropSet = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;        

        if (pAcctDef->GetPropSz(dwPropGet, rgch, ARRAYSIZE(rgch))==S_OK)
            pAcct->SetPropSz(dwPropSet, rgch);

        dwPropGet = fMail ? AP_NNTP_EMAIL_ADDRESS : AP_SMTP_EMAIL_ADDRESS;
        dwPropSet = fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS;        
        
        if (pAcctDef->GetPropSz(dwPropGet, rgch, ARRAYSIZE(rgch))==S_OK)
            pAcct->SetPropSz(dwPropSet, rgch);

        pAcctDef->Release();
    }
    
    // show the account wizard dialog and allow the user to setup properties
    hr = pAcct->DoWizard(m_hwndOwner, ACCT_WIZ_MIGRATE | ACCT_WIZ_INTERNETCONNECTION |
        ACCT_WIZ_HTTPMAIL | ACCT_WIZ_OE);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // find out what servers were added
    hr = pAcct->GetServerTypes(&dwServer);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // if we added a new news or IMAP account, ask the user if they want to see the subscription dialog
    if ( ((dwServer & SRV_IMAP) || (dwServer & SRV_NNTP)) && 
        IDYES == AthMessageBoxW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena),
        dwServer & SRV_NNTP ? MAKEINTRESOURCEW(idsDisplayNewsSubDlg) : MAKEINTRESOURCEW(idsDisplayImapSubDlg),
        0, MB_ICONEXCLAMATION  | MB_YESNO))
    {
        // get the account-id
        hr = pAcct->GetPropSz(AP_ACCOUNT_ID, rgch, ARRAYSIZE(rgch));
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // find the associated node in the store
        hr = g_pStore->FindServerId(rgch, &id);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        //The user wants to download the list of newsgroups, so if we are offline, go online
        if (g_pConMan)
            g_pConMan->SetGlobalOffline(FALSE);

        // finally, show the subscription dialog
        DoSubscriptionDialog(m_hwndOwner, dwServer & SRV_NNTP, id);
    }
    
    
exit:
    ReleaseObj(pAcct);
    return hr;
}

HRESULT CFrontBody::HrClose()
{
    if (m_pTag)
    {
        m_pTag->OnFrontPageClose();
        m_pTag->Release();
        m_pTag = NULL;
    }
    SafeRelease(m_pBrowser);
    return CMimeEditDocHost::HrClose();
}



HRESULT CFrontBody::FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior)
{
    HRESULT hr;

    if ((StrCmpIW(pchBehavior, L"APPLICATION")==0 && StrCmpIW(pchBehaviorUrl, L"#DEFAULT#APPLICATION")==0))
    {
        if (!m_pTag)
        {
            m_pTag = new COETag(m_pBrowser, this);
            if (!m_pTag)
                return E_OUTOFMEMORY;
        }

        return m_pTag->QueryInterface(IID_IElementBehavior, (LPVOID *)ppBehavior);
    }
    return E_FAIL;
}
 

HRESULT CFrontBody::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    pInfo->dwDoubleClick    = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags          = DOCHOSTUIFLAG_DIV_BLOCKDEFAULT|DOCHOSTUIFLAG_OPENNEWWIN|
                              DOCHOSTUIFLAG_NO3DBORDER|DOCHOSTUIFLAG_CODEPAGELINKEDFONTS;

    //This sets the flags that match the browser's encoding
    fGetBrowserUrlEncoding(&pInfo->dwFlags);
    

    // bobn: brianv says we have to take this out...
    /*if (IsBrowserMode())
      pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;*/

    pInfo->pchHostCss       = PszDupW(L"OE\\:APPLICATION { behavior:url(#DEFAULT#APPLICATION) }");
    pInfo->pchHostNS        = PszDupW(L"OE");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\ibodyopt.h ===
#ifndef _IBODYOPT_H
#define _IBODYOPT_H

#include <unknwn.h>

/*
 * IBodyOptions
 *
 * this interface is implemented by clients of IBodyObj. It is used to provide instance-specific options to 
 * the body. Thus the body does not need to know about internal Athena options. They can be provided by the client
 * this will ease moving the body object out into an activeX control at some later date, reducing dependancy on the body.
 * also the body doesn't need to know the difference between a news message and mail message who have different settings
 *
 * The RootStream builder will call back into the body options to ask for various options as it is building the HTML
 * only the host knows what mode the UI is in and sets the options accordingly.
 *
 * NB: implementors, must implement all of the members.
 */


enum 
{
    BOPTF_COMPOSEFONT           = 0x00000001,
    BOPTF_QUOTECHAR             = 0x00000002,
    BOPTF_REPLYTICKCOLOR        = 0x00000004
};

typedef struct BODYOPTINFO_tag
{
    DWORD   dwMask;

    DWORD   dwReplyTickColor;
    TCHAR   rgchComposeFont[LF_FACESIZE + 50];
    TCHAR   chQuote;
} BODYOPTINFO, *LPBODYOPTINFO;

interface IBodyOptions : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE SignatureEnabled(BOOL fAuto) PURE;
        // pdwSigOptions == SIGOPT_ from rootstm.h        
        virtual HRESULT STDMETHODCALLTYPE GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetMarkAsReadTime(LPDWORD pdwSecs) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetFlags(LPDWORD pdwFlags) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetInfo(BODYOPTINFO *pBOI) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetAccount(IImnAccount **ppAcct) PURE;
};

// IID_IBodyOptions:: {9D39DE30-4E3D-11d0-A5A5-00C04FD61319}
DEFINE_GUID(IID_IBodyOptions, 0x9d39de30, 0x4e3d, 0x11d0, 0xa5, 0xa5, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x19);


enum    // Flags for HrGetFlags
{
    BOPT_INCLUDEMSG             = 0x00000001,   // include the message when building the rootstream
    BOPT_HTML                   = 0x00000002,   // set if HTML is enabled
    BOPT_AUTOINLINE             = 0x00000004,   // set if images can be auto-inlined
    BOPT_SENDIMAGES             = 0x00000008,   // set if images to packaged as MTHML at sendtime
    BOPT_AUTOTEXT               = 0x00000010,   // set for compose notes, if some form of autotext needs to be inserted at the caret
    BOPT_NOFONTTAG              = 0x00000020,   // set if we don't want compose font tags emitted, ie. use the stationery default
    BOPT_BLOCKQUOTE             = 0x00000040,   // block quote the text after inserting it.
    BOPT_SENDEXTERNALS          = 0x00000080,   // set is external URL are to be packed
    BOPT_SPELLINGOREORIGINAL    = 0x00000100,   // set if ignore original text in reply&forward.
    BOPT_SECURITYUIENABLED      = 0x00000200,   // set if message should use security UI if message is secure
    BOPT_FROMSTORE              = 0x00000400,   // set if the message is from the store
    BOPT_USEREPLYHEADER         = 0x00000800,   // set if should use a reply header
    BOPT_MAIL                   = 0x00001000,   // set if body is mail (instead of news)
    BOPT_REPLYORFORWARD         = 0x00002000,   // set if action is replay or forward
    BOPT_MULTI_MSGS_SELECTED    = 0x00004000,   // set if there are more than one messages selected
    BOPT_UNREAD                 = 0x00008000,   // set if the msg is not read as of yet
    BOPT_FROM_NOTE              = 0x00010000,   // set if need to mark immediate (as is the case with the note)
    BOPT_SIGNED                 = 0x00020000,   // set if the message is signed
};

enum        // flags for keeping track of the header type
{
    HDRSTYLE_NONE=0,        // no reply header
    HDRSTYLE_NEWS,          // news-style reply header: "On <date>, <author> wrote:"
    HDRSTYLE_MAIL           // MSMail-style reply header
};

enum        // flags for pdwSigOptions in HrGetSignature
{
    SIGOPT_PLAIN    = 0x00000000,   // signature is plain-text, needs conversion.
    SIGOPT_TOP      = 0x00000001,   // signature at the top of the document (default)
    SIGOPT_PREFIX   = 0x00000002,   // use signature prefix ("-- ") only a std for news
    SIGOPT_BOTTOM   = 0x00000004,   // signature at the bottom of document
    SIGOPT_CLOSING  = 0x00000008,   // news messages, close themselves with a '-----' at the end
    SIGOPT_HTML     = 0x00000010    // signature is in HTML already
};

#endif  //_IBODYOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\header.cpp ===
//*************************************************
//     h e a d e r . c p p
//
//     Purpose:
//         implements Header UI for Read|SendNote
//
//     Owner:
//         brettm.
//
//   History:
//       July '95: Created
//
//     Copyright (C) Microsoft Corp. 1993, 1994.
//*************************************************

#include <pch.hxx>
#include <richedit.h>
#include <resource.h>
#include <thormsgs.h>
#include "oleutil.h"
#include "fonts.h"
#include "error.h"
#include "header.h"
#include "options.h"
#include "note.h"
#include "ipab.h"
#include "addrobj.h"
#include "hotlinks.h"
#include <mimeole.h>
#include <secutil.h>
#include <xpcomm.h>
#include "menuutil.h"
#include "shlwapi.h"
#include "envcid.h"
#include "ourguid.h"
#include "mimeutil.h"
#include "strconst.h"
#include "mailutil.h"
#include "regutil.h"
#include "spoolapi.h"
#include "init.h"
#include "instance.h"
#include "attman.h"
#include "envguid.h"
#include <inetcfg.h>        //ICW
#include <pickgrp.h>
#include "menures.h"
#include "storecb.h"
#include "mimeolep.h"
#include "multlang.h"
#include "mirror.h"
#include "seclabel.h"
#include "shlwapip.h"
#include "reutil.h"
#include <iert.h>
#include "msgprop.h"
#include "demand.h"

ASSERTDATA

extern UINT GetCurColorRes(void);

class CFieldSizeMgr : public CPrivateUnknown,
                      public IFontCacheNotify,
                      public IConnectionPoint
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IFontCacheNotify
    HRESULT STDMETHODCALLTYPE OnPreFontChange(void);
    HRESULT STDMETHODCALLTYPE OnPostFontChange(void);

    // IConnectionPoint
    HRESULT STDMETHODCALLTYPE GetConnectionInterface(IID *pIID);        
    HRESULT STDMETHODCALLTYPE GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        
    HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie);        
    HRESULT STDMETHODCALLTYPE EnumConnections(IEnumConnections **ppEnum);

    // CPrivateUnknown
    HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    int GetScalingFactor(void);
    void ResetGlobalSizes(void);
    HRESULT Init(void);

    // This one should only be called from headers' OnPostFontChange calls
    BOOL FontsChanged(void) {return m_fFontsChanged;}

    CFieldSizeMgr(IUnknown *pUnkOuter=NULL);
    ~CFieldSizeMgr();

private:
    IUnknownList       *m_pAdviseRegistry;
    CRITICAL_SECTION    m_rAdviseCritSect;
    BOOL                m_fFontsChanged;
    DWORD               m_dwFontNotify;
};

// **********************************************************
// ***** Debug stuff for handling painting and resizing *****
// **********************************************************
const int PAINTING_DEBUG_LEVEL = 4;
const int RESIZING_DEBUG_LEVEL = 8;
const int GEN_HEADER_DEBUG_LEVEL = 16;

#ifdef DEBUG 

class StackRegistry {
public:
    StackRegistry(LPSTR pszTitle, INT_PTR p1 = 0, INT_PTR p2 = 0, INT_PTR p3 = 0, INT_PTR p4 = 0, INT_PTR p5 = 0);
    ~StackRegistry();

private:
    int     m_StackLevel;
    CHAR    m_szTitle[256+1];

    static int      gm_cStackLevel;
    static int      gm_strLen;
    static LPSTR    gm_Indent;
};

int StackRegistry::gm_cStackLevel = 0;
LPSTR StackRegistry::gm_Indent = "------------------------------";
int StackRegistry::gm_strLen = lstrlen(gm_Indent);

StackRegistry::StackRegistry(LPSTR pszTitle, INT_PTR p1, INT_PTR p2, INT_PTR p3, INT_PTR p4, INT_PTR p5)
{
    gm_cStackLevel++;
    m_StackLevel = (gm_cStackLevel > gm_strLen) ? gm_strLen : gm_cStackLevel;
    lstrcpyn(m_szTitle, pszTitle, 256);
    m_szTitle[256] = 0;

    if (1 == gm_cStackLevel)
        DOUTL(RESIZING_DEBUG_LEVEL, "\n*********** BEGIN TRACE ***********");
    
    DOUTL(RESIZING_DEBUG_LEVEL, "IN*** %s%s - %x, %x, %x, %x, %x", gm_Indent+gm_strLen-m_StackLevel, m_szTitle, p1, p2, p3, p4, p5);
}

StackRegistry::~StackRegistry()
{
    DOUTL(RESIZING_DEBUG_LEVEL, "OUT** %s%s", gm_Indent+gm_strLen-m_StackLevel, m_szTitle);

    if (1 == gm_cStackLevel)
        DOUTL(RESIZING_DEBUG_LEVEL, "************ END TRACE ************\n");
    
    gm_cStackLevel--;
    Assert(gm_cStackLevel >= 0);
}


#define STACK   StackRegistry stack

#else

// BUGBUG (neilbren) WIN64
// Figure out when __noop was introduced (MSC_VER ?) so we don't have to key off of WIN64
#define STACK   __noop

#endif

// ******************************
// ***** End of debug stuff *****
// ******************************


// c o n s t a n t s
const DWORD SETWINPOS_DEF_FLAGS = SWP_NOZORDER|SWP_NOACTIVATE;

#define GET_WM_COMMAND_ID(wp, lp)   LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp) (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)  HIWORD(wp)
#define WC_ATHHEADER                wszHeaderWndClass
#define RGB_TRANSPARENT             RGB(255,0,255)
#define HDM_TESTQUERYPRI            (WM_USER + 1)
#define cxBorder                    (GetSystemMetrics(SM_CXBORDER))
#define cyBorder                    (GetSystemMetrics(SM_CYBORDER))

// HDRCB_VCARD must remain -1 and all others must be negative
enum {
    HDRCB_VCARD = -1,
    HDRCB_SIGNED = -2,
    HDRCB_ENCRYPT = -3,
    HDRCB_NO_BUTTON = -4
};

// WARNING::    This next macro is only to be used with g_rgBtnInd inside the CNoteHdr class.
//              Make sure that they match the entries in g_rgBtnInd
#define BUTTON_STATES               m_fDigSigned,   m_fEncrypted,   m_fVCard
#define BUTTON_USE_IN_COMPOSE       FALSE,          FALSE,          TRUE

static const DWORD g_rgBtnInd[] = {HDRCB_SIGNED, HDRCB_ENCRYPT, HDRCB_VCARD};

static const int cchMaxWab                  = 512;
static const int cxTBButton                 = 16;
static const int BUTTON_BUFFER              = 2;
static const int cxBtn                      = 16;
static const int cyBtn                      = cxBtn;
static const int cxFlags                    = 12;
static const int cyFlags                    = cxFlags;
static const int cxFlagsDelta               = cxFlags + 4;
static const int MAX_ATTACH_PIXEL_HEIGHT    = 50;
static const int ACCT_ENTRY_SIZE            = CCHMAX_ACCOUNT_NAME + CCHMAX_EMAIL_ADDRESS + 10;
static const int INVALID_PHCI_Y             = -1;
static const int cMaxRecipMenu              = (ID_ADD_RECIPIENT_LAST-ID_ADD_RECIPIENT_FIRST);
static const int NUM_COMBO_LINES            = 9;
static const int MAX_RICHEDIT_LINES         = 4;
static const int DEFER_WINDOW_SIZE          = MAX_HEADER_COMP + 1 + 1 + 1 + 5;   // +1=header window, +1=field resize, +1 toolbar
static const LPTSTR GRP_DELIMITERS          = " ,\t;\n\r";

#define c_wszEmpty L""
#define c_aszEmpty ""


// t y p e d e f s

typedef struct TIPLOOKUP_tag
{
    int idm;
    int ids;
} TIPLOOKUP;

typedef struct CMDMAPING_tag
{
    DWORD   cmdIdOffice,
            cmdIdOE;
} CMDMAPING;

typedef struct PERSISTHEADER_tag
{
    DWORD   cbSize;         // size so we can version the stuct
    DWORD   dwRes1,         // padding just in case...
            dwRes2;
} PERSISTHEADER;

#define cchMaxSubject               256

typedef struct WELLINIT_tag
{
    INT             idField;
    ULONG           uMAPI;
} WELLINIT, *PWELLINIT;


// s t a t i c   d a t a
static HIMAGELIST       g_himlStatus = 0,
                        g_himlBtns = 0,
                        g_himlSecurity = 0;

static TCHAR            g_szStatFlagged[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatLowPri[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatHighPri[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatWatched[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatIgnored[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat1[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat2[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat3[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatUnsafeAtt[cchHeaderMax+1] = c_aszEmpty;

static CFieldSizeMgr   *g_pFieldSizeMgr = NULL;
static WNDPROC          g_lpfnREWndProc = NULL;
static CHARFORMAT       g_cfHeader = {0};
static int              g_cyFont = 0,
                        g_cyLabelHeight = 0;

static char const       szButton[]="BUTTON";
static WCHAR const      wszHeaderWndClass[]=L"OE_Envelope";



// KEEP in ssync with c_rgTipLookup
const TBBUTTON    c_btnsOfficeEnvelope[]=
{ 
    {TBIMAGE_SEND_MAIL,         ID_SEND_NOW,            TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1},
    __TOOLBAR_SEP__,
    { TBIMAGE_CHECK_NAMES,      ID_CHECK_NAMES,         TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0, 0}, 0, -1},
    { TBIMAGE_ADDRESS_BOOK,     ID_ADDRESS_BOOK,        TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0, 0}, 0, -1},
    __TOOLBAR_SEP__,
    {TBIMAGE_SET_PRIORITY,      ID_SET_PRIORITY,        TBSTATE_ENABLED,    TBSTYLE_DROPDOWN,   {0,0}, 0, -1},
    {TBIMAGE_INSERT_ATTACHMENT, ID_INSERT_ATTACHMENT,   TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1},
    __TOOLBAR_SEP__,
    { TBIMAGE_ENVELOPE_BCC,     ID_ENV_BCC,             TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1}
};

// KEEP in ssync with c_btnsOfficeEnvelope
const TIPLOOKUP     c_rgTipLookup[] = 
{
    {ID_SEND_NOW, idsSendMsgTT},
    {ID_CHECK_NAMES, idsCheckNamesTT},
    {ID_ADDRESS_BOOK, idsAddressBookTT},
    {ID_SET_PRIORITY, idsSetPriorityTT},
    {ID_INSERT_ATTACHMENT, idsInsertFileTT},
    {ID_ENV_BCC, idsEnvBccTT}
};

// Prototypes
HRESULT ParseFollowup(LPMIMEMESSAGE pMsg, LPTSTR* ppszGroups, BOOL* pfPoster);
DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection);
void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace);

// i n l i n e s

void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace)
{
    if (!hwnd)
        return;

    PHCI phci = (HCI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    AssertSz(phci, "We are calling HdrSetRichEditText on a non-richedit control");

    SetRichEditText(hwnd, pwchBuff, fReplace, phci->pDoc, (phci->dwFlags & HCF_READONLY));
}

DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection)
{
    if (!hwnd)
        return 0;

    PHCI phci = (HCI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    AssertSz(phci, "We are calling HdrSetRichEditText on a non-richedit control");

    return GetRichEditText(hwnd, pwchBuff, dwNumChars, fSelection, phci->pDoc);
}

inline void GetRealClientRect(HWND hwnd, RECT *prc)
{
    GetClientRect(hwnd, prc);
    AdjustWindowRectEx(prc, GetWindowLong(hwnd, GWL_STYLE), FALSE, GetWindowLong(hwnd, GWL_EXSTYLE));
}

inline int GetCtrlWidth(HWND hwnd)
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    return rc.right - rc.left;
}

inline int GetControlSize(BOOL fIncludeBorder, int cLines)
{
    int size = cLines * g_cyFont;

    // If borders, include the metrics
    if (fIncludeBorder)
        size += 7;

    return size;
}

inline int GetCtrlHeight(HWND hwnd)
{
    DWORD id = GetWindowLong(hwnd, GWL_ID);
    if (idFromCombo == id)
    {
        return GetControlSize(TRUE, 1);
    }
    else
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        return rc.bottom - rc.top;
    }
}

inline int GetStatusHeight(int cLines) {return ((cyBtn<g_cyFont)?GetControlSize(TRUE, cLines):((cyBtn-4)*cLines + 2*cyBorder + 6)); }
inline int CYOfStatusLine()     { return ((cyBtn<g_cyFont)?g_cyFont:(cyBtn - 4)); }
inline int ControlXBufferSize() { return 10 * cxBorder; }
inline int ControlYBufferSize() { return 4 * cyBorder; }
inline int PaddingOfLabels()    { return 2 * ControlXBufferSize(); }
inline int CXOfButtonToLabel()  { return 4*cxBorder + cxBtn; }

inline BOOL ButtonInLabels(int iBtn) { return (iBtn > HDRCB_VCARD); }
inline HFONT GetFont(BOOL fBold) { return HGetSystemFont(fBold?FNT_SYS_ICON_BOLD:FNT_SYS_ICON); }


static IMSGPRIORITY priLookup[3]=
{    IMSG_PRI_LOW,
    IMSG_PRI_NORMAL,
    IMSG_PRI_HIGH
};

#define HCI_ENTRY(flg,opt,ide,idb,idsl,idse,idst) \
    { \
        flg, opt, \
        ide, idb, \
        idsl, idse, idst, \
        NOFLAGS, TRUE, \
        NULL, NULL, \
        0, 0, 0, 0, \
        c_wszEmpty, c_wszEmpty \
    }

static int rgIDTabOrderMailSend[] =
{
    idFromCombo,        idADTo,             
    idADCc,             idADBCc,            
    idTXTSubject,       idwAttachWell
};

static HCI  rgMailHeaderSend[]=
{

    HCI_ENTRY(HCF_COMBO|HCF_ADVANCED|HCF_BORDER,
        0,
        idFromCombo,        0,
        idsFromField,       NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_BORDER,
        0,
        idADTo,             idbtnTo,
        idsToField,         idsEmptyTo,
        idsTTRecipients),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_BORDER,
        0,
        idADCc,             idbtnCc,
        idsCcField,         idsEmptyCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_ADVANCED|HCF_BORDER,
        0,
        idADBCc,            idbtnBCc,
        idsBCcField,        idsEmptyBCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubject,
        idsTTSubject),

    HCI_ENTRY(HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        idsTTAttachment),
};

static int rgIDTabOrderMailRead[] =
{
    idADFrom,           idTXTDate,
    idADTo,             idADCc,
    idTXTSubject,       idwAttachWell,
    idSecurity
};

static HCI  rgMailHeaderRead[]=
{
    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADFrom,           0,
        idsFromField,       idsNoFromField,
        NULL),

    HCI_ENTRY(HCF_READONLY,
        0,
        idTXTDate,          0,
        idsDateField,       NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADTo,             0,
        idsToField,         idsNoCcOrTo,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED|HCF_ADDRWELL,
        0,
        idADCc,             0,
        idsCcField,         idsNoCcOrTo,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_USECHARSET,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubjectRO,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,          // HCF_ADVANCED will hide it when empty
        0,
        idSecurity,         0,
        idsSecurityField,   NULL,
        NULL),
};

static int rgIDTabOrderNewsSend[] =
{
    idFromCombo,        idADNewsgroups,     
    idTXTFollowupTo,    idADCc,             
    idADReplyTo,        idTXTDistribution,  
    idTXTKeywords,      idTXTSubject,       
    idwAttachWell,      idADApproved,       
    idTxtControl
};

static HCI  rgNewsHeaderSend[]=
{
    HCI_ENTRY(HCF_COMBO|HCF_ADVANCED|HCF_BORDER,
        0,
        idFromCombo,        0,
        idsNewsServer,      NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_NEWSPICK|HCF_BORDER,
        0,
        idADNewsgroups,     idbtnTo,
        idsNewsgroupsField, idsEmptyNewsgroups,
        idsTTNewsgroups),

    HCI_ENTRY(HCF_ADVANCED|HCF_HASBUTTON|HCF_NEWSPICK|HCF_MULTILINE|HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTFollowupTo,    idbtnFollowup,
        idsFollowupToField, idsEmptyFollowupTo,
        idsTTFollowup),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADDRWELL|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_BORDER,
        0,
        idADCc,             idbtnCc,
        idsCcField,         idsEmptyCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_ADVANCED|HCF_ADDRWELL|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_BORDER,
        0,
        idADReplyTo,        idbtnReplyTo,
        idsReplyToField,    idsEmptyReplyTo,
        idsTTReplyTo),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADVANCED|HCF_BORDER,
        0,
        idTXTDistribution,      0,
        idsDistributionField,   idsEmptyDistribution,
        idsTTDistribution),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADVANCED|HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTKeywords,      0,
        idsKeywordsField,   idsEmptyKeywords,
        idsTTKeywords),

    HCI_ENTRY(HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubject,
        idsTTSubject),

    HCI_ENTRY(HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        idsTTAttachment),

    HCI_ENTRY(HCF_ADVANCED|HCF_OPTIONAL,
        OPT_NEWSMODERATOR,
        idADApproved,       0,
        idsApprovedField,   idsEmptyApproved,
        idsTTApproved),

    HCI_ENTRY(HCF_ADVANCED|HCF_OPTIONAL,
        OPT_NEWSCONTROLHEADER,
        idTxtControl,       0,
        idsControlField,    idsEmptyControl,
        idsTTControl),

};

static int rgIDTabOrderNewsRead[] =
{
    idADFrom,           idADReplyTo,
    idTXTOrg,           idTXTDate,
    idADNewsgroups,     idTXTFollowupTo,
    idTXTDistribution,  idTXTKeywords,
    idTXTSubject,       idwAttachWell,
    idSecurity
};

static HCI  rgNewsHeaderRead[]=
{
    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADFrom,           0,
        idsFromField,       idsNoFromField,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED|HCF_ADDRWELL,
        0,
        idADReplyTo,        0,
        idsReplyToField,    idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED|HCF_USECHARSET,
        0,
        idTXTOrg,           0,
        idsOrgField,        idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY,
        0,
        idTXTDate,          0,
        idsDateField,       idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY,
        0,
        idADNewsgroups,     0,
        idsNewsgroupsField, idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,
        0,
        idTXTFollowupTo,    0,
        idsFollowupToField, idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED,
        0,
        idTXTDistribution,      0,
        idsDistributionField,   idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED|HCF_USECHARSET,
        0,
        idTXTKeywords,      0,
        idsKeywordsField,   idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_USECHARSET,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubjectRO,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,        
        0,
        idSecurity,         0,
        idsSecurityField,   NULL,
        NULL),
};


// p r o t o t y p e s
void _ValidateNewsgroups(LPWSTR pszGroups);
INT_PTR CALLBACK _PlainWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#ifdef DEBUG
void DEBUGHdrName(HWND hwnd);

void DEBUGDumpHdr(HWND hwnd, int cHdr, PHCI rgHCI)
{
    PHCI    phci;
    char    sz[cchHeaderMax+1];
    RECT    rc;
    HWND    hwndEdit;

#ifndef DEBUG_SIZINGCODE
    return;
#endif

    DOUTL(GEN_HEADER_DEBUG_LEVEL, "-----");

    for (int i=0; i<(int)cHdr; i++)
    {
        phci=&rgHCI[i];

        hwndEdit=GetDlgItem(hwnd, phci->idEdit);

        GetChildRect(hwnd, hwndEdit, &rc);
        DEBUGHdrName(hwndEdit);
        wsprintf(sz, "\tat:(%d,%d) \tsize:(%d,%d)\r\n", rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top);
        OutputDebugString(sz);
    }
    GetWindowRect(hwnd, &rc);
    DOUTL(GEN_HEADER_DEBUG_LEVEL, "HeaderSize: (%d,%d)\r\n-----", rc.right-rc.left, rc.bottom-rc.top);
}

void DEBUGHdrName(HWND hwnd)
{
    char    sz[cchHeaderMax+1];
    char    *psz=0;

    switch (GetDlgCtrlID(hwnd))
    {
        case idTXTSubject:
            psz="Subject";
            break;

        case idTXTOrg:
            psz="Org";
            break;

        case idADTo:
            psz="To";
            break;

        case idADCc:
            psz="Cc";
            break;

        case idADFrom:
            psz="From";
            break;

        case idTXTDate:
            psz="Date";
            break;

        case idTXTDistribution:
            psz="Distribution";
            break;

        case idADApproved:
            psz="Approved";
            break;

        case idADReplyTo:
            psz="ReplyTo";
            break;

        case idTXTKeywords:
            psz="Keywords";
            break;

        case idADNewsgroups:
            psz="NewsGroup";
            break;

        case idTXTFollowupTo:
            psz="FollowUp";
            break;

        default:
            psz="<Unknown>";
            break;
    }

    wsprintf(sz, "%s: ", psz);
    OutputDebugString(sz);
}
#endif

// FHeader_Init
//
// Purpose: called to init and de-init global header stuff, eg.
//          wndclasses, static data etc.
//
// Comments:
//    TODO: defer this initialisation
//
BOOL FHeader_Init(BOOL fInit)
{
    WNDCLASSW   wc={0};
    static      BOOL s_fInited=FALSE;
    BOOL        fSucceeded = TRUE;

    if (fInit)
    {
        if (s_fInited)
            goto exit;

        Assert(!g_pFieldSizeMgr);

        g_pFieldSizeMgr = new CFieldSizeMgr;
        if (!g_pFieldSizeMgr || FAILED(g_pFieldSizeMgr->Init()))
        {
            fSucceeded = FALSE;
            goto exit;
        }

        wc.style         = 0;
        wc.lpfnWndProc   = (WNDPROC)CNoteHdr::ExtCNoteHdrWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
        wc.lpszClassName = WC_ATHHEADER;

        if (!RegisterClassWrapW(&wc))
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlStatus=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbHeaderStatus), cxFlags, 0, RGB_TRANSPARENT);
        if (!g_himlStatus)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlBtns=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbBtns), cxBtn, 0, RGB_TRANSPARENT);
        if (!g_himlBtns)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlSecurity=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSecurity), cxBtn, 0, RGB_TRANSPARENT);
        if (!g_himlSecurity)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        ImageList_SetBkColor(g_himlStatus, CLR_NONE);
        ImageList_SetBkColor(g_himlBtns, CLR_NONE);
        ImageList_SetBkColor(g_himlSecurity, CLR_NONE);

        AthLoadString(idsStatusFlagged, g_szStatFlagged, cchHeaderMax);
        AthLoadString(idsStatusLowPri, g_szStatLowPri, cchHeaderMax);
        AthLoadString(idsStatusHighPri, g_szStatHighPri, cchHeaderMax);
        AthLoadString(idsStatusWatched, g_szStatWatched, cchHeaderMax);
        AthLoadString(idsStatusIgnored, g_szStatIgnored, cchHeaderMax);
        AthLoadString(idsStatusFormat1, g_szStatFormat1, cchHeaderMax);
        AthLoadString(idsStatusFormat2, g_szStatFormat2, cchHeaderMax);
        AthLoadString(idsStatusFormat3, g_szStatFormat3, cchHeaderMax);        
        AthLoadString(idsStatusUnsafeAttach, g_szStatUnsafeAtt, cchHeaderMax);        

        s_fInited=TRUE;


    }
    // De-Init ******
    else
    {
        UnregisterClassWrapW(WC_ATHHEADER, g_hInst);
        if (g_himlStatus)
        {
            ImageList_Destroy(g_himlStatus);
            g_himlStatus = 0;
        }
        if (g_himlBtns)
        {
            ImageList_Destroy(g_himlBtns);
            g_himlBtns = 0;
        }
        if (g_himlSecurity)
        {
            ImageList_Destroy(g_himlSecurity);
            g_himlSecurity = 0;
        }
        s_fInited=FALSE;

        SafeRelease(g_pFieldSizeMgr);
    }

exit:
    if (!fSucceeded)
        SafeRelease(g_pFieldSizeMgr);

    return fSucceeded;
}


HRESULT CreateInstance_Envelope(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CNoteHdr           *pNew=NULL;

    // Trace
    TraceCall("CreateInstance_Envelope");

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // Create
    IF_NULLEXIT(pNew = new CNoteHdr);

    // Return the Innter
    *ppUnknown = (IMsoEnvelope*) pNew;

    exit:
    // Done
    return hr;
}


CNoteHdr::CNoteHdr()
{
//    Not initialised
//    Member:                 Initialised In:
//    --------------------+---------------------------
//    m_wNoteType             Finit

    m_cRef = 1;
    m_cHCI = 0;
    m_cAccountIDs = 0;
    m_iCurrComboIndex = 0;

    m_hwnd = 0;
    m_hwndLastFocus = 0;
    m_hwndRebar = 0;

    m_pri = priNorm;    // default to Normal Pri
    m_cfAccept = CF_NULL;
    m_ntNote = OENA_COMPOSE;

    m_fMail = TRUE;
    m_fVCard = FALSE;
    m_fDirty = FALSE;
    m_fInSize = FALSE;
    m_fFlagged = FALSE;
    m_fAdvanced = FALSE;
    m_fResizing = FALSE;
    m_fUIActive = FALSE;
    m_fDigSigned = FALSE;
    m_fEncrypted = FALSE;
    m_fSkipLayout = TRUE;   // Skip layout until after load
    m_fSignTrusted = TRUE;
    m_fOfficeInit = FALSE;
    m_fStillLoading = TRUE;
    m_fEncryptionOK = TRUE;
    m_fHandleChange = TRUE;
    m_fAutoComplete = FALSE;
    m_fSendImmediate = FALSE;
    m_fVCardSave = !m_fVCard;
    m_fSecurityInited = FALSE;
    m_fAddressesChanged = FALSE;
    m_fForceEncryption = FALSE;
    m_fThisHeadDigSigned = FALSE;
    m_fThisHeadEncrypted = FALSE;
    m_fDropTargetRegister = FALSE;
    
    m_pMsg = NULL;
    m_lpWab = NULL;
    m_rgHCI = NULL;
    m_hwndTT = NULL;
    m_pTable = NULL;
    m_lpWabal = NULL;
    m_pszRefs = NULL;
    m_pMsgSend = NULL;
    m_hCharset = NULL;
    m_pAccount = NULL;
    m_hInitRef = NULL;
    m_lpAttMan = NULL;
    m_hwndParent = NULL;
    m_pAddrWells = NULL;
    m_hwndToolbar = NULL;
    m_pHeaderSite = NULL;
    m_pEnvelopeSite = NULL;
    m_pMsoComponentMgr = NULL;
    m_lpszSecurityField = NULL;
    m_ppAccountIDs = NULL;
    *m_szLastLang = 0;

    m_MarkType = MARK_MESSAGE_NORMALTHREAD;
    m_hwndOldCapture = NULL;
    m_dwCurrentBtn = HDRCB_NO_BUTTON;
    m_dwClickedBtn = HDRCB_NO_BUTTON;
    m_dwEffect = 0;
    m_cCapture = 0;
    m_dwDragType = 0;
    m_dwComponentMgrID = 0;
    m_dwIMEStartCount = 0;
    m_dwFontNotify = 0;

    m_dxTBOffset = 0;
    m_grfKeyState = 0;
    m_cxLeftMargin = 0;
    m_himl = NULL;
    m_fPoster = FALSE;

    ZeroMemory(&m_SecState, sizeof(m_SecState));
}

CNoteHdr::~CNoteHdr()
{
    Assert (m_pMsgSend==NULL);
    
    if (m_hwnd)
        DestroyWindow(m_hwnd);

    ReleaseObj(m_pTable);
    ReleaseObj(m_lpWabal);
    ReleaseObj(m_lpWab);
    SafeMemFree(m_pszRefs);
    ReleaseObj(m_pAccount);
    CleanupSECSTATE(&m_SecState);
    ReleaseObj(m_lpAttMan);
    ReleaseObj(m_pMsg);
    SafeMemFree(m_lpszSecurityField);
    
    if (m_pAddrWells)
        delete m_pAddrWells;

    if (m_himl)
        ImageList_Destroy(m_himl);

    if (m_fOfficeInit)
        HrOfficeInitialize(FALSE);

    if (m_cAccountIDs)
    {
        while (m_cAccountIDs--)
            SafeMemFree(m_ppAccountIDs[m_cAccountIDs]);
    }
    SafeMemFree(m_ppAccountIDs);
}


ULONG CNoteHdr::AddRef()
{
    return ++m_cRef;
}

ULONG CNoteHdr::Release()
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT CNoteHdr::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IHeader))
        *lplpObj = (LPVOID)(LPHEADER)this;

    else if (IsEqualIID(riid, IID_IMsoEnvelope))
        *lplpObj = (LPVOID)(IMsoEnvelope*)this;

    else if (IsEqualIID(riid, IID_IMsoComponent))
        *lplpObj = (LPVOID)(IMsoComponent*)this;

    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(LPPERSISTMIME)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IDropTarget))
        *lplpObj = (LPVOID)(IDropTarget*)this;

    else if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify*)this;
    
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

// IOleCommandTarget
HRESULT CNoteHdr::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   ul;
    HWND    hwndFocus = GetFocus();
    DWORD   dwFlags = 0;
    BOOL    fFound = FALSE;

    if (!rgCmds)
        return E_INVALIDARG;

    for (int i=0; i<(int)m_cHCI; i++)
    {
        // if it's in our control-list and not a combobox
        if (hwndFocus == GetDlgItem(m_hwnd, m_rgHCI[i].idEdit) && 
            !(m_rgHCI[i].dwFlags & HCF_COMBO))
        {
            GetEditDisableFlags(hwndFocus, &dwFlags);
            fFound = TRUE;
            break;
        }
    }

    if (pguidCmdGroup == NULL)
    {
        for (ul=0;ul<cCmds; ul++)
        {
            switch (rgCmds[ul].cmdID)
            {

                case cmdidSend:
                case cmdidCheckNames:
                case cmdidAttach:
                case cmdidOptions:
                case cmdidSelectNames:
                case cmdidFocusTo:
                case cmdidFocusCc:
                case cmdidFocusSubject:
                    // office commands enabled if we have an env-site
                    rgCmds[ul].cmdf = m_pEnvelopeSite ? OLECMDF_ENABLED|OLECMDF_SUPPORTED : 0;
                    break;

                case OLECMDID_CUT:
                case OLECMDID_PASTE:
                case OLECMDID_COPY:
                case OLECMDID_UNDO:
                case OLECMDID_SELECTALL:
                    if (fFound)
                        HrQueryToolbarButtons(dwFlags, pguidCmdGroup, &rgCmds[ul]);
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
            }
        }

        return NOERROR;
    }
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        BOOL    fReadOnly = IsReadOnly(),
                fMailAndNotReadOnly = m_fMail && !fReadOnly;
        UINT    pri;

        GetPriority(&pri);

        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            ULONG cmdID = rgCmds[ul].cmdID;
            if (0 != rgCmds[ul].cmdf)
                continue;

            switch (cmdID)
            {
                case ID_SELECT_RECIPIENTS:
                case ID_SELECT_NEWSGROUPS:
                case ID_INSERT_ATTACHMENT:
                    rgCmds[ul].cmdf = QS_ENABLED(!fReadOnly);
                    break;

                case ID_INSERT_CONTACT_INFO:
                    HrGetVCardState(&rgCmds[ul].cmdf);
                    break;

                case ID_ENCRYPT:
                    if(m_fForceEncryption)
                    {
                        if(!m_fDigSigned)
                            rgCmds[ul].cmdf = QS_ENABLECHECK(fMailAndNotReadOnly, m_fEncrypted);
                        else 
                            break;
                    }
                    else
                        rgCmds[ul].cmdf = QS_ENABLECHECK(fMailAndNotReadOnly, m_fEncrypted);
                    break;

                case ID_DIGITALLY_SIGN:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(!fReadOnly && 0 == (g_dwAthenaMode & MODE_NEWSONLY), m_fDigSigned);
                    break;

                case ID_SET_PRIORITY:
                case ID_POPUP_PRIORITY:
                    rgCmds[ul].cmdf = QS_ENABLED(fMailAndNotReadOnly);
                    break;

                case ID_PRIORITY_HIGH:
                case ID_PRIORITY_NORMAL:
                case ID_PRIORITY_LOW:
                    rgCmds[ul].cmdf = QS_ENABLERADIO(fMailAndNotReadOnly, (pri == UINT(ID_PRIORITY_LOW - cmdID)));
                    break;

                case ID_CHECK_NAMES:
                    rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    break;

                case ID_FULL_HEADERS:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(TRUE, m_fAdvanced);
                    break;

                case ID_CUT:
                case ID_COPY:
                case ID_NOTE_COPY:
                case ID_PASTE:
                case ID_UNDO:
                case ID_SELECT_ALL:
                    if (fFound)
                        HrQueryToolbarButtons(dwFlags, pguidCmdGroup, &rgCmds[ul]);
                    break;
            }
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Envelope))
    {
        for (ul=0;ul<cCmds; ul++)
        {
            switch (rgCmds[ul].cmdID)
            {
                case MSOEENVCMDID_VCARD:
                    HrGetVCardState(&rgCmds[ul].cmdf);
                    break;

                case MSOEENVCMDID_DIGSIGN:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(!IsReadOnly(), m_fDigSigned);
                    break;

                case MSOEENVCMDID_ENCRYPT:
                    if(m_fForceEncryption)
                    {
                        if(!m_fDigSigned)
                            rgCmds[ul].cmdf = QS_ENABLECHECK(m_fMail && !IsReadOnly(), m_fEncrypted);
                        else 
                            break;
                    }
                    else
                        rgCmds[ul].cmdf = QS_ENABLECHECK(m_fMail && !IsReadOnly(), m_fEncrypted);
                    break;

                case MSOEENVCMDID_DIRTY:
                    {
                        BOOL fDirty;
                        fDirty = m_fDirty || (m_lpAttMan && m_lpAttMan->HrIsDirty()==S_OK);

                        if (fDirty)
                            rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                        else
                            rgCmds[ul].cmdf = 0;
                    }
                    break;

                case MSOEENVCMDID_SEND:
                case MSOEENVCMDID_CHECKNAMES:
                case MSOEENVCMDID_AUTOCOMPLETE:
                case MSOEENVCMDID_SETACTION:
                case MSOEENVCMDID_PRIORITY:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
            }
        }

        return NOERROR;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


// IOleCommandTarget
HRESULT CNoteHdr::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = NOERROR;
    HWND        hwndFocus;
    UINT        msg = 0;
    WPARAM      wParam = 0;
    LPARAM      lParam = 0;
    BOOL        fOfficeCmd=FALSE;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
            case OLECMDID_CUT:              
                msg = WM_CUT; 
                break;
            
            case OLECMDID_PASTE:            
                msg = WM_PASTE; 
                break;

            case OLECMDID_COPY:             
                msg = WM_COPY; 
                break;

            case OLECMDID_UNDO:             
                msg = WM_UNDO; 
                break;

            case OLECMDID_SELECTALL:        
                msg = EM_SETSEL; 
                lParam = (LPARAM)(INT)-1; 
                break;

            case OLECMDID_CLEARSELECTION:   
                msg = WM_CLEAR; 
                break;

            default:
                hr = _ConvertOfficeCmdIDToOE(&nCmdID);
                if (hr==S_OK)
                {   //if sucess, nCmdId now points to an OE command
                    fOfficeCmd = TRUE;
                    goto oe_cmd;
                }
                else
                    hr = OLECMDERR_E_NOTSUPPORTED;
        }

        if (0 != msg)
        {
            hwndFocus = GetFocus();
            if (IsChild(m_hwnd, hwndFocus))
                SendMessage(hwndFocus, msg, wParam, lParam);
        }
        return hr;
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Envelope))
    {
oe_cmd:
        switch (nCmdID)
        {
            case MSOEENVCMDID_ATTACHFILE:
                if (m_lpAttMan)
                    m_lpAttMan->WMCommand(0, ID_INSERT_ATTACHMENT, NULL);
                break;
                
            case MSOEENVCMDID_FOCUSTO:
                ::SetFocus(GetDlgItem(m_hwnd, idADTo));
                break;

            case MSOEENVCMDID_FOCUSCC:
                ::SetFocus(GetDlgItem(m_hwnd, idADCc));
                break;

            case MSOEENVCMDID_FOCUSSUBJ:
                ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
                break;

            case MSOEENVCMDID_SEND:
                if (MSOCMDEXECOPT_DONTPROMPTUSER == nCmdExecOpt)
                    m_fSendImmediate = TRUE;
                else
                    m_fSendImmediate = FALSE;

                hr = HrSend();
                break;

            case MSOEENVCMDID_NEWS:
                m_fMail = FALSE;
                break;

            case MSOEENVCMDID_CHECKNAMES:
                hr = HrCheckNames((MSOCMDEXECOPT_PROMPTUSER == nCmdExecOpt)? FALSE: TRUE, TRUE);
                if (!m_fMail)
                {
                    hr = HrCheckGroups(FALSE);
                    if (hrNoRecipients == hr)
                        hr = S_OK;
                }
                break;

            case MSOEENVCMDID_AUTOCOMPLETE:
                m_fAutoComplete = TRUE;
                break;

            case MSOEENVCMDID_VIEWCONTACTS:
                hr = HrViewContacts();
                break;

            case MSOEENVCMDID_DIGSIGN:
                hr = HrHandleSecurityIDMs(TRUE);
                break;
            case MSOEENVCMDID_ENCRYPT:
                hr = HrHandleSecurityIDMs(FALSE);
                break;

            case MSOEENVCMDID_SETACTION:
                if (pvaIn->vt == VT_I4)
                    m_ntNote = pvaIn->lVal;
                break;

            case MSOEENVCMDID_SELECTRECIPIENTS:
                hr = HrPickNames(0);
                break;

            case MSOEENVCMDID_ADDSENDER:
                hr = HrAddSender();
                break;

            case MSOEENVCMDID_ADDALLONTO:
                hr = HrAddAllOnToList();
                break;

            case MSOEENVCMDID_PICKNEWSGROUPS:
                if (!m_fMail)
                {
                    if (idTXTFollowupTo == GetWindowLong(GetFocus(), GWL_ID))
                        OnButtonClick(idbtnFollowup);
                    else
                        OnButtonClick(idbtnTo);
                }
                break;

            case MSOEENVCMDID_VCARD:
                m_fVCard = !m_fVCard;
                hr = HrOnOffVCard();
                break;

            case MSOEENVCMDID_DIRTY:
                _ClearDirtyFlag();
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
        }

        // suppress OE errors when running under office-envelope
        if (fOfficeCmd && hr != OLECMDERR_E_NOTSUPPORTED)
            hr = S_OK;
        
        return hr;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


BOOL CNoteHdr::IsReplyNote()
{
    return (m_ntNote==OENA_REPLYTOAUTHOR || m_ntNote==OENA_REPLYTONEWSGROUP || m_ntNote==OENA_REPLYALL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistMime::Load
// before calling this function, need to set m_ntNote by MSOEENVCMDID_SETACTION.
HRESULT CNoteHdr::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT         hr=S_OK;
    HCHARSET        hCharset = NULL;
    PROPVARIANT     var;

    Assert(pMsg);
    if (!pMsg)
        return E_INVALIDARG;

    m_fStillLoading = TRUE;

    m_fSkipLayout = TRUE;

    m_fHandleChange = TRUE;

    ReplaceInterface(m_pMsg, pMsg);

    pMsg->GetCharset(&hCharset);

    // bug #43295
    // If we are in same codepages, we can pass FALSE to UpdateCharSetFont().
    // But if we are in the differnet codepages, we need to update font to
    // display the header (decoded) in the correct codepage.
    //    UpdateCharSetFonts(hCharset, FALSE);
    if (hCharset)
        HrUpdateCharSetFonts(hCharset, hCharset != m_hCharset);

    // If there is an account set in the message, make sure that we use it.
    var.vt = VT_LPSTR;
    if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
    {
        IImnAccount *pAcct = NULL;
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAcct)))
        {
            HWND hwndCombo = GetDlgItem(m_hwnd, idFromCombo);
            if (hwndCombo)
            {
                int     cEntries = ComboBox_GetCount(hwndCombo);
                for (int i = 0; i < cEntries; i++)
                {
                    LPSTR idStr = (LPSTR)ComboBox_GetItemData(hwndCombo, i);
                    if (0 == lstrcmp(idStr, var.pszVal))
                    {
                        ComboBox_SetCurSel(hwndCombo, i);
                        m_iCurrComboIndex = i;
                        ReplaceInterface(m_pAccount, pAcct);
                        break;
                    }
                }
            }
            else 
                ReplaceInterface(m_pAccount, pAcct);

            pAcct->Release();
        }
        SafeMemFree(var.pszVal);
    }

    HrInitSecurity();
    HrUpdateSecurity(pMsg);

    // Modify subject if need to add a Fw: or a Re:
    if (m_ntNote==OENA_FORWARD || IsReplyNote())
        HrSetReplySubject(pMsg, OENA_FORWARD != m_ntNote);
    else
        HrSetupNote(pMsg);

    SetReferences(pMsg);    

    if (m_fMail)
        hr = HrSetMailRecipients(pMsg);
    else
        hr = HrSetNewsRecipients(pMsg);

    if (OENA_READ == m_ntNote)
        _SetEmptyFieldStrings();

    // Update fiels, which depends from language
    _UpdateTextFields(FALSE);
    
    // setup priority, default to normal if a reply
    if (!IsReplyNote())
        HrSetPri(pMsg);
    // on reply's auto add to the wab
    else
        HrAutoAddToWAB();

    HrClearUndoStack();

    m_fSkipLayout = FALSE;
    ReLayout();

    m_fDirty=FALSE;
    if (m_pHeaderSite)
        m_pHeaderSite->Update();

    return hr;
}

void CNoteHdr::_SetEmptyFieldStrings(void)
{
    PHCI        phci = m_rgHCI;

    AssertSz((OENA_READ == m_ntNote), "Should only get here in a read note.");

    // No longer want EN_CHANGE messages to be handled in the richedits. At this
    // point we will be setting text in the edits but don't want the phci->fEmpty 
    // to be set. That message causes the phci->fEmpty to be set.
    m_fHandleChange = FALSE;
    for (int i = 0; (ULONG)i < m_cHCI; i++, phci++)
        if (phci->fEmpty)
        {
            if (0 == (phci->dwFlags & (HCF_COMBO|HCF_ATTACH)))
                HdrSetRichEditText(GetDlgItem(m_hwnd, phci->idEdit), phci->szEmpty, FALSE);
            else
                SetWindowTextWrapW(GetDlgItem(m_hwnd, phci->idEdit), phci->szEmpty);
        }
}

HRESULT CNoteHdr::_AttachVCard(IMimeMessage *pMsg)
{
    HRESULT         hr = 0;
    LPWAB           lpWab = 0;
    TCHAR           szVCardName[MAX_PATH],
                    szTempDir[MAX_PATH], 
                    szVCardTempFile[MAX_PATH],
                    szVCFName[MAX_PATH];
    UINT            uFile=0;
    INT             iLen=0;
    LPTSTR          lptstr = NULL;
    LPSTREAM        pstmFile=NULL, 
                    pstmCopy=NULL;

    *szVCardName = 0;
    *szTempDir = 0;
    *szVCardTempFile = 0;
    *szVCFName = 0;

    if (m_lpAttMan && (S_OK == m_lpAttMan->HrCheckVCardExists(m_fMail)))
        goto error;

    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;

    GetOption(m_fMail?OPT_MAIL_VCARDNAME:OPT_NEWS_VCARDNAME, szVCardName, MAX_PATH);

    if(*szVCardName == '\0')
    {
        hr = E_FAIL;
        goto error;
    }

    GetTempPath(sizeof(szTempDir), szTempDir);

    uFile = GetTempFileName(szTempDir, "VCF", 0, szVCardTempFile);
    if (uFile == 0)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = lpWab->HrCreateVCardFile(szVCardName, szVCardTempFile);
    if(FAILED(hr))
        goto error;

    hr = OpenFileStream((LPSTR)szVCardTempFile, OPEN_EXISTING, GENERIC_READ, &pstmFile);
    if(FAILED(hr))
        goto error;

    hr = MimeOleCreateVirtualStream(&pstmCopy);
    if(FAILED(hr))
        goto error;

    hr = HrCopyStream(pstmFile, pstmCopy, NULL);
    if(FAILED(hr))
        goto error;

    wsprintf(szVCFName, "%s%s", szVCardName, ".vcf");

    hr = pMsg->AttachFile(szVCFName, pstmCopy, FALSE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pstmFile);
    ReleaseObj(pstmCopy);
    ReleaseObj(lpWab);

    DeleteFile(szVCardTempFile);
    return hr;
}

// IPersistMime::Save
HRESULT CNoteHdr::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    HRESULT         hr = NOERROR;
    BOOL            fSkipCheck = FALSE;

    Assert(m_lpWabal);

    // If sending, then previously did a CheckNames passing FALSE. If get here, 
    // then either all the names are resolved, or we are not sending so don't care
    // what error codes are returned.
    HrCheckNames(TRUE, FALSE);

    // RAID 41350. If the save fails after leaving the header, the header
    // recipients might be in a bad state. Make sure that they are resolved again 
    // after the save.
    m_fAddressesChanged = TRUE;

    // Is the security inited???
    if(dwFlags != 0)
        m_fSecurityInited = FALSE;

    // This call will check if the dialog has been shown or if we are not mime and
    // therefore should not show the dialog either.
    if (m_pHeaderSite)
        fSkipCheck = (S_OK != m_pHeaderSite->CheckCharsetConflict());

    if (fSkipCheck)
    {
        IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

        // Ignore any charset conflict errors.
        hr = S_OK;
    }
    else
    {
        IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, TRUE));

        if (MIME_S_CHARSET_CONFLICT == hr)
        {
            int         ret;
            PROPVARIANT Variant;
            HCHARSET    hCharset;

            // Setup the Variant
            Variant.vt = VT_UI4;

            if (m_pEnvelopeSite && m_fShowedUnicodeDialog)
                ret = m_iUnicodeDialogResult;
            else
            {
                ret = IntlCharsetConflictDialogBox();

                if (m_pEnvelopeSite)
                {
                    m_fShowedUnicodeDialog = TRUE;
                    m_iUnicodeDialogResult = ret;
                }
            }

            // Save As Is...
            if (ret == IDOK)
            {
                IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

                // User choose to send as is. Bail out and pretend no charset conflict
                hr = S_OK;
            }
            // Save as Unicode
            else if (ret == idcSendAsUnicode)
            {
                // User choose to send as Unicode (UTF8). set new charset and resnd
                hCharset = GetMimeCharsetFromCodePage(CP_UTF8);
                if (m_pHeaderSite)
                    m_pHeaderSite->ChangeCharset(hCharset);
                else
                {
                    pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
                    ChangeLanguage(m_pMsg);

                    // bobn [6/23/99] Raid 77019
                    // If we switch to unicode and we're a word note, we
                    // need to remember that we're unicode so that we
                    // will not have the body encoding out of sync with
                    // the header encoding
                    if (m_pEnvelopeSite)
                        m_hCharset = hCharset;
                }
                IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

                Assert(MIME_S_CHARSET_CONFLICT != hr);
            }
            else
            {
                // return to edit mode and bail out
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
        }
        else
        {
            IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));
            Assert(MIME_S_CHARSET_CONFLICT != hr);
        }
    }

exit:

    return hr;
}

HRESULT CNoteHdr::_UnicodeSafeSave(IMimeMessage *pMsg, BOOL fCheckConflictOnly)
{
    HRESULT     hr = S_OK;
    UINT        cpID = 0;
    WCHAR       wsz[cchMaxSubject+1];
    PROPVARIANT rVariant;
    SYSTEMTIME  st;

    HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), wsz, ARRAYSIZE(wsz), FALSE);

    // All checks in here had better exit if get a MIME_S_CHARSET_CONFLICT
    if (fCheckConflictOnly)
    {
        HCHARSET        hCharSet;
        BOOL            fGetDefault = TRUE;

        // Get charset for header
        if (m_pHeaderSite)
        {
            if (SUCCEEDED(m_pHeaderSite->GetCharset(&hCharSet)))
            {
                cpID = CustomGetCPFromCharset(hCharSet, FALSE);
                fGetDefault = FALSE;
            }
        }

        // Get default charset if didn't get one from header
        if (fGetDefault)
        {
            pMsg->GetCharset(&hCharSet);
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }

        // If we are unicode, then there is no need to check because
        // we will always work, so exit.
        if (CP_UTF7 == cpID || CP_UTF8 == cpID || CP_UNICODE == cpID)
            goto exit;

        IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMsg, m_pAccount, m_lpWabal, m_fMail, cpID, TRUE));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        IF_FAILEXIT(hr = HrSafeToEncodeToCP(wsz, cpID));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        if (m_pszRefs)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(m_pszRefs, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        IF_FAILEXIT(hr = HrCheckDisplayNames(m_lpWabal, cpID));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        if (m_lpAttMan)
        {
            IF_FAILEXIT(hr = m_lpAttMan->CheckAttachNameSafeWithCP(cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        if (!m_fMail)
        {
            IF_FAILEXIT(hr = HrNewsSave(pMsg, cpID, TRUE));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

// this checking produced a 4 bugs in OE 5.01 and 5.5 and I disaable it (YST)
#ifdef YST
        if (m_pEnvelopeSite)
        {
            IF_FAILEXIT(hr = _CheckMsoBodyCharsetConflict(cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }
#endif
    }
    else
    {
        // ************************
        // This portion only happens on save, so don't try to do for fCheckConflictOnly
        // Anything not in this section had better be mirrored in the fCheckConflictOnly block above

        IF_FAILEXIT(hr = HrSetAccountByAccount(pMsg, m_pAccount));

        if (m_fVCard)
        {
            HWND    hwndFocus=GetFocus();

            hr = _AttachVCard(pMsg);
            if (FAILED(hr))
            {
                if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(m_fMail?idsAthenaMail:idsAthenaNews),
                                  MAKEINTRESOURCEW(idsErrAttachVCard), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
                {
                    ::SetFocus(hwndFocus);
                    IF_FAILEXIT(hr);
                }
            }
        }

        // set the time
        rVariant.vt = VT_FILETIME;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &rVariant.filetime);
        pMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);

        // Priority
        if (m_pri!=priNone)
        {
            rVariant.vt = VT_UI4;
            rVariant.ulVal = priLookup[m_pri];
            pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
        }

        IF_FAILEXIT(hr = HrSaveSecurity(pMsg));
        // end of save only portion.
        // *************************

        m_lpWabal->DeleteRecipType(MAPI_ORIG);
        IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMsg, m_pAccount, m_lpWabal, m_fMail, 0, FALSE));
        IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, wsz));

        if (m_pszRefs)
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, m_pszRefs));

        // This must be called after HrSaveSecurity
        IF_FAILEXIT(hr = HrSetWabalOnMsg(pMsg, m_lpWabal));

        if (m_lpAttMan)
            IF_FAILEXIT(hr = m_lpAttMan->Save(pMsg, 0));

        if (!m_fMail)
            IF_FAILEXIT(hr = HrNewsSave(pMsg, cpID, FALSE));
    }

exit:
    return hr;
}

// IPersist::GetClassID
HRESULT CNoteHdr::GetClassID(CLSID *pClsID)
{
    //TODO:
    *pClsID = CLSID_OEEnvelope;
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
// IHeader::SetRect
HRESULT CNoteHdr::SetRect(LPRECT prc)
{
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right-prc->left, prc->bottom - prc->top, TRUE);
    return NOERROR;
}


// IHeader::GetRect
HRESULT CNoteHdr::GetRect(LPRECT prcView)
{
    GetRealClientRect(m_hwnd, prcView);
    return NOERROR;
}



// IHeader::Init
HRESULT CNoteHdr::Init(IHeaderSite* pHeaderSite, HWND hwndParent)
{
    if (pHeaderSite==NULL || hwndParent==NULL)
        return E_INVALIDARG;

    m_pHeaderSite = pHeaderSite;
    m_pHeaderSite->AddRef();
    m_hwndParent = hwndParent;

    return HrInit(NULL);
}


// IHeader::SetPriority
HRESULT CNoteHdr::SetPriority(UINT pri)
{
    RECT rc;

    if ((UINT)m_pri != pri)
    {
        m_pri = pri;

        InvalidateStatus();
        ReLayout();

        SetDirtyFlag();
    }

    return NOERROR;
}


// IHeader::GetPriority
HRESULT CNoteHdr::GetPriority(UINT* ppri)
{
    *ppri = m_pri;
    return NOERROR;
}

// Update fiels, which depends from language
void CNoteHdr::_UpdateTextFields(BOOL fSetWabal)
{
    LPWSTR  lpszOrg = NULL,
            lpszSubj = NULL,
            lpszKeywords = NULL;

    if (IsReadOnly())
    {
        // if it's a readnote, reload the header that depend on a charset
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpszSubj);
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, &lpszKeywords);
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, &lpszOrg);

        if(lpszOrg)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTOrg), lpszOrg, FALSE);
            MemFree(lpszOrg);
        }

        if(lpszKeywords)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), lpszKeywords, FALSE);
            MemFree(lpszKeywords);
        }

        if(lpszSubj)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), lpszSubj, FALSE);
            MemFree(lpszSubj);
        }

        if (fSetWabal)
        {
            LPWABAL lpWabal = NULL;

            Assert(m_hwnd);
            Assert(m_pMsg);
            Assert(m_lpWabal);            

            if (SUCCEEDED(HrGetWabalFromMsg(m_pMsg, &lpWabal)))
            {
                ReplaceInterface(m_lpWabal, lpWabal);

                if (SUCCEEDED(m_pAddrWells->HrSetWabal(m_lpWabal)))
                {
                    m_lpWabal->HrResolveNames(NULL, FALSE);
                    m_pAddrWells->HrDisplayWells(m_hwnd);
                }
            }
            ReleaseObj(lpWabal);
        }

        m_fDirty = FALSE; // don't make dirty if a readnote
    }
}

// IHeader::ChangeLanguage
HRESULT CNoteHdr::ChangeLanguage(LPMIMEMESSAGE pMsg)
{
    HCHARSET    hCharset=NULL;

    if (!pMsg)
        return E_INVALIDARG;

    pMsg->GetCharset(&hCharset);

     // Update fields, which depends from language
    _UpdateTextFields(TRUE);

    // update the fonts scripts etc
    HrUpdateCharSetFonts(hCharset, TRUE);
    
    // notify the addr wells that the font need to change
    m_pAddrWells->OnFontChange();
    return S_OK;
}




HRESULT CNoteHdr::OnPreFontChange()
{
    HWND        hwndFrom=GetDlgItem(m_hwnd, idFromCombo);

    if (hwndFrom)
        SendMessage(hwndFrom, WM_SETFONT, 0, 0);
    return S_OK;
}

HRESULT CNoteHdr::OnPostFontChange()
{
    ULONG       cxNewLeftMargin = _GetLeftMargin();
    HWND        hwndFrom=GetDlgItem(m_hwnd, idFromCombo);
    HFONT       hFont;
    HWND        hwndBlock = HwndStartBlockingPaints(m_hwnd);
    BOOL        fLayout=FALSE;

    if (g_pFieldSizeMgr->FontsChanged() || (m_cxLeftMargin != cxNewLeftMargin))
    {
        m_cxLeftMargin = cxNewLeftMargin;
        fLayout=TRUE;
    }

    // update the fonts
    ChangeLanguage(m_pMsg);

    // update the account combo
    if (hwndFrom && 
        g_lpIFontCache &&
        g_lpIFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(hwndFrom, WM_SETFONT, (WPARAM)hFont, 0);

    if (fLayout)
        ReLayout();

    if (hwndBlock)
        StopBlockingPaints(hwndBlock);

    return S_OK;
}


// IHeader::GetTitle
HRESULT CNoteHdr::GetTitle(LPWSTR pwszTitle, ULONG cch)
{
    // Locals
    static WCHAR    s_wszNoteTitle[cchHeaderMax+1] = L"";
    static DWORD    s_cLenTitle = 0;
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = 0;
    HRESULT         hr = S_OK;   
    LPWSTR          pwszLang = NULL;
    BOOL            fWinNT = g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    if (pwszTitle==NULL || cch==0)
        return E_INVALIDARG;

    if (*s_wszNoteTitle == L'\0')
    {
        if (fWinNT)
        {
            AthLoadStringW(idsNoteLangTitle, s_wszNoteTitle, ARRAYSIZE(s_wszNoteTitle));

            // -4 for the %1 and %2 that will be replaced
            s_cLenTitle = lstrlenW(s_wszNoteTitle) - 4; 
        }
        else
        {
            AthLoadStringW(idsNoteLangTitle9x, s_wszNoteTitle, ARRAYSIZE(s_wszNoteTitle));

            // -2 for the %s that will be replaced
            s_cLenTitle = lstrlenW(s_wszNoteTitle) - 2; 
        }
    }

    if (m_hCharset)
    {
        MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);
        uiCodePage = CsetInfo.cpiWindows;
    }

    if (uiCodePage == 0 || uiCodePage == GetACP())
    {
        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), pwszTitle, cch-1, FALSE);
        if (0 == *pwszTitle)
            AthLoadStringW((OENA_READ == m_ntNote) ? idsNoSubject : idsNewNote, pwszTitle, cch-1);

        ConvertTabsToSpacesW(pwszTitle);
    }
    else
    {
        AssertSz(cch > (ARRAYSIZE(CsetInfo.szName) + s_cLenTitle), "Won't fit language. Get bigger cch!!!");

        // if no lang pack then s_szLastLang is empty and we need to try to restore message header
        IF_NULLEXIT(pwszLang = PszToUnicode(CP_ACP, *m_szLastLang ? m_szLastLang : CsetInfo.szName));

        if (fWinNT)
        {
            WCHAR   wszSubj[cchHeaderMax+1];
            DWORD   cchLang,
                    cchTotal,
                    cchSubj;
            LPSTR   pArgs[2];

            *wszSubj = 0;

            HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), wszSubj, ARRAYSIZE(wszSubj), FALSE);
            if (0 == *wszSubj)
                AthLoadStringW((OENA_READ == m_ntNote) ? idsNoSubject : idsNewNote, wszSubj, ARRAYSIZE(wszSubj));

            ConvertTabsToSpacesW(wszSubj);

            cchSubj = lstrlenW(wszSubj);
            cchLang = lstrlenW(pwszLang);
            cchTotal = s_cLenTitle + cchLang + cchSubj + 1;

            // If too big, truncate the subject, not language since
            // asserting that we have enough for language.
            if (cchTotal > cch)
            {
                cchSubj -= (cchTotal - cch);
                wszSubj[cchSubj] = L'\0';
            }

            pArgs[0] = (LPSTR)wszSubj;
            pArgs[1] = (LPSTR)pwszLang;
            *pwszTitle = L'\0';
            FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           s_wszNoteTitle,
                           0, 0,
                           pwszTitle,
                           cch,
                           (va_list*)pArgs);
        }
        else
        {
            AthwsprintfW(pwszTitle, cch, s_wszNoteTitle, pwszLang);
        }
    }

exit:
    MemFree(pwszLang);
    return hr;
}


void CNoteHdr::_AddRecipTypeToMenu(HMENU hmenu)
{
    ADRINFO     adrInfo;
    WCHAR       wszDisp[256];
    ULONG       uPos=0;

    BOOL fFound = m_lpWabal->FGetFirst(&adrInfo);
    while (fFound && (uPos < cMaxRecipMenu))
    {
        if (adrInfo.lRecipType==MAPI_TO || adrInfo.lRecipType==MAPI_CC)
        {
            if(lstrlenW(adrInfo.lpwszDisplay) > 255)
            {
                StrCpyNW(wszDisp, adrInfo.lpwszDisplay, 255);
                wszDisp[255] = '\0';
            }
            else
                StrCpyW(wszDisp, adrInfo.lpwszDisplay);

            AppendMenuWrapW(hmenu, MF_STRING , ID_ADD_RECIPIENT_FIRST+uPos, wszDisp);
            uPos++;
        }
        fFound = m_lpWabal->FGetNext(&adrInfo);
    }
}

// IHeader::UpdateRecipientMenu
HRESULT CNoteHdr::UpdateRecipientMenu(HMENU hmenu)
{
    HRESULT     hr = E_FAIL;
    BOOL        fSucceeded = TRUE;

    // destory current recipients
    while (fSucceeded)
        fSucceeded = DeleteMenu(hmenu, 2, MF_BYPOSITION);

    if (!m_lpWabal)
        return E_FAIL;

    // Add To: and Cc: people
    _AddRecipTypeToMenu(hmenu);

    return NOERROR;
}


// IHeader::SetInitFocus
HRESULT CNoteHdr::SetInitFocus(BOOL fSubject)
{
    if (m_rgHCI)
    {
        if (fSubject)
            ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
        else
        {
            if (0 == (m_rgHCI[0].dwFlags & HCF_COMBO))
                ::SetFocus(GetDlgItem(m_hwnd, m_rgHCI[0].idEdit));
            else
                ::SetFocus(GetDlgItem(m_hwnd, m_rgHCI[1].idEdit));
        }
    }
    return NOERROR;
}


// IHeader::SetVCard
HRESULT CNoteHdr::SetVCard(BOOL fFresh)
{
    HRESULT     hr = NOERROR;
    TCHAR       szBuf[MAX_PATH];
    LPWAB       lpWab = NULL;
    ULONG       cbEID=0;
    LPENTRYID   lpEID = NULL;
    WORD        wVCard;

    if (m_ntNote == OENA_READ)
        wVCard = (m_lpAttMan->HrFVCard() == S_OK) ? VCardTRUE : VCardFALSE;
    else if (!fFresh) //not a fresh note.
        wVCard = VCardFALSE;
    else if (m_ntNote == OENA_FORWARD)
        wVCard = (m_lpAttMan->HrCheckVCardExists(m_fMail) == S_OK) ? VCardFALSE : VCardDONTKNOW;
    else
        wVCard = VCardDONTKNOW;

    if (wVCard != VCardDONTKNOW)
        m_fVCard = wVCard;
    else
    {
        hr = HrGetVCardName(szBuf, sizeof(szBuf));
        if (FAILED(hr)) // no vcard name selected
        {
            if (m_fMail)
                SetDwOption(OPT_MAIL_ATTACHVCARD, FALSE, NULL, 0);
            else
                SetDwOption(OPT_NEWS_ATTACHVCARD, FALSE, NULL, 0);
        }

        if (m_fMail)
            m_fVCard = (BOOL)DwGetOption(OPT_MAIL_ATTACHVCARD);
        else
            m_fVCard = (BOOL)DwGetOption(OPT_NEWS_ATTACHVCARD);
    }

    hr = HrOnOffVCard();
    if (FAILED(hr))
        goto error;

    error:
    ReleaseObj(lpWab);
    return hr;
}


// IHeader::IsSecured
HRESULT CNoteHdr::IsSecured()
{
    if (m_fDigSigned || m_fEncrypted)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CNoteHdr::IsHeadSigned()
{
    if (m_fDigSigned)
        return S_OK;
    else
        return S_FALSE;
}

// set ForvrEncryption  form policy module if fSet is TRUE
// if fSet is not set then returns S_FALSE if ForceEncryption was not set

HRESULT CNoteHdr::ForceEncryption(BOOL *fEncrypt, BOOL fSet)
{
    HRESULT hr = S_FALSE;
    if(fSet)
    {
        Assert(fEncrypt);
        if(m_fDigSigned)
        {
            if(*fEncrypt)
                m_fEncrypted = TRUE;

        }
        m_fForceEncryption = *fEncrypt;
        if(m_ntNote != OENA_READ)
            HrUpdateSecurity();
        hr = S_OK;
    }
    else if(m_fForceEncryption && m_fDigSigned)
    {
        m_fEncrypted = TRUE;
        hr = S_OK;
    }

    return(hr);
}

// IHeader::AddRecipient
HRESULT CNoteHdr::AddRecipient(int idOffset)
{
    BOOL        fFound;
    ULONG       uPos=0;
    ADRINFO     adrInfo;
    LPADRINFO   lpAdrInfo=0;
    LPWAB       lpWab;
    HRESULT     hr=E_FAIL;

    Assert(m_lpWabal);

    fFound = m_lpWabal->FGetFirst(&adrInfo);
    while (fFound &&
           (uPos < cMaxRecipMenu))
    {
        if (idOffset==-1  &&
            adrInfo.lRecipType==MAPI_ORIG)
        {
            lpAdrInfo=&adrInfo;
            break;
        }

        if (adrInfo.lRecipType==MAPI_TO || adrInfo.lRecipType==MAPI_CC)
        {
            if (idOffset==(int)uPos)
            {
                lpAdrInfo=&adrInfo;
                break;
            }
            uPos++;
        }
        fFound=m_lpWabal->FGetNext(&adrInfo);
    }

    if (lpAdrInfo &&
        !FAILED (HrCreateWabObject (&lpWab)))
    {
        hr=lpWab->HrAddToWAB(m_hwnd, lpAdrInfo);
        lpWab->Release ();
    }

    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
    {
        if (hr==MAPI_E_COLLISION)
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
        else
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);
    }

    return NOERROR;
}


// IHeader::OnDocumentReady
HRESULT CNoteHdr::OnDocumentReady(LPMIMEMESSAGE pMsg)
{
    HRESULT hr = S_OK;

    m_fStillLoading = FALSE;
    if (m_lpAttMan)
        hr = m_lpAttMan->Load(pMsg);

    return hr;
}


// IHeader::DropFiles
HRESULT CNoteHdr::DropFiles(HDROP hDrop, BOOL fMakeLinks)
{
    HRESULT hr = S_OK;
    if (m_lpAttMan)
        hr = m_lpAttMan->HrDropFiles(hDrop, fMakeLinks);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IMsoEnvelope:Init
HRESULT CNoteHdr::Init(IUnknown* punk, IMsoEnvelopeSite* pesit, DWORD grfInit)
{
    HRESULT         hr = S_OK;

    if (punk == NULL && pesit == NULL && grfInit == 0)
    {
        SafeRelease(m_pEnvelopeSite);
        hr = E_FAIL;
        goto Exit;
    }

    if (pesit==NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    ReplaceInterface(m_pEnvelopeSite, pesit);

    hr = HrInit(NULL);
    if (FAILED(hr))
        goto Exit;

    if (grfInit & ENV_INIT_FROMSTREAM)
    {
        IStream        *pstm = NULL;

        // no IStream to work with?
        if (!punk)
            return E_INVALIDARG;
        
        hr = punk->QueryInterface(IID_IStream, (LPVOID*)&pstm);
        if (!FAILED(hr))
        {
            hr = _LoadFromStream(pstm);
            pstm->Release();
        }
    }

    _SetButtonText(ID_SEND_NOW, MAKEINTRESOURCE((grfInit & ENV_INIT_DOCBEHAVIOR)?idsEnvSendCopy:idsEnvSend));
    
Exit:
    return hr;
}


// IMsoEnvelope::SetParent
// we create the envelope window here
HRESULT CNoteHdr::SetParent(HWND hwndParent)
{
    Assert (IsWindow(m_hwnd));

    ShowWindow(m_hwnd, hwndParent ? SW_SHOW : SW_HIDE);

    if (hwndParent)
    {
        _RegisterWithComponentMgr(TRUE);
        _RegisterAsDropTarget(TRUE);
        _RegisterWithFontCache(TRUE);
    }
    else
    {
        _RegisterWithComponentMgr(FALSE);
        _RegisterAsDropTarget(FALSE);
        _RegisterWithFontCache(FALSE);
    }

    m_hwndParent = hwndParent?hwndParent:g_hwndInit;
    ::SetParent(m_hwnd, m_hwndParent);

    if (hwndParent)
        ReLayout();

    return S_OK;
}

// IMsoEnvelope::Resize
HRESULT CNoteHdr::Resize(LPCRECT prc)
{
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right - prc->left, prc->bottom - prc->top, TRUE);
    return NOERROR;
}

// IMsoEnvelope::Show
HRESULT CNoteHdr::Show(BOOL fShow)
{
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    return NOERROR;
}

// IMsoEnvelope::SetHelpMode
HRESULT CNoteHdr::SetHelpMode(BOOL fEnter)
{
    return NOERROR;
}

// IMsoEnvelope::Save
HRESULT CNoteHdr::Save(IStream* pstm, DWORD grfSave)
{
    HRESULT         hr = S_OK;
    IMimeMessage   *pMsg = NULL;
    PERSISTHEADER   rPersistHdr;

    if (pstm == NULL)
        return E_INVALIDARG;

    hr = WriteClassStm(pstm, CLSID_OEEnvelope);
    if (!FAILED(hr))
    {
        ZeroMemory(&rPersistHdr, sizeof(PERSISTHEADER));
        rPersistHdr.cbSize = sizeof(PERSISTHEADER);
        hr = pstm->Write(&rPersistHdr, sizeof(PERSISTHEADER), NULL);
        if (!FAILED(hr))
        {
            hr = HrCreateMessage(&pMsg);
            if (!FAILED(hr))
            {
                hr = Save(pMsg, 0);
                if (!FAILED(hr))
                    hr = pMsg->Save(pstm, FALSE);
        
                pMsg->Release();    
            }
        }
    }
    
    _ClearDirtyFlag();
    return hr;
}

// IMsoEnvelope::GetAttach
HRESULT CNoteHdr::GetAttach(const WCHAR* wszName,IStream** ppstm)
{
    return NOERROR;
}

HRESULT CNoteHdr::SetAttach(const WCHAR* wszName, const WCHAR *wszCID, IStream **ppstm, DWORD *pgrfAttach)
{
    IStream     *pstm=0;
    HBODY       hBody;
    LPWSTR      pszCntTypeW=NULL;
    HRESULT     hr;
    PROPVARIANT pv;

    if (!m_pMsgSend)
        return E_FAIL;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    IF_FAILEXIT(hr = m_pMsgSend->AttachURL(NULL, NULL, 0, pstm, NULL, &hBody));

    // strip off cid: header
    if (StrCmpNIW(wszCID, L"CID:", 4)==0)
        wszCID += 4;

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(m_pMsgSend, hBody, PIDTOSTR(PID_HDR_CNTID), 0, wszCID));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(m_pMsgSend, hBody, PIDTOSTR(STR_ATT_FILENAME), 0, wszName));

    FindMimeFromData(NULL, wszName, NULL, NULL, NULL, 0, &pszCntTypeW, 0);
    pv.vt = pszCntTypeW ? VT_LPWSTR : VT_LPSTR;
    if (pszCntTypeW)
        pv.pwszVal = pszCntTypeW;
    else
        pv.pszVal = (LPSTR)STR_MIME_APPL_STREAM;        // if FindMimeFromData fails use application/octect-stream

    IF_FAILEXIT(hr = m_pMsgSend->SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &pv));

    *ppstm = pstm;
    pstm->AddRef();

exit:
    ReleaseObj(pstm);
    return hr;
}

// IMsoEnvelope::NewAttach
HRESULT CNoteHdr::NewAttach(const WCHAR* pwzName,DWORD grfAttach)
{
    return NOERROR;
}

// IMsoEnvelope::SetFocus
HRESULT CNoteHdr::SetFocus(DWORD grfFocus)
{
    if (!m_rgHCI)
        return S_OK;

    if (grfFocus & ENV_FOCUS_TAB)
    {
        // reverse tab in from word, focus on well if visible or subject
        if (IsWindowVisible(GetDlgItem(m_hwnd, idwAttachWell)))
            ::SetFocus(GetDlgItem(m_hwnd, idwAttachWell));
        else
            ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
    }
        else if (grfFocus & ENV_FOCUS_INITIAL)
        SetInitFocus(FALSE);
    else if (grfFocus & ENV_FOCUS_RESTORE && m_hwndLastFocus)
        ::SetFocus(m_hwndLastFocus);

    return NOERROR;
}

// IMsoEnvelope::GetHeaderInfo
HRESULT CNoteHdr::GetHeaderInfo(ULONG dispid, DWORD grfHeader, void** pszData)
{
    HRESULT hr = E_FAIL;

    if (!pszData)
        return E_INVALIDARG;

    *pszData = NULL;
    if (dispid == dispidSubject)
        hr = HrGetFieldText((LPWSTR*)pszData, idTXTSubject);

    return hr;
}

// IMsoEnvelope::SetHeaderInfo
HRESULT CNoteHdr::SetHeaderInfo(ULONG dispid, const void *pv)
{
    HRESULT hr = S_OK;
    LPSTR   psz = NULL;

    switch (dispid)
    {
        case dispidSubject:
                HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), (LPWSTR)pv, FALSE);
            break;

        case dispidSendBtnText:
        {
            IF_NULLEXIT(psz = PszToANSI(GetACP(), (LPWSTR)pv));

            _SetButtonText(ID_SEND_NOW, psz);
            break;
        }
    }

exit:
    MemFree(psz);
    return NOERROR;
}

// IMsoEnvelope::IsDirty
HRESULT CNoteHdr::IsDirty()
{
    if (m_fDirty || (m_lpAttMan->HrIsDirty()==S_OK))
        return S_OK;
    else
        return S_FALSE;
}

// IMsoEnvelope::GetLastError
HRESULT CNoteHdr::GetLastError(HRESULT hr, WCHAR __RPC_FAR *wszBuf, ULONG cchBuf)
{
    DWORD ids;

    switch (hr)
    {
        case E_NOTIMPL:
            ids = idsNYIGeneral;
            break;

        default:
            ids = idsGenericError;
    }

    AthLoadStringW(ids, wszBuf, cchBuf);

    return S_OK;
}

// IMsoEnvelope::DoDebug
HRESULT CNoteHdr::DoDebug(DWORD grfDebug)
{
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////
// IMsoComponent::FDebugMessage
BOOL CNoteHdr::FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam)
{
    return TRUE;
}


// IMsoComponent::FPreTranslateMessage
BOOL CNoteHdr::FPreTranslateMessage(MSG *pMsg)
{
    HWND    hwnd;
    BOOL    fShift;

    // Invalid ARgs
    if (NULL == pMsg)
        return FALSE;

    // check if it's US, or one of our children
    if (pMsg->hwnd != m_hwnd && !IsChild(m_hwnd, pMsg->hwnd))
        return FALSE;

    if (pMsg->message == WM_KEYDOWN &&
        pMsg->wParam == VK_ESCAPE &&
        GetFocus() == m_hwndToolbar &&
        m_hwndLastFocus)
    {
        // when focus is inthe toolbar, we're not UIActive (cheaper than subclassing to catch WM_SETFOCUS\WM_KILLFOCUS
        // as toolbar doesn't send NM_SETFOCUS). So we special case ESCAPE to drop the focus from the toolbar
        ::SetFocus(m_hwndLastFocus);
        return TRUE;
    }

    // check to see if we are UIActive
    if (!m_fUIActive)
        return FALSE;

    // check and see if it's one of our accelerators
    if (::TranslateAcceleratorWrapW(m_hwnd, GetAcceleratorTable(), pMsg))
        return TRUE;
    
    // handle tab-key here
    if (pMsg->message == WM_KEYDOWN &&
        pMsg->wParam == VK_TAB)
    {
        fShift = ( GetKeyState(VK_SHIFT ) & 0x8000) != 0;

        if (!fShift && 
            (GetKeyState(VK_CONTROL) & 0x8000))
        {
            // ctrl-TAB means focus to the toolbar
            ::SetFocus(m_hwndToolbar);
            return TRUE;
        }

        hwnd = _GetNextDlgTabItem(m_hwnd, pMsg->hwnd, fShift);
        if (hwnd != NULL)
            ::SetFocus(hwnd);
        else
            if (m_pEnvelopeSite)
                m_pEnvelopeSite->SetFocus(TRUE);
        return TRUE;
    }

    // pass the accelerators to the envelopesite
    if (m_pEnvelopeSite && 
       (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) &&
       m_pEnvelopeSite->TranslateAccelerators(pMsg)==S_OK)
        return TRUE;

    // see if it's a message for our child controls
    if (pMsg->message != WM_SYSCHAR &&
        IsDialogMessageWrapW(m_hwnd, pMsg))
        return TRUE;

    return FALSE;
}


// IMsoComponent::OnEnterState
void CNoteHdr::OnEnterState(ULONG uStateID, BOOL fEnter)
{
    return;
}


// IMsoComponent::OnAppActivate
void CNoteHdr::OnAppActivate(BOOL fActive, DWORD dwOtherThreadID)
{
    return;
}


// IMsoComponent::OnLoseActivation
void CNoteHdr::OnLoseActivation()
{
    return;
}


// IMsoComponent::OnActivationChange
void CNoteHdr::OnActivationChange(IMsoComponent *pic, BOOL fSameComponent, const MSOCRINFO *pcrinfo, BOOL fHostIsActivating, const MSOCHOSTINFO *pchostinfo, DWORD dwReserved)
{
    return;
}


// IMsoComponent::FDoIdle
BOOL CNoteHdr::FDoIdle(DWORD grfidlef)
{
    return FALSE;
}


// IMsoComponent::FContinueMessageLoop
BOOL CNoteHdr::FContinueMessageLoop(ULONG uReason, void *pvLoopData, MSG *pMsgPeeked)
{
    return FALSE;
}


// IMsoComponent::FQueryTerminate
BOOL CNoteHdr::FQueryTerminate(BOOL fPromptUser)
{
    return TRUE;
}


// IMsoComponent::Terminate
void CNoteHdr::Terminate()
{
    _RegisterWithComponentMgr(FALSE);
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

// IMsoComponent::HwndGetWindow
HWND CNoteHdr::HwndGetWindow(DWORD dwWhich, DWORD dwReserved)
{
    HWND hwnd = NULL;
    
    switch (dwWhich)
    {
        case msocWindowComponent:
        case msocWindowDlgOwner:
            hwnd = m_hwnd;
            break;

        case msocWindowFrameOwner:
            hwnd = GetParent(m_hwnd);
            break;

        case msocWindowFrameToplevel:
        {
            if (m_pEnvelopeSite)
                m_pEnvelopeSite->GetFrameWnd(&hwnd);
            return hwnd;
        }
    }
    return hwnd;
}


// HrUpdateCharSetFonts
//
// Purpose: Creates the controls on the header dialog
//          calculates and sets up all initial coordinates
//
//
// Comments:
//
HRESULT CNoteHdr::HrUpdateCharSetFonts(HCHARSET hCharset, BOOL fUpdateFields)
{
    PHCI            phci;
    HWND            hwnd;
    INT             iHC;
    TCHAR           sz[cchHeaderMax+1];
    BOOL            fDirty=m_fDirty;
    INETCSETINFO    rCharset;
    HRESULT         hr = E_FAIL;

    // Check Params
    Assert(hCharset);

    // No font cache, bummer
    if (!g_lpIFontCache)
        return E_FAIL;

    // Get Charset Information
    if (SUCCEEDED(MimeOleGetCharsetInfo(hCharset, &rCharset)))
    {
        HFONT hHeaderFont, hSystemFont;

        if ((m_hCharset != hCharset) || (0 == *m_szLastLang))
        {
            *m_szLastLang = 0;
            GetMimeCharsetForTitle(hCharset, NULL, m_szLastLang, ARRAYSIZE(m_szLastLang) - 1, IsReadOnly());
            // Save Charset
            m_hCharset = hCharset;
        }

        // If don't update fields, then just return
        if (!fUpdateFields)
            return S_OK;

        // Get charset charformat
        hHeaderFont = HGetCharSetFont(FNT_SYS_ICON, hCharset);

        hSystemFont = GetFont(FALSE);

        // Loop through header fields
        for (iHC=0; iHC<(int)m_cHCI; iHC++)
        {
            // Get info
            phci = &m_rgHCI[iHC];
            hwnd = GetDlgItem(m_hwnd, phci->idEdit);
            //Assert(hwndRE);
            if (!hwnd)
                continue;

            switch (phci->dwFlags & (HCF_COMBO|HCF_ATTACH))
            {
                case HCF_COMBO:
                case HCF_ATTACH:
                    SendMessage(hwnd, WM_SETFONT, (WPARAM)hSystemFont, MAKELPARAM(TRUE, 0));
                    break;

                // richedit
                // REVIEW: Why are we only doing a request resize when we have the USECHARSET flag set???
                case 0:
                    if (phci->dwFlags & HCF_USECHARSET)
                    {
                        SetFontOnRichEdit(hwnd, hHeaderFont);
                        SendMessage(hwnd, EM_REQUESTRESIZE, 0, 0);
                    }
                    else
                    {
                        SetFontOnRichEdit(hwnd, hSystemFont);
                    }
                    break;

                default:
                    AssertSz(FALSE, "How did we get something that is combo and attach???");
                    break;
            }
        }
        // Don't let this make the note dirty
        if (fDirty)
            SetDirtyFlag();
        else
            m_fDirty=FALSE;

        hr = S_OK;
    }

    return hr;
}

//
// WMCreate
//
// Purpose: Creates the controls on the header dialog
//          calculates and sets up all initial coordinates
//
//
// Comments:
//
BOOL CNoteHdr::WMCreate()
{
    HWND            hwnd;
    LONG            lStyleFlags,
                    lExStyleFlags,
                    lMask;
    int             cy,
                    cx,
                    cxButtons = ControlXBufferSize();
    HFONT           hFont;
    TOOLINFO        ti;
    PHCI            phci;
    RECT            rc;
    CAddrWellCB    *pawcb;
    CHARFORMAT      cfHeaderCset;
    HRESULT         hr;
    LPCWSTR         pwszTitle = NULL;
    BOOL            fSubjectField;

    Assert(g_cyFont);     // should have been setup already

    if (m_pEnvelopeSite)
    {
        // if we are the office-envelope, create a toolbar
        if (_CreateEnvToolbar())
            return FALSE;
    }

    cy = ControlYBufferSize() + m_dxTBOffset;
    cx = 0;

    if (S_OK != HrInitFieldList())
        return FALSE;

    //BROKEN: using system charformat here as not CSET info with MIMEOLE
    // Get charset for cset
    {
        hFont = GetFont(FALSE);
        if (hFont != 0)
        {
            hr = FontToCharformat(hFont, &g_cfHeader);
        }

        hFont = HGetCharSetFont(FNT_SYS_ICON, m_hCharset);
        if (hFont != 0)
        {
            hr = FontToCharformat(hFont, &cfHeaderCset);
            if (FAILED(hr))
                CopyMemory (&cfHeaderCset, &g_cfHeader, sizeof (CHARFORMAT));
        }
        else
            CopyMemory (&cfHeaderCset, &g_cfHeader, sizeof (CHARFORMAT));
        hFont = GetFont(FALSE);

    }

    // ~~~~ Do we need to be calling this with WrapW???
    // Create a tooltip, if it doesn't already exist:
    m_hwndTT=CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, 0,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,
                            m_hwnd, (HMENU) NULL, g_hInst, NULL);
    if (!m_hwndTT)
        return FALSE;

    ti.cbSize=sizeof(TOOLINFO);
    ti.hwnd=m_hwnd;
    ti.hinst=g_hLocRes;
    ti.uFlags=TTF_IDISHWND|TTF_SUBCLASS;

    m_lpAttMan = new CAttMan();
    if (!m_lpAttMan)
        return FALSE;

    if (m_lpAttMan->HrInit(m_hwnd, m_ntNote==OENA_READ, m_ntNote==OENA_FORWARD, !DwGetOption(OPT_SECURITY_ATTACHMENT)))
        return FALSE;

    for (int iHC=0; iHC<(int)m_cHCI; iHC++)
    {
        phci=&m_rgHCI[iHC];
        BOOL fIsCombo = (HCF_COMBO & phci->dwFlags);
        BOOL fNeedsBorder = (phci->dwFlags & HCF_BORDER);
        int  cyCtrlSize;


        // if header is optional, check setting
        if ((phci->dwFlags & HCF_OPTIONAL) &&
            !DwGetOption(phci->dwOpt))
            continue;

        if (phci->dwFlags & HCF_ATTACH)
        {
            // if we're not readonly, register ourselves as a drop target...
            if (!(phci->dwFlags & HCF_READONLY))
            {
                hr = _RegisterAsDropTarget(TRUE);
                if (FAILED(hr))
                    return FALSE;
            }
            continue;
        }

        phci->height = GetControlSize(fNeedsBorder, 1);

        // Richedit
        if (!fIsCombo)
        {
            pwszTitle = GetREClassStringW();
            cyCtrlSize = phci->height;
            lStyleFlags = WS_CHILD|WS_TABSTOP|WS_VISIBLE|ES_SAVESEL;

            lMask=ENM_KEYEVENTS|ENM_CHANGE|ENM_SELCHANGE|ENM_REQUESTRESIZE;

            if (phci->dwFlags & HCF_MULTILINE)
            {
                //lStyleFlags |= ES_MULTILINE|ES_WANTRETURN|WS_VSCROLL|ES_AUTOVSCROLL;
                lStyleFlags |= ES_MULTILINE|WS_VSCROLL|ES_AUTOVSCROLL;
            }
            else
                lStyleFlags |= ES_AUTOHSCROLL;
        }
        // Combo Box
        else
        {
            pwszTitle = L"ComboBox";
            cyCtrlSize = GetControlSize(fNeedsBorder, NUM_COMBO_LINES);
            lStyleFlags = WS_CHILD|WS_TABSTOP|WS_VISIBLE|WS_VSCROLL|
                        CBS_DROPDOWNLIST|CBS_HASSTRINGS|CBS_SORT;
        }
            
        if (phci->dwFlags & HCF_READONLY)
            lStyleFlags|=ES_READONLY;

        GetClientRect(m_hwnd, &rc);

        lExStyleFlags = fNeedsBorder ? WS_EX_NOPARENTNOTIFY|WS_EX_CLIENTEDGE : WS_EX_NOPARENTNOTIFY;

        // @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
        fSubjectField = (idsSubjectField == phci->idsLabel);
        RichEditRTLMirroring(m_hwnd, fSubjectField, &lExStyleFlags, TRUE);

        // Regardless of mirroring, BiDi-Dates should be displayed RTL
        if(((phci->idsLabel == idsDateField) && IsBiDiCalendar()))
            lExStyleFlags |= WS_EX_RTLREADING;
        hwnd = CreateWindowExWrapW(lExStyleFlags,
                                   pwszTitle,
                                   NULL,
                                   lStyleFlags,
                                   cx, cy, rc.right, cyCtrlSize,
                                   m_hwnd,
                                   (HMENU)IntToPtr(phci->idEdit),
                                   g_hInst, 0 );                                
        if (!hwnd)
            return FALSE;

        RichEditRTLMirroring(m_hwnd, fSubjectField, &lExStyleFlags, FALSE);

        if (0 == (phci->dwFlags & HCF_BORDER))
        {
            SendMessage(hwnd, EM_SETBKGNDCOLOR, WPARAM(FALSE), LPARAM(GetSysColor(COLOR_BTNFACE)));
        }

        ti.uId = (UINT_PTR)hwnd;
        ti.lpszText = (LPTSTR)IntToPtr(phci->idsTT);
        SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM) &ti);

        // hang a pointer into the phci off each control
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)phci);

        if (!fIsCombo)
        {
            LPRICHEDITOLE   preole = NULL;
            ITextDocument  *pDoc = NULL;

            SideAssert(SendMessage(hwnd, EM_GETOLEINTERFACE, NULL, (LPARAM)&preole));
            phci->preole = preole;
            Assert(preole);

            if (SUCCEEDED(preole->QueryInterface(IID_ITextDocument, (LPVOID*)&pDoc)))
                phci->pDoc = pDoc;
            // This only happens with richedit 1.0
            else
                phci->pDoc = NULL;

            // Set edit charformat
            if (phci->dwFlags & HCF_USECHARSET)
                SendMessage(hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&cfHeaderCset);
            else
                SendMessage(hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&g_cfHeader);            

            if ((pawcb = new CAddrWellCB(!(phci->dwFlags&HCF_READONLY), phci->dwFlags&HCF_ADDRWELL)))
            {
                if (pawcb->FInit(hwnd))
                    SendMessage(hwnd, EM_SETOLECALLBACK, 0, (LPARAM)(IRichEditOleCallback *)pawcb);
                ReleaseObj(pawcb);
            }

            SendMessage(hwnd, EM_SETEVENTMASK, 0, lMask);
            g_lpfnREWndProc=(WNDPROC)SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LPARAM)EditSubClassProc);
        }
        else
        {
            CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
            CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
            CHAR                szDefault[CCHMAX_ACCOUNT_NAME];
            CHAR                szEmailAddress[CCHMAX_EMAIL_ADDRESS];
            CHAR                szEntry[ACCT_ENTRY_SIZE];
            CHAR                szDefaultEntry[ACCT_ENTRY_SIZE];
            IImnEnumAccounts   *pEnum=NULL;
            IImnAccount        *pAccount=NULL;
            int                 i = 0;
            DWORD               cAccounts = 0;
            LPSTR              *ppszAcctIDs;

            *szDefault = 0;
            *szDefaultEntry = 0;

            // If default account isn't setup, this might fail, but doesn't matter.
            g_pAcctMan->GetDefaultAccountName(m_fMail?ACCT_MAIL:ACCT_NEWS, szDefault, ARRAYSIZE(szDefault));

            hr = g_pAcctMan->Enumerate(m_fMail?SRV_MAIL:SRV_NNTP, &pEnum);

            if (SUCCEEDED(hr))
                hr = pEnum->GetCount(&cAccounts);

            if (SUCCEEDED(hr) && cAccounts)
            {
                if (!MemAlloc((void**)&m_ppAccountIDs, cAccounts*sizeof(LPSTR)))
                    hr = E_OUTOFMEMORY;
            }


            if (SUCCEEDED(hr))
            {
                *szDefaultEntry = 0;
                ppszAcctIDs = m_ppAccountIDs;
                while(SUCCEEDED(pEnum->GetNext(&pAccount)))
                {
                    *szAccount = 0;
                    *szEmailAddress = 0;

                    pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount));
                    if (m_fMail)
                    {
                        pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress));
                        wsprintf(szEntry, "%s    (%s)", szEmailAddress, szAccount);
                    }
                    else
                        lstrcpy(szEntry, szAccount);

                    i = ComboBox_InsertString(hwnd, -1, szEntry);
                    if (i != CB_ERR)
                    {
                        if (0 == lstrcmpi(szDefault, szAccount))
                            lstrcpy(szDefaultEntry, szEntry);

                        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctID, ARRAYSIZE(szAcctID))))
                        {
                            if (MemAlloc((void**)ppszAcctIDs, (lstrlen(szAcctID) + 1)*sizeof(CHAR)))
                                lstrcpy(*ppszAcctIDs, szAcctID);
                            else
                                *ppszAcctIDs = NULL;
                        }
                        else
                            *ppszAcctIDs = NULL;

                        SendMessage(hwnd, CB_SETITEMDATA, WPARAM(i), LPARAM(*ppszAcctIDs));
                        ppszAcctIDs++;
                        m_cAccountIDs++;
                    }
                    // Release Account
                    SafeRelease(pAccount);
                }
                AssertSz(m_cAccountIDs == cAccounts, "Why isn't num Ds = num accts?");

                SafeRelease(pEnum);
                AssertSz(!pAccount, "The last account didn't get freed.");

                if (0 != *szDefaultEntry)
                {
                    ComboBox_SelectString(hwnd, -1, szDefaultEntry);
                    m_iCurrComboIndex = ComboBox_GetCurSel(hwnd);
                }
                else 
                {
                    ComboBox_SetCurSel(hwnd, 0);
                    m_iCurrComboIndex = 0;
                }

                if (SUCCEEDED(HrGetAccountInHeader(&pAccount)))
                {
                    ReplaceInterface(m_pAccount, pAccount);
                    ReleaseObj(pAccount);
                }

                SendMessage(hwnd, WM_SETFONT, WPARAM(hFont), MAKELONG(TRUE,0));
            }
        }
    }

    _RegisterWithFontCache(TRUE);

    HrOnOffVCard();
    ReLayout();
    return PostWMCreate();  // allow subclass to setup the controls once created...
}


//
// HeaderWndProc
//
// Purpose: Main WNDPROC for header dialog
//
// Comments:
//

LRESULT CALLBACK CNoteHdr::ExtCNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNoteHdr    *pnh = NULL;

    if (msg==WM_NCCREATE)
    {
        SetWndThisPtrOnCreate(hwnd, lParam);
        pnh=(CNoteHdr *)GetWndThisPtr(hwnd);
        if (!pnh)
            return -1;

        pnh->m_hwnd=hwnd;
        return pnh->WMCreate();
    }

    pnh = (CNoteHdr *)GetWndThisPtr(hwnd);
    if (pnh)
        return pnh->CNoteHdrWndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

void CNoteHdr::RelayToolTip(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    MSG     Msg;

    if (m_hwndTT != NULL)
    {
        Msg.lParam=lParam;
        Msg.wParam=wParam;
        Msg.message=msg;
        Msg.hwnd=hwnd;
        SendMessage(m_hwndTT, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &Msg);
    }
}

LRESULT CALLBACK CNoteHdr::CNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    POINT   pt;
    int     newWidth;
    RECT    rc;
    HFONT   hFont=NULL;

    switch (msg)
    {
        case WM_HEADER_GETFONT:
            // update cached fornt for addrobj's
            if (g_lpIFontCache)
                g_lpIFontCache->GetFont(wParam ? FNT_SYS_ICON_BOLD:FNT_SYS_ICON, m_hCharset, &hFont);
            return (LRESULT)hFont;

        case  HDM_TESTQUERYPRI:
            // hack for test team to query header's priority...
            return m_pri;

        case WM_DESTROY:
            OnDestroy();
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_CTLCOLORBTN:
            // make sure the buttons backgrounds are window-color so the ownerdraw
            // imagelists paint transparent OK
            return (LPARAM)GetSysColorBrush(COLOR_WINDOWFRAME);

        case WM_CONTEXTMENU:
            if (m_lpAttMan && m_lpAttMan->WMContextMenu(hwnd, msg, wParam, lParam))
                return 0;
            break;

        case WM_MOUSEMOVE:
            {
                DWORD newButton = GetButtonUnderMouse(LOWORD(lParam), HIWORD(lParam));
                if ((HDRCB_NO_BUTTON == m_dwClickedBtn) || 
                    (HDRCB_NO_BUTTON == newButton) ||
                    (m_dwClickedBtn == newButton))
                if (newButton != m_dwCurrentBtn)
                {
                    DOUTL(PAINTING_DEBUG_LEVEL, "Old button: %d, New Button: %d", m_dwCurrentBtn, newButton);

                    if (HDRCB_NO_BUTTON == newButton)
                    {
                        DOUTL(PAINTING_DEBUG_LEVEL, "Leaving right button framing.");
                        // Need to clear old button.
                        InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);

                        HeaderRelease(FALSE);                
                    }
                    else
                    {
                        DOUTL(PAINTING_DEBUG_LEVEL, "Framing button.");
                        if (HDRCB_NO_BUTTON == m_dwCurrentBtn)
                            HeaderCapture();
                        else
                            InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);

                        GetButtonRect(newButton, &m_rcCurrentBtn);
                        InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);
                    }

                    m_dwCurrentBtn = newButton;
                }
                RelayToolTip(hwnd, msg, wParam, lParam);
                break;
            }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            {
                RECT    rc;
                int x = LOWORD(lParam),
                    y = HIWORD(lParam);

                HeaderCapture();

                m_dwClickedBtn = GetButtonUnderMouse(x, y);
                if (m_dwClickedBtn != HDRCB_NO_BUTTON)
                {
                    GetButtonRect(m_dwClickedBtn, &rc);
                    InvalidateRect(m_hwnd, &rc, FALSE);
                }

                RelayToolTip(hwnd, msg, wParam, lParam);

                break;
            }
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            {
                int x = LOWORD(lParam),
                    y = HIWORD(lParam);
                DWORD iBtn = GetButtonUnderMouse(x, y);

                RelayToolTip(hwnd, msg, wParam, lParam);

                if (m_dwClickedBtn == iBtn)
                    HandleButtonClicks(x, y, iBtn);
                m_dwClickedBtn = HDRCB_NO_BUTTON;
                HeaderRelease(FALSE);                
                break;
            }

        case WM_PAINT:
            WMPaint();
            break;

        case WM_SYSCOLORCHANGE:
            if (m_himl)
            {
                // remap the toolbar bitmap into the new color scheme
                ImageList_Destroy(m_himl);
                SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, NULL);
                m_himl = LoadMappedToolbarBitmap(g_hLocRes, (fIsWhistler() ? ((GetCurColorRes() > 24) ? idb32SmBrowserHot : idbSmBrowserHot): idbNWSmBrowserHot), cxTBButton);
        
                SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);
            }
            
            UpdateRebarBandColors(m_hwndRebar);
            // fall thro'

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendMessage(m_hwndRebar, msg, wParam, lParam);
            break;

        case WM_ERASEBKGND:
            return 1;

        case WM_SIZE:
        {
            STACK("WM_SIZE (width, heigth)", LOWORD(lParam), HIWORD(lParam));

            if (m_fResizing)
                break;

            m_fResizing = TRUE;

            newWidth = LOWORD(lParam);

            SetPosOfControls(newWidth, FALSE);

            if (m_hwndRebar)
            {
                GetClientRect(m_hwndRebar, &rc);

                // resize the width of the toolbar
                if(rc.right != newWidth)
                    SetWindowPos(m_hwndRebar, NULL, 0, 0, newWidth, 30, SETWINPOS_DEF_FLAGS|SWP_NOMOVE);
            }
            
            AssertSz(m_fResizing, "Someone re-entered me!!! Why is m_fResizing already false??");
            m_fResizing = FALSE;
            break;
        }

        case WM_CLOSE:
            //prevent alt-f4
            return 0;

        case WM_COMMAND:
            WMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                      GET_WM_COMMAND_ID(wParam, lParam),
                      GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case WM_NOTIFY:
            return WMNotify(wParam, lParam);
    }
    return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}


void CNoteHdr::HeaderCapture()
{
    if (0 == m_cCapture)
        m_hwndOldCapture = SetCapture(m_hwnd);
    m_cCapture++;
}

void CNoteHdr::HeaderRelease(BOOL fForce)
{
    if (0 == m_cCapture)
        return;

    if (fForce)
        m_cCapture = 0;
    else
        m_cCapture--;

    if (0 == m_cCapture)
    {
        ReleaseCapture();
        if (NULL != m_hwndOldCapture)
        {
            DOUTL(PAINTING_DEBUG_LEVEL, "Restoring old mouse events capture.");
            SetCapture(m_hwndOldCapture);
            m_hwndOldCapture = NULL;
        }
    }
}


BOOL CNoteHdr::WMNotify(WPARAM wParam, LPARAM lParam)
{
    HWND            hwnd=m_hwnd;
    int             idCtl=(int)wParam;
    LPNMHDR         pnmh=(LPNMHDR)lParam;
    TBNOTIFY       *ptbn;
    LPTOOLTIPTEXT   lpttt;
    int             i;

    if (m_lpAttMan->WMNotify((int) wParam, pnmh))
        return TRUE;

    switch (pnmh->code)
    {
        case RBN_CHEVRONPUSHED:
            {                    
                ITrackShellMenu* ptsm;                   
                CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, 
                    (LPVOID*)&ptsm);
                if (!ptsm)
                    break;

                ptsm->Initialize(0, 0, 0, SMINIT_TOPLEVEL|SMINIT_VERTICAL);
            
                LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmh;                                        
                ptsm->SetObscured(m_hwndToolbar, NULL, SMSET_TOP);
            
                MapWindowPoints(m_hwndRebar, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);                  
                POINTL pt = {pnmch->rc.left, pnmch->rc.right};                   
                ptsm->Popup(m_hwndRebar, &pt, (RECTL*)&pnmch->rc, MPPF_BOTTOM);            
                ptsm->Release();                  
                break;      
            }

        case EN_MSGFILTER:
            {
                // if we get a control-tab, then richedit snags this and inserts a
                // tab char, we hook the wm_keydown and never pass to richedit
                if (((MSGFILTER *)pnmh)->msg == WM_KEYDOWN &&
                    ((MSGFILTER *)pnmh)->wParam == VK_TAB && 
                    (GetKeyState(VK_CONTROL) & 0x8000))
                    return TRUE;
                break;
            }

        case ATTN_RESIZEPARENT:
            {
                RECT rc;

                GetClientRect(m_hwnd, &rc);
                SetPosOfControls(rc.right, TRUE);
                return TRUE;
            }

        case EN_REQUESTRESIZE:
            {
                REQRESIZE  *presize=(REQRESIZE *)lParam;
                HWND        hwndEdit = presize->nmhdr.hwndFrom;

                STACK("EN_REQUESTRESIZE (hwnd, width, heigth)", (DWORD_PTR)(presize->nmhdr.hwndFrom), presize->rc.right - presize->rc.left, presize->rc.bottom - presize->rc.top);

                if (S_FALSE != HrUpdateCachedHeight(hwndEdit, &presize->rc) && !m_fResizing)
                {
                    RECT rc;
                    DWORD   dwMask = (DWORD) SendMessage(hwndEdit, EM_GETEVENTMASK, 0, 0);

                    SendMessage(hwndEdit, EM_SETEVENTMASK, 0, dwMask & (~ENM_REQUESTRESIZE));

                    STACK("EN_REQUESTRESIZE after GrowControls");
                    
                    GetClientRect(m_hwnd, &rc);
                    SetPosOfControls(rc.right, FALSE);

                    SendMessage(hwndEdit, EM_SETEVENTMASK, 0, dwMask);
                }

                return TRUE;
            }

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // UIActivate/Deactivate for attachment manager
            if (m_lpAttMan && pnmh->hwndFrom == m_lpAttMan->Hwnd())
                _UIActivate(pnmh->code == NM_SETFOCUS, pnmh->hwndFrom);
            break;

        case EN_SELCHANGE:
            {
                PHCI    phci=(PHCI)GetWndThisPtr(pnmh->hwndFrom);
                if (phci)
                    phci->dwACFlags &= ~AC_SELECTION;
                
                // update office toolbars if running as envelope
                if(m_pEnvelopeSite)
                    m_pEnvelopeSite->DirtyToolbars();

                // on a sel change, forward a note updatetoolbar to update the
                // cut|copy|paste buttons
                if (m_pHeaderSite)
                    m_pHeaderSite->Update();
                return TRUE;
            }

        case TTN_NEEDTEXT:
            // we use TTN_NEEDTEXT to show toolbar tips as we have different tips than toolbar-labels
            // because on the office-envelope toolbar only 2 buttons (send and bcc) have text next to the
            // buttons
            lpttt = (LPTOOLTIPTEXT) pnmh;
            lpttt->hinst = NULL;
            lpttt->lpszText = 0;
            
            for (i=0; i< ARRAYSIZE(c_rgTipLookup); i++)
            {
                if (c_rgTipLookup[i].idm == (int)lpttt->hdr.idFrom)
                {
                    lpttt->hinst = g_hLocRes;
                    lpttt->lpszText = MAKEINTRESOURCE(c_rgTipLookup[i].ids);
                    break;
                }
            }
            break;

        case TBN_DROPDOWN:
            {
                ptbn = (TBNOTIFY *)lParam;

                if (ptbn->iItem == ID_SET_PRIORITY)
                {
                    HMENU hMenuPopup;
                    UINT i;
                    hMenuPopup = LoadPopupMenu(IDR_PRIORITY_POPUP);

                    if (hMenuPopup != NULL)
                    {
                        for (i = 0; i < 3; i++)
                            CheckMenuItem(hMenuPopup, i, MF_UNCHECKED | MF_BYPOSITION);
                        GetPriority(&i);
                        Assert(i != priNone);
                        CheckMenuItem(hMenuPopup, 2 - i, MF_CHECKED | MF_BYPOSITION);

                        DoToolbarDropdown(hwnd, (LPNMHDR) lParam, hMenuPopup);

                        DestroyMenu(hMenuPopup);
                    }
                }
                break;
            }
    }
    return FALSE;
}

HRESULT CNoteHdr::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    HWND    hwnd=m_hwnd;
    int     i;
    UINT    pri;

    if (m_lpAttMan && m_lpAttMan->WMCommand(hwndCmd, id, wCmd))
        return S_OK;

    for (i=0; i<(int)m_cHCI; i++)
        if (m_rgHCI[i].idEdit==id)
        {
            switch (wCmd)
            {
                case EN_CHANGE:
                    {
                        if (m_fHandleChange)
                        {
                            BOOL    fEmpty;
                            PHCI    phci = (PHCI)GetWndThisPtr(hwndCmd);
                            char    sz[cchHeaderMax+1];
                            DWORD   dwMask = 0;

                            RichEditProtectENChange(hwndCmd, &dwMask, TRUE);

                            Assert(phci);
                            fEmpty = (0 == GetRichEditTextLen(hwndCmd));

                            // if it has no text, see if it has object...
                            if (fEmpty && phci->preole)
                                fEmpty = (fEmpty && (0 == phci->preole->GetObjectCount()));

                            if (phci->dwFlags & HCF_ADDRWELL)
                                m_fAddressesChanged = TRUE;

                            phci->fEmpty = fEmpty;
                            SetDirtyFlag();

                            if (m_fAutoComplete && (m_rgHCI[i].dwFlags & HCF_ADDRWELL) && !IsReadOnly())
                            {
                                if (NULL == m_pTable)
                                {
                                    if (NULL == m_lpWab)
                                        HrCreateWabObject(&m_lpWab);
                                    if (m_lpWab)
                                        m_lpWab->HrGetPABTable(&m_pTable);
                                }
                                if (m_pTable)
                                    HrAutoComplete(hwndCmd, &m_rgHCI[i]);
                            }
                            RichEditProtectENChange(hwndCmd, &dwMask, FALSE);
                        }
                    }
                    return S_OK;

                case CBN_SELCHANGE:
                {
                    IImnAccount    *pAcct = NULL;

                    if (!m_fMail)
                    {
                        int     newIndex = ComboBox_GetCurSel(hwndCmd);
                        HWND    hwndNews = GetDlgItem(m_hwnd, idADNewsgroups);

                        // Don't need to warn if going to same account, or if there are no newgroups listed.
                        if ((newIndex != m_iCurrComboIndex) && (0 < GetWindowTextLength(hwndNews)))
                        {
                            if (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSChangeNewsServer, MAKEINTRESOURCE(idsAthena), 
                                                              MAKEINTRESOURCE(idsChangeNewsServer), MB_OKCANCEL))
                            {
                                ComboBox_SetCurSel(hwndCmd, m_iCurrComboIndex);
                                return S_OK;
                            }
                            else
                                HdrSetRichEditText(hwndNews, c_wszEmpty, FALSE);
                        }
                        m_iCurrComboIndex = newIndex;
                    }
                    if (SUCCEEDED(HrGetAccountInHeader(&pAcct)))
                        ReplaceInterface(m_pAccount, pAcct);
                    ReleaseObj(pAcct);

                    return S_OK;
                }

                case CBN_SETFOCUS:
                case EN_SETFOCUS:
                    _UIActivate(TRUE, hwndCmd);
                    return S_OK;

                case CBN_KILLFOCUS:
                case EN_KILLFOCUS:
                    _UIActivate(FALSE, hwndCmd);
                    return S_OK;
            }
            return S_FALSE;
        }

    switch (id)
    {
        case ID_PRIORITY_LOW:
            SetPriority(priLow);
            return S_OK;

        case ID_PRIORITY_NORMAL:
            SetPriority(priNorm);
            return S_OK;

        case ID_PRIORITY_HIGH:
            SetPriority(priHigh);
            return S_OK;

        case ID_SET_PRIORITY:
            GetPriority(&pri);
            pri++;
            if (pri > priHigh)
                pri = priLow;
            SetPriority(pri);
            return S_OK;

        case ID_SELECT_ALL:
            {
                HWND hwndFocus=GetFocus();

                if (GetParent(hwndFocus)==m_hwnd)
                {
                    // only if it's one of our kids..
                    Edit_SetSel(hwndFocus, 0, -1);
                    return S_OK;
                }
            }
            break;

        case ID_CUT:
            if (FDoCutCopyPaste(WM_CUT))
                return S_OK;
            break;

        case ID_NOTE_COPY:
        case ID_COPY:
            if (FDoCutCopyPaste(WM_COPY))
                return S_OK;
            break;

        case ID_PASTE:
            if (FDoCutCopyPaste(WM_PASTE))
                return S_OK;
            break;

        case ID_DELETE_VCARD:
            m_fVCard = FALSE;
            SetDirtyFlag();
            HrOnOffVCard();
            return S_OK;

        case ID_OPEN_VCARD:
            HrShowVCardProperties(m_hwnd);
            return S_OK;

        case ID_DIGITALLY_SIGN:
        case ID_ENCRYPT:
            HrHandleSecurityIDMs(ID_DIGITALLY_SIGN == id);
            return S_OK;

        case ID_ADDRESS_BOOK:
            HrViewContacts();
            return S_OK;

            //this is for office use only
        case ID_CHECK_NAMES:
            HrCheckNames(FALSE, TRUE);
            return S_OK;

            //this is for office use only
        case ID_ENV_BCC:
            if (m_pEnvelopeSite)
            {
                ShowAdvancedHeaders(!m_fAdvanced);

                SetDwOption(OPT_MAILNOTEADVSEND, !!m_fAdvanced, NULL, NULL);

                // ~~~~ m_pHeaderSite is mutually exclusive to m_pEnvelopeSite
                //if (m_pHeaderSite)
                //    m_pHeaderSite->Update();

                return S_OK;
            }
            break;

        case ID_MESSAGE_OPTS:
            ShowEnvOptions();
            return S_OK;

        case ID_SAVE_ATTACHMENTS:
        case ID_NOTE_SAVE_ATTACHMENTS:
            if (m_pHeaderSite)
                m_pHeaderSite->SaveAttachment();

            return S_OK;

        // These next two should only be handled by the header if in the envelope
        case ID_SEND_MESSAGE:
        case ID_SEND_NOW:
            if (m_pEnvelopeSite)
            {
                m_fShowedUnicodeDialog = FALSE;
                m_iUnicodeDialogResult = 0;

                HrSend();
                return S_OK;
            }

        default:
            if (id>=ID_ADDROBJ_OLE_FIRST && id <=ID_ADDROBJ_OLE_LAST)
            {
                DoNoteOleVerb(id-ID_ADDROBJ_OLE_FIRST);
                return S_OK;
            }
    }

    return S_FALSE;
}

HRESULT CNoteHdr::HrAutoComplete(HWND hwnd, PHCI pHCI)
{
    CHARRANGE   chrg, chrgCaret;
    LPWSTR      pszPartial, pszSemiColon, pszComma;
    INT         i, j, len, iTextLen;
    LPWSTR      pszBuf=0;
    WCHAR       szFound[cchMaxWab+1];
    WCHAR       sz;
    HRESULT     hr = NOERROR;

    STACK("HrAutoComplete");

    *szFound = 0;

    // If the IME is open, bail out
    if (0 < m_dwIMEStartCount)
        return hr;

    if (NULL==hwnd || NULL==m_pTable || NULL==pHCI)
        return hr;

    if (pHCI->dwACFlags&AC_IGNORE)
        return hr;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrgCaret);
    if (chrgCaret.cpMin != chrgCaret.cpMax)
        return hr;

    if (S_OK != HrGetFieldText(&pszBuf, hwnd))
        return hr;

    sz = pszBuf[chrgCaret.cpMin];
    if (!(sz==0x0000 || sz==L' ' || sz==L';'|| sz==L',' || sz==L'\r'))
        goto cleanup;

    DOUTL(64, "HrAutoComplete- Didn't exit early");

    pszBuf[chrgCaret.cpMin] = 0x0000;
    pszSemiColon = StrRChrIW(pszBuf, &pszBuf[lstrlenW(pszBuf)], L';');
    pszComma = StrRChrIW(pszBuf, &pszBuf[lstrlenW(pszBuf)], L',');
    if (pszComma >= pszSemiColon)
        pszPartial = pszComma;
    else
        pszPartial = pszSemiColon;

    if (!pszPartial)
        pszPartial = pszBuf;
    else
        pszPartial++;    

    //skip spaces and returns... 
    while (*pszPartial==L' ' || *pszPartial==L'\r' || *pszPartial==L'\n')
        pszPartial++;

    if (NULL == *pszPartial)
        goto cleanup;
    
    //Certain richedits put in 0xfffc for an object, if our text is only that, it's no good
    if (*pszPartial==0xfffc && pszPartial[1]==0x0000)
        goto cleanup;

    len = lstrlenW(pszPartial);
    m_lpWab->SearchPABTable(m_pTable, pszPartial, szFound, ARRAYSIZE(szFound));

    if (*szFound != 0)
    {
        chrg.cpMin = chrgCaret.cpMin;
        chrg.cpMax = chrg.cpMin + lstrlenW(szFound) - len;
        if (chrg.cpMin < chrg.cpMax)
        {
            RichEditExSetSel(hwnd, &chrgCaret);
            HdrSetRichEditText(hwnd, szFound + len, TRUE);
            SendMessage(hwnd, EM_SETMODIFY, (WPARAM)(UINT)TRUE, 0);
            RichEditExSetSel(hwnd, &chrg);
            pHCI->dwACFlags |= AC_SELECTION;
        }
    }

cleanup:
    MemFree(pszBuf);
    return hr;
}



void CNoteHdr::WMPaint()
{
    PAINTSTRUCT ps;
    HDC         hdc,
                hdcMem;
    RECT        rc;
    PHCI        phci = m_rgHCI;
    HBITMAP     hbmMem;

    int         idc, 
                cxHeader,
                cyHeader,
                cxLabel = ControlXBufferSize(), 
                cyStatus,
                cyLeftButtonOffset = BUTTON_BUFFER,
                cxLabelWithBtn = cxLabel + CXOfButtonToLabel();
    char        sz[cchHeaderMax+1];
    int         cStatusBarLines = 0;
    BOOL        fBold;
    HWND        hwnd;

    if (!m_hwnd)
        return;

    STACK("WMPaint");

    if (m_fFlagged || (priLow == m_pri) || (priHigh == m_pri) || (MARK_MESSAGE_NORMALTHREAD != m_MarkType))
        cStatusBarLines++;
    
    if (m_lpAttMan->GetUnsafeAttachCount())
        cStatusBarLines++;

    hdc = BeginPaint(m_hwnd, &ps);

    // **************** Init the background bitmap ****************
    hdcMem = CreateCompatibleDC(hdc);
    idc = SaveDC(hdcMem);

    GetClientRect(m_hwnd, &rc);
    cxHeader = rc.right;
    cyHeader = rc.bottom;

    hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
    SelectObject(hdcMem, (HGDIOBJ)hbmMem);

    // **************** Clear the rect *****************
    FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_BTNFACE));

    // **************** Setup the HDC ******************
    fBold = IsReadOnly();
    SetBkColor(hdcMem, GetSysColor(COLOR_BTNFACE));  // colour of header window
    SetBkMode(hdcMem, TRANSPARENT);
    SetTextColor(hdcMem, GetSysColor(COLOR_BTNTEXT));
    SelectObject(hdcMem, GetFont(fBold));

    // **************** Paint the left labels and buttons **************
    // Center the buttons images
    if (g_cyFont > cyBtn)
        cyLeftButtonOffset += ((g_cyFont - cyBtn) / 2);

    for (int i = 0; (ULONG)i < m_cHCI; i++, phci++)
    {
        if (S_OK == HrFShowHeader(phci))
        {
            if (HCF_HASBUTTON & phci->dwFlags)
            {
                TextOutW(hdcMem, cxLabelWithBtn, phci->cy + BUTTON_BUFFER, phci->sz, phci->strlen);
                ImageList_Draw(g_himlBtns, (HCF_ADDRBOOK & phci->dwFlags)?0:1, hdcMem, cxLabel, phci->cy + cyLeftButtonOffset, ILD_NORMAL);
            }
            else
                TextOutW(hdcMem, cxLabel, (HCF_BORDER & phci->dwFlags)? phci->cy + BUTTON_BUFFER: phci->cy, phci->sz, phci->strlen);
        }
    }

    // **************** Paint the status bar as needed *******************
    if (cStatusBarLines > 0)
    {
        int     cxStatusBtn = ControlXBufferSize() + 1,     // 1 added for the border
                cyStatusBtn = m_dxTBOffset + cyBorder + 1,  // 1 added for the border
                cyStatusBmp = cyStatusBtn,
                cNumButtons = 0;
        LPTSTR  pszTitles[3]={0};

        // Center the buttons images
        if (g_cyFont > cyBtn)
            cyStatusBmp += ((g_cyFont - cyBtn) / 2);

        // Fill the dark rect
        rc.top = m_dxTBOffset;
        rc.bottom = m_dxTBOffset + GetStatusHeight(cStatusBarLines);
        FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_BTNSHADOW));
        InflateRect(&rc, -1, -1);
        FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_INFOBK));

        // Set up the DC for the rest of the status bar
        SetBkColor(hdcMem, GetSysColor(COLOR_INFOBK));  // colour of header window
        SetTextColor(hdcMem, GetSysColor(COLOR_INFOTEXT));
        SelectObject(hdcMem, GetFont(FALSE));

        // Draw icons in status bar
        if (priLow == m_pri)
        {
            ImageList_Draw(g_himlStatus, 1, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatLowPri;
        }
        else if (priHigh == m_pri)
        {
            ImageList_Draw(g_himlStatus, 0, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatHighPri;
        }

        if (MARK_MESSAGE_WATCH == m_MarkType)
        {
            ImageList_Draw(g_himlStatus, 4, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatWatched;
        }
        else if (MARK_MESSAGE_IGNORE == m_MarkType)
        {
            ImageList_Draw(g_himlStatus, 5, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatIgnored;
        }

        if (m_fFlagged)
        {
            ImageList_Draw(g_himlStatus, 2, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatFlagged;
        }

        if (m_lpAttMan->GetUnsafeAttachCount())
        {
            ImageList_Draw(g_himlStatus, 6, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
        }

        if (cNumButtons > 0)
        {
            char    szHeaderString[cchHeaderMax*4+1];

            // Add an additional pixel for the text.
            cyStatusBtn++;
            switch (cNumButtons)
            {
                case 1:
                {
                    wsprintf(szHeaderString, g_szStatFormat1, pszTitles[0]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
                case 2:
                {
                    wsprintf(szHeaderString, g_szStatFormat2, pszTitles[0], pszTitles[1]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
                case 3:
                {
                    wsprintf(szHeaderString, g_szStatFormat3, pszTitles[0], pszTitles[1], pszTitles[2]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
            }
            cyStatusBtn += CYOfStatusLine() - 1;
        }

        if (m_lpAttMan->GetUnsafeAttachCount())
        {
            char    szHeaderString[cchHeaderMax*4+1];

            // Add an additional pixel for the text.
            cyStatusBtn++;
            wsprintf(szHeaderString, g_szStatUnsafeAtt, m_lpAttMan->GetUnsafeAttachList());
            TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
        }
    }

    // ************ Draw the right side buttons **************
    if (m_fDigSigned || m_fEncrypted || m_fVCard)
    {
        int width = GetRightMargin(TRUE),
            cx = cxHeader - (ControlXBufferSize() + cxBtn),
            cy = BeginYPos() + BUTTON_BUFFER,
            yDiff = cyBtn + ControlYBufferSize() + 2*BUTTON_BUFFER;

        if (m_fDigSigned)
        {
            ImageList_Draw(g_himlSecurity, m_fSignTrusted?0:2, hdcMem, cx, cy, ILD_NORMAL);
            cy += yDiff;
        }

        if (m_fEncrypted)
        {
            ImageList_Draw(g_himlSecurity, m_fEncryptionOK?1:3, hdcMem, cx, cy, ILD_NORMAL);
            cy += yDiff;
        }

        if (m_fVCard)
        {
            ImageList_Draw(g_himlBtns, 2, hdcMem, cx, cy, ILD_NORMAL);
        }
    }

    // Draw active button edge
    if (HDRCB_NO_BUTTON != m_dwCurrentBtn)
    {
        DOUTL(PAINTING_DEBUG_LEVEL, "Framing button %d: (%d, %d) to (%d, %d)", 
                m_dwCurrentBtn, m_rcCurrentBtn.left, m_rcCurrentBtn.top, m_rcCurrentBtn.right, m_rcCurrentBtn.bottom);
        if (HDRCB_NO_BUTTON == m_dwClickedBtn)
            DrawEdge(hdcMem, &m_rcCurrentBtn, BDR_RAISEDINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);
        else
            DrawEdge(hdcMem, &m_rcCurrentBtn, BDR_SUNKENINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);
    }

    BitBlt(hdc, 0, 0, cxHeader, cyHeader, hdcMem, 0, 0, SRCCOPY);

    RestoreDC(hdcMem, idc);

    DeleteObject(hbmMem);
    DeleteDC(hdcMem);

    EndPaint(m_hwnd, &ps);
}


HRESULT CNoteHdr::HrFillToolbarColor(HDC hdc)
{
    HRESULT hr = NOERROR;
    RECT    rc;

    if (!m_hwndToolbar)
        return hr;

    GetRealClientRect(m_hwndToolbar, &rc);
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    return hr;
}


HRESULT CNoteHdr::HrGetVCardName(LPTSTR pszName, DWORD cch)
{
    HRESULT hr = E_FAIL;

    if (pszName == NULL || cch==0)
        goto error;

    *pszName = 0;
    if (m_fMail)
        GetOption(OPT_MAIL_VCARDNAME, pszName, cch);
    else
        GetOption(OPT_NEWS_VCARDNAME, pszName, cch);

    if (*pszName != 0)
        hr = NOERROR;

    error:
    return hr;
}

// turn on or off the vcard stamp.
HRESULT CNoteHdr::HrOnOffVCard()
{
    HRESULT     hr = NOERROR;
    RECT        rc;
    TOOLINFO    ti = {0};

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = 0;
    ti.uId = idVCardStamp;
    ti.hinst=g_hLocRes;
    ti.hwnd = m_hwnd;

    if (m_fVCardSave == m_fVCard)
        return hr;
    else
        m_fVCardSave = m_fVCard;

    if (m_fVCard)
    {
        ti.lpszText = (LPTSTR)idsTTVCardStamp;

        SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM) &ti);
    }
    else
        SendMessage(m_hwndTT, TTM_DELTOOL, 0, (LPARAM) &ti);

    InvalidateRightMargin(0);
    ReLayout();

    return hr;
}

HRESULT CNoteHdr::HrGetVCardState(ULONG* pCmdf)
{
    TCHAR       szBuf[MAX_PATH];
    HRESULT     hr;

    // if OLECMDF_LATCHED is on, insert vcard menu should be checked.
    if (m_fVCard)
        *pCmdf |= OLECMDF_LATCHED;

    hr = HrGetVCardName(szBuf, sizeof(szBuf));
    if (FAILED(hr)) // no vcard name selected
    {
        *pCmdf &= ~OLECMDF_ENABLED;
        *pCmdf &= ~OLECMDF_LATCHED;
    }
    else
        *pCmdf |= OLECMDF_ENABLED;

    return NOERROR;
}


HRESULT CNoteHdr::HrShowVCardCtxtMenu(int x, int y)
{
    HMENU   hPopup=0;
    HRESULT hr = E_FAIL;
    POINT   pt;

    if (!m_fVCard)
        goto exit;

    // Pop up the context menu.
    hPopup = LoadPopupMenu(IDR_VCARD_POPUP);
    if (!hPopup)
        goto exit;

    if (IsReadOnly())
        EnableMenuItem(hPopup, ID_DELETE_VCARD, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);

    pt.x = x;
    pt.y = y;
    ClientToScreen(m_hwnd, &pt);
    TrackPopupMenuEx( hPopup, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                      pt.x, pt.y, m_hwnd, NULL);

    hr = NOERROR;

    exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return hr;
}

HRESULT CNoteHdr::HrShowVCardProperties(HWND hwnd)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH] = {0};
    UINT            cb = 0;

    if (IsReadOnly() && m_lpAttMan)
        return m_lpAttMan->HrShowVCardProp();

    //else
    //    return E_FAIL;

    hr = HrGetVCardName(szName, sizeof(szName));
    if (FAILED(hr))
        goto error;

    hr = HrCreateWabObject(&lpWab);
    if (FAILED(hr))
        goto error;

    //load names into the combobox from personal address book
    hr = lpWab->HrEditEntry(hwnd, szName);
    if (FAILED(hr))
        goto error;

    error:
    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrVCardProperties),
                      NULL, MB_OK | MB_ICONEXCLAMATION);

    ReleaseObj(lpWab);
    return hr;
}


LRESULT CALLBACK CNoteHdr::IMESubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PHCI phci)
{
    CNoteHdr   *pnh = NULL;
    HWND        hwndParent = GetParent(hwnd);

    STACK("IMESubClassProc");

    if (IsWindow(hwndParent))
    {
        // Get the header class of the header window
        pnh = (CNoteHdr *)GetWndThisPtr(hwndParent);

        switch (msg)
        {
            case WM_IME_STARTCOMPOSITION:
                DOUTL(64, "WM_IME_STARTCOMPOSITION");
                pnh->m_dwIMEStartCount++;
                break;

            case WM_IME_ENDCOMPOSITION:
                DOUTL(64, "WM_IME_ENDCOMPOSITION");

                // Make sure we don't go negative.
                if (0 < pnh->m_dwIMEStartCount)
                {
                    pnh->m_dwIMEStartCount--;
                }
                else
                {
                    AssertSz(FALSE, "We just received an extra WM_IME_ENDCOMPOSITION");
                    DOUTL(64, "WM_IME_ENDCOMPOSITION, not expected");
                }
                break;
        }
    }

    // Defer to the default window proc
    return CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
}

// bug #28379
// this is a hack to work around RichEd32 4.0 above bug in which
// it did not syncronize the keyboard change in the child windows.
// we use these global variable to keep track which keyboard
// is using now.
static HKL g_hCurrentKeyboardHandle = NULL ;
static BOOL g_fBiDiSystem = (BOOL) GetSystemMetrics(SM_MIDEASTENABLED);
static TCHAR g_chLastPressed = 0;
LRESULT CALLBACK CNoteHdr::EditSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    int         idcKeep;
    PHCI        phci;
    LRESULT     lRet;
    CHARRANGE   chrg;

    phci=(PHCI)GetWndThisPtr(hwnd);
    Assert(phci);
    Assert(g_lpfnREWndProc);


    if (phci && (phci->dwFlags&HCF_ADDRWELL))
    {
        switch (msg)
        {
            case WM_IME_STARTCOMPOSITION:
            case WM_IME_ENDCOMPOSITION:
                return IMESubClassProc(hwnd, msg, wParam, lParam, phci);

            case WM_CUT:
                // if cutting a selection, make sure we don't autocomplete when we get the en_change
                goto cut;

            case WM_KEYDOWN:
                if (VK_BACK==wParam ||
                    VK_DELETE==wParam ||
                    ((GetKeyState(VK_CONTROL)&0x8000) && ('x'==wParam || 'X'==wParam)))
                {
                    // if deleting a selection, make sure we don't autocomplete when we get the en_change
                    cut:
                    phci->dwACFlags |= AC_IGNORE;
                    lRet = CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
                    phci->dwACFlags &= ~AC_IGNORE;
                    return lRet;
                }
                else if (phci->dwACFlags&AC_SELECTION && (VK_RETURN==wParam))
                {
                    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
                    if (chrg.cpMin < chrg.cpMax)
                    {
                        chrg.cpMin = chrg.cpMax;
                        SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&chrg);
                        HdrSetRichEditText(hwnd, (',' == wParam) ? L", ": L"; ", TRUE);
                        return 0;
                    }
                }

                // bobn: brianv says we have to take this out...
                /*if ((g_dwBrowserFlags == 3) && (GetKeyState(VK_CONTROL)&0x8000) && (GetKeyState(VK_SHIFT)&0x8000))
                {
                    switch(wParam) {
                        case 'R':
                            g_chLastPressed = (g_chLastPressed == 0) ? 'R' : 0;
                            break;
                        case 'O':
                            g_chLastPressed = (g_chLastPressed == 'R') ? 'O' : 0;
                            break;
                        case 'C':
                            g_chLastPressed = (g_chLastPressed == 'O') ? 'C' : 0;
                            break;
                        case 'K':
                            if (g_chLastPressed == 'C')
                                g_dwBrowserFlags |= 4;
                            g_chLastPressed = 0;
                            break;
                    }
                }*/
                break;

            case WM_CHAR:
                // VK_RETURN is no longer sent as a WM_CHAR so we place it in the
                // WM_KEYDOWN. RAID 75444
                if (phci->dwACFlags&AC_SELECTION && (wParam==',' || wParam==';'))
                {
                    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
                    if (chrg.cpMin < chrg.cpMax)
                    {
                        chrg.cpMin = chrg.cpMax;
                        SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&chrg);
                        HdrSetRichEditText(hwnd, (wParam==',') ? L", ": L"; ", TRUE);
                        return 0;
                    }
                }
                break;

          case WM_SETFOCUS:
          if(g_fBiDiSystem)
          {
              HKL hklUS = NULL;
              GetUSKeyboardLayout(&hklUS);
              ActivateKeyboardLayout(hklUS, 0);
          }   
          break;
                
        }
    }

    // bug #28379
    // this is a hack to work around RichEd32 4.0 above bug in which
    // it did not syncronize the keyboard change in the child windows.
    // we use these global variable to keep track which keyboard
    // is using now.

    //a-msadek; bug# 45709
    // BiDi richedit uses WM_INPUTLANGCHANGE to determine reading order
    // This will make it confused causing Latin text displayed flipped
    if(!g_fBiDiSystem)
    {
        if (msg == WM_INPUTLANGCHANGE )
        {
            if ( g_hCurrentKeyboardHandle &&
                 g_hCurrentKeyboardHandle != (HKL) lParam )
                ActivateKeyboardLayout(g_hCurrentKeyboardHandle, 0 );
        }
        if (msg == WM_INPUTLANGCHANGEREQUEST )
            g_hCurrentKeyboardHandle = (HKL) lParam ;
    }

    // dispatch subject off to regular edit wndproc, and to & cc off to the RE wnd proc.
    return CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
}

void GetUSKeyboardLayout(HKL *phkl)
{
    UINT cNumkeyboards = 0, i;
    HKL* phKeyboadList = NULL;
    HKL hKeyboardUS = NULL;
    // Let's check how many keyboard the system has
    cNumkeyboards = GetKeyboardLayoutList(0, phKeyboadList);

    phKeyboadList = (HKL*)LocalAlloc(LPTR, cNumkeyboards * sizeof(HKL));  
    cNumkeyboards = GetKeyboardLayoutList(cNumkeyboards, phKeyboadList);

    for (i = 0; i < cNumkeyboards; i++)
    {
        LANGID LangID = PRIMARYLANGID(LANGIDFROMLCID(LOWORD(phKeyboadList[i])));
        if(LangID == LANG_ENGLISH)
        {
            *phkl = phKeyboadList[i];
            break;
        }
    }
   if(phKeyboadList)
   {
       LocalFree((HLOCAL)phKeyboadList);
   }
}

HRESULT CNoteHdr::HrUpdateTooltipPos()
{
    TOOLINFO    ti;

    if (m_hwndTT)
    {
/*        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hwnd;
        ti.uId = idStamp;
        ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y, m_ptStamp.x + cxStamp, m_ptStamp.y + cyStamp);
        SendMessage(m_hwndTT, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);

        if (m_fVCard)
        {
            ti.uFlags = 0;
            ti.uId = idVCardStamp;
            ti.lpszText = (LPTSTR) idsTTVCardStamp;
            if (m_pri!=priNone) //mail
                ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y*2+cyStamp, m_ptStamp.x + cxStamp, 2*(m_ptStamp.y+cyStamp));
            else // news
                ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y, m_ptStamp.x + cxStamp, m_ptStamp.y + cyStamp);

            SendMessage(m_hwndTT, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);
        }*/

    }
    return NOERROR;
}

HRESULT CNoteHdr::HrInit(IMimeMessage *pMsg)
{
    HWND    hwnd;
    HRESULT hr=S_OK;

    if (m_hwnd) // already running
        return S_OK;

    if (!FInitRichEdit(TRUE))
        return E_FAIL;

    if (!m_pEnvelopeSite)
    {
        Assert(m_hwndParent);
        hwnd=CreateWindowExWrapW(   WS_EX_CONTROLPARENT|WS_EX_NOPARENTNOTIFY,
                                    WC_ATHHEADER,
                                    NULL,
                                    WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_CHILD,
                                    0,0,0,0,
                                    m_hwndParent,
                                    (HMENU)idcNoteHdr,
                                    g_hInst, (LPVOID)this );
    }
    else
    {
        Assert(!m_hwnd);

        hr = HrOfficeInitialize(TRUE);
        if (FAILED(hr))
            goto error;

        m_hwndParent = g_hwndInit;

        hwnd=CreateWindowExWrapW(WS_EX_CONTROLPARENT|WS_EX_NOPARENTNOTIFY,
                                 WC_ATHHEADER,
                                 NULL,
                                 WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_CHILD,
                                 0,0,0,0,
                                 m_hwndParent,
                                 (HMENU)idcNoteHdr,
                                 g_hInst, (LPVOID)this);

        if (!hwnd)
        {
            hr = E_FAIL;
            goto error;
        }

        m_ntNote = OENA_COMPOSE;
        m_fMail = TRUE;

        if (pMsg)
            hr = Load(pMsg);
        else
            hr = HrOfficeLoad();
        if (FAILED(hr))
            goto error;
    }


    if (!hwnd)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    m_hwnd = hwnd;
    m_fDirty=FALSE;

    error:
    return hr;
}


HRESULT CNoteHdr::HrOfficeInitialize(BOOL fInit)
{
    HRESULT             hr = E_FAIL;
    
    if (fInit)
    {
        hr = CoIncrementInit("CNoteHdr::HrOfficeInitialize", MSOEAPI_START_COMOBJECT, NULL, &m_hInitRef);
        if (FAILED(hr))
            return hr;

        if (!FHeader_Init(TRUE))
            return E_FAIL;

        m_fAutoComplete = TRUE;
        m_fDirty=FALSE;

        hr = _RegisterWithComponentMgr(TRUE);
        if (FAILED(hr))
            return E_FAIL;
        
        m_fOfficeInit = TRUE;
    }
    else
    {
        if (m_hInitRef)
            CoDecrementInit("CNoteHdr::HrOfficeInitialize", &m_hInitRef);

    }

    return NOERROR;
}


void CNoteHdr::OnNCDestroy()
{
    if (m_rgHCI)
    {
        MemFree(m_rgHCI);
        m_rgHCI = NULL;
        m_cHCI = 0;
    }

    _RegisterAsDropTarget(FALSE);
    _RegisterWithFontCache(FALSE);

    SafeRelease(m_pHeaderSite);
    SafeRelease(m_pEnvelopeSite);

    m_hwnd = NULL;
}

void CNoteHdr::OnDestroy()
{
    HrFreeFieldList();

    if (m_lpAttMan)
        m_lpAttMan->HrClose();

    // release office interfaces if we get torn down
    _RegisterWithComponentMgr(FALSE);
}


HRESULT CNoteHdr::ShowAdvancedHeaders(BOOL fShow)
{
    if (!!m_fAdvanced != fShow)
    {
        m_fAdvanced=fShow;

        ReLayout();

        if (m_hwndToolbar)
            SendMessage(m_hwndToolbar, TB_CHECKBUTTON, ID_ENV_BCC, MAKELONG(!!m_fAdvanced, 0));
    }

    return S_OK;
}


HRESULT CNoteHdr::HrFShowHeader(PHCI phci)
{
    Assert(phci);

    if (phci->dwFlags & HCF_COMBO)
    {
        if (m_cAccountIDs < 2)
            return S_FALSE;
        else
            return S_OK;
    }

    if (phci->dwFlags & HCF_ATTACH)
    {
        if (!m_fStillLoading)
        {
            ULONG cAttMan = 0;
            HrGetAttachCount(&cAttMan);

            if (cAttMan)
                return S_OK;
        }
        return S_FALSE;
    }

    if (phci->dwFlags & HCF_ADVANCED)
    {
        if (IsReadOnly())
        {
            // If it is a read note and CC is empty, don't show
            if (phci->fEmpty)
                return S_FALSE;
        }
        else
            // If is a send note and not suppose to show adv headers, don't show
            if (!m_fAdvanced)
                return S_FALSE;
    }

    if ((phci->dwFlags & HCF_OPTIONAL) && !DwGetOption(phci->dwOpt))
        return S_FALSE;

    if (phci->dwFlags & HCF_HIDDEN)
        return S_FALSE;

    return S_OK;
}

// =================================================================================
// SzGetDisplaySec
//      returns the security enhancements and state of such for this message
// Params:
//      OUT pidsLabel - if non-NULL, will contain the ids for the field name
// Returns:
//      a built string giving information about the signature and/or encryption
// =================================================================================
LPWSTR  CNoteHdr::SzGetDisplaySec(LPMIMEMESSAGE pMsg, int *pidsLabel)
{
    WCHAR       szResource[CCHMAX_STRINGRES];
    LPWSTR      lpszLabel = NULL;    
    
    if (m_lpszSecurityField)
    {
        MemFree(m_lpszSecurityField);
        m_lpszSecurityField = NULL;
    }
    
    // check label first.
    if ((m_ntNote == OENA_READ) && pMsg)
    {
        HrGetLabelString(pMsg, &lpszLabel);
    }
   
    
    if (pidsLabel)
        *pidsLabel=idsSecurityField;

    UINT labelLen = 1;
    if(lpszLabel)
    {
        //Bug #101350 - lstrlenW will AV (and handle it) if passed a NULL
        labelLen += lstrlenW(lpszLabel);
    }
    
    // need to build string
    if (!MemAlloc((LPVOID *)&m_lpszSecurityField, (2*CCHMAX_STRINGRES*sizeof(WCHAR) + labelLen*sizeof(WCHAR))))
        return NULL;
    
    *m_lpszSecurityField = L'\0';

    // Example: "Digitally signed - signature unverifiable; Encrypted - Certificate is trusted"
    
    if (MST_SIGN_MASK & m_SecState.type)
    {
        AthLoadStringW(idsSecurityLineDigSign, szResource, ARRAYSIZE(szResource));
        StrCpyW(m_lpszSecurityField, szResource);
        
        if (IsSignTrusted(&m_SecState))
            AthLoadStringW(idsSecurityLineSignGood, szResource, ARRAYSIZE(szResource));
        else if (MSV_BADSIGNATURE & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineSignBad, szResource, ARRAYSIZE(szResource));
        else if ((MSV_UNVERIFIABLE & m_SecState.ro_msg_validity) ||
            (MSV_MALFORMEDSIG & m_SecState.ro_msg_validity))
            AthLoadStringW(idsSecurityLineSignUnsure, szResource, ARRAYSIZE(szResource));
        
        else if ((ATHSEC_NOTRUSTWRONGADDR & m_SecState.user_validity) &&
            ((m_SecState.user_validity & ~ATHSEC_NOTRUSTWRONGADDR) == ATHSEC_TRUSTED) &&
            (! m_SecState.ro_msg_validity))
        {
            AthLoadStringW(idsSecurityLineSignPreProblem, szResource, ARRAYSIZE(szResource));
            StrCatW(m_lpszSecurityField, szResource);
            AthLoadStringW(idsSecurityLineSignMismatch, szResource, ARRAYSIZE(szResource));
        }
        
        else if (((ATHSEC_TRUSTED != m_SecState.user_validity) && m_SecState.fHaveCert) ||
            (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity))
        {
            AthLoadStringW(idsSecurityLineSignPreProblem, szResource, ARRAYSIZE(szResource));
            
            if (ATHSEC_TRUSTED != m_SecState.user_validity)
            {
                int nNotTrust = 0;
                
                StrCatW(m_lpszSecurityField, szResource);
                
                // ignore revokedness for now
                if (ATHSEC_NOTRUSTUNKNOWN & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignUntrusted, szResource, ARRAYSIZE(szResource));
                }
                else if(ATHSEC_NOTRUSTREVOKED & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignRevoked, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else if(ATHSEC_NOTRUSTOTHER & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignOthers, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else if(m_SecState.user_validity & ATHSEC_NOTRUSTWRONGADDR)
                {
                    AthLoadStringW(idsSecurityLineSignMismatch, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else // if(!(m_SecState.user_validity & ATHSEC_NOTRUSTNOTTRUSTED))
                    AthLoadStringW(idsSecurityLineSignDistrusted, szResource, ARRAYSIZE(szResource));
                
                if((m_SecState.user_validity & ATHSEC_NOTRUSTNOTTRUSTED) && nNotTrust)
                {
                    StrCatW(m_lpszSecurityField, szResource);
                    AthLoadStringW(idsSecurityLineListStr, szResource, ARRAYSIZE(szResource));
                    StrCatW(m_lpszSecurityField, szResource);
                    AthLoadStringW(idsSecurityLineSignDistrusted, szResource, ARRAYSIZE(szResource));
                }
                
                if (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity)
                {
                    StrCatW(m_lpszSecurityField, szResource);
                    AthLoadStringW(idsSecurityLineListStr, szResource, ARRAYSIZE(szResource));
                }
            }
            if (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity)
            {
                StrCatW(m_lpszSecurityField, szResource);
                AthLoadStringW(idsSecurityLineSignExpired, szResource, ARRAYSIZE(szResource));
            }
        }
        else
        {
            AthLoadStringW(idsSecurityLineSignUnsure, szResource, ARRAYSIZE(szResource));
        }
        StrCatW(m_lpszSecurityField, szResource);
        
        if (MST_ENCRYPT_MASK & m_SecState.type)
        {
            AthLoadStringW(idsSecurityLineBreakStr, szResource, ARRAYSIZE(szResource));
            StrCatW(m_lpszSecurityField, szResource);
        }
    }
    
    if (MST_ENCRYPT_MASK & m_SecState.type)
    {
        AthLoadStringW(idsSecurityLineEncryption, szResource, ARRAYSIZE(szResource));
        StrCatW(m_lpszSecurityField, szResource);
        
        if (MSV_OK == (m_SecState.ro_msg_validity & MSV_ENCRYPT_MASK))
            AthLoadStringW(idsSecurityLineEncGood, szResource, ARRAYSIZE(szResource));
        else if (MSV_CANTDECRYPT & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineEncBad, szResource, ARRAYSIZE(szResource));
        else if (MSV_ENC_FOR_EXPIREDCERT & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineEncExpired, szResource, ARRAYSIZE(szResource));
        else
        {
            DOUTL(DOUTL_CRYPT, "CRYPT: bad encrypt state in SzGetDisplaySec");
            szResource[0] = _T('\000');
        }
        StrCatW(m_lpszSecurityField, szResource);
    }
    
    if(lpszLabel != NULL)
    {
        AthLoadStringW(idsSecurityLineBreakStr, szResource, ARRAYSIZE(szResource));
        StrCatW(m_lpszSecurityField, szResource);
        StrCatW(m_lpszSecurityField, lpszLabel);
        MemFree(lpszLabel);
    }
    return m_lpszSecurityField;
}


HRESULT CNoteHdr::HrClearUndoStack()
{
    int     iHC;
    HWND    hwndRE;

    for (iHC=0; iHC<(int)m_cHCI; iHC++)
    {
        if (hwndRE = GetDlgItem(m_hwnd, m_rgHCI[iHC].idEdit))
            SendMessage(hwndRE, EM_EMPTYUNDOBUFFER, 0, 0);
    }

    return S_OK;
}

// There are some cases where we don't wan't the resolve name to
// be skipped. For example, a resolve name during a save will set
// m_fAddressesChanged to be false. That is fine, except it doesn't
// underline the addresses. So when the user tries to resolve the name
// by doing the resolve name command, the name will appear not to 
// be resolved. In this case, we don't want the next call to HrCheckNames
// to be skipped.
HRESULT CNoteHdr::HrCheckNames(BOOL fSilent, BOOL fSetCheckedFlag)
{
    HRESULT     hr;

    if (!m_fAddressesChanged)
        return S_OK;

    if (m_fPoster && (OENA_READ != m_ntNote))
    {
        //We need to setmodify the cc field.
        //We need to do this because this field is not typed in by the user.
        Edit_SetModify(GetDlgItem(m_hwnd, idADCc), TRUE);
    }

    hr = m_pAddrWells->HrCheckNames(m_hwnd, fSilent ? CNF_DONTRESOLVE : 0);
    if (SUCCEEDED(hr))
    {
        if (m_lpWabal == NULL)
            hr = hrNoRecipients;
        else
        {
            ADRINFO AdrInfo;
            if (!m_lpWabal->FGetFirst(&AdrInfo))
                hr = hrNoRecipients;
        }

        if (SUCCEEDED(hr) && fSetCheckedFlag)
            m_fAddressesChanged = FALSE;
    }    
    return hr;
}

HRESULT CNoteHdr::HrCheckGroups(BOOL fPosting)
{
    HRESULT     hr = S_OK;
    BOOL        fFailed = FALSE;
    ULONG       cReplyTo=0;
    ADRINFO     adrInfo;
    BOOL        fOneOrMoreNames = FALSE;
    BOOL        fMoreNames = FALSE;
    TCHAR       szAcctID[CCHMAX_ACCOUNT_NAME];
    FOLDERID    idServer = FOLDERID_INVALID;

    if (!m_pAccount)
        return E_FAIL;

    m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctID, sizeof(szAcctID));
    // find the parent folder id of the account
    hr = g_pStore->FindServerId(szAcctID, &idServer);
    if (FAILED(hr))
        return hr;

    // check the group names...
    hr = ResolveGroupNames(m_hwnd, idADNewsgroups, idServer, FALSE, &fMoreNames);
    fOneOrMoreNames = fMoreNames;
    fFailed = FAILED(hr);

    // Check followup names
    hr = ResolveGroupNames(m_hwnd, idTXTFollowupTo, idServer, TRUE, &fMoreNames);
    fOneOrMoreNames = (fOneOrMoreNames || fMoreNames);
    fFailed = fFailed || FAILED(hr);

    if (!fOneOrMoreNames)
        return hrNoRecipients;

    if (fPosting)
    {
        // make sure there is only one reply-to person, in the wabal
        if (m_lpWabal->FGetFirst(&adrInfo))
            do
                if (adrInfo.lRecipType == MAPI_REPLYTO)
                    cReplyTo++;
            while (m_lpWabal->FGetNext(&adrInfo));

        if (cReplyTo>1)
        {
            // this is not cool. Don't allow then to post...
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsErrOnlyOneReplyTo), NULL, MB_OK);
            return hrTooManyReplyTo;
        }
    }

    if (fPosting && fFailed)
    {
        if (IDYES == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsIgnoreResolveError), 0, MB_ICONEXCLAMATION |MB_YESNO))
            hr = S_OK;
        else
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}


HRESULT CNoteHdr::ResolveGroupNames(HWND hwnd, int idField, FOLDERID idServer, BOOL fPosterAllowed, BOOL *fOneOrMoreNames)
{
    HRESULT hr = S_OK;
    FOLDERINFO  Folder;
    int nResolvedNames = 0;

    AssertSz((idServer != FOLDERID_INVALID), TEXT("ResolveGroupNames: [ARGS] No account folder"));
    
    // Now loop through the group names and see if they all exist.  First make
    // a copy of the string since strtok is destructive.
    LPWSTR  pwszBuffer = NULL;
    LPSTR   pszBuffer = NULL;
    DWORD   dwType;
    LONG    lIndex,
            cchBufLen,
            lIter = 0;
    TCHAR   szPrompt[CCHMAX_STRINGRES];
    LPTSTR  psz = NULL, 
            pszTok = NULL, 
            pszToken = NULL;

    // HrGetFieldText will return S_FALSE if no text
    hr = HrGetFieldText(&pwszBuffer, idField);
    if (S_OK != hr)
        return hr;

    IF_NULLEXIT(pszBuffer = PszToANSI(GetACP(), pwszBuffer));

    psz = pszBuffer;
    // Check group name
    while (*psz && IsSpace(psz))
        psz = CharNext(psz);

    if(!(*psz))
    {
        hr = S_FALSE;
        goto exit;
    }
    else
        psz = NULL;

    pszTok = pszBuffer;
    pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    while (NULL != pszToken)
    {
        if (!fPosterAllowed ||
            (fPosterAllowed && 0 != lstrcmpi(pszToken, c_szPosterKeyword)))
        {
            ZeroMemory(&Folder, sizeof(Folder));
    
            // See if the Folder Already Exists
            Folder.idParent = idServer;
            Folder.pszName = (LPSTR)pszToken;

            // Try to find in the index
            if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Check to see if this newsgroup allows posting.
                if (Folder.dwFlags & FOLDER_NOPOSTING)
                {
                    psz = AthLoadString(idsErrNewsgroupNoPosting, 0, 0);
                    wsprintf(szPrompt, psz, pszToken, pszToken);
                    AthFreeString(psz);

                    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt,
                                  0, MB_ICONSTOP | MB_OK);
                    hr = E_FAIL;
                }

                if (Folder.dwFlags & FOLDER_BLOCKED)
                {
                    psz = AthLoadString(idsErrNewsgroupBlocked, 0, 0);
                    wsprintf(szPrompt, psz, pszToken, pszToken);
                    AthFreeString(psz);

                    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt,
                                  0, MB_ICONSTOP | MB_OK);
                    hr = E_FAIL;
                }
                else
                    nResolvedNames++;


                // Free
                g_pStore->FreeRecord(&Folder);
            }
            else
            {
                psz = AthLoadString(idsErrCantResolveGroup, 0, 0);
                wsprintf(szPrompt, psz, pszToken);
                AthFreeString(psz);
                AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt, 0,
                              MB_ICONSTOP | MB_OK);
                hr = E_FAIL;
            }

        }

        pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    }

exit:
    MemFree(pszBuffer);
    MemFree(pwszBuffer);
    
    *fOneOrMoreNames = ((nResolvedNames > 0) ? TRUE : FALSE);
    return (hr);
}


HRESULT CNoteHdr::HrGetFieldText(LPWSTR* ppszText, int idHdrCtrl)
{
    HWND hwnd = GetDlgItem(m_hwnd, idHdrCtrl);

    return HrGetFieldText(ppszText, hwnd);
}

HRESULT CNoteHdr::HrGetFieldText(LPWSTR* ppszText, HWND hwnd)
{
    DWORD cch;

    cch = GetRichEditTextLen(hwnd) + 1;
    if (1 == cch)
        return (S_FALSE);

    if (!MemAlloc((LPVOID*) ppszText, cch * sizeof(WCHAR)))
        return (E_OUTOFMEMORY);

    HdrGetRichEditText(hwnd, *ppszText, cch, FALSE);

    return (S_OK);
}

HRESULT CNoteHdr::HrAddSender()
{
    ULONG       uPos=0;
    ADRINFO     adrInfo;
    LPADRINFO   lpAdrInfo=0;
    LPWAB       lpWab;
    HRESULT     hr=E_FAIL;

    if (m_lpWabal->FGetFirst(&adrInfo))
        do
            if (adrInfo.lRecipType==MAPI_ORIG)
            {
                lpAdrInfo=&adrInfo;
                break;
            }
        while (m_lpWabal->FGetNext(&adrInfo));

    if (lpAdrInfo &&
        !FAILED (HrCreateWabObject (&lpWab)))
    {
        hr=lpWab->HrAddToWAB(m_hwnd, lpAdrInfo);
        lpWab->Release ();
    }

    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
    {
        if (hr==MAPI_E_COLLISION)
            AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
        else
            AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);
    }
    return NOERROR;
}

HRESULT CNoteHdr::HrAddAllOnToList()
{
    ADRINFO     adrInfo;
    LPWAB       lpWab;
    HRESULT     hr = S_OK;

    if (m_lpWabal->FGetFirst(&adrInfo))
    {
        hr = HrCreateWabObject(&lpWab);
        if (SUCCEEDED(hr))
        {
            do
            {
                if (MAPI_TO == adrInfo.lRecipType)
                {
                    hr = lpWab->HrAddToWAB(m_hwnd, &adrInfo);
                    if (MAPI_E_COLLISION == hr)
                    {
                        hr = S_OK;
                        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
                    }
                }
            } while (SUCCEEDED(hr) && m_lpWabal->FGetNext(&adrInfo));
        }
        lpWab->Release();
    }

    if (FAILED(hr) && (MAPI_E_USER_CANCEL != hr))
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);

    return hr;
}


HRESULT CNoteHdr::HrInitFieldList()
{
    PHCI        pHCI, pLoopHCI;
    INT         size;
    BOOL        fReadOnly = IsReadOnly();

    if (m_fMail)
    {
        if (fReadOnly)
        {
            pHCI = rgMailHeaderRead;
            size = sizeof(rgMailHeaderRead);
        }
        else
        {
            pHCI = rgMailHeaderSend;
            size = sizeof(rgMailHeaderSend);
        }

    }
    else
    {
        if (fReadOnly)
        {
            pHCI = rgNewsHeaderRead;
            size = sizeof(rgNewsHeaderRead);
        }
        else
        {
            pHCI = rgNewsHeaderSend;
            size = sizeof(rgNewsHeaderSend);
        }
    }

    // Setup the labels
    pLoopHCI = pHCI;
    m_cHCI = size/sizeof(HCI);

    for (ULONG i = 0; i < m_cHCI; i++, pLoopHCI++)
    {
        if (0 == pLoopHCI->strlen)
        {
            AthLoadStringW(pLoopHCI->idsLabel, pLoopHCI->sz, cchHeaderMax+1);
            pLoopHCI->strlen = lstrlenW(pLoopHCI->sz);
        }
        if ((0 == pLoopHCI->strlenEmpty) && (0 != pLoopHCI->idsEmpty))
        {
            AthLoadStringW(pLoopHCI->idsEmpty, pLoopHCI->szEmpty, cchHeaderMax+1);
            pLoopHCI->strlenEmpty = lstrlenW(pLoopHCI->szEmpty);
        }
    }

    if (NULL != MemAlloc((LPVOID *)&m_rgHCI, size))
        CopyMemory(m_rgHCI, pHCI, size);
    else
        return E_OUTOFMEMORY;

    m_cxLeftMargin = _GetLeftMargin();

    return S_OK;
}

int CNoteHdr::_GetLeftMargin()
{
    PHCI        pLoopHCI = m_rgHCI;
    INT         size;
    int         cxButtons = ControlXBufferSize();
    HDC         hdc = GetDC(m_hwnd);
    HFONT       hfontOld;
    ULONG       cxEditMarginCur = 0,
                cxEditMaxMargin = 0;
    SIZE        rSize;
    BOOL        fReadOnly = IsReadOnly();

    // Setup the labels
    hfontOld=(HFONT)SelectObject(hdc, GetFont(fReadOnly));

    for (ULONG i = 0; i < m_cHCI; i++, pLoopHCI++)
    {
        AssertSz(pLoopHCI->strlen, "Haven't set the strings yet.");

        GetTextExtentPoint32AthW(hdc, pLoopHCI->sz, pLoopHCI->strlen, &rSize, NOFLAGS);
        cxEditMarginCur = rSize.cx + PaddingOfLabels();
        if (pLoopHCI->dwFlags & HCF_HASBUTTON)
            cxEditMarginCur += CXOfButtonToLabel();

        if (cxEditMarginCur > cxEditMaxMargin)
            cxEditMaxMargin = cxEditMarginCur;
    }
    SelectObject(hdc, hfontOld);
    ReleaseDC(m_hwnd, hdc);

    return cxEditMaxMargin;
}

HRESULT CNoteHdr::HrFreeFieldList()
{
    if (m_rgHCI)
    {
        for (int i=0; i<(int)m_cHCI; i++)
        {
            // You must free the pDoc before the preole or fault! (RICHED 2.0)
            SafeRelease(m_rgHCI[i].pDoc);
            SafeRelease(m_rgHCI[i].preole);
        }
    }
    return NOERROR;
}

static WELLINIT  rgWellInitMail[]=
{
    {idADTo, MAPI_TO},
    {idADCc, MAPI_CC},
    {idADFrom, MAPI_ORIG},
    {idADBCc, MAPI_BCC}
};

static WELLINIT rgWellInitNews[]=
{
    {idADFrom, MAPI_ORIG},
    {idADCc, MAPI_TO},
    {idADReplyTo, MAPI_REPLYTO}
};

BOOL CNoteHdr::PostWMCreate()
{
    HWND    hwnd;
    HWND    hwndWells[4];
    ULONG   ulRecipType[4];
    ULONG   cWells=0;
    PWELLINIT   pWI;
    INT     size;
    INT     i;

    if (hwnd=GetDlgItem(m_hwnd, idTXTSubject))
        SendMessage(hwnd, EM_LIMITTEXT,cchMaxSubject,0);

    if (m_fMail)
    {
        pWI = rgWellInitMail;
        size = ARRAYSIZE(rgWellInitMail);
    }
    else
    {
        pWI = rgWellInitNews;
        size = ARRAYSIZE(rgWellInitNews);
    }

    for (i=0; i<size; i++)
    {
        hwnd = GetDlgItem(m_hwnd, pWI[i].idField);
        if (hwnd)
        {
            hwndWells[cWells] = hwnd;
            ulRecipType[cWells++] = pWI[i].uMAPI;
        }
    }

    AssertSz(!m_pAddrWells, "Who called PostWMCreate??????");
    m_pAddrWells = new CAddrWells;

    if (!m_pAddrWells || FAILED(m_pAddrWells->HrInit(cWells, hwndWells, ulRecipType)))
        return FALSE;

    return TRUE;
}


HRESULT CNoteHdr::HrSetMailRecipients(LPMIMEMESSAGE pMsg)
{
    ADRINFO             rAdrInfo;
    HRESULT             hr = NOERROR;
    IImnEnumAccounts   *pEnumAccounts = NULL;
    LPWABAL             lpWabal = NULL;
    BOOL                fAdvanced = FALSE;

    AssertSz(OENA_REPLYTONEWSGROUP != m_ntNote, "Shouldn't get a REPLYTONEWSGROUP in a mail note.");

    SafeRelease(m_lpWabal);

    // Set initial state of wabals to use
    switch (m_ntNote)
    {
        case OENA_READ:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &m_lpWabal));
            break;

        case OENA_COMPOSE:
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYALL:
            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &lpWabal));
            IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));
            break;

        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
            IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));
            break;
    }

    // Actually set recipients now.            
    switch (m_ntNote)
    {
        case OENA_COMPOSE:
        {
#pragma prefast(suppress:11, "noise")
            BOOL fMoreIterations = lpWabal->FGetFirst(&rAdrInfo);
            while (fMoreIterations)
            {
                if (rAdrInfo.lRecipType != MAPI_ORIG)
                {
                    hr = m_lpWabal->HrAddEntry(&rAdrInfo);
                    if (FAILED(hr))
                        break;
                }
                fMoreIterations = lpWabal->FGetNext(&rAdrInfo);
            }
            break;
        }

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYALL:
        {
            BOOL    fNeedOriginatorItems = TRUE;
            BOOL    fMoreIterations;

            // Add items to To: line from the ReplyTo Field
            fMoreIterations = lpWabal->FGetFirst (&rAdrInfo);
            while (fMoreIterations)
            {
                if (rAdrInfo.lRecipType==MAPI_REPLYTO)
                {
                    Assert (rAdrInfo.lpwszAddress);

                    fNeedOriginatorItems = FALSE;
                    rAdrInfo.lRecipType=MAPI_TO;
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }

                fMoreIterations = lpWabal->FGetNext (&rAdrInfo);
            }

            // If we don't need to add the MAPI_ORIG and we are not trying to reply to all, then we are done
            if (!fNeedOriginatorItems && (OENA_REPLYALL != m_ntNote))
                break;

            // Raid-35976: Unable to open message window with no accounts configured
            // Get an SMTP account enumerator
            Assert(g_pAcctMan);
            if (g_pAcctMan && (OENA_REPLYALL == m_ntNote))
                g_pAcctMan->Enumerate(SRV_SMTP|SRV_HTTPMAIL, &pEnumAccounts);

            // Add the following items to the To line 
            // 1) If there were no ReplyTo items, then fill from the Orig field
            // 2) If is ReplyToAll, then fill from the To and CC line
            fMoreIterations = lpWabal->FGetFirst (&rAdrInfo);
            while (fMoreIterations)
            {
                // No replyto people were added, and this is a MAPI_ORIG
                if (fNeedOriginatorItems && rAdrInfo.lRecipType == MAPI_ORIG)
                {
                    rAdrInfo.lRecipType=MAPI_TO;
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }

                // pEnumAccounts will only be set if ReplyToAll
                // If ReplyToAll, then add the CC and To line entries to the To field
                else if (pEnumAccounts && (rAdrInfo.lRecipType == MAPI_TO || rAdrInfo.lRecipType == MAPI_CC))
                {
                    BOOL            fIsSendersAccount = FALSE;
                    TCHAR           szEmailAddress[CCHMAX_EMAIL_ADDRESS];

                    Assert (rAdrInfo.lpwszAddress);

                    pEnumAccounts->Reset();

                    // See if rAdrInfo.lpszAddress exist as one of the user's Send Email Addresses
                    while (!fIsSendersAccount)
                    {
                        IImnAccount    *pAccount = NULL;
                        hr = pEnumAccounts->GetNext(&pAccount);
                        if (hr == E_EnumFinished || FAILED(hr))
                            break;

                        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress))))
                        {
                            LPWSTR pwszAddress = NULL;
                            IF_NULLEXIT(pwszAddress = PszToUnicode(CP_ACP, szEmailAddress));
                            if (0 == StrCmpIW(rAdrInfo.lpwszAddress, pwszAddress))
                                fIsSendersAccount = TRUE;
                            MemFree(pwszAddress);
                        }
                        pAccount->Release();
                    }

                    // Reset hr
                    hr = S_OK;

                    // Add the account if it isn't from the sender
                    if (!fIsSendersAccount)
                    {
                        if (0 != StrCmpW(rAdrInfo.lpwszAddress, L"Undisclosed Recipients"))
                        {
                            // only include recipient on ReplyAll if it's not the sender...
                            IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                        }
                    }
                }
                fMoreIterations = lpWabal->FGetNext(&rAdrInfo);
            }
        }
    }

    Assert (m_lpWabal);

    // For the send note case, make sure that resolved addresses are valid.
    // If display name and email address are the same, UnresolveOneOffs() will clear
    // the email address to force a real resolve.
    if (OENA_COMPOSE == m_ntNote || OENA_WEBPAGE == m_ntNote || OENA_STATIONERY == m_ntNote)
        m_lpWabal->UnresolveOneOffs();

    m_lpWabal->HrResolveNames(NULL, FALSE);

    Assert(m_pAddrWells);
    m_pAddrWells->HrSetWabal(m_lpWabal);
    m_pAddrWells->HrDisplayWells(m_hwnd);

    if (OENA_READ == m_ntNote)
        fAdvanced = DwGetOption(OPT_MAILNOTEADVREAD);
    else
    {
        fAdvanced = DwGetOption(OPT_MAILNOTEADVSEND);

        // Need to make sure that if we are in a compose note, that we check to see
        // if we added a bcc without setting the advanced headers. If this is the case,
        // then show the advanced headers for this note.
        if (!fAdvanced && (0 < GetRichEditTextLen(GetDlgItem(m_hwnd, idADBCc))))
            fAdvanced = TRUE;
    }
    // BUG: 31217: showadvanced has to be the last thing we call after modifying the
    // well contents
    ShowAdvancedHeaders(fAdvanced);

exit:
    // Cleanup
    ReleaseObj(lpWabal);
    ReleaseObj(pEnumAccounts);
    return hr;
}


HRESULT CNoteHdr::HrSetupNote(LPMIMEMESSAGE pMsg)
{
    HWND        hwnd;
    WCHAR       wsz[cchMaxSubject+1];
    LPWSTR      psz = NULL;
    PROPVARIANT rVariant;
    HRESULT     hr = NOERROR;

    if (!pMsg)
        return E_INVALIDARG;

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz);
    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), psz, FALSE);

    *wsz=0;
    rVariant.vt = VT_FILETIME;
    pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
    AthFileTimeToDateTimeW(&rVariant.filetime, wsz, ARRAYSIZE(wsz), DTM_LONGDATE|DTM_NOSECONDS);

    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTDate), wsz, FALSE);

    MemFree(psz);
    return hr;
}


HRESULT CNoteHdr::HrSetPri(LPMIMEMESSAGE pMsg)
{
    UINT            pri=priNorm;
    PROPVARIANT     rVariant;

    Assert(pMsg);

    rVariant.vt = VT_UI4;
    if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
    {
        if (rVariant.ulVal == IMSG_PRI_HIGH)
            pri=priHigh;
        else if (rVariant.ulVal == IMSG_PRI_LOW)
            pri=priLow;
    }

    return SetPriority(pri);
}


HRESULT CNoteHdr::HrAutoAddToWAB()
{
    LPWAB   lpWab=0;
    LPWABAL lpWabal=0;
    HRESULT hr;
    ADRINFO adrInfo;

    if (!m_lpWabal)
        return S_OK;

    if (!DwGetOption(OPT_MAIL_AUTOADDTOWABONREPLY))
        return S_OK;

    IF_FAILEXIT(hr=HrCreateWabObject(&lpWab));

    // when this is called, m_lpWabal contains everyone on the to: and cc: line
    // for a reply/reply all. We will add all these people to the WAB, ignoring any
    // clashes or failures
    // Add Sender if email and displayname are not the same.
    // if so then there's no username so little point in adding.

    if (m_lpWabal->FGetFirst(&adrInfo))
        do
        {
            // IE5.#2568: we now just add to the WAB regardless of
            // email and dispname being the same.
            // if (lstrcmp(adrInfo.lpszDisplay, adrInfo.lpszAddress)!=0)
            lpWab->HrAddNewEntry(adrInfo.lpwszDisplay, adrInfo.lpwszAddress);
        }
        while (m_lpWabal->FGetNext(&adrInfo));

exit:
    ReleaseObj(lpWab);
    return hr;
}


HRESULT CNoteHdr::HrOfficeLoad()
{
    HRESULT         hr = NOERROR;

    m_fSkipLayout = FALSE;

    if (!m_hCharset)
    {
        if (g_hDefaultCharsetForMail==NULL) 
            ReadSendMailDefaultCharset();

        m_hCharset = g_hDefaultCharsetForMail;        
    }
    
    if (m_hCharset)
        HrUpdateCharSetFonts(m_hCharset, FALSE);

    SafeRelease(m_lpWabal);

    hr = HrCreateWabalObject(&m_lpWabal);
    if (SUCCEEDED(hr))
    {
        Assert(m_pAddrWells);
        m_pAddrWells->HrSetWabal(m_lpWabal);

        ShowAdvancedHeaders(DwGetOption(OPT_MAILNOTEADVSEND));

        m_fStillLoading = FALSE;
    }

    return hr;
}


void CNoteHdr::SetReferences(LPMIMEMESSAGE pMsg)
{
    LPWSTR lpszRefs = 0;

    SafeMemFree(m_pszRefs);
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &lpszRefs);

    switch (m_ntNote)
    {
        case OENA_REPLYALL:
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        {
            LPWSTR lpszMsgId = 0;

            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpszMsgId);

            if (lpszMsgId)
                HrCreateReferences(lpszRefs, lpszMsgId, &m_pszRefs);

            SafeMimeOleFree(lpszMsgId);
            break;
        }

        case OENA_READ:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
        case OENA_COMPOSE:
            // hold on to the reference line for a send-note, so we can repersist if saving in drafts
            if (lpszRefs)
                m_pszRefs = PszDupW(lpszRefs);
            break;

        default:
            break;
    }

    SafeMimeOleFree(lpszRefs);
}

HRESULT CNoteHdr::HrSetNewsRecipients(LPMIMEMESSAGE pMsg)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwszNewsgroups = 0,
                pwszCC = 0,
                pwszSetNewsgroups = 0;
    TCHAR       szApproved[CCHMAX_EMAIL_ADDRESS];
    HWND        hwnd;

    AssertSz(OENA_REPLYTOAUTHOR != m_ntNote,    "Shouldn't get a REPLYTOAUTHOR in a news note.");
    AssertSz(OENA_FORWARD != m_ntNote,          "Shouldn't get a FORWARD in a news note.");
    AssertSz(OENA_FORWARDBYATTACH != m_ntNote,  "Shouldn't get a FORWARDBYATTACH in a news note.");

    *szApproved = 0;
    if (m_pAccount && DwGetOption(OPT_NEWSMODERATOR))
    {
        if (FAILED(m_pAccount->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szApproved, ARRAYSIZE(szApproved))) || (0 == *szApproved))
            m_pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szApproved, ARRAYSIZE(szApproved));
    }

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &pwszNewsgroups);

    switch (m_ntNote)
    {
        case OENA_READ:
        {
            LPWSTR lpszOrg = 0;
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, &lpszOrg);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTOrg), lpszOrg, FALSE);
            SafeMimeOleFree(lpszOrg);
        }
        // Fall through


        case OENA_WEBPAGE:
        case OENA_STATIONERY:
        case OENA_COMPOSE:
        {
            LPWSTR  lpszFollowup = 0,
                    lpszDist = 0,
                    lpszKeywords = 0;

            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, &lpszFollowup);
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_DISTRIB), NOFLAGS, &lpszDist);
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, &lpszKeywords);

            pwszSetNewsgroups = pwszNewsgroups;

            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), lpszFollowup, FALSE);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), lpszDist, FALSE);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), lpszKeywords, FALSE);

            MemFree(lpszFollowup);
            MemFree(lpszDist);
            MemFree(lpszKeywords);
            break;
        }

        case OENA_REPLYALL:
        case OENA_REPLYTONEWSGROUP:
        {
            LPSTR   pszGroupsFree = 0;

            if (SUCCEEDED(ParseFollowup(pMsg, &pszGroupsFree, &m_fPoster)))
            {
                if (pszGroupsFree)
                {
                    SafeMemFree(pwszNewsgroups);

                    IF_NULLEXIT(pwszNewsgroups = PszToUnicode(CP_ACP, pszGroupsFree));
                }

                pwszSetNewsgroups = pwszNewsgroups;
            }
            else
                pwszSetNewsgroups = pwszNewsgroups;
            Assert(pwszSetNewsgroups);

            if ((OENA_REPLYALL == m_ntNote) || m_fPoster)
            {
                MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REPLYTO), NOFLAGS, &pwszCC);
                if (!pwszCC)
                    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwszCC);
            }
            break;
        }
    }

    // set common fields
    HdrSetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), pwszSetNewsgroups, FALSE);

    // set read note / send note specific fields
    if (OENA_READ != m_ntNote)
        SetDlgItemText(m_hwnd, idADApproved, szApproved);

    // set up the recipients
    hr = HrSetNewsWabal(pMsg, pwszCC);

    // BUG: 31217: showadvanced has to be the last thing we call after modifying the
    // well contents
    ShowAdvancedHeaders(DwGetOption(m_ntNote == OENA_READ ? OPT_NEWSNOTEADVREAD : OPT_NEWSNOTEADVSEND));

exit:
    MemFree(pwszNewsgroups);
    MemFree(pwszCC);
   return hr;
}


HRESULT CNoteHdr::FullHeadersShowing(void)
{
    return m_fAdvanced ? S_OK : S_FALSE;
}


HRESULT CNoteHdr::HrNewsSave(LPMIMEMESSAGE pMsg, CODEPAGEID cpID, BOOL fCheckConflictOnly)
{
    HRESULT         hr = S_OK;
    WCHAR           wsz[256];
    WCHAR          *pwszTrim;
    BOOL            fSenderOk = FALSE,
                    fSetMessageAcct = TRUE;
    PROPVARIANT     rVariant;
    SYSTEMTIME      st;
    HWND            hwnd;
    PROPVARIANT     rUserData;
    BOOL            fConflict = FALSE;

    if (fCheckConflictOnly)
    {
        HdrGetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        if (hwnd = GetDlgItem(m_hwnd, idADApproved))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }

        if (hwnd = GetDlgItem(m_hwnd, idTxtControl))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }
    }
    else
    {
        // ************************
        // This portion only happens on save, so don't try to do for fCheckConflictOnly
        // Anything not in this section had better be mirrored in the fCheckConflictOnly block above

        // Place any ascii only stuff here.

        // end of save only portion.
        // *************************
        HdrGetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            // Bug #22455 - Make sure we strip spaces etc from between newsgroups
            _ValidateNewsgroups(pwszTrim);
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_DISTRIB), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, pwszTrim));
        }

        if (hwnd = GetDlgItem(m_hwnd, idADApproved))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_APPROVED), NOFLAGS, pwszTrim));
            }
        }

        if (hwnd = GetDlgItem(m_hwnd, idTxtControl))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CONTROL), NOFLAGS, pwszTrim));
            }
        }
    }

exit:
    return hr;
}


HRESULT CNoteHdr::HrSetNewsWabal(LPMIMEMESSAGE pMsg, LPWSTR     pwszCC)
{
    HRESULT         hr              = S_OK;
    LPWABAL         lpWabal         = NULL;
    ADDRESSLIST     addrList        = { 0 };
    LPWSTR          pwszEmail       = NULL;
    IMimeMessageW   *pMsgW          = NULL;

    SafeRelease(m_lpWabal);

    if (OENA_READ == m_ntNote)
    {
        // for a read note, just take the wabal from the message
        IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &m_lpWabal));
    }
    else
    {
        TCHAR   szReplyAddr[CCHMAX_EMAIL_ADDRESS];
        TCHAR   szEmailAddr[CCHMAX_EMAIL_ADDRESS];

        // for a compose note, or a reply note we need to do some munging, so create a new wabal
        IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));

        if (OENA_COMPOSE == m_ntNote)
        {
            ADRINFO rAdrInfo;

            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &lpWabal));

            // just copy everything except From: and ReplyTo: because we'll add those later
            if (lpWabal->FGetFirst(&rAdrInfo))
            {
                do
                {
                    if (rAdrInfo.lRecipType != MAPI_ORIG && rAdrInfo.lRecipType != MAPI_REPLYTO)
                        IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }
                while (lpWabal->FGetNext(&rAdrInfo));
            }
        }

        // add replyto if necessary
        if (m_pAccount)
        {
            if (SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szReplyAddr, ARRAYSIZE(szReplyAddr))) &&
                *szReplyAddr &&
                SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szEmailAddr, ARRAYSIZE(szEmailAddr))) &&
                lstrcmpi(szReplyAddr, szEmailAddr))
            {
                TCHAR szName[CCHMAX_DISPLAY_NAME];
                if (SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_DISPLAY_NAME, szName, ARRAYSIZE(szName))))
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntryA(szName, szReplyAddr, MAPI_REPLYTO));
                else
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntryA(szReplyAddr, szReplyAddr, MAPI_REPLYTO));
            }
        }

        //Bug# 79066
        if ((OENA_REPLYALL == m_ntNote) || m_fPoster)
        {
            if (FAILED(MimeOleParseRfc822AddressW(IAT_REPLYTO, pwszCC, &addrList)))
            {
                IF_FAILEXIT(hr = MimeOleParseRfc822AddressW(IAT_FROM, pwszCC, &addrList));
            }

            IF_NULLEXIT(pwszEmail = PszToUnicode(CP_ACP, addrList.prgAdr->pszEmail));
            IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(addrList.prgAdr->pszFriendlyW, pwszEmail, MAPI_TO));

        }
    }

    // For the send note case, make sure that resolved addresses are valid.
    // If display name and email address are the same, UnresolveOneOffs() will clear
    // the email address to force a real resolve.
    if ((OENA_COMPOSE == m_ntNote) || (OENA_WEBPAGE == m_ntNote) || OENA_STATIONERY == m_ntNote)
        m_lpWabal->UnresolveOneOffs();

    m_lpWabal->HrResolveNames(NULL, FALSE);

    Assert(m_pAddrWells);
    if (SUCCEEDED(hr = m_pAddrWells->HrSetWabal(m_lpWabal)))
        hr = m_pAddrWells->HrDisplayWells(m_hwnd);

exit:
    if (g_pMoleAlloc)
    {
        if (addrList.cAdrs)
            g_pMoleAlloc->FreeAddressList(&addrList);
    }

    ReleaseObj(lpWabal);
    MemFree(pwszEmail);
    ReleaseObj(pMsgW);
    return hr;
}


HRESULT CNoteHdr::HrSetReplySubject(LPMIMEMESSAGE pMsg, BOOL fReply)
{
    WCHAR   szNewSubject[cchMaxSubject+1];
    LPWSTR  pszNorm = NULL;
    int     cchPrefix;
    LPCWSTR lpwReFwd = NULL; 

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &pszNorm);

    if (!!DwGetOption(OPT_HARDCODEDHDRS))
    {
        //Use english strings and not from resources
        lpwReFwd = fReply ? c_wszRe : c_wszFwd;

        StrCpyNW(szNewSubject, lpwReFwd, cchMaxSubject);
    }
    else
    {
        // pull in the new prefix from resource...
        AthLoadStringW(fReply?idsPrefixReply:idsPrefixForward, szNewSubject, cchMaxSubject);
    }

    cchPrefix = lstrlenW(szNewSubject);
    Assert(cchPrefix);
    if (pszNorm)
    {
        StrCpyNW(szNewSubject+cchPrefix, pszNorm, min(lstrlenW(pszNorm), cchMaxSubject-cchPrefix)+1);
        SafeMimeOleFree(pszNorm);
    }
    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), szNewSubject, FALSE);

    return NOERROR;
}

#define FIsDelimiter(_ch) (_ch==L';' || _ch==L',' || _ch==L' ' || _ch==L'\r' || _ch==L'\n' || _ch == L'\t')

void _ValidateNewsgroups(LPWSTR pszGroups)
{
    LPWSTR pszDst = pszGroups;
    BOOL   fInGroup = FALSE;
    WCHAR  ch;

    Assert(pszGroups);

    while (ch = *pszGroups++)
    {
        if (FIsDelimiter(ch))
        {
            if (fInGroup)
            {
                while ((ch = *pszGroups) && FIsDelimiter(ch))
                    pszGroups++;
                if (ch)
                    *pszDst++ = L',';
                fInGroup = FALSE;
            }
        }
        else
        {
            *pszDst++ = ch;
            fInGroup = TRUE;
        }
    }
    *pszDst = 0;
}


HRESULT CNoteHdr::HrQueryToolbarButtons(DWORD dwFlags, const GUID *pguidCmdGroup, OLECMD* pOleCmd)
{
    pOleCmd->cmdf = 0;

    if (NULL == pguidCmdGroup)
    {
        switch (pOleCmd->cmdID)
        {
            case OLECMDID_CUT:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSelAndIsRW);
                break;

            case OLECMDID_PASTE:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfPaste);
                break;

            case OLECMDID_SELECTALL:
                pOleCmd->cmdf = QS_ENABLED(TRUE);
                break;

            case OLECMDID_COPY:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSel);
                break;

            case OLECMDID_UNDO:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfUndo);
                break;
        }
    }
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        switch (pOleCmd->cmdID)
        {
            case ID_CUT:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSelAndIsRW);
                break;

            case ID_PASTE:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfPaste);
                break;

            case ID_SELECT_ALL:
                pOleCmd->cmdf = QS_ENABLED(TRUE);
                break;

            case ID_NOTE_COPY:
            case ID_COPY:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSel);
                break;

            case ID_UNDO:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfUndo);
                break;
        }
    }

    return NOERROR;
}


void CNoteHdr::OnButtonClick(int idBtn)
{
    UINT cch;
    LPTSTR pszGroups;
    //CPickGroupDlg* ppgd;

    switch (idBtn)
    {
        case idbtnTo:
            if (m_fMail)
                HrPickNames(0);
            else
                HrPickGroups(idADNewsgroups, FALSE);
            break;

        case idbtnFollowup:
            HrPickGroups(idTXTFollowupTo, TRUE);
            break;

        case idbtnCc:
            if (m_fMail)
                HrPickNames(1);
            else
                HrPickNames(0);
            break;

        case idbtnBCc:
            HrPickNames(2);
            break;

        case idbtnReplyTo:
            HrPickNames(1);
            break;
    }
}

void CNoteHdr::HrPickGroups(int idWell, BOOL fFollowUpTo)
{
    UINT            cch;
    DWORD           cServer = 0;
    HWND            hwnd;
    LPSTR           pszGroups=NULL;
    LPWSTR          pwszGroups=NULL;
    CPickGroupDlg  *ppgd;
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];

    g_pAcctMan->GetAccountCount(ACCT_NEWS, &cServer);

    // BUGBUG Sometimes m_pAccount is an IMAP server, so we want to also
    // test that we have at least one news server.  This is a known problem
    // that was punted a long time ago.
    if (!m_pAccount || !cServer)
    {
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrConfigureServer), NULL, MB_OK);
        return;
    }

    hwnd = GetDlgItem(m_hwnd, idWell);
    if (S_OK == HrGetFieldText(&pwszGroups, hwnd))
    {
        // Since this function doesn't fail, just make sure that we
        // don't do anything funky when PszToANSI and PszToUnicode fails.
        pszGroups = PszToANSI(GetACP(), pwszGroups);
    }

    ppgd = new CPickGroupDlg;
    if (ppgd)
    {
        FOLDERID idServer = FOLDERID_INVALID;
        m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount));

        // find the parent folder id of the account
        if (SUCCEEDED(g_pStore->FindServerId(szAccount, &idServer)) && 
                      ppgd->FCreate(m_hwnd, idServer, &pszGroups, fFollowUpTo) &&
                      pszGroups)
        {
            SafeMemFree(pwszGroups);
            pwszGroups = PszToUnicode(CP_ACP, pszGroups);
            HdrSetRichEditText(hwnd, pwszGroups != NULL ? pwszGroups : c_wszEmpty, FALSE);
        }

        ppgd->Release();
    }

    MemFree(pwszGroups);
    MemFree(pszGroups);
}

HRESULT CNoteHdr::HrPickNames(int iwell)
{
    HRESULT hr = NOERROR;

    if (IsReadOnly())
        return hr;

    Assert(m_lpWabal);
    Assert(m_pAddrWells);

    //We need to setmodify so that it is marked as dirty. In a normal case, 
    //the user would have typed in and hence set modify would have happenned automatically
    if (m_fPoster)
    {
        Edit_SetModify(GetDlgItem(m_hwnd, idADCc), TRUE);
    }

    hr=m_pAddrWells->HrSelectNames(m_hwnd, iwell, m_fMail?FALSE:TRUE);
    if (SUCCEEDED(hr))
    {
        // Check to see if need to show advanced headers.
        if (0 < GetRichEditTextLen(GetDlgItem(m_hwnd, idADBCc)))
            ShowAdvancedHeaders(TRUE);
    }
    else if (hr!=MAPI_E_USER_CANCEL)
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrPickNames), NULL, MB_OK);

    return hr;
}

HRESULT CNoteHdr::HrGetAccountInHeader(IImnAccount **ppAcct)
{
    HRESULT         hr = E_FAIL;
    IImnAccount    *pAcct = NULL;
    ULONG           cAccount = 0;
    HWND            hwndCombo = GetDlgItem(m_hwnd, idFromCombo);

    // If the combo box is being used then get the account info from it.
    if (SUCCEEDED(g_pAcctMan->GetAccountCount(m_fMail?ACCT_MAIL:ACCT_NEWS, &cAccount)) && 
            (cAccount > 1) && hwndCombo)
    {
        LPSTR   szAcctID = NULL;
        ULONG   i = ComboBox_GetCurSel(hwndCombo);

        szAcctID = (LPSTR)SendMessage(hwndCombo, CB_GETITEMDATA, WPARAM(i), 0);
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctID, &pAcct);
    }

    // Get default account from MsgSite
    if (FAILED(hr) && m_pHeaderSite)
    {
        IOEMsgSite *pMsgSite = NULL;
        IServiceProvider *pServ = NULL;

        hr = m_pHeaderSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&pServ);
        if (SUCCEEDED(hr))
        {
            hr = pServ->QueryService(IID_IOEMsgSite, IID_IOEMsgSite, (LPVOID*)&pMsgSite);
            pServ->Release();
        }
        if (SUCCEEDED(hr))
        {
            hr = pMsgSite->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &pAcct);
            pMsgSite->Release();
        }
    }

    // Get global default.  Used in failure case and in Envelope (WordMail, etc) case
    if (FAILED(hr))
        hr = g_pAcctMan->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &pAcct);

    if (SUCCEEDED(hr))
    {
        AssertSz(pAcct, "How is it that we succeeded, yet we don't have an account???");
        ReplaceInterface((*ppAcct), pAcct);
    }
    else if (E_FAIL == hr)
        hr = HR_E_COULDNOTFINDACCOUNT;

    ReleaseObj(pAcct);

    return hr;
}

HRESULT CNoteHdr::HrFillMessage(IMimeMessage *pMsg)
{
    IUnknown       *punk;
    IPersistMime   *pPM = NULL;
    HRESULT         hr;

    if (m_pEnvelopeSite)
        punk = m_pEnvelopeSite;
    else
        punk = m_pHeaderSite;

    AssertSz(punk, "You need either a HeaderSite or an EnvelopeSite");

    hr = punk->QueryInterface(IID_IPersistMime, (LPVOID*)&pPM);
    if (SUCCEEDED(hr))
    {
        hr = pPM->Save(pMsg, 0);
        ReleaseObj(pPM);

        if (hr == MAPI_E_USER_CANCEL)
            goto Exit;
    }
    else
    // If can't get a IPersistMime, need to fake the save through the m_pEnvelopeSite
    // The only time the QI for IPersistMime doesn't work is if you have an m_pEnvelopeSite
    // that doesn't support IPersistMime. If you have a m_pHeaderSite, QI should always work.
    {
        LPSTREAM    pstm;
        HBODY       hBodyHtml = 0;

        AssertSz(m_pEnvelopeSite, "If the QI didn't work, then must be an envelope site.");

        // We need to select the charset before we save the message
        pMsg->SetCharset(m_hCharset, CSET_APPLY_ALL);

        hr = Save(pMsg, 0);
        if (FAILED(hr))
            goto Exit;

        // Word will call our GetAttach function during this call to GetBody so save m_pMsgSend
        // so that we can inline attaches that Word sends to us.
        m_pMsgSend = pMsg;

        if (SUCCEEDED(_GetMsoBody(ENV_BODY_HTML, &pstm)))
        {
            pMsg->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, &hBodyHtml);
            pstm->Release();
        }
        
        if (SUCCEEDED(_GetMsoBody(ENV_BODY_TEXT, &pstm)))
        {
            pMsg->SetTextBody(TXT_PLAIN, IET_INETCSET, hBodyHtml, pstm, NULL);
            pstm->Release();
        }

        m_pMsgSend = NULL;
    }

    Exit:
    return hr;
}

HRESULT CNoteHdr::_GetMsoBody(ULONG uBody, LPSTREAM *ppstm)
{
    LPSTREAM    pstm=NULL;
    HRESULT     hr;

    *ppstm = NULL;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));
    IF_FAILEXIT(hr = m_pEnvelopeSite->GetBody(pstm, uCodePageFromCharset(m_hCharset), uBody));

    *ppstm = pstm;
    pstm = NULL;

exit:
    ReleaseObj(pstm);
    return hr;
}

#ifdef YST
// this check produced a 4 bugs in OE 5.01 and 5.5 and I disaable it (YST)
HRESULT CNoteHdr::_CheckMsoBodyCharsetConflict(CODEPAGEID cpID)
{
    HRESULT     hr = S_OK;
    LPSTREAM    pstm = NULL;
    BSTR        bstrText = NULL;
    ULONG       cbToRead = 0, 
                cbRead = 0;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    hr = m_pEnvelopeSite->GetBody(pstm, CP_UNICODE, ENV_BODY_TEXT);

    // bobn; Raid 81900; 6/30/99
    // Excel (and powerpoint?) don't have a text body.
    // Check that there is an HTML body and we can have
    // it in unicode.
    if(FAILED(hr))
        IF_FAILEXIT(hr = m_pEnvelopeSite->GetBody(pstm, CP_UNICODE, ENV_BODY_HTML));

    IF_FAILEXIT(hr = HrIStreamToBSTR(CP_UNICODE, pstm, &bstrText));

    hr = HrSafeToEncodeToCP((LPWSTR)bstrText, cpID);

exit:
    SysFreeString(bstrText);
    ReleaseObj(pstm);
    return hr;
}
#endif //YST

HRESULT CNoteHdr::HrCheckSendInfo()
{
    HRESULT hr;
    BOOL    fOneOrMoreGroups = FALSE,
            fOneOrMoreNames = FALSE;

    hr = HrCheckNames(FALSE, TRUE);
    if (FAILED(hr))
    {
        if ((MAPI_E_USER_CANCEL != hr) && (hrNoRecipients != hr))
            hr = hrBadRecipients;

        if (hrNoRecipients != hr)
            goto Exit;
    }
    else
        fOneOrMoreNames = TRUE;

    // If we didn't find any email recipients, don't need to check if valid.
    if (SUCCEEDED(hr) && m_lpWabal)
        hr = m_lpWabal->IsValidForSending();

    // Only check groups if:
    // 1- Have succeeded to this point or didn't have any email recipients
    // 2- In a news header
    if ((SUCCEEDED(hr) || (hrNoRecipients == hr)) && !m_fMail)
    {
        hr = HrCheckGroups(TRUE);
        if (SUCCEEDED(hr))
            fOneOrMoreGroups = TRUE;
    }

    if (FAILED(hr))
        goto Exit;

    hr = HrCheckSubject(!fOneOrMoreGroups);
    if (FAILED(hr))
        goto Exit;

    // TODO:
    if (m_pHeaderSite && m_pHeaderSite->IsHTML() == S_OK)
    {
        // if a HTML message, then let's make sure there's no plain-text recipients
        if (fOneOrMoreNames)
        {
            hr = HrIsCoolToSendHTML();
            if (hr == S_FALSE && m_pHeaderSite)
                // send plain-text only...
                m_pHeaderSite->SetHTML(FALSE);
        }

        if (fOneOrMoreGroups && 
            (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSHTMLNewsWarning, MAKEINTRESOURCE(idsAthena), 
                                              MAKEINTRESOURCE(idsErrHTMLInNewsIsBad), MB_OKCANCEL)))
            hr = MAPI_E_USER_CANCEL;
    }

Exit:
    return hr;
}

HRESULT CNoteHdr::HrSend(void)
{
    HRESULT             hr;
    IMimeMessage       *pMsg = NULL;
    IOEMsgSite         *pMsgSite = NULL;    

    if (m_pEnvelopeSite)
    {
        // With the envelope site, must check to see if things set up at this point to use mail
        hr = ProcessICW(m_hwnd, FOLDER_LOCAL, TRUE);
        if (hr == S_FALSE)
            // user cancelled out of config wizard so we can't continue
            hr = MAPI_E_USER_CANCEL;
        if (FAILED(hr))
            goto error;
        m_fSendImmediate = TRUE;
    }

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    // The only case where this will happen is if no accounts are configured. Just to make
    // sure, call the ICW and then try to get the default account.
    if (!m_pAccount)
    {
        hr = ProcessICW(m_hwnd, m_fMail ? FOLDER_LOCAL : FOLDER_NEWS, TRUE);
        if (FAILED(hr))
            goto error;

        if (FAILED(g_pAcctMan->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &m_pAccount)))
        {
            hr = HR_E_COULDNOTFINDACCOUNT;
            goto error;
        }
    }

    hr = HrCheckSendInfo();
    if (FAILED(hr))
        goto error;

    // Does IPersistMime save stuff
    hr = HrFillMessage(pMsg);
    if (FAILED(hr))
        goto error;

    if (m_pHeaderSite)
    {
        IOEMsgSite *pMsgSite = NULL;
        IServiceProvider *pServ = NULL;

        hr = m_pHeaderSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&pServ);
        if (SUCCEEDED(hr))
        {
            hr = pServ->QueryService(IID_IOEMsgSite, IID_IOEMsgSite, (LPVOID*)&pMsgSite);
            pServ->Release();
        }
        if (SUCCEEDED(hr))
        {
            hr = pMsgSite->SendToOutbox(pMsg, m_fSendImmediate, m_pHeaderSite);
            pMsgSite->Release();
        }
    }
    // We are in office Envelope
    else
    {
        COEMsgSite *pMsgSite = NULL;
        CStoreCB   *pCB = NULL;

        pMsgSite = new COEMsgSite();
        if (!pMsgSite)
            hr = E_OUTOFMEMORY;

        pCB = new CStoreCB;
        if (!pCB)
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
            hr = pCB->Initialize(m_hwndParent, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);

        if (SUCCEEDED(hr))
        {
            INIT_MSGSITE_STRUCT rInitStruct;

            rInitStruct.dwInitType = OEMSIT_MSG;
            rInitStruct.folderID = FOLDERID_INVALID;
            rInitStruct.pMsg = pMsg;

            hr = pMsgSite->Init(&rInitStruct);
        }

        if (SUCCEEDED(hr))
            hr = pMsgSite->SetStoreCallback(pCB);

        if (SUCCEEDED(hr))
        {
            hr = pMsgSite->SendToOutbox(pMsg, m_fSendImmediate, m_pHeaderSite);
            if (E_PENDING == hr)
                hr = pCB->Block();

            pCB->Close();
        }

        if (SUCCEEDED(hr))
        {
            m_pEnvelopeSite->CloseNote(ENV_CLOSE_SEND);
            ShowWindow(m_hwnd, SW_HIDE);
        }

        if (pMsgSite)
        {
            pMsgSite->Close();
            pMsgSite->Release();
        }

        ReleaseObj(pCB);
    }

    error:
    if (FAILED(hr))
    {
        int idsErr = -1;
        m_fSecurityInited = FALSE;

        switch (hr)
        {
            case hrNoRecipients:        
                if(!m_fMail)
                    hr = HR_E_POST_WITHOUT_NEWS;  // idsErr = idsErrPostWithoutNewsgroup; 
                break;

            case HR_E_COULDNOTFINDACCOUNT:      
                if(!m_fMail)
                    hr  = HR_E_CONFIGURE_SERVER; //idsErr = idsErrConfigureServer; 
                break;

            case HR_E_ATHSEC_FAILED:
            case hrUserCancel:
            case MAPI_E_USER_CANCEL:    
                idsErr = 0; 
                break;

            case HR_E_ATHSEC_NOCERTTOSIGN:
            case MIME_E_SECURITY_NOSIGNINGCERT:
                idsErr = 0; 
                if(DialogBoxParam(g_hLocRes, 
                            MAKEINTRESOURCE(iddErrSecurityNoSigningCert), m_hwnd, 
                            ErrSecurityNoSigningCertDlgProc, NULL) == idGetDigitalIDs)
                    GetDigitalIDs(m_pAccount);
                break;
            
            default:                    
                // idsErr = m_fMail?idsErrSendMail:NULL; // ~~~ Should we have a default for news?
                break;
        }

        if (idsErr != 0)
        {
            AthErrorMessageW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrSendMail), hr);
            if ((hr == hrNoRecipients) || (hr == HR_E_POST_WITHOUT_NEWS))
                SetInitFocus(FALSE);
        }
    }


    ReleaseObj(pMsg);
    return hr;
}

HRESULT CNoteHdr::HrCheckSubject(BOOL fMail)
{
    HWND    hwnd;

    if ((hwnd=GetDlgItem(m_hwnd, idTXTSubject)) && GetRichEditTextLen(hwnd)==0)
    {
        if (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, fMail?c_szRegMailEmptySubj:c_szRegNewsEmptySubj,
                                             MAKEINTRESOURCE(idsAthena),
                                             MAKEINTRESOURCE(fMail?idsWarnMailEmptySubj:idsWarnNewsEmptySubj),
                                             MB_OKCANCEL))
        {
            ::SetFocus(hwnd);
            return MAPI_E_USER_CANCEL;
        }
    }
    return NOERROR;
}

HRESULT CNoteHdr::HrIsCoolToSendHTML()
{
    HRESULT     hr=S_OK;
    ADRINFO     adrInfo;
    BOOL        fPlainText=FALSE;
    int         id;

    // check for plaintext people
    if (m_lpWabal->FGetFirst(&adrInfo))
    {
        do
        {
            if (adrInfo.fPlainText)
            {
                fPlainText=TRUE;
                break;
            }
        }
        while (m_lpWabal->FGetNext(&adrInfo));
    }

    if (fPlainText)
    {
        id = (int) DialogBox(g_hLocRes, MAKEINTRESOURCE(iddPlainRecipWarning), m_hwnd, _PlainWarnDlgProc);
        if (id == IDNO)
            return S_FALSE;
        else
            if (id == IDCANCEL)
            return MAPI_E_USER_CANCEL;
        else
            return S_OK;
    }
    return hr;
}



INT_PTR CALLBACK _PlainWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int id;

    switch (msg)
    {
        case WM_INITDIALOG:
            CenterDialog(hwnd);
            return TRUE;

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);
            if (id == IDYES || id == IDNO || id == IDCANCEL)
            {
                EndDialog(hwnd, id);
                break;
            }
    }
    return FALSE;
}


static HACCEL   g_hAccelMailSend=0;

// This should only get called from the envelope as a send note
HACCEL CNoteHdr::GetAcceleratorTable()
{
    Assert(!IsReadOnly());
    Assert(m_pEnvelopeSite);

    if (!g_hAccelMailSend)
        g_hAccelMailSend = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_SEND_HDR_ACCEL));

    return g_hAccelMailSend;
}

HRESULT CNoteHdr::HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType)
{
    HRESULT hr;

    if (!m_fSecurityInited)
    {
        if (SUCCEEDED(hr = ::HrInitSecurityOptions(pMsg, ulSecurityType)))
            m_fSecurityInited = TRUE;
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CNoteHdr::HrHandleSecurityIDMs(BOOL fDigSign)
{
    IMimeBody  *pBody;
    PROPVARIANT var;
    HRESULT     hr;

    if (fDigSign)
        m_fDigSigned = !m_fDigSigned;
    else
        m_fEncrypted = !m_fEncrypted;

    if(m_fForceEncryption && m_fDigSigned)
        m_fEncrypted = TRUE;

    hr = HrUpdateSecurity();

    return hr;
}


HRESULT CNoteHdr::HrInitSecurity()
{
    HRESULT hr = S_OK;

    // Constructor set these flags to false so don't need to handle else case
    if (OENA_READ != m_ntNote && m_fMail)
    {
        m_fDigSigned = DwGetOption(OPT_MAIL_DIGSIGNMESSAGES);
        m_fEncrypted = DwGetOption(OPT_MAIL_ENCRYPTMESSAGES);
    }

    return hr;
}


HRESULT CNoteHdr::HrUpdateSecurity(LPMIMEMESSAGE pMsg)
{
    RECT        rc;
    HRESULT     hr = NOERROR;
    LPWSTR      psz = NULL;
    HWND        hEdit;
    
    switch (m_ntNote)
    {
    case OENA_READ:
    case OENA_REPLYTOAUTHOR:
    case OENA_REPLYTONEWSGROUP:
    case OENA_REPLYALL:
    case OENA_FORWARD:
    case OENA_FORWARDBYATTACH:
        
        if (pMsg)
        {
            CleanupSECSTATE(&m_SecState);
            HrGetSecurityState(pMsg, &m_SecState, NULL);
            
            m_fDigSigned = IsSigned(m_SecState.type);
            m_fEncrypted = IsEncrypted(m_SecState.type);
            
            // RAID 12243. Added these two flags for broken and untrusted messages
            if(m_ntNote == OENA_READ)
            {
                m_fSignTrusted = IsSignTrusted(&m_SecState);
                m_fEncryptionOK = IsEncryptionOK(&m_SecState);
            }
        }       
        break;
        
    case OENA_COMPOSE:
        if (pMsg)
        {
            // Make certain that the highest security of (current message, option defaults) is applied.
            //
            CleanupSECSTATE(&m_SecState);
            HrGetSecurityState(pMsg, &m_SecState, NULL);
            
            if (! m_fDigSigned)
            {
                m_fDigSigned = IsSigned(m_SecState.type);
            }
            if (! m_fEncrypted)
            {
                m_fEncrypted = IsEncrypted(m_SecState.type);
            }
        }
        break;
        
    default:            // do nothing
        break;        
    }
    hEdit = GetDlgItem(m_hwnd, idSecurity);
    if (hEdit)
    {
        PHCI phci = (HCI*)GetWindowLongPtr(hEdit, GWLP_USERDATA);
        // BUG 17788: need to set the text even if it is null
        // since that will delete old security line text.
        psz = SzGetDisplaySec(pMsg, NULL);
        
        HdrSetRichEditText(hEdit, psz, FALSE);
        
        phci->fEmpty = (0 == *psz);
    }
    
    m_fThisHeadDigSigned = m_fDigSigned;
    m_fThisHeadEncrypted = m_fEncrypted;

//    if(!m_fDigSigned)
//        m_fForceEncryption = FALSE;
    
    InvalidateRightMargin(0);
    ReLayout();
    
    if (m_pHeaderSite)
        m_pHeaderSite->Update();
    
    if (m_hwndToolbar)
    {
        Assert(m_pEnvelopeSite);
        if (m_fDigSigned)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_DIGITALLY_SIGN, MAKELONG(TBSTATE_ENABLED | TBSTATE_PRESSED, 0));
        else
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_DIGITALLY_SIGN, MAKELONG(TBSTATE_ENABLED, 0));

        if(m_fForceEncryption && m_fDigSigned)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_PRESSED, 0));
        else if (m_fEncrypted)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_ENABLED | TBSTATE_PRESSED, 0));
        else
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_ENABLED, 0));
    }
    
    return hr;
}


HRESULT CNoteHdr::HrSaveSecurity(LPMIMEMESSAGE pMsg)
{
    HRESULT     hr;
    ULONG       ulSecurityType = MST_CLASS_SMIME_V1;

    if (m_fDigSigned)
        ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
    else
        ulSecurityType &= ~((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);


    if (m_fEncrypted)
        ulSecurityType |= MST_THIS_ENCRYPT;
    else
        ulSecurityType &= ~MST_THIS_ENCRYPT;

    hr = HrInitSecurityOptions(pMsg, ulSecurityType);

    return hr;
}


BOOL CNoteHdr::IsReadOnly()
{
    if (m_ntNote==OENA_READ)
        return TRUE;
    else
        return FALSE;
}


HRESULT CNoteHdr::HrViewContacts()
{
    LPWAB   lpWab;

    if (!FAILED (HrCreateWabObject (&lpWab)))
    {
        // launch wab in modal-mode if a) container is modal or b) running as office envelope
        lpWab->HrBrowse (m_hwnd, m_fOfficeInit ? TRUE : (m_pHeaderSite ? (m_pHeaderSite->IsModal() == S_OK) : FALSE));
        lpWab->Release ();
    }
    else
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsGeneralWabError), NULL, MB_OK);

    return NOERROR;
}

BOOL CNoteHdr::FDoCutCopyPaste(int wmCmd)
{
    HWND hwndFocus=GetFocus();

    // only if it's one of our kids..
    if (GetParent(hwndFocus)==m_hwnd)
    {
        SendMessage(hwndFocus, wmCmd, 0, 0);
        return TRUE;
    }

    return FALSE;
}

HRESULT CNoteHdr::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);

    int *array;
    int cCount;
    if (m_fMail)
    {
        if (IsReadOnly())
        {
            array = rgIDTabOrderMailRead;
            cCount = sizeof(rgIDTabOrderMailRead)/sizeof(int);
        }
        else
        {
            array = rgIDTabOrderMailSend;
            cCount = sizeof(rgIDTabOrderMailSend)/sizeof(int);
        }
    }
    else
    {
        if (IsReadOnly())
        {
            array = rgIDTabOrderNewsRead;
            cCount = sizeof(rgIDTabOrderNewsRead)/sizeof(int);
        }
        else
        {
            array = rgIDTabOrderNewsSend;
            cCount = sizeof(rgIDTabOrderNewsSend)/sizeof(int);
        }
    }

    AssertSz(cCount <= *pcArrayCount, "Do you need to change MAX_HEADER_COMP in note.h?");
    for (int i = 0; i < cCount; i++)
        *rgTSArray++ = GetDlgItem(m_hwnd, *array++);

    *pcArrayCount = cCount;

    return S_OK;
}


HRESULT CNoteHdr::SetFlagState(MARK_TYPE markType)
{
    BOOL fDoRelayout = FALSE;
    switch (markType)
    {
        case MARK_MESSAGE_FLAGGED:
        case MARK_MESSAGE_UNFLAGGED:
        {
            BOOL fFlagged = (MARK_MESSAGE_FLAGGED == markType);
            if (m_fFlagged != fFlagged)
            {
                fDoRelayout = TRUE;
                m_fFlagged = fFlagged;
            }
            break;
        }

        case MARK_MESSAGE_WATCH: 
        case MARK_MESSAGE_IGNORE: 
        case MARK_MESSAGE_NORMALTHREAD:
            if (m_MarkType != markType)
            {
                fDoRelayout = TRUE;
                m_MarkType = markType;
            }
            break;
    }

    if (fDoRelayout)
    {
        InvalidateStatus();
        ReLayout();

        if (m_pHeaderSite)
            m_pHeaderSite->Update();
    }
    return S_OK;
}


HRESULT CNoteHdr::ShowEnvOptions()
{
    nyi("Header options are not implemented yet.");
    return S_OK;
}

void CNoteHdr::ReLayout()
{
    RECT rc; 

    if (m_fSkipLayout)
        return;

    GetClientRect(m_hwnd, &rc);
    SetPosOfControls(rc.right, TRUE);

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}

//IDropTarget
HRESULT CNoteHdr::DragEnter(LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    LPENUMFORMATETC penum = NULL;
    HRESULT         hr;
    FORMATETC       fmt;
    ULONG           ulCount = 0;

    if (m_lpAttMan->HrIsDragSource() == S_OK)
    {
        *pdwEffect=DROPEFFECT_NONE;
        return S_OK;
    }

    if (!pdwEffect || !pDataObj)
        return E_INVALIDARG;

    m_dwEffect = DROPEFFECT_NONE;

    // lets get the enumerator from the IDataObject, and see if the format we take is
    // available
    hr = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);

    if (SUCCEEDED(hr) && penum)
    {
        hr = penum->Reset();
        while (SUCCEEDED(hr=penum->Next(1, &fmt, &ulCount)) && ulCount)
        {
            if ( fmt.cfFormat==CF_HDROP || 
                 fmt.cfFormat==CF_FILEDESCRIPTORA || 
                 fmt.cfFormat==CF_FILEDESCRIPTORW)
            {
                // we take either a CF_FILEDESCRIPTOR from the shell, or a CF_HDROP...

                //by default, or a move if the shift key is down
                if ( (*pdwEffect) & DROPEFFECT_COPY )
                    m_dwEffect = DROPEFFECT_COPY;

                if ( ((*pdwEffect) & DROPEFFECT_MOVE) &&
                     (grfKeyState & MK_SHIFT))
                    m_dwEffect=DROPEFFECT_MOVE;

                // IE3 gives us a link
                // if ONLY link is specified, default to a copy
                if (*pdwEffect == DROPEFFECT_LINK)
                    m_dwEffect=DROPEFFECT_LINK;

                m_cfAccept=fmt.cfFormat;
                if (m_cfAccept==CF_FILEDESCRIPTORW)   // this is the richest format we take, if we find one of these, no point looking any
                    break;                            // further...
            }
        }
    }

    ReleaseObj(penum);
    *pdwEffect    = m_dwEffect;
    m_grfKeyState = grfKeyState;
    return S_OK;
}


HRESULT CNoteHdr::DragOver(DWORD grfKeyState,POINTL pt, DWORD *pdwEffect)
{
    if (m_lpAttMan->HrIsDragSource() == S_OK)
    {
        *pdwEffect=DROPEFFECT_NONE;
        return S_OK;
    }

    if ( m_dwEffect == DROPEFFECT_NONE) // we're not taking drops at all...
    {
        *pdwEffect = m_dwEffect;
        return NOERROR;
    }

    // Cool, we've accepted the drag this far... now we
    // have to watch to see if it turns into a copy or move...
    // as before, take the copy as default or move if the
    // shft key is down
    if ((*pdwEffect)&DROPEFFECT_COPY)
        m_dwEffect=DROPEFFECT_COPY;

    if (((*pdwEffect)&DROPEFFECT_MOVE)&&
        (grfKeyState&MK_SHIFT))
        m_dwEffect=DROPEFFECT_MOVE;

    if (*pdwEffect==DROPEFFECT_LINK) // if it's link ONLY, like IE3 gives, then fine...
        m_dwEffect=DROPEFFECT_LINK;

    *pdwEffect &= m_dwEffect;
    m_grfKeyState=grfKeyState;

    return NOERROR;
}


HRESULT CNoteHdr::DragLeave()
{
    return NOERROR;
}


HRESULT CNoteHdr::Drop(LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT         hr    = E_FAIL;
    FORMATETC       fmte    = {m_cfAccept, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM       medium;

    *pdwEffect = m_dwEffect;

    if ( m_dwEffect != DROPEFFECT_NONE )
    {
        // If this is us sourcing the drag, just bail. We may want to save the
        // points of the icons.
        //
        if (m_lpAttMan->HrIsDragSource() == S_OK)
        {
            *pdwEffect=DROPEFFECT_NONE;
            return S_OK;
        }

        if ( (m_grfKeyState & MK_RBUTTON) &&
             m_lpAttMan->HrGetRequiredAction(pdwEffect, pt))
            return E_FAIL;


        if (pDataObj &&
            SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
        {

            if (m_cfAccept==CF_HDROP)
            {
                HDROP hdrop=(HDROP)GlobalLock(medium.hGlobal);

                hr=m_lpAttMan->HrDropFiles(hdrop, (*pdwEffect)&DROPEFFECT_LINK);

                GlobalUnlock(medium.hGlobal);
            }
            else
                if (m_cfAccept==CF_FILEDESCRIPTORA || m_cfAccept==CF_FILEDESCRIPTORW)
            {
                // all file descriptors are copy|more, link makes no sense, as they are are
                // memory object, ie. non-existent in fat.
                hr=m_lpAttMan->HrDropFileDescriptor(pDataObj, FALSE);
            }
#ifdef DEBUG
            else
                AssertSz(0, "how did this clipformat get accepted??");
#endif

            if (medium.pUnkForRelease)
                medium.pUnkForRelease->Release();
            else
                GlobalFree(medium.hGlobal);
        }
    }
    return hr;
}

HRESULT CNoteHdr::HrGetAttachCount(ULONG *pcAttach)
{
    return m_lpAttMan->HrGetAttachCount(pcAttach);
}

HRESULT CNoteHdr::HrIsDragSource()
{
    return m_lpAttMan->HrIsDragSource();
}


HRESULT CNoteHdr::UnloadAll()
{
    if (m_lpAttMan)
    {
        m_lpAttMan->HrUnload();
        m_lpAttMan->HrClearDirtyFlag();
    }

    for (int i=0; i<(int)m_cHCI; i++)
    {
        if (0 == (m_rgHCI[i].dwFlags & HCF_ATTACH))
        {
            if (0 == (m_rgHCI[i].dwFlags & HCF_COMBO))
                HdrSetRichEditText(GetDlgItem(m_hwnd, m_rgHCI[i].idEdit), c_wszEmpty, FALSE);
            else
                SetWindowText(GetDlgItem(m_hwnd, m_rgHCI[i].idEdit), "");
        }
    }

    m_fDirty = FALSE;
    m_pri = priNorm;
    return S_OK;
}

void CNoteHdr::SetDirtyFlag()
{
    if (!m_fStillLoading)
    {
        m_fDirty = TRUE;
        if (m_pEnvelopeSite)
            m_pEnvelopeSite->OnPropChange(dispidSomething);
    }
}

void CNoteHdr::SetPosOfControls(int headerWidth, BOOL fChangeVisibleStates)
{
    int         cx,
                cy,
                cyDirty,
                cyLabelDirty,
                oldWidth = 0,
                windowPosFlags = SETWINPOS_DEF_FLAGS,
                editWidth = headerWidth - m_cxLeftMargin - GetRightMargin(FALSE);
    RECT        rc;
    HWND        hwnd;
    PHCI        phci = m_rgHCI;
    BOOL        fRePosition = FALSE;

    if ((headerWidth < 5) || (m_fSkipLayout))
        return; 

    STACK("SetPosOfControls (header width, edit width)", headerWidth, editWidth);

    // size the dialog
    GetClientRect(m_hwnd, &rc);
    cyDirty = rc.bottom;
    cyLabelDirty = rc.bottom;

    if (fChangeVisibleStates)
        windowPosFlags |= SWP_SHOWWINDOW;

    cy = BeginYPos();

    for (int i=0; i<(int)m_cHCI; i++, phci++)
    {
        hwnd = GetDlgItem(m_hwnd, phci->idEdit);
        if (hwnd)
        {
            if (S_OK == HrFShowHeader(phci))
            {
                int     newLabelCY = (phci->dwFlags & HCF_BORDER) ? cy + 2*cyBorder : cy;
                BOOL    fLabelMoved = FALSE;
                if (phci->cy != cy)
                {
                    int smcy = ((INVALID_PHCI_Y != phci->cy) && (phci->cy < cy)) ? phci->cy : cy;
                    if (cyLabelDirty > smcy)
                        cyLabelDirty = smcy;
                    phci->cy = cy;
                    fLabelMoved = TRUE;
                }

                // Is an attachment
                if (HCF_ATTACH & phci->dwFlags)
                {
                    DWORD   cyAttMan = 0;
                    RECT    rc;

                    m_lpAttMan->HrGetHeight(editWidth, &cyAttMan);
                    if (cyAttMan > MAX_ATTACH_PIXEL_HEIGHT)
                        cyAttMan = MAX_ATTACH_PIXEL_HEIGHT;

                    cyAttMan += 4*cyBorder;

                    cyDirty = cy;

                    rc.left = m_cxLeftMargin;
                    rc.right = m_cxLeftMargin + editWidth;
                    rc.top = cy;
                    rc.bottom = cy + cyAttMan;

                    m_lpAttMan->HrSetSize(&rc);

                    if ((cyAttMan != (DWORD)phci->height) && (cyDirty > cy))
                        cyDirty = cy;

                    AssertSz(cyAttMan != 0, "Setting this to zero would be a bummer...");
                    phci->height = cyAttMan;

                    cy += cyAttMan + ControlYBufferSize();
                }
                // Is either an edit or combo
                else
                {
                    int     newHeight = phci->height,
                            ctrlHeight = GetCtrlHeight(hwnd);

                    oldWidth = GetCtrlWidth(hwnd); 

                    if (HCF_COMBO & phci->dwFlags)
                    {
                        if (ctrlHeight != newHeight)
                        {
                            fRePosition = TRUE;
                            phci->height = ctrlHeight;
                            newHeight = GetControlSize(TRUE, NUM_COMBO_LINES);
                        }
                        else
                        {
                            fRePosition = fRePosition || fLabelMoved || (oldWidth != editWidth);
                            if (fRePosition)
                                newHeight = GetControlSize(TRUE, NUM_COMBO_LINES);
                        }
                    }
                    else
                    {
                        fRePosition = fRePosition || fLabelMoved || (oldWidth != editWidth) || (ctrlHeight != newHeight);
                    }

                    if (fRePosition)
                    {
                        SetWindowPos(hwnd, NULL, m_cxLeftMargin, cy, editWidth, newHeight, windowPosFlags);

                        // RAID 81136: The above SetWindowPos might change the width in such a way
                        // that the height now needs to change. We detect this condition below and
                        // cause another resize to handle the needed height change. This, of course,
                        // is only valid with the richedits.
                        if ((newHeight != phci->height) && (0 == (HCF_COMBO & phci->dwFlags)))
                        {
                            SetWindowPos(hwnd, NULL, m_cxLeftMargin, cy, editWidth, phci->height, windowPosFlags);
                        }
                        if (cyDirty > cy)
                            cyDirty = cy;
                        if (fLabelMoved)
                            InvalidateRect(hwnd, NULL, FALSE);
                    }
                    cy += phci->height + ControlYBufferSize();
                }
            }
            else
            {
                phci->cy = INVALID_PHCI_Y;
                if (fChangeVisibleStates)
                    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW);
            }
        }
    }

    DOUTL(RESIZING_DEBUG_LEVEL, "STATE resizing header (headerwidth=%d, cy=%d)", headerWidth, cy);

    // don't send a poschanging, as we did all the work here, plus invalidation...
    SetWindowPos(m_hwnd, NULL, NULL, NULL, headerWidth, cy, 
                SETWINPOS_DEF_FLAGS|SWP_NOMOVE|SWP_DRAWFRAME|SWP_FRAMECHANGED);

    // notify the parent to resize the note...
    if (m_pHeaderSite)
        m_pHeaderSite->Resize();

    if (m_pEnvelopeSite)
    {
        m_pEnvelopeSite->RequestResize(&cy);
    }

    GetRealClientRect(m_hwnd, &rc);

    // Dirty the labels region
    if (rc.bottom != cyLabelDirty)
    {
        rc.top = cyLabelDirty;
        rc.right = m_cxLeftMargin;
        rc.left = 0;
        InvalidateRect(m_hwnd, &rc, TRUE);
        DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
    }

    // Dirty the right margin if needed.
    if (editWidth != oldWidth)
    {
        int rightMargin = (editWidth > oldWidth) ? editWidth - oldWidth : 0;

        InvalidateRightMargin(rightMargin);
    }


#ifdef DEBUG
    DEBUGDumpHdr(m_hwnd, m_cHCI, m_rgHCI);
#endif

}

void CNoteHdr::InvalidateRightMargin(int additionalWidth)
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    rc.left = rc.right - GetRightMargin(TRUE) - additionalWidth;

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}


HRESULT CNoteHdr::HrUpdateCachedHeight(HWND hwndEdit, RECT *prc)
{
    int         cyGrow,
                cLines = (int) SendMessage(hwndEdit, EM_GETLINECOUNT, 0, 0);
    BOOL        fIncludeEdges = WS_EX_CLIENTEDGE & GetWindowLong(hwndEdit, GWL_EXSTYLE);
    PHCI        phci = (HCI*)GetWindowLongPtr(hwndEdit, GWLP_USERDATA);

    if (prc->bottom < 0 || prc->top < 0)
        return S_FALSE;

    STACK("HrUpdateCachedHeight. Desired lines", cLines);

    // Only allow between 1 and MAX_RICHEDIT_LINES lines
    if (cLines < 1)
        cLines = 1;
    else if (cLines > MAX_RICHEDIT_LINES)
        cLines = MAX_RICHEDIT_LINES;

    DOUTL(RESIZING_DEBUG_LEVEL, "STATE Actual lines=%d", cLines);

    // Figure out how many pixels cLines lines is
    cyGrow = GetControlSize(fIncludeEdges, cLines);

    // If these are different, then change is needed
    if (cyGrow != GetCtrlHeight(hwndEdit))
        phci->height = cyGrow;
    else
        return S_FALSE;


    return S_OK;
}


void CNoteHdr::ShowControls()
{
    PHCI    phci = m_rgHCI;

    STACK("ShowControls");

    for (int i=0; i<(int)m_cHCI; i++, phci++)
    {
        HWND hwnd; 
        BOOL fHide;    

        fHide = (S_FALSE == HrFShowHeader(phci));

        hwnd = GetDlgItem(m_hwnd, phci->idEdit);
        if (hwnd)
            ShowWindow(hwnd, fHide?SW_HIDE:SW_SHOW);
    }
}

int CNoteHdr::GetRightMargin(BOOL fMax)
{
    int margin = ControlXBufferSize();

    if (fMax || m_fDigSigned || m_fEncrypted || m_fVCard)
        margin += margin + cxBtn;

    return margin;
}

// prc is in and out
DWORD CNoteHdr::GetButtonUnderMouse(int x, int y)
{
    int     resultButton = HDRCB_NO_BUTTON;
    PHCI    phci = m_rgHCI;

    // Is it in the labels?
    if ((x > int(ControlXBufferSize() - BUTTON_BUFFER)) && (x < int(m_cxLeftMargin - ControlXBufferSize() + BUTTON_BUFFER)))
    {
        for (int i=0; i<(int)m_cHCI; i++, phci++)
        {
            // Only check labels that have buttons that are showing
            if ((0 != (phci->dwFlags & HCF_HASBUTTON)) && (INVALID_PHCI_Y != phci->cy))
            {
                if (y < (phci->cy))
                    break;

                if (y < (phci->cy + 2*BUTTON_BUFFER + g_cyLabelHeight))
                {
                    resultButton = i;
                    break;
                }
            }
        }
    }
    else
    // Is one of the right side buttons?
    {
        int     width = GetCtrlWidth(m_hwnd),
                xBuffSize = ControlXBufferSize(),
                yBuffSize = ControlYBufferSize();

        // Are we in the correct x range?
        if ((x > (width - (xBuffSize + cxBtn + BUTTON_BUFFER))) && (x < width - xBuffSize + BUTTON_BUFFER))
        {
            BOOL    rgBtnStates[] = {BUTTON_STATES};
            BOOL    rgUseButton[] =  {BUTTON_USE_IN_COMPOSE};
            BOOL    fReadOnly = IsReadOnly();
            int     cy = BeginYPos();

            for (int i = 0; i < ARRAYSIZE(rgBtnStates); i++)
            {
                if (rgBtnStates[i])
                {
                    if (y < cy)
                        break;

                    if (y < (cy + cyBtn + 2*BUTTON_BUFFER))
                    {
                        if (fReadOnly || rgUseButton[i])
                            resultButton = g_rgBtnInd[i];
                        break;
                    }
                
                    cy += cyBtn + 2*BUTTON_BUFFER + yBuffSize;
                }
            }
        }
    }

    return resultButton;
}

void CNoteHdr::GetButtonRect(DWORD iBtn, RECT *prc)
{
    // Do we already have the rect?
    if (iBtn == m_dwCurrentBtn)
    {
        CopyRect(prc, &m_rcCurrentBtn);
        return;
    }

    // Buttons on the left hand side of the header
    if (ButtonInLabels(iBtn))
    {
        AssertSz(iBtn < m_cHCI, "We are about to access an invalid element...");
        int cyBegin = BeginYPos();

        prc->top = m_rgHCI[iBtn].cy;
        prc->bottom = m_rgHCI[iBtn].cy + g_cyLabelHeight + 2*BUTTON_BUFFER;
        prc->left = ControlXBufferSize() - BUTTON_BUFFER;
        prc->right = (m_cxLeftMargin - ControlXBufferSize()) + BUTTON_BUFFER;

        DOUTL(PAINTING_DEBUG_LEVEL, "STATE Set New Button Frame for button (btn:%d):(%d,%d) to (%d,%d)", 
                    iBtn, prc->left, prc->top, prc->right, prc->bottom);
    }
    // Buttons on the right hand side.
    else
    {
        RECT    rc;
        int     cx = GetCtrlWidth(m_hwnd) - (ControlXBufferSize() + cxBtn),
                cy = BeginYPos(),
                yBuffSize = cyBtn + ControlYBufferSize() + 2*BUTTON_BUFFER;

        BOOL rgBtnStates[] = {BUTTON_STATES};

        prc->left = cx - BUTTON_BUFFER;
        prc->right = cx + cxBtn + BUTTON_BUFFER;
        for (int i = 0; i < ARRAYSIZE(rgBtnStates); i++)
        {
            if (g_rgBtnInd[i] == iBtn)
            {
                prc->top = cy;
                prc->bottom = cy + cyBtn + 2*BUTTON_BUFFER;
                DOUTL(PAINTING_DEBUG_LEVEL, "STATE Set New Button Frame for button (btn:%d):(%d,%d) to (%d,%d)", 
                            iBtn, prc->left, prc->top, prc->right, prc->bottom);
                return;
            }
            else if (rgBtnStates[i])
                cy += yBuffSize;
        }
    }
}

int CNoteHdr::BeginYPos()
{
    int beginBuffer = m_dxTBOffset;
    int cLines = 0;

    if (m_fFlagged || (priLow == m_pri) || (priHigh == m_pri) || (MARK_MESSAGE_NORMALTHREAD != m_MarkType))
        cLines++;
    
    if (m_lpAttMan->GetUnsafeAttachCount())
        cLines++;

    if (cLines)
        beginBuffer += GetStatusHeight(cLines) + g_cyFont/2;

    return beginBuffer;
}

void CNoteHdr::HandleButtonClicks(int x, int y, int iBtn)
{
    m_dwCurrentBtn = HDRCB_NO_BUTTON;
    m_dwClickedBtn = HDRCB_NO_BUTTON;
    HeaderRelease(TRUE);                
    InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);
    
    if (HDRCB_NO_BUTTON == iBtn)
        return;
    
    switch (iBtn)
    {
    case HDRCB_VCARD:
        HrShowVCardCtxtMenu(x, y);
        break;
        
    case HDRCB_SIGNED:
    case HDRCB_ENCRYPT:
        {
            HrShowSecurityProperty(m_hwnd, m_pMsg);
            break;
        }
        
        // This is an index into the labels
    default:
        OnButtonClick(m_rgHCI[iBtn].idBtn);
        break;
    }
}

void CNoteHdr::InvalidateStatus()
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    rc.bottom = BeginYPos();

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}




HRESULT CNoteHdr::_CreateEnvToolbar()
{
    UINT            i;
    RECT            rc;
    TCHAR           szRes[CCHMAX_STRINGRES];
    REBARBANDINFO   rbbi;
    POINT           ptIdeal = {0};

    // ~~~~ Do we need to do a WrapW here????
    // create REBAR so we can show toolbar chevrons
    m_hwndRebar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                        0, 0, 100, 136, m_hwnd, NULL, g_hInst, NULL);

    if (!m_hwndRebar)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
    SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
    //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);
    SendMessage(m_hwndRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);

    // ~~~~ Do we need to do a WrapW here????
    m_hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|CCS_NOPARENTALIGN|CCS_NODIVIDER|
                        TBSTYLE_TOOLTIPS|TBSTYLE_FLAT|TBSTYLE_LIST,
                        0, 0, 0, 0, m_hwndRebar, NULL, 
                        g_hInst, NULL);

    if (!m_hwndToolbar)
        return E_OUTOFMEMORY;

    // set style on toolbar
    SendMessage(m_hwndToolbar, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS);

    SendMessage(m_hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndToolbar, TB_ADDBUTTONS, (WPARAM)ARRAYSIZE(c_btnsOfficeEnvelope), (LPARAM)c_btnsOfficeEnvelope);

    // set the normal imagelist, office toolbar has ONE only as it's always in Color
    m_himl = LoadMappedToolbarBitmap(g_hLocRes, (fIsWhistler() ? ((GetCurColorRes() > 24) ? idb32SmBrowserHot : idbSmBrowserHot): idbNWSmBrowserHot), cxTBButton);
    if (!m_himl)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);
    SendMessage(m_hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(cxTBButton, cxTBButton));

    // Add text to the Bcc btn. The Send btn is taken care of in the Init
    _SetButtonText(ID_ENV_BCC, MAKEINTRESOURCE(idsEnvBcc));

    GetClientRect(m_hwndToolbar, &rc);

    // get the IDEALSIZE of the toolbar
    SendMessage(m_hwndToolbar, TB_GETIDEALSIZE, FALSE, (LPARAM)&ptIdeal);

    // insert a band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_STYLE;
    rbbi.fStyle     = RBBS_USECHEVRON;
    rbbi.cx         = 0;
    rbbi.hwndChild  = m_hwndToolbar;
    rbbi.cxMinChild = 0;
    rbbi.cyMinChild = rc.bottom;
    rbbi.cxIdeal    = ptIdeal.x;

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);

    // set the toolbar offset
    m_dxTBOffset = rc.bottom;
    return S_OK;
}



HRESULT CNoteHdr::_LoadFromStream(IStream *pstm)
{
    HRESULT         hr;
    IMimeMessage    *pMsg;
    IStream         *pstmTmp,
                    *pstmMsg;
    PERSISTHEADER   rPersist;
    ULONG           cbRead;
    CLSID           clsid;

    if (pstm == NULL)
        return E_INVALIDARG;

    HrRewindStream(pstm);

    // make sure it's our GUID
    if (ReadClassStm(pstm, &clsid)!=S_OK ||
        !IsEqualCLSID(clsid, CLSID_OEEnvelope))
        return E_FAIL;

    // make sure the persistent header is the correct version
    hr = pstm->Read(&rPersist, sizeof(PERSISTHEADER), &cbRead);
    if (hr != S_OK || cbRead != sizeof(PERSISTHEADER) || rPersist.cbSize != sizeof(PERSISTHEADER))
        return E_FAIL;

    // read the message
    hr = HrCreateMessage(&pMsg);
    if (!FAILED(hr))
    {
        hr = MimeOleCreateVirtualStream(&pstmMsg);
        if (!FAILED(hr))
        {
            // MimeOle always rewinds the stream we give it, so we have to copy the 
            // message from our persistent stream into another stream
            hr = HrCopyStream(pstm, pstmMsg, NULL);
            if (!FAILED(hr))
            {
                hr = pMsg->Load(pstmMsg);
                if (!FAILED(hr))
                {
                    hr = Load(pMsg);
                    if (!FAILED(hr))
                    {
                        // BUG: as we use an empty message to persist data for office envelope and empty mime-body can be
                        // considers a text/plain body part. We need to make sure we mark this as RENDERED before loading
                        // any attachments
                        if (pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstmTmp, NULL)==S_OK)
                            pstmTmp->Release();

                        hr = OnDocumentReady(pMsg);
                    }
                }    
            }
            pstmMsg->Release();
        }
        pMsg->Release();
    }
    return hr;
}

HRESULT CNoteHdr::_SetButtonText(int idmCmd, LPSTR pszText)
{
    TBBUTTONINFO    tbi;
    TCHAR           szRes[CCHMAX_STRINGRES];

    ZeroMemory(&tbi, sizeof(TBBUTTONINFO));
    tbi.cbSize = sizeof(TBBUTTONINFO);
    tbi.dwMask = TBIF_TEXT | TBIF_STYLE;
    tbi.fsStyle = TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE;

    if (IS_INTRESOURCE(pszText))
        {
        // its a string resource id
        LoadString(g_hLocRes, PtrToUlong(pszText), szRes, sizeof(szRes));
        pszText = szRes;
        }

    tbi.pszText = pszText;
    tbi.cchText = lstrlen(pszText);
    SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, idmCmd, (LPARAM) &tbi);
    return S_OK;
}

HRESULT CNoteHdr::_ConvertOfficeCmdIDToOE(LPDWORD pdwCmdId)
{
    static const CMDMAPING   rgCmdMap[] = 
    {   {cmdidSend,             MSOEENVCMDID_SEND},
        {cmdidCheckNames,       MSOEENVCMDID_CHECKNAMES},
        {cmdidAttach,           MSOEENVCMDID_ATTACHFILE},
        {cmdidSelectNames,      MSOEENVCMDID_SELECTRECIPIENTS},
        {cmdidFocusTo,          MSOEENVCMDID_FOCUSTO},
        {cmdidFocusCc,          MSOEENVCMDID_FOCUSCC},
        {cmdidFocusSubject,     MSOEENVCMDID_FOCUSSUBJ}
    };

    for (int i=0; i<ARRAYSIZE(rgCmdMap); i++)
        if (rgCmdMap[i].cmdIdOffice == *pdwCmdId)
        {
            *pdwCmdId = rgCmdMap[i].cmdIdOE;
            return S_OK;
        }

        return E_FAIL;
}


HRESULT CNoteHdr::_UIActivate(BOOL fActive, HWND hwndFocus)
{
    m_fUIActive = fActive;
    if (fActive)
    {
        if (m_pHeaderSite)
            m_pHeaderSite->OnUIActivate();

        if (m_pMsoComponentMgr)
            m_pMsoComponentMgr->FOnComponentActivate(m_dwComponentMgrID);

        if (m_pEnvelopeSite)
        {
            m_pEnvelopeSite->OnEnvSetFocus();
            m_pEnvelopeSite->DirtyToolbars();
        }

    }
    else
    {
        // store focus if decativating
        m_hwndLastFocus = hwndFocus;
        if (m_pHeaderSite)
            m_pHeaderSite->OnUIDeactivate(FALSE);
    }
    return S_OK;
}



HWND CNoteHdr::_GetNextDlgTabItem(HWND hwndDlg, HWND hwndFocus, BOOL fShift)
{
    int     i,
            j,
            idFocus = GetDlgCtrlID(hwndFocus),
            iFocus;
    LONG    lStyle;
    HWND    hwnd;

    // find current pos
    for (i=0; i<ARRAYSIZE(rgIDTabOrderMailSend); i++)
    {
        if (rgIDTabOrderMailSend[i] == idFocus)
            break;
    }

    // i now points to the current control's index
    if (fShift)
    {
        // backwards
        for (j=i-1; j>=0; j--)
        {
            hwnd = GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            AssertSz(hwnd, "something broke");
            if (hwnd)
            {
                lStyle = GetWindowLong(hwnd, GWL_STYLE);
                if ((lStyle & WS_VISIBLE) &&
                    (lStyle & WS_TABSTOP) &&
                    !(lStyle & WS_DISABLED))
                    return GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            }
        }
    }
    else
    {
        // forwards tab
        for (j=i+1; j<ARRAYSIZE(rgIDTabOrderMailSend); j++)
        {
            hwnd = GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            AssertSz(hwnd, "something broke");
            if (hwnd)
            {
                lStyle = GetWindowLong(hwnd, GWL_STYLE);
                if ((lStyle & WS_VISIBLE) &&
                    (lStyle & WS_TABSTOP) &&
                    !(lStyle & WS_DISABLED))
                    return GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            }
        }
    }
    // not found
    return NULL;
}



HRESULT CNoteHdr::_ClearDirtyFlag()
{
    m_fDirty = FALSE;
    if (m_lpAttMan)
        m_lpAttMan->HrClearDirtyFlag();

    return S_OK;
}

HRESULT CNoteHdr::_RegisterAsDropTarget(BOOL fOn)
{
    HRESULT     hr=S_OK;

    if (fOn)
    {
        // already registered
        if (!m_fDropTargetRegister)
        {
            hr = CoLockObjectExternal((LPDROPTARGET)this, TRUE, FALSE);
            if (FAILED(hr))
                goto error;

            hr = RegisterDragDrop(m_hwnd, (LPDROPTARGET)this);
            if (FAILED(hr))
                goto error;

            m_fDropTargetRegister=TRUE;
        }
    }
    else
    {
        // nothing to do
        if (m_fDropTargetRegister)
        {
            RevokeDragDrop(m_hwnd);
            CoLockObjectExternal((LPUNKNOWN)(LPDROPTARGET)this, FALSE, TRUE);
            m_fDropTargetRegister = FALSE;    
        }
    }

error:
    return hr;
}


HRESULT CNoteHdr::_RegisterWithFontCache(BOOL fOn)
{
    Assert(g_pFieldSizeMgr);

    if (fOn)
    {
        if (0 == m_dwFontNotify)
            g_pFieldSizeMgr->Advise((IUnknown*)(IFontCacheNotify*)this, &m_dwFontNotify);
    }
    else
    {
        if (m_dwFontNotify)
        {
            g_pFieldSizeMgr->Unadvise(m_dwFontNotify);
            m_dwFontNotify = NULL;
        }
    }

    return S_OK;
}


HRESULT CNoteHdr::_RegisterWithComponentMgr(BOOL fOn)
{
    MSOCRINFO           crinfo;
    IServiceProvider    *pSP;

    if (fOn)
    {
        // not registered, so get a component msgr interface and register ourselves
        if (m_pMsoComponentMgr == NULL)
        {
            // negotiate an component msgr from the host
            if (m_pEnvelopeSite &&
                m_pEnvelopeSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
            {
                pSP->QueryService(IID_IMsoComponentManager, IID_IMsoComponentManager, (LPVOID *)&m_pMsoComponentMgr);
                pSP->Release();
            }

            // if not host-provided, try and obtain from LoadLibrary on office dll
            if (!m_pMsoComponentMgr &&
                FAILED(MsoFGetComponentManager(&m_pMsoComponentMgr)))
                return E_FAIL;
        
            Assert (m_pMsoComponentMgr);
            crinfo.cbSize = sizeof(MSOCRINFO);
            crinfo.uIdleTimeInterval = 3000;
            crinfo.grfcrf = msocrfPreTranslateAll;
            crinfo.grfcadvf = msocadvfRedrawOff;

            if (!m_pMsoComponentMgr->FRegisterComponent((IMsoComponent*) this, &crinfo, &m_dwComponentMgrID))
                return E_FAIL;
        }
    }
    else
    {
        if (m_pMsoComponentMgr)
        {
            m_pMsoComponentMgr->FRevokeComponent(m_dwComponentMgrID);
            m_pMsoComponentMgr->Release();
            m_pMsoComponentMgr = NULL;
            m_dwComponentMgrID = 0;
        }
    }

    return S_OK;
}

HRESULT ParseFollowup(LPMIMEMESSAGE pMsg, LPTSTR* ppszGroups, BOOL* pfPoster)
{
    LPTSTR      pszToken, pszTok;
    BOOL        fFirst = TRUE,
                fPoster = FALSE;
    int         cchFollowup;
    LPSTR       lpszFollowup=0;
    ADDRESSLIST addrList={0};
    HRESULT     hr = S_OK;

    *ppszGroups = NULL;

    if (!pMsg)
        return E_INVALIDARG;

    if (FAILED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, &lpszFollowup)))
        return E_FAIL;

    cchFollowup = lstrlen(lpszFollowup) + 1;
    if (!MemAlloc((LPVOID*) ppszGroups, sizeof(TCHAR) * cchFollowup))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    **ppszGroups = 0;
    
    // WARNING: we about to trash lpszFollowup with strtok...

    // Walk through the string parsing out the tokens
    pszTok = lpszFollowup;
    pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    while (NULL != pszToken)
    {
        // Want to add all items except Poster (c_szPosterKeyword)
        if (0 == lstrcmpi(pszToken, c_szPosterKeyword))
            fPoster = TRUE;
        else
        {
            if (!fFirst)
                lstrcat(*ppszGroups, g_szComma);
            else
                fFirst = FALSE;
            lstrcat(*ppszGroups, pszToken);
        }
        pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    }

    *pfPoster = fPoster;

exit:    
    SafeMimeOleFree(lpszFollowup);

    if (**ppszGroups == 0)
    {
        MemFree(*ppszGroups);
        *ppszGroups = NULL;
    }

    return hr;
}

//***************************************************
CFieldSizeMgr::CFieldSizeMgr(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    TraceCall("CFieldSizeMgr::CFieldSizeMgr");

    m_pAdviseRegistry = NULL;
    m_fFontsChanged = FALSE;
    m_dwFontNotify = 0;
    InitializeCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
CFieldSizeMgr::~CFieldSizeMgr()
{
    IConnectionPoint   *pCP = NULL;

    TraceCall("CFieldSizeMgr::~CFieldSizeMgr");

    EnterCriticalSection(&m_rAdviseCritSect);

    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();

    LeaveCriticalSection(&m_rAdviseCritSect);    

    if (g_lpIFontCache)
    {
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID*)&pCP)))
        {
            pCP->Unadvise(m_dwFontNotify);    
            pCP->Release();
        }
    }

    DeleteCriticalSection(&m_rAdviseCritSect);
}


//***************************************************
HRESULT CFieldSizeMgr::OnPreFontChange(void)
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    TraceCall("CFieldSizeMgr::OnPreFontChange");

    EnterCriticalSection(&m_rAdviseCritSect);
    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (SUCCEEDED(pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)))
        {
            pCurr->OnPreFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFieldSizeMgr::OnPostFontChange(void)
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    TraceCall("CFieldSizeMgr::OnPostFontChange");

    ResetGlobalSizes();

    EnterCriticalSection(&m_rAdviseCritSect);
    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (SUCCEEDED(pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)))
        {
            pCurr->OnPostFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFieldSizeMgr::GetConnectionInterface(IID *pIID)        
{
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    TraceCall("CFieldSizeMgr::Advise");

    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->AddItem(pUnkSink, pdwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFieldSizeMgr::Unadvise(DWORD dwCookie)
{
    TraceCall("CFieldSizeMgr::Unadvise");

    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->RemoveItem(dwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
int CFieldSizeMgr::GetScalingFactor(void)
{
    int iScaling = 100;
    UINT cp;

    cp = GetACP();
    if((932 == cp) || (936 == cp) || (950 == cp) || (949 == cp) || (((1255 == cp) || (1256 == cp)) && (VER_PLATFORM_WIN32_NT != g_OSInfo.dwPlatformId)))
        iScaling = 115;

    return iScaling;
}

//***************************************************
void CFieldSizeMgr::ResetGlobalSizes(void)
{
    HDC         hdc;
    HFONT       hfontOld,
                hfont;
    TEXTMETRIC  tm;

    int         oldcyFont = g_cyFont,
                oldLabelHeight = g_cyLabelHeight,
                cyScaledFont;

    TraceCall("CFieldSizeMgr::ResetGlobalSizes");

    // calc height of edit, based on font we're going to put in it...
    hdc=GetDC(NULL);
    hfont = GetFont(FALSE);
    hfontOld=(HFONT)SelectObject(hdc, hfont); // Hopefully charset fonts are about the same size ???!!!

    g_cfHeader.cbSize = sizeof(CHARFORMAT);
    FontToCharformat(hfont, &g_cfHeader);

    GetTextMetrics(hdc, &tm);

    DOUTL(16, "tmHeight=%d  tmAscent=%d  tmDescent=%d  tmInternalLeading=%d  tmExternalLeading=%d\n", 
            tm.tmHeight, tm.tmAscent, tm.tmDescent, tm.tmInternalLeading, tm.tmExternalLeading);

    SelectObject(hdc, hfontOld);

    cyScaledFont = (tm.tmHeight + tm.tmExternalLeading) * GetScalingFactor();
    if((cyScaledFont%100) >= 50) 
        cyScaledFont  += 100;
    g_cyFont = (cyScaledFont / 100);
    g_cyLabelHeight = (g_cyFont < cyBtn) ? cyBtn : g_cyFont;

    DOUTL(GEN_HEADER_DEBUG_LEVEL,"cyFont=%d", g_cyFont);
    ReleaseDC(NULL, hdc);

    m_fFontsChanged = ((oldcyFont != g_cyFont) || (oldLabelHeight != g_cyLabelHeight));
}

//***************************************************
HRESULT CFieldSizeMgr::Init(void)
{
    HRESULT hr = S_OK;
    IConnectionPoint   *pCP = NULL;

    TraceCall("CFieldSizeMgr::Init");

    ResetGlobalSizes();

    EnterCriticalSection(&m_rAdviseCritSect);

    IF_FAILEXIT(hr = IUnknownList_CreateInstance(&m_pAdviseRegistry));
    IF_FAILEXIT(hr = m_pAdviseRegistry->Init(NULL, 0, 0));

    // We don't want to fail if the font cache is not created. That just means
    // that the fonts won't be changed.
    if (g_lpIFontCache)
    {
        IF_FAILEXIT(hr = g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID*)&pCP));
        IF_FAILEXIT(hr = pCP->Advise((IUnknown*)(IFontCacheNotify*)this, &m_dwFontNotify));    
    }

exit:
    ReleaseObj(pCP);
    LeaveCriticalSection(&m_rAdviseCritSect);

    return hr;
}

//***************************************************
HRESULT CFieldSizeMgr::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CFieldSizeMgr::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify *)this;
    else if (IsEqualIID(riid, IID_IConnectionPoint))
        *lplpObj = (LPVOID)(IConnectionPoint *)this;
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\ibodyobj.h ===
#ifndef _IBODYOBJ_H
#define _IBODYOBJ_H

#include "statbar.h"
#include "mimeole.h"

#ifndef __IBodyObj_FWD_DEFINED__
#define __IBodyObj_FWD_DEFINED__
typedef interface IBodyObj IBodyObj;
#endif 	/* __IBodyObj_FWD_DEFINED__ */

// HrInit flags
enum
{
    IBOF_PRINT               =0x01,
    IBOF_USEMARKREAD         =0x02,       // if msg is UNREAD, activates mark as read rules
    IBOF_TABLINKS            =0x04,        
    IBOF_NOSCROLL            =0x08,
    IBOF_DISPLAYTO           =0x10
};

// HrLoad flags
enum
{
    BLF_PRESERVESERVICE     =0x01,      // uses ULA_PRESERVESERVICE
};

// HrUnloadAll flags
enum
{
    ULA_PRESERVESERVICE     =0x01,      // skips SetService(NULL)
};

// HrSave flags
enum
{
    BSF_HTML                =0x00000001,
    BSF_FIXUPURLS           =0x00000002
};


enum
{
    // Used with SMIME
    MEHC_BTN_OPEN = 0x00000001,     // This if from the error screen to the message
    MEHC_BTN_CERT,                  // This opens the cert
    MEHC_BTN_TRUST,                 // This opens the trusts
    MEHC_BTN_CONTINUE,              // Goes from opening screen to either error or main message

    // Used with HTML errors
    MEHC_CMD_CONNECT,               // Try to reconnect to the server
    MEHC_CMD_DOWNLOAD,              // Try to download message again

    // Used with Mark As Read
    MEHC_CMD_MARK_AS_READ,          // Should mark as read now if haven't done it

    MEHC_UIACTIVATE,                // Notifies the view we have the focus

    MEHC_CMD_PROCESS_RECEIPT,       // Tells the view to process for receipts

    MEHC_CMD_PROCESS_RECEIPT_IF_NOT_SIGNED, //Tells the view to process for reciepts if the msg is not signed
    
    MEHC_MAX
};

interface IMimeEditEventSink : public IUnknown 
{
    // Return S_OK if handled, Return S_FALSE if want MEHost to handle event
    virtual HRESULT STDMETHODCALLTYPE EventOccurred(DWORD cmdID, IMimeMessage *pMessage) PURE;
};



typedef  void (CALLBACK * PFNMARKASREAD)(DWORD);
typedef  HRESULT (CALLBACK * PFNNOSECUI)(DWORD);

interface IBodyOptions;

interface IBodyObj2 : public IUnknown
    {
    public:
        // Basic functions
        virtual HRESULT STDMETHODCALLTYPE HrUpdateFormatBar() PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrClearFormatting() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrClose() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrResetDocument() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetStatusBar(CStatusBar *pStatus) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUpdateToolbar(HWND hwndToolbar) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrShow(BOOL fVisible) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMCommand(HWND hwnd, int id, WORD wCmd) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrGetWindow(HWND *pHwnd) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetSize(LPRECT prc) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetDragSource(BOOL fIsSource) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrTranslateAccelerator(LPMSG lpMsg) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUIActivate(BOOL fActivate) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetUIActivate() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrFrameActivate(BOOL fActivate) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrHasFocus() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetBkGrndPicture(LPTSTR pszPicture) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount) PURE;
        virtual HRESULT STDMETHODCALLTYPE PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSaveAttachment() PURE;
        virtual HRESULT STDMETHODCALLTYPE SetEventSink(IMimeEditEventSink *pEventSink) PURE;
        virtual HRESULT STDMETHODCALLTYPE LoadHtmlErrorPage(LPCSTR pszURL) PURE;

        // MimeEdit Command Set functions
        virtual HRESULT STDMETHODCALLTYPE HrSpellCheck(BOOL fSuppressDoneMsg) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrIsDirty(BOOL *pfDirty) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetDirtyFlag(BOOL fDirty) PURE;                
        virtual HRESULT STDMETHODCALLTYPE HrIsEmpty(BOOL *pfEmpty) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetStyle(DWORD dwStyle) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrGetStyle(DWORD *pdwStyle) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrEnableHTMLMode(BOOL fOn) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrDowngradeToPlainText() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetText(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrPerformROT13Encoding() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInsertTextFile(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInsertTextFileFromDialog() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrViewSource(DWORD dwViewType) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetPreviewFormat(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetEditMode(BOOL fOn) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrIsEditMode(BOOL *pfOn) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetCharset(HCHARSET hCharset) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrGetCharset(HCHARSET *phCharset) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSaveAsStationery(LPWSTR pwszFile) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrApplyStationery(LPWSTR pwszFile) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrHandsOffStorage() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrRefresh() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrScrollPage() PURE;
        virtual HRESULT STDMETHODCALLTYPE UpdateBackAndStyleMenus(HMENU hmenu) PURE;
    };


#endif  //_IBODYOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\iheader.h ===
#ifndef __IHEADER_H__
#define __IHEADER_H__

#ifndef __IHeader_INTERFACE_DEFINED__
#define __IHeader_INTERFACE_DEFINED__
typedef interface IHeader IHeader;
#endif

#ifndef __IHeaderSite_INTERFACE_DEFINED__
#define __IHeaderSite_INTERFACE_DEFINED__
typedef interface IHeaderSite IHeaderSite;
#endif

typedef IHeader __RPC_FAR *LPHEADER;
typedef IHeaderSite __RPC_FAR *LPHEADERSITE;

EXTERN_C const IID IID_IHeader;
EXTERN_C const IID IID_IHeaderSite;

#define cchHeaderMax                256

enum
{
    priNone=-1,
    priLow=0,
    priNorm,
    priHigh
};


interface IHeader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRect(
            /* [in] */ LPRECT prc) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetRect(
            /* [in] */ LPRECT prc) PURE;

        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IHeaderSite* pHeaderSite,
            /* [in] */ HWND hwndParent) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetPriority(
            /* [in] */ UINT pri) PURE;

        virtual HRESULT STDMETHODCALLTYPE ShowAdvancedHeaders(
            /* [in] */ BOOL fOn) PURE;

        virtual HRESULT STDMETHODCALLTYPE FullHeadersShowing(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE ChangeLanguage(
            /* [in] */ LPMIMEMESSAGE pMsg) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetTitle(
            /* [in] */ LPWSTR lpszTitle,
            /* [in] */ ULONG cch) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetPriority(
            /* [in] */ UINT* ppri) PURE;

        virtual HRESULT STDMETHODCALLTYPE UpdateRecipientMenu(
            /* [in] */ HMENU hmenu) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetInitFocus(
            /* [in] */ BOOL fSubject) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetVCard(
            /* [in] */ BOOL fFresh) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsSecured(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsHeadSigned(void) PURE;
        virtual HRESULT STDMETHODCALLTYPE ForceEncryption(BOOL *fEncrypt, BOOL fSet) PURE;

        virtual HRESULT STDMETHODCALLTYPE AddRecipient(
            /* [in] */ int idOffset) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(
            /* [out] */ HWND *rgTSArray,
            /* [in, out] */ int *piArrayCount) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetFlagState(
            /* [in] */ MARK_TYPE markType) PURE;

        virtual HRESULT STDMETHODCALLTYPE WMCommand(HWND, int, WORD) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnDocumentReady(
            /* [in] */ LPMIMEMESSAGE pMsg) PURE;

        virtual HRESULT STDMETHODCALLTYPE DropFiles(HDROP hDrop, BOOL) PURE;

        virtual HRESULT STDMETHODCALLTYPE HrGetAttachCount(
            /* [out] */ ULONG *pcAttMan) PURE;

        virtual HRESULT STDMETHODCALLTYPE HrIsDragSource() PURE;

        virtual HRESULT STDMETHODCALLTYPE HrGetAccountInHeader(
            /* [out] */ IImnAccount **ppAcct) PURE;
    };

interface IHeaderSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resize(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE Update(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnUIActivate(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(
            /* [in] */ BOOL fUndoable) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsHTML(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetHTML(
           /* [in] */ BOOL fHTML) PURE;

        virtual HRESULT STDMETHODCALLTYPE SaveAttachment(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsModal() PURE;
        virtual HRESULT STDMETHODCALLTYPE CheckCharsetConflict() PURE;

        virtual HRESULT STDMETHODCALLTYPE ChangeCharset(HCHARSET hCharset) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(HCHARSET *phCharset) PURE;

#ifdef SMIME_V3
        virtual HRESULT STDMETHODCALLTYPE GetLabelFromNote(
            /*[out]*/  PSMIME_SECURITY_LABEL *plabel) PURE;
        virtual HRESULT STDMETHODCALLTYPE IsSecReceiptRequest(void) PURE;
        virtual HRESULT STDMETHODCALLTYPE IsForceEncryption(void) PURE;
#endif // SMIME_V3
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mailfldr.cpp ===
/*
 *	m a i l f l d r . c p p
 *	
 *	Purpose:
 *		
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */

#include "pch.hxx"
#include "resource.h"
#include "error.h"
#include <strconst.h>
#include "oeschema.h"
#include "demand.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mailfldr.h ===
/*
 *	m a i l f l d r . h
 *	
 *	Purpose:
 *		manages mail folder object, sync's access to store
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\imailcmn.h ===
// ------------------------------------------------------------------------------------
// IMAILCMN.H
// ------------------------------------------------------------------------------------
#ifndef __IMAILCMN_H
#define __IMAILCMN_H

// ------------------------------------------------------------------------------------
// INETMAILERROR
// ------------------------------------------------------------------------------------
typedef struct tagINETMAILERROR {
    DWORD               dwErrorNumber;                  // Error Number
    HRESULT             hrError;                        // HRESULT of error
    LPTSTR              pszServer;                      // Server
    LPTSTR              pszAccount;                     // Account
    LPTSTR              pszMessage;                     // Actual error message
    LPTSTR              pszUserName;                    // User Name
    LPTSTR              pszProtocol;                    // protocol smtp or pop3
    LPTSTR              pszDetails;                     // Details message
    DWORD               dwPort;                         // Port
    BOOL                fSecure;                        // Secure ssl conneciton
} INETMAILERROR, *LPINETMAILERROR;

// ------------------------------------------------------------------------------------
// InetMail Flags
// ------------------------------------------------------------------------------------
#define IM_SENDMAIL     FLAG01
#define IM_RECVMAIL     FLAG02
#define IM_BACKGROUND   FLAG03
#define IM_NOERRORS     FLAG04
#define IM_POP3NOSKIP   FLAG05

// ------------------------------------------------------------------------------------
// InetMail Delivery Notifications
// ------------------------------------------------------------------------------------
typedef enum tagDELIVERTY {
    DELIVERY_CONNECTING,
    DELIVERY_CHECKING,
    DELIVERY_SENDING,
    DELIVERY_RECEIVING,
    DELIVERY_COMPLETE,       // lParam == n new messages
    DELIVERY_FAILURE
} DELIVERY;

// ------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------
HRESULT InetMail_HrInit(VOID);
HRESULT InetMail_HrDeliverNow(HWND hwndView, LPTSTR pszAccount, DWORD dwFlags); // See flags above
HRESULT InetMail_HrFlushOutbox(VOID);
HRESULT InetMail_HrRegisterView(HWND hwndView, BOOL fRegister);
VOID    InetMail_RemoveNewMailNotify(VOID);
HRESULT InetMail_HrClose(VOID);
BOOL CALLBACK InetMailErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif // __IMAILCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mailopt.h ===
/*
 *	m a i l o p t . h
 *	
 *  Purpose: Contains defines and prototypes for the mail options prop sheet.
 */

#ifndef __MAILOPT_H
#define __MAILOPT_H

#include "optdlg.h"

#define IDC_SOUND_CHECK             1000
#define IDC_PREVIEW_CHECK           1001
#define IDC_AUTOCHECK_CHECK         1002
#define IDC_AUTOCHECK_EDIT          1003
#define IDC_EMPTY_CHECK             1004
#define IDC_AUTOCHECK_SPIN          1005
#define IDC_SAVE_CHECK              1006
#define IDC_CHECK3                  1008
#define IDC_INDENT_CHECK            1010
#define IDC_INDENT_COMBO            1011
#define IDC_MIME_RADIO              1013
#define IDC_UUENCODE_RADIO          1014
#define IDC_ENCODE_COMBO            1015
#define IDC_BREAK_CHECK             1016
#define IDC_BREAK_EDIT              1017
#define IDC_BREAK_SPIN              1018
#define IDC_NOSIG_RADIO             1020
#define IDC_TEXT_RADIO              1021
#define IDC_FILE_RADIO              1022
#define IDC_TEXT_EDIT               1023
#define IDC_FILE_EDIT               1024
#define IDC_BROWSE_BUTTON           1025
#define IDC_ADVANCED_BUTTON         1026
#define IDC_INCLUDE_CHECK           1027
#define IDC_AUTOSIGNATURE_CHECK     1029
#define IDC_MARKASREAD_EDIT         1030
#define IDC_MARKASREAD_SPIN         1031
#define IDC_MAILTIMEOUT_SLIDER      1033
#define IDC_MAILTIMEOUT_STATIC      1034
#define IDC_SENDIMMEDIATE_CHECK     1036
#define IDC_SIGREPLY_CHECK          1037
#define IDC_MAILWRAP_EDIT           1038
#define IDC_MAILWRAP_SPIN           1039
#define IDC_8BIT_HEADER             1040
#define IDC_MAILWRAP_TEXT1          1041
#define IDC_MAILWRAP_TEXT2          1042
#define idcStaticOrFwd              1047
#define idcStaticReplying           1048
#define IDC_AUTOWAB_CHECK           1049

#define IDC_SIGN_CHECK              1052
#define IDC_ENCRYPT_CHECK           1053
#define IDC_ADVSETTINGS_BUTTON      1054
#define IDC_CERT_COMBO              1055
#define IDC_INCLUDECERT_CHECK       1056
#define IDC_ENCRYPT_COMBO           1057

#define IDC_FONTSETTINGS            1060

#endif  // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\imsgsite.h ===
#ifndef __IMSGSITE_H__
#define __IMSGSITE_H__

interface IListSelector;
interface IHeaderSite;

// Message Flags
enum {
    OEMF_REPLIED            = 0x00000001, 
    OEMF_FORWARDED          = 0x00000002,
    OEMF_FLAGGED            = 0x00000004,
    OEMF_DISABLE_SECUI      = 0x00000008,
};

// Message Status Flags
enum {
    // Flags saying what functions are available 0x00000XXX
    OEMSF_CAN_DELETE        = 0x00000001,
    OEMSF_CAN_PREV          = 0x00000002,
    OEMSF_CAN_NEXT          = 0x00000004,
    OEMSF_CAN_COPY          = 0x00000008,
    OEMSF_CAN_MOVE          = 0x00000010,
    OEMSF_CAN_SAVE          = 0x00000020,
    OEMSF_CAN_MARK          = 0x00000040,

    // Flags from message and Folder   0x00XXX000
    OEMSF_SEC_UI_ENABLED    = 0x00001000,
    OEMSF_THREADING_ENABLED = 0x00002000,
    OEMSF_UNSENT            = 0x00004000,
    OEMSF_BASEISNEWS        = 0x00008000,
    OEMSF_RULESNOTENABLED   = 0x00010000,
    OEMSF_UNREAD            = 0x00020000,

    //Flags for return receipts
    OEMSF_MDN_REQUEST       = 0x00040000,
    OEMSF_SIGNED            = 0x00080000,

    // Origin flags    0xXX000000
    OEMSF_FROM_STORE        = 0x01000000,
    OEMSF_FROM_FAT          = 0x02000000,
    OEMSF_FROM_MSG          = 0x04000000,
    OEMSF_VIRGIN            = 0x08000000,
};

// Flags used when calling DoNextPrev
enum {
    // These flags will be ignored if doing previous
    OENF_UNREAD             = 0x00000001,      // get next unread
    OENF_THREAD             = 0x00000002,      // get next thread

    // Don't know if need these or want to use them. Keep them here for now.
    OENF_SKIPMAIL           = 0x00000004,      // skip over mail messages
    OENF_SKIPNEWS           = 0x00000008,      // skip over news messages
};

// Notifications used with Notify
enum {
    OEMSN_UPDATE_PREVIEW    = 0x00000001,
    OEMSN_TOGGLE_READRCPT_REQ,
    OEMSN_PROCESS_READRCPT_REQ,
    OEMSN_PROCESS_RCPT_IF_NOT_SIGNED,
};


// Flags used when saving message
enum {
    OESF_UNSENT             = 0x00000001,
    OESF_READ               = 0x00000002,
    OESF_SAVE_IN_ORIG_FOLDER= 0x00000004,
    OESF_FORCE_LOCAL_DRAFT  = 0x00000008,
};

// Flags when getting message
enum {
    OEGM_ORIGINAL           = 0x00000001,
    OEGM_AS_ATTACH          = 0x00000002,
};

// Message Site init type
enum {
    OEMSIT_MSG_TABLE = 1,
    OEMSIT_STORE,
    OEMSIT_FAT,
    OEMSIT_MSG,
    OEMSIT_VIRGIN,
};

typedef struct tagINIT_BY_STORE {
    MESSAGEID       msgID; 
} INIT_BY_STORE;

typedef struct tagINIT_BY_TABLE {
    IMessageTable  *pMsgTable; 
    IListSelector  *pListSelect;
    ROWINDEX        rowIndex; 
} INIT_BY_TABLE;

typedef struct tagINIT_MSGSITE_STRUCT {
    DWORD               dwInitType;
    FOLDERID            folderID;
    union
        {
        INIT_BY_TABLE   initTable;
        INIT_BY_STORE   initStore;
        LPWSTR          pwszFile;
        IMimeMessage   *pMsg;
        };
} INIT_MSGSITE_STRUCT, *LPINIT_MSGSITE_STRUCT;

interface IOEMsgSite : public IUnknown 
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Init(
            /* [in] */ INIT_MSGSITE_STRUCT *pInitStruct) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags(
            /* [out] */ DWORD *dwStatusFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetFolderID(
            /* [out] */ FOLDERID *folderID) PURE;

        virtual HRESULT STDMETHODCALLTYPE Delete(
            /* [in] */  DELETEMESSAGEFLAGS dwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE DoNextPrev(
            /* [in] */ BOOL fNext,
            /* [in] */ DWORD dwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE DoCopyMoveToFolder(
            /* [in] */ BOOL fCopy,
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ BOOL fUnSent) PURE;

        virtual HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IImnAccount *pAcct) PURE;

        virtual HRESULT STDMETHODCALLTYPE SendToOutbox(
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ BOOL fSendImmediate
#ifdef SMIME_V3
            , /* [in] */ IHeaderSite *pHeaderSite
#endif // SMIME_V3
            ) PURE;

        virtual HRESULT STDMETHODCALLTYPE MarkMessage(
            /* [in] */ MARK_TYPE dwType,
            /* [in] */ APPLYCHILDRENTYPE dwApplyType) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetMessageFlags(
            /* [out] */ MESSAGEFLAGS *pdwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount(
            /* [in] */  ACCTTYPE acctType,
            /* [out] */ IImnAccount **ppAcct) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetMessage(
            /* [out] */ IMimeMessage **ppMsg,
            /* [out] */ BOOL *fJustHeader,
            /* [in] */  DWORD dwMessageFlags,
            /* [out] */ HRESULT *phr) PURE;

        virtual HRESULT STDMETHODCALLTYPE Close(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetStoreCallback(
            /* [in] */ IStoreCallback *pStoreCB) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetLocation(
            /* [out] */ LPWSTR rgwchLocation) PURE;

        virtual HRESULT STDMETHODCALLTYPE SwitchLanguage(
            /* [in] */ HCHARSET hOldCharset,
            /* [in] */ HCHARSET hNewCharset) PURE;

        // ptyNewOp will be either SOT_INVALID or 
        // the new final state for the OnComplete in the note
        virtual HRESULT STDMETHODCALLTYPE OnComplete(
            /* [in] */ STOREOPERATIONTYPE tyOperation, 
            /* [in] */ HRESULT hrComplete,
            /* [out] */ STOREOPERATIONTYPE *ptyNewOp) PURE;

        virtual HRESULT STDMETHODCALLTYPE UpdateCallbackInfo(
            /* [in] */ LPSTOREOPERATIONINFO pOpInfo) PURE;

        virtual HRESULT STDMETHODCALLTYPE Notify(
            /* [in] */ DWORD dwNotifyID) PURE;

};

enum {
    OENA_READ = 0, 
    OENA_COMPOSE,

    OENA_REPLYTOAUTHOR, 
    OENA_REPLYTONEWSGROUP, 
    OENA_REPLYALL, 

    OENA_FORWARD, 
    OENA_FORWARDBYATTACH, 

    OENA_WEBPAGE,
    OENA_STATIONERY,
    OENA_MAX,
};

// Note Creation Flags
enum{
    // Used to say creating a news note. Will now be used to 
    // say what is the default set of wells to create in header.
    // This will also be used to say that this is a newsnote for now
    OENCF_NEWSFIRST             = 0x00000001,
    OENCF_NEWSONLY              = 0x00000002,
    OENCF_SENDIMMEDIATE         = 0x00000004,
    OENCF_NOSTATIONERY          = 0x00000008,
    OENCF_NOSIGNATURE           = 0x00000010,
    OENCF_MODAL                 = 0x00000020,
    OENCF_USESTATIONERYFONT     = 0x00000040,
};

interface IOENote : public IUnknown {
    // Init will automatically load message from pMsgSite
    STDMETHOD(Init) (DWORD dwAction, DWORD dwCreateFlags, RECT *prc, HWND hwnd, 
                     INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite,
                     IUnknown *punkPump) PURE;
    STDMETHOD(Show) (void) PURE;
    virtual HRESULT(ToggleToolbar) (void) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mailutil.h ===
// ----------------------------------------------------------------------------------------------------------
// M A I L U T I L . H
// ----------------------------------------------------------------------------------------------------------
#ifndef __MAILUTIL_H
#define __MAILUTIL_H

// ----------------------------------------------------------------------------------------------------------
// Depend On
// ----------------------------------------------------------------------------------------------------------
//#include "gennote.h"

// ----------------------------------------------------------------------------------------------------------
// To create a folder
// ----------------------------------------------------------------------------------------------------------
void MailUtil_DoFolderDialog(HWND hwndParent, FOLDERID idFolder);

#define RenameFolderDlg(_hwnd, _idFolder)  MailUtil_DoFolderDialog(_hwnd, _idFolder);

HRESULT MailUtil_OnImportExportAddressBook(HWND hwnd, BOOL fImport);

HRESULT HrSendWebPage(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump);
HRESULT HrSendWebPageDirect(LPWSTR pwszURL, HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, 
                            BOOL fIncludeSig, IUnknown *pUnkPump, IMimeMessage  *pMsg);

HRESULT HrSaveMessageInFolder(HWND hwnd, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges);
HRESULT HrSaveMessageInFolder(HWND hwnd, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid);
HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges);
HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid);

HRESULT HrSendMailToOutBox(HWND hwndOwner, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail = TRUE);
HRESULT SendMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail);

HRESULT HrSetSenderInfoUtil(IMimeMessage *pMsg, IImnAccount *pAccount, LPWABAL lpWabal, BOOL fMail, CODEPAGEID cpID, BOOL fCheckConflictOnly);

HRESULT HrCreateReferences(LPWSTR pszOrigRefs, LPWSTR pszNewRef, LPWSTR *ppszRefs);

#endif // __MAILUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mailutil.cpp ===
// ----------------------------------------------------------------------------------------------------------
// M A I L U T I L . C P P
// ----------------------------------------------------------------------------------------------------------
#include "pch.hxx"
#include "demand.h"
#include "resource.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "strconst.h"
#include "url.h"
#include "mailutil.h"
#include <spoolapi.h>
#include <fonts.h>
#include "instance.h"
#include "pop3task.h"
#include <ntverp.h>
#include "msgfldr.h"
#include "storutil.h"
#include "note.h"
#include "shlwapip.h"
#include <iert.h>
#include "storecb.h"
#include "conman.h"
#include "multiusr.h"
#include "ipab.h"
#include "secutil.h"

// ----------------------------------------------------------------------------------------------------------
// Folder Dialog Info
// ----------------------------------------------------------------------------------------------------------
typedef struct FLDRDLG_tag
{
    FOLDERID        idFolder;
    BOOL            fPending;
    CStoreDlgCB    *pCallback;
} FLDRDLG, *PFLDRDLG;

// ----------------------------------------------------------------------------------------------------------
// Prototypes
// ----------------------------------------------------------------------------------------------------------
INT_PTR CALLBACK MailUtil_FldrDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WebPageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT HrDlgCreateWebPage(HWND hwndDlg);


// ----------------------------------------------------------------------------------------------------------
// DoFolderDialog
// ----------------------------------------------------------------------------------------------------------
void MailUtil_DoFolderDialog(HWND hwndParent, FOLDERID idFolder)
{
    FLDRDLG fdlg;

    fdlg.idFolder = idFolder;
    fdlg.fPending = FALSE;
    fdlg.pCallback = new CStoreDlgCB;
    if (fdlg.pCallback == NULL)
        // TODO: an error message might be nice
        return;

    DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddNewFolder), hwndParent, MailUtil_FldrDlgProc, (LPARAM)&fdlg);

    fdlg.pCallback->Release();
}

// ----------------------------------------------------------------------------------------------------------
// FldrDlgProc
// ----------------------------------------------------------------------------------------------------------
INT_PTR CALLBACK MailUtil_FldrDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PFLDRDLG        pfdlg;
    TCHAR           sz[CCHMAX_STRINGRES];
    HWND            hwndT;
    HRESULT         hr;
    WORD            id;
    FOLDERINFO      Folder;

    Assert(CCHMAX_STRINGRES > CCHMAX_FOLDER_NAME);

    switch(msg)
        {
        case WM_INITDIALOG:
            pfdlg = (PFLDRDLG)lParam;
            Assert(pfdlg != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pfdlg);

            hwndT = GetDlgItem(hwnd, idtxtFolderName);
            Assert(hwndT != NULL);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_FOLDER_NAME, 0);

            LoadString(g_hLocRes, idsRenameFolderTitle, sz, ARRAYSIZE(sz));
            SetWindowText(hwnd, sz);

            hr = g_pStore->GetFolderInfo(pfdlg->idFolder, &Folder);
            if (!FAILED(hr))
                {
                SetWindowText(hwndT, Folder.pszName);
                g_pStore->FreeRecord(&Folder);
                }

            pfdlg->pCallback->Initialize(hwnd);

            SendMessage(hwndT, EM_SETSEL, 0, -1);

            CenterDialog(hwnd);
            return(TRUE);

        case WM_STORE_COMPLETE:
            pfdlg = (PFLDRDLG)GetDlgThisPtr(hwnd);

            Assert(pfdlg->fPending);
            pfdlg->fPending = FALSE;

            hr = pfdlg->pCallback->GetResult();
            if (hr == S_FALSE)
            {
                EndDialog(hwnd, IDCANCEL);
            }
            else if (FAILED(hr))
            {
                // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete

                /*
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                    MAKEINTRESOURCEW(idsErrRenameFld), hr);
                */
                hwndT = GetDlgItem(hwnd, idtxtFolderName);
                SendMessage(hwndT, EM_SETSEL, 0, -1);
                SetFocus(hwndT);
            }
            else
            {
                EndDialog(hwnd, IDOK);
            }
            break;

        case WM_COMMAND:
            pfdlg = (PFLDRDLG)GetDlgThisPtr(hwnd);

            id=GET_WM_COMMAND_ID(wParam, lParam);

            if (id == IDOK)
            {
                if (pfdlg->fPending)
                    break;

                pfdlg->pCallback->Reset();

                hwndT = GetDlgItem(hwnd, idtxtFolderName);
                GetWindowText(hwndT, sz, ARRAYSIZE(sz));

                hr = g_pStore->RenameFolder(pfdlg->idFolder, sz, NOFLAGS, (IStoreCallback *)pfdlg->pCallback);
                if (hr == E_PENDING)
                {
                    pfdlg->fPending = TRUE;
                }
                else if (FAILED(hr))
                {
                    AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsErrRenameFld), hr);
                    SendMessage(hwndT, EM_SETSEL, 0, -1);
                    SetFocus(hwndT);
                }
                else
                {
                    EndDialog(hwnd, IDOK);
                }
            }
            else if (id==IDCANCEL)
            {
                if (pfdlg->fPending)
                    pfdlg->pCallback->Cancel();
                else
                    EndDialog(hwnd, IDCANCEL);
            }
            break;
        }
    return FALSE;
}

//
//  FUNCTION:   MailUtil_OnImportAddressBook()
//
//  PURPOSE:    Calls the WAB migration code to handle import/export.
//
//  PARAMETERS:
//      <in> fImport - TRUE if we should import, FALSE to export.
//
HRESULT MailUtil_OnImportExportAddressBook(HWND hwnd, BOOL fImport)
{
    OFSTRUCT of;
    HFILE hfile;
    TCHAR szParam[255];  
    LPTSTR lpParam = fImport ? _T("/import") : _T("/export");

    lstrcpy(szParam, lpParam);
    //MU_GetCurrentUserInfo(szParam+13, ARRAYSIZE(szParam) - 13, NULL, 0);

    hfile = OpenFile((TCHAR *)c_szWabMigExe, &of, OF_EXIST);
    if (hfile == HFILE_ERROR)
        return(E_FAIL);


    ShellExecute(hwnd, _T("Open"), of.szPathName, szParam, NULL, SW_SHOWNORMAL);

    return(S_OK);
}

HRESULT HrSendWebPageDirect(LPWSTR pwszUrl, HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, 
                            BOOL fIncludeSig, IUnknown *pUnkPump, IMimeMessage  *pMsg)
{
    HRESULT                 hr;
    LPSTREAM                pstm=NULL;
    HCURSOR                 hcur=0;
    INIT_MSGSITE_STRUCT     initStruct;
    DWORD                   dwCreateFlags = OENCF_SENDIMMEDIATE|OENCF_USESTATIONERYFONT;
    HCHARSET                hCharset;
    ENCODINGTYPE            ietEncoding = IET_DECODED;
    BOOL                    fLittleEndian;
    LPSTR                   pszCharset = NULL;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!pMsg)
    {
        //We were not passed pMessage, so we need to create one.
        IF_FAILEXIT(hr = HrCreateMessage(&pMsg));
    }
    else
    {
        pMsg->AddRef();
    }

    IF_FAILEXIT(hr = HrCreateBasedWebPage(pwszUrl, &pstm));

    if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
    {
        if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_UNICODE;
    }
    else if((S_OK == GetHtmlCharset(pstm, &pszCharset)) && pszCharset)
    {
        if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_INETCSET;
    }

    IF_FAILEXIT(hr = pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL));

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = folderID;

    if (!fIncludeSig)
        dwCreateFlags |= OENCF_NOSIGNATURE;

    if (fModal)
        dwCreateFlags |= OENCF_MODAL;

    if (!fMail)
        dwCreateFlags |= OENCF_NEWSFIRST;

    IF_FAILEXIT(hr = CreateAndShowNote(OENA_STATIONERY, dwCreateFlags, &initStruct, hwnd, pUnkPump));

exit:
    if (hcur)
        SetCursor(hcur);

    ReleaseObj(pMsg);
    ReleaseObj(pstm);
    return hr;
}

HRESULT HrSendWebPage(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump)
{
    HRESULT                 hr;
    LPMIMEMESSAGE           pMsg=0;
    LPSTREAM                pstm=0;
    INIT_MSGSITE_STRUCT     initStruct;
    DWORD                   dwCreateFlags = OENCF_SENDIMMEDIATE;
    LPSTR                   pszCharset;
    HCHARSET                hCharset;
    BOOL                    fLittleEndian;
    ENCODINGTYPE            ietEncoding=IET_INETCSET;

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddWebPage), hwnd, WebPageDlgProc, (LPARAM)&pstm)==IDCANCEL)
        return NOERROR;

    hr=HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    // [SBAILEY]: Raid 23209: OE: File/Send Web Page sends all pages as Latin-1 even if they aren't
    if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
    {
        if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_UNICODE;
    }

    else if (SUCCEEDED(GetHtmlCharset(pstm, &pszCharset)))
    {
        if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        MemFree(pszCharset);
    }

    hr=pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL);
    if (FAILED(hr))
        goto error;

    if (fModal)
        dwCreateFlags |= OENCF_MODAL;

    if (!fMail)
        dwCreateFlags |= OENCF_NEWSFIRST;

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = folderID;

    hr = CreateAndShowNote(OENA_WEBPAGE, dwCreateFlags, &initStruct, hwnd, pUnkPump);

error:
    ReleaseObj(pMsg);
    ReleaseObj(pstm);
    return hr;
}

static const HELPMAP g_rgCtxMapWebPage[] = {
    {idTxtWebPage, 50210},
    {0, 0}
};

INT_PTR CALLBACK WebPageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            int     iTxtLength;
            HWND    hwndEdit = GetDlgItem(hwnd, idTxtWebPage);

            Assert(hwndEdit);
            Assert(lParam!= NULL);

            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)lParam);
            SendDlgItemMessage(hwnd, idTxtWebPage, EM_LIMITTEXT, MAX_PATH-1, NULL);

            SetFocus(hwndEdit);
            SHAutoComplete(hwndEdit, SHACF_URLALL); 
            CenterDialog(hwnd);
            return FALSE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxMapWebPage);

        case WM_COMMAND:
        {
            int     id = GET_WM_COMMAND_ID(wParam, lParam);
            HWND    hwndEdit = GetDlgItem(hwnd, idTxtWebPage);

            switch(id)
            {
                case IDOK:
                    if (FAILED(HrDlgCreateWebPage(hwnd)))
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                            MAKEINTRESOURCEW(idsErrSendWebPageUrl), NULL, MB_OK);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);
                        SetFocus(hwndEdit);
                        return 0;
                    }

                    // fall thro'
                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
        }
    }
    return FALSE;
}

static const CHAR  c_wszHTTP[]  = "http://";
HRESULT HrDlgCreateWebPage(HWND hwndDlg)
{
    WCHAR               wszUrl[MAX_PATH+1],
                        wszUrlCanon[MAX_PATH + 10 + 1];
    DWORD               cCanon = ARRAYSIZE(wszUrlCanon);
    LPSTREAM           *ppstm = NULL;
    HRESULT             hr = E_FAIL;
    HCURSOR             hcur=0;

    *wszUrlCanon = 0;

    ppstm = (LPSTREAM *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    if(!GetWindowTextWrapW(GetDlgItem(hwndDlg, idTxtWebPage), wszUrl, ARRAYSIZE(wszUrl)))
        goto exit;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    IF_FAILEXIT(hr = UrlApplySchemeW(wszUrl, wszUrlCanon, &cCanon, URL_APPLY_DEFAULT|URL_APPLY_GUESSSCHEME|URL_APPLY_GUESSFILE));

    // If UrlApplyScheme returns S_FALSE, then it thought that the original works just fine, so use original
    IF_FAILEXIT(hr = HrCreateBasedWebPage((S_FALSE == hr) ? wszUrl : wszUrlCanon, ppstm));

exit:
    if (hcur)
        SetCursor(hcur);
    return hr;
}

HRESULT HrSaveMessageInFolder(HWND hwnd, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, 
    MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pfldr != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSavingToFolder), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = SaveMessageInFolder((IStoreCallback *)pCB, pfldr, pMsg, dwFlags, pNewMsgid, fSaveChanges);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, IMessageFolder *pfldr, 
    LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    MESSAGEID           msgid;

    // Trace
    TraceCall("HrSaveMessageInFolder");

    // Invalid Args
    if (pMsg == NULL || pfldr == NULL)
        return TraceResult(E_INVALIDARG);

    // Don't save changes, then clear the dirty bit
    if (FALSE == fSaveChanges) 
        MimeOleClearDirtyTree(pMsg);

    // Save the message
    IF_FAILEXIT(hr = pMsg->Commit(0));

    // Insert the Message
    hr = pfldr->SaveMessage(pNewMsgid, SAVE_MESSAGE_GENID, dwFlags, 0, pMsg, pStoreCB);

exit:
    // Done
    return (hr == S_OK ? hrWarnings : hr);
}

HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, FOLDERID idFolder, LPMIMEMESSAGE pMsg, 
    MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid)
{
    // Locals
    HRESULT         hr;

    IMessageFolder *pfldr=NULL;

    // Open the Folder..
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pfldr);
    if (SUCCEEDED(hr))
    {
        hr = SaveMessageInFolder(pStoreCB, pfldr, pMsg, dwFlags, pNewMsgid, TRUE);
        pfldr->Release();
    }

    return hr;
}

HRESULT HrSaveMessageInFolder(HWND hwnd, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, 
    MESSAGEID *pNewMsgid)
{
    // Locals
    HRESULT         hr;

    IMessageFolder *pfldr=NULL;

    // Open the Folder..
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pfldr);
    if (SUCCEEDED(hr))
    {
        hr = HrSaveMessageInFolder(hwnd, pfldr, pMsg, dwFlags, pNewMsgid, TRUE);
        pfldr->Release();
    }

    return hr;
}

HRESULT HrSendMailToOutBox(HWND hwndOwner, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwndOwner, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = SendMailToOutBox((IStoreCallback *)pCB, pMsg, fSendImmediate, fNoUI, fMail);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SendMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail)
{
    HRESULT     hr;
    FOLDERINFO  Outbox;
    const TCHAR c_szXMailerAndNewsReader[] = "Microsoft Outlook Express " VER_PRODUCTVERSION_STR;
    DWORD       dwSendFlags = fMail ? ARF_SUBMITTED|ARF_UNSENT : ARF_SUBMITTED|ARF_UNSENT|ARF_NEWSMSG;
    HWND        hwnd = 0;
    BOOL        fSecure = IsSecure(pMsg);

    Assert(pStoreCB);
    pStoreCB->GetParentWindow(0, &hwnd);

    hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_OUTBOX, &Outbox);
    if (FAILED(hr))
        return hr;

    // make sure we never send mail with the X-Unsent header on it.
    pMsg->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

    if (fMail)
    {
        // pound the X-Mailer prop always for anyone going' thro' our spooler.
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XMAILER), NOFLAGS, c_szXMailerAndNewsReader);
    }
    else
    {
        DWORD dwLines;
        TCHAR rgch[12];
        HrComputeLineCount(pMsg, &dwLines);
        wsprintf(rgch, "%d", dwLines);
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_LINES), NOFLAGS, rgch);
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XNEWSRDR), NOFLAGS, c_szXMailerAndNewsReader);
    }

    hr = SaveMessageInFolder(pStoreCB, Outbox.idFolder, pMsg, dwSendFlags, NULL);
    if (FAILED(hr))
        goto error;

    // if immediate send is required, tell the spooler to pick up next cycle
    // or start a cycle...
    if (fSendImmediate)
    {
        Assert(g_pSpooler);
        if (fMail)
            g_pSpooler->StartDelivery(hwnd, NULL, FOLDERID_INVALID,
                DELIVER_BACKGROUND | DELIVER_QUEUE | DELIVER_MAIL_SEND | DELIVER_NOSKIP);
        else
        {
            PROPVARIANT         var;

            var.vt = VT_LPSTR;
            hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
            if (FAILED(hr))
                var.pszVal = NULL;

            if (S_OK == g_pConMan->CanConnect(var.pszVal))
                g_pSpooler->StartDelivery(hwnd, var.pszVal, FOLDERID_INVALID,
                    DELIVER_BACKGROUND | DELIVER_NOSKIP | DELIVER_NEWS_SEND);
            else
            {
                // Warn the user that this message is going to live in their
                // outbox for all of eternity
                DoDontShowMeAgainDlg(hwnd, c_szDSPostInOutbox, 
                            MAKEINTRESOURCE(idsPostNewsMsg), 
                            MAKEINTRESOURCE(idsPostInOutbox), 
                            MB_OK);
                hr = S_FALSE;
            }
            SafeMemFree(var.pszVal);
        }
    }
    else if (!fNoUI)
    {
        HWND hwnd = 0;
        pStoreCB->GetParentWindow(0, &hwnd);

        AssertSz(hwnd, "How did we not get an hwnd???");

        // warn the user, before we close if it will be stacked in the outbox.
        DoDontShowMeAgainDlg(hwnd, fMail?c_szDSSendMail:c_szDSSendNews, 
                    MAKEINTRESOURCE(fMail?idsSendMail:idsPostNews), 
                    MAKEINTRESOURCE(fMail?idsMailInOutbox:idsPostInOutbox), 
                    MB_OK);
    }

error:
    // Cleanup
    g_pStore->FreeRecord(&Outbox);
    return hr;
}

HRESULT HrSetSenderInfoUtil(IMimeMessage *pMsg, IImnAccount *pAccount, LPWABAL lpWabal, BOOL fMail, CODEPAGEID cpID, BOOL fCheckConflictOnly)
{
    HRESULT hr = S_OK;

    // Don't set any info if no account.
    if (pAccount)
    {
        char    szEMail[CCHMAX_EMAIL_ADDRESS] = "";
        char    szName[CCHMAX_DISPLAY_NAME] = "";
        char    szOrg[CCHMAX_ORG_NAME] = "";
        BOOL    fUseEmailAsName = FALSE;
        DWORD   propID;

        if (fCheckConflictOnly)
        {
            hr = S_OK;
            propID = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szName, ARRAYSIZE(szName))) && *szName)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCPA(szName, CP_ACP, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }

            propID = fMail ? AP_SMTP_ORG_NAME : AP_NNTP_ORG_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szOrg, ARRAYSIZE(szOrg))) && *szOrg)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCPA(szOrg, CP_ACP, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }
        else
        {
            hr = hrNoSender;
            lpWabal->DeleteRecipType(MAPI_REPLYTO);

            propID = fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szEMail, ARRAYSIZE(szEMail))) && *szEMail)
            {
                propID = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;
                // we've got enough to post
                if (FAILED(pAccount->GetPropSz(propID, szName, ARRAYSIZE(szName))) && *szName)
                    fUseEmailAsName = TRUE;

                IF_FAILEXIT(hr = lpWabal->HrAddEntryA(fUseEmailAsName?szEMail:szName, szEMail, MAPI_ORIG));
            }

            propID = fMail ? AP_SMTP_REPLY_EMAIL_ADDRESS : AP_NNTP_REPLY_EMAIL_ADDRESS;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szEMail, ARRAYSIZE(szEMail))) && *szEMail)
                IF_FAILEXIT(hr = lpWabal->HrAddEntryA((*szName)?szName:szEMail, szEMail, MAPI_REPLYTO));

            propID = fMail ? AP_SMTP_ORG_NAME : AP_NNTP_ORG_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szOrg, ARRAYSIZE(szOrg))) && *szOrg)
            {
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, szOrg);
            }
        }
    }

exit:
    return hr;
}

// This function takes an existing refererences line and appends a new
// references to the end removing any references necessary.
// NOTE these SHOULD be char and not TCHAR.
HRESULT HrCreateReferences(LPWSTR pszOrigRefs, LPWSTR pszNewRef,
                           LPWSTR *ppszRefs)
{
    UINT     cch,
             cchOrig,
             cchNew;

    // Validate the arguements
    if (!pszNewRef || !*pszNewRef)
    {
        AssertSz(FALSE, TEXT("pszNewRef cannot be empty."));
        return (E_INVALIDARG);
    }

    // Figure out how long the new references line must be
    cchNew = lstrlenW(pszNewRef);

    // It's possible not to have original references if this is the first
    // reply to an article.
    if (pszOrigRefs && *pszOrigRefs)
        cchOrig = lstrlenW(pszOrigRefs);
    else
        cchOrig = 0;

    cch = cchNew + cchOrig + 1; // extra is for the separator space

    if (!MemAlloc((LPVOID*) ppszRefs, (cch + 1)*sizeof(WCHAR)))
        return (E_OUTOFMEMORY);

    // The line length should be < 1000 chars. If it is, this is simple
    if (cch <= 1000)
    {
        if (pszOrigRefs)
            AthwsprintfW(*ppszRefs, cch+1, L"%s %s", pszOrigRefs, pszNewRef);
        else
            StrCpyW(*ppszRefs, pszNewRef);
    }

    // Since cch > 1000, we have some extra work to do.
    // We need to remove some references. The Son-of-1036 recommends to leave
    // the first and last three. Unless the IDs are greater than 255, we will 
    // be able to do at least this. Otherwise, we will dump as many ids as 
    // needed to get below the 1000 char limit. 

    // For each ID removed, the Son-of-1036 says that we must add 3 spaces in
    // place of the removed ID.
    else
    {
        UINT    cchMaxWithoutNewRef,        // Max length that the orig size can be
                cchNewOrigSize = cchOrig;   // Size of orig after deletion. Always shows final size
        LPWSTR  pszNew = *ppszRefs, 
                pszOld = pszOrigRefs;
        BOOL    fCopiedFirstValidID = FALSE;

        *pszNew = 0;

        // Make sure the new ID is not too long. If it is, discard it.
        if (cchNew > 255)
        {
            cchNew = 0;
            cchMaxWithoutNewRef = 1000;
        }
        else
            cchMaxWithoutNewRef = 1000 - cchNew - 1; // the space between

        // parse the old string looking for ids
        // Son-of-1036 says that we must try to keep the first and the most recent
        // three IDs. So we will copy in the first valid ID and then follow a FIFO
        // algorithm until we can fit the rest of the IDs into the 1000 char limit
        while (pszOld && *pszOld)
        {
            // Is what is left from the original string too big for the left over buffer?
            if (cchNewOrigSize >= cchMaxWithoutNewRef)
            {
                UINT    cchEntryLen = 0;    // Size of particular entry ID.

                // If this is the first ID, make sure we copy into the buffer as we 
                // get length, as well, add the additional spaces required when any 
                // deletion will be happening. Since we only delete directly after 
                // the first valid ID, add the required 3 spaces now
                if (!fCopiedFirstValidID)
                {
                    while (*pszOld && *pszOld != L' ')
                    {
                        *pszNew++ = *pszOld++;
                        cchEntryLen++;
                    }
                    *pszNew++ = L' ';
                    *pszNew++ = L' ';
                    *pszNew++ = L' ';
                    cchNewOrigSize += 3;
                    cchEntryLen += 3;
                }
                // If this in not the first ID, then just skip over it.
                else
                {
                    while (*pszOld && *pszOld != L' ')
                    {
                        pszOld++;
                        cchEntryLen++;
                    }
                }

                // Skip over whitespace in old references between IDs that
                // we are deleting anyway.
                while (*pszOld == L' ')
                {
                    pszOld++;
                    cchNewOrigSize--;
                }

                // If we already did the first, or the current one is invalid
                // we need to do some fix up with sizes. And in the case that
                // we copied one that is not valid, we need to reset the pointer
                // as well as reset the size.
                if (fCopiedFirstValidID || (cchEntryLen > 255))
                {
                    cchNewOrigSize -= cchEntryLen;

                    // Did we copy an invalid ID?
                    if (!fCopiedFirstValidID)
                        pszNew -= cchEntryLen;
                }

                // If we haven't copied the first one in yet and this
                // ID is valid, then remember that we have at this
                // point copied the first valid ID.
                if (!fCopiedFirstValidID && (cchEntryLen <= 255))
                    fCopiedFirstValidID = TRUE;
            }
            else
            {
                // Since we now have a orig string that will fit in the max allowed, 
                // just rip through the rest of the orig string and copy.
                while (*pszOld)
                    *pszNew++ = *pszOld++;
            }
        }

        // At this point, pszNew should be pointing the the char directly after
        // the last digit. If we add a new reference, then we need to add a space.
        // If we don't add a new reference, then we need to null terminate the string.
        if (cchNew)
        {
            // With this assignment, we can end up with 4 spaces in a row if we 
            // deleted all references after the first valid one was copied. The
            // son-of-1036 only specifies minimum of 3 spaces when deleting, so
            // we will be OK with that, especially since the only way to get into
            // this situation is by forcing the references line into a strange state.
            *pszNew++ = L' ';
            pszOld = pszNewRef;
            while (*pszOld)
                *pszNew++ = *pszOld++;
        }

        // NULL terminate the string of references.
        *pszNew = 0;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mapiutil.h ===
#ifndef _MAPIUTIL_H
#define _MAPIUTIL_H

const DWORD MSGTYPE_REPLY = 2;
const DWORD MSGTYPE_FWD   = 5;
const DWORD MSGTYPE_CC    = 4;

void NewsUtil_FreeMAPI(void);
HRESULT NewsUtil_ReFwdByMapi(HWND hwnd, LPMIMEMESSAGE pMsg, DWORD msgtype);
HRESULT NewsUtil_QuoteBodyText(LPMIMEMESSAGE pMsg, LPSTREAM pStreamIn,
                               LPSTREAM* ppStreamOut, BOOL fInsertDesc, BOOL fQP, LPCSTR pszFrom);
HRESULT NewsUtil_LoadMAPI(HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mapiutil.cpp ===
#include "pch.hxx"
#include "note.h"
#include "header.h"
#include "envcid.h"
#include "envguid.h"
#include "bodyutil.h"
#include "oleutil.h"
#include "acctutil.h"
#include "menures.h"
#include "instance.h"
#include "inetcfg.h"
#include "ipab.h"
#include "msgprop.h"
#include "mlang.h"
#include "shlwapip.h" 
#include "demand.h"
#include <ruleutil.h>
#include "instance.h"
#include "mapiutil.h"
#include <mapi.h>



LHANDLE g_lhSession = 0;



//
//  FUNCTION:   NewsUtil_ReFwdByMapi
//
//  PURPOSE:    Allows the caller to reply to the specified message via Simple
//              MAPI instead of Athena Mail.
//
//  PARAMETERS:
//      hwnd     - Handle of the window to display UI over.
//      pNewsMsg - Pointer to the news message to reply/forward to
//      fReply   - TRUE if we should reply, FALSE to forward.
//
//  RETURN VALUE:
//      HRESULT.
//
HRESULT NewsUtil_ReFwdByMapi(HWND hwnd, LPMIMEMESSAGE pMsg, DWORD msgtype)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMAPIFREEBUFFER    pfnMAPIFreeBuffer;
    LPMAPIRESOLVENAME   pfnMAPIResolveName;
    LPMAPISENDMAIL      pfnMAPISendMail;
    MapiMessage         mm;
    MapiFileDesc        *pFileDesc=NULL;
    MapiRecipDesc       *pRecips=NULL;
    ULONG               uAttach;
    ULONG               cAttach=0;
    HBODY               *rghAttach=NULL;
    LPSTR               pszReply=NULL;
    LPSTR               pszSubject=NULL;
    LPSTR               pszFrom=NULL;
    LPSTR               pszTo=NULL;
    LPSTR               pszFile=NULL;
    LPSTR               pszFull=NULL;
    LPSTR               pszDisplay=NULL;
    LPSTR               pszAddr=NULL;
    ADDRESSLIST         addrList={0};
    HBODY               hBody;
    BOOL                fQP;
    TCHAR               szNewSubject[256];
    LPWSTR              pwsz=NULL;
    ULONG               cchRead;
    LPSTREAM            pBodyStream=NULL;
    LPSTREAM            pQuotedStream=NULL;
    INT                 cch;
    DWORD               cbUnicode;
    CHAR                szTempPath[MAX_PATH];
    LPMIMEBODY          pBody=NULL;
    MapiFileDesc       *pCur;

    // Trace
    TraceCall("NewsUtil_ReFwdByMapi");

    // Initialize
    ZeroMemory(&mm, sizeof(MapiMessage));

    // Load the MAPI DLL.  If we don't succeed, then we can't continue
    IF_FAILEXIT(hr = NewsUtil_LoadMAPI(hwnd));

    // pfnMAPIFreeBuffer
    pfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hlibMAPI, c_szMAPIFreeBuffer);
    if (NULL == pfnMAPIFreeBuffer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // pfnMAPIResolveName
    pfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress(g_hlibMAPI, c_szMAPIResolveName);
    if (NULL == pfnMAPIResolveName)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // pfnMAPISendMail
    pfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress(g_hlibMAPI, c_szMAPISendMail);
    if (NULL == pfnMAPISendMail)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // From
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszFrom = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // Reply-To
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REPLYTO), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszReply = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // To
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszTo = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // If this is a reply or forward, we need to get the normalized subject.  Otherwise, we just get the regular subject.
    if (MSGTYPE_REPLY == msgtype || MSGTYPE_FWD == msgtype)
    {
        // Normalized Subject
        if (FAILED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &pwsz)))
            pwsz = NULL;
    }

    // Subject
    else if (FAILED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwsz)))
        pwsz = NULL;

    // Convert to ansi
    if (pwsz)
    {
        IF_NULLEXIT(pszSubject = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // Attempt to generate a reciepent list for MAPI if we're replying or CC'ing.
    if (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_CC)
    {
        // Figure out which address to use
        if (msgtype == MSGTYPE_REPLY)
        {
            // If there's a reply-to field on the message, then use that
            if (pszReply)
                pszFull = pszReply;
            else
                // Otherwise, we'll use the address in the from header
                pszFull = pszFrom;
        }

        // Who to address to
        else
            pszFull = pszTo;

        // Bug #24587 - Use IAT_TO instead of IAT_UNKNOWN.
        if (MimeOleParseRfc822Address(IAT_TO, IET_DECODED, pszFull, &addrList)==S_OK)
        {
            UINT i;
            lpMapiRecipDesc paRecips,pCurrent;
            // we arbitrarily chose 128 as typical for EIDSize and address string lengths
            int cAlloc = (sizeof(MapiRecipDesc) + sizeof(TCHAR)*128 + 128) * addrList.cAdrs;
            int cUsed = sizeof(MapiRecipDesc) * addrList.cAdrs;
            LPBYTE pVal = NULL;

            IF_FAILEXIT(hr = HrAlloc((LPVOID *)&paRecips, cAlloc));
            pCurrent = paRecips;
            pVal = (LPBYTE)pCurrent + sizeof(MapiRecipDesc) * addrList.cAdrs;

            // More than one address
            for (i=0; i < addrList.cAdrs ;i++)
            {
                int cBytes;

                // free Safe Friendly Name (not used here, but was allocated)
                SafeMemFree(addrList.prgAdr[i].pszFriendly);
                addrList.prgAdr[i].pszFriendly = NULL;

                // Save E-mail address
                pszAddr = addrList.prgAdr[i].pszEmail;
                addrList.prgAdr[i].pszEmail = NULL;

                // Resolve Name
                if ((cUsed < cAlloc) && SUCCESS_SUCCESS == pfnMAPIResolveName(g_lhSession, (ULONG_PTR) hwnd, pszAddr, MAPI_DIALOG, 0, &pRecips))
                {
                    pRecips->ulRecipClass = MAPI_TO;

                    // copy pRecip
                    pCurrent->ulReserved = pRecips->ulReserved;
                    pCurrent->ulRecipClass = pRecips->ulRecipClass;
                    pCurrent->ulEIDSize = pRecips->ulEIDSize;

                    do {
                    if (pRecips->lpszName)
                    {
                        cBytes = (lstrlen(pRecips->lpszName)+1)*sizeof(TCHAR);
                        cUsed += cBytes;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpszName = (LPTSTR)pVal;
                        lstrcpy(pCurrent->lpszName, pRecips->lpszName);
                        pVal += cBytes;
                    }
                    else
                        pCurrent->lpszName = NULL;

                    if (pRecips->lpszAddress)
                    {
                        cBytes = (lstrlen(pRecips->lpszAddress)+1)*sizeof(TCHAR);
                        cUsed += cBytes;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpszAddress = (LPTSTR)pVal;
                        lstrcpy(pCurrent->lpszAddress, pRecips->lpszAddress);
                        pVal += cBytes;
                    }
                    else
                        pCurrent->lpszAddress = NULL;

                    if (pRecips->ulEIDSize)
                    {
                        cUsed += pRecips->ulEIDSize;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpEntryID = pVal;
                        CopyMemory(pCurrent->lpEntryID, pRecips->lpEntryID, (size_t)pRecips->ulEIDSize);
                        pVal += pRecips->ulEIDSize;
                    }
                    else
                        pCurrent->lpEntryID = NULL;

                    pCurrent++;
                    mm.nRecipCount++;
                    } while (FALSE);

                    // Free recips
                    (*pfnMAPIFreeBuffer)((LPVOID)pRecips);
                    pRecips = NULL;
                }

                SafeMemFree(pszAddr);
                pszAddr = NULL;
            }
            mm.lpRecips = paRecips;

            // Free the Address List
            g_pMoleAlloc->FreeAddressList(&addrList);
        }
    }

    // If this is a reply or forward, then create a normalized subject
    if (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_FWD)
    {
        // Pull in the new prefix from resource...
        if (msgtype == MSGTYPE_REPLY)
            lstrcpy(szNewSubject, c_szPrefixRE);
        else
            lstrcpy(szNewSubject, c_szPrefixFW);

        // If we have a pszSubject
        if (pszSubject)
        {
            // Get Length
            cch = lstrlen(szNewSubject);

            // Append the Subject
            lstrcpyn(szNewSubject + cch, pszSubject, ARRAYSIZE(szNewSubject) - cch - 1);
        }

        // Set the Subject
        mm.lpszSubject = szNewSubject;
    }

    // Don't append anything
    else
    {
        // If this is a CC, then just use the regular subject field
        mm.lpszSubject = pszSubject;
    }

    // Set the note text.
    // If this is a fwd as attachment, there won't be a body, don't use IF_FAILEXIT
    if(SUCCEEDED(pMsg->GetTextBody(TXT_PLAIN, IET_UNICODE, &pBodyStream, &hBody)))
    {
        // Convert from unicode to CP_ACP - WARNING: HrStreamToByte allocates 10 extra bytes so I can slam in a L'\0'
        IF_FAILEXIT(hr = HrStreamToByte(pBodyStream, (LPBYTE *)&pwsz, &cbUnicode));

        // Store null
        pwsz[cbUnicode / sizeof(WCHAR)] = L'\0';

        // Convert to ANSI
        IF_NULLEXIT(mm.lpszNoteText = PszToANSI(CP_ACP, pwsz));

        // Release pBodyStream
        SafeRelease(pBodyStream);

        // Bug #24159 - We need to quote forwards as well as replies
        if (DwGetOption(OPT_INCLUDEMSG) && (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_FWD))
        {
            // Create a new stream
            IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pBodyStream));

            // Dump mm.lpszNoteText into pBodyStream
            IF_FAILEXIT(hr = pBodyStream->Write(mm.lpszNoteText, lstrlen(mm.lpszNoteText), NULL));

            // Commit
            IF_FAILEXIT(hr = pBodyStream->Commit(STGC_DEFAULT));

            // Rewind
            IF_FAILEXIT(hr = HrRewindStream(pBodyStream));

            // QP
            fQP = HrHasEncodedBodyParts(pMsg, 1, &hBody)==S_OK;

            // Quote the body text
            NewsUtil_QuoteBodyText(pMsg, pBodyStream, &pQuotedStream, TRUE, fQP, pszFrom ? pszFrom : c_szEmpty);

            // Free
            SafeMemFree(mm.lpszNoteText);

            // Dup
            IF_FAILEXIT(hr = HrStreamToByte(pQuotedStream, (LPBYTE *)&mm.lpszNoteText, &cchRead));

            // Null Term
            *(mm.lpszNoteText + cchRead) = '\0';
        }
    }

    // If this is a reply, then we don't include any attachments, otherwise we do.
    if (msgtype != MSGTYPE_REPLY)
    {
        // Get Attachment Count
        IF_FAILEXIT(hr = pMsg->GetAttachments(&cAttach, &rghAttach));

        // Ar there attachments
        if (cAttach)
        {
            // Get the temp file path so we have a place to store temp files.
            GetTempPath(ARRAYSIZE(szTempPath), szTempPath);

            // Create the MapiFileDesc array.
            IF_FAILEXIT(hr = HrAlloc((LPVOID*) &pFileDesc, sizeof(MapiFileDesc) * cAttach));

            // Zero It
            ZeroMemory(pFileDesc, sizeof(MapiFileDesc) * cAttach);

            // Set Current
            pCur = pFileDesc;

            // Loop
            for (uAttach = 0; uAttach < cAttach; uAttach++)
            {
                // Get a temp file name
                IF_FAILEXIT(hr = HrAlloc((LPVOID *)&(pCur->lpszPathName), sizeof(TCHAR) * MAX_PATH));

                // Create temp filename
                GetTempFileName(szTempPath, "NAB", 0, pCur->lpszPathName);

                // Bind to the body
                IF_FAILEXIT(hr = pMsg->BindToObject(rghAttach[uAttach], IID_IMimeBody, (LPVOID *)&pBody));

                // Safe It
                IF_FAILEXIT(hr = pBody->SaveToFile(IET_INETCSET, pCur->lpszPathName));

                // Release
                SafeRelease(pBody);

                // Get the filename
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, rghAttach[uAttach], STR_ATT_GENFNAME, NOFLAGS, &pwsz)))
                {
                    IF_NULLEXIT(pszFile = PszToANSI(CP_ACP, pwsz));
                    SafeMemFree(pwsz);
                }
                
                // Set up the MAPI attachment list
                pCur->ulReserved = 0;
                pCur->flFlags = 0;
                pCur->nPosition = (ULONG) -1;
                pCur->lpszFileName = pszFile;
                pCur->lpFileType = NULL;

                // Increment
                pCur++;

                // Don't Free It
                pszFile = NULL;
            }

            mm.nFileCount = cAttach;
            mm.lpFiles = pFileDesc;
        }
    }

    // Finally send this off to MAPI for sending.  If we're doing a CC, we try not to use UI
    IF_FAILEXIT(hr = (HRESULT) pfnMAPISendMail(g_lhSession, (ULONG_PTR)hwnd, &mm, (msgtype == MSGTYPE_CC) ? 0 : MAPI_DIALOG, 0));

exit:
    // If we have a file description
    if (pFileDesc)
    {
        // Walk through the attachments
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            // Free It
            MemFree(pFileDesc[uAttach].lpszFileName);

            // If we have a file path
            if (pFileDesc[uAttach].lpszPathName)
            {
                // Delete the file
                DeleteFile(pFileDesc[uAttach].lpszPathName);

                // Free It
                MemFree(pFileDesc[uAttach].lpszPathName);
            }
        }

        // Free It
        MemFree(pFileDesc);
    }

    // Free recips
    if (pRecips)
        (*pfnMAPIFreeBuffer)((LPVOID)pRecips);

    // Cleanup
    SafeMemFree(mm.lpRecips);
    SafeMemFree(pszAddr);
    SafeMemFree(pszDisplay);
    SafeMemFree(mm.lpszNoteText);
    SafeMemFree(pwsz);
    SafeMemFree(pszReply);
    SafeMemFree(pszSubject);
    SafeMemFree(pszFrom);
    SafeMemFree(rghAttach);
    SafeMemFree(pszTo);
    SafeRelease(pQuotedStream);
    SafeRelease(pBodyStream);
    SafeRelease(pBody);

    // If we logged on to MAPI, we must log off
    NewsUtil_FreeMAPI();

    return(hr);
}

    //
//  FUNCTION:   NewsUtil_LoadMAPI()
//
//  PURPOSE:    Takes care of checking to see if Simple MAPI is available, and
//              if so loads the library and logs the user on.  If successful,
//              then the global variable g_hlibMAPI is set to the library for
//              MAPI.
//
HRESULT NewsUtil_LoadMAPI(HWND hwnd)
    {
    LPMAPILOGON pfnMAPILogon;
    HRESULT     hr = E_FAIL;

    // Load mapi32 dll if we haven't already
    if (!g_hlibMAPI)
    {            

        // Check to see if Simple MAPI is available
        if (1 != GetProfileInt(c_szMailIni, c_szMAPI, 0))
            {
            // Bug #17561 - Need to tell the user they can't send mail without
            //              a mail client.
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsErrNoMailInstalled), 0, MB_OK | MB_ICONSTOP);
            return (E_FAIL);
            }

        g_hlibMAPI = (HMODULE) LoadLibrary(c_szMAPIDLL);
        if (!g_hlibMAPI)
            {
            // Bug #17561 - Need to tell the user they can't send mail without
            //              a mail client.
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsErrNoMailInstalled), 0, MB_OK | MB_ICONSTOP);
            return (E_FAIL);
            }
    }

    // Get the entry point for MAPILogon and the other APIs we'll use.
    pfnMAPILogon = (LPMAPILOGON) GetProcAddress(g_hlibMAPI, c_szMAPILogon);
    if (!pfnMAPILogon)
        {
        AssertSz(pfnMAPILogon, TEXT("Couldn't find the MAPILogon() API"));
        goto error;
        }

    // Attempt to log on.
    // Bug #17558 - Can't used the FAILED() macro to check the success of this
    //              one, MAPI is not returning HRESULTs, just numbers.
    if (SUCCESS_SUCCESS != (hr = pfnMAPILogon(NULL, NULL, NULL, MAPI_LOGON_UI, 0, &g_lhSession)))
        {
        // AssertSz(FALSE, TEXT("Failed call to MAPILogon()"));
        goto error;
        }

    return (S_OK);

error:
    if (g_hlibMAPI)
        {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = 0;
        }
    g_lhSession = 0;

    return (hr);
    }


//
//  FUNCTION:   NewsUtil_FreeMAPI()
//
//  PURPOSE:    Frees the Simple MAPI library if it was previous library and
//              also logs the user off from the current MAPI session.
//
void NewsUtil_FreeMAPI(void)
    {
    LPMAPILOGOFF pfnMAPILogoff;

    if (!g_hlibMAPI)
        return;
    pfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(g_hlibMAPI, c_szMAPILogoff);

    if (g_lhSession)
        pfnMAPILogoff(g_lhSession, NULL, 0, 0);
    g_lhSession = 0;
    }

//
//  FUNCTION:   NewsUtil_QuoteBodyText()
//
//  PURPOSE:    Takes a body text stream (ASCII plain text) and copies the
//              text to a separate outbound stream while prepending the
//              current quote character (">") to the beginning of each line.
//
//  PARAMETERS:
//      pMsg        - Pointer to the message being replied to.  We use this
//                    to add the "On 1/1/96, B.L. Opie Bailey wrote..."
//      pStreamIn   - Pointer to the inbound body stream to quote.
//      ppStreamOut - Pointer to where the new quoted stream will return.
//      fInsertDesc - TRUE if we should insert the "On 1/1/96 ..." line.
//      fQP         - we now pass a flag to say if it's QP or not as there's no
//                    function on the message object
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
const DWORD c_cBufferSize = 1024;
HRESULT NewsUtil_QuoteBodyText(LPMIMEMESSAGE pMsg, LPSTREAM pStreamIn,
                               LPSTREAM* ppStreamOut, BOOL fInsertDesc, BOOL fQP, LPCSTR pszFrom)
    {
    HRESULT hr = S_OK;
    ULONG   cbRead;
    LPTSTR  pch;
    TCHAR   szQuoteChar;
    LPSTR   lpszMsgId=0;

    szQuoteChar = (TCHAR)DwGetOption(OPT_NEWSINDENT);

    // Validate the inbound stream.
    if (!pStreamIn)
        {
        AssertSz(pStreamIn, TEXT("NewsUtil_QuoteBodyText - Need an inbound stream to process."));
        return (E_INVALIDARG);
        }

    // Create our outbound stream.
    if (FAILED(MimeOleCreateVirtualStream(ppStreamOut)))
        {
        AssertSz(FALSE, TEXT("NewsUtil_QuoteBodyText - Failed to allocate memory."));
        return (E_OUTOFMEMORY);
        }

    // Create a buffer to read into and parse etc.
    LPTSTR pszBuffer;
    if (!MemAlloc((LPVOID*) &pszBuffer, c_cBufferSize * sizeof(TCHAR)))
        {
        (*ppStreamOut)->Release();
        AssertSz(FALSE, TEXT("NewsUtil_QuoteBodyText - Failed to allocate memory."));
        return (E_OUTOFMEMORY);
        }

    ZeroMemory(pszBuffer, c_cBufferSize * sizeof(TCHAR));

    MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpszMsgId);

    if (lpszMsgId == NULL)
        lpszMsgId = (LPSTR)c_szEmpty;

    if (fQP)
        {
        // If the text has some quoted printable stuff in it, then we don't want
        // to introduce hard line breaks.  Instead we just prefix the stream with
        // the normal desc stuff and end it with a suitable line.

        // Add the quote line.
        LPTSTR pszStringRes;
        int ids = 0;

        if (fInsertDesc)
            {
            pszStringRes = AthLoadString(idsReplyTextPrefix, 0, 0);
            wsprintf(pszBuffer, pszStringRes, pszFrom, lpszMsgId);
            AthFreeString(pszStringRes);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF2, lstrlen(g_szCRLF2), NULL);
            (*ppStreamOut)->Write((LPVOID) pszBuffer, lstrlen(pszBuffer), NULL);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF, lstrlen(g_szCRLF), NULL);
            }

        while (TRUE)
            {
            // Read a buffer from the input and write it to the output.
            hr = pStreamIn->Read((LPVOID) pszBuffer, c_cBufferSize - 2, &cbRead);
            if (FAILED(hr))
                goto exit;
            if (cbRead == 0)
                break;

            (*ppStreamOut)->Write((LPVOID) pszBuffer, cbRead, NULL);
            }

        // Write the trailing comment.
        pszStringRes = AthLoadString(idsReplyTextAppend, 0, 0);
        (*ppStreamOut)->Write((LPVOID) pszStringRes, lstrlen(pszStringRes), NULL);
        AthFreeString(pszStringRes);
        }
    else
        {
        if (fInsertDesc)
            {
            // Add the quote line.
            LPTSTR pszStringRes;
            int ids = 0;

            pszStringRes = AthLoadString(idsReplyTextPrefix, 0, 0);
            wsprintf(pszBuffer, pszStringRes, pszFrom, lpszMsgId);
            AthFreeString(pszStringRes);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF2, lstrlen(g_szCRLF2), NULL);
            (*ppStreamOut)->Write((LPVOID) pszBuffer, lstrlen(pszBuffer), NULL);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF, lstrlen(g_szCRLF), NULL);
            }

        // Write the first quote char to the new stream.
        // Bug #26297 - Still go through this bs even if no quote char is necessary
        //              to make sure we get the attribution line right.
        if (szQuoteChar != INDENTCHAR_NONE)
            {
            (*ppStreamOut)->Write((const LPVOID) &szQuoteChar,
                                  sizeof(TCHAR), NULL);
            (*ppStreamOut)->Write((const LPVOID) g_szSpace, sizeof(TCHAR), NULL);
            }

        // Now start the reading and parsing.
        // NOTE - Right now all we're doing is adding a quote char to the beginning
        //        of each line.  We're not trying to wrap lines or re-wrap previously
        //        quoted areas. - SteveSer
        while (TRUE)
            {
            hr = pStreamIn->Read((LPVOID) pszBuffer, c_cBufferSize - 2, &cbRead);
            if (FAILED(hr))
                goto exit;
            if (cbRead == 0)
                break;

            pch = pszBuffer;
            // Make sure the buffer is NULL terminated
            *(pch + cbRead) = 0;

            // Now run through the stream.  Whenever we find a line break, we
            // insert a quote char after the line break.
            while (*pch)
                {
                (*ppStreamOut)->Write((const LPVOID) pch,
                                      (ULONG)((IsDBCSLeadByte(*pch) ? 2 * sizeof(TCHAR) : sizeof(TCHAR))),
                                      NULL);
                if (*pch == *g_szNewline)
                    {
                    // Bug #26297 - Still go through this bs even if no quote char is necessary
                    //              to make sure we get the attribution line right.
                    if (szQuoteChar != INDENTCHAR_NONE)
                        {
                        (*ppStreamOut)->Write((const LPVOID) &szQuoteChar,
                                              sizeof(TCHAR), NULL);
                        (*ppStreamOut)->Write((const LPVOID) g_szSpace, sizeof(TCHAR),
                                              NULL);
                        }
                    }

                pch = CharNext(pch);

                // Do some checking to see if we're at the end of a buffer.
                if (IsDBCSLeadByte(*(pch)) && (0 == *(pch + 1)))
                    {
                    // Here's a little special case.  If we have one byte left in
                    // the buffer, and that byte happens to be the first byte in
                    // a DBCS character, we need to write that byte now, then move
                    // the pointer to the end of the buffer so the next character
                    // get's read off the next stream OK.
                    (*ppStreamOut)->Write((const LPVOID) pch, sizeof(TCHAR), NULL);
                    pch++;
                    }
                }
            }
        }

exit:
    if (pszBuffer)
        MemFree(pszBuffer);

    if (lpszMsgId != c_szEmpty)
        SafeMimeOleFree(lpszMsgId);
    return (hr);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mehost.cpp ===
#include "pch.hxx"
#include <docobj.h>
#include "dllmain.h"
#include "strconst.h"
#include "msoert.h"
#include "mimeole.h"
#include "mehost.h"
#include "oleutil.h"
#include "ibodyopt.h"
#include "resource.h"
#include "mshtmcid.h"
#include "thormsgs.h"
#include "msoeprop.h"
#include "goptions.h"
#include "bodyutil.h"
#include "mimeutil.h"
#include "ourguid.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "ipab.h"
#include "statnery.h"
#include "options.h"
#include "sigs.h"
#include "fonts.h"
#include "url.h"
#include "secutil.h"
#include "sechtml.h"
#include "mimeolep.h"
#include "menuutil.h"
#include "htmlhelp.h"
#include "msgprop.h"
#include "demand.h"
#include <mshtmdid.h>
#include "menures.h"
#include "multiusr.h"
#include "fontnsc.h"

const int   idTimerMarkAsRead   = 100;
const TCHAR c_szSigPrefix[]     = "\r\n-- \r\n";

#define MAKEINDEX(b, l) (((DWORD)l & 0x00ffffff) | ((DWORD)b << 24))
#define GETINDEX(m) (((m & 0xff000000) >> 24) & 0x000000ff)

ASSERTDATA
static const WCHAR  c_wszMailTo[]  = L"mailto:",
                    c_wszHttp[]  = L"http://",
                    c_wszFile[]  = L"file://";

const DWORD rgrgbColors16[16] = {
    RGB(  0,   0, 0),     // "BLACK"},
    RGB(128,   0, 0),     // "MAROON"},
    RGB(  0, 128, 0),     // "GREEN"},
    RGB(128, 128, 0),     // "OLIVE"},
    RGB(  0,   0, 128),   // "NAVY"},
    RGB(128,   0, 128),   // "PURPLE"},
    RGB(  0, 128, 128),   // "TEAL"},
    RGB(128, 128, 128),   // "GREY"},
    RGB(192, 192, 192),   // "SILVER"},
    RGB(255,   0, 0),     // "RED"},
    RGB(  0, 255, 0),     // "LIME"},
    RGB(255, 255, 0),     // "YELLOW"},
    RGB(  0,   0, 255),   // "BLUE"},
    RGB(255,   0, 255),   // "FUSCHIA"},
    RGB(  0, 255, 255),   // "AQUA"},
    RGB(255, 255, 255)    // "WHITE"}
};

INT_PTR CALLBACK BkImageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int                 id;
    LPWSTR              pwszURL;
    HWND                hwndCombo = GetDlgItem(hwnd, idTxtBkImage);
    LRESULT             lr=0;
    HRESULT             hr;

    pwszURL = (LPWSTR)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg)
    {
        case WM_INITDIALOG:
            Assert(lParam!= NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)lParam);
            SetIntlFont(hwndCombo);
            SendDlgItemMessage(hwnd, idTxtBkImage, EM_LIMITTEXT, MAX_PATH-1, NULL);
            SetFocus(hwndCombo);
            pwszURL = (LPWSTR)lParam;

            HrFillStationeryCombo(hwndCombo, TRUE, pwszURL);
            StripStationeryDir(pwszURL);
            SetWindowTextWrapW(hwndCombo, pwszURL);
            SendMessage(GetWindow(hwndCombo, GW_CHILD), EM_SETSEL, 0, -1);
            CenterDialog(hwnd);
            return FALSE;

        case WM_COMMAND:
            switch(id=GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idBrowsePicture:
                    HrBrowsePicture(hwnd, GetDlgItem(hwnd, idTxtBkImage));
                    break;

                case IDOK:
                    Assert(pwszURL);
                    SendMessageWrapW(hwndCombo, CB_GETLBTEXT, (WPARAM)(SendMessage(hwndCombo, CB_GETCURSEL, 0, 0)), (LPARAM)(pwszURL));

                    // fall thro'
                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost
//
//  Synopsis:
//
//---------------------------------------------------------------
CMimeEditDocHost::CMimeEditDocHost(DWORD dwBorderFlags)
{
    m_hwnd = 0; 
    m_hwndDocObj = 0; 

    m_cRef = 1; 

    m_dwStyle = 0;
    m_dwHTMLNotifyCookie = 0; 
    m_dwBorderFlags = dwBorderFlags; 
    m_dwDocStyle = MESTYLE_NOHEADER; 

    m_fUIActive = FALSE; 
    m_fIsSigned = FALSE;
    m_fFixedFont = FALSE;
    m_fMarkedRead = FALSE; 
    m_fSignTrusted = TRUE; 
    m_fIsEncrypted = FALSE; 
    m_fSecDispInfo = FALSE;
    m_fSecureReceipt = FALSE;
    m_fEncryptionOK = TRUE; 
    m_fBlockingOnSMime = FALSE; 
    m_fShowingErrorPage = FALSE;
    m_fRegisteredForDocEvents = FALSE; 

    m_pDoc = NULL; 
    m_pMsg = NULL; 
    m_pStatus = NULL;
    m_pDocView = NULL;
    m_lpOleObj = NULL; 
    m_pPrstMime = NULL; 
    m_pCmdTarget = NULL; 
    m_hmenuColor = NULL; 
    m_hmenuStyle = NULL; 
    m_pEventSink = NULL; 
    m_pUnkService = NULL;
    m_pBodyOptions = NULL; 
    m_pSecureMessage = NULL; 
    m_pInPlaceActiveObj = NULL; 
    m_pSecurityErrorScreen = NULL;
}

//+---------------------------------------------------------------
//
//  Member:
//
//  Synopsis:
//
//---------------------------------------------------------------
CMimeEditDocHost::~CMimeEditDocHost()
{
    // These should all get feed up when we get a WM_DESTROY and close the docobj
    Assert(m_lpOleObj==NULL);
    Assert(m_pDocView==NULL);
    Assert(m_pInPlaceActiveObj==NULL);
    Assert(m_pCmdTarget==NULL);
    Assert(m_pPrstMime==NULL);
    Assert(m_pMsg==NULL);
    Assert(m_pSecurityErrorScreen==NULL);
    Assert(m_pSecureMessage==NULL);

    if(m_hmenuColor)
        DestroyMenu(m_hmenuColor);

    if(m_hmenuStyle)
        DestroyMenu(m_hmenuStyle);

}

//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:
//
//---------------------------------------------------------------
ULONG CMimeEditDocHost::AddRef()
{
    TraceCall("CMimeEditDocHost::AddRef");

    //TraceInfo(_MSG("CMimeEditDocHost::AddRef: cRef==%d", m_cRef+1));
    return ++m_cRef;
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:
//
//---------------------------------------------------------------
ULONG CMimeEditDocHost::Release()
{
    TraceCall("CMimeEditDocHost::Release");

    //TraceInfo(_MSG("CMimeEditDocHost::Release: cRef==%d", m_cRef-1));
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CMimeEditDocHost::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IDocHostUIHandler))
        *lplpObj = (LPVOID)(IDocHostUIHandler*)this;

    else if (IsEqualIID(riid, IID_IBodyObj2))
        *lplpObj = (LPVOID)(IBodyObj2*)this;

    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime*)this;

    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     ExtWndProc
//
//  Synopsis:
//
//---------------------------------------------------------------
LRESULT CALLBACK CMimeEditDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMimeEditDocHost *pDocHost;

    if (WM_CREATE == msg)
    {
        pDocHost = (CMimeEditDocHost *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pDocHost)
            return -1;

        if(FAILED(pDocHost->OnCreate(hwnd)))
            return -1;
    }
    pDocHost = (CMimeEditDocHost *)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:
//
//---------------------------------------------------------------
LRESULT CMimeEditDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_PAINT:
            if (!m_lpOleObj)
            {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;
                HBRUSH      hBrush;

                GetClientRect(m_hwnd, &rc);
                hdc = BeginPaint(hwnd, &ps);
                hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
                SelectBrush(hdc, hBrush);
                EndPaint(hwnd, &ps);
                return 0;
            }

        case WM_COMMAND:
            if(WMCommand(   GET_WM_COMMAND_HWND(wParam, lParam),
                            GET_WM_COMMAND_ID(wParam, lParam),
                            GET_WM_COMMAND_CMD(wParam, lParam)))
                return 0;
            break;

        case WM_SETFOCUS:
            return OnFocus(TRUE);

        case WM_KILLFOCUS:
            return OnFocus(FALSE);

        case WM_NOTIFY:
            return WMNotify((int) wParam, (NMHDR *)lParam);

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_NCDESTROY:
            WMNCDestroy();
            break;

        case WM_TIMER:
            if (wParam == idTimerMarkAsRead)
            {
                OnWMTimer();
                return 0;
            }
            break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
           if (m_hwndDocObj)
                return SendMessage(m_hwndDocObj, msg, wParam, lParam);
            break;
    }

    return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

BOOL CMimeEditDocHost::WMCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return SUCCEEDED(HrSubWMCreate())?TRUE:FALSE;
}

void CMimeEditDocHost::WMNCDestroy()
{
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
}


//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnNCDestroy()
{
    TraceCall("CMimeEditDocHost::OnNCDestroy");
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDestroy
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnDestroy()
{
    TraceCall("CMimeEditDocHost::OnDestroy");

    return CloseDocObj();
}


//+---------------------------------------------------------------
//
//  Member:     OnCreate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnCreate(HWND hwnd)
{
    TraceCall("CMimeEditDocHost::OnCreate");

    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CreateDocObj
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CreateDocObj(LPCLSID pCLSID)
{
    HRESULT hr=NOERROR;

    TraceCall("CMimeEditDocHost::CreateDocObj");

    if(!pCLSID)
        return E_INVALIDARG;

    Assert(!m_lpOleObj);
    Assert(!m_pDocView);
    Assert(!m_pCmdTarget);

    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMime, (LPVOID *)&m_pPrstMime);
    if (FAILED(hr))
        goto error;

    hr = HrInitNew(m_lpOleObj);

error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Show()
{
    RECT    rc;
    HRESULT hr;

    TraceCall("CMimeEditDocHost::Show");

    GetClientRect(m_hwnd, &rc);

    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;
error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CloseDocObj
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    RegisterForHTMLDocEvents(FALSE);

    SafeRelease(m_pCmdTarget);
    SafeRelease(m_pPrstMime);
    SafeRelease(m_pInPlaceActiveObj);
    SafeRelease(m_pDoc);
    SafeRelease(m_pMsg);
    SafeRelease(m_pSecureMessage);
    SafeRelease(m_pSecurityErrorScreen);
    SafeRelease(m_pEventSink);
    SafeRelease(m_pStatus);

    if(m_pDocView)
    {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        m_pDocView->Release();
        m_pDocView=NULL;
    }

    if (m_lpOleObj)
    {
        // deactivate the docobj
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
        {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
        }

        // close the ole object, but blow off changes as we have either extracted
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        AssertSz(uRef==0, "We leaked a docobject!");
    }

    m_fUIActive=FALSE;
    return NOERROR;
}

// Close DocObj
HRESULT CMimeEditDocHost::HrResetDocument()
{
    CloseDocObj();
    CreateDocObj((LPCLSID)&CLSID_MimeEdit);
    CreateDocView();
    return(S_OK);
}

// *** IOleWindow ***

//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetWindow(HWND *phwnd)
{
    TraceCall("CMimeEditDocHost::GetWindow");
    *phwnd=m_hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CMimeEditDocHost::ContextSensitiveHelp");
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
//+---------------------------------------------------------------
//
//  Member:     GetBorder
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetBorder(LPRECT lprectBorder)
{
    TraceCall("CMimeEditDocHost::GetBorder");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestBorderSpace
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceCall("CMimeEditDocHost::RequestBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetBorderSpace
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceUIWindow::SetBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetActiveObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceUIWindow::SetActiveObject");

    ReplaceInterface(m_pInPlaceActiveObj, pActiveObject);
    return S_OK;
}

    // *** IOleInPlaceFrame methods ***

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::InsertMenus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS)
{
    TraceCall("CMimeEditDocHost::InsertMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::SetMenu
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetMenu(HMENU, HOLEMENU, HWND)
{
    TraceCall("CMimeEditDocHost::SetMenu");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::RemoveMenus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RemoveMenus(HMENU)
{
    TraceCall("CMimeEditDocHost::RemoveMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::SetStatusText
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetStatusText(LPCOLESTR pszW)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    TraceCall("CMimeEditDocHost::SetStatusText");

    if(!m_pStatus)
        return E_NOTIMPL;

    *rgch=0;
    if(pszW && WideCharToMultiByte(CP_ACP, 0, pszW, -1, rgch, CCHMAX_STRINGRES, NULL, NULL))
        m_pStatus->ShowSimpleText(rgch);

    if(*rgch==0)
        m_pStatus->HideSimpleText();

    DOUTL(64, "IOleInPlaceFrame::SetStatusText:'%s'", rgch);
    return NOERROR;
}

HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG, WORD)
{
    return E_NOTIMPL;
}


// **** IOleInPlaceSite methods ****

//+---------------------------------------------------------------
//
//  Member:     CanInPlaceActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CanInPlaceActivate()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::CanInPlaceActivate");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive;

    TraceCall("CMimeEditDocHost::OnInPlaceActivate");

    Assert(m_lpOleObj);

    if (m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive)==S_OK)
    {
        SideAssert((pInPlaceActive->GetWindow(&m_hwndDocObj)==NOERROR)&& IsWindow(m_hwndDocObj));
        pInPlaceActive->Release();
    }

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUIActivate()
{
    TraceCall("CMimeEditDocHost::OnUIActivate");
    m_fUIActive=TRUE;

    // Notify our parent that we're the one with the focus now.
    if (m_pEventSink)
        m_pEventSink->EventOccurred(MEHC_UIACTIVATE, NULL);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     GetWindowContext
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetWindowContext( IOleInPlaceFrame    **ppFrame,
                                    IOleInPlaceUIWindow **ppDoc,
                                    LPRECT              lprcPosRect,
                                    LPRECT              lprcClipRect,
                                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::GetWindowContext");

    *ppFrame = (LPOLEINPLACEFRAME)this;
    AddRef();
    *ppDoc = NULL;

    GetClientRect(m_hwnd, lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Scroll
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::Scroll");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUIDeactivate(BOOL fUndoable)
{
    TraceCall("CMimeEditDocHost::OnUIDeactivate");
    m_fUIActive=FALSE;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceDeactivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnInPlaceDeactivate()
{
    TraceCall("CMimeEditDocHost::OnInPlaceDeactivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     DiscardUndoState
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::DiscardUndoState()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::DiscardUndoState");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateAndUndo
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::DeactivateAndUndo()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::DeactivateAndUndo");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnPosRectChange
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::OnPosRectChange");
    return E_NOTIMPL;
}


// IOleClientSite methods.

//+---------------------------------------------------------------
//
//  Member:     SaveObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SaveObject()
{
    TraceCall("CMimeEditDocHost::IOleClientSite::SaveObject");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetContainer
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::GetContainer");
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     ShowObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ShowObject()
{
    // always shown.
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    TraceCall("CMimeEditDocHost::IOleClientSite::ShowObject");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnShowWindow
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnShowWindow(BOOL fShow)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::OnShowWindow");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestNewObjectLayout
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RequestNewObjectLayout()
{
    TraceCall("CMimeEditDocHost::IOleClientSite::RequestNewObjectLayout");
    return E_NOTIMPL;
}

// IOleDocumentSite

//+---------------------------------------------------------------
//
//  Member:     ActivateMe
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{
    TraceCall("CMimeEditDocHost::IOleDocumentSite::ActivateMe");
    return CreateDocView();
}


//+---------------------------------------------------------------
//
//  Member:     CreateDocView
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CreateDocView()
{
    HRESULT             hr;
    LPOLEDOCUMENT       pOleDoc=NULL;
    IServiceProvider    *pSP;

    TraceCall("CMimeEditDocHost::CreateDocView");
    AssertSz(!m_pDocView, "why is this still set??");
    AssertSz(m_lpOleObj, "uh? no docobject at this point?");

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto Exit;

    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto Exit;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto CleanUp;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto CleanUp;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto CleanUp;

    hr = m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP);
    if (!FAILED(hr))
    {
        hr = pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&m_pDoc);
        pSP->Release();
    }

CleanUp:
    pOleDoc->Release();
Exit:
    return hr;
}

// This must be greater than the most number of IDs that will ever be passed down
// to MimeEdit for any one group within the CMDSETID_OutlookExpress portion of 
// QueryStatus below
const DWORD MAX_MIMEEDIT_CMDS = 20;

// I know this is totally cheesy, but...
// These next macros rely upon variables within the CMDSETID_OutlookExpress
// portion of QueryStatus
#define INC_FORMS(id)       _IncrementCmdList(pCmd, rgCmdForms, rgpCmdForms, &cCmdForms, id)
#define INC_STD(id)         _IncrementCmdList(pCmd, rgCmdStd, rgpCmdStd, &cCmdStd, id)
#define INC_MIMEEDIT(id)    _IncrementCmdList(pCmd, rgCmdMimeEdit, rgpCmdMimeEdit, &cCmdMimeEdit, id)

inline void _IncrementCmdList(OLECMD *pCurCmd, OLECMD *pInCmdList, OLECMD **ppOutCmdList, DWORD *pdwIndex, DWORD cmdID)
{
    DWORD dwIndex = *pdwIndex;
    AssertSz(dwIndex < MAX_MIMEEDIT_CMDS, "Need to increment MAX_MIMEEDIT_CMDS");
    pInCmdList[dwIndex].cmdID = cmdID;
    pInCmdList[dwIndex].cmdf = 0;
    ppOutCmdList[dwIndex] = pCurCmd;
    dwIndex++;
    *pdwIndex = dwIndex;
}

//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    TraceCall("CMimeEditDocHost::CMimeEditDocHost::QueryStatus");

    HRESULT     hr = OLECMDERR_E_UNKNOWNGROUP;
    OLECMD     *pCmd = rgCmds;

    if (!rgCmds)
        return E_INVALIDARG;

    if (NULL == pguidCmdGroup)
    {
        // TraceInfo("IOleCmdTarget::QueryStatus - std group");

        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case OLECMDID_UPDATECOMMANDS:
                case OLECMDID_SETPROGRESSPOS:
                case OLECMDID_SETPROGRESSTEXT:
                    pCmd->cmdf = MSOCMDF_ENABLED;
                    break;
            }
        }
        hr = S_OK;
    }

// Will be used when sending down command IDs
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        ULONG   ulTab = MEST_EDIT;

        DWORD   cCmdForms = 0,
                cCmdStd = 0,
                cCmdMimeEdit = 0;

        OLECMD  rgCmdForms[MAX_MIMEEDIT_CMDS],
                rgCmdStd[MAX_MIMEEDIT_CMDS],
                rgCmdMimeEdit[MAX_MIMEEDIT_CMDS],
               *rgpCmdForms[MAX_MIMEEDIT_CMDS],
               *rgpCmdStd[MAX_MIMEEDIT_CMDS],
               *rgpCmdMimeEdit[MAX_MIMEEDIT_CMDS];

        BOOL    fHtml,
                fActiveAndHtml,
                fEditMode = FALSE,
                fFormatMenu = FALSE;

        HrIsEditMode(&fEditMode);
        if (!fEditMode && m_pMsg)
        {
            DWORD dwFlags = 0;
            m_pMsg->GetFlags(&dwFlags);
            fHtml = (dwFlags & IMF_HTML);
        }
        else
            fHtml = (S_OK == HrIsHTMLMode());

        fActiveAndHtml = fHtml && m_fUIActive;

        ExecGetI4(&CMDSETID_MimeEdit, MECMDID_SETSOURCETAB, &ulTab);

        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            ULONG cmdID = pCmd->cmdID;
            if (0 != pCmd->cmdf)
                continue;

            switch (cmdID)
            {
                case ID_REPLY:
                case ID_REPLY_ALL:
                case ID_REPLY_GROUP:
                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                    // If we have the sec UI showing then the reply, etc shouldn't work. We don't care
                    // here in MimeEdit if is isn't displayed. We can allow the other components to
                    // decide what happens in that case.
                    if(m_fSecDispInfo || m_fShowingErrorPage)
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;
                    
                case ID_FONTS_LARGEST:
                case ID_FONTS_LARGE:
                case ID_FONTS_MEDIUM:
                case ID_FONTS_SMALL:
                case ID_FONTS_SMALLEST:
                    INC_FORMS(IDM_BASELINEFONT1 + (cmdID - ID_FONTS_SMALLEST));
                    break;

                case ID_FONTS_FIXED:
                    pCmd->cmdf = QS_ENABLECHECK(!fHtml, m_fFixedFont);
                    break;

                case ID_FIND_TEXT:
                    // For some reason, trident always marks this enabled, but if we are in the
                    // browser and the list view has focus, then the Exec won't work even though 
                    // the QueryStatus returns enabled. Therefore, only enable this if active

                    // Once trident has fixed there problem here, we can enable calling into trident
                    // See RAID 13727
                    //INC_STD(OLECMDID_FIND);
                    pCmd->cmdf = QS_ENABLED(m_fUIActive);
                    break;
                
                case ID_PRINT:
                case ID_PRINT_NOW:
                    if (IsWindowVisible(m_hwnd))
                        INC_STD(OLECMDID_PRINT);
                    
                    break;

                case ID_POPUP_FONTS:
                case ID_VIEW_MSG_SOURCE:
                case ID_VIEW_SOURCE:
                    pCmd->cmdf = QS_ENABLED(TRUE);
                    break;

                // This should be disabled if mail
                case ID_UNSCRAMBLE:
                {
                    DWORD dwFlags = 0;
                    if (m_fSecDispInfo || m_fShowingErrorPage)
                    {
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    }
                    else
                    {
                        m_pBodyOptions->GetFlags(&dwFlags);
                        pCmd->cmdf = QS_ENABLED((0 == (dwFlags & BOPT_MAIL)) && !fEditMode);
                    }
                    break;
                }

                case ID_SAVE_STATIONERY:
                case ID_NOTE_SAVE_STATIONERY:
                {
                    DWORD dwFlags = 0;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    
                    pCmd->cmdf = QS_ENABLED(fHtml && IsWindowVisible(m_hwnd) &&
                                (0 == (BOPT_MULTI_MSGS_SELECTED & dwFlags)) && !m_fShowingErrorPage);
                    break;
                }

                // This should only be enabled if have attachments
                case ID_SAVE_ATTACHMENTS:
                case ID_NOTE_SAVE_ATTACHMENTS:
                {
                    DWORD dwFlags = 0;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    
                    if (IsWindowVisible(m_hwnd) && (0 == (BOPT_MULTI_MSGS_SELECTED & dwFlags)))
                        INC_MIMEEDIT(MECMDID_SAVEATTACHMENTS);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;
                }

                // We only care what happens with these if we are not in the edit tab. If not in the
                // edit tab, then disable these menu items.
                case ID_MOVE_TO_FOLDER:
                case ID_COPY_TO_FOLDER:
                case ID_NOTE_MOVE_TO_FOLDER:
                case ID_NOTE_COPY_TO_FOLDER:
                case ID_FORMATTING_TOOLBAR:
                case ID_POPUP_LANGUAGE:
                case ID_POPUP_LANGUAGE_DEFERRED:
                    if (ulTab != MEST_EDIT)
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_SPELLING:
                    INC_STD(OLECMDID_SPELL); 
                    break;

                case ID_CUT:
                    INC_STD(OLECMDID_CUT); 
                    break;

                case ID_NOTE_COPY:
                case ID_COPY:
                    INC_STD(OLECMDID_COPY); 
                    break;

                case ID_PASTE:
                    INC_STD(OLECMDID_PASTE); 
                    break;

                case ID_SELECT_ALL:
                    INC_STD(OLECMDID_SELECTALL); 
                    break;

                case ID_UNDO:
                    INC_STD(OLECMDID_UNDO); 
                    break;

                case ID_REDO:
                    INC_STD(OLECMDID_REDO); 
                    break;

                case ID_SOURCE_EDIT:
                    INC_MIMEEDIT(MECMDID_SHOWSOURCETABS); 
                    break;

                case ID_DOCDIR_LTR:
                    INC_FORMS(IDM_DIRLTR); 
                    break;

                case ID_DOCDIR_RTL:
                    INC_FORMS(IDM_DIRRTL); 
                    break;

                case ID_INDENT_INCREASE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_INDENT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INDENT_DECREASE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_OUTDENT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FONTS_DIALOG:       
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_FONT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FORMAT_SETTINGS:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_BLOCKFMT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INSERT_TEXT:                
                    if (m_fUIActive)
                        INC_MIMEEDIT(MECMDID_INSERTTEXTFILE); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FORMAT_PARADLG:
                    if (m_fUIActive)
                        INC_MIMEEDIT(MECMDID_FORMATPARAGRAPH);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_POPUP_STYLE:
                    pCmd->cmdf = QS_ENABLED(fActiveAndHtml && (ulTab == MEST_EDIT));
                    break;

                case ID_BACKGROUND_PICTURE:
                case ID_BACKGROUND_SOUND:
                case ID_POPUP_BACKGROUND_COLOR:
                case ID_POPUP_STATIONERY:
                case ID_POPUP_BACKGROUND:
                    pCmd->cmdf = QS_ENABLED(fHtml && (ulTab == MEST_EDIT));
                    break;

                case ID_INSERT_PICTURE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_IMAGE);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INSERT_LINE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_HORIZONTALLINE); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_UNLINK:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_UNLINK); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_EDIT_LINK:
                    pCmd->cmdf = QS_ENABLED(fActiveAndHtml);
                    break;

                case ID_INSERT_SIGNATURE:
                    if (m_fUIActive && (ulTab == MEST_EDIT) && m_pBodyOptions && (S_OK == m_pBodyOptions->SignatureEnabled(FALSE)))
                        INC_MIMEEDIT(MECMDID_INSERTHTML);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                default:
                    if ((ID_FORMAT_FIRST <= cmdID) && (ID_FORMAT_LAST >= cmdID))
                        pCmd->cmdf = QS_ENABLED(TRUE);
                    break;
            }
        }
        if (cCmdForms)
        {
            DOUTL(8, "cCmdForms = %d", cCmdForms);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, cCmdForms, rgCmdForms, NULL))
            {
                OLECMD     *pCmds = rgCmdForms,
                          **ppCmdsToReturn = rgpCmdForms;

                for (DWORD i = 0; i < cCmdForms; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }
        if (cCmdStd)
        {
            DOUTL(8, "cCmdStd = %d", cCmdStd);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(NULL, cCmdStd, rgCmdStd, NULL))
            {
                OLECMD     *pCmds = rgCmdStd,
                          **ppCmdsToReturn = rgpCmdStd;

                for (DWORD i = 0; i < cCmdStd; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }
        if (cCmdMimeEdit)
        {
            DOUTL(8, "cCmdMimeEdit = %d", cCmdMimeEdit);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, cCmdMimeEdit, rgCmdMimeEdit, NULL))
            {
                OLECMD     *pCmds = rgCmdMimeEdit,
                          **ppCmdsToReturn = rgpCmdMimeEdit;

                for (DWORD i = 0; i < cCmdMimeEdit; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }

        hr = S_OK;
    }

    else if (IsEqualGUID(CMDSETID_MimeEditHost, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case MEHOSTCMDID_SAVEATTACH_PATH:
                case MEHOSTCMDID_UNSAFEATTACHMENTS:
                case MEHOSTCMDID_SECURITY_ZONE:
                case MEHOSTCMDID_SIGNATURE_ENABLED:
                case MEHOSTCMDID_SIGNATURE_OPTIONS:
                case MEHOSTCMDID_SIGNATURE:
                case MEHOSTCMDID_HEADER_TYPE:
                case MEHOSTCMDID_FLAGS:
                case MEHOSTCMDID_QUOTE_CHAR:
                case MEHOSTCMDID_REPLY_TICK_COLOR:
                case MEHOSTCMDID_COMPOSE_FONT:
                case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
                case MEHOSTCMDID_ADD_TO_FAVORITES:
                case MEHOSTCMDID_ONPARSECOMPLETE:
                case MEHOSTCMDID_FONTCACHE:
                case MEHOSTCMDID_BORDERFLAGS:
                    pCmd->cmdf = QS_ENABLED(TRUE);
                    break;
            }
        }
        hr = S_OK;
    }

    else if (IsEqualGUID(CMDSETID_OESecurity, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case OECSECCMD_ENCRYPTED:
                {
                    pCmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_fIsEncrypted)
                    {
                        if(m_fSecDispInfo)
                            pCmd->cmdf |= OLECMDF_INVISIBLE;
                        else if (m_fEncryptionOK)
                            pCmd->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                        pCmd->cmdf |= OLECMDF_INVISIBLE;
                    break;
                }
                case OECSECCMD_SIGNED:
                {
                    pCmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_fIsSigned)
                    {
                        if(m_fSecDispInfo)
                            pCmd->cmdf |= OLECMDF_INVISIBLE;
                        else if (m_fSignTrusted)
                            pCmd->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                        pCmd->cmdf |= OLECMDF_INVISIBLE;
                    break;
                }
            }
        }
        hr = S_OK;
    }

    TraceInfoAssert(OLECMDERR_E_UNKNOWNGROUP != hr, "IOleCmdTarget::QueryStatus - unknown group");
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TCHAR   rgch[MAX_PATH];
    HRESULT hr = S_OK;

    TraceCall("CMimeEditDocHost::Exec");

    if (NULL == pguidCmdGroup)
    {
        switch(nCmdID)
        {
            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    SetStatusText(NULL);
                break;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }

// Will be used when sending down command IDs
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        // TraceInfo("IOleCmdTarget::QueryStatus - std group");

        hr = HrWMCommand(m_hwnd, nCmdID, 0);
    }

    else if (IsEqualGUID(CMDSETID_Forms3, *pguidCmdGroup))
    {
        if (nCmdID == IDM_PARSECOMPLETE)
            // add code here to call download complete when 916 comes out.
            OnDocumentReady();
        else if (nCmdID == IDM_DIRRTL)
            return m_pCmdTarget ? m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) : E_FAIL;
        else
            hr = OLECMDERR_E_NOTSUPPORTED;

    }
    else if (IsEqualGUID(CMDSETID_MimeEdit, *pguidCmdGroup))
    {
        return m_pCmdTarget ? m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) : E_FAIL;
    }
    else if (IsEqualGUID(CMDSETID_MimeEditHost, *pguidCmdGroup))
    {
        BOOL fCommandHandled = FALSE;
        // CFrontPage doesn't initialize an m_pBodyOptions
        if (m_pBodyOptions)
        {
            fCommandHandled = TRUE;
            switch (nCmdID)
            {
                case MEHOSTCMDID_SOURCEEDIT_FLAGS:
                    if (pvaOut)
                    {
                        pvaOut->vt = VT_I4;
                        pvaOut->lVal = 0;
                        
                        if (DwGetOption(OPT_SOURCE_EDIT_COLORING))
                            pvaOut->lVal |= MESRCFLAGS_COLOR;
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SAVEATTACH_PATH:
                {
                    if (pvaIn && pvaIn->vt == VT_BSTR && pvaIn->bstrVal)
                    {
                        if (WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, rgch, MAX_PATH, NULL, NULL))
                            SetOption(OPT_SAVEATTACH_PATH, rgch, MAX_PATH, NULL, 0);
                    }
                    else if (pvaOut)
                    {
                        pvaOut->vt = VT_BSTR;
                        GetOption(OPT_SAVEATTACH_PATH, rgch, MAX_PATH);
                        hr = HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
                    } else
                        hr = E_INVALIDARG;
                    break;
                }

                case MEHOSTCMDID_UNSAFEATTACHMENTS:
                    if (pvaOut)
                    {
                        BOOL fEditMode = FALSE;

                        pvaOut->vt = VT_I4;
                        HrIsEditMode(&fEditMode);
                        if (fEditMode)      // allow open/save during edit/compose
                            pvaOut->lVal = 0;
                        else
                            pvaOut->lVal = DwGetOption(OPT_SECURITY_ATTACHMENT);
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SECURITY_ZONE:
                    if (pvaOut)
                    {
                        pvaOut->vt = VT_I4;
#ifdef FORCE_UNTRUSTED
                        pvaOut->lVal = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
                        if (DwGetOption(OPT_READ_IN_TEXT_ONLY))
                        {
                            // In text mode, never let scripts run.
                            pvaOut->lVal = URLZONE_UNTRUSTED;
                        }
                        else
                        {
                            pvaOut->lVal = DwGetOption(OPT_SECURITYZONE);
                        }
#endif // FORCE_UNTRUSTED
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SIGNATURE_ENABLED:
                {
                    Assert(pvaIn);
                    Assert(V_VT(pvaIn) == VT_I4);
                    hr = m_pBodyOptions->SignatureEnabled((V_I4(pvaIn) == MESIG_AUTO) ? TRUE : FALSE);
                    break;
                }

                case MEHOSTCMDID_SIGNATURE_OPTIONS:
                {
                    DWORD   outFlags = 0,
                            fBodyFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    m_pBodyOptions->GetSignature(NULL, &fBodyFlags, NULL);
                    if (fBodyFlags != 0)
                    {
                        outFlags = (fBodyFlags & SIGOPT_HTML) ? MESIGOPT_HTML : MESIGOPT_PLAIN;
                        if (fBodyFlags & SIGOPT_TOP)
                            outFlags |= MESIGOPT_TOP;
                        if (fBodyFlags & SIGOPT_PREFIX)
                            outFlags |= MESIGOPT_PREFIX;
                        if (fBodyFlags & SIGOPT_BOTTOM)
                            outFlags |= MESIGOPT_BOTTOM;
                    }
                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_SPELL_LANGUAGE:
                {
                    Assert(pvaOut);
                    pvaOut->vt = VT_BSTR;
                    
                    if (GetOption(OPT_SPELL_LANGID, rgch, ARRAYSIZE(rgch)))
                    {
                        hr = HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
                    }
                    else
                        hr = E_FAIL;
                    break;
                }

                case MEHOSTCMDID_SPELL_OPTIONS:
                {
                    DWORD   outFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    if (DwGetOption(OPT_SPELLIGNORENUMBER))
                        outFlags |= MESPELLOPT_IGNORENUMBER;
                    if (DwGetOption(OPT_SPELLIGNOREUPPER))
                        outFlags |= MESPELLOPT_IGNOREUPPER;
                    if (DwGetOption(OPT_SPELLIGNOREDBCS))
                        outFlags |= MESPELLOPT_IGNOREDBCS;
                    if (DwGetOption(OPT_SPELLIGNOREPROTECT))
                        outFlags |= MESPELLOPT_IGNOREPROTECT;
                    if (DwGetOption(OPT_SPELLIGNOREURL))
                        outFlags |= MESPELLOPT_IGNOREURL;
                    if (DwGetOption(OPT_SPELLALWAYSSUGGEST))
                        outFlags |= MESPELLOPT_ALWAYSSUGGEST;
                    if (DwGetOption(OPT_SPELLCHECKONSEND))
                        outFlags |= MESPELLOPT_CHECKONSEND;
                    if (DwGetOption(OPT_SPELLCHECKONTYPE))
                        outFlags |= MESPELLOPT_CHECKONTYPE;

                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_SIGNATURE:
                {
                    DWORD fFlags;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_BSTR;
                    hr = m_pBodyOptions->GetSignature(NULL, &fFlags, &V_BSTR(pvaOut));
                    break;
                }

                case MEHOSTCMDID_HEADER_TYPE:
                {
                    DWORD dwFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    if (dwFlags & BOPT_USEREPLYHEADER)
                    {
                        if (dwFlags & BOPT_MAIL)
                        {
                            V_I4(pvaOut) = MEHEADER_MAIL; 
                            if (DwGetOption(OPT_HARDCODEDHDRS))
                                V_I4(pvaOut) |= MEHEADER_FORCE_ENGLISH;
                        }
                        else
                            V_I4(pvaOut) = MEHEADER_NEWS; 
                    }
                    else
                        V_I4(pvaOut) = MEHEADER_NONE; 
                    break;
                }

                case MEHOSTCMDID_FLAGS:
                {
                    DWORD   outFlags = 0,
                            fBodyFlags;

                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    hr = m_pBodyOptions->GetFlags(&fBodyFlags);
                    if (SUCCEEDED(hr))
                    {
                        if (fBodyFlags & BOPT_INCLUDEMSG)
                            outFlags = MEO_FLAGS_INCLUDEMSG;
                        if ((fBodyFlags & BOPT_HTML) || m_fSecDispInfo)
                            outFlags |= MEO_FLAGS_HTML;

                        if (fBodyFlags & BOPT_AUTOINLINE &&
                            DwGetOption(OPT_AUTO_IMAGE_INLINE)!=AUTO_INLINE_OFF)
                        {
                            outFlags |= MEO_FLAGS_AUTOINLINE;
                            if (DwGetOption(OPT_AUTO_IMAGE_INLINE) == AUTO_INLINE_SLIDE)
                                outFlags |= MEO_FLAGS_SLIDESHOW;
                        }

                        if (fBodyFlags & BOPT_SENDIMAGES)
                            outFlags |= MEO_FLAGS_SENDIMAGES;
                        if (fBodyFlags & BOPT_AUTOTEXT)
                            outFlags |= MEO_FLAGS_AUTOTEXT;
                        if (fBodyFlags & BOPT_BLOCKQUOTE)
                            outFlags |= MEO_FLAGS_BLOCKQUOTE;
                        if (fBodyFlags & BOPT_SENDEXTERNALS)
                            outFlags |= MEO_FLAGS_SENDEXTERNALIMGSRC;
                        if (fBodyFlags & BOPT_SPELLINGOREORIGINAL)
                            outFlags |= MEO_FLAGS_DONTSPELLCHECKQUOTED;
                    }
                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_QUOTE_CHAR:
                {
                    BODYOPTINFO boi;
                    Assert(pvaOut);

                    boi.dwMask = BOPTF_QUOTECHAR;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    V_VT(pvaOut) = VT_I4;
                    V_I4(pvaOut) = boi.chQuote;
                    break;
                }

                case MEHOSTCMDID_REPLY_TICK_COLOR:
                {
                    BODYOPTINFO boi;
                    Assert(pvaOut);

                    boi.dwMask = BOPTF_REPLYTICKCOLOR;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    V_VT(pvaOut) = VT_I4;
                    V_I4(pvaOut) = boi.dwReplyTickColor;
                    break;
                }

                case MEHOSTCMDID_COMPOSE_FONT:
                {
                    BODYOPTINFO boi;
                    DWORD   fBodyFlags = 0;
                    Assert(pvaOut);

                    hr = m_pBodyOptions->GetFlags(&fBodyFlags);
                    if (SUCCEEDED(hr) && (fBodyFlags & BOPT_NOFONTTAG))
                    {
                        V_BSTR(pvaOut) = NULL;
                        break;
                    }

                    boi.dwMask = BOPTF_COMPOSEFONT;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    if (SUCCEEDED(hr))
                    {
                        V_VT(pvaOut) = VT_BSTR;
                        hr = HrLPSZToBSTR(boi.rgchComposeFont, &V_BSTR(pvaOut));
                    }
                    break;
                }

                case MEHOSTCMDID_IS_READ_IN_TEXT_ONLY:
                if (VT_BOOL == pvaOut->vt)
                {
                    pvaOut->boolVal = (DwGetOption(OPT_READ_IN_TEXT_ONLY) ? VARIANT_TRUE : VARIANT_FALSE);
                    hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
                break;

                case MEHOSTCMDID_HTML_HELP:
                {         
                    Assert(pvaOut);

                    V_VT(pvaOut) = VT_BOOL;
                    V_BOOL(pvaOut) = (m_fSecDispInfo || m_fShowingErrorPage)?VARIANT_TRUE:VARIANT_FALSE;
                    break;
                }

                default:
                    fCommandHandled = FALSE;
                    break;
            }
        }

        if (fCommandHandled)
            goto exit;

        switch (nCmdID)
        {
            case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
            {
                Assert(pvaIn);
                Assert(V_BSTR(pvaIn));
                hr = HrAddToWab(V_BSTR(pvaIn));
                break;
            }

            case MEHOSTCMDID_ADD_TO_FAVORITES:
            {
                BSTR bstrURL=0, bstrDescr=0;
                LONG l;

                Assert(pvaIn);
                
                l=0;
                IF_FAILEXIT(hr=SafeArrayGetElement(V_ARRAY(pvaIn), &l, &bstrDescr));
                l=1;
                IF_FAILEXIT(hr=SafeArrayGetElement(V_ARRAY(pvaIn), &l, &bstrURL));

                hr = HrAddToFavorites(bstrDescr, bstrURL);
                break;
            }

            case MEHOSTCMDID_SLIDESHOW_DELAY:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = 3000;  //In milleseconds
                break;
            }

            case MEHOSTCMDID_ONPARSECOMPLETE:
            {
                if (!m_fBlockingOnSMime)
                    OnDocumentReady();
                break;
            }

            case MEHOSTCMDID_FONTCACHE:
            {
                Assert(pvaOut);
                if (g_lpIFontCache)
                {
                    V_VT(pvaOut) = VT_UNKNOWN;
                    V_UNKNOWN(pvaOut) = g_lpIFontCache;
                    g_lpIFontCache->AddRef();
                } else
                    hr = E_FAIL;
                break;
            }

            case MEHOSTCMDID_BORDERFLAGS:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = m_dwBorderFlags;
                break;
            }

            // in the case where m_pBodyOptions is not initialized we're
            //  likely in a non-message window so just default to internet zone
            case MEHOSTCMDID_SECURITY_ZONE:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = URLZONE_INTERNET;
                break;
            }

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }
    else if (IsEqualGUID(CMDSETID_OESecurity, *pguidCmdGroup))
    {
        if ((OECSECCMD_ENCRYPTED == nCmdID) || (OECSECCMD_SIGNED == nCmdID))
        {
            if(m_pSecureMessage && (CheckSecReceipt(m_pSecureMessage) == S_OK))
            {
                hr = HrShowSecurityProperty(m_hwnd, m_pSecureMessage);
            }
            else
                hr = HrShowSecurityProperty(m_hwnd, m_pMsg);
        }

        else
            hr = OLECMDERR_E_NOTSUPPORTED;
    } else
        hr = OLECMDERR_E_NOTSUPPORTED;

exit:
    return hr;
}

HRESULT CMimeEditDocHost::HrAddToFavorites(BSTR bstrDescr, BSTR bstrURL)
{
    HRESULT     hr = E_FAIL;

    hr = AddUrlToFavorites(m_hwnd, bstrURL, bstrDescr, TRUE);
    if(FAILED(hr))
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrFavorites), NULL, MB_OK);        

    return (TraceResult(hr));
}

HRESULT CMimeEditDocHost::HrAddToWab(BSTR bstr)
{
    LPWAB           lpWab;
    HRESULT         hr;
    INT             idsErr=0;
    ADRINFO         AdrInfo;
    LPSTR           psz;

    hr = HrCreateWabObject(&lpWab);
    if (!FAILED(hr))
    {
        if (bstr)
        {
            ZeroMemory(&AdrInfo, sizeof(ADRINFO));
            AdrInfo.lpwszAddress = bstr;
            AdrInfo.lpwszDisplay = bstr;

            hr = lpWab->HrAddToWAB(m_hwnd, &AdrInfo);
            if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
            {
                if(hr==MAPI_E_COLLISION)
                    idsErr=idsErrAddrDupe;
                else
                    idsErr=idsErrAddToWAB;
            }

            if(idsErr)
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErr), NULL, MB_OK);
        }
        lpWab->Release();
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     WMSize
//
//  Synopsis:
//
//---------------------------------------------------------------
void CMimeEditDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    TraceCall("CMimeEditDocHost::WMSize");

    if(m_pDocView)
    {
        rc.bottom=cyBody;
        rc.right=cxBody;

        m_pDocView->SetRect(&rc);
    }

    // notify the subclass of a wmsize
    OnWMSize(&rc);
}
// *** IOleControlSite ***

//+---------------------------------------------------------------
//
//  Member:     OnControlInfoChanged
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnControlInfoChanged()
{
    TraceCall("CMimeEditDocHost::OnControlInfoChanged");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     LockInPlaceActive
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::LockInPlaceActive(BOOL fLock)
{
    TraceCall("CMimeEditDocHost::LockInPlaceActive");
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     GetExtendedControl
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    TraceCall("CMimeEditDocHost::GetExtendedControl");

    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TransformCoords
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    TraceCall("CMimeEditDocHost::TransformCoords");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
// Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    TraceCall("CMimeEditDocHost::TranslateAccelerator");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnFocus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnFocus(BOOL fGotFocus)
{
    HRESULT hr = S_OK;

    m_fUIActive = !!fGotFocus;
    if (m_pDocView)
        hr = m_pDocView->UIActivate(fGotFocus);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     ShowPropertyFrame
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ShowPropertyFrame(void)
{
    TraceCall("CMimeEditDocHost::ShowPropertyFrame");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnUpdateCommands
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUpdateCommands()
{
    TraceCall("CMimeEditDocHost::OnUpdateCommands");

    SendMessage(GetParent(m_hwnd), NWM_UPDATETOOLBAR, 0, 0);

    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::Load(LPMIMEMESSAGE pMsg)
{
    SECSTATE    secState = {0};
    DWORD       dw = 0;
    HRESULT     hr;

    m_fFixedFont = FALSE;

    RegisterForHTMLDocEvents(FALSE);

    m_fSecDispInfo = FALSE;      // reset flag
    m_fShowingErrorPage = FALSE;
    m_fSecureReceipt = FALSE;

    if(CheckSecReceipt(pMsg) == S_OK)
    {
        HrGetSecurityState(pMsg, &secState, NULL);
        m_fSecureReceipt = TRUE;
        m_fIsEncrypted = !!IsEncrypted(secState.type);
        m_fIsSigned = !!IsSigned(secState.type);
        m_fSignTrusted = !!IsSignTrusted(&secState);
        m_fEncryptionOK = !!IsEncryptionOK(&secState);
        hr = LoadSecurely(pMsg, &secState);
        CleanupSECSTATE(&secState);
    }
    else if (IsSecure(pMsg) && SUCCEEDED(HrGetSecurityState(pMsg, &secState, NULL)))
    {
        m_fIsEncrypted = !!IsEncrypted(secState.type);
        m_fIsSigned = !!IsSigned(secState.type);
        m_fSignTrusted = !!IsSignTrusted(&secState);
        m_fEncryptionOK = !!IsEncryptionOK(&secState);
        hr = LoadSecurely(pMsg, &secState);
        CleanupSECSTATE(&secState);
    }
    else
    {
        m_fIsEncrypted = FALSE;
        m_fIsSigned = FALSE;
        m_fSignTrusted = TRUE;
        m_fEncryptionOK = TRUE;
        hr = InternalLoad(pMsg);
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::InternalLoad(IMimeMessage *pMsg)
{
    SECSTATE    secState = {0};
    DWORD       dw = 0;
    HRESULT     hr;
    DWORD       dwBodyFlags = 0;
    BOOLEAN     fProcess = FALSE;

    ReplaceInterface(m_pMsg, pMsg);

    if(m_pBodyOptions)
    {
        m_pBodyOptions->GetFlags(&dwBodyFlags);
        
        m_fMarkedRead = (0 == (dwBodyFlags & BOPT_UNREAD));
        if (!m_fMarkedRead)
        {   
            if (!m_fSecDispInfo && !!(dwBodyFlags & BOPT_MAIL))
                fProcess = TRUE;

            if (dwBodyFlags & BOPT_FROM_NOTE)
            {
                //Since opening a message in a note, it should be marked as read immediately. 
                HrMarkAsRead();
            }
            else
            {
                // ReplaceInterface(m_pMsg, pMsg);

                if (m_pBodyOptions->GetMarkAsReadTime(&dw) == S_OK)
                {
                    if (dw == 0)
                        HrMarkAsRead();
                    else 
                    if (dw != OPTION_OFF)
                        SetTimer(m_hwnd, idTimerMarkAsRead, dw*1000, NULL);
                }
                else
                    HrMarkAsRead();
            }
        }
    }

    hr = m_pPrstMime->Load(m_pMsg);

    if ((fProcess) && !(dwBodyFlags & BOPT_FROM_NOTE) && SUCCEEDED(hr) && (m_pEventSink))
    {
        m_pEventSink->EventOccurred(MEHC_CMD_PROCESS_RECEIPT, m_pMsg);
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    DWORD       idsWarning;
    HRESULT     hr;

    Assert(m_pPrstMime);

    hr = m_pPrstMime->Save(pMsg, dwFlags);

    switch (hr)
    {
        case MIMEEDIT_E_CANNOTSAVEWHILESOURCEEDITING:
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCannotSaveInSourceEdit), NULL, MB_OK|MB_ICONEXCLAMATION);
            hr = MAPI_E_USER_CANCEL;
            break;

        // brettm: for OE5 we no longer warn if trident is not readystate complete. In the case of active movie controls 
        // they never go readyState complete 'by design' as they never loaded the source url. The warning is annoying for 
        // msphone message forwarding. for images we check individual readystates anyway.
        //case MIMEEDIT_W_DOWNLOADNOTCOMPLETE:
        
        case MIMEEDIT_W_BADURLSNOTATTACHED:
            if (IDYES != AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrBadMHTMLLinks), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                hr = MAPI_E_USER_CANCEL;
            break;

        case MIMEEDIT_E_CANNOTSAVEUNTILPARSECOMPLETE:
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrNotSaveUntilDownloadDone), NULL, MB_OK|MB_ICONEXCLAMATION);
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::GetClassID(CLSID *pClsID)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrOnDocObjCreate()
{
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetElement(LPCTSTR pszName, IHTMLElement **ppElem)
{
    return ::HrGetElementImpl(m_pDoc, pszName, ppElem);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSpellCheck(BOOL fSuppressDoneMsg)
{
    return m_pCmdTarget ? m_pCmdTarget->Exec(NULL, OLECMDID_SPELL,
        fSuppressDoneMsg ? OLECMDEXECOPT_DONTPROMPTUSER : OLECMDEXECOPT_PROMPTUSER , NULL, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPrint(BOOL fPrompt)
{
    VARIANTARG  va;
    HRESULT     hr;

    if (!m_pCmdTarget)
        return E_FAIL;

    va.vt = VT_BSTR;
    va.bstrVal = NULL;
    GetOEUserName(&va.bstrVal);
    hr = m_pCmdTarget->Exec(NULL, OLECMDID_PRINT, 
                                fPrompt ? OLECMDEXECOPT_PROMPTUSER : OLECMDEXECOPT_DONTPROMPTUSER, &va, NULL);

    SysFreeString(va.bstrVal);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsEmpty(BOOL *pfEmpty)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_EMPTY, pfEmpty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    KillTimer(m_hwnd, idTimerMarkAsRead);

    m_fIsEncrypted = FALSE;
    m_fIsSigned = FALSE;
    m_fSignTrusted = TRUE;
    m_fEncryptionOK = TRUE;

    HrInitNew(m_lpOleObj);

    if (idsDefaultBody)
    {
        LoadString(g_hLocRes, idsDefaultBody, rgch, ARRAYSIZE(rgch));
        HrSetText(rgch);
    }

    return S_OK;
}

// ********************************************
BOOL CMimeEditDocHost::WMCommand(HWND hwnd, int id, WORD wCmd)
{
    return SUCCEEDED(HrWMCommand(hwnd, id, wCmd));
}

// ********************************************
BOOL CMimeEditDocHost::WMNotify(int idFrom, NMHDR *pnmh)
{
    return FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsDirty(BOOL *pfDirty)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_DIRTY, pfDirty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetDirtyFlag(BOOL fDirty)
{
    return ExecSetBool(&CMDSETID_MimeEdit, MECMDID_DIRTY, fDirty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetStyle(DWORD dwStyle)
{
    HRESULT hr = ExecSetI4(&CMDSETID_MimeEdit, MECMDID_STYLE, dwStyle);

    if (SUCCEEDED(hr))
        m_dwDocStyle = dwStyle;

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetStyle(DWORD *pdwStyle)
{
    *pdwStyle = m_dwDocStyle;
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrEnableHTMLMode(BOOL fOn)
{
    BOOL    fEdit=FALSE;

    m_fFixedFont = FALSE;

    // if turning HTML mode on, turn on the source tabs
    if (fOn && HrIsEditMode(&fEdit)==S_OK && fEdit)
        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, DwGetOption(OPT_VIEWSOURCETABS));

    return ExecSetBool(&CMDSETID_MimeEdit, MECMDID_EDITHTML, fOn);
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsHTMLMode()
{
    ULONG   cmdf=0;
        
    QuerySingleMimeEditCmd(MECMDID_EDITHTML, &cmdf);
    return (cmdf & OLECMDF_LATCHED) ? S_OK :S_FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrDowngradeToPlainText()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetText(LPSTR lpsz)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    RegisterForHTMLDocEvents(FALSE);
    m_fShowingErrorPage = TRUE;

    if (HIWORD(lpsz)==0)
    {
        LoadString(g_hLocRes, LOWORD(lpsz), rgch, ARRAYSIZE(rgch));
        lpsz = rgch;
    }
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_SETTEXT, lpsz);
}

// ********************************************
HRESULT CMimeEditDocHost::HrPerformROT13Encoding()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_ROT13);
}

// ********************************************
HRESULT CMimeEditDocHost::LoadHtmlErrorPage(LPCSTR pszURL)
{
    HRESULT hr;
    LPSTR   pszUrlFree=NULL;

    // if relative, wrap in our res:// handler
    pszUrlFree = PszAllocResUrl((LPSTR)pszURL);
    if (!pszUrlFree)
        return E_OUTOFMEMORY;

    hr = HrLoadURL(pszUrlFree);
    if (SUCCEEDED(hr))
        RegisterForHTMLDocEvents(TRUE);

    m_fIsEncrypted = FALSE;
    m_fIsSigned = FALSE;
    m_fSignTrusted = TRUE;
    m_fEncryptionOK = TRUE;
    m_fShowingErrorPage = TRUE;

    SafeMemFree(pszUrlFree);
    return hr;
}

// ********************************************
// Base assumes that is URL to MHTML
HRESULT CMimeEditDocHost::HrLoadURL(LPCSTR pszURL)
{
    BSTR                bstr = NULL;
    IMoniker           *pMoniker = NULL;
    IPersistMoniker    *pPrstMnkr = NULL;
    HRESULT hr;

    hr = HrLPSZToBSTR(pszURL, &bstr);
    if (FAILED(hr))
        goto error;

    hr = CreateURLMoniker(NULL, bstr, &pMoniker);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMoniker, (LPVOID*)&pPrstMnkr);
    if (FAILED(hr))
        goto error;

    hr = pPrstMnkr->Load(FALSE, pMoniker, NULL, 0);

error:
    SysFreeString(bstr);
    SafeRelease(pMoniker);
    SafeRelease(pPrstMnkr);

    return hr;
}


// ********************************************
HRESULT CMimeEditDocHost::HrInsertTextFile(LPSTR lpsz)
{
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_INSERTTEXTFILE, lpsz);
}

// ********************************************
HRESULT CMimeEditDocHost::HrInsertTextFileFromDialog()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_INSERTTEXTFILE);
}

// ********************************************
HRESULT CMimeEditDocHost::HrViewSource(DWORD dwViewType)
{
    return ExecSetI4(&CMDSETID_MimeEdit, MECMDID_VIEWSOURCE, dwViewType);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetPreviewFormat(LPSTR lpsz)
{
    BSTR bstr;
    VARIANTARG var;
    
    if (!m_pCmdTarget)
        return E_FAIL;

    HRESULT hr = HrLPSZToBSTR(lpsz, &bstr);
    if (FAILED(hr))
        goto Exit;

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_PREVIEWFORMAT, OLECMDEXECOPT_DODEFAULT, &var, NULL);

    SysFreeString(bstr);
Exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetEditMode(BOOL fOn)
{
    ExecSetBool(&CMDSETID_MimeEdit, MECMDID_EDITMODE, fOn);

    if (fOn && HrIsHTMLMode()==S_OK)
        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, DwGetOption(OPT_VIEWSOURCETABS));
    
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsEditMode(BOOL *pfOn)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_EDITMODE, pfOn);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetCharset(HCHARSET hCharset)
{
    return ExecSetI8(&CMDSETID_MimeEdit, MECMDID_CHARSET, reinterpret_cast<ULONGLONG>(hCharset));
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetCharset(HCHARSET *phCharset)
{
    HRESULT     hr;
    ULONGLONG   ullCharset;
    
    hr = ExecGetI8(&CMDSETID_MimeEdit, MECMDID_CHARSET, &ullCharset);

    *phCharset = reinterpret_cast<HCHARSET>(ullCharset);
    
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSaveAsStationery(LPWSTR pwszFile)
{
    BSTR        bstr = NULL;
    VARIANTARG  varIn, 
                varOut;
    HRESULT     hr = S_OK;

    V_VT(&varOut) = VT_EMPTY;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    if (pwszFile)
    {
        IF_NULLEXIT(bstr = SysAllocString(pwszFile));
    }
    else
    {
        WCHAR wszPath[MAX_PATH];
        HrGetStationeryPath(wszPath);
        IF_NULLEXIT(bstr = SysAllocString(wszPath));
    }

    V_VT(&varIn) = VT_BSTR;
    V_BSTR(&varIn) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_SAVEASSTATIONERY, OLECMDEXECOPT_DODEFAULT, &varIn, &varOut));

    if (V_VT(&varOut) == VT_BSTR)
    {
        IF_FAILEXIT(hr = HrAddToStationeryMRU(V_BSTR(&varOut)));
    }

exit:
    SysFreeString(bstr);
    if (VT_EMPTY != V_VT(&varOut))
        SysFreeString(V_BSTR(&varOut));

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrApplyStationery(LPWSTR pwszFile)
{
    IStream            *pstm = NULL;
    IHTMLDocument2     *pDoc = NULL;
    HRESULT             hr = S_OK;
    VARIANTARG          var;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    // Apply stationery
    // if no filename in buffer, means No Stationery was called
    if (*pwszFile)
    {
        // Don't need to deal with the unicode stream issue when 
        // returning from HrCreateBasedWebPage in this case. There
        // are only a few attributes that are saved when applying
        // stationery and the ones we care about seem OK right now.
        IF_FAILEXIT(hr = HrCreateBasedWebPage(pwszFile, &pstm));

        IF_FAILEXIT(hr = MimeEditDocumentFromStream(pstm, IID_IHTMLDocument2, (LPVOID*)&pDoc));
    }

    var.vt = VT_UNKNOWN;
    var.punkVal = pDoc;
    IF_FAILEXIT(hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_APPLYDOCUMENT, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    ReleaseObj(pstm);
    ReleaseObj(pDoc);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrUpdateFormatBar()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrClearFormatting()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrMEDocHost_Init(BOOL fInit)
{
    WNDCLASSW    wc={0};

    if(fInit)
    {
        // RAID - 12563
        // We need to check to see if the class has been registered
        // already, because our DLL might get unloaded
        if (0 == GetClassInfoWrapW(g_hInst, c_wszMEDocHostWndClass, &wc))        // already regisered
        {
            wc.lpfnWndProc   = (WNDPROC)CMimeEditDocHost::ExtWndProc;
            wc.hInstance     = g_hInst;
            wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
            wc.lpszClassName = c_wszMEDocHostWndClass;
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
            wc.style = CS_DBLCLKS;

            if(!RegisterClassWrapW(&wc))
                return E_OUTOFMEMORY;
        }
    }
    else if (0 != GetClassInfoWrapW(g_hInst, c_wszMEDocHostWndClass, &wc))
        // don't need to enterCS for this, as it's the process going down.
        UnregisterClassWrapW(c_wszDocHostWndClass, g_hInst);

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPostInit()
{
    HRESULT hr = CreateDocObj((LPCLSID)&CLSID_MimeEdit);
    if (FAILED(hr))
        return hr;

    hr = Show();
    if(FAILED(hr))
        return hr;

    return HrOnDocObjCreate();
}

// ********************************************
HRESULT CMimeEditDocHost::HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions)
{
    HRESULT hr = S_OK;
    HWND    hwnd = 0;

    m_dwStyle=dwFlags;

    Assert(!m_pBodyOptions);
    if (pBodyOptions)
    {
        m_pBodyOptions = pBodyOptions;
        pBodyOptions->AddRef();
    }

    if(!IsWindow(hwndParent))
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr=HrMEDocHost_Init(TRUE));

    hwnd=CreateWindowExWrapW(WS_EX_NOPARENTNOTIFY,
                             c_wszMEDocHostWndClass, NULL,
                             WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP,
                             0,0,0,0, hwndParent,
                             (HMENU)idREBody, g_hInst, (LPVOID)this);
    IF_NULLEXIT(hwnd);

    IF_FAILEXIT(hr = HrCreateColorMenu(ID_FORMAT_COLOR1, &m_hmenuColor, FALSE));

    IF_FAILEXIT(hr = HrPostInit());

exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrClose()
{
    // Don't call HrUnloadAll on close as it's redundant to
    // clear out the contents with an InitNew. We simply force the docobj
    // down with it current content
    SafeRelease(m_pBodyOptions);
    CloseDocObj();
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetStatusBar(CStatusBar *pStatus)
{
    SafeRelease(m_pStatus);
    m_pStatus=pStatus;
    if(pStatus)
        pStatus->AddRef();

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrUpdateToolbar(HWND hwndToolbar)
{
    HRESULT hr=NOERROR;
    ULONG   cmdf=0;

    if(!IsWindow(hwndToolbar))
        return E_INVALIDARG;

    QuerySingleMimeEditCmd(MECMDID_INSERTHTML, &cmdf);

    if ((cmdf & OLECMDF_ENABLED) &&
        m_pBodyOptions &&
        m_pBodyOptions->SignatureEnabled(FALSE)==S_OK && m_fUIActive)
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_INSERT_SIGNATURE, MAKELONG(TRUE, 0));
    else
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_INSERT_SIGNATURE, 0);

    // if docobj has focus, query the command target to get info.
    if (m_fUIActive)
        hr=HrCmdTgtUpdateToolbar(m_pCmdTarget, hwndToolbar);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);
    Assert(*pcArrayCount > 0);

    IOleWindow     *pWindow = NULL;
    HWND            hWnd;

    *pcArrayCount = 0;

    HRESULT hr = m_pDoc->QueryInterface(IID_IOleWindow, (LPVOID *)&pWindow);
    if (FAILED(hr))
        goto error;

    hr = pWindow->GetWindow(&hWnd);
    if (FAILED(hr))
        goto error;

    *rgTSArray = hWnd;
    *pcArrayCount = 1;

error:
    SafeRelease(pWindow);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrInsertSignature(int id)
{
    char        szID[MAXSIGID], *pszID;
    HRESULT     hr=S_OK;
    BSTR        bstr;
    DWORD       dwSigOpt;

    if (!m_pCmdTarget)
        return E_FAIL;

    Assert((ID_INSERT_SIGNATURE == id) || (id >= ID_SIGNATURE_FIRST && id <= ID_SIGNATURE_LAST));
    Assert(m_pBodyOptions);

    if(!m_pBodyOptions)
        return E_FAIL;

    if ((ID_INSERT_SIGNATURE == id) || FAILED(GetSigFromCmd(id, szID)))
    {
        pszID = NULL;
    }
    else
    {
        pszID = szID;
    }

    if (m_pBodyOptions->SignatureEnabled(FALSE)==S_OK)
    {
        if (!FAILED(hr = m_pBodyOptions->GetSignature(pszID, &dwSigOpt, &bstr)))
        {
            DWORD cmd;
            VARIANTARG var;

            if ((dwSigOpt & SIGOPT_PREFIX) && (0 == (dwSigOpt & SIGOPT_HTML)))
            {
                BSTR    bstrPrefix;
                if (HrLPSZToBSTR(c_szSigPrefix, &bstrPrefix)==S_OK)
                {
                    UINT    sigLen = lstrlenW(bstr),
                            preLen = lstrlenW(bstrPrefix);

                    // SysAllocStringLen includes one for the NULL
                    BSTR    bstrTempBuf = SysAllocStringLen(bstrPrefix, preLen + sigLen);
                    if (bstrTempBuf)
                    {
                        memcpy((bstrTempBuf + preLen), bstr, (sigLen+1)*sizeof(*bstr));
                        SysFreeString(bstr);
                        bstr = bstrTempBuf;
                    }
                    SysFreeString(bstrPrefix);
                }
            }

            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = bstr;

            cmd = dwSigOpt&SIGOPT_HTML ? MECMDID_INSERTHTML : MECMDID_INSERTTEXT;
            hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL);

            SysFreeString(bstr);
        }
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrShow(BOOL fVisible)
{
    ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE);
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::ViewCertificate(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
{
    return CommonUI_ViewSigningCertificate(m_hwnd, pCert, hcMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::EditTrust(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
{
    return CommonUI_ViewSigningCertificateTrust(m_hwnd, pCert, hcMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::UpdateBackAndStyleMenus(HMENU hmenu)
{
    MENUITEMINFO    miiBk={0};
    MENUITEMINFO    miiBkColor={0};
    HMENU           hmenuTag=NULL;

    miiBk.cbSize=sizeof(MENUITEMINFO);
    miiBk.fMask = MIIM_ID | MIIM_SUBMENU;
    if (GetMenuItemInfo(hmenu, ID_POPUP_BACKGROUND_COLOR, FALSE, &miiBk))
    {
        HrCheckColor();
        miiBkColor.cbSize=sizeof(MENUITEMINFO);
        miiBkColor.fMask = MIIM_SUBMENU;
        miiBkColor.hSubMenu = m_hmenuColor;
        SetMenuItemInfo(hmenu, ID_POPUP_BACKGROUND_COLOR, FALSE, &miiBkColor);
    }

    if (!m_hmenuStyle)
    {
        Assert(m_pDoc);
        HrCreateTridentMenu(m_pDoc, TM_TAGMENU, ID_FORMAT_FIRST, ID_FORMAT_FIRST - ID_FORMAT_LAST, &m_hmenuStyle);
        Assert(m_hmenuStyle);
    }

    if(m_hmenuStyle)
    {
        VARIANTARG  va;        
        MENUITEMINFO miiTag={0};

        HrCheckTridentMenu(m_pDoc, TM_TAGMENU, ID_FORMAT_FIRST, ID_FORMAT_LAST, m_hmenuStyle);

        miiTag.cbSize=sizeof(MENUITEMINFO);
        miiTag.fMask = MIIM_SUBMENU;
        miiTag.hSubMenu = m_hmenuStyle;
        SetMenuItemInfo(hmenu, ID_POPUP_STYLE, FALSE, &miiTag);
    }
    return S_OK;
}

// ********************************************
void CMimeEditDocHost::UpdateInsertMenu(HMENU hmenu)
{
}

// ********************************************
void CMimeEditDocHost::UpdateEditMenu(HMENU hmenu)
{
}

// ********************************************
void CMimeEditDocHost::UpdateViewMenu(HMENU hmenu)
{
}

// ********************************************
HRESULT CMimeEditDocHost::HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID)
{
    if (m_pCmdTarget)
    {
        switch (uID)
        {
            case ID_POPUP_FILE:
                break;

            case ID_POPUP_FORMAT:
                break;

            case ID_POPUP_LANGUAGE:
            {
                // Now Let's try to insert document direction menu if applicable
                VARIANTARG v = {0};
                HRESULT hr;
                hr = m_pCmdTarget->Exec(&CGID_ShellDocView,SHDVID_GETDOCDIRMENU, OLECMDEXECOPT_DODEFAULT, NULL, &v);
                if (S_OK == hr)
                {
                     MENUITEMINFOW mii;
                     HMENU hmenuDocDir = (HMENU)IntToPtr(v.lVal);
                     UINT uItemDir = 0, uItem = GetMenuItemCount(hmenuPopup);                 
                     WCHAR wszText[MAX_PATH];

                     ZeroMemory(&mii, sizeof(MENUITEMINFO));
                     mii.cbSize = sizeof(MENUITEMINFO);                     
                     mii.cbSize = sizeof(MENUITEMINFO);
                     mii.fMask = MIIM_TYPE;
                     mii.fType = MFT_SEPARATOR;

                     InsertMenuItemWrapW(hmenuPopup, (UINT)uItem, TRUE, &mii);
        
                     mii.fMask = MIIM_CHECKMARKS|MIIM_DATA|MIIM_ID|MIIM_STATE|MIIM_SUBMENU|MIIM_TYPE;
                     mii.fType = MFT_STRING;
                     mii.dwTypeData = wszText;
                     mii.cch = MAX_PATH;

                     while (GetMenuItemInfoWrapW(hmenuDocDir, uItemDir, TRUE, &mii))
                     {
                         mii.wID = ID_DOCDIR_LTR + uItemDir;
                         mii.fType |= MFT_RADIOCHECK;
                         mii.cch = ARRAYSIZE(wszText);
                         InsertMenuItemWrapW(hmenuPopup, (UINT)(uItemDir + uItem + 1), TRUE, &mii);
                         uItemDir++;
                     }
                }
            }
                break;    
            
            case ID_POPUP_INSERT:
                UpdateInsertMenu(hmenuPopup);
                break;

            case ID_POPUP_EDIT:
                UpdateEditMenu(hmenuPopup);
                break;

            case ID_POPUP_VIEW:
                UpdateViewMenu(hmenuPopup);
                break;

            case ID_POPUP_TOOLS:
                break;

        }
    }
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szRes[CCHMAX_STRINGRES];

    if (!m_pStatus)
        return S_FALSE;

    if (LOWORD(wParam)>=ID_LANG_FIRST && LOWORD(wParam) <= ID_LANG_LAST)
    {
        m_pStatus->ShowSimpleText(MAKEINTRESOURCE(idsViewLanguageGeneralHelp));
        return S_OK;
    }

    if (LOWORD(wParam)>=ID_FORMAT_FIRST && LOWORD(wParam)<=ID_FORMAT_LAST)
    {
        // ~~~ did I choose the correct item for idsFmtTagGeneralHelp
        m_pStatus->ShowSimpleText(MAKEINTRESOURCE(ID_HELP_CONTENTS));
        return S_OK;
    }

    return S_FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrCheckColor()
{
    HRESULT     hr;
    INT         iFound = -1;
    DWORD       dwRGB;

    hr = ExecGetI4(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDCOLOR, &dwRGB);
    if (0 == dwRGB)
        iFound = 0;
    else
        iFound = GetColorIndex(dwRGB) - 1;

    CheckMenuRadioItem(m_hmenuColor, ID_FORMAT_COLOR1, ID_FORMAT_COLOR16, ID_FORMAT_COLOR1 + iFound, MF_BYCOMMAND);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis)
{
    // There is a bug in win95 that will sign extend the ID so that the
    // hiword is filled with FFFF. Take the low word of the ID to work
    // around this.
    UINT    id = LOWORD(pdis->itemID);

    if (id >= ID_FORMAT_COLOR1 && id <=ID_FORMAT_COLOR16)
        Color_WMDrawItem(pdis, iColorMenu);

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC     hdc;
    UINT    id = pmis->itemID;

    if (id >= ID_FORMAT_COLOR1 && id <=ID_FORMAT_COLOR16)
    {
        hdc = GetDC(hwnd);
        if(hdc)
        {
            Color_WMMeasureItem(hdc, pmis, iColorMenu);
            ReleaseDC( hwnd, hdc );
        }
    }
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrBackgroundImage()
{
    WCHAR   wszURL[INTERNET_MAX_URL_LENGTH+10];
    LPWSTR  pwszBackName;
    HRESULT hr = S_OK;

    *wszURL = 0;
    hr = ExecGetTextW(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, &pwszBackName);
    // ~~~ MimeEdit returns E_FAIL if no image found. MimeEdit will change to return S_OK is this case
    // Once it is changed can delete these lines.
    if (E_FAIL == hr)
        hr = S_OK;

    IF_FAILEXIT(hr);

    if (pwszBackName != NULL)
        StrCpyNW(wszURL, pwszBackName, INTERNET_MAX_URL_LENGTH);

    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddBkImage), m_hwnd, BkImageDlgProc, (LPARAM)wszURL)==IDCANCEL)
    {
        hr = S_OK;
        goto exit;
    }

    // nothing has been changed, so do nothing.
    if ((pwszBackName!=NULL && StrCmpIW(pwszBackName, wszURL)==0) ||
        // there is no background at all.
        (pwszBackName==NULL && lstrlenW(wszURL)==0))
        goto exit;

    InsertStationeryDir(wszURL);

    hr = ExecSetTextW(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, wszURL);

exit:
    MemFree(pwszBackName);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMCommand(HWND hwnd, int id, WORD wCmd)
{
    DWORD   dwStdCmd = 0,
            dwMECmd = 0,
            dwF3Cmd = 0;
    DWORD   dw;
    ULONG   cmdf;

    if(!m_pCmdTarget)
        return S_FALSE;

    // commands that don't care if we're UI Active

    if (id >= ID_FORMAT_COLOR1 && id <= ID_FORMAT_COLOR16)
    {
        int index = id - ID_FORMAT_COLOR1;
        ExecSetI4(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDCOLOR, rgrgbColors16[index]);
        return S_OK;
    }

    switch(id)
    {
        case ID_INSERT_TEXT:
            HrInsertTextFileFromDialog();
            return S_OK;

        case ID_SOURCE_EDIT:
            // toggle stat
            cmdf=0;
            QuerySingleMimeEditCmd(MECMDID_SHOWSOURCETABS, &cmdf);
            dw = !(cmdf & OLECMDF_LATCHED);
            SetDwOption(OPT_VIEWSOURCETABS, dw, 0, 0);
            ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, dw);
            return S_OK;

        case ID_SAVE_ATTACHMENTS:
        case ID_NOTE_SAVE_ATTACHMENTS:
            dwMECmd = MECMDID_SAVEATTACHMENTS;
            break;

        case ID_PRINT:
        case ID_PRINT_NOW:
            HrPrint(id == ID_PRINT);
            return S_OK;

        case ID_SAVE_STATIONERY:
        case ID_NOTE_SAVE_STATIONERY:
            HrSaveAsStationery(NULL);
            return S_OK;

        case ID_UNSCRAMBLE:
            HrPerformROT13Encoding();
            return S_OK;

        case ID_VIEW_MSG_SOURCE:
            HrViewSource(MECMD_VS_MESSAGE);
            return S_OK;

        case ID_VIEW_SOURCE:
            HrViewSource(MECMD_VS_HTML);
            return S_OK;

        case ID_BACKGROUND_SOUND:
            HrBackgroundSound();
            return S_OK;

        case ID_BACKGROUND_PICTURE:
            HrBackgroundImage();
            return S_OK;

        case ID_FIND_TEXT:
            dwStdCmd = OLECMDID_FIND;
            break;

        case ID_FONTS_DIALOG:
            dwMECmd = MECMDID_FORMATFONT;
            break;

        case ID_FORMAT_PARADLG:
            dwMECmd = MECMDID_FORMATPARAGRAPH;
            break;

        case ID_FONTS_LARGEST:
        case ID_FONTS_LARGE:
        case ID_FONTS_MEDIUM:
        case ID_FONTS_SMALL:
        case ID_FONTS_SMALLEST:
            dwF3Cmd = IDM_BASELINEFONT1 + id - ID_FONTS_SMALLEST;
            break;

        case ID_FONTS_FIXED:
            m_fFixedFont = !m_fFixedFont;
            if (m_fFixedFont)
                ExecSetBool(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT, TRUE);
            else
                m_pPrstMime->Load(m_pMsg);
            return S_OK;

        case ID_DOCDIR_LTR:
            dwF3Cmd = IDM_DIRLTR;
            break;
        case ID_DOCDIR_RTL:
            dwF3Cmd = IDM_DIRRTL;
            break;
    }

    // commands that are only applicable to UI if we're UIActive
    if(m_fUIActive)
    {
        if ((ID_INSERT_SIGNATURE == id) || (id >= ID_SIGNATURE_FIRST && id <= ID_SIGNATURE_LAST))
        {
            HrInsertSignature(id);
            return S_OK;
        }

        if (id >= ID_FORMAT_FIRST && id <= ID_FORMAT_LAST)
        {
            TCHAR szBuf[MAX_PATH];
            *szBuf = 0;
            GetMenuString(m_hmenuStyle, id, szBuf, MAX_PATH, MF_BYCOMMAND);
            Assert(*szBuf);//should not be empty

            SideAssert(ExecSetText(&CMDSETID_Forms3, IDM_BLOCKFMT, szBuf) == S_OK);
            return S_OK;
        }

        switch(id)
        {
            case ID_PASTE:
                if(HrPasteToAttachment()!=S_OK)
                    dwStdCmd = OLECMDID_PASTE;
                break;

            case ID_EDIT_LINK:
                return m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_HYPERLINK, 
                        OLECMDEXECOPT_PROMPTUSER, NULL, NULL);

            case ID_SELECT_ALL: 
                dwStdCmd = OLECMDID_SELECTALL;
                break;

            case ID_CUT:        
                dwStdCmd = OLECMDID_CUT; 
                break;

            case ID_COPY:       
                dwStdCmd = OLECMDID_COPY;
                break;

            case ID_NOTE_COPY:  
                dwStdCmd = OLECMDID_COPY;
                break;

            case ID_UNDO:       
                dwStdCmd = OLECMDID_UNDO;
                break;

            case ID_REDO:       
                dwStdCmd = OLECMDID_REDO;
                break;

            case ID_UNLINK:             
                dwF3Cmd = IDM_UNLINK;
                break;

            case ID_INSERT_PICTURE:  
                dwF3Cmd = IDM_IMAGE; 
                break;

            case ID_INSERT_LINE:        
                dwF3Cmd = IDM_HORIZONTALLINE;
                break;

            case ID_INDENT_INCREASE:    
                dwF3Cmd = IDM_INDENT; 
                break;

            case ID_INDENT_DECREASE:  
                dwF3Cmd = IDM_OUTDENT;
                break;

        }
    }

    // Catch all standard group commands and execute them
    if (dwStdCmd)
    {
        ExecCommand(NULL, dwStdCmd);
        return S_OK;
    }

    // Catch all MimeEdit group commands and execute them
    else if (dwMECmd)
    {
        ExecCommand(&CMDSETID_MimeEdit, dwMECmd);
        return S_OK;
    }

    // Catch all Forms3 group commands and execute them
    else if (dwF3Cmd)
    {
        ExecCommand(&CMDSETID_Forms3, dwF3Cmd);
        return S_OK;
    }

    return OLECMDERR_E_NOTSUPPORTED;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPasteToAttachment()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetWindow(HWND *pHwnd)
{
    if(pHwnd==NULL)
        return E_INVALIDARG;

    *pHwnd=m_hwnd;
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetSize(LPRECT prc)
{
    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrMarkAsRead()
{
    // ignore if already read
    if(!m_fMarkedRead && !m_fSecDispInfo)
    {
        if (m_pEventSink)
            m_pEventSink->EventOccurred(MEHC_CMD_MARK_AS_READ, NULL);
        m_fMarkedRead=TRUE;
    }

    return NOERROR;
}

// ********************************************
void CMimeEditDocHost::OnWMTimer()
{
    // user has been looking at the message for >2 secs,
    // mark message as read now.
    DOUTL(4, "MAR: Timer:: messages marked as read now");
    KillTimer(m_hwnd, idTimerMarkAsRead);
    HrMarkAsRead();
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetDragSource(BOOL fIsSource)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrTranslateAccelerator(LPMSG lpMsg)
{
    
    // this code will attempt to get ctrl-tab working in source-view
    // problem is we uideactivate trident and our host doesn't call our 
    // translateaccel is we're not uiactive. so we have to fudge activation.
    // I turned off for beta1
    if (lpMsg->message == WM_KEYDOWN && 
        (lpMsg->wParam == VK_TAB) &&
        (GetKeyState(VK_CONTROL)&0x8000))
        {
        // if showing the TAB's then control-tab should cycle them
        CycleSrcTabs(!(GetKeyState(VK_SHIFT)&0x8000));
        return S_OK;
        }

    if (!m_fUIActive || !m_pInPlaceActiveObj)
        return S_FALSE;

    return m_pInPlaceActiveObj->TranslateAccelerator(lpMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::HrUIActivate(BOOL fActivate)
{
    HRESULT             hr=NOERROR;

    if (m_pDocView)
        hr = m_pDocView->UIActivate(fActivate);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetUIActivate()
{

    SetFocus(m_hwndDocObj);
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrFrameActivate(BOOL fActivate)
{
    IOleInPlaceActiveObject     *pIPAO;

    // we QI mimeedit to make sure we always pass it the frame activates so it can disable sound playing
    // we can't use m_pInPlaceObject as it's only sent when we're UIActive.
    if (m_lpOleObj &&
        m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pIPAO)==S_OK)
    {
        pIPAO->OnFrameWindowActivate(fActivate);
        pIPAO->Release();
    }
    return S_OK;        
}

// ********************************************
HRESULT CMimeEditDocHost::HrHasFocus()
{
    return m_fUIActive ? S_OK : S_FALSE;
}

// ********************************************
void CMimeEditDocHost::EnableStandardCmd(UINT idm, LPBOOL pbEnable)
{
    OLECMD  cmdEdit;

    Assert(pbEnable);

    cmdEdit.cmdf=0;

    switch(idm)
    {
        case ID_CUT:
            cmdEdit.cmdID = OLECMDID_CUT;
            break;

        case ID_NOTE_COPY:
        case ID_COPY:
            cmdEdit.cmdID = OLECMDID_COPY;
            break;

        case ID_PASTE:
            cmdEdit.cmdID = OLECMDID_PASTE;
            break;

        case ID_SELECT_ALL:
            cmdEdit.cmdID = OLECMDID_SELECTALL;
            break;

        case ID_UNDO:
            cmdEdit.cmdID = OLECMDID_UNDO;
            break;

        default:
            // Should never get here.
            Assert(FALSE);
    }

    if (m_pCmdTarget && !FAILED(m_pCmdTarget->QueryStatus(NULL, 1, &cmdEdit, NULL)))
            *pbEnable = (cmdEdit.cmdf & OLECMDF_ENABLED);
}


// ********************************************
//  HrRegisterNotify:
//
//  Purpose:
//      Generic version of HrRegisterLoadNotify.  This allows
//      a client (like CSecMsgService) to give enough information
//      to become an event sink
//  Takes:
//      fRegister   - TRUE if we're calling Advise
//      szElement   - [OPTIONAL] if given, we'll get that IHTMLElement
//                    and use it for the IConnectionPointContainer
//      riidSink    - IID for the connection point to find
//      pUnkSink    - IUnknown of our sink object
//      pdwCookie   - [OUT] cookie needed for Unadvise
//  Returns:
//      Trident HRs.
//
HRESULT CMimeEditDocHost::HrRegisterNotify(
    BOOL        fRegister,
    LPCTSTR     szElement,
    REFIID      riidSink,
    IUnknown   *pUnkSink,
    DWORD      *pdwCookie)
{
    IConnectionPointContainer  *pCPContainer=0;
    IConnectionPoint           *pCP=0;
    IHTMLElement               *pElem=0;
    HRESULT                     hr;

    if (!m_pDoc || !pdwCookie)
        return E_POINTER;
    if (fRegister && !pUnkSink)
        return E_POINTER;

    if (szElement)
    {
        hr = HrGetElement(szElement, &pElem);
        if (SUCCEEDED(hr))
        {
            hr = pElem->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
            pElem->Release();
        }
    }
    else
    {
        hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    }
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(riidSink, &pCP);
    pCPContainer->Release();
    if (FAILED(hr))
        goto error;

    if (fRegister)
    {
        Assert(*pdwCookie == 0);

        hr = pCP->Advise(pUnkSink, pdwCookie);
        if (FAILED(hr))
            goto error;
    }
    else if (*pdwCookie)
    {
        hr = pCP->Unadvise(*pdwCookie);
        *pdwCookie = NULL;
    }

error:
    ReleaseObj(pCP);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::RegisterForHTMLDocEvents(BOOL fOn)
{
    if (fOn == !!m_fRegisteredForDocEvents)
        return S_OK;

    m_fRegisteredForDocEvents = !!fOn;

    return HrRegisterNotify(fOn, NULL, DIID_HTMLDocumentEvents2, 
                fOn ? ((IUnknown *)(IDispatch *)this) : NULL, 
                &m_dwHTMLNotifyCookie);
}

// ********************************************
HRESULT CMimeEditDocHost::PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    IDocHostUIHandler   *pDHHand = NULL;
    IServiceProvider    *pSP = NULL;
    HRESULT             hr = S_OK;

    // RAID 12020. Need to get IDocHostUIHandler of the body obj
    hr = m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID*)&pSP);
    if (SUCCEEDED(hr))
    {
        hr = pSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID*)&pDHHand);
        if (SUCCEEDED(hr))
        {
            hr = pDHHand->FilterDataObject(pDO, ppDORet);
            pDHHand->Release();
        }
        pSP->Release();
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSaveAttachment()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_SAVEATTACHMENTS);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetBkGrndPicture(LPTSTR pszPicture)
{
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, pszPicture);
}

// ********************************************
HRESULT CMimeEditDocHost::ShowContextMenu(
                DWORD dwID,
                POINT *ppt,
                IUnknown *pcmdtReserved,
                IDispatch *pdispReserved)
{
    return MIMEEDIT_E_DODEFAULT;
}
// ********************************************
HRESULT CMimeEditDocHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
                IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::HideUI()
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::UpdateUI()
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::EnableModeless(BOOL fActivate)
{
    // we don't have to support this, as any disable on a toplevel causes thread
    // windows to get disabled anyway
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::OnDocWindowActivate(BOOL fActivate)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::OnFrameWindowActivate(BOOL fActivate)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    TCHAR   szPath[MAX_PATH];
    // dupW uses CoTaskMemAlloc
    lstrcpy(szPath, MU_GetRegRoot());
    lstrcat(szPath, c_szTrident);

    *pchKey = PszToUnicode(CP_ACP, szPath);
    if (szPath && !(*pchKey))
        return (TraceResult(E_OUTOFMEMORY));

    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    BOOL fEditModeOn = FALSE;
    if (FAILED(HrIsEditMode(&fEditModeOn)) || !fEditModeOn)
        return S_FALSE;

    *ppDropTarget = (IDropTarget*)SendMessage(GetParent(m_hwnd), NWM_GETDROPTARGET, (WPARAM)pDropTarget, 0);
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::GetExternal(IDispatch **ppDispatch)
{
    return QueryInterface(IID_IDispatch, (LPVOID *)ppDispatch);
}

// ********************************************
HRESULT CMimeEditDocHost::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::FilterDataObject( IDataObject *pDO, IDataObject **ppDORet)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
        OnReadyStateChanged();
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::OnRequestEdit (DISPID dispid)
{
    return S_OK;
}


// ********************************************
void CMimeEditDocHost::OnDocumentReady()
{
    NMHDR   nmhdr;

    // Bug 74697
    // Under certain circumstances, Darwin causes Trident to send us IDM_PARSECOMPLETE
    // when we don't even have a message.  To prevent spurious errors, bail out.
    if (!m_pMsg)
        return;

    if(m_fSecDispInfo)
    {
        VARIANTARG  va;

        if(!m_pCmdTarget)
            return;

        if(m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK &&
            va.lVal == MESTYLE_PREVIEW)
            return;

        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_TABLINKS, TRUE);

        return;
    }

    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = GetDlgCtrlID(m_hwnd);
    nmhdr.code = BDN_DOWNLOADCOMPLETE;
    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetBool(const GUID *guid, DWORD cmd, BOOL *pfValue)
{
    VARIANTARG var;
    V_VT(&var) = VT_BOOL;

    if (!m_pCmdTarget)
        return E_FAIL;

    HRESULT hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var);
    if (SUCCEEDED(hr))
        *pfValue = (VARIANT_TRUE == V_BOOL(&var)) ? TRUE : FALSE;
    else
        *pfValue = FALSE;

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetBool(const GUID *guid, DWORD cmd, BOOL fValue)
{
    VARIANTARG var;

    if (!m_pCmdTarget)
        return E_FAIL;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fValue ? VARIANT_TRUE : VARIANT_FALSE;

    return m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL);
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetI4(const GUID *guid, DWORD cmd, DWORD *pdwValue)
{
    VARIANTARG var;
    HRESULT hr;
    V_VT(&var) = VT_I4;

    hr = m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var) : E_FAIL;

    *pdwValue = (SUCCEEDED(hr) ? V_I4(&var) : 0);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetI4(const GUID *guid, DWORD cmd, DWORD dwValue)
{

    VARIANTARG var;
    V_VT(&var) = VT_I4;
    V_I4(&var) = dwValue;

    return  m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetI8(const GUID *guid, DWORD cmd, ULONGLONG *pullValue)
{
    VARIANTARG var;
    HRESULT hr;
    V_VT(&var) = VT_I8;

    hr = m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var) : E_FAIL;

    *pullValue = (SUCCEEDED(hr) ? V_UNION(&var, ullVal) : 0);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetI8(const GUID *guid, DWORD cmd, ULONGLONG ullValue)
{

    VARIANTARG var;
    V_VT(&var) = VT_I8;
    V_UNION(&var, ullVal) = ullValue;

    return  m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetText(const GUID *guid, DWORD cmd, LPSTR psz)
{
    BSTR        bstr = NULL;
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);
    
    IF_FAILEXIT(hr = HrLPSZToBSTR(psz, &bstr));

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    SysFreeString(bstr);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetTextW(const GUID *guid, DWORD cmd, LPWSTR pwsz)
{
    BSTR        bstr = NULL;
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);
    
    IF_NULLEXIT(bstr = SysAllocString(pwsz));

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    SysFreeString(bstr);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetText(const GUID *guid, DWORD cmd, LPSTR *ppsz)
{
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    *ppsz = NULL;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var));

    Assert(V_VT(&var) == VT_BSTR);
    hr = HrBSTRToLPSZ(CP_ACP, V_BSTR(&var), ppsz);
    SysFreeString(V_BSTR(&var));

    IF_FAILEXIT(hr);

exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetTextW(const GUID *guid, DWORD cmd, LPWSTR *ppwsz)
{
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    V_VT(&var) = VT_EMPTY;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    *ppwsz = NULL;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var));

    Assert(V_VT(&var) == VT_BSTR);
    IF_NULLEXIT(*ppwsz = PszDupW(V_BSTR(&var)));

exit:
    if (VT_EMPTY != V_VT(&var))
        SysFreeString(V_BSTR(&var));
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecCommand(const GUID *guid, DWORD cmd)
{
    if (!m_pCmdTarget)
        return E_FAIL;

    return m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
}

// ********************************************
void CMimeEditDocHost::OnReadyStateChanged()
{
    // MimeEdit keeps track of state for us. Left
    // this in in case there is a need to have it
    // in the future.
}

HRESULT CMimeEditDocHost::HrHandsOffStorage()
{
    if (m_pMsg)
        m_pMsg->HandsOffStorage();
    if (m_pSecureMessage)
        m_pSecureMessage->HandsOffStorage();
    if (m_pSecurityErrorScreen)
        m_pSecurityErrorScreen->HandsOffStorage();
    return S_OK;
}

HRESULT CMimeEditDocHost::HrRefresh()
{
    if (m_pCmdTarget)
        ExecCommand(NULL, OLECMDID_REFRESH);

    return S_OK;
}


HRESULT CMimeEditDocHost::HrBackgroundSound()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_INSERTBGSOUND);
}


HRESULT CMimeEditDocHost::QuerySingleMimeEditCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT CMimeEditDocHost::QuerySingleFormsCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT CMimeEditDocHost::QuerySingleStdCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(NULL, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
//  IDispatch
//
/////////////////////////////////////////////////////////////////////////////

// This is a really lightweight IDispatch implementation.  We only expect
// to get invoked.  Trident will call IDispatch::Invoke with the dispID
// of the event that happened or property that changed.

STDMETHODIMP CMimeEditDocHost::GetIDsOfNames(
    REFIID      riid,
    OLECHAR **  rgszNames,
    UINT        cNames,
    LCID        lcid,
    DISPID *    rgDispId)
{
    if (cNames==1 && StrCmpIW(rgszNames[0], L"hotmail")==0)
    {
        rgDispId[0] = 666;
        return S_OK;
    }
    return E_NOTIMPL;
}

STDMETHODIMP CMimeEditDocHost::GetTypeInfo(
    UINT        /*iTInfo*/,
    LCID        /*lcid*/,
    ITypeInfo **ppTInfo)
{
    if (ppTInfo)
        *ppTInfo=NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CMimeEditDocHost::GetTypeInfoCount(UINT *pctinfo)
{
    if (pctinfo)
    {
        *pctinfo=0;
        return NOERROR;
    }
    else
        return E_POINTER;
}

STDMETHODIMP CMimeEditDocHost::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            wFlags,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       pVarResult,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    IHTMLWindow2        *pWindow=0;
    IHTMLEventObj       *pEvent=0;
    IHTMLElement        *pElem=0;
    BSTR                bstr=0;
    HRESULT             hr=E_NOTIMPL;


    if (dispIdMember == 666 && 
        wFlags & DISPATCH_PROPERTYGET)
    {
        // hotmail on/off for welcome message
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = HideHotmail() ? VARIANT_FALSE : VARIANT_TRUE;
        return S_OK;
    }
    // Currently we only care about the button clicks.
    if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONCLICK &&
        (wFlags & DISPATCH_METHOD))
    {
        // Order of events:
        // document gives us window gives us event object
        // the event object can tell us which button was clicked
        // event gives us source element gives us ID
        // a couple lstrcmps will tell us which one got hit
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_srcElement(&pElem);
                if (pElem)
                {
                    pElem->get_id(&bstr);
                    if (bstr)
                    {
                        hr = HandleButtonClicks(bstr);
                        SysFreeString(bstr);
                    }
                    pElem->Release();
                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    }
    return hr;
}

HRESULT CMimeEditDocHost::SetEventSink(IMimeEditEventSink *pEventSink)
{
    ReplaceInterface(m_pEventSink, pEventSink);
    return S_OK;
}


typedef struct tagCOMMANDSTRUCT {
    WCHAR  *string;
    DWORD   id;
} COMMANDSTRUCT, *LPCOMMANDSTRUCT;

COMMANDSTRUCT rgszCmdStrings[] = 
{
    {L"btnOpen",        MEHC_BTN_OPEN},
    {L"btnCert",        MEHC_BTN_CERT},
    {L"btnTrust",       MEHC_BTN_TRUST},
    {L"btnContinue",    MEHC_BTN_CONTINUE},
    {L"cmdConnect",     MEHC_CMD_CONNECT},
    {L"cmdDownload",    MEHC_CMD_DOWNLOAD},
};

HRESULT CMimeEditDocHost::HandleButtonClicks(BSTR bstr)
{
    HRESULT         hr = S_OK;
    LPCOMMANDSTRUCT prg = rgszCmdStrings;
    DWORD           cmdID=0;
    BOOL            fFound = FALSE;

    Assert(bstr);

    for (int i = 0; i < ARRAYSIZE(rgszCmdStrings); i++, prg++)
    {
        if (!StrCmpW(prg->string, bstr))
        {
            cmdID = prg->id;
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        // The notification needs to happen after the preview pane 
        // updates.  Since there's no notifications here that actually
        // return anything but S_FALSE I think this is pretty safe.
        //   -- From "The famous last words of Steve Serdy"
        switch (cmdID)
        {
            case MEHC_BTN_OPEN: 
                hr = DoHtmlBtnOpen(); 
                // Now we need update toolbar
                m_pEventSink->EventOccurred(cmdID, NULL);
                break;

            case MEHC_BTN_CERT:
            case MEHC_BTN_TRUST:
                hr = DoHtmlBtnCertTrust(cmdID);
                break;

            case MEHC_BTN_CONTINUE:
                hr = DoHtmlBtnContinue();
                break;

            default:
                hr = E_NOTIMPL;
        }

        if (m_pEventSink && (cmdID != MEHC_BTN_OPEN))
            hr = m_pEventSink->EventOccurred(cmdID, NULL);
    }

    return hr;
}

HRESULT CMimeEditDocHost::DoHtmlBtnOpen(void)
{
    IHTMLElement *  pElem = NULL;
    HRESULT hr;

    m_fSecDispInfo = FALSE;
    // this process is non-critical; don't save errors
    HrGetElementImpl(m_pDoc, c_szHTMLIDchkShowAgain, &pElem);
    if (pElem)
    {
        VARIANT_BOOL    boolVal;

        HrGetSetCheck(FALSE, pElem, &boolVal);
        SafeRelease(pElem);

        if (VARIANT_TRUE == boolVal)
        {
            NMHDR   nmhdr;

            nmhdr.hwndFrom=m_hwnd;
            nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
            nmhdr.code=BDN_MARKASSECURE;
            SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
        }
    }

    AssertSz(m_pSecureMessage, "Secure message should be set at this point");
    hr = InternalLoad(m_pSecureMessage);
    SafeRelease(m_pSecureMessage);

    return hr;
}

HRESULT CMimeEditDocHost::DoHtmlBtnCertTrust(DWORD cmdID)
{
    IMimeBody      *pRoot = NULL;
    HRESULT         hr = S_OK;
    HBODY               hBody = NULL;
    SECSTATE            SecState ={0};

    if(FAILED(HrGetSecurityState(m_pSecureMessage, &SecState, &hBody)))
        return(hr);

    CleanupSECSTATE(&SecState);

    AssertSz(m_pSecureMessage, "Should have a secure message if getting Cert or Trust");
    hr = m_pSecureMessage->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pRoot);
    if (pRoot)
    {
        PROPVARIANT     var;
        HCERTSTORE      hcStore = NULL;

#ifdef _WIN64
        if (SUCCEEDED(pRoot->GetOption(OID_SECURITY_HCERTSTORE_64, &var)) && (var.vt == VT_UI8)) 
            hcStore = (HCERTSTORE)(var.pulVal);

        hr = pRoot->GetOption(OID_SECURITY_CERT_SIGNING_64, &var);
        if (SUCCEEDED(hr))
        {
            if ((PCCERT_CONTEXT)(var.pulVal)) 
            {
                if (MEHC_BTN_CERT == cmdID)
                    // View digital Cert was clicked
                    hr = ViewCertificate((PCCERT_CONTEXT)(var.pulVal), hcStore);
                else
                    // Edit Trust was clicked
                    hr = EditTrust((PCCERT_CONTEXT)(var.pulVal), hcStore);

                CertFreeCertificateContext((PCCERT_CONTEXT)(var.pulVal));
            }
        }
#else   // !_WIN64
        if (SUCCEEDED(pRoot->GetOption(OID_SECURITY_HCERTSTORE, &var)) && (var.vt == VT_UI4)) 
            hcStore = (HCERTSTORE)var.ulVal;
        hr = pRoot->GetOption(OID_SECURITY_CERT_SIGNING, &var);
        if (SUCCEEDED(hr))
        {
            if ((PCCERT_CONTEXT)var.ulVal) 
            {
                if (MEHC_BTN_CERT == cmdID)
                    // View digital Cert was clicked
                    hr = ViewCertificate((PCCERT_CONTEXT)var.ulVal, hcStore);
                else
                    // Edit Trust was clicked
                    hr = EditTrust((PCCERT_CONTEXT)var.ulVal, hcStore);

                CertFreeCertificateContext((PCCERT_CONTEXT )var.ulVal);
            }
        }
#endif  // _WIN64
        SafeRelease(pRoot);
        if (hcStore)
            CertCloseStore(hcStore, 0);
    }

    return hr;
}


HRESULT CMimeEditDocHost::HrScrollPage()
{
    IHTMLWindow2        *pWindow=0;
    IHTMLBodyElement    *pBody;
    IHTMLElement2       *pElem;
    LONG                cyClientHeight=0,
                        cyScrollTop=0,
                        cyScrollHeight=0;
    HRESULT             hr = E_FAIL;

    if (m_pDoc)
        m_pDoc->get_parentWindow(&pWindow);

    if (pWindow)
    {
        if (HrGetBodyElement(m_pDoc, &pBody)==S_OK)
        {
            if (pBody->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElem)==S_OK)
            {
                pElem->get_clientHeight(&cyClientHeight);
                pElem->get_scrollTop(&cyScrollTop);
                pElem->get_scrollHeight(&cyScrollHeight);

                if (!(cyScrollTop + cyClientHeight >= cyScrollHeight))
                {
                    pWindow->scrollBy(0, cyClientHeight);
                    hr = S_OK;
                }
                
                pElem->Release();
            }
            pBody->Release();
        }
        pWindow->Release();
    }
    return hr;
}



HRESULT CMimeEditDocHost::DoHtmlBtnContinue(void)
{
    HRESULT         hr;
    IHTMLElement   *pElem = NULL;

    // this process is non-critical; don't save errors
    HrGetElementImpl(m_pDoc, c_szHTMLIDchkShowAgain, &pElem);
    if (pElem)
    {
        VARIANT_BOOL boolVal;

        HrGetSetCheck(FALSE, pElem, &boolVal);
        if (VARIANT_TRUE == boolVal)
        {
            if (m_fIsSigned)
                SetDontShowAgain(1, c_szDSDigSigHelp);
            if (m_fIsEncrypted)
                SetDontShowAgain(1, c_szDSEncryptHelp);
        }

        pElem->Release();
    }

    if (m_pSecurityErrorScreen)
    {
        m_fSecDispInfo = TRUE;
        hr = InternalLoad(m_pSecurityErrorScreen);
        SafeRelease(m_pSecurityErrorScreen);
    }
    else
    {
        m_fSecDispInfo = FALSE;
        AssertSz(m_pSecureMessage, "Secure message should be set at this point.");
        hr = InternalLoad(m_pSecureMessage);
        RegisterForHTMLDocEvents(FALSE);
        SafeRelease(m_pSecureMessage);
    }

    return hr;
}

HRESULT CopySecurePropsToMessage(IMimeMessage *pDestMsg, IMimePropertySet *pPropSet)
{
    IMimePropertySet   *pNewProps = NULL;
    HRESULT             hr;

    hr = pDestMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pNewProps);
    if (SUCCEEDED(hr))
    {
        hr = pPropSet->CopyProps(0, NULL, pNewProps);
        pNewProps->Release();
    }
    return hr;
}

LPCSTR rgszHdrKeep[] = {
            PIDTOSTR(PID_HDR_NEWSGROUP),
            PIDTOSTR(PID_HDR_NEWSGROUPS),
            PIDTOSTR(PID_HDR_SUBJECT),
            PIDTOSTR(PID_HDR_FROM),
            PIDTOSTR(PID_HDR_APPARTO),
            PIDTOSTR(PID_HDR_DATE),
            PIDTOSTR(PID_HDR_REPLYTO),
            PIDTOSTR(PID_HDR_TO),
            PIDTOSTR(PID_HDR_CC),
            PIDTOSTR(PID_HDR_APPROVED),
            PIDTOSTR(PID_HDR_DISTRIB),
            PIDTOSTR(PID_HDR_KEYWORDS),
            PIDTOSTR(PID_HDR_ORG),
            PIDTOSTR(PID_HDR_XMSPRI),
            PIDTOSTR(PID_HDR_XPRI),
            PIDTOSTR(PID_HDR_COMMENT),
            PIDTOSTR(PID_HDR_SENDER)};

HRESULT CMimeEditDocHost::LoadSecurely(IMimeMessage *pMsg, SECSTATE *pSecState)
{
    HRESULT         hr=S_OK;
    BOOL            fNeedIntroScreen = FALSE,
                    fNeedErrorScreen = FALSE,
                    fRegisterDispatch = FALSE;
    LPCTSTR         szIntroResName=NULL;
    IMimeMessage   *pSecurityIntroScreen = NULL;
    DWORD           dwFlags = 0;

    // Since we are reloading, go ahead and free the original secure message if there is one.
    SafeRelease(m_pSecureMessage);
    SafeRelease(m_pSecurityErrorScreen);

    // N2 delete schema
    if (g_dwSecurityCheckedSchemaProp)
    {
        PROPVARIANT var;
        var.vt = VT_UI4;
        if (SUCCEEDED(pMsg->GetBodyProp(HBODY_ROOT, PIDTOSTR(g_dwSecurityCheckedSchemaProp), 0, &var)))
        {
            if (1 == var.lVal)
                goto LoadMessage;
        }
    }

    m_pBodyOptions->GetFlags(&dwFlags);

    if(!m_fSecureReceipt)
    {
        if (0 == (dwFlags & BOPT_SECURITYUIENABLED))
            goto LoadMessage;

        if (m_fIsSigned)
        {
            // don't need warning UI if the cert is trusted and the message is okay
            fNeedErrorScreen = (!m_fSignTrusted && !(dwFlags & BOPT_REPLYORFORWARD));

            // If sig is valid, we should update any certs and SMIMECapabilities in the address book.
            if (m_fSignTrusted && (DwGetOption(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB))) 
            {
                FILETIME ftNull = {0};

                HrAddSenderCertToWab(NULL, pMsg, NULL, NULL, NULL, ftNull, WFF_CREATE);
            }

        // check for help UI
            szIntroResName = c_szDigSigHelpHTML;
            fNeedIntroScreen = ((0 == DwGetDontShowAgain(c_szDSDigSigHelp)) && !(dwFlags & BOPT_REPLYORFORWARD));
        }

        if (m_fIsEncrypted)
        {
            fNeedErrorScreen |= (!m_fEncryptionOK && !(dwFlags & BOPT_REPLYORFORWARD));

            // If want signed intro, don't need to test this one.
            if (!fNeedIntroScreen)
                fNeedIntroScreen = ((0 == DwGetDontShowAgain(c_szDSEncryptHelp)) && !(dwFlags & BOPT_REPLYORFORWARD));

            szIntroResName = (m_fIsSigned ? c_szSAndEHelpHTML : c_szEncryptHelpHTML);
        }
        
        // Bug 2557 - prevent error screen when secure reciept request
        if(pSecState->type & MST_RECEIPT_REQUEST)
            fNeedIntroScreen = FALSE;

        if (fNeedIntroScreen && szIntroResName)
        {
            // Since this is only for the opening screen, if things error, allow
            // the user to continue. In order to allow this, will use a temporary hr.
            HRESULT tempHR;
            IStream *pStm = NULL;

            tempHR = LoadResourceToHTMLStream(szIntroResName, &pStm);
            if (SUCCEEDED(tempHR))
                tempHR = HrCreateMessage(&pSecurityIntroScreen);
            if (SUCCEEDED(tempHR))
                tempHR = pSecurityIntroScreen->Load(pStm);

            ReleaseObj(pStm);

            // If there was an error, don't show the screen and NULL the var
            if (FAILED(tempHR))
                SafeRelease(pSecurityIntroScreen);
        }

        if (fNeedErrorScreen)
        {
            // If have problems here, must exit. Can't show message before showing
            // this error screen.
            IStream *pStm = NULL;

            // Disable check box if message not from the store.
            hr = HrOutputSecurityScript(&pStm, pSecState, (0 == (BOPT_FROMSTORE & dwFlags))); 

            if (SUCCEEDED(hr))
                hr = HrCreateMessage(&m_pSecurityErrorScreen);

            if (SUCCEEDED(hr))
                hr = m_pSecurityErrorScreen->Load(pStm);

            ReleaseObj(pStm);

            if (FAILED(hr))
                SafeRelease(m_pSecurityErrorScreen);
        }
    }
    else
    {
        IImnAccount * pAcct = NULL;
        TCHAR       *pszSubject = NULL;
        TCHAR       *pszFrom = NULL;
        FILETIME    ftSigningTime;
        FILETIME    ftSentTime;
        IStream *pStm = NULL;

        SECSTATE    secStateRec = {0};
//        DWORD       dw = 0;

        // Get account for receipt
        if(m_pBodyOptions->GetAccount(&pAcct) == S_OK)
        {
            // Find original meassage and get information from receipt and orig msg
            hr = HandleSecReceipt(pMsg, pAcct, m_hwnd, &pszSubject, &pszFrom, &ftSentTime, &ftSigningTime);
        }
        else
            hr = MIME_E_SECURITY_RECEIPT_CANTFINDSENTITEM;

            HrGetSecurityState(pMsg, &secStateRec, NULL);
            m_fSignTrusted = !!IsSignTrusted(&secStateRec);

            if(hr == S_OK)
                hr = HrOutputSecureReceipt(&pStm, pszSubject, pszFrom, &ftSentTime, &ftSigningTime, &secStateRec); 
            else if(hr == MIME_S_RECEIPT_FROMMYSELF)
                hr = HrOutputUserSecureReceipt(&pStm, pMsg); 
            else
                hr = HrOutputErrSecReceipt(&pStm, hr, &secStateRec); 

            // Display receipt
            if (SUCCEEDED(hr))
            {
                SafeRelease(m_pSecurityErrorScreen);
                hr = HrCreateMessage(&m_pSecurityErrorScreen);
            }

            
            if (SUCCEEDED(hr))
            {
#ifdef YST
                HBODY       hBody = 0;
                ReplaceInterface(m_pSecurityErrorScreen, pMsg);
                m_pSecurityErrorScreen->SetTextBody(TXT_HTML, IET_CURRENT, NULL, pStm, &hBody);
                HrRemoveAttachments(m_pSecurityErrorScreen, FALSE);
#endif // YST
                hr = m_pSecurityErrorScreen->Load(pStm);
            }

            ReleaseObj(pStm);

            if (FAILED(hr))
                SafeRelease(m_pSecurityErrorScreen);

            // If sig is valid, we should update any certs and SMIMECapabilities in the address book.
            if (m_fSignTrusted && (DwGetOption(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB))) 
            {
                FILETIME ftNull = {0};

                HrAddSenderCertToWab(NULL, pMsg, NULL, NULL, NULL, ftNull, WFF_CREATE);
            }

            CleanupSECSTATE(&secStateRec);
            SafeMemFree(pszSubject);
            SafeMemFree(pszFrom);
            ReleaseObj(pAcct);
    }

    // Reset  m_pSecureMessage before continue
    if(m_pSecureMessage)
        SafeRelease(m_pSecureMessage);

    // If we didn't get any errors and we have some screens 
    // to add, copy props from original message into other screens
    if (SUCCEEDED(hr) && (m_pSecurityErrorScreen || pSecurityIntroScreen))
    {
        IMimePropertySet   *pPropSet = NULL;

        fRegisterDispatch = TRUE;
        ReplaceInterface(m_pSecureMessage, pMsg);

        // Move over the headers
        // If the bind fails, don't worry about it. Just means the headers won't be
        // visable until the normal message is loaded.
        if (SUCCEEDED(m_pSecureMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropSet)))
        {
            IMimePropertySet *pCopyProps = NULL;
            if (SUCCEEDED(pPropSet->Clone(&pCopyProps)))
            {
                if (SUCCEEDED(pCopyProps->DeleteExcept(ARRAYSIZE(rgszHdrKeep), rgszHdrKeep)))
                {
                    if (pSecurityIntroScreen)
                        CopySecurePropsToMessage(pSecurityIntroScreen, pCopyProps);
                    if (SUCCEEDED(hr) && m_pSecurityErrorScreen)
                        CopySecurePropsToMessage(m_pSecurityErrorScreen, pCopyProps);
                }                
                pCopyProps->Release();
            }
            pPropSet->Release();
        }

        // need to init the property
        //N8 talk to Opie about this schema thing.
        // I didn't understand the property concept when I did this.  It
        // works fine, but is too big a hammer for the job.
        if (SUCCEEDED(hr) && !g_dwSecurityCheckedSchemaProp)
        {
            IMimePropertySchema *pSchema = NULL;

            hr = MimeOleGetPropertySchema(&pSchema);
            if (SUCCEEDED(hr))
                hr = pSchema->RegisterProperty("Y-SecurityChecked", 0, 0, VT_LPSTR, &g_dwSecurityCheckedSchemaProp);
            if (pSchema)
                pSchema->Release();
        }
    }

LoadMessage:
    if(m_fSecureReceipt)
    {
            m_fSecDispInfo = FALSE;
            if(m_pSecurityErrorScreen)
                hr = InternalLoad(m_pSecurityErrorScreen);
            // Free all mems
            SafeRelease(m_pSecurityErrorScreen);
    }
    else if (SUCCEEDED(hr))
    {
        if (pSecurityIntroScreen)
        {
            m_fSecDispInfo = TRUE;
            hr = InternalLoad(pSecurityIntroScreen);
            SafeRelease(pSecurityIntroScreen);

        }
        else if (m_pSecurityErrorScreen)
        {
            m_fSecDispInfo = TRUE;
            hr = InternalLoad(m_pSecurityErrorScreen);
            SafeRelease(m_pSecurityErrorScreen);
        }
        else if (m_pSecureMessage)
        {
            m_fSecDispInfo = FALSE;
            hr = InternalLoad(m_pSecureMessage);
            SafeRelease(m_pSecureMessage);
        }
        else
        {
            m_fSecDispInfo = FALSE;
            Assert(!m_pSecurityErrorScreen && !pSecurityIntroScreen);
            hr = InternalLoad(pMsg);
        }
        if (fRegisterDispatch)
            RegisterForHTMLDocEvents(TRUE);

    }

    return hr;
}



HRESULT CMimeEditDocHost::CycleSrcTabs(BOOL fFwd)
{
    ExecSetI4(&CMDSETID_MimeEdit, MECMDID_SETSOURCETAB, fFwd ? MEST_NEXT : MEST_PREVIOUS);
    return S_OK;
}

HRESULT CMimeEditDocHost::HrEnableScrollBars(BOOL fEnable)
{
    HRESULT             hr          = S_OK;
    IHTMLBodyElement    *pBody      = NULL;
    BSTR                bstrValue   = NULL;

    if (m_pDoc)
    {
        IF_FAILEXIT(hr = m_pDoc->get_body((IHTMLElement**)&pBody));

        if (fEnable)
        {
            bstrValue = SysAllocString(L"yes");
        }
        else
        {
            bstrValue = SysAllocString(L"no");
        }

        hr = pBody->put_scroll(bstrValue);
    }

exit:

    ReleaseObj(pBody);
    SysFreeString(bstrValue);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\mehost.h ===
#ifndef __MEHOST_H
#define __MEHOST_H

#include "ibodyobj.h"
#include "mshtmhst.h"
#include "secutil.h"

// WM_NOTIFY messages sent to the parent
#define BDN_FIRST               (9000)
#define BDN_HEADERDBLCLK        (BDN_FIRST + 1)
#define BDN_DOWNLOADCOMPLETE    (BDN_FIRST + 2)
#define BDN_MARKASSECURE        (BDN_FIRST + 3)

#define MAX_DATA_MESSAGES       3
#define C_RGBCOLORS 16

extern const DWORD rgrgbColors16[C_RGBCOLORS];

class CMimeEditDocHost:
    public IOleInPlaceFrame,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IBodyObj2,
    public IDocHostUIHandler,
    public IPropertyNotifySink,
    public IPersistMime,
    public IDispatch
{
public:
    // IUnknown methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // IOleInPlaceUIWindow methods
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR);

    // IOleInPlaceFrame methods
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IBodyObj2
    virtual HRESULT STDMETHODCALLTYPE HrUpdateFormatBar();
    virtual HRESULT STDMETHODCALLTYPE HrClearFormatting();
    virtual HRESULT STDMETHODCALLTYPE HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions);
    virtual HRESULT STDMETHODCALLTYPE HrClose();
    virtual HRESULT STDMETHODCALLTYPE HrResetDocument();
    virtual HRESULT STDMETHODCALLTYPE HrSetStatusBar(CStatusBar *pStatus);
    virtual HRESULT STDMETHODCALLTYPE HrUpdateToolbar(HWND hwndToolbar);
    virtual HRESULT STDMETHODCALLTYPE HrShow(BOOL fVisible);
    virtual HRESULT STDMETHODCALLTYPE HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID);
    virtual HRESULT STDMETHODCALLTYPE HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    virtual HRESULT STDMETHODCALLTYPE HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis);
    virtual HRESULT STDMETHODCALLTYPE HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
    virtual HRESULT STDMETHODCALLTYPE HrWMCommand(HWND hwnd, int id, WORD wCmd);
    virtual HRESULT STDMETHODCALLTYPE HrGetWindow(HWND *pHwnd);
    virtual HRESULT STDMETHODCALLTYPE HrSetSize(LPRECT prc);
    virtual HRESULT STDMETHODCALLTYPE HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI);
    virtual HRESULT STDMETHODCALLTYPE HrSetDragSource(BOOL fIsSource);
    virtual HRESULT STDMETHODCALLTYPE HrTranslateAccelerator(LPMSG lpMsg);
    virtual HRESULT STDMETHODCALLTYPE HrUIActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE HrSetUIActivate();
    virtual HRESULT STDMETHODCALLTYPE HrFrameActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE HrHasFocus();
    virtual HRESULT STDMETHODCALLTYPE HrSetBkGrndPicture(LPTSTR pszPicture);
    virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    virtual HRESULT STDMETHODCALLTYPE PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet);
    virtual HRESULT STDMETHODCALLTYPE HrSaveAttachment();
    virtual HRESULT STDMETHODCALLTYPE SetEventSink(IMimeEditEventSink *pEventSink);
    virtual HRESULT STDMETHODCALLTYPE LoadHtmlErrorPage(LPCSTR pszURL);

    virtual HRESULT STDMETHODCALLTYPE HrSpellCheck(BOOL fSuppressDoneMsg);
    virtual HRESULT STDMETHODCALLTYPE HrIsDirty(BOOL *pfDirty);
    virtual HRESULT STDMETHODCALLTYPE HrSetDirtyFlag(BOOL fDirty);
    virtual HRESULT STDMETHODCALLTYPE HrIsEmpty(BOOL *pfEmpty);
    virtual HRESULT STDMETHODCALLTYPE HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE HrSetStyle(DWORD dwStyle);
    virtual HRESULT STDMETHODCALLTYPE HrGetStyle(DWORD *pdwStyle);
    virtual HRESULT STDMETHODCALLTYPE HrEnableHTMLMode(BOOL fOn);
    virtual HRESULT STDMETHODCALLTYPE HrDowngradeToPlainText();
    virtual HRESULT STDMETHODCALLTYPE HrSetText(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrPerformROT13Encoding();
    virtual HRESULT STDMETHODCALLTYPE HrInsertTextFile(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrInsertTextFileFromDialog();
    virtual HRESULT STDMETHODCALLTYPE HrViewSource(DWORD dwViewType);
    virtual HRESULT STDMETHODCALLTYPE HrSetPreviewFormat(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrSetEditMode(BOOL fOn);
    virtual HRESULT STDMETHODCALLTYPE HrIsEditMode(BOOL *pfOn);
    virtual HRESULT STDMETHODCALLTYPE HrSetCharset(HCHARSET hCharset);
    virtual HRESULT STDMETHODCALLTYPE HrGetCharset(HCHARSET *phCharset);
    virtual HRESULT STDMETHODCALLTYPE HrSaveAsStationery(LPWSTR pwszFile);
    virtual HRESULT STDMETHODCALLTYPE HrApplyStationery(LPWSTR pwszFile);
    virtual HRESULT STDMETHODCALLTYPE HrHandsOffStorage();
    virtual HRESULT STDMETHODCALLTYPE HrRefresh();
    virtual HRESULT STDMETHODCALLTYPE HrScrollPage();
    virtual HRESULT STDMETHODCALLTYPE UpdateBackAndStyleMenus(HMENU hmenu);


    // IDocHostUIHandler methods
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu(
                DWORD dwID, 
                POINT *ppt, 
                IUnknown *pcmdtReserved, 
                IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI(
                DWORD dwID, 
                IOleInPlaceActiveObject *pActiveObject, 
                IOleCommandTarget *pCommandTarget, 
                IOleInPlaceFrame *pFrame,
                IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI();
    virtual HRESULT STDMETHODCALLTYPE UpdateUI();
    //This function is already listed above
    //virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDispatch);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject( IDataObject *pDO, IDataObject **ppDORet);

    // IPropertyNotifySink
    virtual HRESULT STDMETHODCALLTYPE OnChanged(DISPID dispid);
    virtual HRESULT STDMETHODCALLTYPE OnRequestEdit (DISPID dispid);

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE pMsg);
    virtual HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE pMsg, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IDispatch methods
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);

    CMimeEditDocHost(DWORD dwBorderFlags = MEBF_OUTERCLIENTEDGE);
    virtual ~CMimeEditDocHost();
    
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    virtual void OnDocumentReady();

    HRESULT CreateDocObj(LPCLSID pCLSID);
    HRESULT CloseDocObj();

    virtual HRESULT HrLoadURL(LPCSTR pszURL);
    virtual HRESULT HrEnableScrollBars(BOOL fEnable);

    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    static HRESULT HrMEDocHost_Init(BOOL fInit);

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    DWORD                       m_dwBorderFlags,
                                m_dwStyle,
                                m_dwHTMLNotifyCookie;
    BOOL                        m_fDownloading              : 1,
                                m_fUIActive                 : 1,
                                m_fMarkedRead               : 1,
                                m_fBlockingOnSMime          : 1,
                                m_fIsEncrypted              : 1,
                                m_fIsSigned                 : 1,
                                m_fSignTrusted              : 1,
                                m_fEncryptionOK             : 1,
                                m_fRegisteredForDocEvents   : 1,
                                m_fShowingErrorPage         : 1,
                                m_fFixedFont                : 1,
                                m_fSecDispInfo              : 1,
                                m_fSecureReceipt            : 1;
    CStatusBar                 *m_pStatus;
    IBodyOptions               *m_pBodyOptions;
    IHTMLDocument2             *m_pDoc;
    IUnknown                   *m_pUnkService;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLECOMMANDTARGET          m_pCmdTarget;
    LPPERSISTMIME               m_pPrstMime;
    LPOLEDOCUMENTVIEW           m_pDocView;
    LPMIMEMESSAGE               m_pMsg,
                                m_pSecureMessage,
                                m_pSecurityErrorScreen;
    IMimeEditEventSink         *m_pEventSink;

    virtual HRESULT OnUpdateCommands();
    virtual HRESULT HrPasteToAttachment();
    virtual void WMSize(int x, int y);
    virtual void OnWMSize(LPRECT prc){};
    virtual BOOL WMCommand(HWND, int, WORD);
    virtual BOOL WMNotify(int idFrom, NMHDR *pnmh);
    virtual HRESULT HrPostInit();
    virtual HRESULT HrSubWMCreate() {Assert(FALSE); return NOERROR;}
    virtual HRESULT HrOnDocObjCreate();
    BOOL WMCreate(HWND hwnd);
    void WMNCDestroy();
    HRESULT HrMarkAsRead();
    void OnWMTimer();

    HRESULT HandleButtonClicks(BSTR bstr);
    HRESULT DoHtmlBtnOpen(void); 
    HRESULT DoHtmlBtnCertTrust(DWORD cmdID);
    HRESULT DoHtmlBtnContinue(void);
    HRESULT InternalLoad(IMimeMessage *pMsg);
    HRESULT LoadSecurely(IMimeMessage *pMsg, SECSTATE *pSecState);
    HRESULT ViewCertificate(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);
    HRESULT EditTrust(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);

    HRESULT RegisterForHTMLDocEvents(BOOL fOn);

    HRESULT ExecCommand(const GUID *guid, DWORD cmd);
    HRESULT ExecGetBool(const GUID *guid, DWORD cmd, BOOL *pfValue);
    HRESULT ExecSetBool(const GUID *guid, DWORD cmd, BOOL fValue);
    HRESULT ExecGetI4(const GUID *guid, DWORD cmd, DWORD *pdwValue);
    HRESULT ExecSetI4(const GUID *guid, DWORD cmd, DWORD dwValue);
    HRESULT ExecGetI8(const GUID *guid, DWORD cmd, ULONGLONG *pullValue);
    HRESULT ExecSetI8(const GUID *guid, DWORD cmd, ULONGLONG ullValue);
    HRESULT ExecGetText(const GUID *guid, DWORD cmd, LPSTR *ppsz);
    HRESULT ExecSetText(const GUID *guid, DWORD cmd, LPSTR psz);
    HRESULT ExecGetTextW(const GUID *guid, DWORD cmd, LPWSTR *ppwsz);
    HRESULT ExecSetTextW(const GUID *guid, DWORD cmd, LPWSTR pwsz);

    HRESULT Show();
    HRESULT HrRegisterLoadNotify(BOOL fRegister);
    HRESULT HrRegisterNotify(BOOL fRegister, LPCTSTR szElement, REFIID riidSink, IUnknown *pUnkSink, DWORD *pdwCookie);
    HRESULT HrAddToFavorites(BSTR bstrDescr, BSTR bstrURL);
    HRESULT HrAddToWab(BSTR bstr);
    HRESULT HrGetElement(LPCTSTR pszName, IHTMLElement **ppElem);

private:
    ULONG           m_cRef;
    DWORD           m_dwDocStyle;
    HMENU           m_hmenuColor,
                    m_hmenuStyle;

    HRESULT HrPrint(BOOL fPrompt);
    HRESULT HrBackgroundImage();
    HRESULT HrBackgroundSound();

    void UpdateInsertMenu(HMENU hmenu);
    void UpdateEditMenu(HMENU hmenu);
    void UpdateViewMenu(HMENU hmenu);
    void EnableStandardCmd(UINT idm, LPBOOL pbEnable);

    HRESULT HrInsertSignature(int id);
    HRESULT HrCheckColor();
    HRESULT CreateDocView();

    HRESULT OnCreate(HWND hwnd);
    HRESULT OnNCDestroy();
    HRESULT OnDestroy();
    void OnReadyStateChanged();
    HRESULT HrIsHTMLMode();
    HRESULT CycleSrcTabs(BOOL fFwd);

    HRESULT QuerySingleMimeEditCmd(ULONG uCmd, ULONG *pcmf);
    HRESULT QuerySingleFormsCmd(ULONG uCmd, ULONG *pcmf);
    HRESULT QuerySingleStdCmd(ULONG uCmd, ULONG *pcmf);
};


typedef CMimeEditDocHost MIMEEDITDOCHOST;
typedef MIMEEDITDOCHOST *LPMIMEEDITDOCHOST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\msgprop.cpp ===
/*
*    m s g p r o p . c p p
*
*    Purpose:
*        Implements propsheet for a msg
*
*    Owner:
*        brettm.
*
*  History:
*      Feb '95: Stolen from Capone Sources - brettm
*
*    Copyright (C) Microsoft Corp. 1993, 1994.
*/

#include <pch.hxx>
#ifdef WIN16
#include "mapi.h"
#endif
#include <resource.h>
#include <richedit.h>
#include "goptions.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "msgprop.h"
#include "addrobj.h"
#include "mpropdlg.h"
#ifndef WIN16
#include "mapi.h"
#endif
#include "ipab.h"
#include <secutil.h>
#include <seclabel.h>
#include <certs.h>
#include <demand.h>
#include <strconst.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "instance.h"
#include "conman.h"
#include "shared.h"
#include "htmlhelp.h"


/*
* m a c r o s   and   c o n s t a n t s
*
*/
#define KILOBYTE 1024L

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

#ifdef WIN16
#ifndef GetLastError
#define GetLastError()  ((DWORD)-1)
#endif
#endif //!WIN16


#ifdef WIN16
#define SET_DIALOG_SECURITY(hwnd, value) SetProp32(hwnd, s_cszDlgSec, (LPVOID)value)
#define GET_DIALOG_SECURITY(hwnd)        GetProp32(hwnd, s_cszDlgSec)
#define CLEAR_DIALOG_SECURITY(hwnd)      RemoveProp32(hwnd, s_cszDlgSec);
#else
#define SET_DIALOG_SECURITY(hwnd, value) SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)value)
#define GET_DIALOG_SECURITY(hwnd)        GetWindowLongPtr(hwnd, DWLP_USER);
#define CLEAR_DIALOG_SECURITY(hwnd)      SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)NULL)
#endif



/*
* s t r u c t u r e s
*
*/

struct DLGSECURITYtag
{
    PCX509CERT      pSenderCert;
    PCCERT_CONTEXT  pEncSenderCert;
    PCCERT_CONTEXT  pEncryptionCert;
    THUMBBLOB       tbSenderThumbprint;
    BLOB            blSymCaps;
    FILETIME        ftSigningTime;
    HCERTSTORE      hcMsg;
};
typedef struct DLGSECURITYtag DLGSECURITY;
typedef DLGSECURITY *PDLGSECURITY;
typedef const DLGSECURITY *PCDLGSECURITY;

/*
* c l a s s e s
*
*/


class CMsgProps
{
public:
    CMsgProps();
    ~CMsgProps();
    
    HRESULT HrDoProps(PMSGPROP pmp);
    
    static INT_PTR CALLBACK GeneralPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK DetailsPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK SecurityPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK EncryptionPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    void InitGeneralPage();
    void InitDetailsPage(HWND hwnd);
    void InitSecurityPage(HWND hwnd);
    
private:
    HIMAGELIST  m_himl;
    HWND        m_hwndGen;
    HWND        m_hwndGenSource;
    PMSGPROP    m_pmp;
};



// Function declarations ////////////////////////////////////////
// msg source dialog is modeless, so it can't be in the CProps dialog.

/*
* p r o t o t y p e s
*
*/
void SecurityOnWMCreate(HWND hwnd, LPARAM lParam);
INT_PTR CALLBACK ViewSecCertDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

/*
* f u n c t i o n s
*
*/


//
//  FUNCTION:   HrMsgProperties()
//
//  PURPOSE:    Displays the property sheet for the specified message.
//
//  PARAMETERS: 
//      [in] pmp - Information needed to identify the message.
//
HRESULT HrMsgProperties(PMSGPROP pmp)
{
    CMsgProps *pMsgProp = 0;
    HRESULT    hr;
    
    TraceCall("HrMsgProperties");

    // Create the property sheet object
    pMsgProp = new CMsgProps();
    if (!pMsgProp)
        return E_OUTOFMEMORY;
    
    // Tell the object to do it's thing.  This won't go away until the
    // property sheet is dismissed.
    hr = pMsgProp->HrDoProps(pmp);
    
    // Free the object
    if (pMsgProp)
        delete pMsgProp;
    
    return hr;
}


CMsgProps::CMsgProps()
{
    m_himl = 0;
    m_hwndGen = 0;
    m_hwndGenSource = 0;
    m_pmp = NULL;
}

CMsgProps::~CMsgProps()
{
}



//
//  FUNCTION:   CMsgProps::HrDoProps()
//
//  PURPOSE:    Initializes the structures used to create the prop sheet
//              and then displays the sheet.  
//
//  PARAMETERS: 
//      [in] pmp - Information needed to identify the message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMsgProps::HrDoProps(PMSGPROP pmp)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp[3];
    BOOL            fApply = FALSE;
    HRESULT         hr;
    LPTSTR          pszSubject = NULL;
    LPTSTR          pszFree = NULL;
    TCHAR           rgch[256] = "";
 
    TraceCall("CMsgProps::HrDoProps");
 
    // Zero init the prop sheet structures
    ZeroMemory(&psh, sizeof(psh));
    ZeroMemory(&psp, sizeof(psp));

    // Double check that we have the information we need to do this.
    if (pmp == NULL || (pmp->pMsg == NULL && pmp->pNoMsgData == NULL))
        return E_INVALIDARG;

    Assert(pmp->hwndParent);
    
    // Stash this pointer
    m_pmp = pmp;

    // Page zero is the general tab
    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags     = PSP_USETITLE;
    psp[0].hInstance   = g_hLocRes;
    psp[0].pszTemplate = MAKEINTRESOURCE(iddMsgProp_General);
    psp[0].pfnDlgProc  = GeneralPageProc;
    psp[0].pszTitle    = MAKEINTRESOURCE(idsPropPageGeneral);
    psp[0].lParam      = (LPARAM) this;

    // Increment the number of pages 
    psh.nPages++;
    
    // If the message is not unsent, then we also display the "Details" tab.
    if (!(pmp->dwFlags & ARF_UNSENT) || (pmp->dwFlags & ARF_SUBMITTED))
    {        
        psp[psh.nPages].dwSize      = sizeof(PROPSHEETPAGE);
        psp[psh.nPages].dwFlags     = PSP_USETITLE;
        psp[psh.nPages].hInstance   = g_hLocRes;
        psp[psh.nPages].pszTemplate = MAKEINTRESOURCE(iddMsgProp_Details);
        psp[psh.nPages].pfnDlgProc  = DetailsPageProc;
        psp[psh.nPages].pszTitle    = MAKEINTRESOURCE(idsPropPageDetails);
        psp[psh.nPages].lParam      = (LPARAM) this;

        // If the caller wanted this to be the first page the user
        // sees, set it to be the start page.
        if (MP_DETAILS == pmp->mpStartPage)
            psh.nStartPage = psh.nPages;

        // Increment the number of pages
        psh.nPages++;
    }
    
    // If the message is secure, add the security pages
    if (pmp->fSecure && (!(pmp->dwFlags & ARF_UNSENT) || (pmp->dwFlags & ARF_SUBMITTED)))
    {
        psp[psh.nPages].dwSize      = sizeof(PROPSHEETPAGE);
        psp[psh.nPages].dwFlags     = PSP_USETITLE;
        psp[psh.nPages].hInstance   = g_hLocRes;
        psp[psh.nPages].pszTemplate = MAKEINTRESOURCE(iddMsgProp_Security_Msg);
        psp[psh.nPages].pfnDlgProc  = SecurityPageProc;        
        psp[psh.nPages].pszTitle    = MAKEINTRESOURCE(idsPropPageSecurity);        
        psp[psh.nPages].lParam      = (LPARAM) this;

        // If the caller wanted this to be the first page the user
        // sees, set it to be the start page.
        if (MP_SECURITY == pmp->mpStartPage)
            psh.nStartPage = psh.nPages;        

        // Increment the number of pages
        psh.nPages++;
    }
    
    // Property sheet header information
    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_USEPAGELANG | ((fApply) ? 0 : PSH_NOAPPLYNOW);
    psh.hwndParent = pmp->hwndParent;
    psh.hInstance  = g_hLocRes;
    
    // The title of the property sheet is the same as the subject.  So now we
    // need to get the subject from either the message or message info.
    if (pmp->pMsg)
    {
        // Get the subject from the message
        if (SUCCEEDED(MimeOleGetBodyPropA(pmp->pMsg, HBODY_ROOT, 
                                          PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, 
                                          &pszSubject)))
        {
            // We'll need to free this string later
            pszFree = pszSubject;
        }
    }
    else
    {
        AssertSz(pmp->pNoMsgData, "CMsgProp::HrDoProps() - Need to provide either a Message or Message Info");
        pszSubject = (LPTSTR) pmp->pNoMsgData->pszSubject;
    }
    
    // If there was no subject on the message, set the title to be "No Subject"
    if (!pszSubject || !*pszSubject)
    {
        LoadString(g_hLocRes, idsNoSubject, rgch, sizeof(rgch));
        pszSubject = rgch;
    }

    // Clean up the subject string before we use it.  Tabs look like pretty bad.
    ConvertTabsToSpaces(pszSubject);

    // Set the subject as the property sheet title.
    psh.pszCaption = pszSubject;
    
    // Provide the array of pages.  The number was set along the way.
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    // Invoke the property sheet.
    PropertySheet(&psh);
    
    // If this is valid, then we need to free the string.
    SafeMemFree(pszFree);
    return (S_OK);
}


//
//  FUNCTION:   CMsgProps::GeneralPageProc()
//
//  PURPOSE:    Callback for the General tab dialog.
//
INT_PTR CALLBACK CMsgProps::GeneralPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMsgProps *pThis = 0;
    
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            // Grab the object's this pointer from the init info
            pThis = (CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;

            // Stash the window handle for this dialog in the class
            pThis->m_hwndGen = hwnd;

            // Initialize the page
            pThis->InitGeneralPage();
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR FAR *)lParam)->code)
            {
                // We're going to do the default thing for all of these notifications
                case PSN_APPLY:
                case PSN_KILLACTIVE:
                case PSN_SETACTIVE:
                {
                    SetDlgMsgResult(hwnd, WM_NOTIFY, FALSE);
                    return TRUE;
                }            
            }
            break;
        }
    }

    return FALSE;
}

enum
{
    freeSubject = 0,
    freeFrom,
    freeMax
};


//
//  FUNCTION:   CMsgProps::InitGeneralPage()
//
//  PURPOSE:    Set's the values for the "General" tab in the message
//              property sheet.
//
void CMsgProps::InitGeneralPage()
{
    HWND            hwnd;
    char            rgch[256],
                    rgchFmt[256];
    char            *psz = NULL;
    PROPVARIANT     rVariant;
    LPMIMEMESSAGE   pMsg = m_pmp->pMsg;
    IMSGPRIORITY    Pri = IMSG_PRI_NORMAL;
    int             ids;
    BOOL            fMime;
    LPSTR           rgszFree[freeMax]={0};
    WCHAR           wszDate[CCHMAX_STRINGRES];
        
    TraceCall("CMsgProps::InitGeneralPage");

    // [SBAILEY]: Raid-2440: ATTACH: Attachments field in Properties dialog innacurate when looked at from the listview.
    if (m_pmp->fFromListView)
    {
        // Too hard to get these counts write from the listview because to really compute the attachment
        // counts correctly, we have to render the message in trident. Since we are time contrained,
        // we are going to simply remove the attachement count from the listview message properties. But
        // since the counts are correct from message note properties, we will show the attachment counts from there.
        ShowWindow(GetDlgItem(m_hwndGen, IDC_ATTACHMENTS_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_ATTACHMENTS), SW_HIDE);
    }

    // If this is a news message, we hide the "Recieved:" and "Priority" fields
    if (m_pmp->type == MSGPROPTYPE_NEWS)
    {
        RECT rc, rcLabel;

        // Get the position of the priority field
        GetWindowRect(GetDlgItem(m_hwndGen, IDC_PRIORITY), &rc);
        MapWindowPoints(NULL, m_hwndGen, (LPPOINT) &rc, 2);

        // Get the position of the priority label
        GetWindowRect(GetDlgItem(m_hwndGen, IDC_PRIORITY_STATIC), &rcLabel);
        MapWindowPoints(NULL, m_hwndGen, (LPPOINT) &rcLabel, 2);

        // Hide the unused fields
        ShowWindow(GetDlgItem(m_hwndGen, IDC_PRIORITY_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_PRIORITY), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, idcStatic1), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_RECEIVED_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_RECEIVED), SW_HIDE);

        // Move the sent fields up to where the priority fields were
        SetWindowPos(GetDlgItem(m_hwndGen, IDC_SENT_STATIC), NULL, rcLabel.left, 
                     rcLabel.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        SetWindowPos(GetDlgItem(m_hwndGen, IDC_SENT), NULL, rc.left, rc.top, 0, 0, 
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // Figure out the correct image for this message
    int idIcon;
    if (m_pmp->type == MSGPROPTYPE_MAIL)
    {
        if (m_pmp->dwFlags & ARF_UNSENT)
            idIcon = idiMsgPropUnSent;
        else
            idIcon = idiMsgPropSent;
    }
    else
    {
        if (m_pmp->dwFlags & ARF_UNSENT)
            idIcon = idiArtPropUnpost;
        else
            idIcon = idiArtPropPost;
    }

    // Set the image on the property sheet
    HICON hIcon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idIcon));
    SendDlgItemMessage(m_hwndGen, IDC_FOLDER_IMAGE, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    // Subject
    if (pMsg)
    {
        // If we have a message object, then we need to get the subject from the message
        if (SUCCEEDED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT,  PIDTOSTR(PID_HDR_SUBJECT), 
                                          NOFLAGS, &psz)))
        {
            // Make sure we free this later, eh?
            rgszFree[freeSubject] = psz;
        }
    }
    else
    {
        Assert(m_pmp->pNoMsgData);
        psz = (LPTSTR) m_pmp->pNoMsgData->pszSubject;
    }

    // If the message doesn't have a subject, then substitute "(No Subject)"
    if (!psz || !*psz)
    {
        LoadString(g_hLocRes, idsNoSubject, rgch, sizeof(rgch));
        psz = rgch;
    }
    
    // Set the subject on the dialog
    SetDlgItemText(m_hwndGen, IDC_MSGSUBJECT, psz);

    // From
    if (pMsg)
    {
        // Get the "From" line
        if (S_OK == pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_BOTH, &psz))
        {
            // We'll need to free this later
            rgszFree[freeFrom] = psz;
            
            // Set the name on the control
            SetDlgItemText(m_hwndGen, IDC_MSGFROM, psz);
        }
    }
    else
    {
        // Check to see if the caller provided this information
        if (m_pmp->pNoMsgData && m_pmp->pNoMsgData->pszFrom)
        {
            SetDlgItemText(m_hwndGen, IDC_MSGFROM, m_pmp->pNoMsgData->pszFrom);
        }
    }

    // Type (News or Mail)
    if (m_pmp->type == MSGPROPTYPE_MAIL)
        LoadString(g_hLocRes, idsMailMessage, rgch, ARRAYSIZE(rgch));
    else
        LoadString(g_hLocRes, idsNewsMessage, rgch, ARRAYSIZE(rgch));

    SetDlgItemText(m_hwndGen, IDC_TYPE, rgch);

    // Location
    if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_MSGFOLDER, rgch);
    }
    else
        SetDlgItemText(m_hwndGen, IDC_MSGFOLDER, m_pmp->szFolderName);

    // Size
    ULONG ulSize;
    if (pMsg)
    {
        pMsg->GetMessageSize(&ulSize, 0);
        if (0 == ulSize)
        {
            // see if the message has the userprop for uncached size
            rVariant.vt = VT_UI4;
            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_UNCACHEDSIZE), 0, &rVariant)))
                ulSize = rVariant.ulVal;
        }
        AthFormatSizeK(ulSize, rgch, ARRAYSIZE(rgch));
    }
    else if (m_pmp->pNoMsgData && m_pmp->pNoMsgData->ulSize)
    {
        AthFormatSizeK(m_pmp->pNoMsgData->ulSize, rgch, ARRAYSIZE(rgch));
    }
    else
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
    }

    SetDlgItemText(m_hwndGen, IDC_MSGSIZE, rgch);

    // Attachments
    ULONG cAttachments = 0;
    if (pMsg)
    {
        GetAttachmentCount(pMsg, &cAttachments);
    }
    else if (m_pmp->pNoMsgData)
    {
        cAttachments = m_pmp->pNoMsgData->cAttachments;
        SetDlgItemInt(m_hwndGen, IDC_ATTACHMENTS, cAttachments, FALSE);
    }

    if (cAttachments)
    {
        SetDlgItemInt(m_hwndGen, IDC_ATTACHMENTS, cAttachments, FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsPropAttachNone, rgch, sizeof(rgch));
        SetDlgItemText(m_hwndGen, IDC_ATTACHMENTS, rgch);
    }

    // Priority
    // Get the priority from the message
    rVariant.vt = VT_UI4;
    Pri = IMSG_PRI_NORMAL;
    if (pMsg && SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
        Pri = (IMSGPRIORITY) rVariant.ulVal;
    else
    {
        Assert(m_pmp->pNoMsgData);
        Pri = m_pmp->pNoMsgData->Pri;
    }
    
    // Map the priority to a string
    switch (Pri)
    {
        case IMSG_PRI_LOW:
            ids = idsPriLow;
            break;
        case IMSG_PRI_HIGH:
            ids = idsPriHigh;
            break;
        default:
            ids = idsPriNormal;
    }
    
    // Set the string on the dialog
    LoadString(g_hLocRes, ids, rgch, ARRAYSIZE(rgch));
    SetDlgItemText(m_hwndGen, IDC_PRIORITY, rgch);

    // Sent
    if (pMsg)
    {
        *wszDate = 0;
        rVariant.vt = VT_FILETIME;
        pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS);
        SetDlgItemTextWrapW(m_hwndGen, IDC_SENT, wszDate);
    }
    else if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_SENT, rgch);
    }
    else
    {
        SetDlgItemText(m_hwndGen, IDC_SENT, m_pmp->pNoMsgData->pszSent);
    }

    // Recieved
    if (pMsg)
    {        
        *wszDate = 0;
        rVariant.vt = VT_FILETIME;
        pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant);
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS);
        SetDlgItemTextWrapW(m_hwndGen, IDC_RECEIVED, wszDate);
    }
    else if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_RECEIVED, rgch);
    }
    
    // Free the string table
    for (register int i=0; i < freeMax; i++)
        if (rgszFree[i])
            MemFree(rgszFree[i]);
}



void CMsgProps::InitDetailsPage(HWND hwnd)
{
    LPSTREAM    pstm;
    BODYOFFSETS rOffset;
    char        *psz;
    int         cch;
    
    Assert(m_pmp);
    Assert(m_pmp->pMsg);
    
    // fill in the headers...
    if(m_pmp->pMsg->GetMessageSource(&pstm, 0)==S_OK)
    {
        HrRewindStream(pstm);
        
        m_pmp->pMsg->GetBodyOffsets(HBODY_ROOT, &rOffset);
        
        cch=rOffset.cbBodyStart;
        if(MemAlloc((LPVOID *)&psz, cch+1))
        {
            if(!pstm->Read(psz, cch, NULL))
            {
                psz[cch]=0; // null term this
                SetDlgItemText(hwnd, idcTxtHeaders, psz);
            }
            MemFree(psz);
        }
        ReleaseObj(pstm);
    }
    else
        EnableWindow(GetDlgItem(hwnd, idbMsgSource), FALSE);
    
    if (!m_pmp->fSecure || !m_pmp->pSecureMsg)
        ShowWindow(GetDlgItem(hwnd, idbSecMsgSource), SW_HIDE);
}

INT_PTR CALLBACK CMsgProps::DetailsPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMsgProps   *pmprop=0;
    
    switch(msg)
    {
    case WM_INITDIALOG:
        pmprop=(CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;
        SetDlgThisPtr(hwnd, (LPARAM)pmprop);
        
        Assert(pmprop);
        pmprop->InitDetailsPage(hwnd);
        return TRUE;
        
    case WM_COMMAND:
        pmprop=(CMsgProps *)GetDlgThisPtr(hwnd);
        if(GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            if (GET_WM_COMMAND_ID(wParam, lParam)==idbMsgSource)
            {
                MimeEditViewSource(pmprop->m_pmp->hwndParent, pmprop->m_pmp->pMsg);
                return(FALSE);
            }
            else if (GET_WM_COMMAND_ID(wParam, lParam)==idbSecMsgSource)
            {
                MimeEditViewSource(pmprop->m_pmp->hwndParent, pmprop->m_pmp->pSecureMsg);
                return(FALSE);
            }
        }
        else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_SETFOCUS) {
            if (GET_WM_COMMAND_ID(wParam, lParam) == idcTxtHeaders) {
                // Remove the selection!
                SendDlgItemMessage(hwnd, idcTxtHeaders, EM_SETSEL, -1, -1);
                // fall through to default processing.
            }
        }
        return TRUE;
        
    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
            pmprop=(CMsgProps *)GetDlgThisPtr(hwnd);
        case PSN_APPLY:
        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;
            
        }
        break;

    case WM_CLOSE:
        {
            PostMessage(GetParent(hwnd), WM_CLOSE, 0, 0);
            break;
        }
        
    }
    return FALSE;
}


#ifdef WIN16
static const char  s_cszDlgSec[] = "PDLGSECUTIRY";
#endif

INT_PTR CALLBACK CMsgProps::SecurityPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PMSGPROP            pMsgProp = (PMSGPROP)0;
    DLGSECURITY         *pDlgSec;
    
    switch(msg)
    {
    case WM_INITDIALOG:
        {
            CMsgProps *pmprop;
            pmprop=(CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;
            SetWndThisPtr(hwnd, (LPARAM)pmprop->m_pmp);
            if (pmprop)
                pmprop->InitSecurityPage(hwnd);
        }
        return TRUE;
        
    case WM_COMMAND:
        
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case idcAddCert:
                pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
                pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
                
                // Get thumbprint into WAB and cert into AddressBook CAPI store
                // cert goes to store first so CAPI details page can find it
                if (pDlgSec && pMsgProp)
                {
                    if (SUCCEEDED(HrAddSenderCertToWab(hwnd,
                        pMsgProp->pMsg,
                        pMsgProp->lpWabal,
                        &pDlgSec->tbSenderThumbprint,
                        &pDlgSec->blSymCaps,
                        pDlgSec->ftSigningTime,
                        WFF_CREATE | WFF_SHOWUI)))
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                            MAKEINTRESOURCEW(idsSenderCertAdded), NULL, MB_ICONINFORMATION | MB_OK);
                    }
                }
                return(FALSE);
                
            case idcVerifySig:
                pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
                
                if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pSenderCert, pDlgSec->hcMsg))
                    MessageBeep(MB_OK);
                return(FALSE);
                
            case idcViewCerts:
                pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
                
                return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddMsgProp_Sec_ViewCert),
                    hwnd, ViewSecCertDlgProc, (LPARAM) (pMsgProp)) == IDOK);
                
            case idcCertHelp:
                OEHtmlHelp(hwnd, c_szCtxHelpFileHTMLCtx, HH_DISPLAY_TOPIC, (DWORD_PTR)(LPCSTR)"mail_overview_send_secure_messages.htm");
                return(FALSE);

            default:
                break;
            }
        }
        return TRUE;
        
    case WM_DESTROY:
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        if (pDlgSec)
        {
            if (pDlgSec->pSenderCert)
                CertFreeCertificateContext(pDlgSec->pSenderCert);
            if (pDlgSec->pEncSenderCert)
                CertFreeCertificateContext(pDlgSec->pEncSenderCert);
            if (pDlgSec->pEncryptionCert)
                CertFreeCertificateContext(pDlgSec->pEncryptionCert);
            if (pDlgSec->tbSenderThumbprint.pBlobData)
                MemFree(pDlgSec->tbSenderThumbprint.pBlobData);
            if (pDlgSec->hcMsg) {
                if (! CertCloseStore(pDlgSec->hcMsg, 0)) {
                    DOUTL(DOUTL_CRYPT, "CertCloseStore (message store) failed");
                }
                pDlgSec->hcMsg = NULL;
            }
            
            MemFree(pDlgSec);
            
            CLEAR_DIALOG_SECURITY(hwnd);
        }
        return NULL;
        
    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_APPLY:
        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;
            
        }
        break;
    }
    return FALSE;
}


void CMsgProps::InitSecurityPage(HWND hwnd)
{
    DWORD               cb;
    DWORD               i;
    HRESULT             hr;
    TCHAR               szYes[CCHMAX_STRINGRES/4],
        szNo[CCHMAX_STRINGRES/4],
        szMaybe[CCHMAX_STRINGRES/4],
        szNA[CCHMAX_STRINGRES/4];
    HWND                hwndCtrl;
    DLGSECURITY        *pDlgSec;
    IMimeBody          *pBody;
    PROPVARIANT         var;
    ULONG               secType, ulROVal;
    BOOL                fNoEncAlg = TRUE;
    LPTSTR              sz;
    LPMIMEMESSAGE       pMsg = m_pmp->pMsg;
    PCCERT_CONTEXT          pccert = NULL;
    TCHAR               szTmp[CCHMAX_STRINGRES];
    
    HBODY               hBody = NULL;
    SECSTATE            SecState ={0};
    
    // We need these to set the statics
    LoadString(g_hLocRes, idsOui, szYes, ARRAYSIZE(szYes));
    LoadString(g_hLocRes, idsNon, szNo, ARRAYSIZE(szNo));
    LoadString(g_hLocRes, idsMaybe, szMaybe, ARRAYSIZE(szMaybe));
    LoadString(g_hLocRes, idsNotApplicable, szNA, ARRAYSIZE(szNA));
    
    if(FAILED(HrGetSecurityState(m_pmp->pMsg, &SecState, &hBody)))
        return;

    CleanupSECSTATE(&SecState);
    if (FAILED(m_pmp->pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
        return;
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var)))
        secType = var.ulVal;
    
    // Set up storage for the other security info that
    // we care about
    if (MemAlloc((LPVOID *)&pDlgSec, sizeof(DLGSECURITY)))
    {
        memset(pDlgSec, 0, sizeof(DLGSECURITY));
#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
        {
            pDlgSec->hcMsg = (HCERTSTORE)(var.pulVal);     // Closed in WM_DESTROY
        }
        
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            // we don't have to dupe the pDlgSec cert because we won't free
            // the var's.
            pDlgSec->pSenderCert = (PCCERT_CONTEXT)(var.pulVal);
        }
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
        {
            pDlgSec->hcMsg = (HCERTSTORE) var.ulVal;     // Closed in WM_DESTROY
        }
        
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            // we don't have to dupe the pDlgSec cert because we won't free
            // the var's.
            pDlgSec->pSenderCert = (PCCERT_CONTEXT) var.ulVal;
        }
#endif  // _WIN64
        hr = GetSigningCert(m_pmp->pMsg, &pccert,
            &pDlgSec->tbSenderThumbprint, &pDlgSec->blSymCaps,
            &pDlgSec->ftSigningTime);
        if (FAILED(hr) && (hr != MIME_E_SECURITY_NOCERT))
        {
            SUCCEEDED(hr);
        }
    }
    
    SET_DIALOG_SECURITY(hwnd, (LPARAM)pDlgSec);
    
    // we use the same dlgproc for sent items and recd items
    // so use if statements to check for existance of all
    // non-common controls
    
    // set up the statics based on the message's info
    
    if(IsSigned(secType))
    {
        LPSTR szCertEmail = SzGetCertificateEmailAddress(pccert);
        SetDlgItemText(hwnd,  idcStaticDigSign, szCertEmail);
        MemFree(szCertEmail);
        SetDlgItemText(hwnd, idcStaticRevoked,
            (LPCTSTR)(((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && CheckCDPinCert(pMsg))
            ? szYes
            : szNo));
    }
    else
    {
        SetDlgItemText(hwnd,  idcStaticDigSign, szNA);
        SetDlgItemText(hwnd,  idcStaticRevoked, szNA);
    }
    
    
    SetDlgItemText(hwnd, idcStaticEncrypt,
        (LPCTSTR)(IsEncrypted(secType)
        ? szYes
        : szNo));
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RO_MSG_VALIDITY, &var)))
        ulROVal = var.ulVal;
    else
        ulROVal = MSV_INVALID|MSV_UNVERIFIABLE;
    
#ifdef SMIME_V3
    if(!IsSMIME3Supported())
    {
        LoadString(g_hLocRes, idsRecUnknown, szTmp, ARRAYSIZE(szTmp));
        SendMessage(GetDlgItem(hwnd, idcRetRecReq), WM_SETTEXT, 0, LPARAM(LPCTSTR(szTmp)));
    }
    else
    {
        if(FPresentPolicyRegInfo()) 
        {   
            if ((hwndCtrl = GetDlgItem(hwnd, idcSecLabelText)) && IsSigned(secType))
            {
                LPWSTR pwStr = NULL;
                // Set Label text
                if((hr = HrGetLabelString(m_pmp->pMsg, &pwStr)) == S_OK)
                {
                    SetWindowTextWrapW(hwndCtrl, pwStr);
                    SafeMemFree(pwStr);
                }
                else
                    SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(SUCCEEDED(hr) ? szYes : szNo)));
            }
        }
        // Check receipt request
        if ((hwndCtrl = GetDlgItem(hwnd, idcRetRecReq)))
        {
            if (!IsSigned(secType))
                sz = szNA;
            else
            {
                PSMIME_RECEIPT      pSecReceipt = NULL; 
                if(CheckDecodedForReceipt(m_pmp->pMsg, &pSecReceipt) == S_OK)
                    sz = szNA;
                else
                    sz = (secType & MST_RECEIPT_REQUEST) ? szYes : szNo;
                SafeMemFree(pSecReceipt);
            }
            SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
        }
    }
    
#endif // SMIME_V3    
    ////////
    // begin sign dependent block
    
    if (!IsSigned(secType))
        sz = szNA;
    
    if ((hwndCtrl = GetDlgItem(hwnd, idcStaticAlter)))
    {
        if (IsSigned(secType))
        {
            sz = (MSV_SIGNATURE_MASK & ulROVal)  
                ? (MSV_BADSIGNATURE & ulROVal)
                ? szNo
                : szMaybe
                : ((pccert != NULL) ? szYes : szMaybe);
        }
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
    }
    
    if ((hwndCtrl = GetDlgItem(hwnd, idcStaticTrust)) &&
        SUCCEEDED(pBody->GetOption(OID_SECURITY_USER_VALIDITY, &var)))
    {
        if (IsSigned(secType))
        {
            sz = (ATHSEC_TRUSTSTATEMASK & var.ulVal)
                ? ((ATHSEC_NOTRUSTNOTTRUSTED & var.ulVal) || (ulROVal & MSV_EXPIRED_SIGNINGCERT))
                ? szNo
                : szMaybe
                : szYes;
        }
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
        
    }
    
    if((hwndCtrl = GetDlgItem(hwnd, idcStaticRevStatus)) && IsSigned(secType))
    {
        if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && CheckCDPinCert(pMsg))
        {
            if(var.ulVal & ATHSEC_NOTRUSTREVOKED)
                LoadString(g_hLocRes, idsWrnSecurityCertRevoked, szTmp, ARRAYSIZE(szTmp));
            else if(var.ulVal & ATHSEC_NOTRUSTREVFAIL)
                LoadString(g_hLocRes, idsWrnSecurityRevFail, szTmp, ARRAYSIZE(szTmp));
            else
                LoadString(g_hLocRes, idsOkSecurityCertRevoked, szTmp, ARRAYSIZE(szTmp));
        }
        else if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && !CheckCDPinCert(pMsg))
            LoadString(g_hLocRes, idsWrnSecurityNoCDP, szTmp, ARRAYSIZE(szTmp));
        
        else if((DwGetOption(OPT_REVOKE_CHECK) != 0) && g_pConMan->IsGlobalOffline())
            LoadString(g_hLocRes, idsRevokationOffline, szTmp, ARRAYSIZE(szTmp));
        
        else if(DwGetOption(OPT_REVOKE_CHECK) == 0)
            LoadString(g_hLocRes, idsRevokationTurnedOff, szTmp, ARRAYSIZE(szTmp));
        
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(szTmp)));
    }
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_INCLUDED, &var)))
    {
        if (IsSigned(secType))
            sz = (var.boolVal == TRUE) ? szYes : szNo;
        SetDlgItemText(hwnd, idcStaticCertInc, LPCTSTR(sz));
    }
    
    // end signing dependent block
    ////////
    
    
    if (IsEncrypted(secType) && SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_BULK, &var)))
    {
        Assert(var.vt == VT_BLOB);
        if (var.vt == VT_BLOB && var.blob.cbSize && var.blob.pBlobData) 
        {
            LPCTSTR pszProtocol = NULL;
            
            // Convert the SYMCAPS blob to an "encrypted using" string
            if (SUCCEEDED(MimeOleAlgNameFromSMimeCap(var.blob.pBlobData, var.blob.cbSize,
                &pszProtocol))) 
            {     // Note: returns a static string.  Don't free it.
                if (pszProtocol) 
                {
                    SendMessage(GetDlgItem(hwnd, idcStaticEncAlg), WM_SETTEXT, 0, (LPARAM)pszProtocol);
                    fNoEncAlg = FALSE;
                }
            }
            // Free the data
            MemFree(var.blob.pBlobData);
        }
    }
    if (fNoEncAlg) 
    {
        SendMessage(GetDlgItem(hwnd, idcStaticEncAlg), WM_SETTEXT, 0,
            LPARAM(LPCTSTR(szNA)));
    }
    
    if (pccert != NULL)
        CertFreeCertificateContext(pccert);
    ReleaseObj(pBody);
    return;
}

INT_PTR CALLBACK ViewSecCertDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPMIMEMESSAGE       pMsg = NULL;
    IMimeBody          *pBody;
    PROPVARIANT         var;
    DLGSECURITY         *pDlgSec;
    ULONG               secType, ulROVal;
    HWND                hwndCtrl = NULL;
    PMSGPROP            pMsgProp = (PMSGPROP)0;
    HRESULT             hr = S_OK;
    TCHAR               szTmp[CCHMAX_STRINGRES];
    HBODY               hBody = NULL;
    HBODY               hInerBody = NULL;
    SECSTATE            SecState ={0};
    
    switch (message)
    {
    case WM_INITDIALOG:
        TCHAR               szNA[CCHMAX_STRINGRES/4];

        SetWndThisPtr(hwnd, lParam);
        CenterDialog(hwnd);
        pMsgProp =  (PMSGPROP) lParam;
        pMsg = pMsgProp->pMsg;
        
        LoadString(g_hLocRes, idsNotApplicable, szNA, ARRAYSIZE(szNA));

        if(FAILED(HrGetSecurityState(pMsgProp->pMsg, &SecState, &hBody)))
            return FALSE;

        if(FAILED(HrGetInnerLayer(pMsgProp->pMsg, &hInerBody)))
            return FALSE;

        if((!IsSignTrusted(&SecState) || !IsEncryptionOK(&SecState)) && (hBody != hInerBody))
            EnableWindow(GetDlgItem(hwnd, idcAddCert), FALSE);

        CleanupSECSTATE(&SecState);

        if (FAILED(pMsgProp->pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
            return FALSE;

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var)))
            secType = var.ulVal;
        
        // Set up storage for the other security info that
        // we care about
        if (MemAlloc((LPVOID *)&pDlgSec, sizeof(DLGSECURITY)))
        {
            memset(pDlgSec, 0, sizeof(DLGSECURITY));
#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
            {
                pDlgSec->hcMsg = (HCERTSTORE)(var.pulVal);     // Closed in WM_DESTROY
            }
            
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
            {
                // we don't have to dupe the pDlgSec cert because we won't free
                // the var's.
                pDlgSec->pSenderCert = (PCCERT_CONTEXT)(var.pulVal);
            }
#else   // !_WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
            {
                pDlgSec->hcMsg = (HCERTSTORE) var.ulVal;     // Closed in WM_DESTROY
            }
            
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
            {
                // we don't have to dupe the pDlgSec cert because we won't free
                // the var's.
                pDlgSec->pSenderCert = (PCCERT_CONTEXT) var.ulVal;
            }
#endif  // _WIN64
            hr = GetSignerEncryptionCert(pMsgProp->pMsg, &pDlgSec->pEncSenderCert,
                &pDlgSec->tbSenderThumbprint, &pDlgSec->blSymCaps,
                &pDlgSec->ftSigningTime);
            if (FAILED(hr) && (hr != MIME_E_SECURITY_NOCERT))
            {
                SUCCEEDED(hr);
            }
        }
        if(IsEncrypted(secType))
        {
#ifdef _WIN64
            if (SUCCEEDED(hr = pBody->GetOption(OID_SECURITY_CERT_DECRYPTION_64, &var)))
            {
                Assert(VT_UI8 == var.vt);
                if ((PCCERT_CONTEXT)(var.pulVal))
                    pDlgSec->pEncryptionCert = (PCCERT_CONTEXT)(var.pulVal);
            }

#else // !_WIN64

            if (SUCCEEDED(hr = pBody->GetOption(OID_SECURITY_CERT_DECRYPTION, &var)))
            {
                Assert(VT_UI4 == var.vt);
                if (*(PCCERT_CONTEXT *)(&(var.uhVal)))
                    pDlgSec->pEncryptionCert = *(PCCERT_CONTEXT *)(&(var.uhVal));
            }
#endif // _WIN64
        }
        else
            pDlgSec->pEncryptionCert = NULL;

        SET_DIALOG_SECURITY(hwnd, (LPARAM)pDlgSec);

        if (pDlgSec->pEncSenderCert == NULL)
        {
            // Disable Add to Address Book button
            if ((hwndCtrl = GetDlgItem(hwnd, idcAddCert)))
                EnableWindow(hwndCtrl, FALSE);
            
            // Disable View sender's encrypt cert.
            if ((hwndCtrl = GetDlgItem(hwnd, idcSendersEncryptionCert)))
                EnableWindow(hwndCtrl, FALSE);

            LoadString(g_hLocRes, idsEncrCertNotIncluded, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticSendersCert, LPCTSTR(szTmp));
        }            
            //
        if (pDlgSec->pSenderCert == NULL)
        {
            if ((hwndCtrl = GetDlgItem(hwnd, idcVerifySig)))
                EnableWindow(hwndCtrl, FALSE);

            LoadString(g_hLocRes, idsSignCertNotIncl, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticSigningCert, LPCTSTR(szTmp));
        }
            
        if(pDlgSec->pEncryptionCert == NULL)
        {
            if ((hwndCtrl = GetDlgItem(hwnd, idcViewEncrytionCert)))
                EnableWindow(hwndCtrl, FALSE);
                
            if(IsEncrypted(secType))
                LoadString(g_hLocRes, idsEncrCertNotFoundOnPC, szTmp, ARRAYSIZE(szTmp));
            else
                LoadString(g_hLocRes, idsMsgWasNotEncrypted, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticEncryptionCert, LPCTSTR(szTmp));
        }

        if(pDlgSec->blSymCaps.cbSize > 0)
        {
            // Convert the SYMCAPS blob to an "encrypted using" string
            LPCTSTR pszProtocol = NULL;
            if (SUCCEEDED(MimeOleAlgNameFromSMimeCap(pDlgSec->blSymCaps.pBlobData, pDlgSec->blSymCaps.cbSize,
                &pszProtocol))) 
            {     // Note: returns a static string.  Don't free it.
                if (pszProtocol) 
                    SetDlgItemText(hwnd, idcStaticEncryptAlgorithm, LPCTSTR(pszProtocol));
            }

        }
        else
            SetDlgItemText(hwnd, idcStaticEncryptAlgorithm, LPCTSTR(szNA));

            
        if(pBody)
            ReleaseObj(pBody);
        
        break;

    case WM_COMMAND:
        
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
        pMsg = pMsgProp->pMsg;
        
        switch (LOWORD(wParam))
        {
        case idcAddCert:
            
            // Get thumbprint into WAB and cert into AddressBook CAPI store
            // cert goes to store first so CAPI details page can find it
            if (pDlgSec && pMsgProp)
            {
                if (SUCCEEDED(HrAddSenderCertToWab(hwnd,
                    pMsgProp->pMsg,
                    pMsgProp->lpWabal,
                    &pDlgSec->tbSenderThumbprint,
                    &pDlgSec->blSymCaps,
                    pDlgSec->ftSigningTime,
                    WFF_CREATE | WFF_SHOWUI)))
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsSenderCertAdded), NULL, MB_ICONINFORMATION | MB_OK);
                }
            }
            break;
            
        case idcVerifySig:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pSenderCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case idcViewEncrytionCert:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pEncryptionCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case idcSendersEncryptionCert:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pEncSenderCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            return(TRUE);
            
        }
        
        break; // wm_command
    case WM_CLOSE:
        SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
        return (TRUE);
            
    case WM_DESTROY:
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        if (pDlgSec)
        {
            if (pDlgSec->pSenderCert)
                CertFreeCertificateContext(pDlgSec->pSenderCert);
            if (pDlgSec->pEncSenderCert)
                CertFreeCertificateContext(pDlgSec->pEncSenderCert);
            if (pDlgSec->pEncryptionCert)
                CertFreeCertificateContext(pDlgSec->pEncryptionCert);
            if (pDlgSec->tbSenderThumbprint.pBlobData)
                MemFree(pDlgSec->tbSenderThumbprint.pBlobData);
            if (pDlgSec->hcMsg) 
            {
                if (! CertCloseStore(pDlgSec->hcMsg, 0)) 
                {
                    DOUTL(DOUTL_CRYPT, "CertCloseStore (message store) failed");
                }
                pDlgSec->hcMsg = NULL;
            }
                
            MemFree(pDlgSec);
                
            CLEAR_DIALOG_SECURITY(hwnd);
        }
            
    } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\msgprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgprop.h
//
//  PURPOSE:    Types, structs, and functions for the Message Properties 
//              prop sheet.
//

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Defines
//

interface IMimeMessage;
typedef DWORD MSGFLAGS;

class CWabal;
typedef CWabal *LPWABAL;

////////////////////////////////////////////////////////////////////////////
// New Types
//

// This is set in the MSGPROP structure to set which page in the propsheet
// is visible by default.
typedef enum tagMSGPAGE {
    MP_GENERAL = 0,
    MP_DETAILS,
    MP_SECURITY
} MSGPAGE;

// Tells the propsheet if the message that properties are being displayed for
// is news or mail.
typedef enum tagMSGPROPTYPE {
    MSGPROPTYPE_MAIL = 0,
    MSGPROPTYPE_NEWS,
    MSGPROPTYPE_MAX
} MSGPROPTYPE;

// This is used when a property sheet is to be invoked on a message that either
// is under composition or has not yet been downloaded.
typedef struct tagNOMSGDATA {
    LPCTSTR         pszSubject;
    LPCTSTR         pszFrom;
    LPCTSTR         pszSent;
    ULONG           ulSize;
    ULONG           cAttachments;
    IMSGPRIORITY    Pri;
} NOMSGDATA, *PNOMSGDATA;

// This structure defines the information needed to invoke the property 
// sheet.
typedef struct MSGPROP_tag
{
    // Basic fields necessary (Required)
    HWND            hwndParent;     // (Required) Handle of the window to parent the propsheet to
    MSGPROPTYPE     type;           // (Required) Type of message
    MSGPAGE         mpStartPage;    // (Required) Page to make visible initially
    BOOL            fSecure;        // (Required) If this is TRUE, lpWabal and pSecureMsg must be valid

    // Message Information
    MSGFLAGS        dwFlags;        // (Required) ARF_* flags
    LPCTSTR         szFolderName;   // (Optional) Folder or Newsgroup where the message is located
    IMimeMessage   *pMsg;           // (Optional) NULL for unsent sendnote
    PNOMSGDATA      pNoMsgData;     // (Optional) If pMsg is NULL, this must be valid

    // S/MIME goo
    LPWABAL         lpWabal;        // (Optional) 
    IMimeMessage   *pSecureMsg;     // (Optional) only valid if pNoMsgData is NULL and fSecure is TRUE

    // Hacks
    BOOL            fFromListView; 
} MSGPROP, *PMSGPROP;


/////////////////////////////////////////////////////////////////////////////
// Functions
//

HRESULT HrMsgProperties(PMSGPROP pmp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\note.cpp ===
#include "pch.hxx"
#include "note.h"
#include "header.h"
#include "envcid.h"
#include "envguid.h"
#include "bodyutil.h"
#include "sigs.h"
#include "mehost.h"
#include "conman.h"
#include "menuutil.h"
#include "url.h"
#include "fonts.h"
#include "multlang.h"
#include "statnery.h"
#include "spell.h"
#include "oleutil.h"
#include "htmlhelp.h"
#include "shared.h"
#include "acctutil.h"
#include "menures.h"
#include "instance.h"
#include "inetcfg.h"
#include "ipab.h"
#include "msgprop.h"
#include "finder.h"
#include "tbbands.h"
#include "demand.h"
#include "multiusr.h"
#include <ruleutil.h>
#include "instance.h"
#include "mapiutil.h"
#include "regutil.h"
#include "storecb.h"
#include "receipts.h"
#include "mirror.h"
#include "secutil.h"
#include "seclabel.h"
#include "shlwapip.h"
#include "mshtmcid.h"

#define cxRect(rc)  (rc.right - rc.left)
#define cyRect(rc)  (rc.bottom - rc.top)
#define cyMinEdit   30

enum {
    MORFS_UNKNOWN = 0,
    MORFS_CLEARING,
    MORFS_SETTING,
};

// Static Variables
static const TCHAR  c_szEditWebPage[] = "EditWebPages";

static DWORD        g_dwTlsActiveNote = 0xffffffff;
static HIMAGELIST   g_himlToolbar = 0;
static RECT         g_rcLastResize = {50,30,450,450};    // default size
static HACCEL       g_hAccelRead = 0,
                    g_hAccelSend = 0;

//Static Functions

void SetTlsGlobalActiveNote(CNote* pNote)
{
    SideAssert(0 != TlsSetValue(g_dwTlsActiveNote, pNote));
}

CNote* GetTlsGlobalActiveNote(void) 
{ 
    return (CNote*)TlsGetValue(g_dwTlsActiveNote); 
}

void InitTlsActiveNote()
{
    // Allocate a global TLS active note index
    g_dwTlsActiveNote = TlsAlloc();
    Assert(g_dwTlsActiveNote != 0xffffffff);
    SideAssert(0 != TlsSetValue(g_dwTlsActiveNote, NULL));
}

void DeInitTlsActiveNote()
{
    // Free the tls index
    TlsFree(g_dwTlsActiveNote);
    g_dwTlsActiveNote = 0xffffffff;
}

// *************************
HRESULT CreateOENote(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    TraceCall("CreateOENote");

    Assert(ppUnknown);

    *ppUnknown = NULL;

    // Create me
    CNote *pNew = new CNote();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IOENote *);

    // Done
    return S_OK;
}

// *************************
BOOL Note_Init(BOOL fInit)
{
    static BOOL     fInited=FALSE;
    WNDCLASSW       wc;

    DOUTL(4, "Note_Init: %d", (int)fInit);

    if(fInit)
    {
        if(fInited)
        {
            DOUTL(4, "Note_Init: already inited");
            return TRUE;
        }
        wc.style         = CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc   = (WNDPROC)CNote::ExtNoteWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = g_hInst;
        wc.hIcon         = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMessageAtt));
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_wszNoteWndClass;

        if(!RegisterClassWrapW(&wc))
            return FALSE;

        if(!FHeader_Init(TRUE))
            return FALSE;

        fInited=TRUE;
        DOUTL(4, "Note_Init: success");

        return TRUE;
    }
    else
    {
        // save back to registry
        UnregisterClassWrapW(c_wszNoteWndClass, g_hInst);
        if(g_himlToolbar)
        {
            ImageList_Destroy(g_himlToolbar);
            g_himlToolbar=0;
        }

        FHeader_Init(FALSE);

        fInited=FALSE;
        DOUTL(4, "Note_Init: deinit OK");
        return TRUE;
    }
}

HRESULT _HrBlockSender(RULE_TYPE typeRule, IMimeMessage * pMsg, HWND hwnd)
{
    HRESULT         hr = S_OK;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;

    // Check incoming params
    if ((NULL == pMsg) || (NULL == hwnd))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the address to add
    rSender.dwProps = IAP_EMAIL;
    hr = pMsg->GetSender(&rSender);
    if (FAILED(hr))
    {
        goto exit;
    }
        
    Assert(ISFLAGSET(rSender.dwProps, IAP_EMAIL));
    if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
    {
        goto exit;
    }

    // Add the sender to the list
    hr = RuleUtil_HrAddBlockSender(typeRule, rSender.pszEmail);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load the template string
    AthLoadString(idsSenderAdded, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * (lstrlen(szRes) + lstrlen(rSender.pszEmail) + 1));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the warning string
    wsprintf(pszResult, szRes, rSender.pszEmail);

    // Show the success dialog
    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_OK | MB_ICONINFORMATION);

    // Set the return value
    hr = S_OK;

exit:
    SafeMemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

// *************************
LRESULT CALLBACK CNote::ExtNoteWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNote *pNote=0;

    if(msg==WM_CREATE)
    {
        pNote=(CNote*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(pNote && pNote->WMCreate(hwnd))
            return 0;
        else
            return -1;
    }

    pNote = (CNote*)GetWndThisPtr(hwnd);
    if(pNote)
    {
        return pNote->WndProc(hwnd, msg, wParam, lParam);
    }
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

// *************************
CNote::CNote()
{
    // Initialized in Init:
    //      m_rHtmlOpt
    //      m_rPlainOpt
    // Set before used:
    //      m_pTabStopArray

    CoIncrementInit("CNote", MSOEAPI_START_SHOWERRORS, NULL, NULL);
    m_punkPump = NULL;
    m_pHdr = NULL; 
    m_pMsg = NULL; 
    m_pCancel = NULL;
    m_pstatus = NULL;
    m_pMsgSite = NULL; 
    m_pPrstMime = NULL;
    m_pBodyObj2 = NULL; 
    m_pCmdTargetHdr = NULL; 
    m_pCmdTargetBody = NULL;
    m_pDropTargetHdr = NULL; 
    m_pTridentDropTarget = NULL;
    m_pToolbarObj = NULL;

    m_hwnd = 0; 
    m_hMenu = 0;
    m_hIcon = 0;
    m_hbmBack = 0; 
    m_hCursor = 0;
    m_hCharset = 0; 
    m_hTimeout = 0;
    m_hwndRebar = 0;
    m_hwndFocus = 0; 
    m_hwndOwner = 0; 
    m_hmenuLater = 0;
    m_hwndToolbar = 0; 
    m_hmenuAccounts = 0; 
    m_hmenuLanguage = 0; 

    m_dwNoteAction = 0; 
    m_dwIdentCookie = 0;
    m_dwNoteCreateFlags = 0; 
    m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
    m_dwCBMarkType = MARK_MAX;
    m_OrigOperationType = SOT_INVALID;

    m_fHtml = TRUE; 
    m_fMail = TRUE; 
    m_fCBCopy = FALSE;
    m_fReadNote = FALSE; 
    m_fProgress = FALSE;
    m_fCommitSave = TRUE;
    m_fTabStopsSet = FALSE; 
    m_fCompleteMsg = FALSE; 
    m_fHasBeenSaved = FALSE;
    m_fPackageImages = TRUE; 
    m_fWindowDisabled = FALSE;
    m_fHeaderUIActive = FALSE; 
    m_fOrgCmdWasDelete = FALSE;
    m_fUseReplyHeaders = FALSE;
    m_fCBDestroyWindow = FALSE;
    m_fBypassDropTests = FALSE; 
    m_fOnDocReadyHandled = FALSE;
    m_fOriginallyWasRead = FALSE;
    m_fUseStationeryFonts = FALSE; 
    m_fBodyContainsFrames = FALSE; 
    m_fPreventConflictDlg = FALSE;
    m_fInternal = FALSE;
    m_fForceClose = FALSE;

    m_pLabel = NULL;
    if(FPresentPolicyRegInfo() && IsSMIME3Supported())
    {
        m_fSecurityLabel = !!DwGetOption(OPT_USE_LABELS);
        HrGetOELabel(&m_pLabel);
    }
    else
        m_fSecurityLabel = FALSE;

    if(IsSMIME3Supported())
    {
        m_fSecReceiptRequest = !!DwGetOption(OPT_SECREC_USE);
    }
    else
        m_fSecReceiptRequest = FALSE;

    m_ulPct = 0;
    m_iIndexOfBody = -1;    

    m_cRef = 1; 
    m_cAcctMenu = 0; 
    m_cAcctLater = 0; 
    m_cTabStopCount = 0; 

    m_fStatusbarVisible = !!DwGetOption(OPT_SHOW_NOTE_STATUSBAR);
    m_fFormatbarVisible = !!DwGetOption(OPT_SHOW_NOTE_FMTBAR);
    
    InitializeCriticalSection(&m_csNoteState);
    m_nisNoteState = NIS_INIT;

    if (!g_hAccelRead)
        g_hAccelRead = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_READ_NOTE_ACCEL));
    if (!g_hAccelSend)
        g_hAccelSend = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_SEND_NOTE_ACCEL));

    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));

    m_dwRequestMDNLocked = GetLockKeyValue(c_szRequestMDNLocked);    
}

// *************************
CNote::~CNote()
{
    if (0 != m_hmenuLanguage)
    {
        // unload global MIME language codepage data
        DeinitMultiLanguage();
        DestroyMenu(m_hmenuLanguage);
    }

    if (m_hMenu != NULL)
        DestroyMenu(m_hMenu);

    if (m_hIcon)
        DestroyIcon(m_hIcon);

    if (m_hbmBack)
        DeleteObject(m_hbmBack);

    // sometimes we get a setfocus in our processing of DestroyWindow
    // this causes a WM_ACTIVATE to the note without a corresponding
    // WM_DEACTIVATE. if at the time the note dies, the global note ptr
    // has our this ptr in it, null it out to be safe.
    if (this == GetTlsGlobalActiveNote())
    {
        Assert(!(m_dwNoteCreateFlags & OENCF_MODAL));
        SetTlsGlobalActiveNote(NULL);
    }

    SafeMemFree(m_pLabel);

    ReleaseObj(m_pMsg);
    ReleaseObj(m_pHdr);
    ReleaseObj(m_pstatus);
    ReleaseObj(m_pCancel);
    ReleaseObj(m_pMsgSite);
    ReleaseObj(m_punkPump);
    ReleaseObj(m_pPrstMime);
    ReleaseObj(m_pBodyObj2);
    ReleaseObj(m_pCmdTargetHdr);
    ReleaseObj(m_pCmdTargetBody);
    ReleaseObj(m_pDropTargetHdr);
    ReleaseObj(m_pTridentDropTarget);

    SafeRelease(m_pToolbarObj);    

    CallbackCloseTimeout(&m_hTimeout);
    
    DeleteCriticalSection(&m_csNoteState);
    CoDecrementInit("CNote", NULL);    
}

// *************************
ULONG CNote::AddRef()
{
    return ++m_cRef;
}

// *************************
ULONG CNote::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// *************************
HRESULT CNote::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    HRESULT hr;

    if(!ppvObj)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = ((IUnknown *)(IOENote *)this);
    else if(IsEqualIID(riid, IID_IOENote))
        *ppvObj = (IOENote *)this;
    else if (IsEqualIID(riid, IID_IBodyOptions))
        *ppvObj = (IBodyOptions *)this;
    else if(IsEqualIID(riid, IID_IDropTarget))
        *ppvObj = (IDropTarget *)this;
    else if (IsEqualIID(riid, IID_IHeaderSite))
        *ppvObj = (IHeaderSite *)this;
    else if(IsEqualIID(riid, IID_IPersistMime))
        *ppvObj = (IPersistMime *)this;
    else if(IsEqualIID(riid, IID_IServiceProvider))
        *ppvObj = (IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IDockingWindowSite))
        *ppvObj = (IDockingWindowSite*)this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (IIdentityChangeNotify*)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (IOleCommandTarget*)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (ITimeoutCallback *) this;
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    hr = NOERROR;

exit:
    return hr;
}

// *************************
HRESULT CNote::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (!rgCmds)
        return E_INVALIDARG;
    if (!pguidCmdGroup)
        return hr;

    // We are closing down
    if (!m_pMsgSite)
        return E_UNEXPECTED;

    if (m_pCmdTargetHdr)
        m_pCmdTargetHdr->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
        
    if (m_pCmdTargetBody)
        m_pCmdTargetBody->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
    
    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText, m_fMail);

    if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        DWORD   dwStatusFlags = 0;
        BOOL    fCompleteMsg = !!m_fCompleteMsg;
        BOOL    fHtmlSettingsOK = m_fHtml && !m_fBodyContainsFrames;

        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            ULONG cmdID = rgCmds[ul].cmdID;

            // There are certain cases that need to be overridden even if the earlier
            // components enabled or disabled them. They are in this switch statement.
            switch (cmdID)
            {
                // Until trident allows printing in edit mode, don't allow this. RAID 35635
                case ID_PRINT:
                case ID_PRINT_NOW:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && m_fReadNote);
                    continue;
            }

            if (0 != rgCmds[ul].cmdf)
                continue;

            switch (cmdID)
            {
                case ID_POPUP_LANGUAGE:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg);
                    break;

                case ID_NOTE_SAVE_AS:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg || !m_fReadNote);
                    break;

                case ID_WORK_OFFLINE:
                    rgCmds[ul].cmdf = QS_CHECKED(g_pConMan->IsGlobalOffline());
                    break;

                case ID_CREATE_RULE_FROM_MESSAGE:
                case ID_BLOCK_SENDER:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && (0 == (OEMSF_RULESNOTENABLED & dwStatusFlags)));
                    break;

                case ID_REPLY:
                case ID_REPLY_ALL:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && fCompleteMsg);
                    break;

                case ID_REPLY_GROUP:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && !m_fMail && fCompleteMsg);
                    break;

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && fCompleteMsg);
                    break;

                case ID_UNSCRAMBLE:
                    rgCmds[ul].cmdf = QS_ENABLED(!m_fMail && m_fReadNote);
                    break;
                    
                case ID_POPUP_FORMAT:
                case ID_INSERT_SIGNATURE:
                    rgCmds[ul].cmdf = QS_ENABLED(!m_fBodyContainsFrames);
                    break;

                case ID_NOTE_COPY_TO_FOLDER:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_COPY & dwStatusFlags));
                    break;

                // Can move message if is readnote, or compose note where the message was store based.
                case ID_NOTE_MOVE_TO_FOLDER:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_MOVE & dwStatusFlags) && (m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)));
                    break;

                case ID_NOTE_DELETE:
                    // We should be able to delete anything that msgsite says we can delete 
                    // so long as we are a read note, or we are a drafts message.
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_CAN_DELETE & dwStatusFlags) && (m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)));
                    break;

                case ID_REDO:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fHeaderUIActive);
                    break;

                case ID_SAVE:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_SAVE & dwStatusFlags) && (m_fOnDocReadyHandled || !m_fReadNote));
                    break;

                case ID_NEXT_UNREAD_MESSAGE:
                case ID_NEXT_MESSAGE:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_CAN_NEXT & dwStatusFlags);
                    break;

                case ID_POPUP_NEXT:
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_CAN_PREV & dwStatusFlags) || (OEMSF_CAN_NEXT & dwStatusFlags));
                    break;

                case ID_MARK_THREAD_READ:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_THREADING_ENABLED & dwStatusFlags);
                    break;

                case ID_NEXT_UNREAD_THREAD:
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_THREADING_ENABLED & dwStatusFlags) && (OEMSF_CAN_NEXT & dwStatusFlags));
                    break;

                case ID_PREVIOUS:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_CAN_PREV & dwStatusFlags);
                    break;

                case ID_FORMAT_COLOR:
                case ID_FORMAT_COLOR1:
                case ID_FORMAT_COLOR2:
                case ID_FORMAT_COLOR3:
                case ID_FORMAT_COLOR4:
                case ID_FORMAT_COLOR5:
                case ID_FORMAT_COLOR6:
                case ID_FORMAT_COLOR7:
                case ID_FORMAT_COLOR8:
                case ID_FORMAT_COLOR9:
                case ID_FORMAT_COLOR10:
                case ID_FORMAT_COLOR11:
                case ID_FORMAT_COLOR12:
                case ID_FORMAT_COLOR13:
                case ID_FORMAT_COLOR14:
                case ID_FORMAT_COLOR15:
                case ID_FORMAT_COLOR16:
                case ID_BACK_COLOR_AUTO:
                case ID_FORMAT_COLORAUTO:
                case ID_POPUP_BACKGROUND:
                    rgCmds[ul].cmdf = QS_ENABLED(fHtmlSettingsOK);
                    break;

                case ID_FORMATTING_TOOLBAR:
                    rgCmds[ul].cmdf = QS_ENABLECHECK((m_fHtml && !m_fBodyContainsFrames), m_fFormatbarVisible);
                    break;

                case ID_SHOW_TOOLBAR:
                    rgCmds[ul].cmdf = QS_CHECKED(m_fToolbarVisible);
                    break;

                case ID_STATUS_BAR:
                    rgCmds[ul].cmdf = QS_CHECKED(m_fStatusbarVisible);
                    break;

                case ID_SEND_OBJECTS:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(fHtmlSettingsOK, m_fPackageImages);
                    break;

                case ID_RICH_TEXT:
                    rgCmds[ul].cmdf = QS_RADIOED(m_fHtml);
                    break;

                case ID_PLAIN_TEXT:
                    rgCmds[ul].cmdf = QS_RADIOED(!m_fHtml);
                    break;

                case ID_FLAG_MESSAGE:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(OEMSF_CAN_MARK & dwStatusFlags, IsFlagged());
                    break;

                case ID_WATCH_THREAD:
                    rgCmds[ul].cmdf = QS_CHECKED(IsFlagged(ARF_WATCH));
                    break;

                case ID_IGNORE_THREAD:
                    rgCmds[ul].cmdf = QS_CHECKED(IsFlagged(ARF_IGNORE));
                    break;

                case ID_POPUP_NEW:
                case ID_NOTE_PROPERTIES:
                case ID_CLOSE:
                case ID_POPUP_FIND:
                case ID_POPUP_LANGUAGE_DEFERRED:
                case ID_POPUP_FONTS:
                case ID_ADDRESS_BOOK:
                case ID_POPUP_ADDRESS_BOOK:
                case ID_ADD_SENDER:
                case ID_ADD_ALL_TO:
                case ID_POPUP_TOOLBAR:
                case ID_CUSTOMIZE:

                // Help Menus
                case ID_HELP_CONTENTS:
                case ID_README:
                case ID_POPUP_MSWEB:
                case ID_MSWEB_FREE_STUFF:
                case ID_MSWEB_PRODUCT_NEWS:
                case ID_MSWEB_FAQ:
                case ID_MSWEB_SUPPORT:
                case ID_MSWEB_FEEDBACK:
                case ID_MSWEB_BEST:
                case ID_MSWEB_SEARCH:
                case ID_MSWEB_HOME:
                case ID_MSWEB_HOTMAIL:
                case ID_ABOUT:

                case ID_FIND_MESSAGE:
                case ID_FIND_PEOPLE:
                case ID_FIND_TEXT:
                case ID_SELECT_ALL:
                case ID_POPUP_LANGUAGE_MORE:
                case ID_SEND_NOW:
                case ID_SEND_LATER:
                case ID_SEND_MESSAGE:
                case ID_SEND_DEFAULT:
                    rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    break;

                case ID_REQUEST_READRCPT:
                    if (m_fMail)
                    {
                        rgCmds[ul].cmdf = QS_CHECKFORLATCH(!m_dwRequestMDNLocked, 
                                                         !!(dwStatusFlags & OEMSF_MDN_REQUEST));
                    }
                    else
                    {
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);
                    }
                    break;
                case ID_INCLUDE_LABEL:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_CHECKED(m_fSecurityLabel);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                    break;

                case ID_LABEL_SETTINGS:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_ENABLED(m_fSecurityLabel);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                    break;

                case ID_SEC_RECEIPT_REQUEST:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_CHECKED(m_fSecReceiptRequest);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                default:
                    if ((ID_LANG_FIRST <= cmdID) && (ID_LANG_LAST >= cmdID))
                    {
                        rgCmds[ul].cmdf = OLECMDF_SUPPORTED | SetMimeLanguageCheckMark(CustomGetCPFromCharset(m_hCharset, m_fReadNote), cmdID - ID_LANG_FIRST);
                    }

                    if (((ID_ADD_RECIPIENT_FIRST <= cmdID) && (ID_ADD_RECIPIENT_LAST >= cmdID)) ||
                        ((ID_APPLY_STATIONERY_0 <= cmdID) && (ID_APPLY_STATIONERY_NONE >= cmdID)))
                        rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    else if ((ID_SIGNATURE_FIRST <= cmdID) && (ID_SIGNATURE_LAST >= cmdID))
                        rgCmds[ul].cmdf = QS_ENABLED(!m_fBodyContainsFrames);
                    break;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// *************************
HRESULT CNote::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,  VARIANTARG *pvaOut)
{
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::ClearDirtyFlag()
{
    m_pBodyObj2->HrSetDirtyFlag(FALSE);

    HeaderExecCommand(MSOEENVCMDID_DIRTY, MSOCMDEXECOPT_DODEFAULT, NULL);
    return S_OK;
}

// *************************
HRESULT CNote::IsDirty(void)
{
    OLECMD  rgCmd[] = {{MSOEENVCMDID_DIRTY, 0}};
    BOOL    fBodyDirty = FALSE;

    m_pBodyObj2->HrIsDirty(&fBodyDirty);
    if (fBodyDirty)
        return S_OK;

    if (m_pCmdTargetHdr)
        m_pCmdTargetHdr->QueryStatus(&CGID_Envelope, 1, rgCmd, NULL);

    return (0 != (rgCmd[0].cmdf&OLECMDF_ENABLED)) ? S_OK : S_FALSE;
}

// *************************
HRESULT CNote::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT         hr;
    VARIANTARG      var;
    IPersistMime   *pPMHdr=0;
    BOOL fWarnUser = (OENA_WEBPAGE == m_dwNoteAction ) || 
                     (OENA_COMPOSE == m_dwNoteAction ) || 
                     (OENA_STATIONERY == m_dwNoteAction ) || 
                     (OENA_FORWARD == m_dwNoteAction);

    if (!m_pHdr)
        return E_FAIL;

    // OnDocumentReady will get call on the CheckForFramesets function.
    // Don't want that document ready to matter. Set this flag to true so
    // the doc ready doesn't do anything. Once the check is done, we will
    // set this flag to false again.
    m_fOnDocReadyHandled = TRUE;

    // If not a read note and contains frames, need to see what user wants to do 
    if (!m_fReadNote)
    {
        hr = HrCheckForFramesets(pMsg, fWarnUser);
        if (FAILED(hr))
            goto Exit;

        if (hr == S_READONLY)
            m_fBodyContainsFrames = TRUE;
    }

    ReplaceInterface(m_pMsg, pMsg);

    // The next OnDocumentReady should be run.
    m_fOnDocReadyHandled = FALSE;

    hr = m_pHdr->QueryInterface(IID_IPersistMime, (LPVOID*)&pPMHdr);
    if (FAILED(hr))
        return hr;

    hr = pPMHdr->Load(pMsg);
    if (FAILED(hr))
        goto Exit;

    m_pHdr->SetFlagState(IsFlagged(ARF_FLAGGED) ? MARK_MESSAGE_FLAGGED : MARK_MESSAGE_UNFLAGGED);

    if (IsFlagged(ARF_WATCH))
        m_pHdr->SetFlagState(MARK_MESSAGE_WATCH);
    else if (IsFlagged(ARF_IGNORE))
        m_pHdr->SetFlagState(MARK_MESSAGE_IGNORE);
    else
        m_pHdr->SetFlagState(MARK_MESSAGE_NORMALTHREAD);

    if (m_fCompleteMsg)
        hr = m_pPrstMime->Load(pMsg);

    CheckAndForceEncryption();

Exit:
    if (FAILED(hr))
        // ~~~ This should eventually be an html error message
        m_pBodyObj2->HrUnloadAll(idsErrHtmlBodyFailedToLoad, NULL);

    ReleaseObj(pPMHdr);
    return hr;
}


// *************************
void CNote::CheckAndForceEncryption()
{
    BOOL fCheck = FALSE;
    if(m_fSecurityLabel && m_pLabel)
    {
        DWORD dwFlags;
        if (SUCCEEDED(HrGetPolicyFlags(m_pLabel->pszObjIdSecurityPolicy, &dwFlags)))
        {   
            if(dwFlags & SMIME_POLICY_MODULE_FORCE_ENCRYPTION)
                fCheck = TRUE;
        }
    }
    m_pHdr->ForceEncryption(&fCheck, TRUE);
}

// *************************
HRESULT CNote::SetCharsetUnicodeIfNeeded(IMimeMessage *pMsg)
{
    HRESULT         hr = S_OK;
    VARIANTARG      va;
    PROPVARIANT     Variant;
    int             ret;
    HCHARSET        hCharSet;
    UINT            cpID = 0;

    // Call dialog only if sending a mime message
    // See raid 8436 or 79339 in the IE/OE 5 database. We can't send
    // unicode encoding unless we are a mime message.
    if (m_fHtml || m_rPlainOpt.fMime)
    {

        m_fPreventConflictDlg = FALSE;

        if (SUCCEEDED(GetCharset(&hCharSet)))
        {
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }
        else
        {
            pMsg->GetCharset(&hCharSet);
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }

        // Check to see if have chars that don't work in encoding
        va.vt = VT_UI4;
        va.ulVal = cpID;
        IF_FAILEXIT(hr = m_pCmdTargetBody->Exec(&CMDSETID_MimeEdit, MECMDID_CANENCODETEXT, 0, &va, NULL));

        if (MIME_S_CHARSET_CONFLICT == hr)
        {
            // Don't let header call conflict dialog again
            m_fPreventConflictDlg = TRUE;

            ret = IntlCharsetConflictDialogBox();
            if (idcSendAsUnicode == ret)
            {
                // User choose to send as Unicode (UTF8). set new charset and resnd
                hCharSet = GetMimeCharsetFromCodePage(CP_UTF8);
                ChangeCharset(hCharSet);
            }
            else if (IDOK != ret)
            {
                // return to edit mode and bail out
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
        }
    }
    else
        // Since we are not mime, don't show dialog ever.
        m_fPreventConflictDlg = TRUE;

exit:
    return hr;
}

// *************************
HRESULT CNote::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    HRESULT         hr;
    IPersistMime*   pPersistMimeHdr=0;
    DWORD           dwHtmlFlags = PMS_TEXT;

    if(!m_pHdr)
        IF_FAILEXIT(hr = E_FAIL);

    IF_FAILEXIT(hr = SetCharsetUnicodeIfNeeded(pMsg));

    IF_FAILEXIT(hr = m_pHdr->QueryInterface(IID_IPersistMime, (LPVOID*)&pPersistMimeHdr));

    IF_FAILEXIT(hr = pPersistMimeHdr->Save(pMsg, TRUE));

    if (m_fHtml)
        dwHtmlFlags |= PMS_HTML;

    IF_FAILEXIT(hr = m_pPrstMime->Save(pMsg, dwHtmlFlags));

    UpdateMsgOptions(pMsg);

    // During a send, don't want to commit at this time. m_fCommitSave
    // is set to false during a send.
    if (m_fCommitSave)
    {
        hr = pMsg->Commit(0);
        // temporary hack for #27823
        if((hr == MIME_E_SECURITY_NOSIGNINGCERT) || 
           (hr == MIME_E_SECURITY_ENCRYPTNOSENDERCERT) ||
           (hr == MIME_E_SECURITY_CERTERROR) ||
           (hr == MIME_E_SECURITY_NOCERT) )  // too early for this error
            hr = S_OK;
    }

exit:
    ReleaseObj(pPersistMimeHdr);
    return hr;
}

// *************************
HRESULT CNote::InitNew(void)
{
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::GetClassID(CLSID *pClsID)
{
    return NOERROR;
}

// *************************
HRESULT CNote::SignatureEnabled(BOOL fAuto)
{
    int     cSig;
    HRESULT hr;
    DWORD   dwSigFlag;
    
    if (m_fBodyContainsFrames || m_fReadNote || (OENA_WEBPAGE == m_dwNoteAction))
        return S_FALSE;
    if (FAILED(g_pSigMgr->GetSignatureCount(&cSig)) || (0 == cSig))
        return S_FALSE;

    if (!fAuto)     // for non-auto scenario's it's cool to insert a sig, as there is one.
        return S_OK;

    // From this point down, we are only talking about insertion upon creation

    if (OENCF_NOSIGNATURE & m_dwNoteCreateFlags)
        return S_FALSE;

    dwSigFlag = DwGetOption(OPT_SIGNATURE_FLAGS);

    // if its a sendnote: check autonew. for automatically appending the signature. We only append on a virgin sendnote or a stationery sendnote.
    // as if it's been saved to the store, the signature is already there.
    // if in a reply or forward, then check for auto-reply.
    switch (m_dwNoteAction)
    {
        // If it is a compose note, make sure it wasn't from the store or file system, that it doesn't have any
        // body parts, and that the sig flag is set
        case OENA_COMPOSE:
        {
            Assert(m_pMsgSite);
            if (m_pMsgSite)
                hr = (!m_fOriginallyWasRead && (S_FALSE == HrHasBodyParts(m_pMsg)) && (dwSigFlag & SIGFLAG_AUTONEW)) ? S_OK : S_FALSE;
            else
                hr = S_FALSE;
            break;
        }

        // For stationery, check sig flag
        case OENA_STATIONERY:
        {
            hr = (dwSigFlag & SIGFLAG_AUTONEW) ? S_OK : S_FALSE;
            break;
        }

        // Check sig flag
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
        {
            hr = (dwSigFlag & SIGFLAG_AUTOREPLY) ? S_OK : S_FALSE;
            break;
        }

        default:
            AssertSz(FALSE, "Bad note action type for signature");
            hr = S_FALSE;
    }

    return hr;
}

// *************************
HRESULT CNote::GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr)
{
    HRESULT hr;
    IImnAccount *pAcct = NULL;
    GETSIGINFO si;

    if (m_fBodyContainsFrames)
        return E_NOTIMPL;

    hr = m_pHdr->HrGetAccountInHeader(&pAcct);
    if (FAILED(hr))
        return hr;

    si.szSigID = szSigID;
    si.pAcct = pAcct;
    si.hwnd = m_hwnd;
    si.fHtmlOk = m_fHtml;
    si.fMail = m_fMail;
    si.uCodePage = GetACP();

    hr = HrGetMailNewsSignature(&si, pdwSigOptions, pbstr);
    ReleaseObj(pAcct);
    return hr;
}

// *************************
HRESULT CNote::GetMarkAsReadTime(LPDWORD pdwSecs)
{
    // Notes don't care about mark as read timers, only Views
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::GetFlags(LPDWORD pdwFlags)
{
    DWORD dwMsgSiteFlags = 0;

    if (!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags= BOPT_FROM_NOTE;   

    Assert(m_pMsgSite);
    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwMsgSiteFlags);

    // if a readnote, we can auto-inline attachments
    if (m_fReadNote)
        *pdwFlags |= BOPT_AUTOINLINE;

    // set HTML flag
    if (m_fHtml)
        *pdwFlags |= BOPT_HTML;
    else
        *pdwFlags |= BOPT_NOFONTTAG;

    if (IsReplyNote())
    {
        // If block quote option is ON, and is HTML messages
        if (m_fHtml && DwGetOption(m_fMail?OPT_MAIL_MSG_HTML_INDENT_REPLY:OPT_NEWS_MSG_HTML_INDENT_REPLY))
            *pdwFlags |= BOPT_BLOCKQUOTE;

        // Set this in all cases except where we are a reply note and the INCLUDEMSG is not set
        if (DwGetOption(OPT_INCLUDEMSG))
            *pdwFlags |= BOPT_INCLUDEMSG;
    }
    else
        *pdwFlags |= BOPT_INCLUDEMSG;

    // If is reply or forward...
    if (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction) )
    {
        *pdwFlags |= BOPT_REPLYORFORWARD;
        // ... and spell ignore is set
        if(DwGetOption(OPT_SPELLIGNOREPROTECT))
            *pdwFlags |= BOPT_SPELLINGOREORIGINAL;
    }

    // If not a read note, or a compose note that started as a compose note (ie one that was previously saved)
    if (!m_fReadNote && !m_fOriginallyWasRead)
        *pdwFlags |= BOPT_AUTOTEXT;

    if (!m_fReadNote && m_fPackageImages)
        *pdwFlags |= BOPT_SENDIMAGES;

    // ugh. OK, this is big-time sleazy. We found a security hole in SP1. To
    // plug this we need to at reply and forward time
    // mark incoming images etc as NOSEND=1 links. We do this for all messages
    // EXCEPT stationery or webpages
    if ((OENA_STATIONERY == m_dwNoteAction) || (OENA_WEBPAGE == m_dwNoteAction))
        *pdwFlags |= BOPT_SENDEXTERNALS;

    if (m_fUseStationeryFonts)
        *pdwFlags |= BOPT_NOFONTTAG;

    if (m_fReadNote && (dwMsgSiteFlags & OEMSF_SEC_UI_ENABLED))
        *pdwFlags |= BOPT_SECURITYUIENABLED;

    if (dwMsgSiteFlags & OEMSF_FROM_STORE)
        *pdwFlags |= BOPT_FROMSTORE;

    if (dwMsgSiteFlags & OEMSF_UNREAD)
        *pdwFlags |= BOPT_UNREAD;

    if (!m_fBodyContainsFrames && m_fUseReplyHeaders)
        *pdwFlags |= BOPT_USEREPLYHEADER;

    if (m_fMail)
        *pdwFlags |= BOPT_MAIL;

    return S_OK;
}

// *************************
HRESULT CNote::GetInfo(BODYOPTINFO *pBOI)
{
    HRESULT hr = S_OK;

    if (m_fBodyContainsFrames)
        return E_NOTIMPL;

    if (pBOI->dwMask & BOPTF_QUOTECHAR)
    {
        pBOI->chQuote = NULL;

        // we allow quote char in plain-text mode only
        if (!m_fHtml && (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction)))
            pBOI->chQuote =(CHAR)DwGetOption(m_fMail?OPT_MAILINDENT:OPT_NEWSINDENT);
    }

    if (pBOI->dwMask & BOPTF_REPLYTICKCOLOR)
        pBOI->dwReplyTickColor = DwGetOption(m_fMail?OPT_MAIL_FONTCOLOR:OPT_NEWS_FONTCOLOR);

    if (pBOI->dwMask & BOPTF_COMPOSEFONT)
        hr = HrGetComposeFontString(pBOI->rgchComposeFont, m_fMail);

    return hr;
}

HRESULT CNote::GetAccount(IImnAccount **ppAcct)
{
    HRESULT hr = S_OK;
#ifdef YST
    FOLDERINFO      fi;
    FOLDERID FolderID;
    hr = m_pMsgSite->GetFolderID(&FolderID);
    if (FOLDERID_INVALID != FolderID)
    {
        hr = g_pStore->GetFolderInfo(FolderID, &fi);
        if (SUCCEEDED(hr))
        {
            // Set account based upon the folder ID passed down
            if (FOLDER_LOCAL != fi.tyFolder)
            {
                char szAcctId[CCHMAX_ACCOUNT_NAME];

                hr = GetFolderAccountId(&fi, szAcctId); 
                if (SUCCEEDED(hr))
                    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctId, ppAcct);
            }
            else
                hr = m_pMsgSite->GetCurrentAccount(ppAcct);
            g_pStore->FreeRecord(&fi);
        }
    }
    else
        hr = E_FAIL;
#endif // 0

    hr = m_pHdr->HrGetAccountInHeader(ppAcct);

    return(hr);
}

// *************************
void CNote::WMSize(int cxNote, int cyNote, BOOL fInternal)
{
    RECT        rc;
    int         cy = 0;

    // assume the header autosizes itself..., unless an internal size requires we recalc...
    if(fInternal)
    {
        // if the size is coming from the header... figure out the current size
        // of the note... as cxNote and cyNote are bogus at this point...
        GetClientRect(m_hwnd, &rc);
        cxNote = cxRect(rc);
        cyNote = cyRect(rc);
    }

    if (m_pToolbarObj)
    {
        //Ideally we should be calling ResizeBorderDW. But 
        HWND rebarHwnd = m_hwndRebar;

        m_pToolbarObj->ResizeBorderDW(&rc, (IUnknown*)(IDockingWindowSite*)this, 0);
        GetWindowRect(GetParent(rebarHwnd), &rc);
        cy += cyRect(rc);
    }

    
    ResizeChildren(cxNote, cyNote, cy, fInternal);
}

void CNote::ResizeChildren(int cxNote, int cyNote, int cy, BOOL fInternal)
{
    int     cyBottom;
    RECT    rc; 
    int     cyStatus = 0;
    static  int cxBorder = 0,
                cyBorder = 0;

    if(!cxBorder || !cyBorder)
    {
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
    }

    // size the header
    GetClientRect(m_hwnd, &rc);

    // remember the actual bottom
    cyBottom = rc.bottom;
    cy += 4;

    InflateRect(&rc, -1, -1);
    rc.bottom = GetRequiredHdrHeight();
    rc.top = cy;
    rc.bottom += rc.top;
    if(!fInternal && m_pHdr)
        m_pHdr->SetRect(&rc);


    // WARNING: the header may resize itself during a size, due to an edit
    //          growing
    cy += GetRequiredHdrHeight()+2;

    cy += cyBorder; 

    if (m_pstatus)
    {
        m_pstatus->OnSize(cxNote, cyNote);
        m_pstatus->GetHeight(&cyStatus);
    }

    rc.top = cy;
    rc.bottom = cyBottom-cyBorder; // edit has a minimum size, clip if if gets too tight...

    rc.bottom -= cyStatus;

    if (m_pBodyObj2)
        m_pBodyObj2->HrSetSize(&rc);

}

// *************************
BOOL CNote::IsReplyNote()
{
    return ((OENA_REPLYTOAUTHOR == m_dwNoteAction) || (OENA_REPLYTONEWSGROUP == m_dwNoteAction) || (OENA_REPLYALL == m_dwNoteAction));
}

// *************************
HRESULT CNote::Resize(void)
{
    WMSize(0, 0, TRUE);
    return S_OK;
}

// *************************
HRESULT CNote::UpdateTitle()
{
    HRESULT     hr;
    WCHAR       wszTitle[cchHeaderMax+1];

    Assert(m_pHdr);

    *wszTitle = 0x0000;

    hr = m_pHdr->GetTitle(wszTitle, ARRAYSIZE(wszTitle));
    if(SUCCEEDED(hr))
        SetWindowTextWrapW(m_hwnd, wszTitle);

    return hr;
}

// *************************
HRESULT CNote::Update(void)
{
    m_pToolbarObj->Update();
    UpdateTitle();
    return S_OK;
}

// *************************
HRESULT CNote::OnSetFocus(HWND hwndFrom)
{
    HWND    hwndBody;

    // setfocus from a kid and not a body. make sure we
    // UIDeactivate the docobj
    SideAssert(m_pBodyObj2->HrGetWindow(&hwndBody)==NOERROR);
    if(hwndFrom != hwndBody)
        m_pBodyObj2->HrUIActivate(FALSE);

    // if focus goes to a kid, update the toolbar
    m_pToolbarObj->Update();

    // focus is going to a kid. Enable/Disable the formatbar
    m_pBodyObj2->HrUpdateFormatBar();

    return S_OK;
}

// *************************
HRESULT CNote::OnUIActivate()
{
    m_fHeaderUIActive = TRUE;
    return OnSetFocus(0);
}

// *************************
HRESULT CNote::OnKillFocus()
{
    m_pToolbarObj->Update();
    return S_OK;
}
// *************************
HRESULT CNote::OnUIDeactivate(BOOL)
{
    m_fHeaderUIActive = FALSE;
    return OnKillFocus();
}

// *************************
HRESULT CNote::IsHTML(void)
{
    return m_fHtml ? S_OK : S_FALSE;
}

HRESULT CNote::IsModal()
{
    return (m_dwNoteCreateFlags & OENCF_MODAL) ? S_OK : S_FALSE;
}

// *************************
HRESULT CNote::SetHTML(BOOL fHTML)
{
    m_fHtml = !!fHTML;
    return NOERROR;
}

#ifdef SMIME_V3
// return selected label in note
// S_OK user select label
// S_FALSE user uncheck using security labels
HRESULT CNote::GetLabelFromNote(PSMIME_SECURITY_LABEL *pplabel)
{
    if(m_fSecurityLabel && m_fMail)
    {
        *pplabel = m_pLabel;
        return S_OK;
    }
    else
    {
        *pplabel = NULL;
        return S_FALSE;
    }
}
HRESULT CNote::IsSecReceiptRequest(void)
{
    if(m_fSecReceiptRequest)
        return(S_OK);
    else
        return(S_FALSE);
}

HRESULT CNote::IsForceEncryption(void)
{
    return(m_pHdr->ForceEncryption(NULL, FALSE));
}
#endif // SMIME_V3

// *************************
HRESULT CNote::SaveAttachment(void)
{
    return m_pBodyObj2 ? m_pBodyObj2->HrSaveAttachment() : E_FAIL;
}

// *************************
HRESULT CNote::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectSave = *pdwEffect;;
    m_fBypassDropTests = FALSE;

    Assert(m_pDropTargetHdr && m_pTridentDropTarget);

    if (m_pHdr->HrIsDragSource() == S_OK)
    {
        m_fBypassDropTests = TRUE; // treated as drop to itself.
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_pDropTargetHdr->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        if (!m_fHtml) // plain text mode. If there is no text, we should not take it.
        {
            IEnumFORMATETC* pEnum = NULL;
            FORMATETC       fetc = {0};
            ULONG           celtFetched = 0;
            BOOL            fCFTEXTFound = FALSE;

            // see if there is CF_TEXT format
            if (SUCCEEDED(pDataObj->EnumFormatEtc(DATADIR_GET, &pEnum)))
            {
                pEnum->Reset();

                while (S_OK == pEnum->Next(1, &fetc, &celtFetched))
                {
                    Assert(celtFetched == 1);
                    if (fetc.cfFormat == CF_TEXT)
                    {
                        fCFTEXTFound = TRUE;
                        break;
                    }
                }

                pEnum->Release();
            }

            if (!fCFTEXTFound) // no CF_TEXT, cannot drop in plain text mode.
            {
                *pdwEffect = DROPEFFECT_NONE;
                m_fBypassDropTests = TRUE; // treated as drop to itself.
                return S_OK;
            }
        }

        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    }

    return S_OK;
}

// *************************
HRESULT CNote::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectSave = *pdwEffect;

    if (m_fBypassDropTests)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_pDropTargetHdr->DragOver(grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->DragOver(grfKeyState, pt, pdwEffect);
    }

    return S_OK;

}

// *************************
HRESULT CNote::DragLeave(void)
{
    if (m_fBypassDropTests)
        return S_OK;

    m_pDropTargetHdr->DragLeave();
    m_pTridentDropTarget->DragLeave();

    return NOERROR;
}

// *************************
HRESULT CNote::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    IDataObject    *pDataObjNew = NULL;
    HRESULT         hr = S_OK;
    STGMEDIUM       stgmed;
    DWORD           dwEffectSave = *pdwEffect;

    ZeroMemory(&stgmed, sizeof(stgmed));

    if (m_fBypassDropTests)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    m_pDropTargetHdr->Drop(pDataObj, grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE) // it is Trident's drag&drop
    {
        if(!m_fHtml)
        {
            hr = m_pBodyObj2->PublicFilterDataObject(pDataObj, &pDataObjNew);
            if(FAILED(hr))
                return E_UNEXPECTED;
        }
        else
        {
            pDataObjNew = pDataObj;
            pDataObj->AddRef();
        }

        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->Drop(pDataObjNew, grfKeyState, pt, pdwEffect);
    }

    ReleaseObj(pDataObjNew);
    return hr;
}

// *************************
HRESULT CNote::InitWindows(RECT *prc, HWND hwndOwner)
{
    HWND        hwnd;
    HMENU       hMenu;
    RECT        rcCreate,
                rc;
    HCURSOR     hcur;
    HWND        hwndCapture;
    DWORD       dwStyle = WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN;
    HRESULT     hr = S_OK;
    DWORD       dwExStyle = WS_EX_WINDOWEDGE | WS_EX_CONTROLPARENT | (IS_BIDI_LOCALIZED_SYSTEM() ? RTL_MIRRORED_WINDOW : 0L);
    WINDOWPLACEMENT wp = {0};

    Assert(hwndOwner == NULL || IsWindow(hwndOwner));
    m_hwndOwner = hwndOwner;
    hcur=SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(!Note_Init(TRUE))
        IF_FAILEXIT(hr = E_FAIL);

    if(prc)
        CopyRect(&rcCreate, prc);
    else
        CopyRect(&rcCreate, &g_rcLastResize);

    m_hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(m_fReadNote?IDR_READ_NOTE_MENU:IDR_SEND_NOTE_MENU));
    MenuUtil_ReplaceHelpMenu(m_hMenu);
    MenuUtil_ReplaceNewMsgMenus(m_hMenu);

    if (m_dwNoteCreateFlags & OENCF_MODAL)
    {
        // Check to make sure nobody has captured the mouse from us
        hwndCapture = GetCapture();
        if (hwndCapture)
            SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

        // Let's make sure we have a real topmost owner
        if (m_hwndOwner)
        {
            HWND hwndParent = GetParent(m_hwndOwner);

            // IsChild checks the WM_CHILD bit in the window. This will only be
            // set with controls or subs of a window. So, a dialog's parent might be
            // a note, but that dialog will not be a child of the parent.
            // RAID 37188
            while(IsChild(hwndParent, m_hwndOwner))
            {
                m_hwndOwner = hwndParent;
                hwndParent = GetParent(m_hwndOwner);
            }

            // Lose the minimize box for modal notes if there is a parent
            dwStyle &= ~WS_MINIMIZEBOX;
        
        }
    }
    
    hwnd = CreateWindowExWrapW( dwExStyle,
                                c_wszNoteWndClass,
                                NULL, //caption set by en_change of subject
                                dwStyle,
                                prc?rcCreate.left:CW_USEDEFAULT,  // use windows default for x and y.
                                prc?rcCreate.top:CW_USEDEFAULT,
                                cxRect(rcCreate), cyRect(rcCreate), m_hwndOwner, NULL, g_hInst, (LPVOID)this);

    IF_NULLEXIT(hwnd);

    if ((m_dwNoteCreateFlags & OENCF_MODAL) && (NULL != m_hwndOwner))
        EnableWindow(m_hwndOwner, FALSE);

    if ( GetOption(OPT_MAILNOTEPOSEX, (LPVOID)&wp, sizeof(wp)) )
    {
        wp.length = sizeof(wp);
        wp.showCmd = SW_HIDE;
        SetWindowPlacement(hwnd, &wp);   
    }
    else
    {
        CenterDialog(hwnd);
    }

exit:
    SetCursor(hcur);

    return hr;
}

// *************************
HRESULT CNote::Init(DWORD dwAction, DWORD dwCreateFlags, RECT *prc, HWND hwnd, INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite, IUnknown *punkPump)
{
    HRESULT         hr,
                    tempHr = S_OK;
    IMimeMessage   *pMsg = NULL;
    DWORD           dwFormatFlags,
                    dwStatusFlags = 0,
                    dwMsgFlags = (OENA_FORWARDBYATTACH == dwAction) ? (OEGM_ORIGINAL|OEGM_AS_ATTACH) : NOFLAGS;
    LPSTR           pszUnsent = NULL;
    BOOL            fBool = FALSE,
                    fOffline=FALSE;
    
    Assert((pInitStruct && !pMsgSite)|| (!pInitStruct && pMsgSite));

    ReplaceInterface(m_punkPump, punkPump);

    // If passed in an INIT_MSGSITE_STRUCT, must convert it to a pMsgSite
    if (pInitStruct)
    {
        m_pMsgSite = new COEMsgSite();
        if (!m_pMsgSite)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        Assert(pInitStruct);
        hr = m_pMsgSite->Init(pInitStruct);
        if (FAILED(hr))
            goto exit;    
    }
    else
        ReplaceInterface(m_pMsgSite, pMsgSite);

    if(m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

    AssertSz(m_pMsgSite, "Why don't we have a msgSite???");

    m_dwNoteAction = dwAction;
    m_fReadNote = !!(OENA_READ == m_dwNoteAction);
    m_fOriginallyWasRead = m_fReadNote;
    m_dwNoteCreateFlags = dwCreateFlags;

    // The storeCallback needs to be set. m_hwnd will be reset once we have a valid handle
    m_hwnd = hwnd;
    m_pMsgSite->SetStoreCallback(this);

    hr = m_pMsgSite->GetMessage(&pMsg, &fBool, dwMsgFlags, &tempHr);
    if (FAILED(hr))
        goto exit;

    // Raid 80277; Set default charset
    if(OENA_FORWARDBYATTACH == dwAction)
    {
        if (NULL == g_hDefaultCharsetForMail) 
            ReadSendMailDefaultCharset();

        pMsg->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
    }

    m_fCompleteMsg = !!fBool;   // m_f* is a bitfield
    fOffline = (hr == HR_S_OFFLINE);

    switch (m_dwNoteAction)
    {
        case OENA_REPLYTOAUTHOR:
        case OENA_FORWARDBYATTACH:
        case OENA_FORWARD:
            m_fMail = TRUE;
            break;

        case OENA_REPLYTONEWSGROUP:
            m_fMail = FALSE;

        case OENA_STATIONERY:
        case OENA_WEBPAGE:
        case OENA_COMPOSE:
            m_fMail = (0 == (m_dwNoteCreateFlags & OENCF_NEWSFIRST));
            break;

        case OENA_REPLYALL:
        case OENA_READ:
        {
            DWORD dwStatusFlags = 0;
            hr = m_pMsgSite->GetStatusFlags(&dwStatusFlags);
            if (FAILED(hr))
                goto exit;

            m_fMail = (0 == (OEMSF_BASEISNEWS & dwStatusFlags));
            break;
        }
    }

    ProcessIncompleteAccts(hwnd);

    hr = ProcessICW(hwnd, m_fMail ? FOLDER_LOCAL : FOLDER_NEWS);
    if (FAILED(hr))
        goto exit;

    // If this is an unsent message and is a read note, then change the type to compose. This needs
    // to happen after setting the m_fMail flag since we mangle the noteAction.
    ChangeReadToComposeIfUnsent(pMsg);

    if (m_fMail)
    {
        m_fPackageImages = !!DwGetOption(OPT_MAIL_SENDINLINEIMAGES);
        dwFormatFlags = FMT_MAIL;
    }
    else
    {
        PROPVARIANT     var;
        IImnAccount    *pAcct = NULL;
        TCHAR           szAcctID[CCHMAX_ACCOUNT_NAME];
        DWORD           dw;

        m_fPackageImages = !!DwGetOption(OPT_NEWS_SENDINLINEIMAGES);

        *szAcctID = 0;

        dwFormatFlags = FMT_NEWS;
        // Bug #24267 - Check the message object for a server name before defaulting
        //              to the default server.
        var.vt = VT_LPSTR;
        if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
        {
            lstrcpy(szAcctID, var.pszVal);
            SafeMemFree(var.pszVal);
        }

        if (*szAcctID)
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctID, &pAcct);

        // No account present, or the listed one no longer exists try to get the default
        if (!*szAcctID || (*szAcctID && FAILED(hr)))
            hr = m_pMsgSite->GetDefaultAccount(ACCT_NEWS, &pAcct);

        if ((OENA_WEBPAGE == dwAction) || (OENA_STATIONERY == dwAction))
            dwFormatFlags |= FMT_FORCE_HTML;
        else if (SUCCEEDED(hr) && pAcct && SUCCEEDED(pAcct->GetPropDw(AP_NNTP_POST_FORMAT, &dw)))
        {
            if (dw == POST_USE_HTML)
                dwFormatFlags |= FMT_FORCE_HTML;
            else if (dw == POST_USE_PLAIN_TEXT)
                dwFormatFlags |= FMT_FORCE_PLAIN;
            else
                Assert(dw == POST_USE_DEFAULT);
        }
        ReleaseObj(pAcct);
    }

    GetDefaultOptInfo(&m_rHtmlOpt, &m_rPlainOpt, &fBool, dwFormatFlags);

    switch (m_dwNoteAction)
    {
        case OENA_FORWARDBYATTACH:
            m_fHtml = !!fBool;
            break;

        case OENA_COMPOSE:
            if (m_fOriginallyWasRead)
            {
                DWORD dwFlags = 0;
                pMsg->GetFlags(&dwFlags);
                m_fHtml = !!(dwFlags & IMF_HTML);
            }
            else
                m_fHtml = !!fBool;
            break;

        case OENA_STATIONERY:
        case OENA_WEBPAGE:
        case OENA_READ:
            m_fHtml = TRUE;       // HTML is always cool in a readnote
            break;

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
            // when replying, if option to repect sender format is on, do so
            if (DwGetOption(OPT_REPLYINORIGFMT))
            {
                DWORD dwFlags = 0;
                pMsg->GetFlags(&dwFlags);
                m_fHtml = !!(dwFlags & IMF_HTML);
            }
            else
                m_fHtml = !!fBool;

            // Bug 76570, 76575
            // Set security label
            if(pMsg)
            {
                SECSTATE        SecState;
                HrGetSecurityState(pMsg, &SecState, NULL);
                // only in case of signing message check label
                if(IsSigned(SecState.type))
                {
                    PCRYPT_ATTRIBUTE    pattrLabel;
                    LPBYTE              pbLabel = NULL;
                    DWORD               cbLabel;
                    PSMIME_SECURITY_LABEL plabel = NULL;
        
                    IMimeSecurity2 * pSMIME3 = NULL;
                    IMimeBody      *pBody = NULL;

                    if(pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody) == S_OK)
                    {
                        if(pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pSMIME3) == S_OK)
                        {
            
                            // Get label attribute
                            if(pSMIME3->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED,
                                        0, szOID_SMIME_Security_Label,
                                        &pattrLabel) == S_OK)
                            {
                                // decode label
                                if(CryptDecodeObjectEx(X509_ASN_ENCODING,
                                            szOID_SMIME_Security_Label,
                                            pattrLabel->rgValue[0].pbData,
                                            pattrLabel->rgValue[0].cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            &CryptDecodeAlloc, &plabel, &cbLabel))
                                {
                                    if(plabel)
                                    {
                                        m_fSecurityLabel = TRUE;
                                        SafeMemFree(m_pLabel);
                                        m_pLabel = plabel;
                                    }
                                }
                            }
                            else 
                            {   // Secure receipt is binary message and pMsg->GetFlags always will retutn non-HTML, but we 
                                // forward (or Replay) with our HTML screen and need to set this to HTML.
                                if(CheckSecReceipt(pMsg) == S_OK)
                                    m_fHtml = TRUE;
                            }

                            SafeRelease(pSMIME3);
                        }   
                        ReleaseObj(pBody);
                    }

                }
                CleanupSECSTATE(&SecState);
            }
            break;
    }

    hr = InitWindows(prc, (dwCreateFlags & OENCF_MODAL) ? hwnd : 0);
    if (FAILED(hr))
        goto exit;

    hr = Load(pMsg);
    if (FAILED(hr))
        goto exit;

    if (FAILED(tempHr))
        ShowErrorScreen(tempHr);

    m_fFullHeaders = (S_OK == m_pHdr->FullHeadersShowing());

    if (fOffline)
        ShowErrorScreen(HR_E_OFFLINE);

    hr = InitMenusAndToolbars();        

    // Register with identity manager
    SideAssert(SUCCEEDED(hr = MU_RegisterIdentityNotifier((IUnknown *)(IOENote *)this, &m_dwIdentCookie)));

exit:
    ReleaseObj(pMsg);
    if (FAILED(hr) && m_pMsgSite && !pMsgSite)
        m_pMsgSite->Close();    
    
    return hr;
}

// Will return after close if is modal, otherwise returns immediately
HRESULT CNote::Show(void)
{    
    ShowWindow(m_hwnd, SW_SHOW);
    SetForegroundWindow(m_hwnd);

    if (m_dwNoteCreateFlags & OENCF_MODAL)
    {
        MSG         msg;
        HWNDLIST    hwndList;

        EnableThreadWindows(&hwndList, FALSE, 0, m_hwnd);

        while (GetMessageWrapW(&msg, NULL, 0, 0))
        {
            // This is a member function, so don't need to wrap
            if (TranslateAccelerator(&msg) == S_OK)
                continue;


            ::TranslateMessage(&msg);
            ::DispatchMessageWrapW(&msg);
        }

        EnableThreadWindows(&hwndList, TRUE, 0, m_hwnd);
    }
    return S_OK;
}

// *************************
BOOL CNote::WMCreate(HWND hwnd)
{
    LPTBBUTTON          lpButtons;
    ULONG               cBtns;
    HWND                hwndRebar;
    CMimeEditDocHost   *pNoteBody;
    DWORD               dwStyle;
    RECT                rc;
    VARIANTARG          var;
    IUnknown           *pUnk = NULL;
    REBARBANDINFO       rbbi;

    m_hwnd = hwnd;
    SetWndThisPtr(hwnd, this);
    AddRef();

    Assert(IsWindow(m_hwnd));

    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    //Create a new bandsclass and intialize it
    m_pToolbarObj = new CBands();
    if (!m_pToolbarObj)
        return FALSE;

    m_pToolbarObj->HrInit(0, m_hMenu, PARENT_TYPE_NOTE);
    m_pToolbarObj->SetSite((IOENote*)this);
    m_pToolbarObj->ShowDW(TRUE);
    m_pToolbarObj->SetFolderType(GetNoteType());
    m_fToolbarVisible = m_pToolbarObj->IsToolbarVisible();

    m_hwndToolbar = m_pToolbarObj->GetToolbarWnd();
    m_hwndRebar = m_pToolbarObj->GetRebarWnd();

    pNoteBody = new CMimeEditDocHost(MEBF_INNERCLIENTEDGE);
    if (!pNoteBody)
        return FALSE;

    pNoteBody->QueryInterface(IID_IBodyObj2, (LPVOID *)&m_pBodyObj2);
    pNoteBody->Release();
    if (!m_pBodyObj2)
        return FALSE;

    m_pBodyObj2->QueryInterface(IID_IPersistMime, (LPVOID*)&m_pPrstMime);
    if (!m_pPrstMime)
        return FALSE;

    m_pstatus = new CStatusBar();
    if (NULL == m_pstatus)
        return FALSE;

    m_pstatus->Initialize(m_hwnd, SBI_HIDE_SPOOLER | SBI_HIDE_CONNECTED | SBI_HIDE_FILTERED);
    m_pstatus->ShowStatus(m_fStatusbarVisible);

    m_pBodyObj2->HrSetStatusBar(m_pstatus);

    CreateInstance_Envelope(NULL, (IUnknown**)&pUnk);
    if (!pUnk)
        return FALSE;

    pUnk->QueryInterface(IID_IHeader, (LPVOID*)&m_pHdr);
    pUnk->Release();
    if (!m_pHdr)
        return FALSE;

    m_pHdr->QueryInterface(IID_IDropTarget, (LPVOID*)&m_pDropTargetHdr);
    if (!m_pDropTargetHdr)
        return FALSE;

    m_pHdr->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_pCmdTargetHdr);
    if (!m_pCmdTargetHdr)
        return FALSE;

    if (!m_fMail)
        HeaderExecCommand(MSOEENVCMDID_NEWS, MSOCMDEXECOPT_DODEFAULT, NULL);

    var.vt = VT_I4;
    var.lVal = m_dwNoteAction;

    HeaderExecCommand(MSOEENVCMDID_SETACTION, MSOCMDEXECOPT_DODEFAULT, &var);
    if (FAILED(m_pHdr->Init((IHeaderSite*)this, hwnd)))
        return FALSE;

    if (FAILED(InitBodyObj()))
        return FALSE;

    // Set focus in the To: line
    switch (m_dwNoteAction)
    {
        case OENA_COMPOSE:
        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
            m_pHdr->SetInitFocus(FALSE);
            break;
    }

    m_pBodyObj2->SetEventSink((IMimeEditEventSink *) this);

    SetForegroundWindow(m_hwnd);
    return TRUE;
}

// *************************
void CNote::InitSendAndBccBtns()
{
    DWORD idiIcon;
    HICON hIconTemp = 0;

    Assert(m_hwnd);
    if (m_fMail)
        idiIcon = m_fReadNote?idiMsgPropSent:idiMsgPropUnSent;
    else
        idiIcon = m_fReadNote?idiArtPropPost:idiArtPropUnpost;

    // don't have to free HICON loaded from LoadIcon
    SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM)LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiIcon)));

    if (m_fMail)
        idiIcon = m_fReadNote?idiSmallMsgPropSent:idiSmallMsgPropUnSent;
    else
        idiIcon = m_fReadNote?idiSmallArtPropPost:idiSmallArtPropUnpost;

    if(m_hIcon)
    {
        hIconTemp = m_hIcon;
    }
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiIcon), IMAGE_ICON, 
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);

    // don't have to free HICON loaded from LoadIcon
    SendMessage(m_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIcon);

    if(hIconTemp)
    {
        //Bug #101345 - (erici) ICON leaked when 'Previous' or 'Next' button clicked
        DestroyIcon(hIconTemp);
    }

    // If this is a news send note, then we spruce up the send button on the toolbar
    if ((FALSE == m_fReadNote) && (FALSE == m_fMail))
    {
        TBBUTTONINFO tbi;

        ZeroMemory(&tbi, sizeof(TBBUTTONINFO));
        tbi.cbSize = sizeof(TBBUTTONINFO);
        tbi.dwMask = TBIF_IMAGE;
        tbi.iImage = TBIMAGE_SEND_NEWS;
        SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, ID_SEND_DEFAULT, (LPARAM) &tbi);
    }
}

// *************************
HRESULT CNote::HeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn)
{
    HRESULT hr = S_FALSE;

    if (uCmdID && m_pCmdTargetHdr)
        hr = m_pCmdTargetHdr->Exec(&CGID_Envelope, uCmdID, nCmdExecOpt, pvaIn, NULL);

    return hr;
}

// *************************
HRESULT CNote::InitBodyObj()
{
    DWORD       dwBodyStyle = MESTYLE_NOHEADER;
    HRESULT     hr;
    int         idsErr=0;

    hr = m_pBodyObj2->HrInit(m_hwnd, IBOF_TABLINKS, (IBodyOptions *)this);
    if (FAILED(hr))
        goto fail;

    hr = m_pBodyObj2->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_pCmdTargetBody);
    if (FAILED(hr))
        goto fail;

    hr = m_pBodyObj2->HrShow(TRUE);
    if (FAILED(hr))
        goto fail;

    // if not in html mode, don't show format bar...
    // we do this test here, as HrLoad could determine that a previously saved message
    // is indeed in html, which overrides the default setting
    if(!m_fHtml)
        m_fFormatbarVisible = FALSE;

    if (!m_fReadNote && !m_fBodyContainsFrames && m_fFormatbarVisible)
        dwBodyStyle = MESTYLE_FORMATBAR;

    m_pBodyObj2->HrEnableHTMLMode(m_fHtml);
    m_pBodyObj2->HrSetStyle(dwBodyStyle);

    // all is groovey
    return hr;

fail:
    switch (hr)
    {
        case INET_E_UNKNOWN_PROTOCOL:
            idsErr = idsErrLoadProtocolBad;
            break;

        default:
            idsErr = idsErrNoteDeferedInit;
            break;
    }

    AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErr), NULL, MB_OK);
    return hr;
}

// *************************
HRESULT CNote::InitMenusAndToolbars()
{
    DWORD       dwStatusFlags;
    HRESULT     hr;
    BOOL        fComposeNote,
                fCompleteMsg = !!m_fCompleteMsg, // m_fCompleteMsg is a bit field.
                fNextPrevious;
    HMENU       hMenu = m_hMenu;

    m_fUseReplyHeaders = FALSE;

    Assert(m_pMsgSite);
    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

    switch (m_dwNoteAction)
    {
        case OENA_FORWARDBYATTACH:
        case OENA_COMPOSE:
            // if it's a virgin compose-note, we check the regsettings to see if they want to compose
            // from a stationery file. If so, we set the html stream to that file.
            if (m_fHtml && !(m_dwNoteCreateFlags & OENCF_NOSTATIONERY) && (OEMSF_VIRGIN & dwStatusFlags))
                SetComposeStationery();
            break;

        case OENA_STATIONERY:
            if (m_dwNoteCreateFlags & OENCF_USESTATIONERYFONT)
                m_fUseStationeryFonts = TRUE;
            break;

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
            m_fUseReplyHeaders = TRUE;
            break;
    }

    InitSendAndBccBtns();
    
    if (m_fMail)
    {
        if (m_fReadNote || IsReplyNote())
            m_pBodyObj2->HrUIActivate(TRUE);
    }
    else
    {
        if ((OENA_COMPOSE == m_dwNoteAction) && (OEMSF_VIRGIN & dwStatusFlags))
            // for a sendnote in news, put focus in the subject as the to: line is filled in. bug #24720
            m_pHdr->SetInitFocus(TRUE);
        else
            // else , always put focus in the BODY
            m_pBodyObj2->HrUIActivate(TRUE);
    }

    RECT rc;
    GetClientRect(m_hwnd, &rc);
    SendMessage(m_hwnd, WM_SIZE, SIZE_RESTORED, MAKELPARAM(rc.right, rc.bottom));        

    // put us into edit mode if not a readnote...
    hr=m_pBodyObj2->HrSetEditMode(!m_fReadNote && !m_fBodyContainsFrames);
    if (FAILED(hr))
        goto error;

    if (m_fBodyContainsFrames)
        DisableSendNoteOnlyMenus();

    // get the character set of the message being loaded
    if (m_pMsg)
        m_pMsg->GetCharset(&m_hCharset);

error:
    return hr;
}

// *************************
void CNote::DisableSendNoteOnlyMenus()
{
}

// *************************
HACCEL CNote::GetAcceleratorTable()
{
    return (m_fReadNote ? g_hAccelRead : g_hAccelSend);
}

// *************************
HRESULT CNote::TranslateAccelerator(LPMSG lpmsg)
{
    HWND        hwndT,
                hwndFocus;

    if (IsMenuMessage(lpmsg) == S_OK)
       return S_OK;

    // handle the mousewheel messages for this note
    if ((g_msgMSWheel && (lpmsg->message == g_msgMSWheel)) || (lpmsg->message == WM_MOUSEWHEEL))
    {
        POINT pt;
        HWND  hwndT;

        pt.x = GET_X_LPARAM(lpmsg->lParam);
        pt.y = GET_Y_LPARAM(lpmsg->lParam);

        hwndT = WindowFromPoint(pt);
        hwndFocus = GetFocus();

        if (hwndT != m_hwnd && IsChild(m_hwnd, hwndT))
            SendMessage(hwndT, lpmsg->message, lpmsg->wParam, lpmsg->lParam);
        else if (hwndFocus != m_hwnd && IsChild(m_hwnd, hwndFocus))
            SendMessage(hwndFocus, lpmsg->message, lpmsg->wParam, lpmsg->wParam);
        else
            return S_FALSE;
        return S_OK;
    }

    // our accelerators have higher priority.
    if(::TranslateAcceleratorWrapW(m_hwnd, GetAcceleratorTable(), lpmsg))
        return S_OK;

    // see if the body want it for the docobject...
    if(m_pBodyObj2 &&
        m_pBodyObj2->HrTranslateAccelerator(lpmsg)==S_OK)
        return S_OK;

    if (lpmsg->message == WM_KEYDOWN &&
        lpmsg->wParam == VK_TAB && 
        !(GetKeyState(VK_CONTROL) & 0x8000 ))
    {
        BOOL  fGoForward = ( GetKeyState( VK_SHIFT ) & 0x8000 ) == 0;
        CycleThroughControls(fGoForward);

        return S_OK;
    }

    return S_FALSE;
}

// *************************
LRESULT CNote::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lResult;
    LRESULT         lres;
    MSG             Menumsg;
    HWND            hwndActive;
    WINDOWPLACEMENT wp;

    Menumsg.hwnd    = hwnd;
    Menumsg.message = msg;
    Menumsg.wParam  = wParam;
    Menumsg.lParam  = lParam;

    if (m_pToolbarObj && (m_pToolbarObj->TranslateMenuMessage(&Menumsg, &lres) == S_OK))
        return lres;

    wParam = Menumsg.wParam;
    lParam = Menumsg.lParam;


    switch(msg)
    {
        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, !!wParam, ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_OE_DESTROYNOTE:
            m_fForceClose = 1;
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_OENOTE_ON_COMPLETE:
            _OnComplete((STOREOPERATIONTYPE)lParam, (HRESULT) wParam);
            break;
            
        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case NWM_GETDROPTARGET:
            SafeRelease(m_pTridentDropTarget);
            m_pTridentDropTarget = (IDropTarget*) wParam;
            if (m_pTridentDropTarget)
                m_pTridentDropTarget->AddRef();

            AddRef();
            return (LRESULT)(IDropTarget *) this;

        case WM_DESTROY:
            // Unregister with Identity manager
            if (m_dwIdentCookie != 0)
            {
                MU_UnregisterIdentityNotifier(m_dwIdentCookie);
                m_dwIdentCookie = 0;
            }

            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetOption(OPT_MAILNOTEPOSEX, (LPVOID)&wp, sizeof(wp), NULL, 0);

            RemoveProp(hwnd, c_szOETopLevel);

            DeinitSigPopupMenu(hwnd);

            if(m_pBodyObj2)
            {
                m_pBodyObj2->HrSetStatusBar(NULL);
                m_pBodyObj2->HrClose();
            }

            SafeRelease(m_pTridentDropTarget);

            if (m_pToolbarObj)
            {
                DWORD   dwReserved = 0;

                m_pToolbarObj->SetSite(NULL);
                m_pToolbarObj->CloseDW(dwReserved);
            }

            if (m_pCancel)
                m_pCancel->Cancel(CT_ABORT);

            if (m_pMsgSite)
                m_pMsgSite->Close();

            break;

        case WM_NCDESTROY:
            DOUTL(8, "CNote::WMNCDESTROY");
            WMNCDestroy();
            return 0;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }
            break;
        
        case WM_SYSCOMMAND:
            // if we're minimizing, get the control with focus, as when we get the 
            // next WM_ACTIVATE we will already be minimized
            if (wParam == SC_MINIMIZE)
                m_hwndFocus = GetFocus();
            break;

        case WM_ACTIVATE:
            if (m_pBodyObj2)
                m_pBodyObj2->HrFrameActivate(LOWORD(wParam) != WA_INACTIVE);
            break;

        case WM_ENDSESSION:
            DOUTL(2, "CNote::WM_ENDSESSION");
            if (wParam)
                DestroyWindow(hwnd);
            return 0;

        case WM_QUERYENDSESSION:
            DOUTL(2, "CNote::WM_QUERYENDSESSION");
            // fall thro'

        case WM_CLOSE:
            if (!m_fForceClose && !FCanClose())
                return 0;

            // listen-up:
            // we have to do this EnableWindowof the modal owner in the WM_CLOSE
            // handler, as WM_DESTROY is too late - USER may have SetFocus to the next
            // active toplevel z-order window (as the note has been hidden by then) - if the
            // window is in another process SetFocus back to the owner will be ignored.
            // Also, in the places we call DestroyWindow we need to make sure we go thro' this
            // WM_CLOSE handler. So all calls to DestroyWindow instead call WM_OE_DESTROYNOTE
            // which sets an internal flag to force down the note (so we don't prompt if dirty)
            // and then calls WM_CLOSE, which falls thro' to DefWndProc and results in a DestroyWindow
            // got it?
            if (m_dwNoteCreateFlags & OENCF_MODAL)
            {
                // Need to enable the owner window
                if (NULL != m_hwndOwner)   
                {
                    EnableWindow(m_hwndOwner, TRUE);
                }
            }
           
            break;

        case WM_MEASUREITEM:
            if(m_pBodyObj2 &&
                m_pBodyObj2->HrWMMeasureMenuItem(hwnd, (LPMEASUREITEMSTRUCT)lParam)==S_OK)
                return 0;
            break;

        case WM_DRAWITEM:
            if(m_pBodyObj2 &&
                m_pBodyObj2->HrWMDrawMenuItem(hwnd, (LPDRAWITEMSTRUCT)lParam)==S_OK)
                return 0;
            break;


        case WM_DROPFILES:
            if (m_pHdr)
                m_pHdr->DropFiles((HDROP)wParam, FALSE);
            return 0;

        case WM_COMMAND:
            WMCommand(  GET_WM_COMMAND_HWND(wParam, lParam),
                        GET_WM_COMMAND_ID(wParam, lParam),
                        GET_WM_COMMAND_CMD(wParam, lParam));
            return 0;

        case WM_INITMENUPOPUP:
            return WMInitMenuPopup(hwnd, (HMENU)wParam, (UINT)LOWORD(lParam));

        case WM_GETMINMAXINFO:
            WMGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_MENUSELECT:
            if (LOWORD(wParam)>=ID_STATIONERY_RECENT_0 && LOWORD(wParam)<=ID_STATIONERY_RECENT_9)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_APPLY_STATIONERY_0 && LOWORD(wParam)<=ID_APPLY_STATIONERY_9)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsApplyStationeryGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_SIGNATURE_FIRST && LOWORD(wParam)<=ID_SIGNATURE_LAST)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsInsertSigGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_FORMAT_FIRST && LOWORD(wParam)<=ID_FORMAT_LAST)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsApplyFormatGeneralHelp));
                return 0;
            }

            HandleMenuSelect(m_pstatus, wParam, lParam);
            return 0;

        case NWM_TESTGETDISP:
        case NWM_TESTGETADDR:
            return lTestHook(msg, wParam, lParam);

        case NWM_UPDATETOOLBAR:
            m_pToolbarObj->Update();
            return 0;

        case NWM_PASTETOATTACHMENT:
            if (m_pHdr)
                m_pHdr->DropFiles((HDROP)wParam, (BOOL)lParam);

            return 0;

        case WM_CONTEXTMENU:
            break;

        case WM_SIZE:
            if(wParam==SIZE_RESTORED)   // update global last-size
                GetWindowRect(hwnd, &g_rcLastResize);

            WMSize(LOWORD(lParam), HIWORD(lParam), FALSE);
            break;

        case WM_NOTIFY:
            WMNotify((int) wParam, (NMHDR *)lParam);
            break;

        case WM_SETCURSOR:
            if (!!m_fWindowDisabled)
            {
                HourGlass();
                return TRUE;
            }
            break;

        case WM_DISPLAYCHANGE:
            {
                WINDOWPLACEMENT wp;

                wp.length = sizeof(wp);
                GetWindowPlacement(hwnd, &wp);
                SetWindowPlacement(hwnd, &wp);
            }
            // Drop through
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            {
                HWND hwndT;

                // pass down to trident
                if (m_pBodyObj2 && 
                    m_pBodyObj2->HrGetWindow(&hwndT)==S_OK)
                    SendMessage(hwndT, msg, wParam, lParam);

                if (m_pToolbarObj &&
                    m_pToolbarObj->GetWindow(&hwndT)==S_OK)
                    SendMessage(hwndT, msg, wParam, lParam);
            }
            break;

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
            {
                HWND hwndFocus = GetFocus();
                if (hwndFocus != hwnd)
                    return SendMessage(hwndFocus, msg, wParam, lParam);
            }
            break;
    }

    lResult=DefWindowProcWrapW(hwnd, msg, wParam, lParam);
    if (msg==WM_ACTIVATE)
    {
        // need to post-process this

        // save the control with the focus don't do this is we're
        // minimized, otherwise GetFocus()==m_hwnd
        if (!HIWORD(wParam))
        {
            // if not minimized, save/restore child focus
            
            if ((LOWORD(wParam) == WA_INACTIVE))
            {
                // if deactivating then save the focus
                m_hwndFocus = GetFocus();
                DOUTL(4, "Focus was on 0x%x", m_hwndFocus);
            }    
            else
            {
                // if activating, and not minimized then restore focus
                if (IsWindow(m_hwndFocus) && 
                    IsChild(hwnd, m_hwndFocus))
                {
                    DOUTL(4, "Restoring Focus to: 0x%x", m_hwndFocus);
                    SetFocus(m_hwndFocus);
                }        
            }
        }
        
        if (!(m_dwNoteCreateFlags & OENCF_MODAL))
            SetTlsGlobalActiveNote((LOWORD(wParam)==WA_INACTIVE)?NULL:this);
        DOUTL(8, "CNote::WMActivate:: %x", GetTlsGlobalActiveNote());
    }
    return lResult;
}

// *************************
BOOL CNote::FCanClose()
{
    int id;
    HRESULT hr = S_OK;

    if(IsDirty()==S_FALSE)
        return TRUE;

    // TODO: set the title properly
    id = AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSaveChangesMsg), NULL, MB_YESNOCANCEL|MB_ICONWARNING);
    if(id==IDCANCEL)
        return FALSE;

    // Note - It's the job of the subclass to display any UI that might
    //        describe why saving failed.
    if (id == IDYES)
        hr = SaveMessage(NOFLAGS);

    if (FAILED(hr))
    {
        if (E_PENDING == hr)
            m_fCBDestroyWindow = TRUE;
        return FALSE;
    }

    return TRUE;
}

// *************************
HRESULT CNote::SaveMessage(DWORD dwSaveFlags)
{
    HRESULT         hr;
    IMimeMessage   *pMsg = NULL;
    IImnAccount    *pAcct = NULL;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto exit;

    hr = Save(pMsg, 0);
    if (SUCCEEDED(hr))
    {
        hr = m_pHdr->HrGetAccountInHeader(&pAcct);
        if (FAILED(hr))
            goto exit;

        dwSaveFlags |= OESF_UNSENT;
        if (m_fOriginallyWasRead && (OENA_COMPOSE == m_dwNoteAction))
            dwSaveFlags |= OESF_SAVE_IN_ORIG_FOLDER;

        if(IsSecure(pMsg))
        {
            if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                    MAKEINTRESOURCEW(idsSaveSecMsgToDraft), NULL, MB_OKCANCEL) == IDCANCEL)
            {
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
            else
            {
                PROPVARIANT     rVariant;
                IMimeBody      *pBody = NULL;

                rVariant.vt = VT_BOOL;
                rVariant.boolVal = TRUE;

                hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                if(SUCCEEDED(hr))
                {
                    pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                    ReleaseObj(pBody);
                }


            }
        }

        m_fHasBeenSaved = TRUE;

        _SetPendingOp(SOT_PUT_MESSAGE);

        hr = m_pMsgSite->Save(pMsg, dwSaveFlags, pAcct);
        if (SUCCEEDED(hr))
            _OnComplete(SOT_PUT_MESSAGE, S_OK);
        else
            if (hr == E_PENDING)
                EnableNote(FALSE);
    }

exit:
    ReleaseObj(pAcct);
    ReleaseObj(pMsg);
    return hr;
}

// *************************
void CNote::WMNCDestroy()
{
    if (m_dwNoteCreateFlags & OENCF_MODAL)
        PostQuitMessage(0);
    SetWndThisPtr(m_hwnd, NULL);

    m_hwnd=NULL;
    Release();
}


// *************************
void CNote::ChangeReadToComposeIfUnsent(IMimeMessage *pMsg)
{
    DWORD   dwStatusFlags = 0;
    if (m_fReadNote && SUCCEEDED(m_pMsgSite->GetStatusFlags(&dwStatusFlags)) && 
        (OEMSF_UNSENT & dwStatusFlags))
    {
        m_dwNoteAction = OENA_COMPOSE;
        m_fReadNote = FALSE;
    }
}

// *************************
void CNote::ReloadMessageFromSite(BOOL fOriginal)
{
    IMimeMessage   *pMsg = NULL;
    BOOL            fBool = FALSE,
                    fTempHtml;
    DWORD           dwBodyStyle = MESTYLE_NOHEADER,
                    dwMsgFlags;
    HRESULT         hr = S_OK,
                    tempHr;

    if (OENA_FORWARDBYATTACH == m_dwNoteAction)
        dwMsgFlags = (OEGM_ORIGINAL|OEGM_AS_ATTACH);
    else
        dwMsgFlags = (fOriginal ? OEGM_ORIGINAL : NOFLAGS);

    hr = m_pMsgSite->GetMessage(&pMsg, &fBool, dwMsgFlags, &tempHr);
    if (SUCCEEDED(hr))
    {
        // ~~~ Check what happens here if message is not downloaded and hit forward as attach
        DWORD dwFlags = 0;
        m_fCompleteMsg = !!fBool;

        // All notes will be read note unless unsent
        m_dwNoteAction = OENA_READ;
        m_fOriginallyWasRead = TRUE;
        m_fReadNote = TRUE;

        // Is this an unsent message and is a read note? Then should be a compose.
        ChangeReadToComposeIfUnsent(pMsg);

        // This needs to be called for the case where we load an IMAP message. In this
        // case we don't know if it is html or not. We won't know until after it is
        // downloaded. That is what is happening at this point. Before we do our
        // load, let's make sure that we have set m_fHtml properly. RAID 46327
        if(CheckSecReceipt(pMsg) == S_OK)
            fTempHtml = TRUE;
        else
        {
            pMsg->GetFlags(&dwFlags);
            fTempHtml = !!(dwFlags & IMF_HTML);
        }

        // If m_fHtml was already set correctly, then don't do it again.
        if (fTempHtml != m_fHtml)
        {
            m_fFormatbarVisible = m_fHtml = fTempHtml;

            if (!m_fReadNote && !m_fBodyContainsFrames && m_fFormatbarVisible)
                dwBodyStyle = MESTYLE_FORMATBAR;

            m_pBodyObj2->HrSetStyle(dwBodyStyle);
            m_pBodyObj2->HrEnableHTMLMode(m_fHtml);
        }

        Load(pMsg);
        InitMenusAndToolbars();
        
        pMsg->Release();

        if (FAILED(tempHr))
            ShowErrorScreen(tempHr);
    }
    else
    {
        if (E_FAIL == hr)
            m_fCBDestroyWindow = TRUE;
    }
}

// *************************
HRESULT CNote::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    int         iRet = 0;
    DWORD       dwFlags = 0;
    FOLDERID    folderID = FOLDERID_INVALID;

    DOUTL(4, "CNote::WMCommand");

    OLECMD          cmd;

    // We can hit this via accelerators.  Since accelerators don't go through 
    // QueryStatus(), we need to make sure this should really be enabled.
    cmd.cmdID = id;
    cmd.cmdf = 0;
    if (FAILED(QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL)) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (S_OK);
    
    // see if any of these are for the body control, if so we're done...
    if(m_pBodyObj2 && SUCCEEDED(m_pBodyObj2->HrWMCommand(hwndCmd, id, wCmd)))
        return S_OK;

    // give the header a shot after the note is done
    if (m_pHdr &&
        m_pHdr->WMCommand(hwndCmd, id, wCmd)==S_OK)
        return S_OK;

    // Don't handle anything that isn't a menu item or accelerator
    if (wCmd <= 1)
    {
        if ((id == ID_SEND_NOW)   || (id >= ID_SEND_NOW_ACCOUNT_FIRST && id <= ID_SEND_NOW_ACCOUNT_LAST) ||
            (id == ID_SEND_LATER) || (id >= ID_SEND_LATER_ACCOUNT_FIRST && id <= ID_SEND_LATER_ACCOUNT_LAST))
        {
            HrSendMail(id);
            return S_OK;
        }

        if (id >= ID_LANG_FIRST && id <= ID_LANG_LAST)
        {
            SwitchLanguage(id);
            return S_OK;
        }

        if (id>=ID_ADD_RECIPIENT_FIRST && id<=ID_ADD_RECIPIENT_LAST)
        {
            if (m_pHdr)
                m_pHdr->AddRecipient(id - ID_ADD_RECIPIENT_FIRST);
            return S_OK;
        }

        if (id > ID_MSWEB_BASE && id < ID_MSWEB_LAST)
        {
            OnHelpGoto(m_hwnd, id);
            return S_OK;
        }

        // Handle all "create new note" IDs
        Assert(m_pMsgSite);
        if (m_pMsgSite)
        {
            m_pMsgSite->GetFolderID(&folderID);
            if (MenuUtil_HandleNewMessageIDs(id, m_hwnd, folderID, m_fMail, (m_dwNoteCreateFlags & OENCF_MODAL)?TRUE:FALSE, m_punkPump))
                return S_OK;
        }

        // ONLY processing menu accelerators
        switch(id)
        {
            case ID_SEND_DEFAULT:
                HrSendMail(DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline() ? ID_SEND_NOW : ID_SEND_LATER);
                return S_OK;

            case ID_ABOUT:
                DoAboutAthena(m_hwnd, idiMail);
                return S_OK;

            case ID_SAVE:
                SaveMessage(NOFLAGS);
                return S_OK;

            case ID_NOTE_DELETE:
            {
                HRESULT hr;

                m_fOrgCmdWasDelete = TRUE;

                _SetPendingOp(SOT_DELETING_MESSAGES);

                hr = m_pMsgSite->Delete(NOFLAGS);
                if (SUCCEEDED(hr))
                    _OnComplete(SOT_DELETING_MESSAGES, S_OK);
                else 
                {
                    if (hr == E_PENDING)
                        EnableNote(FALSE);
                    else
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);
                }
                return S_OK;
            }

            case ID_NOTE_COPY_TO_FOLDER:
            case ID_NOTE_MOVE_TO_FOLDER:
            {
                HRESULT         hr;
                IMimeMessage   *pMsg = NULL;
                DWORD           dwStatusFlags = 0;

                m_fCBCopy = (ID_NOTE_COPY_TO_FOLDER == id);

                m_pMsgSite->GetStatusFlags(&dwStatusFlags);
                if (S_OK == IsDirty() || ((OEMSF_FROM_MSG | OEMSF_VIRGIN) & dwStatusFlags))
                {
                    CommitChangesInNote();
                    pMsg = m_pMsg;
                }

                if(IsSecure(m_pMsg) && !m_fReadNote)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsSaveSecMsgToFolder), NULL, MB_OKCANCEL) == IDCANCEL)
                        return S_OK;
                    else
                    {
                        PROPVARIANT     rVariant;
                        IMimeBody      *pBody = NULL;

                        rVariant.vt = VT_BOOL;
                        rVariant.boolVal = TRUE;

                        hr = m_pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                        if(SUCCEEDED(hr))
                        {
                            pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                            ReleaseObj(pBody);
                        }
                    }
                }

                _SetPendingOp(SOT_COPYMOVE_MESSAGE);
                hr = m_pMsgSite->DoCopyMoveToFolder(m_fCBCopy, pMsg, !m_fReadNote);
                if (SUCCEEDED(hr))
                    _OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
                else if (E_PENDING == hr)
                    EnableNote(FALSE);

                return S_OK;
            }

            case ID_NEXT_UNREAD_MESSAGE:
            case ID_NEXT_UNREAD_THREAD:
            case ID_NEXT_UNREAD_ARTICLE:
                dwFlags = OENF_UNREAD;
                if (ID_NEXT_UNREAD_THREAD == id)
                    dwFlags |= OENF_THREAD;
                // Fall through

            case ID_PREVIOUS:
            case ID_NEXT_MESSAGE:
            {
                HRESULT hr;
                dwFlags |= (m_fMail ? OENF_SKIPMAIL : OENF_SKIPNEWS);

                hr = m_pMsgSite->DoNextPrev((ID_PREVIOUS != id), dwFlags);
                if (SUCCEEDED(hr))
                {
                    ReloadMessageFromSite();
                    AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
                }
#ifdef DEBUG
                // All DoNextPrev does is set the new message ID. Should never need to go
                // E_PENDING to get that information
                else if (E_PENDING == hr)
                    AssertSz(FALSE, "Didn't expect to get an E_PENDING with NextPrev.");
#endif
                else
                    MessageBeep(MB_OK);
                    
                return S_OK;
            }

            case ID_MARK_THREAD_READ:
                MarkMessage(MARK_MESSAGE_READ, APPLY_CHILDREN);
                return S_OK;

            case ID_NOTE_PROPERTIES:
                DoProperties();
                return S_OK;

            case ID_REPLY:
            case ID_REPLY_GROUP:
            case ID_REPLY_ALL:
            case ID_FORWARD:
            case ID_FORWARD_AS_ATTACH:
            {
                DWORD   dwAction = 0;
                RECT    rc;
                HRESULT hr = S_OK;

                GetWindowRect(m_hwnd, &rc);
                switch (id)
                {
                    case ID_REPLY:              dwAction = OENA_REPLYTOAUTHOR; break;
                    case ID_REPLY_GROUP:        dwAction = OENA_REPLYTONEWSGROUP; break;
                    case ID_REPLY_ALL:          dwAction = OENA_REPLYALL; break;
                    case ID_FORWARD:            dwAction = OENA_FORWARD; break;
                    case ID_FORWARD_AS_ATTACH:  dwAction = OENA_FORWARDBYATTACH; break;
                    default:                    AssertSz(dwAction, "We are about to create a note with no action."); break;
                };

                AssertSz(m_pMsgSite, "We are about to create a note with a null m_pMsgSite.");
                hr = CreateAndShowNote(dwAction, m_dwNoteCreateFlags, NULL, m_hwnd, m_punkPump, &rc, m_pMsgSite);
                if (SUCCEEDED(hr))
                {
                    // Since the new note has this site now, I don't need to keep track of it.
                    // More importantly, if I do, I break the new note since I will try to
                    // close the msgsite on my destroy notification. If I haven't released it,
                    // I would then null out items in 
                    SafeRelease(m_pMsgSite);
                    PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
                }
                else if (m_fReadNote && (MAPI_E_USER_CANCEL != hr))
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrReplyForward), NULL, MB_OK);

                return S_OK;
            }

            case ID_HELP_CONTENTS:
                OEHtmlHelp(GetParent(m_hwnd), c_szMailHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) c_szCtxHelpDefault);
                return S_OK;

            case ID_README:
                DoReadme(m_hwnd);
                break;
        
            case ID_SEND_OBJECTS:
                m_fPackageImages = !m_fPackageImages;
                return S_OK;

            case ID_NEW_CONTACT:
    #if 0
                Assert(g_pABInit);
                if (g_pABInit)
                    g_pABInit->NewContact( m_hwnd );
    #endif
                nyi("New contact");
                return S_OK;

            case ID_NOTE_SAVE_AS:
                SaveMessageAs();
                return S_OK;

            case ID_CHECK_NAMES:
                HeaderExecCommand(MSOEENVCMDID_CHECKNAMES, MSOCMDEXECOPT_PROMPTUSER, NULL);
                return S_OK;

            case ID_SELECT_RECIPIENTS:
                HeaderExecCommand(MSOEENVCMDID_SELECTRECIPIENTS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_SELECT_NEWSGROUPS:
                HeaderExecCommand(MSOEENVCMDID_PICKNEWSGROUPS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_NEWSGROUPS:
                HeaderExecCommand(MSOEENVCMDID_PICKNEWSGROUPS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_ADDRESS_BOOK:
                HeaderExecCommand(MSOEENVCMDID_VIEWCONTACTS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    MESSAGEINFO msginfo = {0};
                    
                    return HrCreateRuleFromMessage(m_hwnd, (FALSE == m_fMail) ? CRFMF_NEWS : CRFMF_MAIL, &msginfo, m_pMsg);
                }
                break;

            case ID_BLOCK_SENDER:
                {
                    return _HrBlockSender((FALSE == m_fMail) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, m_pMsg, m_hwnd);
                }
                break;
                
            case ID_FIND_MESSAGE:
                DoFindMsg(FOLDERID_ROOT, FOLDER_ROOTNODE);
                break;

            case ID_FIND_PEOPLE:
            {
                TCHAR szWABExePath[MAX_PATH];
                if(S_OK == HrLoadPathWABEXE(szWABExePath, sizeof(szWABExePath)))
                    ShellExecute(NULL, "open", szWABExePath, "/find", "", SW_SHOWNORMAL);
                break;
            }

            case ID_OPTIONS:
                ShowOptions(m_hwnd, ATHENA_OPTIONS, 0, NULL);
                break;

            case ID_ACCOUNTS:
            {
                DoAccountListDialog(m_hwnd, m_fMail?ACCT_MAIL:ACCT_NEWS);
                break;
            }

            case ID_ADD_ALL_TO:
                HeaderExecCommand(MSOEENVCMDID_ADDALLONTO, MSOCMDEXECOPT_DODEFAULT, NULL);
                break;

            case ID_ADD_SENDER:
                if(m_fMail)
                {
                    if (m_pHdr)
                        m_pHdr->AddRecipient(-1);
                }
                else
                    HeaderExecCommand(MSOEENVCMDID_ADDSENDER, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_INSERT_CONTACT_INFO:
                HeaderExecCommand(MSOEENVCMDID_VCARD, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;


            case ID_FULL_HEADERS:
                m_fFullHeaders = !m_fFullHeaders;
                if(m_pHdr)
                    m_pHdr->ShowAdvancedHeaders(m_fFullHeaders);

                if (m_fMail)
                    SetDwOption((m_fReadNote ? OPT_MAILNOTEADVREAD : OPT_MAILNOTEADVSEND), m_fFullHeaders, NULL, 0);
                else
                    SetDwOption((m_fReadNote ? OPT_NEWSNOTEADVREAD : OPT_NEWSNOTEADVSEND), m_fFullHeaders, NULL, 0);
                return S_OK;

            case ID_CUT:
                SendMessage(GetFocus(), WM_CUT, 0, 0);
                return S_OK;

            case ID_NOTE_COPY:
            case ID_COPY:
                SendMessage(GetFocus(), WM_COPY, 0, 0);
                return S_OK;

            case ID_PASTE:
                SendMessage(GetFocus(), WM_PASTE, 0, 0);
                return S_OK;

            case ID_SHOW_TOOLBAR:
                ToggleToolbar();
                return S_OK;

            case ID_CUSTOMIZE:
                SendMessage(m_hwndToolbar, TB_CUSTOMIZE, 0, 0);
                break;

            case ID_FORMATTING_TOOLBAR:
                ToggleFormatbar();
                return S_OK;

            case ID_STATUS_BAR:
                ToggleStatusbar();
                return S_OK;

            case ID_UNDO:
                Edit_Undo(GetFocus());
                return S_OK;

            case ID_SELECT_ALL:
                Edit_SetSel(GetFocus(), 0, -1);
                return S_OK;

            case ID_CLOSE:
                SendMessage(m_hwnd, WM_CLOSE, 0, 0);
                return S_OK;

            case ID_SPELLING:
                if (FCheckSpellAvail() && (!m_fReadNote))
                {
                    HWND    hwndFocus = GetFocus();
                    HRESULT hr;

                    hr = m_pBodyObj2->HrSpellCheck(FALSE);
                    if(FAILED(hr))
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrSpellGenericSpell), NULL, MB_OK | MB_ICONSTOP);

                    SetFocus(hwndFocus);
                }
                return S_OK;

            case ID_FORMAT_SETTINGS:
                FormatSettings();
                return S_OK;

            case ID_WORK_OFFLINE:
                if (g_pConMan)
                    g_pConMan->SetGlobalOffline(!g_pConMan->IsGlobalOffline(), hwndCmd);

                if (m_pToolbarObj)
                    m_pToolbarObj->Update();

                break;

            case ID_RICH_TEXT:
            case ID_PLAIN_TEXT:
                // noops
                if(id==ID_RICH_TEXT && m_fHtml)
                    return S_OK;
                if(id==ID_PLAIN_TEXT && !m_fHtml)
                    return S_OK;

                // if going to plain, warn the user he'll loose formatting...
                if((ID_PLAIN_TEXT == id) &&
                   (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSHtmlToPlain, MAKEINTRESOURCE(idsAthena),
                                        MAKEINTRESOURCE(idsWarnHTMLToPlain), MB_OKCANCEL)))
                    return S_OK;

                m_fHtml=!!(id==ID_RICH_TEXT);
        
                m_fFormatbarVisible=!!m_fHtml;
                m_pBodyObj2->HrSetStyle(m_fHtml ? MESTYLE_FORMATBAR : MESTYLE_NOHEADER);
                m_pBodyObj2->HrEnableHTMLMode(m_fHtml);

                // if going into plain-mode blow away formatting
                if (!m_fHtml)
                    m_pBodyObj2->HrDowngradeToPlainText();

                return S_OK;

            case ID_DIGITALLY_SIGN:
                HeaderExecCommand(MSOEENVCMDID_DIGSIGN, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_ENCRYPT:
                if(m_pHdr->ForceEncryption(NULL, FALSE) == S_FALSE)
                    HeaderExecCommand(MSOEENVCMDID_ENCRYPT, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_INCLUDE_LABEL:
                m_fSecurityLabel = !m_fSecurityLabel;
                CheckAndForceEncryption();
                return S_OK;

            case ID_LABEL_SETTINGS:
                if(m_pLabel)
                {
                    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSelectLabel),
                            m_hwnd, SecurityLabelsDlgProc, (LPARAM) &m_pLabel) != IDOK)
                        return (S_FALSE);
                    CheckAndForceEncryption();
                }
                return S_OK;

            case ID_SEC_RECEIPT_REQUEST:
                m_fSecReceiptRequest = !m_fSecReceiptRequest;
                break;

            case ID_FLAG_MESSAGE:
                m_dwCBMarkType = (!IsFlagged(ARF_FLAGGED)) ? MARK_MESSAGE_FLAGGED : MARK_MESSAGE_UNFLAGGED;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_WATCH_THREAD:
                m_dwCBMarkType = (!IsFlagged(ARF_WATCH)) ? MARK_MESSAGE_WATCH : MARK_MESSAGE_NORMALTHREAD;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_IGNORE_THREAD:
                m_dwCBMarkType = (!IsFlagged(ARF_IGNORE)) ? MARK_MESSAGE_IGNORE : MARK_MESSAGE_NORMALTHREAD;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_APPLY_STATIONERY_0:
            case ID_APPLY_STATIONERY_1:
            case ID_APPLY_STATIONERY_2:
            case ID_APPLY_STATIONERY_3:
            case ID_APPLY_STATIONERY_4:
            case ID_APPLY_STATIONERY_5:
            case ID_APPLY_STATIONERY_6:
            case ID_APPLY_STATIONERY_7:
            case ID_APPLY_STATIONERY_8:
            case ID_APPLY_STATIONERY_9:
            case ID_APPLY_STATIONERY_MORE:
            case ID_APPLY_STATIONERY_NONE:
            {
                AssertSz(m_fHtml, "QueryStatus should have caught this and not let this function run.");
                HRESULT     hr;
                WCHAR       wszBuf[INTERNET_MAX_URL_LENGTH+1];
                *wszBuf = 0;
                switch (id)
                {
                    case ID_APPLY_STATIONERY_MORE:
                        hr = HrGetMoreStationeryFileName(m_hwnd, wszBuf);
                        break;

                    case ID_APPLY_STATIONERY_NONE:
                        *wszBuf=0;
                        hr = NOERROR;
                        break;

                    default:
                        hr = HrGetStationeryFileName(id - ID_APPLY_STATIONERY_0, wszBuf);
                        if (FAILED(hr))
                        {
                            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                                MAKEINTRESOURCEW(idsErrStationeryNotFound), NULL, MB_OK | MB_ICONERROR);
                        
                            HrRemoveFromStationeryMRU(wszBuf);
                        }
                        break;
                }

                if(m_pBodyObj2 && SUCCEEDED(hr))
                {
                    hr = m_pBodyObj2->HrApplyStationery(wszBuf);
                    if(SUCCEEDED(hr))
                        HrAddToStationeryMRU(wszBuf);
                }
                return S_OK;

            case IDOK:
            case IDCANCEL:
                // ignore these
                return S_OK;

            case ID_REQUEST_READRCPT:
                m_pMsgSite->Notify(OEMSN_TOGGLE_READRCPT_REQ);
                return S_OK;

            default:
                if(id>=ID_ADDROBJ_OLE_FIRST && id <=ID_ADDROBJ_OLE_LAST)
                {
                    DoNoteOleVerb(id-ID_ADDROBJ_OLE_FIRST);
                    return S_OK;
                }
            }
        }
    }

    if(wCmd==NHD_SIZECHANGE &&
        id==idcNoteHdr)
    {
        DOUTL(8, "CNote::NHD_SIZECHANGE - doing note WMSize");
        //header control is requesting a resize
        WMSize(NULL, NULL, TRUE);
        return S_OK;
    }

    return S_FALSE;
}

// *************************
BOOL CNote::IsFlagged(DWORD dwFlag)
{
    BOOL fFlagged = FALSE;
    MESSAGEFLAGS dwCurrFlags = 0;

    Assert(m_pMsgSite);
    if (m_pMsgSite)
    {
        // Readnote and compose note are the only ones that can be flagged. The others might
        // be flagged in the store, but since we are replying or forwarding, etc, they can't
        // be flagged. RAID 37729
        if ((m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)) && SUCCEEDED(m_pMsgSite->GetMessageFlags(&dwCurrFlags)))
            fFlagged = (0 != (dwFlag & dwCurrFlags));
    }

    return fFlagged;
}

// *************************
void CNote::DeferedLanguageMenu()
{
    HMENU hMenu = m_hMenu;

    Assert (hMenu);

    if (!m_hmenuLanguage)
    {    // load global MIME language codepage data
        InitMultiLanguage();
    }
    else
    {
        // Charset chaching mechanism requires us to reconstruct 
        // language menu every time
        DestroyMenu(m_hmenuLanguage);
    }
    m_hmenuLanguage = CreateMimeLanguageMenu(m_fMail, m_fReadNote, CustomGetCPFromCharset(m_hCharset, m_fReadNote));       
}

// *************************
LRESULT CNote::WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    HWND            hwndFocus=GetFocus();
    DWORD           dwFlags=0;
    BOOL            fEnableStyleMenu = FALSE;

    hmenuMain = m_hMenu;
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    if (hmenuMain == NULL ||!GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii) || mii.hSubMenu != hmenuPopup)
    {

        if (GetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            mii.wID=ID_POPUP_LANGUAGE;
            mii.fMask = MIIM_ID;
            SetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii);
        }

        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        if (GetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            DeferedLanguageMenu();
            mii.fMask = MIIM_SUBMENU;
            mii.wID=ID_POPUP_LANGUAGE;

            hmenuPopup = mii.hSubMenu = m_hmenuLanguage;
            SetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE, FALSE, &mii);
        }
        else return 1;
    }

    switch (mii.wID)
    {
        case ID_POPUP_FILE:
        case ID_POPUP_EDIT:
        case ID_POPUP_VIEW:
            break;

        case ID_POPUP_INSERT:
            InitSigPopupMenu(hmenuPopup, NULL);
            break;

        case ID_POPUP_FORMAT:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_STATIONERY, ID_APPLY_STATIONERY_0, ID_APPLY_STATIONERY_MORE);
            fEnableStyleMenu = TRUE;
            break;
        }

        case ID_POPUP_TOOLS:
            if (m_fMail)
            {
                DeleteMenu(hmenuPopup, ID_SELECT_NEWSGROUPS, MF_BYCOMMAND);
#ifdef SMIME_V3
                if (!FPresentPolicyRegInfo()) 
                {
                    DeleteMenu(hmenuPopup, ID_INCLUDE_LABEL, MF_BYCOMMAND);
                    DeleteMenu(hmenuPopup, ID_LABEL_SETTINGS, MF_BYCOMMAND);
                    m_fSecurityLabel = FALSE;
                }
                if(!IsSMIME3Supported())
                {
                    DeleteMenu(hmenuPopup, ID_SEC_RECEIPT_REQUEST, MF_BYCOMMAND);
                    m_fSecReceiptRequest = FALSE;
                }


#endif 
            }
            else
            {
                DeleteMenu(hmenuPopup, ID_REQUEST_READRCPT, MF_BYCOMMAND);
#ifdef SMIME_V3
                DeleteMenu(hmenuPopup, ID_INCLUDE_LABEL, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_LABEL_SETTINGS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_SEC_RECEIPT_REQUEST, MF_BYCOMMAND);
                m_fSecurityLabel = FALSE;
                m_fSecReceiptRequest = FALSE;
#endif 
            }

            if (GetMenuItemInfo(hmenuPopup, ID_POPUP_ADDRESS_BOOK, FALSE, &mii))
                m_pHdr->UpdateRecipientMenu(mii.hSubMenu);

            break;

        case ID_POPUP_MESSAGE:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);
            break;
        }

        case ID_POPUP_LANGUAGE:
        {
            if (m_pBodyObj2)
                m_pBodyObj2->HrOnInitMenuPopup(hmenuPopup, ID_POPUP_LANGUAGE);
            break;
        }
    }
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    if (fEnableStyleMenu)
    {
        if (m_pBodyObj2)
            m_pBodyObj2->UpdateBackAndStyleMenus(hmenuPopup);
    }

    return S_OK;
}

// *************************
void CNote::RemoveNewMailIcon(void)
{
    HRESULT     hr;
    FOLDERINFO  fiFolderInfo;
    FOLDERID    idFolder;

    // If a message is marked (read or deleted) and it's from the Inbox,
    // remove the new mail notification icon from the tray
    if (NULL == g_pInstance || NULL == m_pMsgSite || NULL == g_pStore)
        return;

    hr = m_pMsgSite->GetFolderID(&idFolder);
    if (FAILED(hr))
        return;

    hr = g_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        if (FOLDER_INBOX == fiFolderInfo.tySpecial)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);

        g_pStore->FreeRecord(&fiFolderInfo);
    }
}


// *************************
LRESULT CNote::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, UINT wID)
{
    return 0;
}


// *************************
void CNote::WMGetMinMaxInfo(LPMINMAXINFO pmmi)
{

    MINMAXINFO  mmi={0};
    RECT        rc;
    int         cy;
    ULONG       cyAttMan=0;
    HWND        hwnd;

    cy=GetRequiredHdrHeight();

    
    Assert(IsWindow(m_hwndToolbar));
    if(IsWindowVisible(m_hwndToolbar))
    {
        GetWindowRect(m_hwndToolbar, &rc);
        cy += cyRect(rc);
    }
    
    cy += GetSystemMetrics(SM_CYCAPTION);
    cy += GetSystemMetrics(SM_CYMENU);
    cy += 2*cyMinEdit;
    pmmi->ptMinTrackSize.x=200; //hack
    pmmi->ptMinTrackSize.y=cy;
}

// *************************
INT CNote::GetRequiredHdrHeight()
{
    RECT    rc={0};

    if(m_pHdr)
        m_pHdr->GetRect(&rc);
    return cyRect(rc);
}

// *************************
LONG CNote::lTestHook(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

// *************************
void CNote::WMNotify(int idFrom, NMHDR *pnmh)
{
    switch(pnmh->code)
    {
        case NM_SETFOCUS:
            if (pnmh)
                OnSetFocus(pnmh->hwndFrom);
            break;

        case NM_KILLFOCUS:
            OnKillFocus();
            break;

        case BDN_DOWNLOADCOMPLETE:
            OnDocumentReady();
            break;

        case BDN_MARKASSECURE:
            MarkMessage(MARK_MESSAGE_NOSECUI, APPLY_SPECIFIED);
            break;

        case TBN_DROPDOWN:
            OnDropDown(m_hwnd, pnmh);
            break;
    }
}

// *************************
void CNote::OnDocumentReady()
{
    if (!m_fOnDocReadyHandled && m_fCompleteMsg)
    {
        HRESULT     hr;
        DWORD       dwStatusFlags;

        m_fOnDocReadyHandled = TRUE;

        m_pMsgSite->GetStatusFlags(&dwStatusFlags);
        // once, we've got a successfull download, we can init the attachment manager.
        // we can't do this before, as we have to wait until Trident has requested MHTML parts so we
        // can mark them as inlined. If we're in a reply or reply all then we have to remove the unused
        // attachments at this time

        if (IsReplyNote())
            HrRemoveAttachments(m_pMsg, FALSE);

        // #62618: hack. if forwarding a multi/altern in (force) plain-text mode then the html part
        // shows up as an attachment
        // we call GetTextBody here on the html body if we're a plaintext node in forward so that
        // PID_ATT_RENDERED is set before we load teh attachment well
        if (m_dwNoteAction == OENA_FORWARD && m_fHtml == FALSE)
        {
            HBODY   hBody;
            IStream *pstm;

            if (m_pMsg && 
                !FAILED(m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)))
                pstm->Release();
        }


        if (m_pHdr)
        {
            if (FAILED(m_pHdr->OnDocumentReady(m_pMsg)))
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAttmanLoadFail), NULL, MB_OK|MB_ICONEXCLAMATION);
            m_pHdr->SetVCard((OEMSF_FROM_MSG|OEMSF_VIRGIN) & dwStatusFlags);
        }

        ClearDirtyFlag();

        // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect
        // Internet Encoded and Windows Encoding are CPI_AUTODETECT
        {
            INETCSETINFO CsetInfo ;
            HCHARSET hCharset = NULL ;
            int nIdm = 0 ;

            // if it is a new message, check if charset equals to default charset
            if ((OENA_COMPOSE == m_dwNoteAction) && (OEMSF_VIRGIN & dwStatusFlags))
            {
                // defer default charset reading until now ..
                if (g_hDefaultCharsetForMail==NULL) 
                    ReadSendMailDefaultCharset();

                if (m_hCharset != g_hDefaultCharsetForMail )
                    hCharset = g_hDefaultCharsetForMail ;

                // get CharsetInfo from HCHARSET
                if ( hCharset)
                    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
                else
                    MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);
            }
            else
                // get CharsetInfo from HCHARSET
                MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);

            // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
            // re-map iso-2022-jp to default charset if they are in the same category
            if (!m_fReadNote) 
            {
                hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE));
            }
            else
            {
                VARIANTARG  va;

                va.vt = VT_BOOL;
                va.boolVal = VARIANT_TRUE;

                m_pCmdTargetBody->Exec(&CMDSETID_MimeEdit, MECMDID_TABLINKS, 0, &va, NULL);
            }

            // has a new charset defined, change it
            ChangeCharset(hCharset);

            // if user want's auto complete, enable it once we're fully loaded
            if (DwGetOption(OPT_USEAUTOCOMPLETE))
                HeaderExecCommand(MSOEENVCMDID_AUTOCOMPLETE, MSOCMDEXECOPT_DODEFAULT, NULL);

            if (m_fReadNote && m_fMail && m_pMsgSite)
            {
                if(m_pMsgSite->Notify(OEMSN_PROCESS_READRCPT_REQ) != S_OK)
                    return;
            }
        }

        if(DwGetOption(OPT_RTL_MSG_DIR) && ((m_dwNoteAction == OENA_FORWARDBYATTACH) || (OEMSF_VIRGIN & dwStatusFlags)))
        {
            if(FAILED(m_pCmdTargetBody->Exec(&CMDSETID_Forms3, IDM_DIRRTL, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
                AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrRTLDirFailed), NULL, MB_OK);
        }

        EnterCriticalSection(&m_csNoteState);

        if(m_nisNoteState == NIS_INIT)
            m_nisNoteState = NIS_NORMAL;

        LeaveCriticalSection(&m_csNoteState);
    }    
}

HRESULT CNote::ChangeCharset(HCHARSET hCharset)
{
    HRESULT hr = S_OK;
    if (hCharset && (hCharset != m_hCharset))
    {
        Assert(m_pBodyObj2);
        IF_FAILEXIT(hr = m_pBodyObj2->HrSetCharset(hCharset));

        // set the new charset into the message and call HrLanguageChange to update the headers
        m_hCharset = hCharset;
        if (m_pMsg)
            m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);

        if (m_pHdr)
            m_pHdr->ChangeLanguage(m_pMsg);

        UpdateTitle();
    }

exit:
    return hr;
}

HRESULT CNote::GetCharset(HCHARSET *phCharset)
{
    Assert(phCharset);

    *phCharset = m_hCharset;

    return S_OK;
}

// *************************
LRESULT CNote::OnDropDown(HWND hwnd, LPNMHDR lpnmh)
{
    UINT            i;
    HMENU           hMenuPopup;
    RECT            rc;
    DWORD           dwCmd;
    TBNOTIFY       *ptbn = (TBNOTIFY *)lpnmh;

    if (ptbn->iItem == ID_SET_PRIORITY)
        {
        hMenuPopup = LoadPopupMenu(IDR_PRIORITY_POPUP);
        if (hMenuPopup != NULL)
            {
            for (i = 0; i < 3; i++)
                CheckMenuItem(hMenuPopup, i, MF_UNCHECKED | MF_BYPOSITION);
            m_pHdr->GetPriority(&i);
            Assert(i != priNone);
            CheckMenuItem(hMenuPopup, 2 - i, MF_CHECKED | MF_BYPOSITION);

            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);
        
            DestroyMenu(hMenuPopup);
            }
        }
    else if (ptbn->iItem == ID_INSERT_SIGNATURE)
        {
        hMenuPopup = CreatePopupMenu();
        if (hMenuPopup != NULL)
            {        
            FillSignatureMenu(hMenuPopup, NULL);
            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);

            DestroyMenu(hMenuPopup);
            }
        }
    else if(ptbn->iItem == ID_POPUP_LANGUAGE)
    {
        DeferedLanguageMenu();
        hMenuPopup = m_hmenuLanguage;
        if(hMenuPopup)
        {
            MenuUtil_EnablePopupMenu(hMenuPopup, this);
            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);
        }
    }

    return(TBDDRET_DEFAULT);
}

// *************************
void CNote::UpdateMsgOptions(LPMIMEMESSAGE pMsg)
{
    // Store the options onto the message object
    SideAssert(SUCCEEDED(HrSetMailOptionsOnMessage(pMsg, &m_rHtmlOpt, &m_rPlainOpt, m_hCharset, m_fHtml)));
}

// *************************
HRESULT CNote::SetComposeStationery()
{
    LPSTREAM        pstm;
    WCHAR           wszFile[MAX_PATH];
    HRESULT         hr=E_FAIL;
    HCHARSET        hCharset;
    ENCODINGTYPE    ietEncoding = IET_DECODED;
    BOOL            fLittleEndian;

    AssertSz(m_fHtml, "Are you sure you want to set stationery in plain-text mode??");

    if (!(m_dwNoteCreateFlags & OENCF_NOSTATIONERY) && m_pMsg &&
        DwGetOption(m_fMail?OPT_MAIL_USESTATIONERY:OPT_NEWS_USESTATIONERY) &&
        SUCCEEDED(GetDefaultStationeryName(m_fMail, wszFile)))
    {
        if (SUCCEEDED(hr = HrCreateBasedWebPage(wszFile, &pstm)))
        {
            if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
            {
                if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
                {
                    m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
                }

                ietEncoding = IET_UNICODE;
            }

            hr = m_pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL);
            pstm->Release();
            m_fUseStationeryFonts = TRUE;
        }
    }
    return hr;
}

// *************************
HRESULT CNote::CycleThroughControls(BOOL fForward)
{

    HRESULT hr = CheckTabStopArrays();
    if (SUCCEEDED(hr))
    {
        int index, newIndex;
        BOOL fFound = FALSE;
        HWND hCurr = GetFocus();

        for (index = 0; index < m_cTabStopCount; index++)
            if (hCurr == m_pTabStopArray[index])
            {
                fFound = TRUE;
                break;
            }

        newIndex = fFound ? GetNextIndex(index, fForward) : m_iIndexOfBody;

        if (newIndex == m_iIndexOfBody)
            m_pBodyObj2->HrUIActivate(TRUE);
        else       
            SetFocus(m_pTabStopArray[newIndex]);
    }
    return hr;
}

// *************************
HRESULT CNote::CheckTabStopArrays()
{
    HRESULT hr = S_OK;
    if (m_fTabStopsSet)
        return S_OK;

    m_fTabStopsSet = TRUE;
    HWND *pArray = m_pTabStopArray;
    int cCount = MAX_HEADER_COMP;

    hr = m_pHdr->GetTabStopArray(pArray, &cCount);
    if (FAILED(hr))
        goto error;

    pArray += cCount;
    m_cTabStopCount = cCount;
    cCount = MAX_BODY_COMP;

    hr = m_pBodyObj2->GetTabStopArray(pArray, &cCount);
    if (FAILED(hr))
        goto error;

    // This assumes that the first in the list returned from m_pBodyObj2-GetTabStopArray
    // is the Trident window handle. If that changes where it returns more than one 
    // handle, or something else, this simple index scheme won't work
    m_iIndexOfBody = m_cTabStopCount;
    pArray += cCount;
    m_cTabStopCount += cCount;
    cCount = MAX_ATTMAN_COMP;

    m_cTabStopCount += cCount;

    return S_OK;

error:
    m_cTabStopCount = 0;
    m_fTabStopsSet = FALSE;

    return hr;
}

// *************************
int CNote::GetNextIndex(int index, BOOL fForward)
{
    LONG style;
    int cTotalTested = 0;
    BOOL fGoodHandleFound;

    do 
    {
        if (fForward)
        {
            index++;
            if (index >= m_cTabStopCount)
                index = 0;
        }
        else
        {
            // If this is true, other asserts should have fired before now.
            Assert(m_cTabStopCount > 0);
            index--;
            if (index < 0)
                index = m_cTabStopCount - 1;
        }
        style = GetWindowLong(m_pTabStopArray[index], GWL_STYLE);
        cTotalTested++;
        fGoodHandleFound = ((0 == (style & WS_DISABLED)) && 
                            (style & WS_VISIBLE) && 
                            ((style & WS_TABSTOP) || (index == m_iIndexOfBody)));  // Trident doesn't mark itself as a tabstop
    } while (!fGoodHandleFound && (cTotalTested < m_cTabStopCount));

    if (cTotalTested >= m_cTabStopCount)
        index = m_iIndexOfBody;
    return index;
}

// *************************
HRESULT CreateAndShowNote(DWORD dwAction, DWORD dwCreateFlags, INIT_MSGSITE_STRUCT *pInitStruct, 
                          HWND hwnd,      IUnknown *punk, RECT *prc, IOEMsgSite *pMsgSite)
{
    HRESULT hr = S_OK;
    CNote *pNote = NULL;

    AssertSz((pMsgSite || pInitStruct), "Should have either a pInitStruct or a pMsgSite...");

    // If we are coming from news, we might need to pass off this call to the smapi
    // client. If we reply or forward a message that was news, pass it off to smapi
    if ((OENCF_NEWSFIRST & dwCreateFlags) && ((OENA_REPLYTOAUTHOR == dwAction)  || (OENA_FORWARD == dwAction) || (OENA_FORWARDBYATTACH == dwAction)))
    {
        // fIsDefaultMailConfiged hits the reg, only check for last result
        if (!FIsDefaultMailConfiged())
        {
            IOEMsgSite     *pSite = NULL;
            CStoreCB       *pCB = NULL;


            //send using smapi
            if (pInitStruct)
            {
                pCB = new CStoreCB;
                if (!pCB)
                    hr = E_OUTOFMEMORY;

                if (SUCCEEDED(hr))
                    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);

                if (SUCCEEDED(hr))
                    pSite = new COEMsgSite();

                if (!pSite)
                    hr = E_OUTOFMEMORY;

                if (SUCCEEDED(hr))
                    hr = pSite->Init(pInitStruct);

                if (SUCCEEDED(hr))
                    pSite->SetStoreCallback(pCB);
            }
            else
                ReplaceInterface(pSite, pMsgSite);

            if (pSite)
            {
                if (SUCCEEDED(hr))
                {
                    IMimeMessage   *pMsg = NULL;
                    BOOL            fCompleteMsg;
                    HRESULT         hres = E_FAIL;
                    DWORD           dwMsgFlags = (OENA_FORWARDBYATTACH == dwAction) ? (OEGM_ORIGINAL|OEGM_AS_ATTACH) : NOFLAGS;

                    hr = pSite->GetMessage(&pMsg, &fCompleteMsg, dwMsgFlags, &hres);
                    if (E_PENDING == hr)
                    {
                        AssertSz((pCB && pMsgSite), "Should never get E_PENDING with pMsgSite being NULL");
                        pCB->Block();
                        pCB->Close();

                        hr = pSite->GetMessage(&pMsg, &fCompleteMsg, dwMsgFlags, &hres);
                    }
                
                    if (pCB)
                        pCB->Close();

                    if (SUCCEEDED(hr))
                    {
                        if (SUCCEEDED(hres))
                            hr = NewsUtil_ReFwdByMapi(hwnd, pMsg, dwAction);
                        pMsg->Release();
                    }
                }
                // Don't want to close the site if it came from another note...
                if (!pMsgSite)
                    pSite->Close();

                pSite->Release();
            }

            ReleaseObj(pCB);
            // if we succeeded, then we need to tell the creator that we 
            // cancelled the creation through OE and went with the smapi client
            return (FAILED(hr) ? hr : MAPI_E_USER_CANCEL);
        }
    }

    //We are the default smapi client
    pNote = new CNote;
    if (pNote)
        hr = pNote->Init(dwAction, dwCreateFlags, prc, hwnd, pInitStruct, pMsgSite, punk);
    else
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pNote->Show();

    ReleaseObj(pNote);

    if (FAILED(hr))
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrNewsCantOpen), hr); 
    return hr;
}
// *************************
HRESULT CNote::SaveMessageAs()
{
    HRESULT             hr=S_OK;
    IMimeMessage        *pSecMsg=NULL;
    BOOL                fCanbeDurt = !m_fReadNote;
    PROPVARIANT     rVariant;
    IMimeBody      *pBody = NULL;

    // Raid #25822: we can't just get the message source if it
    // is a secure message
    if (m_fReadNote/* && IsSecure(m_pMsg)*/)
    {
        // Won't care about these since the user already loaded the message
        BOOL    fCompleteMsg = FALSE; 
        HRESULT tempHr = S_OK;
        m_pMsgSite->GetMessage(&pSecMsg, &fCompleteMsg, OEGM_ORIGINAL, &tempHr);

        AssertSz(fCompleteMsg && SUCCEEDED(tempHr), "Shouldn't have reached this point if the load failed now.");
    } 
    else
    {
        hr = CommitChangesInNote();
        if (FAILED(hr))
            goto error;

        // if a compose note, set the X-Unsent header if saving to .eml files, and save the props.
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, "1");

        if(IsSecure(m_pMsg))
        {
            if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                    MAKEINTRESOURCEW(idsSaveSecMsgToFolder), NULL, MB_OKCANCEL) == IDCANCEL)
                goto error;
            else 
            {
                rVariant.vt = VT_BOOL;
                rVariant.boolVal = TRUE;

                hr = m_pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                if(SUCCEEDED(hr))
                {
                    pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                    ReleaseObj(pBody);
                }

                fCanbeDurt = FALSE;
            }
        }
        
    }

    // SaveMessageToFile displays a failure error.
    _SetPendingOp(SOT_PUT_MESSAGE);

    hr = HrSaveMessageToFile(m_hwnd, (pSecMsg ? pSecMsg : m_pMsg), m_pMsg, !m_fMail, fCanbeDurt);
    if (SUCCEEDED(hr))
        _OnComplete(SOT_PUT_MESSAGE, S_OK);
    else if (E_PENDING == hr)
    {
        EnableNote(FALSE);
        hr = S_OK;
    }

error:
    ReleaseObj(pSecMsg);
    return hr;
}

// *************************
HRESULT CNote::CommitChangesInNote()
{
    LPMIMEMESSAGE   pMsg=0;
    HRESULT         hr=S_OK;

    Assert(m_pMsg);

    if (!m_fReadNote && !m_fBodyContainsFrames)
    {
        if (FAILED(HrCreateMessage(&pMsg)))
            return E_FAIL;

        hr = Save(pMsg, 0);
        if (SUCCEEDED(hr))
            ReplaceInterface(m_pMsg, pMsg)

        pMsg->Release();
    }

    return hr;
}

// *************************
void CNote::ToggleFormatbar()
{
    m_fFormatbarVisible = !m_fFormatbarVisible;

    SetDwOption(OPT_SHOW_NOTE_FMTBAR, m_fFormatbarVisible, NULL, 0);
    m_pBodyObj2->HrSetStyle(m_fFormatbarVisible ? MESTYLE_FORMATBAR : MESTYLE_NOHEADER);
}

// *************************
void CNote::ToggleStatusbar()
{
    RECT    rc;

    m_fStatusbarVisible = !m_fStatusbarVisible;

    SetDwOption(OPT_SHOW_NOTE_STATUSBAR, m_fStatusbarVisible, NULL, 0);

    m_pstatus->ShowStatus(m_fStatusbarVisible);

    // cause a size
    GetWindowRect(m_hwnd, &rc);
    WMSize(rc.right-rc.left, rc.bottom-rc.top, FALSE);
}

// *************************
HRESULT CNote::ToggleToolbar()
{
    RECT    rc;

    m_fToolbarVisible = !m_fToolbarVisible;

    if (m_pToolbarObj)
        m_pToolbarObj->HideToolbar(!m_fToolbarVisible);

    GetWindowRect(m_hwnd, &rc);
    // cause a size
    WMSize(rc.right-rc.left, rc.bottom-rc.top, FALSE);

    return S_OK;
}

// *************************
void CNote::FormatSettings()
{
    AssertSz(m_fReadNote, "this is broken for readnote!!!");

    if (m_fHtml)
        FGetHTMLOptions(m_hwnd, &m_rHtmlOpt);
    else
        FGetPlainOptions(m_hwnd, &m_rPlainOpt);
}

// *************************
void CNote::SwitchLanguage(int idm)
{
    HCHARSET    hCharset, hOldCharset;
    HRESULT     hr;

    hCharset = GetMimeCharsetFromMenuID(idm);

    if (!hCharset || (hCharset == m_hCharset))
        return;

    hOldCharset = m_hCharset;

    // View|Language in a view does not affect the listview as in v1. It only affect the preview.
    // the user can change his default charset to get changes in the listview
    // setcharset on the body object will cause it to refresh with new fonts etc.
    hr = ChangeCharset(hCharset);
    if (FAILED(hr))
    {
        AthMessageBoxW( m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                        MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                        NULL, MB_OK|MB_ICONEXCLAMATION);
        goto Exit;
    }

    // here after we ask user if he wants to add this change to charset remapping list
    m_pMsgSite->SwitchLanguage(hOldCharset, hCharset);

Exit:
    return;
}

// *************************
BOOL CNote::DoProperties()
{
    NOMSGDATA   noMsgData;
    MSGPROP     msgProp;
    UINT        pri;
    TCHAR       szSubj[256];
    TCHAR       szLocation[1024];
    LPSTR       pszLocation = NULL;
    WCHAR       wszLocation[1024];
    BOOL        fSucceeded;
    
    msgProp.pNoMsgData = &noMsgData;
    msgProp.hwndParent = m_hwnd;
    msgProp.type = (m_fMail ? MSGPROPTYPE_MAIL : MSGPROPTYPE_NEWS);
    msgProp.mpStartPage = MP_GENERAL;
    msgProp.szFolderName = 0;  // This one needs to have special handling
    msgProp.pSecureMsg = NULL;
    msgProp.lpWabal = NULL;
    msgProp.szFolderName = szLocation;
    *szLocation = 0;
    m_pMsgSite->GetLocation(wszLocation);
    pszLocation = PszToANSI(CP_ACP, wszLocation);
    StrCpy(szLocation, pszLocation);
    MemFree(pszLocation);
    

    if (m_fReadNote)
    {
        msgProp.dwFlags = ARF_RECEIVED;
        msgProp.pMsg = m_pMsg;
        msgProp.fSecure = IsSecure(msgProp.pMsg);
        if (msgProp.fSecure)
        {
            BOOL    fCompleteMsg = FALSE;
            HRESULT tempHr = S_OK;
            m_pMsgSite->GetMessage(&msgProp.pSecureMsg, &fCompleteMsg, OEGM_ORIGINAL, &tempHr);

            AssertSz(fCompleteMsg && SUCCEEDED(tempHr), "Shouldn't have reached this point if the load failed now.");

            HrGetWabalFromMsg(msgProp.pMsg, &msgProp.lpWabal);
        }
    }
    else
    {
        msgProp.dwFlags = ARF_UNSENT;
        msgProp.pMsg = NULL;
    }

    m_pHdr->GetPriority(&pri);
    if (pri==priLow)
        noMsgData.Pri=IMSG_PRI_LOW;
    else if (pri==priHigh)
        noMsgData.Pri=IMSG_PRI_HIGH;
    else
        noMsgData.Pri=IMSG_PRI_NORMAL;

    noMsgData.pszFrom = NULL;
    noMsgData.pszSent = NULL;

    noMsgData.ulSize = 0;
    noMsgData.cAttachments = 0;
    m_pHdr->HrGetAttachCount(&noMsgData.cAttachments);

    GetWindowText(m_hwnd, szSubj, sizeof(szSubj)/sizeof(TCHAR));
    noMsgData.pszSubject = szSubj;

    msgProp.fFromListView = FALSE;

    fSucceeded = (S_OK == HrMsgProperties(&msgProp));
    ReleaseObj(msgProp.lpWabal);
    ReleaseObj(msgProp.pSecureMsg);

    return fSucceeded;
}

// *************************
HRESULT CNote::HrSendMail(int id)
{
    IImnAccount    *pAccount=NULL;
    ULONG           i;
    BOOL            fFound=FALSE;
    HRESULT         hr;
    BOOL            fSendLater = (id == ID_SEND_LATER);
    VARIANTARG      varIn;
    DWORD           dwMsgSiteFlags=0;

    // Do spell check if needed
    if (FCheckSpellAvail() && FCheckOnSend())
    {
        HWND    hwndFocus=GetFocus();

        hr=m_pBodyObj2->HrSpellCheck(TRUE);
        if (FAILED(hr) || hr==HR_S_SPELLCANCEL)
        {
            if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsSpellMsgSendOK), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
            {
                SetFocus(hwndFocus);
                return E_FAIL;
            }
        }
    }

    if (!m_fMail && m_pBodyObj2)
    {
        BOOL fEmpty = FALSE;
        if (SUCCEEDED(m_pBodyObj2->HrIsEmpty(&fEmpty)) && fEmpty)
        {
            if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsNoTextInNewsPost), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
                return MAPI_E_USER_CANCEL;
        }
    }

    // During the send, a call to the note save gets made. During
    // that call, IMimeMessage::Commit gets called. That is a big perf hit.
    // It turns out that commit will get called a second time anyway. So
    // set a flag to tell the save not to commit.
    m_fCommitSave = FALSE;
    hr = HeaderExecCommand(MSOEENVCMDID_SEND, fSendLater?MSOCMDEXECOPT_DODEFAULT:MSOCMDEXECOPT_DONTPROMPTUSER, NULL);
    m_fCommitSave = TRUE;

    // REVIEW: dhaws: I don't think this happens anymore. I think the send call no longer returns the conflict
    //RAID 8780: This message MIME_S_CHARSET_CONFLICT will get propagated to here. Now change it to an E_FAIL;
    if (MIME_S_CHARSET_CONFLICT == hr)
        hr = E_FAIL;
    if (FAILED(hr))
        goto error;

    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwMsgSiteFlags);

    // If has been saved, then this note is store based in drafts and
    // need to delete the draft.
    if (((OENA_COMPOSE == m_dwNoteAction) || m_fHasBeenSaved) && !(dwMsgSiteFlags & OEMSF_FROM_FAT))
    {
        HRESULT hr;

        _SetPendingOp(SOT_DELETING_MESSAGES);

        hr = m_pMsgSite->Delete(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT);
        if (SUCCEEDED(hr))
        {
            m_fCBDestroyWindow = TRUE;
            _OnComplete(SOT_DELETING_MESSAGES, S_OK);
        }
        else if (E_PENDING == hr)
        {
            EnableNote(FALSE);
            m_fCBDestroyWindow = TRUE;
        }
        else
        {
            // ~~~ Can we handle this a bit better???
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);
        }
    }
    // If note is reply or forward, then mark the message as appropriate
    else if (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction))
    {
        HRESULT hr;
        BOOL    fForwarded = (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction);
        // Clear any previous flags so we don't show both, only the most recent 

        m_dwMarkOnReplyForwardState = MORFS_CLEARING;
        hr = MarkMessage(fForwarded ? MARK_MESSAGE_UNREPLIED : MARK_MESSAGE_UNFORWARDED, APPLY_SPECIFIED);
        if (FAILED(hr) && (E_PENDING != hr))
        {
            // Even though we have an error, we can still close the note because the send did work.
            PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
            m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
        }
    }
    // Web Page and stationery
    else
        PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);

error:
    ReleaseObj(pAccount);
    return hr;
}

// *************************
HRESULT CNote::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IOEMsgSite) &&
        IsEqualGUID(riid, IID_IOEMsgSite))
    {
        if (!m_pMsgSite)
            return E_FAIL;

        *ppvObject = (LPVOID)m_pMsgSite;
        m_pMsgSite->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// *************************
HRESULT CNote::MarkMessage(MARK_TYPE dwFlags, APPLYCHILDRENTYPE dwApplyType)
{
    HRESULT hr;

    // [PaulHi] 6/8/99  We need to restore the pending operation
    // if the MarkMessage() call fails.
    STOREOPERATIONTYPE  tyPrevOperation = m_OrigOperationType;
    _SetPendingOp(SOT_SET_MESSAGEFLAGS);
    
    hr = m_pMsgSite->MarkMessage(dwFlags, dwApplyType);

    if (SUCCEEDED(hr))
        _OnComplete(SOT_SET_MESSAGEFLAGS, S_OK);
    else if (E_PENDING == hr)
    {
        EnableNote(FALSE);

        EnterCriticalSection(&m_csNoteState);

        if(m_nisNoteState == NIS_INIT)
            m_nisNoteState = NIS_FIXFOCUS;

        LeaveCriticalSection(&m_csNoteState);

        hr = S_OK;
    }
    else
    {
        // Restore previous operation to ensure the note window will be
        // re-enabled.
        _SetPendingOp(tyPrevOperation);
    }

    return hr;
}

HRESULT CNote::_SetPendingOp(STOREOPERATIONTYPE tyOperation)
{
    m_OrigOperationType = tyOperation;
    return S_OK;
}


void CNote::EnableNote(BOOL fEnable)
{
    Assert (IsWindow(m_hwnd));

    m_fInternal = 1;
    if (fEnable)
    {
        if (m_fWindowDisabled)
        {
            EnableWindow(m_hwnd, TRUE);
            if (m_hCursor)
            {
                SetCursor(m_hCursor);
                m_hCursor = 0;
            }
            m_fWindowDisabled = FALSE;
        }
    }
    else
    {
        if (!m_fWindowDisabled)
        {
            m_fWindowDisabled = TRUE;
            EnableWindow(m_hwnd, FALSE);
            m_hCursor = HourGlass();
        }
    }
    m_fInternal = 0;
}

// *************************
void CNote::SetStatusText(LPSTR szBuf)
{
    if(m_pstatus)
        m_pstatus->SetStatusText(szBuf);
}

// *************************
void CNote::SetProgressPct(INT iPct)
{
//    if (m_pstatus)
//        m_pstatus->SetProgressBarPos(1, iPct, FALSE);
}

// *************************
HRESULT CNote::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    
    GetClientRect(m_hwnd, lprectBorder);
    
    DOUTL(4, "CNote::GetBorderDW called returning=%x,%x,%x,%x",
        lprectBorder->left, lprectBorder->top, lprectBorder->right, lprectBorder->bottom);
    return S_OK;
}

// *************************
HRESULT CNote::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    DOUTL(4, "CNote::ReqestBorderSpaceST pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

// *************************
HRESULT CNote::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    
    DOUTL(4, "CNote::SetBorderSpaceDW pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    

    RECT    rcNote = {0};
    GetClientRect(m_hwnd, &rcNote);

    //WMSize(cxRect(rcNote), cyRect(rcNote), FALSE);
    ResizeChildren(cxRect(rcNote), cyRect(rcNote), pborderwidths->top, FALSE);

    return S_OK;
}

// *************************
HRESULT CNote::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

// *************************
BYTE    CNote::GetNoteType()
{
    BYTE    retval;

    if (m_fReadNote)
        retval = m_fMail ? MailReadNoteType : NewsReadNoteType;
    else
        retval = m_fMail ? MailSendNoteType : NewsSendNoteType;

    return retval;
}

// *************************
HRESULT CNote::IsMenuMessage(MSG *lpmsg)
{
    Assert(m_pToolbarObj);
    if (m_pToolbarObj)
        return m_pToolbarObj->IsMenuMessage(lpmsg);
    else
        return S_FALSE;
}

// *************************
HRESULT CNote::EventOccurred(DWORD nCmdID, IMimeMessage *)
{
    switch (nCmdID)
    {
        case MEHC_CMD_MARK_AS_READ:
            RemoveNewMailIcon();
            MarkMessage(MARK_MESSAGE_READ, APPLY_SPECIFIED);
            break;

        case MEHC_CMD_CONNECT:
            if (g_pConMan)
                g_pConMan->SetGlobalOffline(FALSE);

            ReloadMessageFromSite(TRUE);
            AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
            break;

        default:
            return S_FALSE;
    }

    return S_OK;
}

// *************************
HRESULT CNote::QuerySwitchIdentities()
{
    IImnAccount *pAcct = NULL;
    DWORD       dwServType;
    HRESULT     hr;

    if (!IsWindowEnabled(m_hwnd))
    {
        Assert(IsWindowVisible(m_hwnd));
        return E_PROCESS_CANCELLED_SWITCH;
    }

    if (IsDirty() != S_FALSE)
    {
        if (FAILED(hr = m_pHdr->HrGetAccountInHeader(&pAcct)))
            goto fail;

        if (FAILED(hr = pAcct->GetServerTypes(&dwServType)))
            goto fail;

        ReleaseObj(pAcct);
        pAcct = NULL;

        SetForegroundWindow(m_hwnd);

        if (!!(dwServType & SRV_POP3) || !!(dwServType & SRV_NNTP))
        {
            if (!FCanClose())
                return E_USER_CANCELLED;
        }
        else
        {
            // IMAP and HTTPMail would have to remote the note, which they
            // can't do at this point, so fail the switch until the window is closed.
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsCantSaveMsg),
                            MAKEINTRESOURCEW(idsNoteCantSwitchIdentity),
                            NULL, MB_OK | MB_ICONEXCLAMATION);
            return E_USER_CANCELLED;
            
        }
    }

    return S_OK;

fail:
    ReleaseObj(pAcct);
    return E_PROCESS_CANCELLED_SWITCH;
}

// *************************
HRESULT CNote::SwitchIdentities()
{
    HRESULT hr;
    
    if (IsDirty() != S_FALSE)
        hr = SaveMessage(OESF_FORCE_LOCAL_DRAFT);
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    return S_OK;
}

// *************************
HRESULT CNote::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}

// *************************
HRESULT CNote::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, 
                          IOperationCancel *pCancel)
{
    Assert(m_pCancel == NULL);

    if (NULL != pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

// *************************
void CNote::ShowErrorScreen(HRESULT hr)
{
    switch (hr)
    {
        case IXP_E_NNTP_ARTICLE_FAILED:
        case STORE_E_EXPIRED:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_Expired);
            break;

        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_Offline);
            SetFocus(m_hwnd);
            break;

        case STG_E_MEDIUMFULL:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_DiskFull);
            break;
            
        case MIME_E_SECURITY_CANTDECRYPT:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
            break;

#ifdef SMIME_V3
        case MIME_E_SECURITY_LABELACCESSDENIED:
        case MIME_E_SECURITY_LABELACCESSCANCELLED:
        case MIME_E_SECURITY_LABELCORRUPT:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
            break;
#endif // SMIME_V3

        case MAPI_E_USER_CANCEL:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_DownloadCanceled);
            break;

        default:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_GenFailure);
            break;
    }
    m_fCompleteMsg = FALSE;
}


// *************************
HRESULT CNote::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                             DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR       szRes[CCHMAX_STRINGRES],
                szRes2[CCHMAX_STRINGRES],
                szRes3[CCHMAX_STRINGRES];
    MSG         msg;

    if (m_pstatus && pszStatus)
        m_pstatus->SetStatusText(const_cast<LPSTR>(pszStatus));

    CallbackCloseTimeout(&m_hTimeout);

    switch (tyOperation)
    {
        case SOT_GET_MESSAGE:
            if (m_pstatus)
            {
                if (0 != dwMax)
                {
                    if (!m_fProgress)
                    {
                        m_fProgress = TRUE;
                        m_pstatus->ShowProgress(dwMax);
                    }

                    if (m_pstatus)
                        m_pstatus->SetProgress(dwCurrent);

                    if (!pszStatus)
                    {
                        AthLoadString(idsDownloadingArticle, szRes, ARRAYSIZE(szRes));
                        wsprintf(szRes2, szRes, (100 * dwCurrent ) / dwMax );
                        m_pstatus->SetStatusText(szRes2);
                    }
                }
                else if (0 != dwCurrent)
                {
                    // dwCurrent is non-zero, but no max has been specified.
                    // This implies that dwCurrent is a byte count.
                    AthLoadString(idsDownloadArtBytes, szRes, ARRAYSIZE(szRes));
                    AthFormatSizeK(dwCurrent, szRes2, ARRAYSIZE(szRes2));
                    wsprintf(szRes3, szRes, szRes2);
                    m_pstatus->SetStatusText(szRes3);
                }
            }
            break;
    }

    return S_OK;
}

// *************************
HRESULT CNote::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) 
{
    if ((SOT_PUT_MESSAGE == tyOperation) && SUCCEEDED(hrComplete) && pOpInfo && m_pMsgSite)
        m_pMsgSite->UpdateCallbackInfo(pOpInfo);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_pstatus)
    {
        if (m_fProgress)
        {
            m_pstatus->HideProgress();
            m_fProgress = FALSE;
        }

        m_pstatus->SetStatusText(const_cast<LPSTR>(c_szEmpty));
    }

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    PostMessage(m_hwnd, WM_OENOTE_ON_COMPLETE, hrComplete, (DWORD)tyOperation);

    // This is not a very neat fix. But, at this time it is a safe fix. 
    // Here is the reason why we can't do it any other place.
    // _OnComplete posts a destroy message to the note window depending on the operation. 
    // To avoid this object from being destroyed before this function returns, the above
    // message is posted. Since there is no way to pass in the error info through PostMessage,
    // we will handle this error here. I am not handling other operation types because some 
    // of them do get handled in _OnComplete
    if (tyOperation == SOT_DELETING_MESSAGES)
    {
        // Display an Error on Failures
        if (FAILED(hrComplete) && hrComplete != HR_E_OFFLINE)
        {
            // Call into my swanky utility
            CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);
        }

    }
    return S_OK;
}

// *************************
void CNote::_OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete) 
{
    BOOL                fExpectedComplete = TRUE;
    STOREOPERATIONTYPE  tyNewOp = SOT_INVALID;

    m_pMsgSite->OnComplete(tyOperation, hrComplete, &tyNewOp);
    if ((SOT_INVALID != tyNewOp) && (SOT_INVALID != m_OrigOperationType))
        m_OrigOperationType = tyNewOp;

    if (SUCCEEDED(hrComplete))
    {
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                switch (hrComplete)
                {
                case S_OK:
                    ReloadMessageFromSite();
                    AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
                    break;

                case S_FALSE:
                    // S_FALSE means the operation was canceled
                    ShowErrorScreen(MAPI_E_USER_CANCEL);
                    break;
                }
                break;

            case SOT_PUT_MESSAGE:
                ClearDirtyFlag();
                break;

            case SOT_DELETING_MESSAGES:
                if (!m_fCBDestroyWindow && m_fOrgCmdWasDelete)
                    ReloadMessageFromSite(TRUE);
                m_fOrgCmdWasDelete = FALSE;
                break;

            case SOT_COPYMOVE_MESSAGE:
                if (!m_fCBCopy)
                    ReloadMessageFromSite();
                break;

            case SOT_SET_MESSAGEFLAGS:
                if ((MARK_MAX != m_dwCBMarkType) && m_pHdr)
                {
                    m_pHdr->SetFlagState(m_dwCBMarkType);
                    m_dwCBMarkType = MARK_MAX;
                }

                if (MORFS_UNKNOWN != m_dwMarkOnReplyForwardState)
                {
                    if (MORFS_CLEARING == m_dwMarkOnReplyForwardState)
                    {
                        HRESULT hr;
                        BOOL    fForwarded = (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction);
                        MARK_TYPE dwMarkType = (fForwarded ? MARK_MESSAGE_FORWARDED : MARK_MESSAGE_REPLIED);

                        m_dwMarkOnReplyForwardState = MORFS_SETTING;
                        hr = MarkMessage(dwMarkType, APPLY_SPECIFIED);
                        if (FAILED(hr) && (E_PENDING != hr))
                            m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                    }
                    else
                    {
                        PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
                        m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                    }
                }

                // Remove new mail notification icon
                RemoveNewMailIcon();
                break;

            default:
                fExpectedComplete = FALSE;
                break;
        }
    }
    else
    {
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                ShowErrorScreen(hrComplete);
                break;

            case SOT_PUT_MESSAGE:
                if (FAILED(hrComplete))
                {
                    HRESULT hrTemp;

                    // Can't save to remote server for whatever reason. Save to local Drafts instead
                    // First, inform user of the situation, if special folders SHOULD have worked
                    if (STORE_E_NOREMOTESPECIALFLDR != hrComplete)
                    {
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena),
                            MAKEINTRESOURCEW(idsForceSaveToLocalDrafts),
                            NULL, MB_OK | MB_ICONEXCLAMATION);
                    }

                    hrTemp = SaveMessage(OESF_FORCE_LOCAL_DRAFT);
                    TraceError(hrTemp);
                }
                break;

            case SOT_SET_MESSAGEFLAGS:
                if (MORFS_UNKNOWN != m_dwMarkOnReplyForwardState)
                    m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                break;

            case SOT_DELETING_MESSAGES:
                m_fOrgCmdWasDelete = FALSE;
                break;


            default:
                fExpectedComplete = FALSE;
                break;
        }

    }

    // If the original operation was originated from the note, then
    // we will need to re-enable the note as well as check to see
    // if we need to close the window.
    if (tyOperation == m_OrigOperationType)
    {
        _SetPendingOp(SOT_INVALID);

        EnableNote(TRUE);
        
        EnterCriticalSection(&m_csNoteState);

        if ((tyOperation == SOT_SET_MESSAGEFLAGS) && (m_nisNoteState == NIS_FIXFOCUS))
        {
            if(GetForegroundWindow() == m_hwnd)
                m_pBodyObj2->HrFrameActivate(TRUE);
            else
                m_pBodyObj2->HrGetWindow(&m_hwndFocus);
            m_nisNoteState = NIS_NORMAL;
        }

        LeaveCriticalSection(&m_csNoteState);

        if (!!m_fCBDestroyWindow)
        {
            m_fCBDestroyWindow = FALSE;
            PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
        }
    }
}

// *************************
HRESULT CNote::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{ 
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

// *************************
HRESULT CNote::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{ 
    // Call into general CanConnect Utility
    //return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
    //Always TRUE will prompt to go online if we are offline, which is what we want to do.
    return CallbackCanConnect(pszAccountId, m_hwnd, TRUE);
}

// *************************
HRESULT CNote::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) 
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

// *************************
HRESULT CNote::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

// *************************
HRESULT CNote::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{ 
    *phwndParent = m_hwnd;
    return(S_OK);
}

// *************************
HRESULT CNote::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    HRESULT hr = S_OK;

    // Call into general timeout response utility
    if (NULL != m_pCancel)
        hr = CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);

    return hr;
}

// *************************
HRESULT CNote::CheckCharsetConflict()
{
    return m_fPreventConflictDlg ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\note.h ===
#ifndef _NOTE_H_
#define _NOTE_H_

#include "imsgsite.h"
#include "ibodyopt.h"
#include "iheader.h"
#include "statbar.h"
#include "ibodyobj.h"
#include "msgsite.h"
#include "options.h"
#include "acctutil.h"
#include "dllmain.h"
#include "tbbands.h"
#include "msident.h"
#include "storutil.h"

enum NOTEINITSTATE
{
    NIS_INIT = -1,
    NIS_NORMAL = 0,
    NIS_FIXFOCUS = 1
};

// As header, body and attman add additional items that should
// be included in the tab order, these items might need to 
// be increased
const int MAX_HEADER_COMP = 11;
const int MAX_BODY_COMP = 1;
const int MAX_ATTMAN_COMP = 1;

class COEMsgSite;
interface IBodyObj2;

class CNote : 
    public IOENote,
    public IBodyOptions,
    public IDropTarget,
    public IHeaderSite,
    public IPersistMime,
    public IServiceProvider,
    public IDockingWindowSite,
    public IMimeEditEventSink,
    public IIdentityChangeNotify,
    public IOleCommandTarget,
    public IStoreCallback,
    public ITimeoutCallback
{
public:
    CNote();
    ~CNote();

    // IUnknown
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    // IOENote
    virtual HRESULT STDMETHODCALLTYPE Init(DWORD action, DWORD dwCreateFlags, RECT *prc, HWND hwnd, 
                                           INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite, 
                                           IUnknown *punkPump);
    virtual HRESULT STDMETHODCALLTYPE Show(void);
    virtual HRESULT ToggleToolbar(void);

    // IBodyOptions
    virtual HRESULT STDMETHODCALLTYPE SignatureEnabled(BOOL fAuto);
    virtual HRESULT STDMETHODCALLTYPE GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE GetMarkAsReadTime(LPDWORD pdwSecs);
    virtual HRESULT STDMETHODCALLTYPE GetFlags(LPDWORD pdwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetInfo(BODYOPTINFO *pBOI);
    virtual HRESULT STDMETHODCALLTYPE GetAccount(IImnAccount **ppAcct);

    // IHeaderSite
    virtual HRESULT STDMETHODCALLTYPE Resize(void);
    virtual HRESULT STDMETHODCALLTYPE Update(void);
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE IsHTML(void);
    virtual HRESULT STDMETHODCALLTYPE SetHTML(BOOL);
    virtual HRESULT STDMETHODCALLTYPE SaveAttachment(void);
    virtual HRESULT STDMETHODCALLTYPE IsModal();
    virtual HRESULT STDMETHODCALLTYPE CheckCharsetConflict();
    virtual HRESULT STDMETHODCALLTYPE ChangeCharset(HCHARSET hCharset);
    virtual HRESULT STDMETHODCALLTYPE GetCharset(HCHARSET *phCharset);
#ifdef SMIME_V3
    virtual HRESULT STDMETHODCALLTYPE GetLabelFromNote(PSMIME_SECURITY_LABEL *plabel);
    virtual HRESULT STDMETHODCALLTYPE IsSecReceiptRequest(void);
    virtual HRESULT STDMETHODCALLTYPE IsForceEncryption(void);
#endif

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE IsDirty(void);
    virtual HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE);
    virtual HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE InitNew(void);
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IDropTarget methods
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IServiceProvider
    HRESULT STDMETHODCALLTYPE QueryService(REFGUID rsid, REFIID riid, void **ppvObj);

    // IMimeEditEventSink
    HRESULT STDMETHODCALLTYPE EventOccurred(DWORD cmdID, IMimeMessage *pMessage);

    // IIdentityChangeNotify
    HRESULT STDMETHODCALLTYPE QuerySwitchIdentities();
    HRESULT STDMETHODCALLTYPE SwitchIdentities();
    HRESULT STDMETHODCALLTYPE IdentityInformationChanged(DWORD dwType);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IDockingWindowSite (also IOleWindow)
    HRESULT STDMETHODCALLTYPE GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    HRESULT STDMETHODCALLTYPE RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    HRESULT STDMETHODCALLTYPE SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    
    // IOleWindow methods
    HRESULT STDMETHODCALLTYPE GetWindow (HWND * lphwnd);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode) {return E_NOTIMPL;};

    // IStoreCallback methods
    HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    // ITimeoutCallback
    HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    HRESULT TranslateAccelerator(LPMSG lpmsg);
    static LRESULT EXPORT_16 CALLBACK ExtNoteWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT IsMenuMessage(MSG *lpmsg);

protected:
    BOOL IsFlagged(DWORD dwFlag = ARF_FLAGGED);
    BOOL FCanClose();
    BOOL IsReplyNote();
    BOOL DoProperties();
    BOOL WMCreate(HWND hwnd);

    void WMNCDestroy();
    void FormatSettings();
    void ToggleFormatbar();
    void ToggleStatusbar();
    void OnDocumentReady();
    void InitSendAndBccBtns();
    void DeferedLanguageMenu();
    void DisableSendNoteOnlyMenus();

    void WMSize(int, int, BOOL);
    void RemoveNewMailIcon(void);
    void SwitchLanguage(int idm);
    void SetProgressPct(INT iPct);
    void SetStatusText(LPSTR szBuf);
    void GetNoteMenu(HMENU *phmenu);
    void ShowErrorScreen(HRESULT hr);
    void WMGetMinMaxInfo(LPMINMAXINFO pmmi);
    void WMNotify(int idFrom, NMHDR *pnmhdr);
    void UpdateMsgOptions(LPMIMEMESSAGE pMsg);
    void ReloadMessageFromSite(BOOL fOriginal = FALSE);
    void ChangeReadToComposeIfUnsent(IMimeMessage *pMsg);
    void EnableNote(BOOL fEnable);
    HRESULT _SetPendingOp(STOREOPERATIONTYPE tyOperation);

    void _OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete) ;

    HRESULT InitBodyObj();
    HRESULT OnKillFocus();
    HRESULT UpdateTitle();
    HRESULT SaveMessage(DWORD dwSaveFlags);
    HRESULT SaveMessageAs();
    HRESULT ClearDirtyFlag();
    HRESULT CheckTabStopArrays();
    HRESULT CommitChangesInNote();
    HRESULT InitMenusAndToolbars();
    HRESULT SetComposeStationery();

    HRESULT HrSendMail(int idm);
    HRESULT OnSetFocus(HWND hwndFrom);
    HRESULT SetCharsetUnicodeIfNeeded(IMimeMessage *pMsg);
    HRESULT CycleThroughControls(BOOL fForward);
    HRESULT InitWindows(RECT *prc, HWND ownerHwnd);
    HRESULT WMCommand(HWND hwndCmd, int id, WORD wCmd);
    HRESULT MarkMessage(MARK_TYPE dwFlags, APPLYCHILDRENTYPE dwApplyType);
    HRESULT HeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);

    LRESULT WMInitMenuPopup(HWND, HMENU, UINT);
    LRESULT OnDropDown(HWND hwnd, LPNMHDR lpnmh);
    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    LRESULT OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, UINT wID);
    LRESULT NoteDefWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    INT GetRequiredHdrHeight();
    HACCEL GetAcceleratorTable();
    int GetNextIndex(int index, BOOL fForward);
    LONG lTestHook(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BYTE    GetNoteType();
    void    ResizeChildren(int cxNote, int cyNote, int cy, BOOL fInternal);
    void    CheckAndForceEncryption(void);
private:
    CStatusBar         *m_pstatus;

    // Used to make sure that special pumps for note don't close while note is open.
    // This was initially for the finder.
    IUnknown           *m_punkPump; 

    IOEMsgSite         *m_pMsgSite;
    IHeader            *m_pHdr;
    IMimeMessage       *m_pMsg;
    IPersistMime       *m_pPrstMime;
    IBodyObj2          *m_pBodyObj2;
    IOleCommandTarget  *m_pCmdTargetHdr,
                       *m_pCmdTargetBody;
    IDropTarget        *m_pDropTargetHdr,
                       *m_pTridentDropTarget;
    IOperationCancel   *m_pCancel;

    HTMLOPT             m_rHtmlOpt;
    PLAINOPT            m_rPlainOpt;
    MARK_TYPE           m_dwCBMarkType;
    STOREOPERATIONTYPE  m_OrigOperationType;

    HCHARSET            m_hCharset;
    HBITMAP             m_hbmBack;
    HICON               m_hIcon;
    HCURSOR             m_hCursor;
    HTIMEOUT            m_hTimeout;

    LPACCTMENU          m_pAcctMenu,
                        m_pAcctLater;
    int                 m_cTabStopCount,
                        m_iIndexOfBody;
    NOTEINITSTATE       m_nisNoteState;
    CRITICAL_SECTION    m_csNoteState;
    HMENU               m_hmenuLanguage,
                        m_hmenuAccounts,
                        m_hmenuLater;
    ULONG               m_cRef, 
                        m_ulPct,
                        m_cAcctMenu,
                        m_cAcctLater;
    DWORD               m_dwNoteCreateFlags,
                        m_dwNoteAction,
                        m_dwMarkOnReplyForwardState,
                        m_dwIdentCookie;
    HWND                m_hwnd,
                        m_pTabStopArray[MAX_HEADER_COMP+MAX_BODY_COMP+MAX_ATTMAN_COMP],
                        m_hwndFocus,
                        m_hwndOwner,
                        m_hwndToolbar;
    BOOL                m_fHtml                 :1,     // Tells whether we are in html mode or not
                        m_fMail                 :1,     // This will be removed when the UI is combined
                        m_fReadNote             :1,     // Is this a read note?
                        m_fPackageImages        :1,     // Toggled per note. Use to be m_fSendImages
                        m_fUseStationeryFonts   :1,     // Keep fonts that are in the stationary
                        m_fToolbarVisible       :1,     // Is toolbar visible
                        m_fStatusbarVisible     :1,     // Is status bar visible
                        m_fFormatbarVisible     :1,     // Is the format bar visible
                        m_fHeaderUIActive       :1,     // Are we currently active?
                        m_fBypassDropTests      :1,     // Used to say drop not acceptable. Use to be m_fNoText
                        m_fCompleteMsg          :1,     // Is true if message contains all of message
                        m_fTabStopsSet          :1,     // Have the tab stops been set up???
                        m_fBodyContainsFrames   :1,     // Was previously m_fReadOnlyBody
                        m_fOriginallyWasRead    :1,     // Initial NoteAction was OENA_READ
                        m_fCBDestroyWindow      :1,     // Destroy window after callback complete
                        m_fCBCopy               :1,     // Used during callback complete to tell if copied or moved.
                        m_fFlagged              :1,     // Is message flagged
                        m_fFullHeaders          :1,     // Show full headers
                        m_fWindowDisabled       :1,     // Is the window disabled? 
                        m_fProgress             :1,
                        m_fOrgCmdWasDelete      :1,     // Delete from callback wasn't originally a save or move/copy
                        m_fCommitSave           :1,     // Used to say that when you save, you should call commit
                        m_fOnDocReadyHandled    :1,     // Used in the OnDocumentReady function.
                        m_fUseReplyHeaders      :1,     // Use reply headers
                        m_fHasBeenSaved         :1,     // Is this a message that has been saved (ie ID_SAVE)
                        m_fInternal             :1,     // used to enable/disable thread windows
                        m_fSecurityLabel        :1,     // used for security labels
                        m_fSecReceiptRequest    :1,     // used for security receipt request
                        m_fPreventConflictDlg   :1,     // make sure we only show charset conflictdlg once per save
                        m_fForceClose           :1;     // used when forcing a destory

    RECT                m_rcRebar;
    CBands             *m_pToolbarObj;
    HWND                m_hwndRebar;
    HMENU               m_hMenu;
    HWNDLIST            m_hlDisabled;
    DWORD               m_dwRequestMDNLocked;
#ifdef SMIME_V3
    PSMIME_SECURITY_LABEL m_pLabel;
#endif // SMIME_V3
};

BOOL Note_Init(BOOL);
HRESULT CreateOENote(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateAndShowNote(DWORD dwAction, DWORD dwCreateFlags, INIT_MSGSITE_STRUCT *pInitStruct, 
                          HWND hwnd = 0, IUnknown *punk = NULL, RECT *prc = NULL, IOEMsgSite *pMsgSite = NULL);

void SetTlsGlobalActiveNote(CNote* pNote);
CNote* GetTlsGlobalActiveNote(void);
void InitTlsActiveNote();
void DeInitTlsActiveNote();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\msgsite.cpp ===
#include "pch.hxx"
#include "msgsite.h"
#include "secutil.h"
#include "mailutil.h"
#include "conman.h"
#include "newfldr.h"
#include "storutil.h"
#include "msoeobj.h"
#include "regutil.h"
#include "mapiutil.h"
#include "browser.h"
#include "receipts.h"
#include "shlwapip.h"
#include "msoert.h"

// ****************************************
COEMsgSite::COEMsgSite()
{
    m_pMsg = NULL; 
    m_pOrigMsg = NULL;
    m_pStoreCB = NULL;
    m_pMsgTable = NULL; 
    m_pListSelect = NULL;
    m_pCBMsgFolder = NULL;

    m_fCBCopy = FALSE;
    m_fCBSavedInDrafts = FALSE;
    m_fCBSaveInFolderAndDelOrig = FALSE;

    m_fGotNewID = FALSE;
    m_fHeaderOnly = FALSE;
    m_fValidMessage = FALSE;
    m_fNeedToLoadMsg = TRUE;
    m_fHaveCBMessageID = TRUE;
    m_fThreadingEnabled = FALSE;
    m_fReloadMessageFlag = TRUE;

    m_dwArfFlags = 0;
    m_dwMSAction = MSA_IDLE;
    m_dwCMFState = CMF_UNINITED;
    m_dwOrigFolderIsImap = OFIMAP_UNDEFINED;

    m_cRef = 1; 

    m_FolderID = FOLDERID_INVALID; 
    m_CBFolderID = FOLDERID_INVALID; 

    m_MessageID = 0;
    m_CBMessageID = 0;
    m_NewMessageID = 0;

    *m_rgwchFileName = 0;
    
    m_pFolderReleaseOnComplete = NULL;

    m_dwMDNFlags = 0;

    if (!!DwGetOption(OPT_MDN_SEND_REQUEST))
        m_dwMDNFlags |= MDN_REQUEST;

}

// ****************************************
COEMsgSite::~COEMsgSite()
{
    Assert(!m_pMsg);
    Assert(!m_pOrigMsg);
    Assert(!m_pMsgTable);
    Assert(!m_pStoreCB);
    Assert(!m_pListSelect);
    AssertSz(!m_pCBMsgFolder, "Who missed freeing this?");
    
    ReleaseObj(m_pFolderReleaseOnComplete);
}

// ****************************************
HRESULT COEMsgSite::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

// ****************************************
ULONG COEMsgSite::AddRef()
{
    return ++m_cRef;
}

// ****************************************
ULONG COEMsgSite::Release()
{
    if(--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// ****************************************
BOOL COEMsgSite::ThreadingEnabled(void)
{
    BOOL            fEnabled = FALSE;
    FOLDERSORTINFO  SortInfo;
    
    Assert(OEMSIT_MSG_TABLE == m_dwInitType);

    if (SUCCEEDED(m_pMsgTable->GetSortInfo(&SortInfo)))
        fEnabled = SortInfo.fThreaded;

    return fEnabled;
}

// ****************************************
HRESULT COEMsgSite::Init(INIT_MSGSITE_STRUCT *pInitStruct)
{
    // WARNING!!! pStoreCB will not have been setup by this point.
    // Use it in this function only if you are sure things will work.
    // For instance, the hwnd will not get setup yet so GetCallbackHwnd
    // will not work appropriatly.
    
    Assert(pInitStruct);

    HRESULT hr = S_OK;
    m_dwInitType = pInitStruct->dwInitType;
    m_fValidMessage = TRUE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        {
            Assert (m_pMsgTable==NULL);
            
            ReplaceInterface(m_pMsgTable, pInitStruct->initTable.pMsgTable);
            if (m_pMsgTable)
                m_pMsgTable->ConnectionAddRef();
            
            ReplaceInterface(m_pListSelect, pInitStruct->initTable.pListSelect);
            hr = m_pMsgTable->GetRowMessageId(pInitStruct->initTable.rowIndex, &m_MessageID);
            if (FAILED(hr))
                break;

            m_FolderID = pInitStruct->folderID;
            m_fThreadingEnabled = ThreadingEnabled();
            break;
        }

        case OEMSIT_STORE:
            AssertSz(FALSE, "Can't init using the store...");
            hr = E_UNEXPECTED;
            break;

        case OEMSIT_FAT:
            StrCpyW(m_rgwchFileName, pInitStruct->pwszFile);
            break;

        case OEMSIT_MSG:
            m_FolderID = pInitStruct->folderID;
            ReplaceInterface(m_pMsg, pInitStruct->pMsg);
            break;

        case OEMSIT_VIRGIN:
            m_FolderID = pInitStruct->folderID;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
    }

/* ~~~ Took this out of mailnote.cpp HrInit(pcni) code. How do we get this to work???
   ~~~ It is suppose to notify us if a folder has been deleted. In that case, we would
   ~~~ need to convert the msgSite to a msg based msgsite.
    if (m_pMsgTable)
        m_pMsgTable->Advise(GetCallbackHwnd());
    if (FAILED(hr = CreateNotify(&m_pFldrDelNotify)) ||
        FAILED(hr = m_pFldrDelNotify->Initialize((TCHAR *)c_szFolderDelNotify)) ||
        FAILED(hr = m_pFldrDelNotify->Register(GetCallbackHwnd(), g_hwndInit, FALSE)))
        goto error;
*/

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetStatusFlags(DWORD *pdwFlags)
{
    DWORD dwNewFlags = OEMSF_CAN_COPY | OEMSF_CAN_SAVE;

    if (!!(m_dwMDNFlags & MDN_REQUEST))
    {
        dwNewFlags |= OEMSF_MDN_REQUEST;
    }

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        case OEMSIT_STORE:
        {
            FOLDERTYPE folderType = GetFolderType(m_FolderID);
            dwNewFlags |= OEMSF_CAN_MARK | OEMSF_FROM_STORE;

            // GetMessageFlags is fairly intensive to be called as often as GetStatusFlags
            // is called. Since this flag really only matters at load time, we will only go
            // and get the value after a load from store. Otherwise, we will use the 
            // cached value from m_fSecUI.
            if (m_fReloadMessageFlag)
            {
                m_dwArfFlags = 0;

                GetMessageFlags(&m_dwArfFlags);
                m_fReloadMessageFlag = FALSE;
            }

            if (0 == (m_dwArfFlags & ARF_READ))
                dwNewFlags |= OEMSF_UNREAD;

            // If we came from a store and we are a new folder, then can't delete
            if (FOLDER_NEWS != folderType)
            {
                dwNewFlags |= OEMSF_CAN_MOVE;
                if (0 == (m_dwArfFlags & ARF_ENDANGERED))
                    dwNewFlags |= OEMSF_CAN_DELETE;

                if ((FOLDER_HTTPMAIL == folderType) || (FOLDER_IMAP == folderType))
                    dwNewFlags |= OEMSF_RULESNOTENABLED;
            }

            if (OEMSIT_MSG_TABLE == m_dwInitType)
            {
                dwNewFlags |= OEMSF_CAN_NEXT|OEMSF_CAN_PREV;

                if (m_fThreadingEnabled)
                    dwNewFlags |= OEMSF_THREADING_ENABLED;
            }

            if (m_dwArfFlags & ARF_UNSENT)
            {
                // If we are table based, need to do extra checking for IMAP message in find folder
                if (OEMSIT_MSG_TABLE == m_dwInitType)
                {
                    if (OFIMAP_UNDEFINED == m_dwOrigFolderIsImap)
                    {
                        FOLDERINFO  fi;
                        if (SUCCEEDED(g_pStore->GetFolderInfo(m_FolderID, &fi)))
                        {
                            // If is a find folder, check to see if message is IMAP
                            if (FOLDER_FINDRESULTS & (fi.dwFlags))
                            {
                                // Get original folder for this message (ie, not the find folder)
                                IMessageFolder *pMsgFolder = NULL;
                                if (SUCCEEDED(g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pMsgFolder)))
                                {
                                    // If original folder type is IMAP, then don't set unsent flag
                                    FOLDERID folderID;
                                    if (SUCCEEDED(pMsgFolder->GetMessageFolderId(m_MessageID, &folderID)))
                                    {
                                        FOLDERTYPE origFolderType = GetFolderType(folderID);
                                        if (FOLDER_IMAP != origFolderType)
                                        {
                                            m_dwOrigFolderIsImap = OFIMAP_FALSE;
                                            dwNewFlags |= OEMSF_UNSENT;
                                        }
                                        else
                                            m_dwOrigFolderIsImap = OFIMAP_TRUE;
                                    }
                                    pMsgFolder->Release();
                                }
                            }
                            else
                                dwNewFlags |= OEMSF_UNSENT;
                            g_pStore->FreeRecord(&fi);
                        }
                    }
                    else
                        if (OFIMAP_FALSE == m_dwOrigFolderIsImap)
                            dwNewFlags |= OEMSF_UNSENT;
                }
                else
                    dwNewFlags |= OEMSF_UNSENT;
            }

            if (0 == (m_dwArfFlags & ARF_NOSECUI))
                dwNewFlags |= OEMSF_SEC_UI_ENABLED;

            if (m_dwArfFlags & ARF_NEWSMSG)
                dwNewFlags |= OEMSF_BASEISNEWS;

            break;
        }

        case OEMSIT_FAT:
            {
                LPWSTR  pwszUnsent = NULL,
                        pwszExt = PathFindExtensionW(m_rgwchFileName);

                dwNewFlags |= OEMSF_CAN_DELETE | OEMSF_CAN_MOVE | OEMSF_SEC_UI_ENABLED;
                dwNewFlags |= OEMSF_FROM_FAT;

                if (SUCCEEDED(MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &pwszUnsent)))
                {
                    if (FALSE == FIsEmptyW(pwszUnsent))
                        dwNewFlags |= OEMSF_UNSENT;
                    SafeMemFree(pwszUnsent);
                }

                if (0 == StrCmpW(pwszExt, c_wszNwsExt))
                    dwNewFlags |= OEMSF_BASEISNEWS;
                break;
            }

        case OEMSIT_MSG:
            dwNewFlags |= OEMSF_FROM_MSG;
            break;

        case OEMSIT_VIRGIN:
            dwNewFlags |= OEMSF_VIRGIN | OEMSF_UNSENT;
            break;
    }

    *pdwFlags = dwNewFlags;
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::DeleteFromStore(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT hr;

    AssertSz(!m_pCBMsgFolder, "Someone forgot to release this baby.");

    Assert(m_pStoreCB);

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
    if (SUCCEEDED(hr))
    {
        MESSAGEIDLIST   list;
        FOLDERINFO      fi;

        list.cMsgs = 1;
        list.prgidMsg = &m_MessageID;

        hr = m_pCBMsgFolder->DeleteMessages(dwFlags, &list, NULL, m_pStoreCB);
        if (E_PENDING != hr)
            SafeRelease(m_pCBMsgFolder);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DeleteFromMsgTable(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT         hr;
    ROWINDEX        iRow = -1,
                    iNewRow = -1;

    AssertSz(m_pMsgTable, "How can you be OEMSIT_MSG_TABLE and not have a table");

    m_fGotNewID = FALSE;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
    if (FAILED(hr))
        goto Exit;

    if (SUCCEEDED(m_pMsgTable->GetNextRow(iRow, GETNEXT_NEXT, ROWMSG_ALL, 0, &iNewRow)) && 
                SUCCEEDED(m_pMsgTable->GetRowMessageId(iNewRow, &m_NewMessageID)))
        m_fGotNewID = TRUE;

    hr = m_pMsgTable->DeleteRows(dwFlags, 1, &iRow, FALSE, m_pStoreCB);
    if (FAILED(hr) && (E_PENDING != hr))
        AthMessageBoxW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::Delete(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT hr;

    m_dwMSAction = MSA_DELETE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
            hr = DeleteFromMsgTable(dwFlags);
            break;

        case OEMSIT_STORE:
            hr = DeleteFromStore(dwFlags);
            m_fValidMessage = FALSE;
            break;

        case OEMSIT_FAT:
            DeleteFileWrapW(m_rgwchFileName);
            m_fValidMessage = FALSE;
            m_dwMSAction = MSA_IDLE;
            break;

        // With these two, there is nothing to delete.
        case OEMSIT_MSG:
        case OEMSIT_VIRGIN:
            hr = S_OK;
            break;

        default:
            AssertSz(FALSE, "Weren't prepared to handle this initType");
            hr = E_UNEXPECTED;
            break;
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoNextPrev(BOOL fNext, DWORD dwFlags)
{
    HRESULT hr;
    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWMESSAGETYPE  tyMsg;
        ROWINDEX        iRow = 0,
                        iNewRow = 0;
        MESSAGEID       idNewMark;
        GETNEXTFLAGS    dwNextFlags = 0;
        GETNEXTTYPE     tyDir = fNext?GETNEXT_NEXT:GETNEXT_PREVIOUS;

        AssertSz(m_pMsgTable, "How can you be OEMSIT_MSG_TABLE and not have a table");

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (FAILED(hr))
            goto Exit;

        if (dwFlags&OENF_SKIPMAIL)
            tyMsg = ROWMSG_MAIL;
        else if (dwFlags&OENF_SKIPNEWS)
            tyMsg = ROWMSG_NEWS;
        else
            tyMsg = ROWMSG_ALL;

        if (dwFlags&OENF_UNREAD)
            dwNextFlags |= GETNEXT_UNREAD;

        if (dwFlags&OENF_THREAD)
            dwNextFlags |= GETNEXT_THREAD;

        hr = m_pMsgTable->GetNextRow(iRow, tyDir, tyMsg, dwNextFlags, &iNewRow);
        if (FAILED(hr))
            goto Exit;

        hr = m_pMsgTable->GetRowMessageId(iNewRow, &idNewMark);
        if (FAILED(hr))
            goto Exit;

        if (m_pListSelect)
            m_pListSelect->SetActiveRow(iNewRow);

        m_MessageID = idNewMark;
        m_fNeedToLoadMsg = TRUE;
    }
    else
        hr = E_UNEXPECTED;

Exit:
    AssertSz(E_PENDING != hr, "COEMsgSite::DoNextPrev not setup to handle E_PENDING.");
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromMsgToFldr(IMimeMessage *pMsg, BOOL fUnSent)
{
    HRESULT hr = E_UNEXPECTED;
    if (m_fCBCopy)
    {
        hr = m_pCBMsgFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, fUnSent?ARF_UNSENT:NOFLAGS, 0, pMsg, m_pStoreCB);

        if (SUCCEEDED(hr))
        {
            m_dwCMFState = CMF_MSG_TO_FOLDER;
            OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
        }
    }
    else
        AssertSz(FALSE, "Can't move a message based on a message. Only copy.");

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromStoreToFldr(BOOL fUnSent)
{
    HRESULT     hr;
    MESSAGEID   msgID = 0;

    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, m_pMsg, fUnSent?ARF_UNSENT:NOFLAGS, &msgID, TRUE);

    if (SUCCEEDED(hr))
    {
        m_dwCMFState = CMF_STORE_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromTableToFldr(void)
{
    HRESULT hr;
    IMessageFolder *pSrcFolder = NULL;
    MESSAGEIDLIST   rMsgIDList;
    LPMESSAGEINFO   pMsgInfo;
    ROWINDEX        iRow, iNewRow;
    MESSAGEID       msgID;
    FOLDERID        folderID = 0;

    Assert(m_pStoreCB);

    m_fGotNewID = FALSE;

    if (m_pFolderReleaseOnComplete != NULL)
        return E_FAIL;

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pSrcFolder);
    if (FAILED(hr))
        goto Exit;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
    if (FAILED(hr))
        goto Exit;
     
    // If we are moving, then we need to get the next item in the list
    if (!m_fCBCopy && SUCCEEDED(m_pMsgTable->GetNextRow(iRow, GETNEXT_NEXT, ROWMSG_ALL, 0, &iNewRow)) &&
                  SUCCEEDED(m_pMsgTable->GetRowMessageId(iNewRow, &m_NewMessageID)))
        m_fGotNewID = TRUE;

    hr = m_pMsgTable->GetRow(iRow, &pMsgInfo);
    if (FAILED(hr))
        goto Exit;
         
    msgID = pMsgInfo->idMessage;
    m_pMsgTable->ReleaseRow(pMsgInfo);

    rMsgIDList.cAllocated = 0;
    rMsgIDList.cMsgs = 1;
    rMsgIDList.prgidMsg = &msgID;

    if (SUCCEEDED(m_pCBMsgFolder->GetFolderId(&folderID)))
    {
        m_CBFolderID = folderID;
        m_CBMessageID = msgID;
    }
    else
    {
        m_CBFolderID = FOLDERID_INVALID;
        m_dwInitType = OEMSIT_MSG;
    }

    hr = pSrcFolder->CopyMessages(m_pCBMsgFolder, m_fCBCopy?0:COPY_MESSAGE_MOVE, &rMsgIDList, NULL, NULL, m_pStoreCB);
    if (SUCCEEDED(hr))
    {
        m_dwCMFState = CMF_TABLE_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    if (hr == E_PENDING)
    {
        ReplaceInterface(m_pFolderReleaseOnComplete, pSrcFolder);
        SafeRelease(pSrcFolder);
    }

Exit:
    ReleaseObj(pSrcFolder);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromFATToFldr(BOOL fUnSent)
{
    IMimeMessage *pMsg = NULL;
    HRESULT hr = S_OK;

    // Need original message, because m_pMsg is without security...
    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        return hr;

    hr = HrLoadMsgFromFileW(pMsg, m_rgwchFileName);

    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, pMsg, fUnSent?ARF_UNSENT:NOFLAGS, &m_CBMessageID, TRUE);
    if (SUCCEEDED(hr))
    {
        m_fHaveCBMessageID = TRUE;
        m_dwCMFState = CMF_FAT_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    SafeRelease(pMsg);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveToFolder(BOOL fCopy, IMimeMessage *pMsg, BOOL fUnSent)
{
    HRESULT hr;
    FOLDERID newFolderID;

    Assert(m_pStoreCB);

    AssertSz(NULL == m_pCBMsgFolder, "Someone forgot to release the folder");

    m_fCBCopy = fCopy;
    m_dwMSAction = MSA_COPYMOVE;

    hr = SelectFolderDialog(GetCallbackHwnd(), SFD_SELECTFOLDER, m_FolderID, 
                            FD_DISABLESERVERS | TREEVIEW_NONEWS | 
                            (m_fCBCopy?FD_COPYFLAGS:FD_MOVEFLAGS), 
                            MAKEINTRESOURCE(m_fCBCopy?idsCopy:idsMove),
                            MAKEINTRESOURCE(m_fCBCopy?idsCopyCaption:idsMoveCaption),
                            &newFolderID);

    // Only want to do the copy if:
    // 1- The new folder is not invalid
    // 2- Can open the needed folder
    if (SUCCEEDED(hr) && (newFolderID != FOLDERID_INVALID) && 
        SUCCEEDED(hr = g_pStore->OpenFolder(newFolderID, NULL, NOFLAGS, &m_pCBMsgFolder)))
    {
        if (pMsg)
            hr = DoCopyMoveFromMsgToFldr(pMsg, fUnSent);
        else
            switch (m_dwInitType)
            {
                case OEMSIT_MSG_TABLE:
                    hr = DoCopyMoveFromTableToFldr();
                    break;

                case OEMSIT_STORE:
                    hr = DoCopyMoveFromStoreToFldr(fUnSent);
                    break;

                case OEMSIT_FAT:
                    hr = DoCopyMoveFromFATToFldr(fUnSent);
                    break;

                case OEMSIT_VIRGIN:
                case OEMSIT_MSG:
                    hr = DoCopyMoveFromMsgToFldr(m_pMsg, fUnSent);
                    break;
            }
        if (E_PENDING != hr)
            SafeRelease(m_pCBMsgFolder);
    }

    if (FAILED(hr) && (E_PENDING != hr) && (hrUserCancel != hr))
        AthErrorMessageW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsCantSaveMsg), hr);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::Save(IMimeMessage *pMsg, DWORD dwFlags, IImnAccount *pAcct)
{
    HRESULT         hr;
    WORD            wMessageFlags = 0;
    ACCTTYPE        acctType = ACCT_MAIL;

    AssertSz(!m_pCBMsgFolder, "Someone forgot to release this baby.");

    m_fCBSaveInFolderAndDelOrig = !!(dwFlags & OESF_SAVE_IN_ORIG_FOLDER);
    m_fCBSavedInDrafts = FALSE;

    m_dwMSAction = MSA_SAVE;

    pAcct->GetAccountType(&acctType);
    if (ACCT_NEWS == acctType)
        wMessageFlags |= ARF_NEWSMSG;

    if (dwFlags & OESF_UNSENT)
        wMessageFlags |= ARF_UNSENT;
    if (dwFlags & OESF_READ)
        wMessageFlags |= ARF_READ;
    
    // Decide if want to save to drafts or some other folder
    if ((OEMSIT_MSG_TABLE == m_dwInitType) && m_fCBSaveInFolderAndDelOrig)
    {
        m_CBFolderID = m_FolderID;
        hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
    }
    else
    {
        FOLDERID    idStore;

        m_fCBSavedInDrafts = TRUE;

        // Find store ID of account in the header
        // If have problems getting the special folder on the server, then use
        // the local store drafts.
        if (dwFlags & OESF_FORCE_LOCAL_DRAFT)
            idStore = FOLDERID_LOCAL_STORE;
        else
        {
            IImnAccount *pSaveAcct = NULL;

            if (ACCT_NEWS == acctType)
                GetDefaultAccount(ACCT_MAIL, &pSaveAcct);
            else
                ReplaceInterface(pSaveAcct, pAcct);

            if (pSaveAcct)
            {
                DWORD dw = 0;
                CHAR szAcctId[CCHMAX_ACCOUNT_NAME];

                hr = pSaveAcct->GetPropSz(AP_ACCOUNT_ID, szAcctId, ARRAYSIZE(szAcctId));
                if (SUCCEEDED(hr))
                    hr = g_pStore->FindServerId(szAcctId, &idStore);

                pSaveAcct->Release();
            }
            else
                hr = E_FAIL;

            if (FAILED(hr))
                idStore = FOLDERID_LOCAL_STORE;
        }

        hr = g_pStore->OpenSpecialFolder(idStore, NULL, FOLDER_DRAFT, &m_pCBMsgFolder);

        // If failed opening special folder and we weren't trying local folders, try
        // using local folders now.
        if (FAILED(hr) && (idStore != FOLDERID_LOCAL_STORE))
            hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_DRAFT, &m_pCBMsgFolder);

        if (SUCCEEDED(hr))
        {
            m_CBFolderID = FOLDERID_INVALID;
            m_pCBMsgFolder->GetFolderId(&m_CBFolderID);
        }
    }

    if (FAILED(hr))
        goto Exit;

    m_CBMessageID = m_MessageID;

    // Save message to the folder
    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, pMsg, wMessageFlags, &m_CBMessageID, TRUE);
    if (SUCCEEDED(hr))
        m_fHaveCBMessageID = TRUE;
    else if (E_PENDING == hr)
    {
        ReplaceInterface(m_pMsg, pMsg);
        m_fHaveCBMessageID = FALSE;
    }

Exit:
    if (E_PENDING != hr)
        SafeRelease(m_pCBMsgFolder);
    if (FAILED(hr) && (hrUserCancel != hr) && (E_PENDING != hr))
    {
        int idsErr = ((MIME_E_URL_NOTFOUND == hr) ? idsErrSaveDownloadFail : idsCantSaveMsg);

        AthMessageBoxW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsCantSaveMsg), NULL, MB_OK);
    }
    return hr;
}

// ****************************************
// Use to split this function into one for news and one for mail. Don't think that 
// we need to do that anymore. If there is any difference, that should probably
// be moved into the message mangling phase. I can't see anything else that would
// be different.
#ifdef SMIME_V3
HRESULT COEMsgSite::SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail, IHeaderSite *pHeaderSite)
#else
HRESULT COEMsgSite::SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail)
#endif // SMIME_V3
{
    HRESULT         hr;

        // Figure out whether we need to request for MDNs. Doing it here skips processing it in smapi.
    if (fMail &&
        (!!(m_dwMDNFlags & MDN_REQUEST)) &&
        (!IsMDN(pMsg)))
    {
        LPWSTR pwsz = NULL;
       
        if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwsz)))
        {
            MimeOleSetBodyPropW(pMsg, HBODY_ROOT, STR_HDR_DISP_NOTIFICATION_TO, NOFLAGS, pwsz);
            
            MemFree(pwsz);
        }
    }

    // Account should already be setup in the message by this time.
    if (IsSecure(pMsg))
#ifdef SMIME_V3
        hr = SendSecureMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail, pHeaderSite);
#else
        hr = SendSecureMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail);
#endif // SMIME_V3        
    else
        hr = SendMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail);
    
    return hr;
}

// ****************************************
BOOL COEMsgSite::NeedToSendNews(IMimePropertySet *pPropSet)
{
    MIMEPROPINFO    mimePropInfo;

    AssertSz(pPropSet, "A property set needs to be passed in.");

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_FOLLOWUPTO), &mimePropInfo)))
        return TRUE;

    return FALSE;    
}

// ****************************************
BOOL COEMsgSite::NeedToSendMail(IMimePropertySet *pPropSet)
{
    MIMEPROPINFO    mimePropInfo;

    AssertSz(pPropSet, "A property set needs to be passed in.");

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_TO), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_CC), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_BCC), &mimePropInfo)))
        return TRUE;

    return FALSE;    
}

// ****************************************
HRESULT COEMsgSite::ClearHeaders(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    HRESULT hr = S_OK;

    for (ULONG i = 0; i < cNames; i++)
        pPropSet->DeleteProp(*prgszName++);

    return S_OK;
}

// ****************************************
#ifdef SMIME_V3
HRESULT COEMsgSite::SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate, IHeaderSite *pHeaderSite)
#else
HRESULT COEMsgSite::SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate)
#endif // SMIME_V3
{
    HRESULT             hr;
    BOOL                fSendMail, 
                        fSendNews,
                        fSendBoth;
    IMimePropertySet   *pPropSet = NULL,
                       *pTempPropSet = NULL;
    PROPVARIANT         var;
    IImnAccount        *pAccount = NULL;
    ACCTTYPE            acctType;
    IMimeMessage       *pTempMsg = NULL;

    LPCSTR  rgszMailOnlyHeaders[] =
            {   
                PIDTOSTR(PID_HDR_TO),
                PIDTOSTR(PID_HDR_CC),
                PIDTOSTR(PID_HDR_BCC),
                PIDTOSTR(PID_HDR_XPRI),
                PIDTOSTR(PID_HDR_XMSPRI),
                PIDTOSTR(PID_HDR_APPARTO),
                PIDTOSTR(PID_HDR_COMMENT),
                PIDTOSTR(PID_HDR_SENDER),
                PIDTOSTR(PID_HDR_XMAILER),
                PIDTOSTR(PID_HDR_RECEIVED),
                PIDTOSTR(PID_HDR_DISP_NOTIFICATION_TO)
            };
    LPCSTR  rgszNewsOnlyHeaders[] =
            {
                PIDTOSTR(PID_HDR_NEWSGROUPS),
                PIDTOSTR(PID_HDR_PATH),
                PIDTOSTR(PID_HDR_FOLLOWUPTO),
                PIDTOSTR(PID_HDR_EXPIRES),
                PIDTOSTR(PID_HDR_REFS),
                PIDTOSTR(PID_HDR_DISTRIB),
                PIDTOSTR(PID_HDR_ORG),
                PIDTOSTR(PID_HDR_KEYWORDS),
                PIDTOSTR(PID_HDR_SUMMARY),
                PIDTOSTR(PID_HDR_APPROVED),
                PIDTOSTR(PID_HDR_LINES),
                PIDTOSTR(PID_HDR_XREF),
                PIDTOSTR(PID_HDR_CONTROL)
            };          

//  Common headers between mail and news that can be left where they are
//  PID_HDR_FROM     PID_HDR_DATE     PID_HDR_SUBJECT  PID_HDR_MESSAGEID
//  PID_HDR_REPLYTO  PID_HDR_CNTTYPE  PID_HDR_CNTXFER  PID_HDR_CNTDESC  
//  PID_HDR_CNTDISP  PID_HDR_CNTBASE  PID_HDR_CNTLOC   PID_HDR_CNTID    
//  PID_HDR_MIMEVER  PID_HDR_ENCODING PID_HDR_ENCRYPTED

    m_dwMSAction = MSA_SEND;

    hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropSet);
    if(FAILED(hr))
        return hr;

    fSendMail = NeedToSendMail(pPropSet);
    fSendNews = NeedToSendNews(pPropSet);
    fSendBoth = fSendMail && fSendNews;

    if((!fSendMail) && (!fSendNews))
    {
        hr = hrNoRecipients;
        goto Exit;
    }

    var.vt = VT_LPSTR;
    hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
    if (FAILED(hr))
        goto Exit;

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAccount);
    if (FAILED(hr))
        goto Exit;

    hr = pAccount->GetAccountType(&acctType);
    if (FAILED(hr))
        goto Exit;

    if (fSendBoth)
    {
        hr = HrDupeMsg(pMsg, &pTempMsg);
        if (FAILED(hr))
            goto Exit;

        hr = pTempMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pTempPropSet);
        if(FAILED(hr))
            return hr;

        hr = ClearHeaders(ARRAYSIZE(rgszMailOnlyHeaders), rgszMailOnlyHeaders, pPropSet);
        if (FAILED(hr))
            goto Exit;

        hr = ClearHeaders(ARRAYSIZE(rgszNewsOnlyHeaders), rgszNewsOnlyHeaders, pTempPropSet);
        if (FAILED(hr))
            goto Exit;
    }

    // If going to do both news and mail, then must send news first. The spooler will
    // block and say it is busy if we send mail first. If we send mail second, then
    // the spooler has a special flag that says when you are done being busy, send
    // any mail that you have in your outbox.
    if (fSendNews)
    {
        if (ACCT_MAIL == acctType)
        {
            IImnAccount *pTempAccount = NULL;
            if (SUCCEEDED(GetDefaultAccount(ACCT_NEWS, &pTempAccount)))
            {
                HrSetAccountByAccount(pMsg, pTempAccount);
                pTempAccount->Release();
            }
        }

#ifdef SMIME_V3
        hr = SendMsg(pMsg, fSendImmediate, FALSE, pHeaderSite);
#else
        hr = SendMsg(pMsg, fSendImmediate, FALSE);
#endif // SMIME_V3
        if (FAILED(hr) && (E_PENDING != hr))
            goto Exit;

        // Tell the user this is being sent to the server but might not appear
        // right away.
        if (fSendImmediate && !g_pConMan->IsGlobalOffline())
            DoDontShowMeAgainDlg(GetCallbackHwnd(), c_szDSSendNews,
                                MAKEINTRESOURCE(idsPostNews),
                                MAKEINTRESOURCE(idsPostSentToServer),
                                MB_OK);
        if (fSendBoth)
            pMsg = pTempMsg;
    }

    if (fSendMail)
    {
        if (ACCT_NEWS == acctType)
        {
            //If we are not the smapi client forward it to whoever it is.
            if (!FIsDefaultMailConfiged())
            {
                hr = NewsUtil_ReFwdByMapi(GetCallbackHwnd(), pMsg, MSGTYPE_CC);
                goto Exit;
            }

            IImnAccount *pTempAccount = NULL;
            if (SUCCEEDED(GetDefaultAccount(ACCT_MAIL, &pTempAccount)))
            {
                HrSetAccountByAccount(pMsg, pTempAccount);
                pTempAccount->Release();
            }
        }

#ifdef SMIME_V3
        hr = SendMsg(pMsg, fSendImmediate, TRUE, pHeaderSite);
#else
        hr = SendMsg(pMsg, fSendImmediate, TRUE);
#endif // SMIME_V3
    }


Exit:
    SafeMemFree(var.pszVal);
    ReleaseObj(pAccount);
    ReleaseObj(pPropSet);
    ReleaseObj(pTempPropSet);
    ReleaseObj(pTempMsg);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetLocation(LPWSTR rgwchLocation)
{
    FOLDERINFO  fi;
    LPWSTR      pwszName = NULL;
    HRESULT     hr = S_OK;
    BOOL        fFreeFolder = FALSE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        case OEMSIT_STORE:
            if (SUCCEEDED(g_pStore->GetFolderInfo(m_FolderID, &fi)))
            {
                Assert(fi.pszName);
                fFreeFolder = TRUE;

                IF_NULLEXIT(pwszName = PszToUnicode(CP_ACP, fi.pszName));

                StrCpyW(rgwchLocation, pwszName);
            }
            else
                *rgwchLocation = 0;
            break;

        case OEMSIT_FAT:
            StrCpyW(rgwchLocation, m_rgwchFileName);
            break;

        case OEMSIT_MSG:
        case OEMSIT_VIRGIN:
            *rgwchLocation = 0;
            break;
    }

exit:
    if (fFreeFolder)
        g_pStore->FreeRecord(&fi);

    MemFree(pwszName);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::MarkMessage(MARK_TYPE dwType, APPLYCHILDRENTYPE dwApplyType)
{
    HRESULT hr = E_FAIL;
    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWINDEX iRow = 0;

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (SUCCEEDED(hr))
            hr = m_pMsgTable->Mark(&iRow, 1, dwApplyType, dwType, m_pStoreCB);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetMessageFlags(MESSAGEFLAGS *pdwFlags)
{
    HRESULT hr = S_OK;

    *pdwFlags = 0;

    if (!m_pMsgTable)
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWINDEX iRow = 0;
        LPMESSAGEINFO pMsgInfo;

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (FAILED(hr))
            goto Exit;

        hr = m_pMsgTable->GetRow(iRow, &pMsgInfo); 
        if (FAILED(hr))
            goto Exit;
        
        *pdwFlags = pMsgInfo->dwFlags;
        m_pMsgTable->ReleaseRow(pMsgInfo);
    }

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetDefaultAccount(ACCTTYPE acctType, IImnAccount **ppAcct)
{
    HRESULT         hr = E_FAIL,
                    hr2;
    LPMESSAGEINFO   pMsgInfo = NULL;
    ROWINDEX        iRow;
    DWORD           dwFlags = 0;

    Assert(ppAcct);

    if(OEMSIT_MSG_TABLE == m_dwInitType)
    {
        if (ACCT_MAIL == acctType)
        {
            IF_FAILEXIT(GetMessageFlags(&dwFlags));
            if (!!(dwFlags & ARF_NEWSMSG))
                goto exit;
        }
        IF_FAILEXIT(hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow));
        IF_FAILEXIT(hr = m_pMsgTable->GetRow(iRow, &pMsgInfo));
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, ppAcct));  
    }

exit:
    if(FAILED(hr))
        hr = g_pAcctMan->GetDefaultAccount(acctType, ppAcct);

    if(pMsgInfo)
    {
        // We don't want to mask hr, so we'll just test an alternative HRESULT
        hr2 = m_pMsgTable->ReleaseRow(pMsgInfo);

        if(FAILED(hr2))
            TraceResult(hr2);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromStore(void)
{
    HRESULT hr;
    IMessageFolder *pMsgFolder = NULL;

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pMsgFolder);
    if (SUCCEEDED(hr))
    {
        IMimeMessage *pMsg = NULL;
        //Can only get into this state in a drafts message, so don't need worry about security
        hr = pMsgFolder->OpenMessage(m_MessageID, 0/* OPEN_MESSAGE_SECURE*/, &pMsg, NULL);
        if (SUCCEEDED(hr))
        {
            ReplaceInterface(m_pMsg, pMsg);
            pMsg->Release();
        }
        pMsgFolder->Release();
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromRow(IMimeMessage **ppMsg, ROWINDEX row)
{
    HRESULT         hr;
    LPMESSAGEINFO   pInfo;

    AssertSz(!(*ppMsg), "We create a message in this function.");

    hr = m_pMsgTable->GetRow(row, &pInfo);
    if (SUCCEEDED(hr))
    {
        m_dwMSAction = MSA_GET_MESSAGE;

        hr = CreateMessageFromInfo(pInfo, ppMsg, m_FolderID);
        m_fHeaderOnly = TRUE;

        // now we wait until the message has downloaded and reload in
        // OnComplete
        m_pMsgTable->ReleaseRow(pInfo);
    }
    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromTable(BOOL fGetOriginal, HRESULT *phr)
{
    IMimeMessage   *pMsg = NULL;
    BOOL            fOffline=FALSE;
    ROWINDEX        rowIndex = 0;
    HRESULT         hr,
                    tempHr = S_OK;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &rowIndex);
    if (FAILED(hr))
        goto Exit;
        
    m_fHeaderOnly = FALSE;
    hr = m_pMsgTable->OpenMessage(rowIndex, (fGetOriginal ? OPEN_MESSAGE_SECURE : 0), &pMsg, m_pStoreCB);
    if (FAILED(hr) || hr == STORE_S_ALREADYPENDING)
    {
        tempHr = hr;
        hr = LoadMessageFromRow(&pMsg, rowIndex);

        if (SUCCEEDED(hr))
        {
            switch (tempHr)
            {
                case E_NOT_ONLINE:
                    hr = HR_S_OFFLINE;
                    break;

                case STORE_S_ALREADYPENDING:
                case E_PENDING:
                {
                    LPMESSAGEINFO pmiMsgInfo;

                    // Save the MsgID of msg we're trying to load. This way if user quickly loads
                    // several msgs into note, we won't re-enter MSA_IDLE until the desired msg loads
                    if (SUCCEEDED(m_pMsgTable->GetRow(rowIndex, &pmiMsgInfo)))
                    {
                        m_MessageID = pmiMsgInfo->idMessage;
                        m_pMsgTable->ReleaseRow(pmiMsgInfo);
                    }
                    else
                        m_MessageID = 0; // This means show the next msg we get!

                    tempHr = S_OK;
                    break;
                }
            }
        }

        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        m_dwArfFlags = 0;
        GetMessageFlags(&m_dwArfFlags);
    }

    *phr = tempHr;
    ReplaceInterface(m_pMsg, pMsg);

Exit:
    ReleaseObj(pMsg);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromFAT(BOOL fGetOriginal, HRESULT *phr)
{
    IMimeMessage *pMsg = NULL;
    HRESULT hr;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        return hr;

    //bobn: We need to make sure we know the default charset
    HGetDefaultCharset(NULL);

    hr = HrLoadMsgFromFileW(pMsg, m_rgwchFileName);
    if (SUCCEEDED(hr))
    {
        if(!fGetOriginal)
            *phr = HandleSecurity(NULL, pMsg);

        //if (SUCCEEDED(hr))
            ReplaceInterface(m_pMsg, pMsg);
    }

    SafeRelease(pMsg);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetFolderID(FOLDERID *folderID)
{
    Assert(folderID);
    *folderID = m_FolderID;
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SetAccountInfo(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    PROPVARIANT     var;

    // Check to see if need an account in the message.
    var.vt = VT_LPSTR;
    if (FAILED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)) || !(var.pszVal))
    {
        if (FOLDERID_INVALID != m_FolderID)
        {
            hr = g_pStore->GetFolderInfo(m_FolderID, &fi);
            if (SUCCEEDED(hr))
            {
                // Set account based upon the folder ID passed down
                if (FOLDER_LOCAL != fi.tyFolder)
                {
                    char szAcctId[CCHMAX_ACCOUNT_NAME];
                    IImnAccount *pAcct = NULL;

                    if (SUCCEEDED(GetFolderAccountId(&fi, szAcctId)) && SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctId, &pAcct)))
                    {
                        HrSetAccountByAccount(m_pMsg, pAcct);
                        pAcct->Release();
                    }

                    // If not a server node, set the newgroup
                    if ((FOLDER_NEWS == fi.tyFolder) && (0 == (FOLDER_SERVER & fi.dwFlags)))
                        hr = MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);
                }
                g_pStore->FreeRecord(&fi);
            }
        }
    }
    else
        SafeMemFree(var.pszVal);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::CreateMsgWithAccountInfo(void)
{
    HRESULT     hr;

    SafeRelease(m_pMsg);
    hr = HrCreateMessage(&m_pMsg);
    if (SUCCEEDED(hr))
    {
        if(g_hDefaultCharsetForMail)
            m_pMsg->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
        hr = SetAccountInfo();
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetMessage(IMimeMessage **ppMsg, BOOL *pfCompleteMsg, DWORD dwMessageFlags, HRESULT *phr)
{
    HRESULT hr = S_OK;
    BOOL    fGetOriginal = (OEGM_ORIGINAL & dwMessageFlags);

    if (!m_fValidMessage)
        return E_FAIL;

    *phr = S_OK;
    if (m_fNeedToLoadMsg || fGetOriginal)
    {
        switch (m_dwInitType)
        {
            case OEMSIT_MSG_TABLE:
                hr = LoadMessageFromTable(fGetOriginal, phr);
                break;

            case OEMSIT_STORE:
                hr = LoadMessageFromStore();
                break;

            case OEMSIT_FAT:
                hr = LoadMessageFromFAT(fGetOriginal, phr);
                break;

            case OEMSIT_MSG:
                hr = SetAccountInfo();
                break;

            case OEMSIT_VIRGIN:
                hr = CreateMsgWithAccountInfo();
                break;
        }
        m_fNeedToLoadMsg = FALSE;
    }

    if (SUCCEEDED(hr) && !m_fHeaderOnly && (OEGM_AS_ATTACH &dwMessageFlags))
    {
        IMimeMessage   *pMsgFwd = NULL;
        PROPVARIANT     var;

        hr = HrCreateMessage(&pMsgFwd);

        if (SUCCEEDED(hr))            
            hr = pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)m_pMsg, NULL);

        var.vt = VT_LPSTR;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
        {
            pMsgFwd->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
        }

        if (SUCCEEDED(hr))
        {
            ReplaceInterface(m_pMsg, pMsgFwd);
            pMsgFwd->Release();
            m_dwInitType = OEMSIT_MSG;
        }
    }

    if (fGetOriginal)
        m_fReloadMessageFlag = TRUE;

    if (SUCCEEDED(hr))
    {
        ReplaceInterface((*ppMsg), m_pMsg);
        *pfCompleteMsg = !m_fHeaderOnly;

        m_fNeedToLoadMsg = !!m_fHeaderOnly;

        if (!m_pMsg)
            hr = E_FAIL;
    }

    return hr;
}

// *************************
BOOL COEMsgSite::FCanConnect()
{
    IImnAccount    *pAcct = NULL;
    HRESULT         hr;
    BOOL            fRet = TRUE;

    hr = GetDefaultAccount(ACCT_MAIL, &pAcct);
    if (SUCCEEDED(hr))
    {
        hr = g_pConMan->CanConnect(pAcct);
        pAcct->Release();
    }

    fRet = (S_OK == hr);

    return(fRet);
}

// ****************************************
HWND COEMsgSite::GetCallbackHwnd()
{
    HWND hwnd;

    Assert(m_pStoreCB);
    if (SUCCEEDED(m_pStoreCB->GetParentWindow(0, &hwnd)))
        return hwnd;
    return 0;
}

// ****************************************
HRESULT COEMsgSite::Close(void)
{
    SafeRelease(m_pMsg);
    SafeRelease(m_pOrigMsg);

    if (m_pMsgTable)
    {
        m_pMsgTable->ConnectionRelease();
        m_pMsgTable->Release();
        m_pMsgTable = NULL;
    }

    SafeRelease(m_pStoreCB);
    SafeRelease(m_pListSelect);
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SetStoreCallback(IStoreCallback *pStoreCB)
{
    ReplaceInterface(m_pStoreCB, pStoreCB);
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SwitchLanguage(HCHARSET hOldCharset, HCHARSET hNewCharset)
{
    DWORD           dwCodePage = 0;
    INETCSETINFO    CsetInfo;
    BOOL            fSaveLang = TRUE;
    ROWINDEX        iRow = 0;
    HRESULT         hr = S_OK;

    if (OEMSIT_MSG_TABLE != m_dwInitType)
        goto Exit;
       
    if (FAILED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
        goto Exit;
        
#if 0
    if (SUCCEEDED(m_pMsgTable->GetLanguage(iRow, &dwCodePage)))
    {
        DWORD dwFlag ;

        m_pMsg->GetFlags(&dwFlag);

        // for tagged message only
        if ((dwFlag & IMF_CSETTAGGED) && !dwCodePage )
            fSaveLang = TRUE; // was !IntlCharsetMapLanguageCheck(hOldCharset, hNewCharset); We have
    }
#endif

    // save language change to message store
    if (fSaveLang)
    {
        MimeOleGetCharsetInfo(hNewCharset, &CsetInfo);
        dwCodePage = CsetInfo.cpiInternet;

        // Get index again incase user changed row during dialog
        if (FAILED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
            goto Exit;

        hr = m_pMsgTable->SetLanguage(1, &iRow, dwCodePage);
        if (FAILED(hr))
            AthMessageBoxW(  GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthena), 
                            MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                            NULL, MB_OK|MB_ICONEXCLAMATION);
    }

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, STOREOPERATIONTYPE *ptyNewOp)
{
    // Action wasn't inited in MsgSite
    if (MSA_IDLE == m_dwMSAction)
        return S_OK;

    if (ptyNewOp)
        *ptyNewOp = SOT_INVALID;

    switch (tyOperation)
    {
        case SOT_GET_MESSAGE:
            HandleGetMessage(hrComplete);
            break;

        case SOT_DELETING_MESSAGES:
            HandleDelete(hrComplete);
            break;

        case SOT_PUT_MESSAGE:
            HandlePut(hrComplete, ptyNewOp);
            break;

        case SOT_COPYMOVE_MESSAGE:
            HandleCopyMove(hrComplete);
            SafeRelease(m_pFolderReleaseOnComplete);
            break;

#ifdef DEBUG
        default:
            AssertSz(!m_pCBMsgFolder, "How did we get here with a CBMsgFolder");
#endif
    }

    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::UpdateCallbackInfo(LPSTOREOPERATIONINFO pOpInfo)
{
    if (pOpInfo->idMessage != MESSAGEID_INVALID)
    {
        m_fHaveCBMessageID = TRUE;
        m_CBMessageID = pOpInfo->idMessage;
    }
    return S_OK;
}

// ****************************************
// Need to handle MSA_SAVE, MSA_SEND, MSA_COPYMOVE
void COEMsgSite::HandlePut(HRESULT hr, STOREOPERATIONTYPE *ptyNewOp)
{
    // If is COPYMOVE, simply redirect to proper function
    if (MSA_COPYMOVE == m_dwMSAction)
    {
        HandleCopyMove(hr);
        if (ptyNewOp)
            *ptyNewOp = SOT_PUT_MESSAGE;
        return;
    }

    SafeRelease(m_pCBMsgFolder);
    if (FAILED(hr))
        goto Exit;

    switch (m_dwMSAction)
    {
        case MSA_SAVE:
        {
            // Decide whether need to delete old message or not
            switch (m_dwInitType)
            {
                case OEMSIT_MSG_TABLE:
                {
                    if (m_fCBSaveInFolderAndDelOrig)
                    {
                        ROWINDEX iRow = 0;
                        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
                        if (SUCCEEDED(hr))
                            hr = m_pMsgTable->DeleteRows(
                                    DELETE_MESSAGE_NOTRASHCAN | 
                                    DELETE_MESSAGE_NOPROMPT | 
                                    DELETE_MESSAGE_MAYIGNORENOTRASH,
                                    1, &iRow, FALSE, m_pStoreCB);
                        if (SUCCEEDED(hr))
                            OnComplete(SOT_DELETING_MESSAGES, S_OK);
                        else if ((E_PENDING == hr) && ptyNewOp)
                            *ptyNewOp = SOT_DELETING_MESSAGES;
                    }
                    else
                    {

                        m_dwInitType = OEMSIT_STORE;
                        m_fThreadingEnabled = FALSE;
                        m_FolderID = m_CBFolderID;
                    }
                    m_MessageID = m_CBMessageID;
                    if (!m_fHaveCBMessageID)
                    {
                        m_dwInitType = OEMSIT_MSG;
                    }
                    break;
                }

                // Always delete since our message was in drafts and is being saved to drafts
                case OEMSIT_STORE:
                {
                    hr = DeleteFromStore(
                            DELETE_MESSAGE_NOTRASHCAN | 
                            DELETE_MESSAGE_NOPROMPT | 
                            DELETE_MESSAGE_MAYIGNORENOTRASH);
                    if ((E_PENDING == hr) && ptyNewOp)
                        *ptyNewOp = SOT_DELETING_MESSAGES;
                    else if (SUCCEEDED(hr))
                        OnComplete(SOT_DELETING_MESSAGES, S_OK);
                    break;
                }

                case OEMSIT_FAT:
                case OEMSIT_MSG:
                case OEMSIT_VIRGIN:
                    // This folder id should always be drafts.
                    m_FolderID = m_CBFolderID;
                    if ((FOLDERID_INVALID != m_FolderID) && m_fHaveCBMessageID)
                    {
                        m_MessageID = m_CBMessageID;
                        m_dwInitType = OEMSIT_STORE;
                        m_fThreadingEnabled = FALSE;
                    }
                    else
                        m_dwInitType = OEMSIT_MSG;

                    break;
            }
            if (m_fCBSavedInDrafts)
                DoDontShowMeAgainDlg(GetCallbackHwnd(), c_szDSSavedInSavedItems, 
                            MAKEINTRESOURCE(idsSavedMessage), 
                            MAKEINTRESOURCE(idsSavedInDrafts), 
                            MB_OK);

            break;
        }

        // Don't do anything with send. Just be happy that it worked.
        case MSA_SEND:
            break;

        default:
            AssertSz(FALSE, "Didn't expect to get PUT with other MsgSite action.");
    }


Exit:
    if (hr != E_PENDING)
        m_dwMSAction = MSA_IDLE;
}

void COEMsgSite::HandleGetMessage(HRESULT hr)
{
    if (SUCCEEDED(hr))
    {
        HRESULT tempHr;
        LoadMessageFromTable(TRUE, &tempHr);
        AssertSz(SUCCEEDED(tempHr), "If hr succeeded, tempHr should have as well.");

        m_fHeaderOnly = FALSE;
        Notify(OEMSN_UPDATE_PREVIEW);
        SetFocus(GetCallbackHwnd());
    }

    // Success or failure, we've loaded the target msg. Go to idle
    m_dwMSAction = MSA_IDLE;
}

HRESULT COEMsgSite::Notify(DWORD dwNotifyID)
{
    HRESULT     hr = S_OK;

    switch (dwNotifyID)
    {
        case OEMSN_UPDATE_PREVIEW:
        {
            if ((OEMSIT_MSG_TABLE == m_dwInitType) && (0 != m_MessageID))
            {
                ROWINDEX iRow = 0;
                if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                    m_pListSelect->SetActiveRow(iRow);
            }
            break;
        }

        case OEMSN_TOGGLE_READRCPT_REQ:
        {
            if (!!(m_dwMDNFlags & MDN_REQUEST))
            {
                m_dwMDNFlags = m_dwMDNFlags & (~MDN_REQUEST);
            }
            else
            {
                m_dwMDNFlags |= MDN_REQUEST;
            }
            break;
        }

        case OEMSN_PROCESS_READRCPT_REQ:
        {
            ROWINDEX    rowIndex = 0;

            if ((OEMSIT_MSG_TABLE == m_dwInitType) && (0 != m_MessageID))
            {

                IF_FAILEXIT(hr = m_pMsgTable->GetRowIndex(m_MessageID, &rowIndex));

                if (!(m_dwArfFlags & ARF_READ))
                {
                    IF_FAILEXIT(hr = ProcessReturnReceipts(m_pMsgTable, m_pStoreCB, rowIndex, READRECEIPT, m_FolderID, m_pMsg));
                }
            }
            break;
        }
    }

exit:

    return hr;
}

// ****************************************
// Need to handle MSA_DELETE, MSA_COPYMOVE, and MSA_SAVE
void COEMsgSite::HandleDelete(HRESULT hr)
{
    AssertSz((MSA_DELETE == m_dwMSAction) || (MSA_COPYMOVE == m_dwMSAction) || (MSA_SAVE == m_dwMSAction), 
                "Didn't expect to get DELETE with other MsgSite action.");

    SafeRelease(m_pCBMsgFolder);

    // If came from COPYMOVE, then don't do anything here.
    if (FAILED(hr))
        goto exit;

    if (MSA_COPYMOVE == m_dwMSAction)
    {
        m_FolderID = m_CBFolderID;
        m_MessageID = m_CBMessageID;
    }
    else if (MSA_SAVE == m_dwMSAction)
    {
        m_FolderID = m_CBFolderID;
        m_MessageID = m_CBMessageID;
        if (m_pListSelect && (OEMSIT_MSG_TABLE == m_dwInitType))
        {
            ROWINDEX iRow = 0;
            if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                m_pListSelect->SetActiveRow(iRow);
        }
    }

    // Then this must be a straight delete
    else
        switch (m_dwInitType)
        {
            case OEMSIT_MSG_TABLE:
                if (m_fGotNewID)
                {
                    m_MessageID = m_NewMessageID;
                    m_fNeedToLoadMsg = TRUE;
                    if (m_pListSelect)
                    {
                        ROWINDEX iRow = 0;
                        if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                            m_pListSelect->SetActiveRow(iRow);
                    }
                }
                else
                {
                    m_fValidMessage = FALSE;
                }
                break;

            // Do nothing if from store
            case OEMSIT_STORE:
                break;

        }

exit:
    
    // If doing copy move, I expect SOT_DELETING_MESSAGES to be called before SOT_COPYMOVE_MESSAGE
    m_dwMSAction = MSA_IDLE;
}

// ****************************************
// Need to handle MSA_COPYMOVE
void COEMsgSite::HandleCopyMove(HRESULT hr)
{

    AssertSz(MSA_COPYMOVE == m_dwMSAction, "Didn't expect to get COPYMOVE with other MsgSite action.");

    SafeRelease(m_pCBMsgFolder);

    if (FAILED(hr) || m_fCBCopy)
        goto Exit;

    switch (m_dwCMFState)
    {
        case CMF_MSG_TO_FOLDER:
            // Don't need to worry about anything
            break;

        case CMF_TABLE_TO_FOLDER:
        {
            // If we are moving and there is a valid bookmark to go to, then set up the note to have the next message
            if (m_fGotNewID)
            {
                m_MessageID = m_NewMessageID;
                m_fNeedToLoadMsg = TRUE;
            }
            else
                m_fValidMessage = FALSE;
            break;
        }

        case CMF_STORE_TO_FOLDER:
        {
            FOLDERID        folderID;
            MESSAGEIDLIST   rMsgIDList;

            Assert(m_pStoreCB);

            rMsgIDList.cAllocated = 0;
            rMsgIDList.cMsgs = 1;
            rMsgIDList.prgidMsg = &m_MessageID;
            hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
            if (FAILED(hr))
                goto Exit;

            // Don't really care if this works.
            hr = m_pCBMsgFolder->DeleteMessages(
                        DELETE_MESSAGE_NOTRASHCAN | 
                        DELETE_MESSAGE_NOPROMPT |
                        DELETE_MESSAGE_MAYIGNORENOTRASH, 
                        &rMsgIDList, NULL, m_pStoreCB);
            AssertSz(E_PENDING != hr, "Didn't expect E_PENDING here.")
            if (SUCCEEDED(hr))
                OnComplete(SOT_DELETING_MESSAGES, S_OK);

            break;
        }

        case CMF_FAT_TO_FOLDER:
        {
            DeleteFileWrapW(m_rgwchFileName);

            // Need to shut down the note.
            m_fValidMessage = FALSE;
            break;
        }
    }

Exit:
    // I expect SOT_DELETING_MESSAGES to be called before SOT_COPYMOVE_MESSAGE
    m_dwMSAction = MSA_IDLE;
    m_dwCMFState = CMF_UNINITED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\msgsite.h ===
#ifndef _MSGSITE_H
#define _MSGSITE_H

#include "imsgsite.h"

// Current MsgSite Action
// These are the only ones that the msg site worries about.
enum {
    MSA_IDLE = 0,
    MSA_DELETE,
    MSA_COPYMOVE,
    MSA_SAVE,
    MSA_SEND,
    MSA_GET_MESSAGE
};

// CopyMove function used
enum {
    CMF_UNINITED = 0,
    CMF_MSG_TO_FOLDER,
    CMF_TABLE_TO_FOLDER,
    CMF_STORE_TO_FOLDER,
    CMF_FAT_TO_FOLDER,
};

// Original Folder is IMAP state
enum {
    OFIMAP_UNDEFINED = 0,
    OFIMAP_TRUE,
    OFIMAP_FALSE,
};


class COEMsgSite : public IOEMsgSite {
public:

    COEMsgSite();
    ~COEMsgSite();

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IMsgSite Methods
    virtual HRESULT STDMETHODCALLTYPE Init(INIT_MSGSITE_STRUCT *pInitStruct);
    virtual HRESULT STDMETHODCALLTYPE GetStatusFlags(DWORD *dwflags);
    virtual HRESULT STDMETHODCALLTYPE GetFolderID(FOLDERID *folderID);
    virtual HRESULT STDMETHODCALLTYPE Delete(DELETEMESSAGEFLAGS dwFlags);
    virtual HRESULT STDMETHODCALLTYPE DoNextPrev(BOOL fNext, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE DoCopyMoveToFolder(BOOL fCopy, IMimeMessage *pMsg, BOOL fUnSent);
    virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwflags, IImnAccount *pAcct);

#ifdef SMIME_V3
    virtual HRESULT STDMETHODCALLTYPE SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate, IHeaderSite *pHeaderSite);
#else
    virtual HRESULT STDMETHODCALLTYPE SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate);
#endif // SMIME_V3

    virtual HRESULT STDMETHODCALLTYPE MarkMessage(MARK_TYPE dwType, APPLYCHILDRENTYPE dwApplyType);
    virtual HRESULT STDMETHODCALLTYPE GetMessageFlags(MESSAGEFLAGS *pdwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount(ACCTTYPE acctType, IImnAccount **ppAcct);
    virtual HRESULT STDMETHODCALLTYPE GetMessage(IMimeMessage **ppMsg, BOOL *pfCompleteMsg, DWORD dwMessageFlags, HRESULT *phr);
    virtual HRESULT STDMETHODCALLTYPE Close(void);
    virtual HRESULT STDMETHODCALLTYPE SetStoreCallback(IStoreCallback *pStoreCB);
    virtual HRESULT STDMETHODCALLTYPE GetLocation(LPWSTR rgwchLocation);
    virtual HRESULT STDMETHODCALLTYPE SwitchLanguage(HCHARSET hOldCharset, HCHARSET hNewCharset);
    virtual HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, STOREOPERATIONTYPE *ptyNewOp = NULL);
    virtual HRESULT STDMETHODCALLTYPE UpdateCallbackInfo(LPSTOREOPERATIONINFO pOpInfo);
    virtual HRESULT STDMETHODCALLTYPE Notify(DWORD dwNotifyID);

protected:
    HWND GetCallbackHwnd(void);

    void HandlePut(HRESULT hr, STOREOPERATIONTYPE *ptyNewOp);
    void HandleDelete(HRESULT hr);
    void HandleCopyMove(HRESULT hr);
    void HandleGetMessage(HRESULT hr);

    BOOL FCanConnect(void);
    BOOL ThreadingEnabled(void);
    BOOL NeedToSendNews(IMimePropertySet *pPropSet);
    BOOL NeedToSendMail(IMimePropertySet *pPropSet);

    HRESULT LoadMessage(void);
    HRESULT LoadMessageFromFAT(BOOL fOriginal, HRESULT *phr);
    HRESULT LoadMessageFromTable(BOOL fOriginal, HRESULT *phr);
    HRESULT LoadMessageFromStore(void);
    HRESULT LoadMessageFromRow(IMimeMessage **ppMsg, ROWINDEX row);
    HRESULT CreateMsgWithAccountInfo(void);
    HRESULT SetAccountInfo(void);

    HRESULT DoCopyMoveFromFATToFldr(BOOL fUnSent);
    HRESULT DoCopyMoveFromTableToFldr(void);
    HRESULT DoCopyMoveFromStoreToFldr(BOOL fUnSent);
    HRESULT DoCopyMoveFromMsgToFldr(IMimeMessage *pMsg, BOOL fUnSent);

    HRESULT DeleteFromMsgTable(DELETEMESSAGEFLAGS dwFlags);
    HRESULT DeleteFromStore(DELETEMESSAGEFLAGS dwFlags);

#ifdef SMIME_V3
    HRESULT SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail, IHeaderSite *pHeaderSite);
#else
    HRESULT SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail);
#endif // SMIME_V3

    HRESULT ClearHeaders(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet);

private:
    BOOL            m_fValidMessage,
                    m_fReloadMessageFlag,
                    m_fNeedToLoadMsg,
                    m_fThreadingEnabled,
                    m_fCBCopy,
                    m_fCBSavedInDrafts,
                    m_fCBSaveInFolderAndDelOrig,
                    m_fGotNewID,
                    m_fHaveCBMessageID,
                    m_fHeaderOnly;
    DWORD           m_dwInitType,
                    m_dwCMFState,
                    m_dwOrigFolderIsImap,
                    m_dwArfFlags,
                    m_dwMSAction;
    ULONG           m_cRef;
    IMimeMessage   *m_pMsg,
                   *m_pOrigMsg;
    IMessageTable  *m_pMsgTable;
    IMessageFolder *m_pCBMsgFolder;
    IMessageFolder *m_pFolderReleaseOnComplete;
    IListSelector  *m_pListSelect;
    IStoreCallback *m_pStoreCB;
    MESSAGEID       m_MessageID,
                    m_CBMessageID,
                    m_NewMessageID;
    FOLDERID        m_FolderID,
                    m_CBFolderID;
    MESSAGEID       m_idBookmark,
                    m_idNewBookmark;
    WCHAR           m_rgwchFileName[MAX_PATH];

    DWORD           m_dwMDNFlags;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\options.h ===
/* *
   * o p t i o n s . h
   * 
   */

#ifndef _OPTIONS_H
#define _OPTIONS_H

//////////////////////////////////////////////////////////////////////////////
//
//  Depends on
//

#ifndef _RICHEDIT_H
#include <richedit.h>
#endif
#include <commdlg.h>
#include <goptions.h>

#ifdef WIN16
#include <mimeole.h>
#endif
// mimeole.h
typedef enum tagENCODINGTYPE ENCODINGTYPE;

//////////////////////////////////////////////////////////////////////////////
//
//  BEGIN
//

#define PORT_CCHMAX         8

#define DOWNLOAD_MAX        10000
#define DOWNLOAD_MIN        10
#define DOWNLOAD_DEFAULT    1000
#define EXPIRE_MAX          100
#define EXPIRE_MIN          1
#define EXPIRE_DEFAULT      5
#define DEFAULT_TIMEOUT     60

enum tagPages {
    PAGE_GEN    = 0x0001,
    PAGE_SEND   = 0x0002,
    PAGE_READ   = 0x0004,
    PAGE_SPELL  = 0x0008,
    PAGE_SEC    = 0x0010,
    PAGE_DIALUP = 0x0020,
    PAGE_ADV    = 0x0040,
    PAGE_SIGS   = 0x0080,
    PAGE_COMPOSE= 0x0100
    };

enum tagStationery {
    PAGE_STATIONERY_MAIL   = 0x0001,
    PAGE_STATIONERY_NEWS   = 0x0002
    };

typedef struct tagOPTPAGES
    {
    DLGPROC pfnDlgProc;
    UINT    uTemplate;
    } OPTPAGES;

typedef struct tagOPTINFO
    {
    IOptionBucketEx *pOpt;
    
    BOOL        fMakeDefaultMail;
    BOOL        fMakeDefaultNews;
    BOOL        fWasSMAPI;
    BOOL        fCanChangeSMAPI;

    BOOL        fMail;

    HIMAGELIST  himl;
    } OPTINFO;

#define ATHENA_OPTIONS  1
#define SPELL_OPTIONS   2

interface IAthenaBrowser;
BOOL ShowOptions(HWND hwndParent, DWORD type, UINT nStartPage, IAthenaBrowser *pBrowser);

BOOL InitOptInfo(DWORD type, OPTINFO **ppoi);
void DeInitOptInfo(OPTINFO *poi);

void InitIndentOptions(CHAR chIndent, HWND hwnd, UINT idCheck, UINT idCombo);

void FillEncodeCombo(HWND hwnd, BOOL fHtml);

void InitCheckCounterFromOptInfo(HWND hwnd, int idCheck, int idEdit, int idSpin, OPTINFO *poi, PROPID opt);
BOOL GetCheckCounter(DWORD *pdw, HWND hwnd, int idCheck, int idEdit, int idSpin);

void ButtonChkFromOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, PROPID opt);
BOOL ButtonChkToOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt);

void FillPollingDialCombo(HWND  hwndPollDialCombo);            

void InitDlgEdit(HWND hwnd, int id, int max, TCHAR *sz);

void InitTimeoutSlider(HWND hwndSlider, HWND hwndText, DWORD dwTimeout);
void SetTimeoutString(HWND hwnd, UINT pos);
DWORD GetTimeoutFromSlider(HWND hwnd);

BOOL ShowStationery(HWND hwndParent, UINT nStartPage);
VOID LoadVCardList(HWND hwndCombo, LPTSTR lpszDisplayName);
BOOL UpdateVCardOptions(HWND hwnd, BOOL fMail, OPTINFO* pmoi);
HRESULT VCardEdit(HWND hwnd, DWORD idc, DWORD idcOther);
HRESULT VCardNewEntry(HWND hwnd);

typedef struct tagHTMLOPT
{
    ENCODINGTYPE    ietEncoding;
    BOOL            f8Bit,
                    fSendImages,
                    fIndentReply;
    ULONG           uWrap;
} 
HTMLOPT, *LPHTMLOPT;

typedef struct tagPLAINOPT
{
    ENCODINGTYPE    ietEncoding;
    BOOL            f8Bit;
    BOOL            fMime;
    ULONG           uWrap;
    CHAR            chQuote;
} 
PLAINOPT, *LPPLAINOPT;

// flags for GetDefaultOptInfo()
#define FMT_MAIL        0x0001
#define FMT_NEWS        0x0002
#define FMT_FORCE_PLAIN 0x0004
#define FMT_FORCE_HTML  0x0008

void GetDefaultOptInfo(LPHTMLOPT prHtmlOpt, LPPLAINOPT prPlainOpt, BOOL *pfHtml, DWORD dwFlags);

void SetPageDirty(OPTINFO *poi, HWND hwnd, DWORD page);
LRESULT InvalidOptionProp(HWND hwndPage, int idcEdit, int idsError, UINT idPage);

BOOL FGetHTMLOptions(HWND hwndParent, LPHTMLOPT pHtmlOpt);
BOOL FGetPlainOptions(HWND hwndParent, LPPLAINOPT pPlainOpt);
BOOL ChangeFontSettings(HWND hwnd);  

INT_PTR CALLBACK PlainSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK HTMLSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK MailStationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewsStationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, BOOL fMail);
INT_PTR CALLBACK SelectDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK CacheCleanUpDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void DoDefaultClientCheck(HWND hwnd, DWORD dwFlags);
void FreeIcon(HWND hwnd, int idc);

// General Page
INT_PTR CALLBACK GeneralDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT General_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Send Page
INT_PTR CALLBACK SendDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Send_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Send_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Send_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Read Page
INT_PTR CALLBACK ReadDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Read_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Read_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Read_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Security Page
INT_PTR CALLBACK SecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Security_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Security_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Security_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Dial Page
INT_PTR CALLBACK DialUpDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Dial_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Dial_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Dial_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Maintenance
INT_PTR CALLBACK MaintenanceDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Maintenance_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Maintenance_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Maintenance_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Compose
INT_PTR CALLBACK ComposeDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Compose_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Compose_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Compose_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

//Receipts
INT_PTR CALLBACK ReceiptsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL Receipts_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void Receipts_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Receipts_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);


// Test whether or not HTTPMail is enabled (for OE5b2)
BOOL IsHTTPMailEnabled(void);

enum {
    ID_OPTIONS_GENERAL = 0,
    ID_SEND_RECEIEVE,
    ID_DEFAULT_PROGRAMS,
    ID_SENDING,
    ID_MAIL_FORMAT,
    ID_NEWS_FORMAT,
    ID_READING,
    ID_READ_NEWS,
    ID_FONTS,
    ID_SIGNATURES,
    ID_SIG_LIST,
    ID_SIG_EDIT,
    ID_SPELL,
    ID_SPELL_IGNORE,
    ID_LANGUAGE_ICON,
    ID_SECURITY_ZONE,
    ID_SECURE_MAIL,
    ID_CONNECTION,
    ID_CONNECTION_START,
    ID_CONNECTION_INTERNET,
    ID_MAINTENANCE,
    ID_TROUBLESHOOTING,
    ID_FILES,
    ID_STATIONERY_ICON,
    ID_VCARD,
    ID_RECEIPT,
    ID_SEC_RECEIPT,
    ID_MAX
};

#endif //_OPTIONS_H

#if 0
    {IDC_INDENT_CHECK,          IDH_NEWS_SEND_INDENT_WITH},
    {IDC_INDENT_COMBO,          IDH_NEWS_SEND_INDENT_WITH},
    {idcIndentReply,            IDH_NEWS_SEND_INDENT_WITH},
    {idcIndentChar,             IDH_NEWS_SEND_INDENT_WITH},

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\optres.h ===
#ifndef _INC_OPTRES_H
#define _INC_OPTRES_H

#define IDC_SOUND_CHECK             1000
#define IDC_PREVIEW_CHECK           1001
#define IDC_AUTOCHECK_CHECK         1002
#define IDC_AUTOCHECK_EDIT          1003
#define IDC_EMPTY_CHECK             1004
#define IDC_AUTOCHECK_SPIN          1005
#define IDC_SAVE_CHECK              1006
#define IDC_CHECK3                  1008
#define IDC_INDENT_CHECK            1010
#define IDC_INDENT_COMBO            1011
#define IDC_MIME_RADIO              1013
#define IDC_UUENCODE_RADIO          1014
#define IDC_ENCODE_COMBO            1015
#define IDC_BREAK_CHECK             1016
#define IDC_BREAK_EDIT              1017
#define IDC_BREAK_SPIN              1018
#define IDC_NOSIG_RADIO             1020
#define IDC_TEXT_RADIO              1021
#define IDC_FILE_RADIO              1022
#define IDC_TEXT_EDIT               1023
#define IDC_FILE_EDIT               1024
#define IDC_BROWSE_BUTTON           1025
#define IDC_ADVANCED_BUTTON         1026
#define IDC_INCLUDE_CHECK           1027
#define IDC_AUTOSIGNATURE_CHECK     1029
#define IDC_MARKASREAD_EDIT         1030
#define IDC_MARKASREAD_SPIN         1031
#define IDC_MAILTIMEOUT_SLIDER      1033
#define IDC_MAILTIMEOUT_STATIC      1034
#define IDC_SENDIMMEDIATE_CHECK     1036
#define IDC_SIGREPLY_CHECK          1037
#define IDC_MAILWRAP_EDIT           1038
#define IDC_MAILWRAP_SPIN           1039
#define IDC_8BIT_HEADER             1040
#define IDC_MAILWRAP_TEXT1          1041
#define IDC_MAILWRAP_TEXT2          1042
#define idcStaticOrFwd              1047
#define idcStaticReplying           1048
#define IDC_AUTOWAB_CHECK           1049

#define IDC_INCLUDE_OTHERS          1051
#define IDC_SIGN_CHECK              1052
#define IDC_ENCRYPT_CHECK           1053
#define IDC_ADVSETTINGS_BUTTON      1054
#define IDC_CERT_COMBO              1055
#define IDC_INCLUDECERT_CHECK       1056
#define IDC_ENCRYPT_COMBO           1057
#define IDC_ENCRYPT_FOR_SELF        1058
#define IDC_OPAQUE_SIGN             1059

#define IDC_FONTSETTINGS            1060
#define idcAutoInline               1061
#define idcAutoInlineSlide          1062
#define IDC_SENDIMAGES              1063
#define IDC_REPLY_IN_ORIGFMT        1064
#define IDC_STORE_LOCATION          1065
#define IDC_STORE_EDIT              1066
#define IDC_CHANGE_BTN              1067

#define IDC_AUTO_ADD_SENDERS_CERT_TO_WAB    1068
#define IDC_ENCRYPT_WARN_COMBO      1069


#define IDC_VCARD_CHECK             1071
#define IDC_VCARD_COMBO             1072
#define IDC_VCARD_BUTTON_EDIT       1073
#define IDC_VCARD_BUTTON_NEW        1074
#define IDC_BROWSE_PICTURE          1075
#define IDC_BKGRNDPICTURE_CHECK     1076
#define IDC_BKGRNDPICTURE           1077
#define IDC_SENDFONTSETTINGS        1078
#define IDC_INDENTREPLY_CHECK       1079
#define IDC_USEAUTOCOMPLETE_CHECK   1080
#define IDC_SIGBOTTOM_CHECK         1081

#define IDC_ALWAYSCHECK             1090
#define IDC_NOTDEFAULT              1091
#define IDC_WARNINGICON             1092
#define IDC_ENCRYPT_ICON			1093
#define	IDC_SIGNED_ICON				1094

#define	IDC_SIG_LIST                1095
#define	IDC_NEW_BUTTON              1096
#define	IDC_REMOVE_BUTTON           1097
#define	IDC_RENAME_BUTTON           1098
#define	IDC_ADDSIG_CHECK            1099
#define	IDC_ADDREPLY_CHECK          1100
#define	IDC_DEFAULT_BUTTON          1101
#define	IDC_ADV_BUTTON              1102
#define IDC_ACCOUNT_LIST            1103
#define IDC_ADVSIG_STATIC           1104
#define IDC_POLLING_DIAL_OPTIONS    1105
#define IDC_CERT_ICON               1106
#define IDC_SELECT_LABEL            1107
#define IDC_SEC_LABEL               1108


#define idcName                                   2001
#define idcOrganization                           2002
#define idcEmailAddress                           2003
#define idcReplyTo                                2004
#define idcNumSubj                                2005
#define idcSpinNumSubj                            2006
#define idcAdvancedBtn                            2007
#define idcAutoExpand                             2008
#define idcMarkAllRead                            2009
#define idcSelectEntireWord                       2010
#define idcMarkReadPreview                        2011
#define idcCheckForNew                            2012
#define idcEditHowOften                           2013
#define idcSpinHowOften                           2014
#define idcIncludeInReply                         2015
#define idcFontList                               2016
#define idcChange                                 2017
#define idcDemoText                               2018
#define idcSuggest                                2019
#define idcCheckBeforeSend                        2020
#define idcIgnoreUpper                            2021
#define idcIgnoreNum                              2022
#define idcIgnoreOrig                             2023
#define idcRadioText                              2024
#define idcSigText                                2025
#define idcRadioFile                              2026
#define idcFileName                               2027
#define idcBrowse                                 2028
#define idcAutoAddSig                             2029
#define idcDownloadChunks                         2030
#define idcAttachMime                             2031
#define idcAttachUuencode                         2032
#define IDC_BUDDYLIST_CHECK                       2033

#define IDC_NOTIFY_NEW_GROUPS                     2037
#define idcSaveCopy                               2038
#define idcIndentReply                            2039
#define idcIndentChar                             2040
#define idcProperties                             2041
#define idcAddServer                              2043
#define idcRemoveServer                           2044
#define idcPreviewTimeout                         2045
#define idcPreviewSpin                            2046
#define idcEncoding                               2047
#define idcServerList                             2048
#define idcNewsWrapEdit                           2049
#define idcNewsWrapSpin                           2050
#define idcAutoFillPreview                        2051
#define idch8bitHeader                            2052

#define idcTotalSize                              2053
#define idcWastedSpace                            2054
#define idbRemove                                 2055
#define idbCompactCache                           2059
#define idbDelete                                 2060
#define idchDeleteMsgs                            2061
#define ideDays                                   2062
#define idspDays                                  2063
#define idchDontCacheRead                         2066
#define idbManualCleanUp                          2067
#define idsDiskUsage                              2068
#define ideCompactPer                             2071
#define idspCompactPer                            2072
#define idcStartGroup                             2073
#define idcNewsWrapText1                          2074
#define idcNewsWrapText2                          2075
#define idcAdd                                    2076
#define idcSetAsDefault                           2077
#define idcFontSettings                           2078
#define idcLogNewsXport                           2079
#define idcNewsXportBrowse                        2080
#define idcLogNewsOffline                         2081
#define idcOfflineBrowse                          2082
#define idcNoConnectionRadio                      2083
#define idcDialRadio                              2084
#define idcDialUpCombo                            2085
#define idcPromptRadio                            2086
#define idcSwitchCheck                            2087
#define idbtnMailPlain                            2088
#define idbtnMailHTML                             2089
#define idrbMailPlain                             2090
#define idrbMailHTML                              2091
#define idbtnNewsPlain                            2092
#define idbtnNewsHTML                             2093
#define idrbNewsPlain                             2094
#define idrbNewsHTML                              2095
#define idcLogMailXport                           2096
#define idcHangupCheck                            2097
#define IDC_LAUNCH_INBOX                          2098
#define idcIntlButton                             2099
#define IDC_SAMPLE                                2100
#define IDC_RADIOMYFONT                           2101
#define IDC_RADIOUSETHIS                          2102
#define IDC_EDITSTATIONERY                        2103
#define IDC_SELECT                                2104
#define IDC_SIGNATURE                             2105
#define IDC_ADDSTATIONERY                         2106
#define IDC_PREVIEW                               2107
#define IDC_LISTSTATIONERY                        2108
#define IDC_MORESTATIONERY                        2110
#define idbtnSendIntl                             2111
#define idbtnIDs                                  2112
#define idcAutoDiscovery                          2113

#define idcZone                                   2115
#define idbtnDigitalID                            2117
#define idbtnMoreInfo                             2118
#define idcLogImapXport                           2119
#define idcResetText                              2120
#define idbReset                                  2121
#define IDC_ENGLISH_HDR_CHECK                     2122
#define IDC_EXPANDUNREAD_CHECK                    2124
#define IDC_MAILFORMAT_GROUP                      2125
#define IDC_SECURITYSETTINGS_GROUP                2126
#define IDC_DIGITALIDS_GROUP                      2127
#define IDC_MAILFORMAT_STATIC                     2128
#define IDC_SECURITYSETTINGS_STATIC               2129
#define IDC_DIGITALIDS_STATIC                     2130
#define IDC_MOREPREVIEW                           2132
#define IDC_SHOWPREVIEW_CHECK                     2133
#define idcIMAPPurge                              2134
#define idcTooltips                               2135
#define idcDialupButton                           2136
#define IDC_DEFMAIL                               2137
#define IDC_DEFNEWS                               2138
#define IDC_MAILHANDSTAT                          2139
#define IDC_NEWSHANDSTAT                          2140
#define IDC_STATIONERY                            2141
#define IDC_INTERNET_ZONE                         2142
#define IDC_RESTRICTED_ZONE                       2143
#define IDC_SEND_RECEIVE_ON_START                 2144
#define IDC_BACKGROUND_COMPACTION                 2145
#define IDC_MAIL_FORMAT                           2146
#define IDC_MAIL_FORMAT_ADVANCED                  2147
#define IDC_NEWS_FORMAT                           2148
#define IDC_NEWS_FORMAT_ADVANCED                  2149
#define IDC_ADD_SIG                               2150
#define IDC_EDIT_SIG                              2151
#define IDC_TROUBLE_ICON                          2152
#define IDC_CLEANUP_ICON                          2153
#define IDC_DIAL_ICON                             2154
#define IDC_DIAL_START_ICON                       2155
#define IDC_INTERNET_DIAL_ICON                    2156
#define IDC_READ_ICON                             2157
#define IDC_READ_NEWS_ICON                        2158
#define IDC_FONTS_ICON                            2159
#define IDC_SECURITY_ZONE_ICON                    2160
#define IDC_SECURE_MAIL_ICON                      2161
#define IDC_SEND_ICON                             2162
#define IDC_MAIL_FORMAT_ICON                      2163
#define IDC_NEWS_FORMAT_ICON                      2164
#define IDC_SIGLIST_ICON                          2165
#define IDC_SIG_SETTINGS_ICON                     2166
#define IDC_SPELL_SETTINGS_ICON                   2167
#define IDC_SPELL_IGNORE_ICON                     2168
#define IDC_SPELL_LANGUAGE_ICON                   2169
#define IDC_SIG_EDIT_ICON                         2170
#define IDC_GENERAL_ICON                          2171
#define IDC_SEND_RECEIVE_ICON                     2172
#define IDC_DEFAULT_ICON                          2173
#define IDC_CACHE_FOLDER                          2174
#define IDC_FOLDER_BROWSE                         2175
#define IDC_MAIL_FONT_SETTINGS                    2176
#define IDC_NEWS_FONT_SETTINGS                    2177
#define IDC_MAIL_FONT_DEMO                        2178
#define IDC_NEWS_FONT_DEMO                        2179
#define IDC_FONT_ICON                             2180
#define IDC_SELECT_MAIL                           2181
#define IDC_SELECT_NEWS                           2182
#define IDC_MAIL_STATIONERY                       2183
#define IDC_NEWS_STATIONERY                       2184
#define IDC_USE_MAIL_STATIONERY                   2185
#define IDC_USE_NEWS_STATIONERY                   2186
#define IDC_DOWNLOAD_MORE                         2187
#define IDC_CREATE_NEW                            2188
#define IDC_STATIONERY_ICON                       2189
#define IDC_MAIL_VCARD                            2190
#define IDC_NEWS_VCARD                            2191
#define IDC_VCARD_ICON                            2192
#define IDC_EDIT_VCARD                            2193
#define IDC_MAIL_VCARD_SELECT                     2194
#define IDC_NEWS_VCARD_SELECT                     2195
#define IDC_EDIT_MAIL_VCARD                       2196
#define IDC_EDIT_NEWS_VCARD                       2197
#define idcLogHTTPMailXport                       2198
#define IDC_RTL_MSG_DIR_CHECK                     2199

#define IDC_SHOWPREVIEW_BUTTON_ADD                2200
#define IDC_SHOWPREVIEW_BUTTON_EDIT               2201
#define IDC_WATCHED_COLOR                         2202
#define IDC_REVOKE_ONLINE_ONLY                    2203
#define IDC_REVOKE_NEVER                          2204

#define IDC_MDN_SEND_REQUEST                      2205
#define IDC_SECURE_RECEIPT                        2206
#define IDC_DONOT_REPSONDTO_RCPT                  2207
#define IDC_ASKME_FOR_RCPT                        2208
#define IDC_SEND_AUTO_RCPT                        2209
#define IDC_TO_CC_LINE_RCPT                       2210
#define IDC_TO_CC_TEXT                            2211
#define IDC_RECEIPT                               2212
#define IDC_AUTODISCOVERY_ICON                    2213

#define IDC_SENDMAIL_WARN_CHECK                   2220
#define IDC_SAFE_ATTACHMENT_CHECK                 2221
#define IDC_READ_IN_TEXT_ONLY                     2222

#define IDC_SR_TXT1                               2232
#define IDC_SRES_TXT2                             2233
#define IDC_SRES_TXT3                             2234
#define IDC_SEC_SEND_REQUEST                      2235
#define IDC_DONOT_RESSEC_RCPT                     2236
#define IDC_ASKME_FOR_SEC_RCPT                    2237
#define IDC_SEC_AUTO_RCPT                         2238
#define IDC_ENCRYPT_RCPT                          2239
#define IDC_SECREC_VERIFY                         2240
#define IDC_SEC_REC                               2241

#endif // _INC_OPTRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\options.cpp ===
/*
*    o p t i o n s . c p p
*
*    Purpose:
*        Implements options propsheets
*
*    Owner:
*        t-anthda.
*        brettm.
*
*    Copyright (C) Microsoft Corp. 1993, 1994.
*/
#include "pch.hxx"
#include <wininet.h>
#include "resource.h"
#include "options.h"
#include "optres.h"
#include <goptions.h>
#include "strconst.h"
#include "mailnews.h"
#include <error.h>
#include "fonts.h"
#include <regutil.h>
#include <secutil.h>
#include <inetreg.h>
#include "mimeutil.h"
#include <ipab.h>
#include "xpcomm.h"
#include "conman.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <thumb.h>
#include <statnery.h>
#include <url.h>
#include "spell.h"
#include "htmlhelp.h"
#include "shared.h"
#include <sigs.h>
#include "instance.h"
#include <layout.h>
#include "statwiz.h"
#include "storfldr.h"
#include "storutil.h"
#include "cleanup.h"
#include "receipts.h"
#include "demand.h"
#include "multiusr.h"
#include "fontnsc.h"
#include "menuutil.h"

#ifdef SMIME_V3
#include "seclabel.h"
#endif // SMIME_V3

ASSERTDATA

#define MAX_SHOWNAME    25
#define DEFAULT_FONTPIXELSIZE 9

#define SZ_REGKEY_AUTODISCOVERY                 TEXT("SOFTWARE\\Microsoft\\Outlook Express\\5.0")
#define SZ_REGKEY_AUTODISCOVERY_POLICY          TEXT("SOFTWARE\\Policies\\Microsoft\\Windows")

#define SZ_REGVALUE_AUTODISCOVERY               TEXT("AutoDiscovery")
#define SZ_REGVALUE_AUTODISCOVERY_POLICY        TEXT("AutoDiscovery Policy")



void SendTridentOptionsChange();
INT_PTR CALLBACK AdvSecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK FChooseFontHookProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FGetAdvSecOptions(HWND hwndParent, OPTINFO *opie);

#ifdef SMIME_V3
BOOL FGetSecLabel(HWND hwndParent, OPTINFO *opie);
BOOL FGetSecRecOptions(HWND hwndParent, OPTINFO *opie);
INT_PTR CALLBACK SecurityReceiptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // SMIME_V3

LRESULT CALLBACK FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

void HtmlOptFromMailOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void MailOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void PlainOptFromMailOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void MailOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void PaintFontSample(HWND hwnd, HDC hdc, OPTINFO *poi);
void EnableStationeryWindows(HWND hwnd);
void _SetThisStationery(HWND hwnd, BOOL fMail, LPWSTR pwsz, OPTINFO* pmoi);

enum {
    SAMPLE_MAIL = 0,
    SAMPLE_NEWS = 1
};

void _SetComposeFontSample(HWND hwndDlg, DWORD dwType, OPTINFO *pmoi);

void NewsOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void NewsOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void HtmlOptFromNewsOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void PlainOptFromNewsOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);

BOOL AdvSec_GetEncryptWarnCombo(HWND hwnd, OPTINFO *poi);
BOOL AdvSec_FillEncWarnCombo(HWND hwnd, OPTINFO *poi);

BOOL ChangeSendFontSettings(OPTINFO *pmoi, BOOL fMail, HWND hwnd);

void FreeIcon(HWND hwnd, int idc);

WCHAR g_wszNewsStationery[MAX_PATH];
WCHAR g_wszMailStationery[MAX_PATH];

const OPTPAGES c_rgOptPages[] =
{
    { GeneralDlgProc,               iddOpt_General },
    { ReadDlgProc,                  iddOpt_Read },
    { ReceiptsDlgProc,              iddOpt_Receipts },
    { SendDlgProc,                  iddOpt_Send },
    { ComposeDlgProc,               iddOpt_Compose },
    { SigDlgProc,                   iddOpt_Signature },
    { SpellingPageProc,             iddOpt_Spelling },
    { SecurityDlgProc,              iddOpt_Security },
    { DialUpDlgProc,                iddOpt_DialUp },
    { MaintenanceDlgProc,           iddOpt_Advanced }
};

TCHAR   szDialAlways[CCHMAX_STRINGRES];
TCHAR   szDialIfNotOffline[CCHMAX_STRINGRES];
TCHAR   szDoNotDial[CCHMAX_STRINGRES];

//These static won't hurt switching identities because they need not be initialized when switching the
//identities. These need to be persistent across identities.
static  BOOL    fRasInstalled = FALSE;

BOOL    IsRasInstalled()
{
    //These static won't hurt switching identities because they need not be initialized when switching the
    //identities. These need to be persistent across identities.
    static          BOOL    fCheckedRasInstalled = FALSE;
    
    if (!fCheckedRasInstalled)
    {
        if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            // Check Win9x key
            char    szSmall[3]; // there should be a "1" or a "0" only
            DWORD   cb;
            HKEY    hkey;
            long    lRes;
            
            lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RNACOMPONENT,
                NULL, KEY_READ, &hkey);
            if(ERROR_SUCCESS == lRes) 
            {
                cb = sizeof(szSmall);
                //  REGSTR_VAL_RNAINSTALLED is defined with TEXT() macro so
                //  if wininet is ever compiled unicode this will be a compile
                //  error.
                lRes = RegQueryValueExA(hkey, REGSTR_VAL_RNAINSTALLED, NULL,
                    NULL, (LPBYTE)szSmall, &cb);
                if(ERROR_SUCCESS == lRes) {
                    if((szSmall[0] == '1') && (szSmall[1] == 0)) {
                        // 1 means ras installed
                        fRasInstalled = TRUE;
                    }
                }
                RegCloseKey(hkey);
            }
        }
        else if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            // Ask NT service manager if RemoteAccess service is installed
            //
            SC_HANDLE hscm;
            
            hscm = OpenSCManager(NULL, NULL, GENERIC_READ);
            /*
            if(hscm)
            {
            SC_HANDLE hras;
            
              hras = OpenService(hscm, TEXT("RemoteAccess"), GENERIC_READ);
              if(hras)
              {
              // service exists - ras is installed
              fRasInstalled = TRUE;
              
                CloseServiceHandle(hras);
                }
                
                  CloseServiceHandle(hscm);
                  }
            */
            if(hscm)
            {
                SC_HANDLE hras;
                ENUM_SERVICE_STATUS essServices[16];
                DWORD dwError, dwResume = 0, i;
                DWORD cbNeeded = 1, csReturned;
                
                while(FALSE == fRasInstalled && cbNeeded > 0)
                {
                    // Get the next chunk of services
                    dwError = 0;
                    if(FALSE == EnumServicesStatus(hscm, SERVICE_WIN32, SERVICE_ACTIVE,
                        essServices, sizeof(essServices), &cbNeeded, &csReturned,
                        &dwResume))
                    {
                        dwError = GetLastError();
                    }
                    
                    if(dwError && dwError != ERROR_MORE_DATA)
                    {
                        // unknown error - bail
                        break;
                    }
                    
                    for(i=0; i<csReturned; i++)
                    {
                        if(0 == lstrcmp(essServices[i].lpServiceName, TEXT("RasMan")))
                        {
                            // service exists. RAS is installed.
                            fRasInstalled = TRUE;
                            break;
                        }
                    }
                }
                
                CloseServiceHandle(hscm);
            }
        }
        fCheckedRasInstalled = TRUE;
        
    }
    return fRasInstalled;
}

BOOL InitOptInfo(DWORD type, OPTINFO **ppoi)
{
    BOOL fRet;
    OPTINFO *poi;
    
    Assert(type == ATHENA_OPTIONS || type == SPELL_OPTIONS);
    Assert(ppoi != NULL);
    
    fRet = FALSE;
    *ppoi = NULL;
    
    if (!MemAlloc((void **)&poi, sizeof(OPTINFO)))
        return(FALSE);
    
    ZeroMemory(poi, sizeof(OPTINFO));

    poi->himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbOptions), 32, 0,
                                    RGB(255, 0, 255));
    Assert(poi->himl);
    
    // TODO: we may want to make a copy of g_pOptBcktEx and use that instead?????
    
    Assert(g_pOpt != NULL);
    poi->pOpt = g_pOpt;
    poi->pOpt->AddRef();
    // poi->pOpt->EnableNotification(FALSE);
    fRet = TRUE;
    
    if (!fRet)
    {
        DeInitOptInfo(poi);
        poi = NULL;
    }
    
    *ppoi = poi;
    
    return(fRet);
}

void DeInitOptInfo(OPTINFO *poi)
{
    Assert(poi != NULL);

    if (poi->himl)
    {
        ImageList_Destroy(poi->himl);
    }
    
    if (poi->pOpt != NULL)
    {
        // poi->pOpt->EnableNotification(TRUE);
        poi->pOpt->Release();
    }
    
    MemFree(poi);
}


BOOL ShowOptions(HWND hwndParent, DWORD type, UINT nStartPage, IAthenaBrowser *pBrowser)
{
    LPARAM              lParam;
    PROPSHEETHEADERW    psh;
    OPTINFO            *poi;
    int                 i, 
                        cPage;
    OPTPAGES           *pPages;
    BOOL                fRet;
    PROPSHEETPAGEW     *ppsp, 
                        psp[ARRAYSIZE(c_rgOptPages)];
    HMODULE             hmodxpres = NULL;
    
    Assert(type == ATHENA_OPTIONS || type == SPELL_OPTIONS);
    
    if (!InitOptInfo(type, &poi))
        return(FALSE);
    
    fRet = FALSE;
    
    pPages = (OPTPAGES *)c_rgOptPages;
    cPage = ARRAYSIZE(c_rgOptPages);
    
    psh.nPages = 0;
    
    // Fill out the PROPSHEETPAGE structs
    for (i = 0, ppsp = psp; i < cPage; i++, pPages++)
    {
        lParam = (LPARAM)poi;
        
        if (pPages->uTemplate == iddOpt_Spelling)
        {
            if (!FCheckSpellAvail())
                continue;

            if (type == SPELL_OPTIONS)
                nStartPage = psh.nPages;
        }
        else if (pPages->uTemplate == iddViewLayout)
        {
            if (pBrowser == NULL)
                continue;
            lParam = (LPARAM)pBrowser;
        }
        else if (pPages->uTemplate == iddOpt_Read)
        {
            OSVERSIONINFOEXA osvi = {0};
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            // is whistler ?
            if (GetVersionExA((OSVERSIONINFOA*)&osvi) && (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId &&
                 (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1 && LOWORD(osvi.dwBuildNumber) == 2600)))
            {
                hmodxpres = LoadLibrary(TEXT("xpsp1res.dll"));
            }
        }
        
        ppsp->dwSize        = sizeof(*ppsp);
        ppsp->dwFlags       = PSP_DEFAULT;
        if ((pPages->uTemplate == iddOpt_Read) && (hmodxpres != NULL))
            ppsp->hInstance = hmodxpres;
        else
            ppsp->hInstance = g_hLocRes;
        ppsp->pszTemplate   = MAKEINTRESOURCEW(pPages->uTemplate);
        ppsp->pszIcon       = 0;
        ppsp->pfnDlgProc    = pPages->pfnDlgProc;
        ppsp->pszTitle      = 0;
        ppsp->lParam        = lParam;
        ppsp->pfnCallback   = NULL;
        
        psh.nPages++;
        ppsp++;
    }
    
    // Adjust start page if greater than number of pages
    if ((int)nStartPage > psh.nPages)
    {
        AssertSz(FALSE, "Start page is too high.");
        nStartPage = 0;
    }
    
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_USEICONID | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hLocRes;
    psh.pszCaption = MAKEINTRESOURCEW(idsOptions);
    psh.nStartPage = nStartPage;
    psh.pszIcon = MAKEINTRESOURCEW(idiMailNews);
    psh.ppsp = (LPCPROPSHEETPAGEW)&psp;
    
    if (-1 != PropertySheetW(&psh))
        fRet = TRUE;
    
    DeInitOptInfo(poi);
    if (hmodxpres)
        FreeLibrary(hmodxpres);
    
    return(fRet);
}

void InitDlgEdit(HWND hwnd, int id, int max, TCHAR *sz)
{
    HWND hwndT;
    
    hwndT = GetDlgItem(hwnd, id);
    Edit_LimitText(hwndT, max);
    if (sz != NULL)
        Edit_SetText(hwndT, sz);
}

void InitCheckCounterFromOptInfo(HWND hwnd, int idcCheck, int idcEdit, int idcSpin, OPTINFO *poi, PROPID id)
{
    BOOL f;
    int digit;
    DWORD dw;
    HRESULT hr;
    PROPINFO info;
    
    Assert(poi != NULL);
    Assert(idcEdit != 0);
    Assert(idcSpin != 0);
    
    info.cbSize = sizeof(PROPINFO);
    hr = poi->pOpt->GetPropertyInfo(id, &info, 0);
    Assert(hr == S_OK);
    Assert(info.vt == VT_UI4);
    
    dw = IDwGetOption(poi->pOpt, id);
    f = (dw != OPTION_OFF);
    if (!f)
        dw = IDwGetOptionDefault(poi->pOpt, id);
    
    Assert(info.uMin <= (int)dw);
    Assert(info.uMax >= (int)dw);
    
    if (id == OPT_POLLFORMSGS)
    {
        // convert to minutes from millisecs
        dw = dw / (60 * 1000);
        info.uMin = info.uMin / (60 * 1000);
        info.uMax = info.uMax / (60 * 1000);
    }
    
    if (idcCheck != 0)
    {
        CheckDlgButton(hwnd, idcCheck, f ? BST_CHECKED : BST_UNCHECKED);
    }
    else
    {
        Assert(f);
    }
    SendDlgItemMessage(hwnd, idcSpin, UDM_SETRANGE, 0, MAKELONG(info.uMax, info.uMin));
    
    digit = 1;
    while (info.uMax >= 10)
    {
        info.uMax = info.uMax / 10;
        digit++;
    }
    SendDlgItemMessage(hwnd, idcEdit, EM_LIMITTEXT, (WPARAM)digit, 0);
    
    SetDlgItemInt(hwnd, idcEdit, dw, FALSE);
    EnableWindow(GetDlgItem(hwnd, idcEdit), f);
    EnableWindow(GetDlgItem(hwnd, idcSpin), f);
}

BOOL GetCheckCounter(DWORD *pdw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin)
{
    BOOL f, fRet;
    DWORD dw, range;
    
    f = (idcCheck == 0 || IsDlgButtonChecked(hwnd, idcCheck) == BST_CHECKED);
    if (!f)
    {
        dw = OPTION_OFF;
        fRet = TRUE;
    }
    else
    {
        dw = GetDlgItemInt(hwnd, idcEdit, &fRet, FALSE);
        if (fRet)
        {
            range = (DWORD) SendDlgItemMessage(hwnd, idcSpin, UDM_GETRANGE, 0, 0);
            if (dw < HIWORD(range) || dw > LOWORD(range))
                fRet = FALSE;
        }
    }
    
    *pdw = dw;
    
    return(fRet);
}

void SetPageDirty(OPTINFO *poi, HWND hwnd, DWORD page)
{
    Assert(poi != NULL);
    
    PropSheet_Changed(GetParent(hwnd), hwnd);
}


/////////////////////////////////////////////////////////////////////////////
// General Tab 
//

static const HELPMAP g_rgCtxMapMailGeneral[] = {
    {IDC_LAUNCH_INBOX,          IDH_OPTIONS_GO_TO_INBOX},
    {IDC_NOTIFY_NEW_GROUPS,     IDH_NEWS_OPT_READ_NOTIFY_NEW_NEWS},
    {IDC_SOUND_CHECK,           IDH_MAIL_OPT_READ_PLYSND},
    {IDC_AUTOCHECK_EDIT,        IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_AUTOCHECK_SPIN,        IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_AUTOCHECK_CHECK,       IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_MAILHANDSTAT,          IDH_MAIL_SEND_IM_DEFAULT},
    {IDC_DEFMAIL,               IDH_MAIL_SEND_IM_DEFAULT},
    {IDC_NEWSHANDSTAT,          IDH_NEWS_OPT_READ_DEFAULT},
    {IDC_DEFNEWS,               IDH_NEWS_OPT_READ_DEFAULT},
    {IDC_EXPANDUNREAD_CHECK,    502000},
    {IDC_POLLING_DIAL_OPTIONS,  25252507},
    {IDC_BUDDYLIST_CHECK,       502004},
    {IDC_SEND_RECEIVE_ON_START, 502005},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_GENERAL_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_RECEIVE_ICON,     IDH_NEWS_COMM_GROUPBOX},
    {IDC_DEFAULT_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK GeneralDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, General_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailGeneral);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, General_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, General_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_GENERAL_ICON);
            FreeIcon(hwnd, IDC_SEND_RECEIVE_ICON);
            FreeIcon(hwnd, IDC_DEFAULT_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}

void FillPollingDialCombo(HWND hwndPollDialCombo,     OPTINFO     *pmoi)            
{
    DWORD       dw;
    UINT        iSel;

    LoadString(g_hLocRes, idsDoNotDial, szDoNotDial, ARRAYSIZE(szDoNotDial));
    ComboBox_AddString(hwndPollDialCombo, szDoNotDial);

    LoadString(g_hLocRes, idsDialIfNotOffline, szDialIfNotOffline, ARRAYSIZE(szDialIfNotOffline));
    ComboBox_AddString(hwndPollDialCombo, szDialIfNotOffline);

    LoadString(g_hLocRes, idsDialAlways, szDialAlways, ARRAYSIZE(szDialAlways));
    GetLastError();
    ComboBox_AddString(hwndPollDialCombo, szDialAlways);

    

    dw = IDwGetOption(pmoi->pOpt, OPT_DIAL_DURING_POLL);
    switch (dw)
    {
    case DIAL_ALWAYS:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDialAlways);
        break;

    case DIAL_IF_NOT_OFFLINE:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDialIfNotOffline);
        break;

    case DO_NOT_DIAL:
    default:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDoNotDial);
        break;
    }

    ComboBox_SetCurSel(hwndPollDialCombo, iSel);

}

//
//  FUNCTION:   General_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the General Tab on the options
//              property sheet.
//
BOOL General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    TCHAR    szRes[CCHMAX_STRINGRES] = "";
    BOOL     fEnable = FALSE;
    DWORD    id;
    DWORD    dw;
    HWND     hwndPollDialCombo;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Set the check boxes and counters
    ButtonChkFromOptInfo(hwnd, IDC_LAUNCH_INBOX, pmoi, OPT_LAUNCH_INBOX);
    ButtonChkFromOptInfo(hwnd, IDC_NOTIFY_NEW_GROUPS, pmoi, OPT_NOTIFYGROUPS);
    ButtonChkFromOptInfo(hwnd, IDC_EXPANDUNREAD_CHECK, pmoi, OPT_EXPAND_UNREAD);
    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
        ShowWindow(GetDlgItem(hwnd, IDC_BUDDYLIST_CHECK), SW_HIDE);
    else
    {
        GetDlgItemText(hwnd, IDC_BUDDYLIST_CHECK, szRes, CCHMAX_STRINGRES);
        MenuUtil_BuildMessengerString(szRes);
        SetDlgItemText(hwnd, IDC_BUDDYLIST_CHECK, szRes);

        ButtonChkFromOptInfo(hwnd, IDC_BUDDYLIST_CHECK, pmoi, OPT_BUDDYLIST_CHECK);
    }
    
    ButtonChkFromOptInfo(hwnd, IDC_SOUND_CHECK, pmoi, OPT_NEWMAILSOUND);
    
    ButtonChkFromOptInfo(hwnd, IDC_SEND_RECEIVE_ON_START, pmoi, OPT_POLLFORMSGS_ATSTARTUP);

    InitCheckCounterFromOptInfo(hwnd, IDC_AUTOCHECK_CHECK, IDC_AUTOCHECK_EDIT, IDC_AUTOCHECK_SPIN,
                                pmoi, OPT_POLLFORMSGS);
    fEnable = (IsDlgButtonChecked(hwnd, IDC_AUTOCHECK_CHECK) == BST_CHECKED);
    
    hwndPollDialCombo = GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS);
    EnableWindow(hwndPollDialCombo, fEnable);
    
    //Fill the combo box and select the right option
    FillPollingDialCombo(hwndPollDialCombo, pmoi);        
        
    // Check to see if we're the default mail handler
    if (FIsDefaultMailConfiged())
    {
        LoadString(g_hLocRes, idsCurrentlyDefMail, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsNotDefMail, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), TRUE);
    }
    SetWindowText(GetDlgItem(hwnd, IDC_MAILHANDSTAT), szRes);

    // In news only mode...
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MAILHANDSTAT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);

        // Hide other mail options
        EnableWindow(GetDlgItem(hwnd, IDC_SOUND_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_LAUNCH_INBOX), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_BUDDYLIST_CHECK), FALSE);
        
    }
    
    // Check to see if we're the default news handler
    szRes[0] = 0;
    if (FIsDefaultNewsConfiged(g_dwAthenaMode & MODE_OUTLOOKNEWS ? DEFAULT_OUTNEWS : 0))
    {
        LoadString(g_hLocRes, idsCurrentlyDefNews, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsNotDefNews, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), TRUE);
    }
    SetWindowText(GetDlgItem(hwnd, IDC_NEWSHANDSTAT), szRes);    
    
    // Default to taking no action
    pmoi->fMakeDefaultMail = pmoi->fMakeDefaultNews = FALSE;

    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_OPTIONS_GENERAL, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_GENERAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_DEFAULT_PROGRAMS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_DEFAULT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   General_OnCommand()
//
//  PURPOSE:    Command handler for the General tab on the Options
//              property sheet.
//
void General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    TCHAR    szRes[CCHMAX_STRINGRES];

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_AUTOCHECK_CHECK:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_AUTOCHECK_EDIT), f);
                EnableWindow(GetDlgItem(hwnd, IDC_AUTOCHECK_SPIN), f);
    
                EnableWindow(GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS), f);

                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            }
            break;

        case IDC_POLLING_DIAL_OPTIONS:
            if (codeNotify == CBN_SELENDOK)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;

        case IDC_AUTOCHECK_EDIT:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;
                
        case IDC_SEND_RECEIVE_ON_START:
        case IDC_SOUND_CHECK:
        case IDC_NOTIFY_NEW_GROUPS:
        case IDC_LAUNCH_INBOX:
        case IDC_EXPANDUNREAD_CHECK:
        case IDC_BUDDYLIST_CHECK:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;
                
        case IDC_DEFMAIL:
            szRes[0] = 0;
            LoadString(g_hLocRes, idsCurrentlyDefMail, szRes, ARRAYSIZE(szRes));
            SetWindowText(GetDlgItem(hwnd, IDC_MAILHANDSTAT), szRes);
            EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);
            SetPageDirty(pmoi, hwnd, PAGE_GEN);
            pmoi->fMakeDefaultMail = TRUE;
            break;
        
        case IDC_DEFNEWS:
            szRes[0] = 0;
            LoadString(g_hLocRes, idsCurrentlyDefNews, szRes, ARRAYSIZE(szRes));
            SetWindowText(GetDlgItem(hwnd, IDC_NEWSHANDSTAT), szRes);
            EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), FALSE);
            SetPageDirty(pmoi, hwnd, PAGE_GEN);
            pmoi->fMakeDefaultNews = TRUE;
            break;
    }                
}


//
//  FUNCTION:   General_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the General Tab.
//
LRESULT General_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    DWORD    dw;
    HWND     hwndCombo;
    TCHAR    szEntryName[CCHMAX_STRINGRES];
    UINT     iSel;

    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // General options
        ButtonChkToOptInfo(hwnd, IDC_LAUNCH_INBOX, pmoi, OPT_LAUNCH_INBOX);
        ButtonChkToOptInfo(hwnd, IDC_NOTIFY_NEW_GROUPS, pmoi, OPT_NOTIFYGROUPS);
        ButtonChkToOptInfo(hwnd, IDC_EXPANDUNREAD_CHECK, pmoi, OPT_EXPAND_UNREAD);
        if (!((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE)))
            ButtonChkToOptInfo(hwnd, IDC_BUDDYLIST_CHECK, pmoi, OPT_BUDDYLIST_CHECK);

        // Send / Receive options
        ButtonChkToOptInfo(hwnd, IDC_SOUND_CHECK, pmoi, OPT_NEWMAILSOUND);
        if (!GetCheckCounter(&dw, hwnd, IDC_AUTOCHECK_CHECK, IDC_AUTOCHECK_EDIT, IDC_AUTOCHECK_SPIN))
            return(InvalidOptionProp(hwnd, IDC_AUTOCHECK_EDIT, idsEnterPollTime, iddOpt_General));
    
        if (dw != OPTION_OFF)
            dw = dw * 60 * 1000;
        ISetDwOption(pmoi->pOpt, OPT_POLLFORMSGS, dw, NULL, 0);

        hwndCombo = GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS);
        iSel = ComboBox_GetCurSel(hwndCombo);
        
        if (iSel != CB_ERR)
        {
            ComboBox_GetLBText(hwndCombo, iSel, szEntryName);
            if (lstrcmp(szDialAlways, szEntryName) == 0)
                dw = DIAL_ALWAYS;
            else 
            if (lstrcmp(szDialIfNotOffline, szEntryName) == 0)
                dw = DIAL_IF_NOT_OFFLINE;
            else
                dw = DO_NOT_DIAL;
        }

        ISetDwOption(pmoi->pOpt, OPT_DIAL_DURING_POLL, dw, NULL, 0);

        ButtonChkToOptInfo(hwnd, IDC_SEND_RECEIVE_ON_START, pmoi, OPT_POLLFORMSGS_ATSTARTUP);

        // Default client                    
        if (pmoi->fMakeDefaultMail)
            SetDefaultMailHandler(0);
    
        if (pmoi->fMakeDefaultNews)
            SetDefaultNewsHandler(g_dwAthenaMode & MODE_OUTLOOKNEWS ? DEFAULT_OUTNEWS : 0);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }
    
    return (FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Send Page
//

const static HELPMAP g_rgCtxMapSendMail[] = 
{
    {IDC_SAVE_CHECK,            IDH_MAIL_SEND_SAVE_COPY},
    {IDC_SENDIMMEDIATE_CHECK,   IDH_NEWSMAIL_SEND_ADVSET_SEND_IMMED},
    {IDC_AUTOWAB_CHECK,         IDH_OPTIONS_ADD_REPLIES},
    {IDC_INCLUDE_CHECK,         IDH_NEWS_SEND_MESS_IN_REPLY},
    {IDC_REPLY_IN_ORIGFMT,      IDH_OPTIONS_REPLY_USING_SENT_FORMAT},
    {idrbMailHTML,              IDH_SEND_HTML},
    {idrbMailPlain,             IDH_SEND_PLAINTEXT},
    {idbtnMailHTML,             353718},
    {idbtnMailPlain,            IDH_SEND_SETTINGS},
    {idrbNewsHTML,              IDH_SEND_HTML},
    {idrbNewsPlain,             IDH_SEND_PLAINTEXT},
    {idbtnNewsHTML,             353718},
    {idbtnNewsPlain,            IDH_SEND_SETTINGS},
    {idbtnSendIntl,             IDH_SEND_SETTINGS},
    {IDC_USEAUTOCOMPLETE_CHECK, 502065},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_MAILFORMAT_GROUP,      IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_MAIL_FORMAT_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {IDC_NEWS_FORMAT_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK SendDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Send_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapSendMail);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Send_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Send_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SEND_ICON);
            FreeIcon(hwnd, IDC_MAIL_FORMAT_ICON);
            FreeIcon(hwnd, IDC_NEWS_FORMAT_ICON);
            return (TRUE);
    }
    
    return (FALSE);
}


//
//  FUNCTION:   Send_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Send Tab on the options
//              property sheet.
//
BOOL Send_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    DWORD    dw;
    
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Send Options
    ButtonChkFromOptInfo(hwnd, IDC_SAVE_CHECK, pmoi, OPT_SAVESENTMSGS);
    ButtonChkFromOptInfo(hwnd, IDC_SENDIMMEDIATE_CHECK, pmoi, OPT_SENDIMMEDIATE);
    ButtonChkFromOptInfo(hwnd, IDC_AUTOWAB_CHECK, pmoi, OPT_MAIL_AUTOADDTOWABONREPLY);
    ButtonChkFromOptInfo(hwnd, IDC_USEAUTOCOMPLETE_CHECK, pmoi, OPT_USEAUTOCOMPLETE);
    ButtonChkFromOptInfo(hwnd, IDC_INCLUDE_CHECK, pmoi, OPT_INCLUDEMSG);
    ButtonChkFromOptInfo(hwnd, IDC_REPLY_IN_ORIGFMT, pmoi, OPT_REPLYINORIGFMT);

    // Mail Format
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_SEND_HTML);
    CheckDlgButton(hwnd, dw ? idrbMailHTML : idrbMailPlain, BST_CHECKED);
    
    // News Format
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_SEND_HTML);
    CheckDlgButton(hwnd, dw ? idrbNewsHTML : idrbNewsPlain, BST_CHECKED);
        
    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MAILFORMAT_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAILFORMAT_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, idrbMailHTML), FALSE);
        EnableWindow(GetDlgItem(hwnd, idrbMailPlain), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMailHTML), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMailPlain), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FORMAT_ICON), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnSendIntl), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_AUTOWAB_CHECK), FALSE);
    }
    
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_SENDING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_MAIL_FORMAT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_MAIL_FORMAT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_NEWS_FORMAT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_NEWS_FORMAT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   Send_OnCommand()
//
//  PURPOSE:    Command handler for the Send tab on the Options
//              property sheet.
//
void Send_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    HTMLOPT  rHtmlOpt;
    PLAINOPT rPlainOpt;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_SAVE_CHECK:
        case IDC_SENDIMMEDIATE_CHECK:
        case IDC_AUTOWAB_CHECK:
        case IDC_USEAUTOCOMPLETE_CHECK:
        case IDC_INCLUDE_CHECK:
        case IDC_REPLY_IN_ORIGFMT:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_SEND);
            break;

        case idbtnMailHTML:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rHtmlOpt, sizeof(rHtmlOpt));
                HtmlOptFromMailOpt(&rHtmlOpt, pmoi);
                if(FGetHTMLOptions(hwnd, &rHtmlOpt))
                {
                    MailOptFromHtmlOpt(&rHtmlOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;

        case idbtnSendIntl:
            if (codeNotify == BN_CLICKED)
                SetSendCharSetDlg(hwnd);
            break;
                
        case idbtnMailPlain:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rPlainOpt, sizeof(PLAINOPT));
                PlainOptFromMailOpt(&rPlainOpt, pmoi);
                if(FGetPlainOptions(hwnd, &rPlainOpt))
                {
                    MailOptFromPlainOpt(&rPlainOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idbtnNewsHTML:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rHtmlOpt, sizeof(rHtmlOpt));
                HtmlOptFromNewsOpt(&rHtmlOpt, pmoi);
                if(FGetHTMLOptions(hwnd, &rHtmlOpt))
                {
                    NewsOptFromHtmlOpt(&rHtmlOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idbtnNewsPlain:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rPlainOpt, sizeof(PLAINOPT));
            
                PlainOptFromNewsOpt(&rPlainOpt, pmoi);
                if(FGetPlainOptions(hwnd, &rPlainOpt))
                {
                    NewsOptFromPlainOpt(&rPlainOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idrbMailHTML:
        case idrbMailPlain:
        case idrbNewsHTML:
        case idrbNewsPlain:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_SEND);
            break;
                
    }
}


//
//  FUNCTION:   Send_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Send Tab.
//
LRESULT Send_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *pmoi = 0;
    DWORD    dw, dwOld;

    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        Assert(pmoi != NULL);
    
        // Send Options
        ButtonChkToOptInfo(hwnd, IDC_SAVE_CHECK, pmoi, OPT_SAVESENTMSGS);
        ButtonChkToOptInfo(hwnd, IDC_AUTOWAB_CHECK, pmoi, OPT_MAIL_AUTOADDTOWABONREPLY);
        ButtonChkToOptInfo(hwnd, IDC_USEAUTOCOMPLETE_CHECK, pmoi, OPT_USEAUTOCOMPLETE);
        ButtonChkToOptInfo(hwnd, IDC_INCLUDE_CHECK, pmoi, OPT_INCLUDEMSG);
        ButtonChkToOptInfo(hwnd, IDC_REPLY_IN_ORIGFMT, pmoi, OPT_REPLYINORIGFMT);
    
        // see if the send immediate option has changed from true->false, if so we
        // blow away the dontshow registry for sending to the outbox.
        dwOld = IDwGetOption(pmoi->pOpt, OPT_SENDIMMEDIATE);
        dw = (IsDlgButtonChecked(hwnd, IDC_SENDIMMEDIATE_CHECK) == BST_CHECKED);
        ISetDwOption(pmoi->pOpt, OPT_SENDIMMEDIATE, dw, NULL, 0);
        if (dwOld && !dw)
            SetDontShowAgain(0, (LPSTR) c_szDSSendMail);
    
        // Mail / News format
        ButtonChkToOptInfo(hwnd, idrbMailHTML, pmoi, OPT_MAIL_SEND_HTML);
        ButtonChkToOptInfo(hwnd, idrbNewsHTML, pmoi, OPT_NEWS_SEND_HTML);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}


/////////////////////////////////////////////////////////////////////////////
// Read Page
//

static const HELPMAP g_rgCtxMapMailRead[] = 
{
    {IDC_PREVIEW_CHECK,         IDH_MAIL_OPT_READ_MARK_READ},
    {IDC_MARKASREAD_EDIT,       IDH_MAIL_OPT_READ_MARK_READ},
    {IDC_MARKASREAD_SPIN,       IDH_MAIL_OPT_READ_MARK_READ},
    {idcStatic2,                IDH_MAIL_OPT_READ_MARK_READ},
    {idcDownloadChunks,         IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcStatic1,                IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcNumSubj,                IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcSpinNumSubj,            IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcAutoExpand,             IDH_NEWS_OPT_READ_AUTO_EXPAND},
    {idcAutoFillPreview,        IDH_NEWS_OPT_IN_PREVIEW},
    {idcMarkAllRead,            IDH_NEWS_OPT_READ_MARK_ALL_EXIT},
    {idcAutoInline,             IDH_OPTIONS_READ_SHOW_PICTURE_ATTACHMENTS},
    {idcAutoInlineSlide,        IDH_OPTIONS_READ_SHOW_SLIDESHOW},
    {IDC_FONTSETTINGS,          IDH_OPTIONS_READ_FONT_SETTINGS},
    {idcIntlButton,             IDH_OPTIONS_READ_INTL_SETTINGS},
    {idcTooltips,               502050},
    {IDC_WATCHED_COLOR,         35526},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic9,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_READ_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_READ_NEWS_ICON,        IDH_NEWS_COMM_GROUPBOX},
    {IDC_FONTS_ICON,            IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK ReadDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;    
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Read_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Read_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Read_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DRAWITEM:
            Color_WMDrawItem((LPDRAWITEMSTRUCT) lParam, iColorCombo);
            return (FALSE);

        case WM_MEASUREITEM:
        {
            LPMEASUREITEMSTRUCT pmis = (LPMEASUREITEMSTRUCT) lParam;
            HWND hwndColor = GetDlgItem(hwnd, IDC_WATCHED_COLOR);
            HDC hdc = GetDC(hwndColor);
            if (hdc)
            {
                Color_WMMeasureItem(hdc, pmis, iColorCombo);
                ReleaseDC(hwndColor, hdc);
            }

            return (TRUE);
        }

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_READ_ICON);
            FreeIcon(hwnd, IDC_READ_NEWS_ICON);
            FreeIcon(hwnd, IDC_FONTS_ICON);
            return (TRUE);
    }
    
    return(FALSE);
}

//
//  FUNCTION:   Read_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Read Tab on the options
//              property sheet.
//
BOOL Read_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD    dw;
    OPTINFO *pmoi = 0;
    
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Preview pane timer
    InitCheckCounterFromOptInfo(hwnd, IDC_PREVIEW_CHECK, IDC_MARKASREAD_EDIT, 
                                IDC_MARKASREAD_SPIN, pmoi, OPT_MARKASREAD);
    
    ButtonChkFromOptInfo(hwnd, idcAutoExpand, pmoi, OPT_AUTOEXPAND);
    ButtonChkFromOptInfo(hwnd, idcAutoFillPreview, pmoi, OPT_AUTOFILLPREVIEW);
    ButtonChkFromOptInfo(hwnd, idcTooltips, pmoi, OPT_MESSAGE_LIST_TIPS);
    ButtonChkFromOptInfo(hwnd, IDC_READ_IN_TEXT_ONLY, pmoi, OPT_READ_IN_TEXT_ONLY);

    // Watched color
    DWORD dwColor = DwGetOption(OPT_WATCHED_COLOR);
    HWND  hwndColor = GetDlgItem(hwnd, IDC_WATCHED_COLOR);

    SetIntlFont(hwndColor);

    // Create the color control
    HrCreateComboColor(hwndColor);
    Assert(dwColor <= 16);
    ComboBox_SetCurSel(hwndColor, dwColor);

    // Download 300 headers at a time
    InitCheckCounterFromOptInfo(hwnd, idcDownloadChunks, idcNumSubj, idcSpinNumSubj,
                                pmoi, OPT_DOWNLOADCHUNKS);    
    ButtonChkFromOptInfo(hwnd, idcMarkAllRead, pmoi, OPT_MARKALLREAD);
        
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_READING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_READ_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_READ_NEWS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_READ_NEWS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_FONTS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_FONTS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);    
}


//
//  FUNCTION:   Read_OnCommand()
//
//  PURPOSE:    Command handler for the Read tab on the Options
//              property sheet.
//
void Read_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    DWORD    dw, dwPreview, dwDownload;
    OPTINFO *pmoi = 0;
    BOOL     f;

    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (pmoi == NULL)
        return;
            
    switch (id)
    {
        case IDC_PREVIEW_CHECK:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_MARKASREAD_EDIT), f);
                EnableWindow(GetDlgItem(hwnd, IDC_MARKASREAD_SPIN), f);
            
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            }
            break;
        
        case idcAutoExpand:
        case idcAutoFillPreview:
        case idcMarkAllRead:
        case idcAutoInlineSlide:
        case idcTooltips:
        case IDC_READ_IN_TEXT_ONLY:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;

        case idcDownloadChunks:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, idcNumSubj), f);
                EnableWindow(GetDlgItem(hwnd, idcSpinNumSubj), f);
            
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            }
            break;

        case IDC_MARKASREAD_EDIT:
        case idcNumSubj:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;

        case IDC_FONTSETTINGS:
            ChangeFontSettings(hwnd);
            break;
                
        case idcIntlButton:
            if (codeNotify == BN_CLICKED)
                IntlCharsetMapDialogBox(hwnd);
            break;

        case IDC_WATCHED_COLOR:
            if (codeNotify == CBN_SELENDOK)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;
    }
}


//
//  FUNCTION:   Read_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Read Tab.
//
LRESULT Read_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    DWORD    dw, dwPreview, dwDownload;
    WORD     code;
    OPTINFO *pmoi = 0;
    BOOL     f;

    if (PSN_APPLY == pnmhdr->code)
    {
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(pmoi != NULL);
                    
        if (!GetCheckCounter(&dwPreview, hwnd, IDC_PREVIEW_CHECK, IDC_MARKASREAD_EDIT, IDC_MARKASREAD_SPIN))
            return (InvalidOptionProp(hwnd, IDC_MARKASREAD_EDIT, idsEnterPreviewTime, iddOpt_Read));
    
        if (!GetCheckCounter(&dwDownload, hwnd, idcDownloadChunks, idcNumSubj, idcSpinNumSubj))
            return (InvalidOptionProp(hwnd, idcNumSubj, idsEnterDownloadChunks, iddOpt_Read));
    
        ISetDwOption(pmoi->pOpt, OPT_MARKASREAD, dwPreview, NULL, 0);
        ISetDwOption(pmoi->pOpt, OPT_DOWNLOADCHUNKS, dwDownload, NULL, 0);
    
        ButtonChkToOptInfo(hwnd, idcAutoExpand, pmoi, OPT_AUTOEXPAND);
        ButtonChkToOptInfo(hwnd, idcAutoFillPreview, pmoi, OPT_AUTOFILLPREVIEW);
        ButtonChkToOptInfo(hwnd, idcMarkAllRead, pmoi, OPT_MARKALLREAD);
        ButtonChkToOptInfo(hwnd, idcTooltips, pmoi, OPT_MESSAGE_LIST_TIPS);
        ButtonChkToOptInfo(hwnd, IDC_READ_IN_TEXT_ONLY, pmoi, OPT_READ_IN_TEXT_ONLY);

        if (CB_ERR != (dw = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_WATCHED_COLOR))))
            ISetDwOption(pmoi->pOpt, OPT_WATCHED_COLOR, dw, NULL, 0);
    
        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

/////////////////////////////////////////////////////////////////////////////
// Security Page
//

const static HELPMAP g_rgCtxMapSec[] = 
{
    {IDC_SIGN_CHECK,            IDH_OPTIONS_ADD_DIGITAL_SIGNATURE},
    {IDC_ENCRYPT_CHECK,         IDH_OPTIONS_ENCRYPT_MESSAGES},
    {IDC_ADVSETTINGS_BUTTON,    IDH_OPTIONS_SECURITY_ADVANCED},
    {IDC_INTERNET_ZONE,         IDH_SECURITY_ZONES_SETTINGS},
    {IDC_RESTRICTED_ZONE,       IDH_SECURITY_ZONES_SETTINGS},
    {IDC_SENDMAIL_WARN_CHECK,   IDH_SECURITY_SENDMAIL_WARN},
    {IDC_SAFE_ATTACHMENT_CHECK, IDH_SECURITY_SAFE_ATTACHMENTS},
    {idbtnDigitalID,            IDH_GET_DIGITAL_ID},
    {idbtnMoreInfo,             IDH_MORE_ON_CERTIFICATES},
    {idbtnIDs,                  355544},
    {IDC_SEC_LABEL,             IDH_SECURITY_LABEL},
    {IDC_SELECT_LABEL,          IDH_SECURITY_SETLABEL},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_SECURITY_ZONE_ICON,    IDH_NEWS_COMM_GROUPBOX},
    {IDC_SECURE_MAIL_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
   
 
INT_PTR CALLBACK SecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Security_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapSec);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Security_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Security_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SECURITY_ZONE_ICON);
            FreeIcon(hwnd, IDC_SECURE_MAIL_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}


//
//  FUNCTION:   Security_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Security Tab on the options
//              property sheet.
//
BOOL Security_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *poi = 0;
    DWORD    dw;

    Assert(poi == NULL);
    poi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(poi != NULL);
    
    ButtonChkFromOptInfo(hwnd, IDC_SIGN_CHECK, poi, OPT_MAIL_DIGSIGNMESSAGES);
    ButtonChkFromOptInfo(hwnd, IDC_ENCRYPT_CHECK, poi, OPT_MAIL_ENCRYPTMESSAGES);
    ButtonChkFromOptInfo(hwnd, IDC_SENDMAIL_WARN_CHECK, poi, OPT_SECURITY_MAPI_SEND);
    ButtonChkFromOptInfo(hwnd, IDC_SAFE_ATTACHMENT_CHECK, poi, OPT_SECURITY_ATTACHMENT);

#ifdef FORCE_UNTRUSTED
    dw = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
    dw = IDwGetOption(poi->pOpt, OPT_SECURITYZONE);
#endif // FORCE_UNTRUSTED

    CheckDlgButton(hwnd, dw == URLZONE_INTERNET ? IDC_INTERNET_ZONE : IDC_RESTRICTED_ZONE, BST_CHECKED);
    if (DwGetOption(OPT_SECURITYZONELOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_INTERNET_ZONE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_RESTRICTED_ZONE), FALSE);
    }
    if (DwGetOption(OPT_SECURITY_MAPI_SEND_LOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SENDMAIL_WARN_CHECK), FALSE);
    }
    if (DwGetOption(OPT_SECURITY_ATTACHMENT_LOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SAFE_ATTACHMENT_CHECK), FALSE);
    }

    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SECURITYSETTINGS_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURITYSETTINGS_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SIGN_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ENCRYPT_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADVSETTINGS_BUTTON), FALSE);
#ifdef SMIME_V3
        EnableWindow(GetDlgItem(hwnd, IDC_SELECT_LABEL), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SEC_LABEL), FALSE);
#endif // SMIME_V3
        EnableWindow(GetDlgItem(hwnd, IDC_DIGITALIDS_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DIGITALIDS_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnDigitalID), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnIDs), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMoreInfo), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic5), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic6), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURE_MAIL_ICON), FALSE);
    }
    
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(poi->himl, ID_SECURITY_ZONE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SECURITY_ZONE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_SECURE_MAIL, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SECURE_MAIL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

#ifdef SMIME_V3
    if (!FPresentPolicyRegInfo()) 
    {
        ShowWindow(GetDlgItem(hwnd, IDC_SEC_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SELECT_LABEL), SW_HIDE);
    }
    else
        ButtonChkFromOptInfo(hwnd, IDC_SEC_LABEL, poi, OPT_USE_LABELS);

#endif // SMIME_V3

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);
}


//
//  FUNCTION:   Security_OnCommand()
//
//  PURPOSE:    Command handler for the Security tab on the Options
//              property sheet.
//
void Security_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *poi = 0;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (poi == NULL)
        return;
            
    switch (id)
    {
        case idbtnDigitalID:
            GetDigitalIDs(NULL);
            break;

        case idbtnIDs:
            ShowDigitalIDs(hwnd);
            break;

        case idbtnMoreInfo:
            if (codeNotify == BN_CLICKED)
            {
                OEHtmlHelp(hwnd, "%SYSTEMROOT%\\help\\msoe.chm>large_context", HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) "mail_overview_send_secure_messages.htm");
            }
            break;

        case IDC_INTERNET_ZONE:
        case IDC_RESTRICTED_ZONE:
        case IDC_SENDMAIL_WARN_CHECK:
        case IDC_SAFE_ATTACHMENT_CHECK:
        case IDC_SIGN_CHECK:
#ifdef SMIME_V3
        case IDC_SEC_LABEL:
#endif // SMIME_V3
        case IDC_ENCRYPT_CHECK:
            if (codeNotify == BN_CLICKED)
                PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

#ifdef SMIME_V3                
        case IDC_SELECT_LABEL:
            if (codeNotify == BN_CLICKED)
            {
                FGetSecLabel(hwnd, poi);
            }
            break;
#endif // SMIME_V3

        case IDC_ADVSETTINGS_BUTTON:
            if (codeNotify == BN_CLICKED)
                FGetAdvSecOptions(hwnd, poi);
            break;
    }
}


//
//  FUNCTION:   Security_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Security Tab.
//
LRESULT Security_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *poi;

    if (pnmhdr->code == PSN_APPLY)
    {
        // make sure something has changed
        poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(poi != NULL);

        // update the global options based on states of the controls
        ButtonChkToOptInfo(hwnd, IDC_SIGN_CHECK, poi, OPT_MAIL_DIGSIGNMESSAGES);
        ButtonChkToOptInfo(hwnd, IDC_ENCRYPT_CHECK, poi, OPT_MAIL_ENCRYPTMESSAGES);
        if (IsWindowEnabled(GetDlgItem(hwnd, IDC_SENDMAIL_WARN_CHECK)))
            ButtonChkToOptInfo(hwnd, IDC_SENDMAIL_WARN_CHECK, poi, OPT_SECURITY_MAPI_SEND);
        if (IsWindowEnabled(GetDlgItem(hwnd, IDC_SAFE_ATTACHMENT_CHECK)))
            ButtonChkToOptInfo(hwnd, IDC_SAFE_ATTACHMENT_CHECK, poi, OPT_SECURITY_ATTACHMENT);
#ifdef SMIME_V3
        ButtonChkToOptInfo(hwnd, IDC_SEC_LABEL, poi, OPT_USE_LABELS);
#endif

#ifdef FORCE_UNTRUSTED
        DWORD dwZone = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
        DWORD dwZone = URLZONE_INTERNET;

        if (IsDlgButtonChecked(hwnd, IDC_RESTRICTED_ZONE))
        {
            dwZone = URLZONE_UNTRUSTED;
        }
#endif // FORCE_UNTRUSTED

        ISetDwOption(poi->pOpt, OPT_SECURITYZONE, dwZone, NULL, 0);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

    
BOOL FGetAdvSecOptions(HWND hwndParent, OPTINFO *opie)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddAdvSecurity),
        hwndParent, AdvSecurityDlgProc, (LPARAM)opie)==IDOK);
}

#ifdef SMIME_V3
BOOL FGetSecLabel(HWND hwndParent, OPTINFO *opie)
{
    PSMIME_SECURITY_LABEL plabel = NULL;
    BOOL fRes = FALSE;

    HRESULT hr = HrGetOELabel(&plabel);

    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSelectLabel),
        hwndParent, SecurityLabelsDlgProc, (LPARAM) ((hr == S_OK) ? &plabel : NULL)) == IDOK)
    {
        hr = HrSetOELabel(plabel);
        if(hr == S_OK)
            fRes = TRUE;
    }

    // These two calls are temporary.
    SecPolicyFree(plabel);
    HrUnloadPolicyRegInfo(0);
    return (fRes);
}
#endif // SMIME_V3


/////////////////////////////////////////////////////////////////////////////
// Connection Page
//

static const HELPMAP g_rgCtxMapDialup[] = 
{
    {idcNoConnectionRadio,      IDH_OPTIONS_DIALUP_DONT_CONNECT},
    {idcDialUpCombo,            IDH_OPTIONS_DIALUP_CONNECTION_NUMBER},
    {idcDialRadio,              IDH_OPTIONS_DIALUP_CONNECTION_NUMBER},
    {idcPromptRadio,            IDH_OPTIONS_DIALUP_ASK},
    {idcSwitchCheck,            IDH_OPTIONS_DIALUP_WARN_BEFORE_SWITCHING},
    {idcHangupCheck,            IDH_OPTIONS_DIALUP_HANG_UP},
    {idcDialupButton,           25252596},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_DIAL_START_ICON,       IDH_NEWS_COMM_GROUPBOX},
    {IDC_INTERNET_DIAL_ICON,    IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
    
INT_PTR CALLBACK DialUpDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    HWND        hwndChangeButton;
    OPTINFO     *pmoi;
    
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    
    hwndChangeButton = GetDlgItem(hwnd, idcDialupButton);
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Dial_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapDialup);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Dial_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Dial_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_DIAL_START_ICON);
            FreeIcon(hwnd, IDC_INTERNET_DIAL_ICON);
            FreeIcon(hwnd, IDC_DIAL_ICON);

            if (IsWindow(GetDlgItem(hwnd, IDC_AUTODISCOVERY_ICON)))
            {
                FreeIcon(hwnd, IDC_AUTODISCOVERY_ICON);
            }
            return (TRUE);
    }
    
    return(FALSE);
}
    

//  FUNCTION:   Dial_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Dial Tab on the options
//              property sheet.
#define FEATURE_AUTODISCOVERY_DEFAULT                FALSE

BOOL Dial_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO     *pmoi = 0;
    DWORD       dwEnableAutodial = 0, dwsize = sizeof(DWORD);
    HICON hIcon;

    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);

    ButtonChkFromOptInfo(hwnd, idcSwitchCheck, pmoi, OPT_DIALUP_WARN_SWITCH);
    ButtonChkFromOptInfo(hwnd, idcHangupCheck, pmoi, OPT_DIALUP_HANGUP_DONE);

    EnableWindow(GetDlgItem(hwnd, idcSwitchCheck), IsRasInstalled());
    EnableWindow(GetDlgItem(hwnd, idcHangupCheck), IsRasInstalled());

    // Pictures
    hIcon = ImageList_GetIcon(pmoi->himl, ID_CONNECTION_START, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_DIAL_START_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_CONNECTION_INTERNET, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_INTERNET_DIAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);


#ifdef FEATURE_AUTODISCOVERY
    // Is the AutoDiscovery feature available?
    if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY_POLICY, SZ_REGVALUE_AUTODISCOVERY_POLICY, FALSE, TRUE))
    {
        // Yes, so load the state into the controls.
        SendDlgItemMessage(hwnd, IDC_AUTODISCOVERY_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
        CheckDlgButton(hwnd, idcAutoDiscovery, SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY, FALSE, FEATURE_AUTODISCOVERY_DEFAULT));
    }
    else
    {
        // No so remove the UI.
        DestroyWindow(GetDlgItem(hwnd, idcStatic7));
        DestroyWindow(GetDlgItem(hwnd, idcStatic8));
        DestroyWindow(GetDlgItem(hwnd, IDC_AUTODISCOVERY_ICON));
        DestroyWindow(GetDlgItem(hwnd, idcAutoDiscovery));
    }
#endif FEATURE_AUTODISCOVERY

    return(TRUE);
}


//
//  FUNCTION:   Dial_OnCommand()
//
//  PURPOSE:    Command handler for the Dial tab on the Options
//              property sheet.
//
void Dial_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO     *pmoi = 0;

    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (pmoi == NULL)
        return;
    
    switch (id)
    {
        case idcSwitchCheck:
        case idcHangupCheck:
        case idcAutoDiscovery:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_DIALUP);
            break;
        
        case idcDialupButton:
        {
            AssertSz(!!LaunchConnectionDialog, TEXT("LoadLibrary failed on INETCPL.CPL"));
        
            if (LaunchConnectionDialog != NULL)
            {
                LaunchConnectionDialog(hwnd);
            }
            break;
        }
    }        
}


//
//  FUNCTION:   Dial_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Dial Tab.
//
LRESULT Dial_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *pmoi = 0;

    if (PSN_APPLY == pnmhdr->code)
    {
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(pmoi != NULL);
        
        ButtonChkToOptInfo(hwnd, idcSwitchCheck, pmoi, OPT_DIALUP_WARN_SWITCH);
        ButtonChkToOptInfo(hwnd, idcHangupCheck, pmoi, OPT_DIALUP_HANGUP_DONE);

#ifdef FEATURE_AUTODISCOVERY
        // Is the AutoDiscovery feature available?
        if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY_POLICY, SZ_REGVALUE_AUTODISCOVERY_POLICY, FALSE, TRUE))
        {
            // Yes, so set the AutoDiscovery Option
            BOOL fAutoDiscoveryOn = IsDlgButtonChecked(hwnd, idcAutoDiscovery);
            LPCTSTR pszValue = (fAutoDiscoveryOn ? TEXT("TRUE") : TEXT("FALSE"));
            DWORD cbSize = ((lstrlen(pszValue) + 1) * sizeof(pszValue[0]));

            SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY, REG_SZ, (LPCVOID) pszValue, cbSize);
        }
#endif FEATURE_AUTODISCOVERY

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

/////////////////////////////////////////////////////////////////////////////
// Maintenance Page
//
const static HELPMAP g_rgCtxMapNOAdvnaced[] = 
{
    {idchDeleteMsgs,            IDH_DELETE_AFTER_XXDAYS},
    {idcStatic1,                IDH_DELETE_AFTER_XXDAYS},
    {ideDays,                   IDH_DELETE_AFTER_XXDAYS},
    {idspDays,                  IDH_DELETE_AFTER_XXDAYS},
    {idchDontCacheRead,         IDH_DELETE_READ},
    {ideCompactPer,             IDH_COMPACT_WHEN_WASTED},
    {idcStatic2,                IDH_COMPACT_WHEN_WASTED},
    {idcStatic3,                IDH_COMPACT_WHEN_WASTED},
    {idspCompactPer,            IDH_COMPACT_WHEN_WASTED},
    {idbManualCleanUp,          IDH_CLEAN_UP_BUTTON},
    {idcLogMailXport,           IDH_OPTIONS_MAIL_TRANSPORT},
    {idcLogNewsXport,           IDH_OPTIONS_NEWS_TRANSPORT},
    {idcLogNewsOffline,         IDH_OPTIONS_OFFLINE_LOG},
    {idcLogImapXport,           IDH_OPTIONS_IMAP_TRANSPORT},
    {idcLogHTTPMailXport,       355567},
    {IDC_STORE_LOCATION,        IDH_ADVANCED_STORE_FOLDER},
    {IDC_EMPTY_CHECK,           IDH_MAIL_OPT_READ_EMPTY_DELETED},
    {idcIMAPPurge,              502001},
    {IDC_BACKGROUND_COMPACTION, 502002},
    {IDC_STORE_LOCATION,        502003},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic9,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic10,               IDH_NEWS_COMM_GROUPBOX},
    {idcStatic11,               IDH_NEWS_COMM_GROUPBOX},
    {IDC_CLEANUP_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {IDC_TROUBLE_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK MaintenanceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Maintenance_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapNOAdvnaced);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Maintenance_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Maintenance_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_CLEANUP_ICON);
            FreeIcon(hwnd, IDC_TROUBLE_ICON);
            return (TRUE);
    }
        
    return 0;
}


//
//  FUNCTION:   Maintenance_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Maintenance Tab on the options
//              property sheet.
//
BOOL Maintenance_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO    *poi = 0;
    HICON       hIcon;

    poi = (OPTINFO *)((PROPSHEETPAGE *)lParam)->lParam;
    Assert(poi != NULL);
    
    ButtonChkFromOptInfo(hwnd, IDC_EMPTY_CHECK, poi, OPT_PURGEWASTE);
    ButtonChkFromOptInfo(hwnd, idcIMAPPurge, poi, OPT_IMAPPURGE);

    ButtonChkFromOptInfo(hwnd, IDC_BACKGROUND_COMPACTION, poi, OPT_BACKGROUNDCOMPACT);
    ButtonChkFromOptInfo(hwnd, idchDontCacheRead, poi, OPT_CACHEREAD);
    InitCheckCounterFromOptInfo(hwnd, idchDeleteMsgs, ideDays, idspDays,
                                poi, OPT_CACHEDELETEMSGS);
    InitCheckCounterFromOptInfo(hwnd, 0, ideCompactPer, idspCompactPer,
                                poi, OPT_CACHECOMPACTPER);

    if (0 == IDwGetOption(poi->pOpt, OPT_BACKGROUNDCOMPACT))
    {
        EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic1), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
    }
    
    ButtonChkFromOptInfo(hwnd, idcLogMailXport, poi, OPT_MAILLOG);
    ButtonChkFromOptInfo(hwnd, idcLogNewsXport, poi, OPT_NEWS_XPORT_LOG);
    ButtonChkFromOptInfo(hwnd, idcLogImapXport, poi, OPT_MAIL_LOGIMAP4);
    ButtonChkFromOptInfo(hwnd, idcLogHTTPMailXport, poi, OPT_MAIL_LOGHTTPMAIL);

    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, idcLogMailXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcLogImapXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcIMAPPurge), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcLogHTTPMailXport), FALSE);
    }
    
    // Hide these controls in mail-only mode
    if (g_dwAthenaMode & MODE_MAILONLY)
    {
        EnableWindow(GetDlgItem(hwnd, idcLogNewsXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic1), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbManualCleanUp), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic5), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic6), FALSE);
    }

    // HTTPMail accounts not visible unless the secret reg key exists
    if (!IsHTTPMailEnabled())
        ShowWindow(GetDlgItem(hwnd, idcLogHTTPMailXport), SW_HIDE);

    
    // Pictures
    hIcon = ImageList_GetIcon(poi->himl, ID_MAINTENANCE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_CLEANUP_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_TROUBLESHOOTING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_TROUBLE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    // Done
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);
}


//
//  FUNCTION:   Maintenance_OnCommand()
//
//  PURPOSE:    Command handler for the Maintenance tab on the Options
//              property sheet.
//
void Maintenance_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO    *poi;
    DWORD       dw;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (poi == NULL)
        return;
                
    switch(id)
    {
        case IDC_STORE_LOCATION:
            if (codeNotify == BN_CLICKED)
                DoStoreLocationDlg(hwnd);
            break;
                    
        case idbManualCleanUp:
            if (codeNotify == BN_CLICKED)
                DialogBox(g_hLocRes, MAKEINTRESOURCE(iddCacheMan), hwnd, CacheCleanUpDlgProc);
            break;

        case IDC_EMPTY_CHECK:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
            
        case idchDeleteMsgs:
            if (codeNotify == BN_CLICKED)
            {
                dw = BST_CHECKED == IsDlgButtonChecked(hwnd, id);
                EnableWindow(GetDlgItem (hwnd, ideDays), dw);
                EnableWindow(GetDlgItem (hwnd, idspDays), dw);
                
                SetPageDirty(poi, hwnd, PAGE_ADV);
            }
            break;
                    
        case ideCompactPer:
        case ideDays:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
                    
        case IDC_BACKGROUND_COMPACTION:
            if (codeNotify == BN_CLICKED)
            {
                dw = IsDlgButtonChecked(hwnd, id);
                EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), dw);
                EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), dw);
                EnableWindow(GetDlgItem(hwnd, ideDays), dw && IsDlgButtonChecked(hwnd, idchDeleteMsgs));
                EnableWindow(GetDlgItem(hwnd, idspDays), dw && IsDlgButtonChecked(hwnd, idchDeleteMsgs));
                EnableWindow(GetDlgItem(hwnd, idcStatic1), dw);
                EnableWindow(GetDlgItem(hwnd, idcStatic2), dw);
                EnableWindow(GetDlgItem(hwnd, ideCompactPer), dw);
                EnableWindow(GetDlgItem(hwnd, idspCompactPer), dw);
                EnableWindow(GetDlgItem(hwnd, idcStatic3), dw);
                SetPageDirty(poi, hwnd, PAGE_ADV);
            }
            break;

        case idchDontCacheRead:
        case idcLogNewsXport:
        case idcLogMailXport:
        case idcLogImapXport:
        case idcLogHTTPMailXport:
        case idcIMAPPurge:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
    }
}


//
//  FUNCTION:   Maintenance_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Maintenance Tab.
//
LRESULT Maintenance_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *poi;
    DWORD dwCompact, dwDelete;

    if (PSN_APPLY == pnmhdr->code)
    {
        poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(poi != NULL);
                        
        ButtonChkToOptInfo(hwnd, IDC_BACKGROUND_COMPACTION, poi, OPT_BACKGROUNDCOMPACT);

        // Startup or Shutdown background compaction!
        if (DwGetOption(OPT_BACKGROUNDCOMPACT))
            SideAssert(SUCCEEDED(StartBackgroundStoreCleanup(1)));
        else
            SideAssert(SUCCEEDED(CloseBackgroundStoreCleanup()));

        // Delete messages
        if (!GetCheckCounter(&dwDelete, hwnd, idchDeleteMsgs, ideDays, idspDays))
            return(InvalidOptionProp(hwnd, ideDays, idsEnterDays, iddOpt_Advanced));
                        
        // Disk space usage
        if (!GetCheckCounter(&dwCompact, hwnd, 0, ideCompactPer, idspCompactPer))
            return(InvalidOptionProp(hwnd, ideCompactPer, idsEnterCompactPer, iddOpt_Advanced));
        
        ISetDwOption(poi->pOpt, OPT_CACHEDELETEMSGS, dwDelete, NULL, 0);
        ISetDwOption(poi->pOpt, OPT_CACHECOMPACTPER, dwCompact, NULL, 0);
        
        // Cache read articles ?
        ISetDwOption(poi->pOpt, OPT_CACHEREAD, IsDlgButtonChecked(hwnd, idchDontCacheRead), NULL, 0);
        
        // IMAP Purge ?
        ISetDwOption(poi->pOpt, OPT_IMAPPURGE, IsDlgButtonChecked(hwnd, idcIMAPPurge), NULL, 0);
        
        // Logging?
        ButtonChkToOptInfo(hwnd, idcLogMailXport, poi, OPT_MAILLOG);
        ButtonChkToOptInfo(hwnd, idcLogNewsXport, poi, OPT_NEWS_XPORT_LOG);
        ButtonChkToOptInfo(hwnd, idcLogImapXport, poi, OPT_MAIL_LOGIMAP4);
        ButtonChkToOptInfo(hwnd, idcLogHTTPMailXport, poi, OPT_MAIL_LOGHTTPMAIL);
        ButtonChkToOptInfo(hwnd, IDC_EMPTY_CHECK, poi, OPT_PURGEWASTE);

        // Done
        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

    
/////////////////////////////////////////////////////////////////////////////
// Compose Tab 
//

static const HELPMAP g_rgCtxMapCompose[] = {
    {IDC_MAIL_FONT_DEMO,        35585},
    {IDC_NEWS_FONT_DEMO,        35585},
    {IDC_MAIL_FONT_SETTINGS,    35560},
    {IDC_NEWS_FONT_SETTINGS,    35560},
    {IDC_USE_MAIL_STATIONERY,   35587},
    {IDC_USE_NEWS_STATIONERY,   35587},
    {IDC_MAIL_STATIONERY,       35586},
    {IDC_NEWS_STATIONERY,       35586},
    {IDC_SELECT_MAIL,           35575},
    {IDC_SELECT_NEWS,           35575},
    {IDC_DOWNLOAD_MORE,         35650},
    {IDC_MAIL_VCARD,            35611},
    {IDC_NEWS_VCARD,            35611},
    {IDC_EDIT_MAIL_VCARD,       35620},
    {IDC_EDIT_NEWS_VCARD,       35620},
    {IDC_CREATE_NEW,            35632},
    {IDC_MAIL_VCARD_SELECT,     35630},
    {IDC_NEWS_VCARD_SELECT,     35630},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_FONT_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_STATIONERY_ICON,       IDH_NEWS_COMM_GROUPBOX},
    {IDC_VCARD_ICON,            IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK ComposeDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Compose_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapCompose);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Compose_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Compose_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_FONT_ICON);
            FreeIcon(hwnd, IDC_STATIONERY_ICON);
            FreeIcon(hwnd, IDC_VCARD_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}
    

//
//  FUNCTION:   Compose_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Compose Tab on the options
//              property sheet.
//
BOOL Compose_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    TCHAR    szBuf[CCHMAX_STRINGRES] = "";
    DWORD    dw;
    DWORD    cch;
    HWND     hwndT;
    FARPROC  pfnFontSampleWndProc;
    HRESULT  hr;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);

    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);

    // Compose Font Settings
    hwndT = GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO);
    pfnFontSampleWndProc = (FARPROC) SetWindowLongPtrAthW(hwndT, GWLP_WNDPROC, (LPARAM) FontSampleSubProc);
    SetWindowLongPtr(hwndT, GWLP_USERDATA, (LPARAM) pfnFontSampleWndProc);

    
    hwndT = GetDlgItem(hwnd, IDC_NEWS_FONT_DEMO);
    pfnFontSampleWndProc = (FARPROC) SetWindowLongPtrAthW(hwndT, GWLP_WNDPROC, (LPARAM) FontSampleSubProc);
    SetWindowLongPtr(hwndT, GWLP_USERDATA, (LPARAM) pfnFontSampleWndProc);

    // Mail Stationery
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_USESTATIONERY);
    SendDlgItemMessage(hwnd, IDC_USE_MAIL_STATIONERY, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), !!dw);
    hr = GetDefaultStationeryName(TRUE, g_wszMailStationery);
    _SetThisStationery(hwnd, TRUE, SUCCEEDED(hr) ? g_wszMailStationery : NULL, pmoi);

    // News Stationery
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_USESTATIONERY);
    SendDlgItemMessage(hwnd, IDC_USE_NEWS_STATIONERY, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_SELECT_NEWS), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_NEWS_STATIONERY), !!dw);
    hr = GetDefaultStationeryName(FALSE, g_wszNewsStationery);
    _SetThisStationery(hwnd, FALSE, SUCCEEDED(hr) ? g_wszNewsStationery : NULL, pmoi);

    // Mail VCard
    hwndT = GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT);
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_ATTACHVCARD);
    IGetOption(pmoi->pOpt, OPT_MAIL_VCARDNAME, szBuf, sizeof(szBuf));
    SetIntlFont(hwndT);
    LoadVCardList(hwndT, szBuf);
    cch = GetWindowTextLength(hwndT);
    if (cch == 0)
        dw = 0;

    SendDlgItemMessage(hwnd, IDC_MAIL_VCARD, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), (cch && dw));
        
    // News VCard
    hwndT = GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT);
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_ATTACHVCARD);
    IGetOption(pmoi->pOpt, OPT_NEWS_VCARDNAME, szBuf, sizeof(szBuf));
    SetIntlFont(hwndT);
    LoadVCardList(hwndT, szBuf);
    cch = GetWindowTextLength(hwndT);
    if (cch == 0)
        dw = 0;

    SendDlgItemMessage(hwnd, IDC_NEWS_VCARD, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), (cch && dw));

    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_FONTS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_FONT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_STATIONERY_ICON, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_STATIONERY_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_VCARD, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_VCARD_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
//    if(!!(g_dwAthenaMode & MODE_OUTLOOKNEWS))
    if(!!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        //Disable all the mail stuff
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FONT_SETTINGS), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_USE_MAIL_STATIONERY), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), FALSE);
    }

    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   Compose_OnCommand()
//
//  PURPOSE:    Command handler for the Compose tab on the Options
//              property sheet.
//
void Compose_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    HWND     hwndT;
    TCHAR    szBuf[MAX_PATH];
    WCHAR    wszBuf[MAX_PATH];
    DWORD    cch = 0;
    int      i;
    BOOL     f2;
    TCHAR    szURL[2048];

    *szBuf = 0;
    *wszBuf = 0;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_MAIL_FONT_SETTINGS:
        case IDC_NEWS_FONT_SETTINGS:
            if (ChangeSendFontSettings(pmoi, id == IDC_MAIL_FONT_SETTINGS, hwnd))
            {
                hwndT = GetDlgItem(hwnd, id == IDC_MAIL_FONT_SETTINGS ? IDC_MAIL_FONT_DEMO : IDC_NEWS_FONT_DEMO);
                InvalidateRect(hwndT, NULL, TRUE);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_USE_MAIL_STATIONERY:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            if( !f )
            {
                SetWindowTextWrapW(GetDlgItem(hwnd,IDC_MAIL_STATIONERY), c_wszEmpty);
                StrCpyW(g_wszMailStationery, c_wszEmpty);
            }
            EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), f);
            EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_USE_NEWS_STATIONERY:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            if( !f )
            {
                SetWindowTextWrapW(GetDlgItem(hwnd,IDC_NEWS_STATIONERY), c_wszEmpty);
                StrCpyW(g_wszNewsStationery, c_wszEmpty);
            }
            EnableWindow(GetDlgItem(hwnd, IDC_SELECT_NEWS), f);
            EnableWindow(GetDlgItem(hwnd, IDC_NEWS_STATIONERY), f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_SELECT_MAIL:
            hwndT = GetDlgItem(hwnd, IDC_MAIL_STATIONERY);
            cch = GetWindowTextWrapW(hwndT, wszBuf, ARRAYSIZE(wszBuf)-1);
            wszBuf[cch] = 0;
            
            if( HR_SUCCEEDED(HrGetMoreStationeryFileName( hwnd, g_wszMailStationery)) )
            {
                GetStationeryFullName(g_wszMailStationery);
                
                _SetThisStationery(hwnd, TRUE, g_wszMailStationery, pmoi);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_SELECT_NEWS:
            hwndT = GetDlgItem(hwnd, IDC_NEWS_STATIONERY);
            cch = GetWindowText(hwndT, szBuf, sizeof(szBuf)-1);
            szBuf[cch] = 0;
            
            if( HR_SUCCEEDED(HrGetMoreStationeryFileName(hwnd, g_wszNewsStationery)) )
            {
                GetStationeryFullName(g_wszNewsStationery);
                
                _SetThisStationery(hwnd, FALSE, g_wszNewsStationery, pmoi);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_MAIL_VCARD:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            f2 = (SendDlgItemMessage(hwnd, IDC_MAIL_VCARD_SELECT, CB_GETCURSEL, 0, 0) != CB_ERR);
            EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), f);
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), f2 && f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_NEWS_VCARD:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            f2 = (SendDlgItemMessage(hwnd, IDC_NEWS_VCARD_SELECT, CB_GETCURSEL, 0, 0) != CB_ERR);
            EnableWindow(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT), f);
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), f && f2);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_MAIL_VCARD_SELECT:
            if (codeNotify == CBN_SELENDOK)
            {
                f = (SendMessage(hwndCtl, CB_GETCURSEL, 0, 0) != CB_ERR);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), f);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_NEWS_VCARD_SELECT:
            if (codeNotify == CBN_SELENDOK)
            {
                f = (SendMessage(hwndCtl, CB_GETCURSEL, 0, 0) != CB_ERR);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), f);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_EDIT_MAIL_VCARD:
            VCardEdit(hwnd, IDC_MAIL_VCARD_SELECT, IDC_NEWS_VCARD_SELECT);
            break;

        case IDC_EDIT_NEWS_VCARD:
            VCardEdit(hwnd, IDC_NEWS_VCARD_SELECT, IDC_MAIL_VCARD_SELECT);
            break;

        case IDC_DOWNLOAD_MORE:
            if (SUCCEEDED(URLSubLoadStringA(idsShopMoreStationery, szURL, ARRAYSIZE(szURL), URLSUB_ALL, NULL)))
                ShellExecute(NULL, "open", szURL, NULL, NULL, SW_SHOWNORMAL);
            break;

        case IDC_CREATE_NEW:
            CStatWiz* pStatWiz = 0;
            pStatWiz = new CStatWiz();
            if (pStatWiz)
            {
                pStatWiz->DoWizard(hwnd);
                ReleaseObj(pStatWiz);
            }
            break;
    }                
}


//
//  FUNCTION:   Compose_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Compose Tab.
//
LRESULT Compose_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    TCHAR    szBuf[MAX_PATH];
    DWORD    cch;

    if (PSN_SETACTIVE == pnmhdr->code)
    {
        InvalidateRect(GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO), NULL, TRUE);
        InvalidateRect(GetDlgItem(hwnd, IDC_NEWS_FONT_DEMO), NULL, TRUE);
        return TRUE;
    }
                
    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // Stationery options
        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_USE_MAIL_STATIONERY))
        {
            // Make sure the user has selected some stationery
            if (0 == GetDlgItemText(hwnd, IDC_MAIL_STATIONERY, szBuf, sizeof(szBuf)))
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsStationery),
                              MAKEINTRESOURCEW(idsSelectStationery),
                              NULL, MB_OK | MB_ICONEXCLAMATION);
            
                SetFocus(GetDlgItem(hwnd, IDC_SELECT_MAIL));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_USE_NEWS_STATIONERY))
        {
            if (0 == GetDlgItemText(hwnd, IDC_NEWS_STATIONERY, szBuf, sizeof(szBuf)))
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsStationery),
                              MAKEINTRESOURCEW(idsSelectStationery),
                              NULL, MB_OK | MB_ICONEXCLAMATION);
                
                SetFocus(GetDlgItem(hwnd, IDC_SELECT_NEWS));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }            
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_MAIL_VCARD))
        {
            cch = GetWindowTextLength(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT));
            if (cch == 0)
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsChooseName),
                    NULL, MB_OK | MB_ICONEXCLAMATION);

                SetFocus(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_NEWS_VCARD))
        {
            cch = GetWindowTextLength(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT));
            if (cch == 0)
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsChooseName),
                    NULL, MB_OK | MB_ICONEXCLAMATION);

                SetFocus(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        SetDefaultStationeryName(TRUE, g_wszMailStationery);
        ButtonChkToOptInfo(hwnd, IDC_USE_MAIL_STATIONERY, pmoi, OPT_MAIL_USESTATIONERY);

        SetDefaultStationeryName(FALSE, g_wszNewsStationery);
        ButtonChkToOptInfo(hwnd, IDC_USE_NEWS_STATIONERY, pmoi, OPT_NEWS_USESTATIONERY);

        UpdateVCardOptions(hwnd, TRUE, pmoi);
        UpdateVCardOptions(hwnd, FALSE, pmoi);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }
    
    return (FALSE);
}


void InitIndentOptions(CHAR chIndent, HWND hwnd, UINT idCheck, UINT idCombo)
{
    TCHAR szQuote[2], *sz;
    BOOL f;
    int isel;
    HWND hDlg=GetDlgItem(hwnd, idCombo);
    
    f = (chIndent != INDENTCHAR_NONE);
    CheckDlgButton(hwnd, idCheck, f ? BST_CHECKED : BST_UNCHECKED);
    EnableWindow(hDlg, f);
    
    // initialize the quote char combo
    if (!f)
        chIndent = DEF_INDENTCHAR;
    isel = 0;
    szQuote[1] = 0;
    sz = (TCHAR *)c_szQuoteChars;
    while (*sz != NULL)
    {
        *szQuote = *sz;
        SendMessage(hDlg, CB_ADDSTRING, 0, (LPARAM)szQuote);
        if (*szQuote == chIndent)
            SendMessage(hDlg, CB_SETCURSEL, (WPARAM)isel, 0);
        isel++;
        sz++;
    }
}

    
    
void FillEncodeCombo(HWND hwnd, BOOL fHTML, ENCODINGTYPE ietEncoding)
{
    TCHAR   sz[CCHMAX_STRINGRES];
    INT     i;
    
    // $$TODO$ Someday we should allow NONE as a text encoding type for HTML, but we must fix our line wrapping first.
    // None
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    if (!fHTML)
#endif
    {
        LoadString(g_hLocRes, idsNone, sz, CCHMAX_STRINGRES);
        i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
        SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_7BIT);
    }
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    else
        Assert(ietEncoding != IET_7BIT);
#endif
    
    // QuotedPrintable
    LoadString(g_hLocRes, idsQuotedPrintable, sz, CCHMAX_STRINGRES);
    i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
    SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_QP);
    
    // Base64
    LoadString(g_hLocRes, idsBase64, sz, CCHMAX_STRINGRES);
    i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
    SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_BASE64);
    
    // Select current - will default to QP if HTML is TRUE
    if (ietEncoding == IET_7BIT)
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)0, 0);
    
    else if (ietEncoding == IET_QP)
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)fHTML ? 0 : 1, 0);
#else
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)1, 0);
#endif
    
    if (ietEncoding == IET_BASE64)
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)fHTML ? 0 : 2, 0);
#else
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)2, 0);
#endif
}

VOID MailEnableWraps(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_TEXT1), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_TEXT2), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_SPIN), fEnable);
}



const static int c_rgidsFilter[] =
{
    idsTextFileFilter,
        idsHtmlFileFilter,
        idsAllFilesFilter
};
#define CSIGFILTER  (sizeof(c_rgidsFilter) / sizeof(int))

///Signature tab
const static HELPMAP g_rgCtxMapStationery[] = {
    {IDC_SENDFONTSETTINGS, IDH_STATIONERY_FONT_SETTINGS},
    {IDC_RADIOMYFONT, IDH_STATIONERY_MY_FONT},
    {IDC_RADIOUSETHIS, IDH_STATIONERY_USE_STATIONERY},
    {IDC_SELECT, IDH_STATIONERY_SELECT},
    {IDC_VCARD_CHECK, IDH_STATIONERY_ATTACH_BUSINESS_CARD},
    {IDC_VCARD_COMBO, IDH_STATIONERY_ENTER_BUSINESS_CARD},
    {IDC_VCARD_BUTTON_EDIT, IDH_STATIONERY_EDIT_BUSINESS_CARD},
    {IDC_VCARD_BUTTON_NEW, IDH_STATIONERY_NEW_BUSINESS_CARD},
    {0, 0}};
    
    


LRESULT CALLBACK FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    OPTINFO     *pmoi;
    WNDPROC     pfn;
    HDC         hdc;
    PAINTSTRUCT ps;
    
    pmoi = (OPTINFO *)GetWindowLongPtr(GetParent(hwnd), DWLP_USER);
    Assert(pmoi);
    
    if (msg == WM_PAINT)
    {
        hdc=BeginPaint (hwnd, &ps);
        PaintFontSample(hwnd, hdc, pmoi);
        EndPaint (hwnd, &ps);
        return(0);
    }
    
    pfn = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    Assert(pfn != NULL);
    return(CallWindowProcWrapW(pfn, hwnd, msg, wParam, lParam));
}

typedef struct tagFONTOPTIONS
{
    PROPID color;
    PROPID size;
    PROPID bold;
    PROPID italic;
    PROPID underline;
    PROPID face;
} FONTOPTIONS;

static const FONTOPTIONS c_rgFontOptions[2] =
{
    {
        OPT_MAIL_FONTCOLOR,
        OPT_MAIL_FONTSIZE,
        OPT_MAIL_FONTBOLD,
        OPT_MAIL_FONTITALIC,
        OPT_MAIL_FONTUNDERLINE,
        OPT_MAIL_FONTFACE
    },
    {
        OPT_NEWS_FONTCOLOR,
        OPT_NEWS_FONTSIZE,
        OPT_NEWS_FONTBOLD,
        OPT_NEWS_FONTITALIC,
        OPT_NEWS_FONTUNDERLINE,
        OPT_NEWS_FONTFACE
    }
};

void PaintFontSample(HWND hwnd, HDC hdc, OPTINFO *pmoi)
{
    int                 dcSave=SaveDC(hdc);
    RECT                rc;
    const FONTOPTIONS   *pfo;
    SIZE                rSize;
    INT                 x, y, cbSample;
    HFONT               hFont, hOldFont;
    LOGFONT             lf={0};
    TCHAR               szBuf[LF_FACESIZE+1];
    WCHAR               wszRes[CCHMAX_STRINGRES],
                        wsz[CCHMAX_STRINGRES],
                        wszFontFace[CCHMAX_STRINGRES];
    DWORD               dw, dwSize;
    BOOL                fBold=FALSE,
                        fItalic=FALSE,
                        fUnderline=FALSE;    
    BOOL                fMail;

    *szBuf = 0;
    *wszRes = 0;
    *wsz = 0;

    fMail = GetWindowLong(hwnd, GWL_ID) == IDC_MAIL_FONT_DEMO;
    pfo = fMail ? &c_rgFontOptions[0] : &c_rgFontOptions[1];
    
    dwSize = IDwGetOption(pmoi->pOpt, pfo->size);
    if (dwSize < 8 || dwSize > 72)
    {
        ISetDwOption(pmoi->pOpt, pfo->size, DEFAULT_FONTPIXELSIZE, NULL, 0);
        
        dwSize = DEFAULT_FONTPIXELSIZE;
    }
    
    INT yPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    lf.lfHeight =-(INT)((9*10*2*yPerInch)/1440);
    
    fBold = IDwGetOption(pmoi->pOpt, pfo->bold);
    fItalic = IDwGetOption(pmoi->pOpt, pfo->italic);
    fUnderline = IDwGetOption(pmoi->pOpt, pfo->underline);
    
    lf.lfWeight = fBold ? FW_BOLD : FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DRAFT_QUALITY;
    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfItalic = !!fItalic;
    lf.lfUnderline = !!fUnderline;
    
    IGetOption(pmoi->pOpt, pfo->face, szBuf, sizeof(szBuf));
    
    if (*szBuf != 0)
        lstrcpy(lf.lfFaceName, szBuf);
    else
    {
        if(LoadString(g_hLocRes, idsComposeFontFace, szBuf, LF_FACESIZE))
        {
            lstrcpy(lf.lfFaceName, szBuf);
            
            ISetOption(pmoi->pOpt, pfo->face, szBuf, lstrlen(szBuf) + 1, NULL, 0);
        }        
    }
    
    hFont=CreateFontIndirect(&lf);
    hOldFont = (HFONT)SelectObject (hdc, hFont);
    
    GetClientRect(hwnd, &rc);
    FillRect (hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
    // pull in the drawing rect by 2 pixels all around
    InflateRect(&rc, -2, -2);
    SetBkMode (hdc, TRANSPARENT);  // So the background shows through the text.
    
    dw = IDwGetOption(pmoi->pOpt, pfo->color);
    SetTextColor (hdc, dw);
    
    LoadStringWrapW(g_hLocRes, idsFontSampleFmt, wszRes, ARRAYSIZE(wszRes));

    *wszFontFace = 0;
    MultiByteToWideChar(CP_ACP, 0, lf.lfFaceName, -1, wszFontFace, ARRAYSIZE(wszFontFace));

    AthwsprintfW(wsz, ARRAYSIZE(wsz), wszRes, dwSize, wszFontFace);
    GetTextExtentPoint32AthW(hdc, wsz, lstrlenW(wsz), &rSize, NOFLAGS);
    x = rc.left + (((rc.right-rc.left) / 2) - (rSize.cx / 2));
    y = rc.top + (((rc.bottom-rc.top) / 2) - (rSize.cy / 2));
    ExtTextOutWrapW(hdc, x, y, ETO_CLIPPED, &rc, wsz, lstrlenW(wsz), NULL);
    DeleteObject(SelectObject (hdc, hOldFont));
    RestoreDC(hdc, dcSave);
}


VOID LoadVCardList(HWND hwndCombo, LPTSTR lpszDisplayName)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    int             cRows = 0;
    DWORD           dwIndex=0;
    
    if(hwndCombo==0)
        return;
    
    ComboBox_ResetContent(hwndCombo);
    
    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;
    
    //load names into the combobox from personal address book
    hr = lpWab->HrFillComboWithPABNames(hwndCombo, &cRows);
    if(FAILED(hr))
        goto error;
    
    if(lpszDisplayName)
        dwIndex = ComboBox_SelectString(hwndCombo, -1, lpszDisplayName);
    
error:
    ReleaseObj(lpWab);
}
    
BOOL UpdateVCardOptions(HWND hwnd, BOOL fMail, OPTINFO* pmoi)
{
    HWND    hDlg;
    DWORD   dw;
    int     cch;
    TCHAR*  sz;
    
    dw = ButtonChkToOptInfo(hwnd, fMail ? IDC_MAIL_VCARD : IDC_NEWS_VCARD, pmoi, fMail ? OPT_MAIL_ATTACHVCARD : OPT_NEWS_ATTACHVCARD);
    
    hDlg = GetDlgItem(hwnd, fMail ? IDC_MAIL_VCARD_SELECT : IDC_NEWS_VCARD_SELECT);
    cch = GetWindowTextLength(hDlg);
    Assert(dw == 0 || cch > 0);
    
    cch++;
    if (!MemAlloc((void **)&sz, cch * sizeof(TCHAR)))
        return(TRUE);
    
    cch = ComboBox_GetText(hDlg, sz, cch) + 1;
    ISetOption(pmoi->pOpt, fMail ? OPT_MAIL_VCARDNAME : OPT_NEWS_VCARDNAME, sz, cch, NULL, 0);
    
    MemFree(sz);    
    return(FALSE);
}
    
// The rest of file is in options2.cpp
HRESULT VCardNewEntry(HWND hwnd)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH] = {0};
    HWND            hwndCombo = NULL;
    UINT            cb = 0;
    
    hwndCombo = GetDlgItem(hwnd, IDC_VCARD_COMBO);
    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;
    
    //load names into the combobox from personal address book
    hr = lpWab->HrNewEntry(hwnd, szName);
    if(FAILED(hr))
        goto error;
    
    // reload the vcard list.
    LoadVCardList(hwndCombo, szName);
    
error:
    ReleaseObj(lpWab);
    return hr;
}
    
HRESULT VCardEdit(HWND hwnd, DWORD idc, DWORD idcOther)
{
    HWND            hwndCombo, hwndOther;
    HRESULT         hr;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH], szPrev[MAX_PATH], szOther[MAX_PATH];
    UINT            cb;
    
    hwndCombo = GetDlgItem(hwnd, idc);
    cb = GetWindowText(hwndCombo, szName, sizeof(szName));
    Assert(cb > 0);
    lstrcpy(szPrev, szName);

    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        return(hr);
    
    //load names into the combobox from personal address book
    hr = lpWab->HrEditEntry(hwnd, szName);
    if(SUCCEEDED(hr))
    {
        if (0 != lstrcmp(szName, szPrev))
        {
            hwndOther = GetDlgItem(hwnd, idcOther);
            cb = GetWindowText(hwndOther, szOther, ARRAYSIZE(szOther));
            if (cb > 0)
            {
                if (0 == lstrcmp(szOther, szPrev))
                    LoadVCardList(hwndOther, szName);
                else
                    LoadVCardList(hwndOther, szOther);
            }            
            else
            {
                LoadVCardList(hwndOther, NULL);
            }

            // reload the vcard list.
            LoadVCardList(hwndCombo, szName);
        }
    }
    
    ReleaseObj(lpWab);
    return hr;
}

void _SetThisStationery(HWND hwnd, BOOL fMail, LPWSTR wsz, OPTINFO* pmoi)
{
    HWND        hDlg;
    WCHAR       wszBuf[MAX_PATH];
    WCHAR       wszCompact[MAX_SHOWNAME+1];
    
    *wszBuf = 0;
    *wszCompact = 0;

    hDlg = GetDlgItem(hwnd, fMail ? IDC_MAIL_STATIONERY : IDC_NEWS_STATIONERY);
    SetIntlFont(hDlg);
    if (wsz != NULL)
    {
        StrCpyW(wszBuf, wsz);
        GetStationeryFullName(wszBuf);
        if (*wszBuf == 0)
            goto reset;
        
        StripStationeryDir(wszBuf);
        PathRemoveExtensionW(wszBuf);
        PathCompactPathExW(wszCompact, wszBuf, MAX_SHOWNAME, 0);
        SetWindowTextWrapW(hDlg, wszCompact);
        return;
    }
    
reset:
    SetDefaultStationeryName(fMail, wszBuf);
    ISetDwOption(pmoi->pOpt, fMail ? OPT_MAIL_USESTATIONERY :  OPT_NEWS_USESTATIONERY, 
                 FALSE, NULL, 0);

    SetWindowText(hDlg, "");
    return;
}

INT_PTR CALLBACK CacheCleanUpDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    FOLDERINFO Folder;
    FOLDERID idFolder;
    RECURSEFLAGS dwRecurse=RECURSE_INCLUDECURRENT | RECURSE_ONLYSUBSCRIBED | RECURSE_SUBFOLDERS | RECURSE_NOLOCALSTORE;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
        
            // Initialzie the Folder Combo Box
            InitFolderPickerEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER), FOLDERID_ROOT);
        
            // Display Folder Size Info
            DisplayFolderSizeInfo(hwnd, dwRecurse, FOLDERID_ROOT);
        
            // Done
            return 1;
        
        case WM_DESTROY:
            return 0;
        
        case WM_CLOSE:
            EndDialog(hwnd, IDOK);
            return 1;
        
        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam,lParam))
            {
                case IDCANCEL:
                    SendMessage (hwnd, WM_CLOSE, 0, 0);
                    return 1;
            
                case IDC_FOLDER_BROWSE:
                    if (GET_WM_COMMAND_CMD(wParam,lParam) == BN_CLICKED)
                    {
                        // Pick a Folder
                        if (SUCCEEDED(PickFolderInEdit(hwnd, GetDlgItem(hwnd, IDC_CACHE_FOLDER), TREEVIEW_NOLOCAL, NULL, NULL, &idFolder)))
                        {
                            // Display Folder Size Info
                            DisplayFolderSizeInfo(hwnd, dwRecurse, idFolder);
                        }
                    }
                    return 1;
            
                case idbCompactCache:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER)), &Folder)))
                    {
                        CleanupFolder(hwnd, dwRecurse, Folder.idFolder, CLEANUP_COMPACT);
                        DisplayFolderSizeInfo(hwnd, dwRecurse, Folder.idFolder);
                        g_pStore->FreeRecord(&Folder);
                    }
                    return 1;
            
                case idbRemove:
                case idbDelete:
                case idbReset:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER)), &Folder)))
                    {
                        // Locals
                        CHAR szRes[255];
                        CHAR szMsg[255 + 255];
                
                        // Get Command
                        UINT                idCommand=GET_WM_COMMAND_ID(wParam, lParam);
                        UINT                idString;
                        CLEANUPFOLDERTYPE   tyCleanup;
                
                        // Remove
                        if (idbRemove == idCommand)
                            tyCleanup = CLEANUP_REMOVEBODIES;
                        else if (idbDelete == idCommand)
                            tyCleanup = CLEANUP_DELETE;
                        else
                            tyCleanup = CLEANUP_RESET;
                
                        // Root
                        if (FOLDERID_ROOT == Folder.idFolder)
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodiesAll;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgsAll;
                            else
                                idString = idsConfirmResetAll;
                    
                            // Confirm
                            if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idString), NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Server
                        else if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodiesStore;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgsStore;
                            else
                                idString = idsConfirmResetStore;
                    
                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
                    
                            // Format with the Folder Name
                            wsprintf(szMsg, szRes, Folder.pszName);
                    
                            // Confirm
                            if (IDNO == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Folder
                        else
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodies;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgs;
                            else
                                idString = idsConfirmReset;
                    
                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
                    
                            // Format with the Folder Name
                            wsprintf(szMsg, szRes, Folder.pszName);
                    
                            // Confirm
                            if (IDNO == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Recurse
                        CleanupFolder(hwnd, dwRecurse, Folder.idFolder, tyCleanup);
                
                        // Display Folder Size Info
                        DisplayFolderSizeInfo(hwnd, dwRecurse, (FOLDERID)Folder.idFolder);
                
                        // Cleanup
                        g_pStore->FreeRecord(&Folder);
                    }
                    return 1;
            
                case IDOK:
                    EndDialog(hwnd, IDOK);
                    return 1;
            }
            break;
    }
    
    return 0;
}

// before calling always ensure poi contains valid HTML settings
// else we assert...
void HtmlOptFromMailOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    pHtmlOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_ENCODE);
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    AssertSz(pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64, "Illegal HTML encoding type");
#endif
    pHtmlOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_ALLOW_8BIT);
    pHtmlOpt->fSendImages = IDwGetOption(poi->pOpt, OPT_MAIL_SENDINLINEIMAGES);
    pHtmlOpt->uWrap = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_LINE_WRAP);
    pHtmlOpt->fIndentReply = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_INDENT_REPLY);
}

void MailOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_ENCODE, (DWORD)pHtmlOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_ALLOW_8BIT, pHtmlOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_SENDINLINEIMAGES, pHtmlOpt->fSendImages, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_LINE_WRAP, pHtmlOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_INDENT_REPLY, pHtmlOpt->fIndentReply, NULL, 0);
}

void PlainOptFromMailOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    pPlainOpt->fMime = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_MIME);
    pPlainOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ENCODE);
    pPlainOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ALLOW_8BIT);
    pPlainOpt->uWrap = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_LINE_WRAP);
    pPlainOpt->chQuote = (CHAR)IDwGetOption(poi->pOpt, OPT_MAILINDENT);
}

void MailOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_MIME, pPlainOpt->fMime, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ENCODE, (DWORD)pPlainOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ALLOW_8BIT, pPlainOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_LINE_WRAP, pPlainOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAILINDENT, pPlainOpt->chQuote, NULL, 0);
}

// before calling always ensure poi contains valid HTML settings
// else we assert...
void HtmlOptFromNewsOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    pHtmlOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_ENCODE);
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    Assert(pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64);
#endif
    pHtmlOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_ALLOW_8BIT);
    pHtmlOpt->fSendImages = IDwGetOption(poi->pOpt, OPT_NEWS_SENDINLINEIMAGES);
    pHtmlOpt->uWrap = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_LINE_WRAP);
    pHtmlOpt->fIndentReply = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_INDENT_REPLY);
}

void NewsOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_ENCODE, (DWORD)pHtmlOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_ALLOW_8BIT, pHtmlOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_SENDINLINEIMAGES, pHtmlOpt->fSendImages, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_LINE_WRAP, pHtmlOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_INDENT_REPLY, pHtmlOpt->fIndentReply, NULL, 0);
}

void PlainOptFromNewsOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    pPlainOpt->fMime = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_MIME);
    pPlainOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ENCODE);
    pPlainOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ALLOW_8BIT);
    pPlainOpt->uWrap = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_LINE_WRAP);
    pPlainOpt->chQuote = (CHAR)IDwGetOption(poi->pOpt, OPT_NEWSINDENT);
}

void NewsOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_MIME, pPlainOpt->fMime, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ENCODE, (DWORD)pPlainOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ALLOW_8BIT, pPlainOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_LINE_WRAP, pPlainOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWSINDENT, pPlainOpt->chQuote, NULL, 0);
    
}

BOOL FGetHTMLOptions(HWND hwndParent, LPHTMLOPT pHtmlOpt)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddHTMLSettings),
        hwndParent, HTMLSettingsDlgProc, (LPARAM)pHtmlOpt)==IDOK);
}

BOOL FGetPlainOptions(HWND hwndParent, LPPLAINOPT pPlainOpt)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPlainSettings),
        hwndParent, PlainSettingsDlgProc, (LPARAM)pPlainOpt)==IDOK);
}

const static HELPMAP g_rgCtxMapSettings[] = {
    {IDC_MIME_RADIO, IDH_NEWSMAIL_SEND_ADVSET_MIME},
    {IDC_UUENCODE_RADIO, IDH_NEWSMAIL_SEND_ADVSET_UUENCODE},
    {IDC_MAILWRAP_EDIT, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_MAILWRAP_SPIN, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_ENCODE_COMBO, IDH_NEWSMAIL_SEND_ADVSET_ENCODE_WITH},
    {IDC_8BIT_HEADER, IDH_SEND_SETTING_8BIT_HEADINGS},
    {IDC_MAILWRAP_TEXT1, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_MAILWRAP_TEXT2, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_SENDIMAGES, IDH_OPTIONS_SEND_SETTINGS_SEND_PICTURE},
    {IDC_INDENTREPLY_CHECK, 502066},
    {idcStatic1, 353540},
    {IDC_INDENT_CHECK, 502067},
    {IDC_INDENT_COMBO, 502067},
    {idcStaticReplying, 502067},
    {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
    {0,0}};
    
INT_PTR CALLBACK PlainSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD dw;
    BOOL fMime;
    HWND hwndT;
    UINT id,  code;
    LPPLAINOPT   pPlainOpt;
    ENCODINGTYPE ietEncoding;
    
    pPlainOpt = (LPPLAINOPT)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        
        Assert(pPlainOpt == NULL);
        pPlainOpt = (LPPLAINOPT)lParam;
        Assert(pPlainOpt);
        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pPlainOpt);
        
        if (pPlainOpt->fMime && (pPlainOpt->ietEncoding == IET_QP || pPlainOpt->ietEncoding == IET_BASE64))
            MailEnableWraps(hwnd, FALSE);
        
        hwndT = GetDlgItem(hwnd, IDC_ENCODE_COMBO);
        FillEncodeCombo(hwndT, FALSE, pPlainOpt->ietEncoding);
        
        CheckDlgButton(hwnd, pPlainOpt->fMime ? IDC_MIME_RADIO : IDC_UUENCODE_RADIO, BST_CHECKED);
        
        InitIndentOptions(pPlainOpt->chQuote, hwnd, IDC_INDENT_CHECK, IDC_INDENT_COMBO);
        
        CheckDlgButton (hwnd, IDC_8BIT_HEADER, pPlainOpt->f8Bit ? 1 : 0);
        if (pPlainOpt->fMime == FALSE)
        {
            EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), FALSE);
            EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), FALSE);
            EnableWindow (GetDlgItem (hwnd, idcStatic1), FALSE);
        }
        
        dw = pPlainOpt->uWrap;
        // this is to handle change in option... it was previously true/false
        // now it is a count of columns for wrapping or OPTION_OFF
        if (dw == 0 || dw == 1 || dw == OPTION_OFF)
            dw = DEF_AUTOWRAP;
        
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_SPIN, UDM_SETRANGE, 0, MAKELONG(AUTOWRAP_MAX, AUTOWRAP_MIN));
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_EDIT, EM_LIMITTEXT, 3, 0);
        SetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, dw, FALSE);
        return(TRUE);
        
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapSettings);
        
    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam,lParam);
        code = GET_WM_COMMAND_CMD(wParam, lParam);
        
        switch (id)
        {
        case IDC_ENCODE_COMBO:
            if (code == CBN_SELCHANGE)
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ENCODINGTYPE ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDC_INDENT_CHECK:
            if (code == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_INDENT_COMBO),
                    SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED);
            }
            break;
            
        case idcIndentReply:
            if (code == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwnd, idcIndentChar),
                    SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED);
            }
            break;
            
        case IDC_MIME_RADIO:
        case IDC_UUENCODE_RADIO:
            
            if (id == IDC_UUENCODE_RADIO)
            {
                EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), FALSE);
                EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), FALSE);
                EnableWindow (GetDlgItem (hwnd, idcStatic1), FALSE);
                MailEnableWraps(hwnd, TRUE);
            }
            else
            {
                EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), TRUE);
                EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), TRUE);
                EnableWindow (GetDlgItem (hwnd, idcStatic1), TRUE);
                
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDOK:
            fMime = (IsDlgButtonChecked(hwnd, IDC_MIME_RADIO) == BST_CHECKED);
            
            dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
            ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
            
            if (!(fMime && (ietEncoding == IET_QP || ietEncoding == IET_BASE64)))
            {
                dw = GetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, NULL, FALSE);
                if (dw > AUTOWRAP_MAX || dw < AUTOWRAP_MIN)
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsEnterAutoWrap), NULL, MB_OK | MB_ICONEXCLAMATION);
                    SendMessage(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT));
                    return TRUE;
                }
                
                pPlainOpt->uWrap = dw;
            }
            
            pPlainOpt->fMime = fMime;
            
            pPlainOpt->ietEncoding = ietEncoding;
            
            pPlainOpt->f8Bit = (IsDlgButtonChecked(hwnd, IDC_8BIT_HEADER) == BST_CHECKED);
            
            if ((IsDlgButtonChecked(hwnd, IDC_INDENT_CHECK) == BST_CHECKED))
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_INDENT_COMBO, CB_GETCURSEL, 0, 0);
                pPlainOpt->chQuote = (CHAR)c_szQuoteChars[dw];
            }
            else
                pPlainOpt->chQuote = INDENTCHAR_NONE;
            
            // fall through...
            
        case IDCANCEL:
            EndDialog(hwnd, id);
            return(TRUE);
        }
        break;
        
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);
            
    }
    
    return (FALSE);
}

INT_PTR CALLBACK HTMLSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD       dw;
    HWND        hwndT;
    UINT        id;
    LPHTMLOPT   pHtmlOpt;
    ENCODINGTYPE ietEncoding;
    
    pHtmlOpt= (LPHTMLOPT)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        
        Assert(pHtmlOpt==NULL);
        pHtmlOpt = (LPHTMLOPT)lParam;
        Assert(pHtmlOpt);
        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pHtmlOpt);
        
        hwndT = GetDlgItem(hwnd, IDC_ENCODE_COMBO);
        FillEncodeCombo(hwndT, TRUE, pHtmlOpt->ietEncoding);
        
        CheckDlgButton (hwnd, IDC_8BIT_HEADER, pHtmlOpt->f8Bit);
        CheckDlgButton (hwnd, IDC_SENDIMAGES, pHtmlOpt->fSendImages);
        CheckDlgButton (hwnd, IDC_INDENTREPLY_CHECK, pHtmlOpt->fIndentReply);
        
        if (pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64)
            MailEnableWraps(hwnd, FALSE);
        else
            MailEnableWraps(hwnd, TRUE);
        
        dw = pHtmlOpt->uWrap;
        // this is to handle change in option... it was previously true/false
        // now it is a count of columns for wrapping or OPTION_OFF
        if (dw == 0 || dw == 1 || dw == OPTION_OFF)
            dw = DEF_AUTOWRAP;
        
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_SPIN, UDM_SETRANGE, 0, MAKELONG(AUTOWRAP_MAX, AUTOWRAP_MIN));
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_EDIT, EM_LIMITTEXT, 3, 0);
        SetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, dw, FALSE);
        return(TRUE);
        
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapSettings);
        
    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam,lParam);
        
        switch (id)
        {
        case IDC_ENCODE_COMBO:
            if (GET_WM_COMMAND_CMD(wParam,lParam) == CBN_SELCHANGE)
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ENCODINGTYPE ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDOK:
            dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
            ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
            
            if (!(ietEncoding == IET_QP || ietEncoding == IET_BASE64))
            {
                dw = GetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, NULL, FALSE);
                if (dw > AUTOWRAP_MAX || dw < AUTOWRAP_MIN)
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsEnterAutoWrap), NULL, MB_OK | MB_ICONEXCLAMATION);
                    SendMessage(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT));
                    return TRUE;
                }
                
                pHtmlOpt->uWrap = dw;
            }
            
            pHtmlOpt->ietEncoding = ietEncoding;
            
            pHtmlOpt->f8Bit=(IsDlgButtonChecked(hwnd, IDC_8BIT_HEADER) == BST_CHECKED);
            pHtmlOpt->fSendImages=(IsDlgButtonChecked(hwnd, IDC_SENDIMAGES) == BST_CHECKED);
            pHtmlOpt->fIndentReply=(IsDlgButtonChecked(hwnd, IDC_INDENTREPLY_CHECK) == BST_CHECKED);
            // fall through...
            
        case IDCANCEL:
            EndDialog(hwnd, id);
            return(TRUE);
        }
        break;
        
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);
            
    }
    return (FALSE);
}

const static HELPMAP g_rgCtxMapAdvSec[] = 
{
    {IDC_ENCRYPT_FOR_SELF, IDH_SECURITY_ADVANCED_INCLUDE_SELF},
    {IDC_INCLUDECERT_CHECK, IDH_SECURITY_ADVANCED_INCLUDE_ID},
    {IDC_OPAQUE_SIGN, IDH_SECURITY_ADVANCED_INCLUDE_PKCS},
    {IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, 355528},
    {IDC_ENCRYPT_WARN_COMBO, 355527},
    {IDC_REVOKE_ONLINE_ONLY, 355529},
    {IDC_REVOKE_NEVER, 355531},
    {idcStatic1, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6, IDH_NEWS_COMM_GROUPBOX},
    {IDC_ENCRYPT_ICON, IDH_NEWS_COMM_GROUPBOX},
    {IDC_SIGNED_ICON, IDH_NEWS_COMM_GROUPBOX},
    {IDC_CERT_ICON, IDH_NEWS_COMM_GROUPBOX},
    {0,0}
};

    
INT_PTR CALLBACK AdvSecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    OPTINFO *poi;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (message)
    {
        case WM_INITDIALOG:
            CenterDialog(hwnd);
        
            // save our cookie pointer
            Assert(poi == NULL);
            poi = (OPTINFO *)lParam;
            Assert(poi != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
        
            // Set the images correctly
            HIMAGELIST himl;
            himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32Hot),
                30, 0, RGB(255, 0, 255));
            if (himl)
            {
                HICON hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 0);
                SendDlgItemMessage(hwnd, IDC_ENCRYPT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 1);
                SendDlgItemMessage(hwnd, IDC_SIGNED_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 6);
                SendDlgItemMessage(hwnd, IDC_CERT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                ImageList_Destroy(himl);
            }
        
            // set initial state of controls
            AdvSec_FillEncWarnCombo(hwnd, poi);
        
            ButtonChkFromOptInfo(hwnd, IDC_INCLUDECERT_CHECK, poi, OPT_MAIL_INCLUDECERT);
        
            // Encrypt for myself
            CheckDlgButton(hwnd, IDC_ENCRYPT_FOR_SELF, (0 == IDwGetOption(poi->pOpt, OPT_NO_SELF_ENCRYPT)) ? BST_CHECKED : BST_UNCHECKED);
        
            // Opaque signing
            ButtonChkFromOptInfo(hwnd, IDC_OPAQUE_SIGN, poi, OPT_OPAQUE_SIGN);
        
            // Opaque signing
            ButtonChkFromOptInfo(hwnd, IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, poi, OPT_AUTO_ADD_SENDERS_CERT_TO_WAB);

            CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, (0 == IDwGetOption(poi->pOpt, OPT_REVOKE_CHECK)) ? BST_UNCHECKED : BST_CHECKED);
            CheckDlgButton(hwnd, IDC_REVOKE_NEVER, (0 != IDwGetOption(poi->pOpt, OPT_REVOKE_CHECK)) ? BST_UNCHECKED : BST_CHECKED);
        
            return(TRUE);
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapAdvSec);
        
        case WM_COMMAND:
            if (poi == NULL)
                break;

            switch (LOWORD(wParam))
            {
                case IDOK:
                    {
                        BOOL fDontEncryptForSelf;
                
                        // update the registry based on states of the controls
                        // BUG: #33047, don't use global options now
                        ButtonChkToOptInfo(hwnd, IDC_INCLUDECERT_CHECK, poi, OPT_MAIL_INCLUDECERT);
                
                        // Opaque signing is stored in registry
                        fDontEncryptForSelf = !(IsDlgButtonChecked(hwnd, IDC_ENCRYPT_FOR_SELF) == BST_CHECKED);
                        ISetDwOption(poi->pOpt, OPT_NO_SELF_ENCRYPT, fDontEncryptForSelf, NULL, 0);
                
                        // Opaque signing is stored in registry
                        ButtonChkToOptInfo(hwnd, IDC_OPAQUE_SIGN, poi, OPT_OPAQUE_SIGN);
                
                        // Opaque signing is stored in registry
                        ButtonChkToOptInfo(hwnd, IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, poi, OPT_AUTO_ADD_SENDERS_CERT_TO_WAB);

                        // Revocation checking
                        ButtonChkToOptInfo(hwnd, IDC_REVOKE_ONLINE_ONLY, poi, OPT_REVOKE_CHECK);

                        // Get encryption warning strenght into registry
                        AdvSec_GetEncryptWarnCombo(hwnd, poi);
                    }
            
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                case IDC_REVOKE_NEVER:
                    CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, BST_UNCHECKED);
                    CheckDlgButton(hwnd, IDC_REVOKE_NEVER, BST_CHECKED);
                    break;

                case IDC_REVOKE_ONLINE_ONLY:
                    CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, BST_CHECKED);
                    CheckDlgButton(hwnd, IDC_REVOKE_NEVER, BST_UNCHECKED);
                    break;
            }
        
            break; // wm_command
        
            case WM_CLOSE:
                SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
                return (TRUE);
            
    } // message switch
    return(FALSE);
}
    
void ButtonChkFromOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt)
{
    Assert(poi != NULL);
    CheckDlgButton(hwnd, idc, (!!IDwGetOption(poi->pOpt, opt)) ? BST_CHECKED : BST_UNCHECKED);
}

BOOL ButtonChkToOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt)
{
    register BOOL f = (IsDlgButtonChecked(hwnd, idc) == BST_CHECKED);
    Assert(poi != NULL);
    ISetDwOption(poi->pOpt, opt, f, NULL, 0);
    
    return(f);
}
    
// These are the bit-strength values that will show up in our drop down.

const ULONG BitStrengthValues[5] = {
    168,
    128,
    64,
    56,
    40
};
const ULONG CBitStrengthValues = sizeof(BitStrengthValues) / sizeof(ULONG);

BOOL AdvSec_FillEncWarnCombo(HWND hwnd, OPTINFO *poi)
{
    HRESULT hr;
    PROPVARIANT var;
    ULONG ulHighestStrength;
    ULONG ulCurrentStrength = 0;
    ULONG i, j;
    ULONG k = 0;
    
    // Get the default lcaps blob from the registry
    hr = poi->pOpt->GetProperty(MAKEPROPSTRING(OPT_MAIL_ENCRYPT_WARN_BITS), &var, 0);
    
    if (SUCCEEDED(hr)) {
        Assert(var.vt == VT_UI4);
        ulCurrentStrength = var.ulVal;
    }
    
    // Get the available encryption algorithms from the available providers.
    ulHighestStrength = GetHighestEncryptionStrength();
    if (! ulCurrentStrength) {  // default to highest available
        ulCurrentStrength = ulHighestStrength;
    }
    
    for (i = 0; i < CBitStrengthValues; i++)
    {
        if (BitStrengthValues[i] <= ulHighestStrength)
        {
            // Add it to the list
            // LPTSTR lpString = NULL;
            // DWORD rgdw[1] = {BitStrengthValues[i]};
            TCHAR szBuffer[100];    // really ought to be big enough
            TCHAR szTmp[256];
            
            LoadString(g_hLocRes, idsBitStrength, szBuffer, sizeof(szBuffer));
            
            if (szBuffer[0])
            {
#ifdef OLD
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szBuffer,
                    0, 0,
                    (LPTSTR)&lpString, 0, (va_list *)rgdw);
#endif
                wsprintf(szTmp, szBuffer, BitStrengthValues[i]);
            }
            
            if (szTmp[0])
            {
                j = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_ADDSTRING, 0, (LPARAM)szTmp/*lpString*/);
                // Item data is the bit strength
                SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_SETITEMDATA, j, BitStrengthValues[i]);
                if (ulCurrentStrength == BitStrengthValues[i])
                {
                    SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_SETCURSEL, (WPARAM)j, 0);
                }
            }
            // LocalFree(lpString);
            // lpString = NULL;
        }
    }
    
    return(SUCCEEDED(hr));
}
    
    
BOOL AdvSec_GetEncryptWarnCombo(HWND hwnd, OPTINFO *poi)
{
    HRESULT hr;
    ULONG i;
    ULONG ulStrength = 0;
    ULONG ulHighestStrength;
    PROPVARIANT var;
    
    // What item is selected?
    i = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_GETCURSEL, 0, 0);
    if (i != CB_ERR) {
        ulStrength = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_GETITEMDATA, (WPARAM)i, 0);
    }
    
    // If the strength is the highest available, then set this to the default value.
    ulHighestStrength = GetHighestEncryptionStrength();
    if (ulHighestStrength == ulStrength) {
        ulStrength = 0;
    }
    
    // Set the default value to the registry
    var.vt = VT_UI4;
    var.ulVal = ulStrength;
    hr = poi->pOpt->SetProperty(MAKEPROPSTRING(OPT_MAIL_ENCRYPT_WARN_BITS), &var, 0);
    
    return(SUCCEEDED(hr));
}

    
BOOL ChangeSendFontSettings(OPTINFO *pmoi, BOOL fMail, HWND hwnd)
{
    const FONTOPTIONS *pfo;
    CHOOSEFONT  cf;
    LOGFONT     logfont;
    HDC         hdc;
    LONG        yPerInch;
    DWORD       dwColor, dwSize;
    BOOL        fRet = FALSE,
        fBold,
        fItalic,
        fUnderline;
    
    Assert(pmoi != NULL);
    Assert(hwnd != NULL);
    
    ZeroMemory(&logfont, sizeof(LOGFONT));
    
    pfo = fMail ? &c_rgFontOptions[0] : &c_rgFontOptions[1];
    
    dwColor     = IDwGetOption(pmoi->pOpt, pfo->color);
    dwSize      = IDwGetOption(pmoi->pOpt, pfo->size);
    fBold       = IDwGetOption(pmoi->pOpt, pfo->bold);
    fItalic     = IDwGetOption(pmoi->pOpt, pfo->italic);
    fUnderline  = IDwGetOption(pmoi->pOpt, pfo->underline);
    
    logfont.lfWeight = fBold ? FW_BOLD : FW_NORMAL;
    logfont.lfItalic = !!fItalic;
    logfont.lfUnderline = !!fUnderline;
    
    IGetOption(pmoi->pOpt, pfo->face, logfont.lfFaceName, sizeof(logfont.lfFaceName));
    
    hdc = GetDC(hwnd);
    yPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(hwnd, hdc);
    
    if (dwSize)
        logfont.lfHeight = -(INT)((dwSize*10*2*yPerInch)/1440);
    
    if (dwColor)
        cf.rgbColors = dwColor;
    
    cf.lStructSize      = sizeof(CHOOSEFONT);
    cf.hwndOwner        = hwnd;
    cf.hDC              = NULL;
    cf.lpLogFont        = &logfont;
    cf.Flags            = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS | CF_ENABLEHOOK |
        CF_EFFECTS | CF_LIMITSIZE | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
    cf.lCustData        = 0;
    cf.lpfnHook         = (LPOFNHOOKPROC)FChooseFontHookProc;
    cf.lpTemplateName   = NULL;
    cf.hInstance        = NULL;
    cf.nFontType        = REGULAR_FONTTYPE | SCREEN_FONTTYPE;
    cf.nSizeMin         = 8;
    cf.nSizeMax         = 36;
    
    if (fRet = ChooseFont(&cf))
    {
        ISetDwOption(pmoi->pOpt, pfo->color, cf.rgbColors, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->size, cf.iPointSize/10, NULL, 0);
        
        ISetDwOption(pmoi->pOpt, pfo->bold, logfont.lfWeight == FW_BOLD, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->italic, !!logfont.lfItalic, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->underline, !!logfont.lfUnderline, NULL, 0);
        
        ISetOption(pmoi->pOpt, pfo->face, logfont.lfFaceName, lstrlen(logfont.lfFaceName) + 1, NULL, 0);
    }
    
    return fRet;
}
    
INT_PTR CALLBACK FChooseFontHookProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        EnableWindow(GetDlgItem(hwnd, 1040), FALSE);
        break;
    }
    return(FALSE);
}

static  TCHAR s_szUserDefined[] = "\\50000";
static  TCHAR s_szScrUserDefined[] = "\\Scripts\\40";

BOOL ChangeFontSettings(HWND hwnd)
{
    LPCTSTR pszRoot;
    TCHAR szIntl[MAX_PATH];
    TCHAR szCodePage[MAX_PATH*2];
    TCHAR szScript[MAX_PATH*2];
    DWORD cb;
    DWORD dwVal;
    DWORD dwType;
    HKEY hKeyCP = NULL;
    HKEY hKeyScr = NULL;
    DWORD   dw;



    pszRoot = MU_GetRegRoot();
    if (pszRoot != NULL)
    {
        lstrcpy(szIntl, pszRoot);
        lstrcat(szIntl, c_szTridentIntl);

        OpenFontsDialog(hwnd, szIntl);

        // HACK! HACK! HACK! Bug 84378

        lstrcpy(szCodePage, szIntl);
        lstrcat(szCodePage, s_szUserDefined);
        lstrcpy(szScript, szIntl);
        lstrcat(szScript, s_szScrUserDefined);


        if (RegCreateKeyEx(HKEY_CURRENT_USER, szCodePage, NULL, NULL, NULL, KEY_READ, NULL, &hKeyCP, &dw)
                == ERROR_SUCCESS)
        {
            if (RegCreateKeyEx(HKEY_CURRENT_USER, szScript, NULL, NULL, NULL, KEY_WRITE, NULL, &hKeyScr, &dw)
                == ERROR_SUCCESS)
            {

                TCHAR szFont[MAX_MIMEFACE_NAME];

                cb = MAX_MIMEFACE_NAME;
                if (RegQueryValueEx(hKeyCP, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                                (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKeyScr, REGSTR_VAL_FIXED_FONT, NULL, REG_SZ, (LPBYTE)szFont, (lstrlen(szFont)+1)*sizeof(TCHAR));
                }

                cb = MAX_MIMEFACE_NAME;
                if (RegQueryValueEx(hKeyCP, REGSTR_VAL_PROP_FONT,  NULL, NULL,
                                (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKeyScr, REGSTR_VAL_PROP_FONT,  NULL, REG_SZ, (LPBYTE)szFont, (lstrlen(szFont)+1)*sizeof(TCHAR));
                }

                RegCloseKey(hKeyScr);
            }
            RegCloseKey(hKeyCP);
        }
        // END of HACK!!!

        // hack: we should call these only if OpenFontsDialog tells us user has changed the font.
        g_lpIFontCache->OnOptionChange();
    
        SendTridentOptionsChange();

        // Re-Read Default Character Set
        SetDefaultCharset(NULL);

        // Reset g_uiCodePage
        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
            g_uiCodePage = (UINT)dwVal;
    }

    return TRUE;
}
    
void GetDefaultOptInfo(LPHTMLOPT prHtmlOpt, LPPLAINOPT prPlainOpt, BOOL *pfHtml, DWORD dwFlags)
{
    BOOL fMail;
    
    Assert (prHtmlOpt && prPlainOpt && pfHtml );
    
    ZeroMemory (prHtmlOpt, sizeof(HTMLOPT));
    ZeroMemory (prPlainOpt, sizeof(PLAINOPT));
    
    fMail = !!(dwFlags & FMT_MAIL);
    
    // setup reasonable defaults
    prPlainOpt->uWrap = 76;
    prPlainOpt->ietEncoding = IET_7BIT;
    prHtmlOpt->ietEncoding = IET_QP;
    
    if (fMail)
    {
        // Mail Options
        if (!!(dwFlags & FMT_FORCE_PLAIN))
            *pfHtml = FALSE;
        else if (!!(dwFlags & FMT_FORCE_HTML))
            *pfHtml = TRUE;
        else
            *pfHtml = !!DwGetOption(OPT_MAIL_SEND_HTML);
        
        // HTML Options
        prHtmlOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_MAIL_MSG_HTML_ENCODE);
        prHtmlOpt->f8Bit = !!DwGetOption(OPT_MAIL_MSG_HTML_ALLOW_8BIT);
        prHtmlOpt->fSendImages = !!DwGetOption(OPT_MAIL_SENDINLINEIMAGES);
        prHtmlOpt->uWrap = DwGetOption(OPT_MAIL_MSG_HTML_LINE_WRAP);
        
        // Plain text options
        prPlainOpt->fMime = !!DwGetOption(OPT_MAIL_MSG_PLAIN_MIME);
        prPlainOpt->f8Bit = !!DwGetOption(OPT_MAIL_MSG_PLAIN_ALLOW_8BIT);
        prPlainOpt->uWrap = DwGetOption(OPT_MAIL_MSG_PLAIN_LINE_WRAP);
        prPlainOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_MAIL_MSG_PLAIN_ENCODE);
    }
    else
    {
        // News Options
        if (!!(dwFlags & FMT_FORCE_PLAIN))
            *pfHtml = FALSE;
        else if (!!(dwFlags & FMT_FORCE_HTML))
            *pfHtml = TRUE;
        else
            *pfHtml = !!DwGetOption(OPT_NEWS_SEND_HTML);
        
        // HTML Options
        prHtmlOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_NEWS_MSG_HTML_ENCODE);
        prHtmlOpt->f8Bit = !!DwGetOption(OPT_NEWS_MSG_HTML_ALLOW_8BIT);
        prHtmlOpt->fSendImages = !!DwGetOption(OPT_NEWS_SENDINLINEIMAGES);
        prHtmlOpt->uWrap = DwGetOption(OPT_NEWS_MSG_HTML_LINE_WRAP);
        
        prPlainOpt->fMime = !!DwGetOption(OPT_NEWS_MSG_PLAIN_MIME);
        prPlainOpt->f8Bit = !!DwGetOption(OPT_NEWS_MSG_PLAIN_ALLOW_8BIT);
        prPlainOpt->uWrap = DwGetOption(OPT_NEWS_MSG_PLAIN_LINE_WRAP);
        prPlainOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_NEWS_MSG_PLAIN_ENCODE);
    }
    
    // Do some validation based on the stuff that may be in the registry
    
    // Allow 8bit in headers is always on if not a MIME message
    if (!prPlainOpt->fMime)
        prPlainOpt->f8Bit = TRUE;
    
    // HTML has to be either QP or base-64. If not, then force QP
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    if (prHtmlOpt->ietEncoding != IET_QP && prHtmlOpt->ietEncoding != IET_BASE64)
        prHtmlOpt->ietEncoding = IET_QP;
#else
    // if PLAIN, MIME: then enforce either QP, B64 or 7BIT: Default to 7BIT
    if (prHtmlOpt->ietEncoding != IET_QP && prHtmlOpt->ietEncoding != IET_BASE64 && prHtmlOpt->ietEncoding != IET_7BIT)
        prHtmlOpt->ietEncoding = IET_7BIT;
#endif
    
    // if PLAIN, MIME: then enforce either QP, B64 or 7BIT: Default to 7BIT
    if (prPlainOpt->fMime &&
        prPlainOpt->ietEncoding != IET_QP && prPlainOpt->ietEncoding != IET_BASE64 && prPlainOpt->ietEncoding != IET_7BIT)
        prPlainOpt->ietEncoding = IET_7BIT;
    
    // if PLAIN, UU: then enforce 7BIT.
    if (!prPlainOpt->fMime && prPlainOpt->ietEncoding != IET_7BIT)
        prPlainOpt->ietEncoding = IET_7BIT;
}
    
LRESULT InvalidOptionProp(HWND hwndPage, int idcEdit, int idsError, UINT idPage)
{
    HWND hwndCurr, hwndParent, hwndEdit;
    
    Assert(hwndPage != NULL);
    Assert(idPage != 0);
    Assert(idcEdit != 0);
    Assert(idsError != 0);
    
    hwndParent = GetParent(hwndPage);
    
    AthMessageBoxW(hwndPage, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsError), 0, MB_ICONSTOP | MB_OK);
    
    hwndCurr = PropSheet_GetCurrentPageHwnd(hwndParent);
    if (hwndCurr != hwndPage)
        SendMessage(hwndParent, PSM_SETCURSELID, 0, (LPARAM)idPage);
    
    hwndEdit = GetDlgItem(hwndPage, idcEdit);
    SendMessage(hwndEdit, EM_SETSEL, 0, -1);
    SetFocus(hwndEdit);
    
    return (PSNRET_INVALID_NOCHANGEPAGE);
}
    
INT_PTR CALLBACK DefaultClientDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);    

void DoDefaultClientCheck(HWND hwnd, DWORD dwFlags)
{
    int iret;
    DWORD dwType, dw, cb;
    BOOL f, bSet = FALSE;
    
    // Are we handling?
    if (dwFlags & DEFAULT_MAIL)
    {
        if (FIsDefaultMailConfiged())
            return;
    }
    else
    {
        if (FIsDefaultNewsConfiged(dwFlags))
            return;
    }
    
    // Someone else is a valid handler
    
    // If we're supposed to be the "outlook newsreader", then we check for "don't ask" in a different place
    cb = sizeof(DWORD);
    if (dwFlags & DEFAULT_OUTNEWS)
    {
        f = (ERROR_SUCCESS != AthUserGetValue(c_szRegOutNewsDefault, c_szNoCheckDefault,
            &dwType, (LPBYTE)&dw, &cb) || dw == 0);
    }
    else
    {
        f = (ERROR_SUCCESS != AthUserGetValue(dwFlags & DEFAULT_MAIL ? c_szRegPathMail : c_szRegPathNews,
            c_szNoCheckDefault, &dwType, (LPBYTE)&dw, &cb) || dw == 0);
    }
    
    if (f)
    {
        iret = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddAthenaDefault), hwnd, DefaultClientDlgProc, (LPARAM) dwFlags);
        if (HIWORD(iret) != 0)
        {
            dw = 1;
            if (dwFlags & DEFAULT_OUTNEWS)
            {
                AthUserSetValue(c_szRegOutNewsDefault, c_szNoCheckDefault, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
            }
            else
            {
                AthUserSetValue(dwFlags & DEFAULT_MAIL ? c_szRegPathMail : c_szRegPathNews,
                    c_szNoCheckDefault, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
            }
        }
        
        bSet = (LOWORD(iret) == IDYES);
    }
    
    if (bSet)
    {
        dwFlags |= DEFAULT_UI;
        if (dwFlags & DEFAULT_MAIL)
            SetDefaultMailHandler(dwFlags);
        else
            SetDefaultNewsHandler(dwFlags);
    }
}
    
INT_PTR CALLBACK DefaultClientDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WORD id;
    TCHAR sz[CCHMAX_STRINGRES];
    HICON hicon;
    BOOL fRet = TRUE;
    
    switch (msg)
    {
        case WM_INITDIALOG:
            if (lParam & DEFAULT_OUTNEWS)
            {
                LoadString(g_hLocRes, idsNotDefOutNewsClient, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_NOTDEFAULT, sz);
            
                LoadString(g_hLocRes, idsAlwaysCheckOutNews, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_ALWAYSCHECK, sz);
            }
            else if (lParam & DEFAULT_NEWS)
            {
                LoadString(g_hLocRes, idsNotDefNewsClient, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_NOTDEFAULT, sz);
            }
        
            hicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION));
            if (hicon != NULL)
                SendDlgItemMessage(hwnd, IDC_WARNINGICON, STM_SETICON, (WPARAM)hicon, 0);
        
            CheckDlgButton(hwnd, IDC_ALWAYSCHECK, BST_CHECKED);
        
            CenterDialog(hwnd);
            PostMessage(hwnd, WM_USER, 0, 0);
            break;
        
        case WM_USER:
            SetForegroundWindow(hwnd);
            break;
        
        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
            {
                case IDYES:
                case IDNO:
                    EndDialog(hwnd, MAKELONG(id, BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_ALWAYSCHECK) ? 1 : 0));
                    break;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    return(fRet);
}
    
BOOL CALLBACK TridentSearchCB(HWND hwnd, LPARAM lParam)
{
    DWORD   dwProc,
            dwAthenaProc=GetCurrentProcessId();
    TCHAR   rgch[MAX_PATH];
    
    if (GetWindowThreadProcessId(hwnd, &dwProc) && dwProc == dwAthenaProc &&
        GetClassName(hwnd, rgch, ARRAYSIZE(rgch)) &&
        lstrcmp(rgch, "Internet Explorer_Hidden")==0)
        {
            PostMessage(hwnd, WM_USER + 338, 0, 0);
            return FALSE;
        }

    return TRUE;
}

void SendTridentOptionsChange()
{
    // walk the top-level windows in our process, looking for the trident notification window
    // when we find it, post it WM_USER + 338
    EnumWindows(TridentSearchCB, 0);
}
    
void FreeIcon(HWND hwnd, int idc)
{
    HICON hIcon;

    hIcon = (HICON) SendDlgItemMessage(hwnd, idc, STM_GETIMAGE, IMAGE_ICON, 0);
    SendDlgItemMessage(hwnd, idc, STM_SETIMAGE, IMAGE_ICON, NULL);

    if (hIcon)
        DestroyIcon(hIcon);
}
// -----------------------------------------------------------------------------
// IsHTTPMailEnabled
// HTTPMail accounts can only be created and accessed when a special
// registry value exists. This limitation exists during development of
// OE 5.0, and will probably be removed for release.
// -----------------------------------------------------------------------------
BOOL IsHTTPMailEnabled(void)
{
#ifdef NOHTTPMAIL
    return FALSE;    
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // open the OE5.0 key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    return bEnabled;
#endif
}

const static HELPMAP g_rgCtxMapReceipts[] =
{
    {IDC_MDN_SEND_REQUEST,     IDH_RECEIPTS_REQUEST},
    {IDC_DONOT_REPSONDTO_RCPT, IDH_RECEIPTS_NEVER},
    {IDC_ASKME_FOR_RCPT,       IDH_RECEIPTS_ASK},
    {IDC_SEND_AUTO_RCPT,       IDH_RECEIPTS_ALWAYS},
    {IDC_TO_CC_LINE_RCPT,      IDH_RECEIPTS_EXCEPTIONS},
    {IDC_SECURE_RECEIPT,       IDH_RECEIPTS_SECURE},
    {0,                        0                  }
};

INT_PTR CALLBACK ReceiptsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT     lResult;

    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Receipts_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapReceipts);
            break;
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Receipts_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Receipts_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_RECEIPT);
            FreeIcon(hwnd, IDC_SEND_RECEIVE_ICON);
            if(!IsSMIME3Supported())
                FreeIcon(hwnd, IDC_SEC_REC);                
            return (TRUE);
    }
    
    return (FALSE);
}

BOOL Receipts_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi    = 0;
    BOOL     fEnable = FALSE;
    DWORD    id;
    DWORD    dw;
    DWORD    dwLocked = FALSE;
    DWORD    dwType;
    DWORD    cbData;
    HKEY     hKeyLM;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    dw = IDwGetOption(pmoi->pOpt, OPT_MDN_SEND_RECEIPT);

    switch (dw)
    {
        case MDN_SENDRECEIPT_AUTO:
            id = IDC_SEND_AUTO_RCPT;
            break;

        case MDN_DONT_SENDRECEIPT:
            id = IDC_DONOT_REPSONDTO_RCPT;
            break;
        
        default:
        case MDN_PROMPTFOR_SENDRECEIPT:
            id = IDC_ASKME_FOR_RCPT;
            break;
    }

    CheckDlgButton(hwnd, id, BST_CHECKED);

    ButtonChkFromOptInfo(hwnd, IDC_TO_CC_LINE_RCPT, pmoi, OPT_TO_CC_LINE_RCPT);

    cbData = sizeof(DWORD);
    
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szSendMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&  
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szSendMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    if (!!dwLocked)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SEND_AUTO_RCPT),       FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DONOT_REPSONDTO_RCPT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ASKME_FOR_RCPT),       FALSE);
    }

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szSendReceiptToListLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szSendReceiptToListLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    fEnable = (id == IDC_SEND_AUTO_RCPT);

    if (!fEnable || (!!dwLocked))
    {
        EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT),  FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), FALSE);
    }

    //Request for Receipt
    ButtonChkFromOptInfo(hwnd, IDC_MDN_SEND_REQUEST, pmoi, OPT_MDN_SEND_REQUEST);

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    if (!!dwLocked)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MDN_SEND_REQUEST), FALSE);
    }    

    HICON hIcon;

#ifdef SMIME_V3
    if(!IsSMIME3Supported())
    {
        ShowWindow(GetDlgItem(hwnd, IDC_SR_TXT1), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SRES_TXT2), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SRES_TXT3), SW_HIDE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), FALSE);
        ShowWindow(GetDlgItem(hwnd, idiSecReceipt), SW_HIDE);
    }
    else
    {
        if (g_dwAthenaMode & MODE_NEWSONLY)
        {
            EnableWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), FALSE);
        }
        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEC_RECEIPT, ILD_TRANSPARENT);
        SendDlgItemMessage(hwnd, IDC_SEC_REC, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    }

    // ButtonChkFromOptInfo(hwnd, IDC_SECURE_RECEIPT, pmoi, OPT_SECURE_READ_RECEIPT);
#endif // SMIME_V3

    // Pictures

    hIcon = ImageList_GetIcon(pmoi->himl, ID_RECEIPT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_RECEIPT, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    

    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


void Receipts_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     fEnable;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    if (codeNotify == BN_CLICKED)
    {
        switch (id)
        {
            case IDC_SEND_AUTO_RCPT:
                fEnable = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), fEnable);
                PropSheet_Changed(GetParent(hwnd), hwnd);
                break;

            case IDC_DONOT_REPSONDTO_RCPT:
            case IDC_ASKME_FOR_RCPT:
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), FALSE);
                //Fallthrough
        
            case IDC_MDN_SEND_REQUEST:
            // case IDC_SECURE_RECEIPT:
            case IDC_TO_CC_LINE_RCPT:
                PropSheet_Changed(GetParent(hwnd), hwnd);
                break;

#ifdef SMIME_V3
            case IDC_SECURE_RECEIPT:
                FGetSecRecOptions(hwnd, pmoi);
                break;
#endif // SMIME_V3
        }
    }
}


LRESULT Receipts_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    DWORD    dw;
    DWORD    id;

    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // General options
        ButtonChkToOptInfo(hwnd, IDC_MDN_SEND_REQUEST, pmoi, OPT_MDN_SEND_REQUEST);
        // ButtonChkToOptInfo(hwnd, IDC_SECURE_RECEIPT, pmoi, OPT_NOTIFYGROUPS);

        id = IDC_ASKME_FOR_RCPT;
        if (IsDlgButtonChecked(hwnd, IDC_DONOT_REPSONDTO_RCPT) == BST_CHECKED)
        {
            id = IDC_DONOT_REPSONDTO_RCPT;
        }
        else if (IsDlgButtonChecked(hwnd, IDC_SEND_AUTO_RCPT) == BST_CHECKED)
        {
            id = IDC_SEND_AUTO_RCPT;
        }

        switch (id)
        {
            case IDC_SEND_AUTO_RCPT:
                dw = MDN_SENDRECEIPT_AUTO;
                break;

            case IDC_DONOT_REPSONDTO_RCPT:
                dw = MDN_DONT_SENDRECEIPT;
                break;
        
            default:
            case IDC_ASKME_FOR_RCPT:
                dw = MDN_PROMPTFOR_SENDRECEIPT;
                break;
        }

        ISetDwOption(pmoi->pOpt, OPT_MDN_SEND_RECEIPT, dw, NULL, 0);
        
        ButtonChkToOptInfo(hwnd, IDC_TO_CC_LINE_RCPT, pmoi, OPT_TO_CC_LINE_RCPT);

        return (PSNRET_NOERROR);

    }   

    return (FALSE);
}

#ifdef SMIME_V3
// Security receipts options

BOOL FGetSecRecOptions(HWND hwndParent, OPTINFO *opie)
{
    BOOL fRes = FALSE;

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSecReceipt),
        hwndParent, SecurityReceiptDlgProc, (LPARAM) (opie)) == IDOK)
    {
//        hr = HrSetOELabel(plabel);
//        if(hr == S_OK)
        fRes = TRUE;
    }

    return (fRes);

}


// Dlg proc
static const HELPMAP g_rgCtxMapSecureRec[] = {
    {IDC_SEC_SEND_REQUEST,      IDH_SECURERECEIPTS_REQUEST},
    {IDC_DONOT_RESSEC_RCPT,     IDH_SECURERECEIPTS_NEVER},
    {IDC_ASKME_FOR_SEC_RCPT,    IDH_SECURERECEIPTS_ASK},
    {IDC_SEC_AUTO_RCPT,         IDH_SECURERECEIPTS_ALWAYS},
    {IDC_ENCRYPT_RCPT,          IDH_SECURERECEIPTS_ENCRYPT},
    {IDC_SECREC_VERIFY,         IDH_SECURERECEIPTS_VERIFY},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEC_REC,               IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_RECEIVE_ICON,     IDH_NEWS_COMM_GROUPBOX},
    {IDC_GENERAL_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};


INT_PTR CALLBACK SecurityReceiptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT                 hr;
    LONG_PTR                iEntry;
    OPTINFO                 *pmoi    = 0;
    DWORD                   dw = 0;
    UINT                    id = 0;
    HICON                   hIcon = NULL;
    
    switch ( msg) {
    case WM_INITDIALOG:

        pmoi = (OPTINFO *)(lParam);
        Assert(pmoi != NULL);

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM) pmoi);

        CenterDialog(hwndDlg);
        
        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEC_RECEIPT, ILD_TRANSPARENT);;

        SendDlgItemMessage(hwndDlg, IDC_SEC_REC, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
        SendDlgItemMessage(hwndDlg, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
        
        hIcon = ImageList_GetIcon(pmoi->himl, ID_OPTIONS_GENERAL, ILD_TRANSPARENT);
        SendDlgItemMessage(hwndDlg, IDC_GENERAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

        ButtonChkFromOptInfo(hwndDlg, IDC_SEC_SEND_REQUEST, pmoi, OPT_SECREC_USE);
        ButtonChkFromOptInfo(hwndDlg, IDC_SECREC_VERIFY, pmoi, OPT_SECREC_VERIFY);
        ButtonChkFromOptInfo(hwndDlg, IDC_ENCRYPT_RCPT,  pmoi, OPT_SECREC_ENCRYPT);

        dw = IDwGetOption(pmoi->pOpt, OPT_MDN_SEC_RECEIPT);

        switch (dw)
        {
            case MDN_SENDRECEIPT_AUTO:
                id = IDC_SEC_AUTO_RCPT;
                break;

            case MDN_DONT_SENDRECEIPT:
                id = IDC_DONOT_RESSEC_RCPT;
                break;
        
            case MDN_PROMPTFOR_SENDRECEIPT:
            default:
                id = IDC_ASKME_FOR_SEC_RCPT;
                break;
        }

        CheckDlgButton(hwndDlg, id, BST_CHECKED);


        if (id != IDC_SEC_AUTO_RCPT)
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  FALSE);

        break;
        
    case WM_COMMAND:
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwndDlg, DWLP_USER);    
        if (pmoi == NULL)
            break;

        switch (LOWORD(wParam)) 
        {

        case IDC_SEC_AUTO_RCPT:
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  TRUE);
            break;

        case IDC_DONOT_RESSEC_RCPT:
        case IDC_ASKME_FOR_SEC_RCPT:
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  FALSE);
            break;

        case IDOK:
            ButtonChkToOptInfo(hwndDlg, IDC_SEC_SEND_REQUEST, pmoi, OPT_SECREC_USE);
            ButtonChkToOptInfo(hwndDlg, IDC_SECREC_VERIFY, pmoi, OPT_SECREC_VERIFY);
            ButtonChkToOptInfo(hwndDlg, IDC_ENCRYPT_RCPT, pmoi, OPT_SECREC_ENCRYPT);

            dw = MDN_PROMPTFOR_SENDRECEIPT;

            if (IsDlgButtonChecked(hwndDlg, IDC_DONOT_RESSEC_RCPT) == BST_CHECKED)
                dw = MDN_DONT_SENDRECEIPT;
            else if (IsDlgButtonChecked(hwndDlg, IDC_SEC_AUTO_RCPT) == BST_CHECKED)
                dw = MDN_SENDRECEIPT_AUTO;

            ISetDwOption(pmoi->pOpt, OPT_MDN_SEC_RECEIPT, dw, NULL, 0);
            EndDialog(hwndDlg, IDOK);
            break;        

        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;

        default:
            return FALSE;
        }
        break;
        
    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapSecureRec);
        break;

    case WM_DESTROY:
        FreeIcon(hwndDlg, IDC_SEND_RECEIVE_ICON);
        FreeIcon(hwndDlg, IDC_GENERAL_ICON);
        FreeIcon(hwndDlg, IDC_SEC_REC);                
        return (TRUE);

    default:
        return FALSE;
    }
    
    return TRUE;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\receipts.cpp ===
#include "pch.hxx"
#include <cryptdlg.h>
#include "strconst.h"
#include "msoert.h"
#include "resource.h"
#include "mailutil.h"
#include "ipab.h"
#include "receipts.h"
#include "oestore.h"
#include "shlwapip.h" 
#include "goptions.h"
#include "conman.h"
#include "multlang.h"
#include "demand.h"
#include "secutil.h"

#ifdef SMIME_V3
HRESULT ProcessSecureReceipt(IMimeMessage * pMsg, IStoreCallback  *pStoreCB);
INT_PTR CALLBACK SecRecResDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // SMIME_V3

const WCHAR c_szReadableTextFirst[]     = L"This is a receipt for the mail you sent to\r\n";
const WCHAR c_szReadableTextSecond[]    = L"\r\n\r\nThis receipt verifies that the message has been displayed on the recipient's computer at ";
const WCHAR c_szReceiptsAt[]            = L" at ";
const WCHAR c_szReadReceipt[]           = L"Read: %s";

const WCHAR c_szSecReadReceipt[]           = L"Secure Receipt: %s";

//Does not include NULL
const int cbReadableTextFirst     = sizeof(c_szReadableTextFirst)     - sizeof(*c_szReadableTextFirst);
const int cbReadableTextSecond    = sizeof(c_szReadableTextSecond)    - sizeof(*c_szReadableTextSecond);
const int cbReceiptsAt            = sizeof(c_szReceiptsAt)            - sizeof(*c_szReceiptsAt);

//Include NULL
const int cbReadReceipt           = sizeof(c_szReadReceipt);


//Not wide, does not include NULL
const TCHAR c_szDisposition[]           = TEXT("\r\nDisposition: manual-action/");
const TCHAR c_szMDNSendAutomatically[]  = TEXT("MDN-sent-automatically; ");
const TCHAR c_szMDNSendManually[]       = TEXT("MDN-sent-manually; ");
const TCHAR c_szOriginalRecipient[]     = TEXT("\r\nOriginal-Recipient: rfc822;");
const TCHAR c_szFinalRecipient[]        = TEXT("Final-Recipient: rfc822;");
const TCHAR c_szOriginalMessageId[]     = TEXT("\r\nOriginal-Message-ID: ");
const TCHAR c_szDisplayed[]             = TEXT("displayed\r\n");

//Does not include NULL
const int cbDisposition           = sizeof(c_szDisposition)           - sizeof(*c_szDisposition);
const int cbMDNSendAutomatically  = sizeof(c_szMDNSendAutomatically)  - sizeof(*c_szMDNSendAutomatically);
const int cbMDNSendManually       = sizeof(c_szMDNSendManually)       - sizeof(*c_szMDNSendManually);
const int cbOriginalRecipient     = sizeof(c_szOriginalRecipient)     - sizeof(*c_szOriginalRecipient);
const int cbFinalRecipient        = sizeof(c_szFinalRecipient)        - sizeof(*c_szFinalRecipient);
const int cbOriginalMessageId     = sizeof(c_szOriginalMessageId)     - sizeof(*c_szOriginalMessageId);
const int cbDisplayed             = sizeof(c_szDisplayed)             - sizeof(*c_szDisplayed);


HRESULT ProcessReturnReceipts(IMessageTable  *pTable, 
                             IStoreCallback  *pStoreCB,
                             ROWINDEX        iRow, 
                             RECEIPTTYPE     ReceiptType,
                             FOLDERID        IdFolder,
                             IMimeMessage *pMsg)
{
    IMimeMessage        *pMessage       = NULL;
    IMimeMessage        *pMessageRcpt   = NULL;
    BOOL                fSendImmediate  = FALSE;
    BOOL                fMail           = TRUE;
    LPWABAL             lpWabal         = NULL;
    LPWSTR              lpsz            = NULL;
    MESSAGEINFO         *pMsgInfo       = NULL;
    IImnAccount         *pTempAccount   = NULL;
    HRESULT             hr              = S_OK;
    DWORD               dwOption;
    PROPVARIANT         var = {0};
    FOLDERINFO          FolderInfo = {0};

    TraceCall("ProcessReturnReceipts");

   if (!pTable || !g_pAcctMan)
        return TraceResult(E_INVALIDARG);

    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(IdFolder, &FolderInfo));

    if (FolderInfo.tySpecial == FOLDER_OUTBOX || FolderInfo.tyFolder == FOLDER_NEWS)
    {
        goto exit;
    }

    //First of all check if this has already been processed
    IF_FAILEXIT(hr = pTable->GetRow(iRow, &pMsgInfo));
    
    if ((!pMsgInfo) || (pMsgInfo->dwFlags & (ARF_RCPT_PROCESSED | ARF_NEWSMSG)))
        goto exit;

    //Mark this flag as having been processed
    IF_FAILEXIT(hr = pTable->Mark(&iRow, 1, APPLY_SPECIFIED, MARK_MESSAGE_RCPT_PROCESSED, pStoreCB));

    if(!pMsg)
        IF_FAILEXIT(hr = pTable->OpenMessage(iRow, 0, &pMessage, pStoreCB));
    else
        pMessage = pMsg;
        
#ifdef SMIME_V3
    // Secure receipt check
    hr = ProcessSecureReceipt(pMessage, pStoreCB);
    if(hr != S_OK)
        goto exit;
#endif // SMIME_V3

    dwOption = DwGetOption(OPT_MDN_SEND_RECEIPT);
    if (dwOption == MDN_DONT_SENDRECEIPT)
        goto exit;

    hr = MimeOleGetBodyPropW(pMessage, HBODY_ROOT, STR_HDR_DISP_NOTIFICATION_TO, 
                                        NOFLAGS, &lpsz);

    if (FAILED(hr) || !lpsz || !*lpsz)
    {
        //Check if there is a Return-Receipt-To header
        hr = MimeOleGetBodyPropW(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_RETRCPTTO), 
                                        NOFLAGS, &lpsz);

        if (FAILED(hr) || !lpsz || !*lpsz)
        {
            if (hr == MIME_E_NOT_FOUND)
            {
                //this is a legitimate error, so we don't want to show an error to the user
                hr = S_OK;
            }
            goto exit;
        }
    }

    if (dwOption == MDN_PROMPTFOR_SENDRECEIPT)
    {
        if (!PromptReturnReceipts(pStoreCB))
        goto exit;
    }

    var.vt = VT_LPSTR;
    
    IF_FAILEXIT(hr = pMessage->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var));

    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pTempAccount));
    
    if ((dwOption == MDN_SENDRECEIPT_AUTO) && (!!DwGetOption(OPT_TO_CC_LINE_RCPT)))
    {
        IF_FAILEXIT(hr = CheckForLists(pMessage, pStoreCB, pTempAccount));

        if (hr == S_FALSE)
        {
            // My name is not found in the list. So we don't send a receipt. 
            // However this is not failure.
            goto exit;
        }
    }

    IF_FAILEXIT(hr = HrCreateMessage (&pMessageRcpt));

    IF_FAILEXIT(hr = SetRootHeaderFields(pMessageRcpt, pMessage, lpsz, READRECEIPT));
                
    IF_FAILEXIT(hr = HrSetAccountByAccount(pMessageRcpt, pTempAccount));

    IF_FAILEXIT(hr = HrGetWabalFromMsg(pMessageRcpt, &lpWabal));

    IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMessageRcpt, pTempAccount, lpWabal, TRUE, 0, FALSE));

    IF_FAILEXIT(hr = HrSetWabalOnMsg(pMessageRcpt, lpWabal));

    fSendImmediate = (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline());

    IF_FAILEXIT(hr = SendMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, fMail));

exit:
    
    //Show an error if it failed
    if (FAILED(hr))
        ShowErrorMessage(pStoreCB);

    g_pStore->FreeRecord(&FolderInfo);
    
    SafeMemFree(var.pszVal);

    pTable->ReleaseRow(pMsgInfo);

    SafeRelease(pMessageRcpt);

    SafeRelease(pTempAccount);

    SafeRelease(lpWabal);

    SafeMemFree(lpsz);

    if(!pMsg)
        SafeRelease(pMessage);

    return hr;
}


HRESULT SetRootHeaderFields(IMimeMessage   *pMessageRcpt, 
                            IMimeMessage   *pOriginalMsg, 
                            LPWSTR          lpszNotificationTo,
                            RECEIPTTYPE     ReceiptType)
{
    HRESULT             hr              = S_OK;
    LPWSTR              lpsz            = NULL;
    LPWSTR              szParam         = NULL;
    UINT                ResId;
    LPWSTR              pszRefs         = NULL;
    LPWSTR              pszOrigRefs     = NULL;
    LPWSTR              pszNewRef       = NULL;
    WCHAR               lpBuffer[CCHMAX_STRINGRES];
    int                 cch = 0;

    // Trace
    TraceCall("_SetRootHeaderFields");

    // Set the subject and the To field.
    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, lpszNotificationTo));

    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &lpsz));

    switch (ReceiptType)
    {
        case DELETERECEIPT:
            ResId = idsDeleteReceipt;
            break;

        case READRECEIPT:
        default:
            ResId = idsReadReceipt;
            break;
    }

    if (fMessageEncodingMatch(pOriginalMsg))
    {
        AthLoadStringW(ResId, lpBuffer, CCHMAX_STRINGRES);
    }
    else
    {
        //The encoding didn't match, so we just load english headers
        StrCpyNW(lpBuffer, c_szReadReceipt, CCHMAX_STRINGRES);
    }

    cch = lstrlenW(lpsz) + lstrlenW(lpBuffer) + 1;
    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&szParam,  cch * sizeof(WCHAR)));

    AthwsprintfW(szParam, cch, lpBuffer, lpsz);

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szParam));

    //Set Time
    IF_FAILEXIT(hr = HrSetSentTimeProp(pMessageRcpt, NULL));

    //Set References property
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszNewRef));

    //No need to check for return value. It gets handled correctly in HrCreateReferences
    MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &pszOrigRefs);

    IF_FAILEXIT(hr = HrCreateReferences(pszOrigRefs, pszNewRef, &pszRefs));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, pszRefs));

    //Readable text
    //TODO: Change the file name depending on the ReceiptType
    IF_FAILEXIT(hr = InsertReadableText(pMessageRcpt, pOriginalMsg));

    //Create the second part
    IF_FAILEXIT(hr = InsertSecondComponent(pMessageRcpt, pOriginalMsg));

    //Set Content-type field. Content-type: multipart/report; report-type=disposition-notification;
    //Content-type is multipart, sub-content-type is report and report-type is a parameter whose 
    //value should be set to disposition-notification
    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, c_szMultiPartReport));

    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, HBODY_ROOT, STR_PAR_REPORTTYPE, PDF_ENCODED, c_szDispositionNotification));

exit:
    SafeMemFree(lpsz);
    SafeMimeOleFree(pszNewRef);
    SafeMemFree(szParam);
    SafeMimeOleFree(pszOrigRefs);
    SafeMemFree(pszRefs);
    return(hr);
}

HRESULT InsertReadableText(IMimeMessage  *pMessageRcpt, IMimeMessage *pOriginalMsg)
{
    HBODY           hBody;
    IStream         *pStream    = NULL;
    HRESULT         hr          = S_OK;
    LPWSTR          lpsz        = NULL;
    ULONG           cbWritten;
    WCHAR           lpBuffer[CCHMAX_STRINGRES];
    HCHARSET        hCharset = NULL;
    WCHAR           wszReceiptSentDate[CCHMAX_STRINGRES];
    WCHAR           wszOriginalSentDate[CCHMAX_STRINGRES];
    PROPVARIANT     varOriginal;
    PROPVARIANT     var;
    INETCSETINFO    CsetInfo = {0};

    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &lpsz));

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream((IStream**)&pStream));

    varOriginal.vt = VT_FILETIME;
    IF_FAILEXIT(hr = pOriginalMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &varOriginal));


    var.vt = VT_FILETIME;
    IF_FAILEXIT(hr = pMessageRcpt->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &var));
    
    if (fMessageEncodingMatch(pOriginalMsg))
    {
        AthLoadStringW(idsReadableTextFirst, lpBuffer, CCHMAX_STRINGRES);

        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlenW(lpsz) * sizeof(WCHAR), &cbWritten));

        *lpBuffer = 0;

        AthLoadStringW(idsReceiptAt, lpBuffer, CCHMAX_STRINGRES);
        
        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        *wszOriginalSentDate = 0;
        AthFileTimeToDateTimeW(&varOriginal.filetime, wszOriginalSentDate, ARRAYSIZE(wszOriginalSentDate),
                            DTM_NOSECONDS);

        IF_FAILEXIT(hr = pStream->Write(wszOriginalSentDate, lstrlenW(wszOriginalSentDate) * sizeof(*wszOriginalSentDate), 
                                        &cbWritten));

        AthLoadStringW(idsReadableTextSecond, lpBuffer, CCHMAX_STRINGRES);

        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        *wszReceiptSentDate = 0;
        AthFileTimeToDateTimeW(&var.filetime, wszReceiptSentDate, ARRAYSIZE(wszReceiptSentDate),
                                DTM_NOSECONDS);
    }
    else
    {
        //Insert English headers and content

        IF_FAILEXIT(hr = pStream->Write(c_szReadableTextFirst, cbReadableTextFirst, &cbWritten));

        IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlenW(lpsz) * sizeof(WCHAR), &cbWritten));
        
        IF_FAILEXIT(hr = pStream->Write(c_szReceiptsAt, cbReceiptsAt, &cbWritten));

        //Original Sent Date
        *wszOriginalSentDate = 0;
        AthFileTimeToDateTimeW(&varOriginal.filetime, wszOriginalSentDate, ARRAYSIZE(wszOriginalSentDate),
                                DTM_FORCEWESTERN | DTM_NOSECONDS);

        IF_FAILEXIT(hr = pStream->Write(wszOriginalSentDate, lstrlenW(wszOriginalSentDate) * sizeof(*wszOriginalSentDate), 
                                        &cbWritten));

        //Second line of readable text
        IF_FAILEXIT(hr = pStream->Write(c_szReadableTextSecond, cbReadableTextSecond, &cbWritten));        


        //Receipt Sent Date
        *wszReceiptSentDate = 0;
        AthFileTimeToDateTimeW(&var.filetime, wszReceiptSentDate, ARRAYSIZE(wszReceiptSentDate),
                                DTM_FORCEWESTERN | DTM_NOSECONDS);
    }

    IF_FAILEXIT(hr = pStream->Write(wszReceiptSentDate, lstrlenW(wszReceiptSentDate) * sizeof(*wszReceiptSentDate), 
                                        &cbWritten));

    IF_FAILEXIT(hr = pOriginalMsg->GetCharset(&hCharset));

    // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
    // re-map iso-2022-jp to default charset if they are in the same category
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));
    
    IF_NULLEXIT(hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE)));
    
    IF_FAILEXIT(hr = pMessageRcpt->SetCharset(hCharset, CSET_APPLY_ALL));

    IF_FAILEXIT(hr = pMessageRcpt->SetTextBody(TXT_PLAIN, IET_UNICODE, NULL, pStream, &hBody));

exit:
    SafeRelease(pStream);
    SafeMemFree(lpsz);
    return hr;
}

HRESULT InsertSecondComponent(IMimeMessage  *pMessageRcpt, IMimeMessage     *pOriginalMsg)
{
    HBODY               hBody;
    ULONG               cbWritten;
    IStream             *pStream    = NULL;
    LPTSTR              lpsz        = NULL;
    HRESULT             hr          = S_OK;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream((IStream**)&pStream));

    //Final Recipient
    IF_FAILEXIT(hr = AddOriginalAndFinalRecipient(pOriginalMsg, pMessageRcpt, pStream));
    
    //Original Message Id
    IF_FAILEXIT(hr = MimeOleGetBodyPropA(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpsz));

    IF_FAILEXIT(hr = pStream->Write(c_szOriginalMessageId, cbOriginalMessageId, &cbWritten));

    IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlen(lpsz) * sizeof(TCHAR), &cbWritten));


    //TODO:If the receipt type is deleted, change the last parameter to reflect the correct string

    IF_FAILEXIT(hr = pStream->Write(c_szDisposition, cbDisposition, &cbWritten));

    if (DwGetOption(OPT_MDN_SEND_RECEIPT) == MDN_PROMPTFOR_SENDRECEIPT)
        IF_FAILEXIT(hr = pStream->Write(c_szMDNSendManually, cbMDNSendManually, &cbWritten));
    else
        IF_FAILEXIT(hr = pStream->Write(c_szMDNSendAutomatically, cbMDNSendAutomatically, &cbWritten));
            
    IF_FAILEXIT(hr = pStream->Write(c_szDisplayed, cbDisplayed, &cbWritten));

    IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

    IF_FAILEXIT(hr = pMessageRcpt->AttachObject(IID_IStream, pStream, &hBody));

    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, c_szMessageDispNotification));

    //Change the content-disposition header field to inline, so that this body gets copied and not get attached.
    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, hBody, PIDTOSTR(PID_HDR_CNTDISP), NOFLAGS, STR_DIS_INLINE));

exit:
    MemFree(lpsz);
    ReleaseObj(pStream);

    return hr;
}

HRESULT AddOriginalAndFinalRecipient(IMimeMessage *pOriginalMsg,
                          IMimeMessage *pMessageRcpt,
                          IStream      *pStream)
{
    IMimeEnumAddressTypes   *pEnumAddrTypes = NULL;
    HRESULT                 hr = S_OK;
    ULONG                   cbWritten;
    ULONG                   Count;
    ADDRESSPROPS            AddressProps;
    ULONG                   cFetched;
    IMimeAddressTable       *pAddrTable = NULL;
    LPTSTR                  lpszOriginalRecip = NULL;
    ADDRESSLIST             addrList = {0};

    IF_FAILEXIT(hr = pOriginalMsg->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (LPVOID*)&pAddrTable));

    IF_FAILEXIT(hr = pAddrTable->EnumTypes(IAT_FROM, IAP_EMAIL, &pEnumAddrTypes));
    
#ifdef DEBUG
    IF_FAILEXIT(hr = pEnumAddrTypes->Count(&Count));

    Assert (Count == 1);
#endif DEBUG

    IF_FAILEXIT(hr = pEnumAddrTypes->Next(1, &AddressProps, &cFetched));

    Assert(cFetched == 1);
    
    if (!(AddressProps.pszEmail) || !(*AddressProps.pszEmail))
    {
        hr = E_FAIL;
        goto exit;
    }

    IF_FAILEXIT(hr = pStream->Write(c_szFinalRecipient, cbFinalRecipient, &cbWritten));

    IF_FAILEXIT(hr = pStream->Write(AddressProps.pszEmail, lstrlen(AddressProps.pszEmail) * sizeof(TCHAR), &cbWritten));

    hr = MimeOleGetBodyPropA(pOriginalMsg, HBODY_ROOT, STR_HDR_ORIG_RECIPIENT, NOFLAGS, &lpszOriginalRecip);
    if (SUCCEEDED(hr))
    {
        IF_FAILEXIT(hr = MimeOleParseRfc822Address(IAT_TO, IET_ENCODED, lpszOriginalRecip, &addrList));
        
        if (addrList.cAdrs > 0)
        {
            IF_FAILEXIT(hr = pStream->Write(c_szOriginalRecipient, cbOriginalRecipient, &cbWritten));

            IF_FAILEXIT(hr = pStream->Write(addrList.prgAdr[0].pszEmail, lstrlen(addrList.prgAdr[0].pszEmail), &cbWritten));
        }
    }
    else
    {
        if (hr == MIME_E_NOT_FOUND)
            hr = S_OK;
    }

exit:
    if (g_pMoleAlloc)
    {
        g_pMoleAlloc->FreeAddressProps(&AddressProps);

        if (addrList.cAdrs)
            g_pMoleAlloc->FreeAddressList(&addrList);
    }

    ReleaseObj(pEnumAddrTypes);

    ReleaseObj(pAddrTable);

    MemFree(lpszOriginalRecip);
    
    return hr;
}

HRESULT CheckForLists(IMimeMessage   *pOriginalMsg, IStoreCallback   *pStoreCB, IImnAccount   *pDefAccount)
{
    HRESULT                 hr                  = S_OK;
    IMimeEnumAddressTypes   *pEnumAddrTypes     = NULL;
    ULONG                   cbAddrTypes;
    ULONG                   cFetched;
    ADDRESSPROPS            *prgAddress         = NULL;
    TCHAR                   szEmail[CCHMAX_EMAIL_ADDRESS];
    DWORD                   index;
    
    IF_FAILEXIT(hr = pOriginalMsg->EnumAddressTypes(IAT_TO | IAT_CC, IAP_EMAIL, &pEnumAddrTypes));
        
    IF_FAILEXIT(hr = pEnumAddrTypes->Count(&cbAddrTypes));

    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&prgAddress, cbAddrTypes * sizeof(ADDRESSPROPS)));

    IF_FAILEXIT(hr = pEnumAddrTypes->Next(cbAddrTypes, prgAddress, &cFetched));
    
    IF_FAILEXIT(hr = pDefAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail)));
    
    if (!(*szEmail))
    {
        hr = E_FAIL;
        goto exit;    
    }

    for (index = 0; index < cFetched; index++)
    {
        if (lstrcmpi(szEmail, (prgAddress + index)->pszEmail) == 0)
            break;
    }

    if (index == cFetched)
    {
        //We did not find it.
        hr = S_FALSE;
    }

exit:

    if (g_pMoleAlloc && prgAddress)
    {
        for (index = 0; index < cFetched; index++)
        {
            g_pMoleAlloc->FreeAddressProps(&prgAddress[index]);
        }
    }

    MemFree(prgAddress);

    ReleaseObj(pEnumAddrTypes);
    
    return hr;
}

void ShowErrorMessage(IStoreCallback    *pStoreCB)
{
    HWND    hwnd;

    Assert(pStoreCB);

    if (SUCCEEDED(pStoreCB->GetParentWindow(0, &hwnd)))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsReceiptsError),
                      0, MB_OK);
    }
}

BOOL PromptReturnReceipts(IStoreCallback   *pStoreCB)
{
    HWND    hwnd;
    int     idAnswer;
    BOOL    fRet = FALSE;
//  HWND    hwndFocus;

    if (SUCCEEDED(pStoreCB->GetParentWindow(0, &hwnd)))
    {
        /*
        hwndFocus = GetFocus();
        if (hwndFocus != hwnd)
            hwnd = hwndFocus;
        */

        idAnswer = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsPromptReturnReceipts),
                                          0, MB_YESNO | MB_ICONEXCLAMATION );

        fRet = (idAnswer == IDYES);
    }

    return fRet;
}

BOOL IsMDN(IMimeMessage *pMsg)
{
    LPTSTR      lpsz    = NULL;
    BOOL        fRetVal = FALSE;

    
    if (SUCCEEDED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT, STR_PAR_REPORTTYPE, NOFLAGS, &lpsz)) && (lpsz) && (*lpsz))
    {         
        if (lstrcmp(c_szDispositionNotification, lpsz))
        {
            fRetVal = TRUE;
        }

        MemFree(lpsz);
    }
    return fRetVal;
}

DWORD   GetLockKeyValue(LPCTSTR     pszValue)
{
    DWORD   cbData;
    DWORD   dwLocked = FALSE;
    DWORD   dwType;
    HKEY    hKeyLM;

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, pszValue, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    return dwLocked;
}

BOOL  fMessageEncodingMatch(IMimeMessage *pMsg)
{
    INETCSETINFO    CharsetInfo;
    BOOL            fret = FALSE;
    HRESULT         hr = S_OK;
    HCHARSET        hCharset = NULL;
    CODEPAGEINFO    CodePage = {0};

    Assert(pMsg);

    IF_FAILEXIT(hr = pMsg->GetCharset(&hCharset));

    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CharsetInfo));

    /*
    if (CharsetInfo.cpiWindows == GetACP() || CharsetInfo.cpiWindows == CP_UNICODE)
        fret = TRUE;
    */

    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(CharsetInfo.cpiInternet, &CodePage));

    if (CodePage.cpiFamily == GetACP() || CodePage.cpiFamily == CP_UNICODE)
        fret = TRUE;
exit:

    return fret;
}

#ifdef SMIME_V3

static const BYTE RgbASNForSHASign[11] = 
{
    0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2b, 0x0e, 
    0x03, 0x02, 0x1a
};


// Auto association of signing certificate for secure receipt
BOOL AutoAssociateCert(BOOL *fAllowTryAgain, HWND hwnd, IImnAccount *pTempAccount)
{
    if(*fAllowTryAgain)
    {
        *fAllowTryAgain = FALSE;
        if (SUCCEEDED(_HrFindMyCertForAccount(hwnd, NULL, pTempAccount, FALSE)))
            return(TRUE);
    }
    return(FALSE);
}


void ErrorSendSecReceipt(HWND hwnd, HRESULT hr, IImnAccount *pAccount)
{
    if(hr == HR_E_ATHSEC_NOCERTTOSIGN)
    {
        if(DialogBoxParam(g_hLocRes, 
                MAKEINTRESOURCE(iddErrSecurityNoSigningCert), hwnd, 
                ErrSecurityNoSigningCertDlgProc, NULL) == idGetDigitalIDs)
            GetDigitalIDs(pAccount);
    }
    else
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsCannotSendSecReceipt),
                      0, MB_OK | MB_ICONSTOP);
    return;
}

// Process secure receipts
HRESULT ProcessSecureReceipt(IMimeMessage * pMsg, IStoreCallback  *pStoreCB)
{

    IMimeMessage        *pMessageRcpt   = NULL;
    IMimeBody *         pBody = NULL;
    IMimeBody *         pBodyRec = NULL;
    IMimeSecurity2 *    pSMIME3 = NULL;
    CERT_NAME_BLOB      *rgReceiptFromList = NULL;
    DWORD               cReceiptFromList = 0;
    PCX509CERT          pCert = NULL;
    THUMBBLOB           tbCert = {0, 0};
    HCERTSTORE          hMyCertStore = NULL;
    X509CERTRESULT      certResult;
    CERTSTATE           cs;
    LPVOID              pv = NULL;
    DWORD               dwBits = 40;
    DWORD               cb = 0;
    LPBYTE              pBlobData = NULL;
    ULONG               ulSecurityType = MST_CLASS_SMIME_V1;

    LPWABAL             lpWabal = NULL;
    PROPVARIANT         var = {0};
    DWORD               dwOption = 0;
    UINT                uiRes = 0;
    HRESULT             hr = S_OK;
    IImnAccount         *pTempAccount   = NULL;
    HWND                hwnd = NULL;
    TCHAR               szEmail[CCHMAX_EMAIL_ADDRESS];
    BOOL                fSendImmediate  = FALSE;
    LPWSTR              lpsz            = NULL;
    WCHAR               lpBuffer[CCHMAX_STRINGRES];
    LPWSTR              szParam         = NULL;
    SECSTATE            secStateRec = {0};
    BOOL                fAllowTryAgain = TRUE;
    PCCERT_CONTEXT      *rgCertChain = NULL;
    DWORD               cCertChain = 0;
    const DWORD         dwIgnore = CERT_VALIDITY_NO_CRL_FOUND;
    DWORD               dwTrust = 0;
    LPWSTR              pszRefs         = NULL;
    LPWSTR              pszOrigRefs     = NULL;
    LPWSTR              pszNewRef       = NULL;
    HCHARSET            hCharset = NULL;
    INETCSETINFO        CsetInfo = {0};
    HBODY               hBody = NULL;
    int                 cch;

    Assert(pMsg != NULL);

    // get windof for error messages
    IF_FAILEXIT(hr = pStoreCB->GetParentWindow(0, &hwnd));

    // if option set DO NOT send secure receipt then exit
    dwOption = DwGetOption(OPT_MDN_SEC_RECEIPT);
    if (dwOption == MDN_DONT_SENDRECEIPT)
        goto exit;

    // check do we have secure receipt request in message?
    IF_FAILEXIT(hr = HrGetInnerLayer(pMsg, &hBody));

    IF_FAILEXIT(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody));

    IF_FAILEXIT(hr = pBody->GetOption(OID_SECURITY_TYPE, &var));

    if(!(var.ulVal & MST_RECEIPT_REQUEST))
    {
        var.ulVal = 0; // Set to 0, because var.pszVal and var.ulVal point to the same address.
        hr = S_OK;
        goto exit;
    }
    // Check do we trust this message: Bug 78118
    IF_FAILEXIT(hr = HrGetSecurityState(pMsg, &secStateRec, NULL));
    if(!IsSignTrusted(&secStateRec))
    {
        // do not show any error message in this case,  just exit
        hr = S_OK;
        goto exit;
    }

    // we have request, check that we would like to send receipt
    if (dwOption == MDN_PROMPTFOR_SENDRECEIPT)
    {
        uiRes = (UINT) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSecResponse),
            hwnd, (DLGPROC) SecRecResDlgProc, (LPARAM) 0);

        if(uiRes == 0)
        {
            hr = S_FALSE;
            goto exit;
        }
        else if((uiRes != IDOK) && (uiRes != IDYES))           // IDYES means we will encrypt receipt
        {
            hr = S_OK;
            goto exit;
        }
    }

    // Get SMIME3 Security interface on message
    IF_FAILEXIT(hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pSMIME3));

    // Get List of people who should send receipts
    IF_FAILEXIT(hr = pSMIME3->GetReceiptSendersList(0, &cReceiptFromList,&rgReceiptFromList));

    // Check if asking for receipt from noone
    if (hr == S_FALSE) 
    {
        hr = S_OK;
        goto exit;
    }

    // Check account information
    var.vt = VT_LPSTR;
    
    IF_FAILEXIT(hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var));

    if(FAILED(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pTempAccount)))
    {
        MemFree(var.pszVal);
        goto exit;
    }

    SafeMemFree(var.pszVal);

    // Check that we are in secure list
    IF_FAILEXIT(hr = pTempAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail)));

    if(!FNameInList(szEmail, cReceiptFromList,rgReceiptFromList))
    {
        // we are not in list
        hr = S_FALSE;
        goto exit;
    }

    // Get a certificate for receipt
Try_agian:
    if((hr = pTempAccount->GetProp(AP_SMTP_CERTIFICATE, NULL, &tbCert.cbSize)) != S_OK)
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }
    IF_FAILEXIT(hr = HrAlloc((void**)&tbCert.pBlobData, tbCert.cbSize));
    IF_FAILEXIT(hr = pTempAccount->GetProp(AP_SMTP_CERTIFICATE, tbCert.pBlobData, &tbCert.cbSize));

    hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                    NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);

    if (hMyCertStore == NULL)
        goto exit;

    certResult.cEntries = 1;
    certResult.rgcs = &cs;
    certResult.rgpCert = &pCert;
                    
    if((hr = MimeOleGetCertsFromThumbprints(&tbCert, &certResult, &hMyCertStore, 1) != S_OK))
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }

    // Check certificate
    // As to CRLs, if we'll ever have one!
    dwTrust = DwGenerateTrustedChain(hwnd, NULL, pCert,
                        dwIgnore, TRUE, &cCertChain, &rgCertChain);

    if (rgCertChain)
    {
        for (cCertChain--; int(cCertChain)>=0; cCertChain--)
            CertFreeCertificateContext(rgCertChain[cCertChain]);
        MemFree(rgCertChain);
        rgCertChain = NULL;
    }

    if (dwTrust)
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }
        

    // Create receipt message
    IF_FAILEXIT(hr = pSMIME3->CreateReceipt(0, lstrlen(szEmail), (const BYTE *) szEmail, 1, &pCert, &pMessageRcpt));

//     IF_FAILEXIT(hr = HrCreateMessage (&pMessageRcpt));

//    IF_FAILEXIT(hr = SetRootHeaderFields(pMessageRcpt, pMsg, szEmail, READRECEIPT));  // szEmail is bug!

    // Subject
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &lpsz));
    if (fMessageEncodingMatch(pMsg))
    {
        AthLoadStringW(idsSecureReceiptText, lpBuffer, CCHMAX_STRINGRES);
    }
    else
    {
        //The encoding didn't match, so we just load english headers
        StrCpyNW(lpBuffer, c_szSecReadReceipt, CCHMAX_STRINGRES);
    }

    // Init security options
#if 0
    if(DwGetOption(OPT_MAIL_INCLUDECERT))
    {
        ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
        HrInitSecurityOptions(pMessageRcpt, ulSecurityType);
    }
#endif // 0

    cch = lstrlenW(lpsz) + lstrlenW(lpBuffer) + 1;
    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&szParam,  cch * sizeof(WCHAR)));

    AthwsprintfW(szParam, cch, lpBuffer, lpsz);

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szParam));

    //Set Time
    IF_FAILEXIT(hr = HrSetSentTimeProp(pMessageRcpt, NULL));

    //Set References property
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszNewRef));

    //No need to check for return value. It gets handled correctly in HrCreateReferences
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &pszOrigRefs);

    IF_FAILEXIT(hr = HrCreateReferences(pszOrigRefs, pszNewRef, &pszRefs));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, pszRefs));
               
    IF_FAILEXIT(hr = HrSetAccountByAccount(pMessageRcpt, pTempAccount));
//
    IF_FAILEXIT(hr = HrGetWabalFromMsg(pMessageRcpt, &lpWabal));

    IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMessageRcpt, pTempAccount, lpWabal, TRUE, 0, FALSE));

    IF_FAILEXIT(hr = HrSetWabalOnMsg(pMessageRcpt, lpWabal));

//#if 0
    IF_FAILEXIT(hr = pMessageRcpt->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pBodyRec));

    // Set hash algorithm
    // Init with no symcap gives max allowed by providers
    MimeOleSMimeCapInit(NULL, NULL, &pv);

    MimeOleSMimeCapGetHashAlg(pv, NULL, &cb, &dwBits);

    var.vt = VT_BLOB;
    if(cb > 0)
    {
        if(!MemAlloc((LPVOID *)&pBlobData, cb)) 
            goto exit;

        // ZeroMemory(&pBlobData, cb);

        MimeOleSMimeCapGetHashAlg(pv, pBlobData, &cb, &dwBits);
        var.blob.cbSize = cb;
        var.blob.pBlobData = pBlobData;
    }
    else
    {
        var.blob.cbSize = sizeof(RgbASNForSHASign);
        var.blob.pBlobData = (LPBYTE) RgbASNForSHASign;
    }

    IF_FAILEXIT(hr = pBodyRec->SetOption(OID_SECURITY_ALG_HASH, &var));

#ifdef _WIN64
    var.vt = VT_UI8;
    var.pulVal = (ULONG *) hwnd;
    IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER_64, &var));
#else
    var.vt = VT_UI4;
    var.ulVal = (DWORD) hwnd;
    IF_FAILEXIT(hr = pBodyRec->SetOption(OID_SECURITY_HWND_OWNER, &var));
    var.ulVal = 0; // Set to 0, because var.pszVal and var.ulVal point to the same address.
#endif // _WIN64

//    IF_FAILEXIT(hr = pMessageRcpt->Commit(0));
// #endif //0

    IF_FAILEXIT(hr = pMsg->GetCharset(&hCharset));

    // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
    // re-map iso-2022-jp to default charset if they are in the same category

    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));
    
    IF_NULLEXIT(hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE)));

    IF_FAILEXIT(hr = pMessageRcpt->SetCharset(hCharset, CSET_APPLY_ALL));

    // should be new header
    
    fSendImmediate = (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline());

    if (DwGetOption(OPT_MAIL_INCLUDECERT))
        IF_FAILEXIT(hr = SendSecureMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, TRUE, NULL));
    else
        IF_FAILEXIT(hr = SendMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, TRUE));
exit:
    if(FAILED(hr))
        ErrorSendSecReceipt(hwnd, hr, pTempAccount);

    CleanupSECSTATE(&secStateRec);
    SafeMemFree(lpsz);
    SafeMemFree(szParam);
    SafeMemFree(pBlobData);
    SafeMemFree(pv);
    SafeRelease(pBodyRec);
    SafeRelease(pMessageRcpt);

    if(hMyCertStore)
        CertCloseStore(hMyCertStore, 0);

    if(pCert)
        CertFreeCertificateContext(pCert);

    // if(tbCert.pBlobData)
    SafeMemFree(tbCert.pBlobData);
    SafeRelease(lpWabal);

    SafeRelease(pTempAccount);
    SafeRelease(pSMIME3);
    SafeRelease(pBody);
    SafeMimeOleFree(pszNewRef);
    SafeMimeOleFree(pszOrigRefs);
    MemFree(pszRefs);
    return(hr);
}

INT_PTR CALLBACK SecRecResDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) 
    {
    case WM_INITDIALOG:
        CenterDialog(hwndDlg);
        CheckDlgButton(hwndDlg, IDC_ENCRECEIPT, (!!DwGetOption(OPT_SECREC_ENCRYPT)) ? BST_CHECKED : BST_UNCHECKED);
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            
            EndDialog(hwndDlg, IsDlgButtonChecked(hwndDlg, IDC_ENCRECEIPT) ? IDYES : IDOK);
            break;        
    
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;
            
        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}



#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\uidlcmn.h ===
// ========================================================================================
// U I D L C M N . H
// ========================================================================================
#ifndef __UIDLCMN_H
#define __UIDLCMN_H

// ========================================================================================
// UIDLINFO
// ========================================================================================
typedef struct tagUIDLINFO
{
    BYTE            fDownloaded;
    BYTE            fDeletedOnClient;
    FILETIME        ftDownload;
    LPTSTR          lpszUidl;
    LPTSTR          lpszServer;
    LPTSTR          lpszUserName;

} UIDLINFO, *LPUIDLINFO;

#endif // __UIDLCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\receipts.h ===
#ifndef _RECEIPTS_H_
#define _RECEIPTS_H_

enum RECEIPTTYPE
{
    READRECEIPT,
    DELETERECEIPT,
};

#define MDN_REQUEST                 0x00000001


//Util functions related to receipts
BOOL IsMDN(IMimeMessage *pMsg);
BOOL IsReturnReceiptsAllowed();

HRESULT ProcessReturnReceipts(IMessageTable  *pMsgTable, 
                              IStoreCallback *pStoreCB, 
                              ROWINDEX        iRow, 
                              RECEIPTTYPE     ReceiptType,
                              FOLDERID        IdFolder,
                              IMimeMessage *pMessage);

HRESULT SetRootHeaderFields(IMimeMessage  *pMessageRcpt, 
                         IMimeMessage     *pOriginalMsg, 
                         LPWSTR           lpszNotificationTo,
                         RECEIPTTYPE      ReceiptType);

HRESULT InsertReadableText(IMimeMessage  *pMessageRcpt, 
                           IMimeMessage *pOriginalMsg);

HRESULT InsertSecondComponent(IMimeMessage *pMessageRcpt, 
                              IMimeMessage     *pOriginalMsg);

BOOL    PromptReturnReceipts(IStoreCallback   *pStoreCB);

HRESULT CheckForLists(IMimeMessage   *pOriginalMsg, 
                      IStoreCallback   *pStoreCB, 
                      IImnAccount   *pDefAccount);

HRESULT AddOriginalAndFinalRecipient(IMimeMessage *pOriginalMsg,
                                  IMimeMessage *pMessageRcpt,
                                  IStream      *pStream);
 
DWORD   GetLockKeyValue(LPCTSTR     pszValue);

BOOL  fMessageEncodingMatch(IMimeMessage *pMsg);

void  ShowErrorMessage(IStoreCallback   *pStoreCB);

#endif //_RECEIPTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\rtf2html.h ===
#ifndef _INC_RTF2HTML
#define _INC_RTF2HTML

#ifdef __cplusplus
extern "C" {
#endif 
#define CFCONV_HTML_TO_RTF      0
#define CFCONV_RTF_TO_HTML      1

ULONG   SizeHTML(HGLOBAL hgl);
HANDLE  ConvertRTF2HTML(HANDLE hgl, UINT uiDirection);

int CALLBACK CallbackHTMLtoRTF(UINT  cch, UINT nPercentComplete);
int CALLBACK CallbackRTFtoHTML(int rgf, int unused);
HANDLE  CallMtmTextConverter(HWND   hwnd, 
                             UINT   uiConvertDirection, 
                             HANDLE ghInputData, 
                             long   lInputDataSize);
#ifdef __cplusplus
}
#endif 

#endif //_INC_RTF2HTML
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\grpdlg.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     GrpDlg.h
//
//  PURPOSE:    Defines the CGroupListDlg class.
//

#ifndef __GRPDLG_H__
#define __GRPDLG_H__

#define idtFindDelay    1
#define dtFindDelay     600
#define szDelimiters    TEXT(" ,\t;")

// Forward references
class CNNTPServer;
class CGroupList;
class CSubList;
class CEmptyList;


/////////////////////////////////////////////////////////////////////////////
// Types

// SERVERINFO - One of these structs is kept for each news server currently
//              configured.  We keep all the information about the server,
//              including the agent used to connect, the list of groups which
//              groups are subscribed or new, etc. here.
typedef struct tagSERVERINFO
    {
    LPTSTR           pszAcct;
    CNNTPServer     *pNNTPServer;
    CGroupList      *pGroupList;
    CSubList        *pSubList;
    LPDWORD          rgdwItems;
    LPDWORD          rgdwOrigSub;
    DWORD            cOrigSub;
    DWORD            cItems;
    BOOL             fNewViewed;
    BOOL             fDirty;
    } SERVERINFO, *PSERVERINFO;

// #define SetSubscribed(_b, _f) (_b) = (_f ? ((_b) | GROUP_SUBSCRIBED) : ((_b) & ~GROUP_SUBSCRIBED))
// #define SetNew(_b, _f)        (_b) = (_f ? ((_b) | GROUP_NEW) : ((_b) & ~GROUP_NEW))

// SIZETABLE - This struct is used to make the dialog resizable.  We keep one
//             of these for each control in the dialog.  The rect's are updated
//             in WM_SIZE.  A table of these is built in WM_INITDIALOG.
typedef struct tagSIZETABLE
    {
    HWND hwndCtl;
    UINT id;
    RECT rc;
    } SIZETABLE, *PSIZETABLE;
    
    
// COLUMNS - This struct is used to store the widths of the columns in the 
//           dialog box so the widths can be persisted from session to session.
//           This guy is created in the WM_DESTROY handler and read in
//           CGroupListDlg::InitListView().

#define COLUMNS_VERSION 0x1
#define NUM_COLUMNS     2       // Group name, Description

typedef struct tagCOLUMNS
    {
    DWORD  dwVersion;
    DWORD  rgWidths[NUM_COLUMNS];
    } COLUMNS, *PCOLUMNS;


// CGroupListDlg - This class manages the Newsgroups... Dialog.  It used to have
//                 several subclasses so if it seems wierd to have all these 
//                 functions as virtual that's why.
class CGroupListDlg
    {
    /////////////////////////////////////////////////////////////////////////
    // Initialization
public:
    CGroupListDlg();
    ~CGroupListDlg();
  
#ifdef DEAD
    virtual BOOL FCreate(HWND hwndOwner, CNNTPServer *pNNTPServer, 
                         CSubList *pSubList, LPTSTR* ppszNewGroup, 
                         LPTSTR* ppszNewServer, UINT m_iTabSelect = 0, 
                         BOOL fEnableGoto = TRUE, LPTSTR pszAcctSel = NULL);
#endif // DEAD

protected:
    virtual BOOL FCreate(HWND hwndOwner, UINT idd);

    /////////////////////////////////////////////////////////////////////////
    // Message Handlers
protected:
    static BOOL CALLBACK GroupListDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam);
    virtual BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    virtual void OnTimer(HWND hwnd, UINT id);
    virtual void OnPaint(HWND hwnd);
    virtual void OnClose(HWND hwnd);
    virtual void OnDestroy(HWND hwnd);
    virtual void OnSize(HWND hwnd, UINT state, int cx, int cy);
    virtual void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    virtual void OnChangeServers(HWND hwnd);
    
    virtual BOOL IsGrpDialogMessage(HWND hwnd, LPMSG pMsg);
    
    /////////////////////////////////////////////////////////////////////////
    // Group List manipulation
    void QueryList(LPTSTR pszQuery);
    void ResetList(void);
    void FilterFavorites(void);
    void FilterNew(void);
    
    void SetSubscribed(PSERVERINFO psi, DWORD index, BOOL fSubscribe);
    BOOL IsSubscribed(PSERVERINFO psi, DWORD index);
    BOOL IsNew(PSERVERINFO psi, DWORD index);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    LPTSTR GetFindText(void);
    virtual BOOL ChangeServers(LPTSTR pszAcct, BOOL fUseAgent,
                               BOOL fForce = FALSE);
    BOOL FillServerList(HWND hwndList, LPTSTR pszSelectServer);
    BOOL OnSwitchTabs(HWND hwnd, UINT iTab);
    void UpdateStateInfo(PSERVERINFO psi);
    virtual BOOL InitListView(HWND hwndList);
    void SetLastServer(LPTSTR pszAcct);
    void SetLastGroup(LPTSTR pszGroup);
    PSERVERINFO FInitServer(LPTSTR pszAcct, CNNTPServer* pNNTPServer, 
                            CSubList* pSubList);
    void Sort(LPDWORD rgdw, DWORD c);
    void ShowHideDescriptions(BOOL fShow);
    HRESULT HandleResetButton(void);
    HRESULT SaveCurrentSubscribed(PSERVERINFO psi, LPTSTR** prgszSubscribed, LPUINT pcSub);
    HRESULT RestoreCurrentSubscribed(PSERVERINFO psi, LPTSTR* rgszSub, UINT cSub);
    

    // Whenever we do something that might update the state of a button on
    // the dialog, we call this to allow the subclasses to update their UI.
    virtual void UpdateStateUI(void);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Class Data

    // Array of server information objects.  Each object contains all the 
    // objects and state arrays for the server it needs.
    PSERVERINFO m_rgServerInfo;
    DWORD       m_cServers;
    DWORD       m_cMaxServers;
    PSERVERINFO m_psiCur;
    
    // Handy window handles to have available
    HWND        m_hwnd;
    HWND        m_hwndList;
    HWND        m_hwndFindText;
    HWND        m_hwndOwner;

    // State variables
    BOOL        m_fAllowDesc;       // TRUE if the user can search descriptions
    LPTSTR      m_pszPrevQuery;     // The string that we last searched on
    UINT        m_cchPrevQuery;     // The allocated length of m_pszPrevQuery
    
    // Values used in resizing
    UINT        m_cxHorzSep;
    UINT        m_cyVertSep;
    PSIZETABLE  m_rgst;             // st - SizeTable.  I use this a lot so I wanted it short - SteveSer
    SIZE        m_sizeDlg;
    POINT       m_ptDragMin;

    // Everything else
    HIMAGELIST   m_himlFolders;      // The folder image list.
    HIMAGELIST   m_himlState;
    CNNTPServer *m_pNNTPServer;
    CSubList    *m_pSubList;
    BOOL         m_fServerListInited;
    DWORD        m_dwCurrentAccount;
    LPTSTR       m_pszCurrentAccount;
    LPTSTR       m_pszLastAccount;
    LPTSTR       m_pszLastGroup;    
    BOOL         m_fSaveWindowPos;
    UINT         m_iTabSelect;
    BOOL         m_fEnableGoto;
    LPTSTR       m_pszAcctSel;
    HICON        m_hIcon;

    CEmptyList  *m_pEmptyList;
    };




/////////////////////////////////////////////////////////////////////////////
// Dialog Control ID's
// 

#define idcGroupList                2001            // Group list listview
#define idcFindText                 2002            // Find query edit box
#define idcShowFavorites            2003            // Filter favorites toggle
#define idcUseDesc                  2004            // Use Desc checkbox
#define idcServers                  2005            // Server Listview
#define idcHelp                     2006            // Help button
#define idcResetList                2007            // Rebuild the group list

#define idcUpdateNow                1001
#define idcFullWord                 1004
#define idcPreview                  1006
#define idcProgress                 1007
#define idcApply                    1008
#define idcFind                     1010
#define idcDispText                 1011
#define idcServerText               1012
#define idcPreviewBtn               1013
#define idcSubscribe                1014
#define idcUnsubscribe              1015
#define idcTabs                     1016
#define idcStaticNewsServers        1017
#define idcStaticVertLine           1018
#define idcStaticHorzLine           1019
#define idcGoto                     1020

enum { iTabAll = 0, iTabSubscribed, iTabNew, iTabMax };
enum { iCtlFindText = 0, iCtlUseDesc, iCtlGroupList, iCtlSubscribe, iCtlUnsubscribe,
       iCtlResetList, iCtlGoto, iCtlOK, iCtlCancel, iCtlServers, iCtlStaticNewsServers, iCtlStaticVertLine, 
       iCtlStaticHorzLine, iCtlTabs, iCtlMax };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\wells.cpp ===
/*
 *  w e l l s . c p p 
 *    
 *  Purpose:
 *      implments name checking and stuff for the wells
 *    
 *    Author:brettm
 *
 *  Ported to C++ and modified for Athena from Capone src
 */
#include <pch.hxx>
#include <resource.h>
#include <richedit.h>
#include <ipab.h>
#include <addrlist.h>
#include "addrobj.h"
#include "wells.h"
#include "header.h"
#include <ourguid.h>

ASSERTDATA

HRESULT CAddrWells::HrInit(ULONG cWells, HWND *rgHwnd, ULONG *rgRecipType)
{
    
    if(cWells<=0 || rgHwnd==NULL || rgRecipType==NULL)
        return E_INVALIDARG;

    Assert(m_rgHwnd==NULL);
    Assert(m_rgRecipType==NULL);
    Assert(m_cWells==0);    
    
    if(!MemAlloc((LPVOID *)&m_rgHwnd, sizeof(HWND)*cWells))
        return E_OUTOFMEMORY;

    if(!MemAlloc((LPVOID *)&m_rgRecipType, sizeof(ULONG)*cWells))
        return E_OUTOFMEMORY;

    CopyMemory(m_rgHwnd, rgHwnd, sizeof(HWND)*cWells);
    CopyMemory(m_rgRecipType, rgRecipType, sizeof(ULONG)*cWells);
    m_cWells=cWells;
    return NOERROR;
}

HRESULT CAddrWells::HrSetWabal(LPWABAL lpWabal)
{
    Assert(lpWabal);

    if(!lpWabal)
        return E_INVALIDARG;
    
    ReleaseObj(m_lpWabal);
    m_lpWabal=lpWabal;
    m_lpWabal->AddRef();
    return NOERROR;    
}

HRESULT CAddrWells::HrCheckNames(HWND hwnd, ULONG uFlags)
{
    HRESULT     hr=NOERROR;
    ULONG       ulWell;
    HCURSOR     hcur;
    BOOL        fDirty=FALSE;
           
    if(!m_lpWabal)
        return E_FAIL;

    // This optimization will only occur in the office envelope
    // on autosave. In most cases, the ResolveNames in the header
    // will stop before calling down to this level. For the other 
    // minority cases, we should leave this code in.
    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            {
            fDirty=TRUE;
            break;
            }

    if(!fDirty)
        return NOERROR;
        
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // clear the current list
    m_lpWabal->Reset();

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            hr=HrAddNamesToList(m_rgHwnd[ulWell], m_rgRecipType[ulWell]);

    if(!(uFlags&CNF_DONTRESOLVE))
    {
        if(uFlags&CNF_SILENTRESOLVEUI)
            hr=m_lpWabal->HrResolveNames(NULL, FALSE);
        else
            hr=m_lpWabal->HrResolveNames(hwnd, TRUE);
        HrDisplayWells(hwnd);
    }

    if(hcur)
        SetCursor(hcur);

    return hr;
}

HRESULT CAddrWells::HrDisplayWells(HWND hwnd)
{
    HRESULT hr=E_FAIL;
    HCURSOR hcursor;
    HWND    hwndBlock;
    ULONG   ulWell;
    
    if (m_lpWabal)
    {
        hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        // brettm: hack taken from Capone. LockUpdateWindow doesn't work for the
        // richedit, so we block paints by covering the edit controls with a
        // paint-swallowing window until we're done...
        hwndBlock=HwndStartBlockingPaints(hwnd);
        
        // empty the wells...
        for(ulWell=0; ulWell<m_cWells; ulWell++)
            SetWindowText(m_rgHwnd[ulWell], NULL);
       
        hr=HrAddRecipientsToWells();
        StopBlockingPaints(hwndBlock);
        
        if (hcursor)
            SetCursor(hcursor);
    }
    return hr;
}

CAddrWells::CAddrWells()
{
    m_lpWabal = 0;
    m_rgHwnd = NULL;
    m_rgRecipType = NULL;
    m_cWells = 0;
};

CAddrWells::~CAddrWells()
{
    ReleaseObj(m_lpWabal);
    if(m_rgRecipType)
        MemFree(m_rgRecipType);
    if(m_rgHwnd)
        MemFree(m_rgHwnd);
};



HRESULT CAddrWells::HrAddNamesToList(HWND hwndWell, LONG lRecipType)
{
    ULONG               iOb;
    ULONG               cOb;
    REOBJECT            reobj = {0};
    HRESULT             hr;
    PHCI                phci;
    LPRICHEDITOLE       preole;
    LPPERSIST           ppersist = NULL;
    LPWSTR              pwszText = NULL;
    DWORD               cch;

    Assert(IsWindow(hwndWell));

    // if the edit is not dirty, we're done
    if(!Edit_GetModify(hwndWell))
        return S_OK;

    phci = (HCI*)GetWindowLongPtr(hwndWell, GWLP_USERDATA);
    Assert(phci);

    preole = phci->preole;
    Assert(preole);

    m_hwndWell = hwndWell;
    m_cchBuf = 0;
    m_fTruncated = FALSE;
    m_lRecipType = lRecipType;

    reobj.cbStruct = sizeof(reobj);

    cOb = preole->GetObjectCount();
    for (iOb = 0; iOb < cOb; iOb++)
    {
        LPADRINFO   pAdrInfo=NULL;
        IF_FAILEXIT(hr = preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ));
        
        IF_FAILEXIT(hr = reobj.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&ppersist));
#ifdef DEBUG
        AssertValidAddrObject(reobj.poleobj);
#endif
        // HrGetAdrInfo doesn't alloc memory.
        IF_FAILEXIT(hr = ((CAddrObj *)ppersist)->HrGetAdrInfo(&pAdrInfo));
        
        // set the new recipient type...
        pAdrInfo->lRecipType=lRecipType;
        IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(pAdrInfo));

        SafeRelease(ppersist);
        SafeRelease(reobj.poleobj);
    }
    
    // now we add in all the unresolved names...

    cch = GetRichEditTextLen(m_hwndWell) + 1;
    if (0 == cch)
        return (S_FALSE);

    IF_NULLEXIT(MemAlloc((LPVOID*)&pwszText, cch * sizeof(WCHAR)));

    GetRichEditText(m_hwndWell, pwszText, cch, FALSE, phci->pDoc);

    hr = UnresolvedText(pwszText, cch - 1); 
    
    // Add whatever is left after the last semicolon
    if (SUCCEEDED(hr))
        HrAddUnresolvedName();
    
exit:
    if(m_fTruncated)      // warn if we trucated an address
        MessageBeep(MB_OK);
    
    ReleaseObj(reobj.poleobj);
    ReleaseObj(ppersist);
    MemFree(pwszText);
    
    return hr;
}


HRESULT CAddrWells::OnFontChange()
{
    ULONG   ulWell;

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        _UpdateFont(m_rgHwnd[ulWell]);

    return S_OK;
}


HRESULT CAddrWells::_UpdateFont(HWND hwndWell)
{
    ULONG               iOb;
    ULONG               cOb;
    REOBJECT            rObject={0};
    IRichEditOle        *pREOle;
    IOleInPlaceSite     *pIPS;
    LPPERSIST           pPersist = NULL;

    rObject.cbStruct = sizeof(REOBJECT);

    // walk the ole objects and send them an font-update
    if (SendMessage(hwndWell, EM_GETOLEINTERFACE, 0, (LPARAM) &pREOle))
    {
        cOb = pREOle->GetObjectCount();

        for (iOb = 0; iOb < cOb; iOb++)
        {
            if (pREOle->GetObject(iOb, &rObject, REO_GETOBJ_POLEOBJ)==S_OK)
            {
                if (rObject.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&pPersist)==S_OK)
                {
                    ((CAddrObj *)pPersist)->OnFontChange();
                    pPersist->Release();
                }
                rObject.poleobj->Release();
            }
        }
        pREOle->Release();
    }
    InvalidateRect(hwndWell, NULL, TRUE);
    return S_OK;
}


HRESULT CAddrWells::HrAddUnresolvedName()
{
    HRESULT hr = S_OK;
    // strip any trailing white-space
    while(m_cchBuf > 0 && (m_rgwch[m_cchBuf - 1] == L' '
                            || m_rgwch[m_cchBuf - 1] == L'\t'))
        --m_cchBuf;

    if (m_cchBuf)
    {
        // there is something in the buffer...
        m_rgwch[m_cchBuf] = L'\0';
        hr = m_lpWabal->HrAddUnresolved(m_rgwch, m_lRecipType);
        m_cchBuf = 0;
    }
    
    return hr;
}

HRESULT CAddrWells::UnresolvedText(LPWSTR pwszText, LONG cch)
{
    HRESULT     hr = S_OK;

    // The algorithm below will strip spaces off of the
    // beginning and end of each name

    while (cch)
    {
        cch--;
        // On some versions of richedit, 0xfffc is inserted in the text
        // where there is a addrObj present. So just skip over that.
        if ((L'\t' == *pwszText) || (0xfffc == *pwszText))
            *pwszText = L' ';
        
        if (*pwszText == L';' || *pwszText == L'\r'|| *pwszText == L',')
        {
            hr = HrAddUnresolvedName();
            if (S_OK != hr)
                goto err;
        }
        else
        {
            if ((*pwszText != L' ' && *pwszText != L'\n' && *pwszText != L'\r')
                || m_cchBuf > 0)
            {
                if (m_cchBuf < ARRAYSIZE(m_rgwch) - 1)
                    m_rgwch[m_cchBuf++] = *pwszText;
                else
                    // Truncation has occurred so I want to beep
                    m_fTruncated = TRUE;
            }
        }
        ++pwszText;
    }
    
err:
    return hr;
}




enum
{
    mapiTo=0,
    mapiCc,
    mapiFrom,
    mapiReplyTo,
    mapiBcc,
    mapiMax
};

HRESULT CAddrWells::HrAddRecipientsToWells()
{
    HRESULT         hr;
    ADRINFO         AdrInfo;
    HWND            hwnd;
    HWND            hwndMap[mapiMax]={0};
    ULONG           ulWell;
    
    Assert(m_lpWabal);
    // walk the list of entries, and add them to the well...
    
    // build mapping to MAPI_TO -> hwnd if available to make the lookup quicker..
    
    for(ulWell=0; ulWell<m_cWells; ulWell++)
    {
        switch(m_rgRecipType[ulWell])
        {
            case MAPI_TO:
                hwndMap[mapiTo]=m_rgHwnd[ulWell];
                break;
            case MAPI_CC:
                hwndMap[mapiCc]=m_rgHwnd[ulWell];
                break;
            case MAPI_BCC:
                hwndMap[mapiBcc]=m_rgHwnd[ulWell];
                break;
            case MAPI_REPLYTO:
                hwndMap[mapiReplyTo]=m_rgHwnd[ulWell];
                break;
            case MAPI_ORIG:
                hwndMap[mapiFrom]=m_rgHwnd[ulWell];
                break;
        }
    }
    
    if(m_lpWabal->FGetFirst(&AdrInfo))
    {
        do
        {
            hwnd=0;
            switch(AdrInfo.lRecipType)
            {
                case MAPI_TO:
                    hwnd=hwndMap[mapiTo];
                    break;
                case MAPI_CC:
                    hwnd=hwndMap[mapiCc];
                    break;
                case MAPI_ORIG:
                    hwnd=hwndMap[mapiFrom];
                    break;
                case MAPI_BCC:
                    hwnd=hwndMap[mapiBcc];
                    break;
                case MAPI_REPLYTO:
                    hwnd=hwndMap[mapiReplyTo];
                    break;
                default:
                    AssertSz(0, "Unsupported RECIPTYPE in AdrList");
            }
            
            if(hwnd && IsWindow(hwnd))
            {
                hr = HrAddRecipientToWell(hwnd, &AdrInfo, TRUE);
                if(FAILED(hr))
                    return hr;
            }
        }
        while(m_lpWabal->FGetNext(&AdrInfo));
    }        
    return NOERROR;
}

/*
 *    HrAddRecipientToWell
 *    
 *    Purpose:
 *        This function adds a recipient to a recipient well.
 *    
 *    Parameters:
 *        hwndEdit        hwnd of the recipient well to add the
 *                        recipient to
 *        pae                pointer to an ADRENTRY
 *        fAddSemi        whether to add a semicolon between entries
 *        fCopyEntry        whether to copy the ADRENTRY or just use it
 *    
 *    Returns:
 *        scode
 */
HRESULT HrAddRecipientToWell(HWND hwndEdit, LPADRINFO lpAdrInfo, BOOL fAddSemi)
{
    HRESULT         hr = S_OK;
    CAddrObj       *pAddrObj = NULL;
    INT             cch;
    REOBJECT        reobj = {0};
    PHCI            phci;
    LPRICHEDITOLE   preole;

    Assert(IsWindow(hwndEdit));
    Assert(lpAdrInfo);

    phci = (HCI*)GetWindowLongPtr(hwndEdit, GWLP_USERDATA);
    Assert(phci);

    preole = phci->preole;
    Assert(preole);

    if(lpAdrInfo->fResolved)
    {
        // Initialize the object information structure
        reobj.cbStruct = sizeof(reobj);
        reobj.cp = REO_CP_SELECTION;
        reobj.clsid = CLSID_AddrObject;
        reobj.dwFlags = REO_BELOWBASELINE|REO_INVERTEDSELECT|
            REO_DYNAMICSIZE|REO_DONTNEEDPALETTE;
        reobj.dvaspect = DVASPECT_CONTENT;
        
        IF_FAILEXIT(hr = preole->GetClientSite(&reobj.polesite));
        
        IF_NULLEXIT(pAddrObj = new CAddrObj());
        
        IF_FAILEXIT(hr = pAddrObj->HrSetAdrInfo(lpAdrInfo));
    }
    
    if (fAddSemi && (cch = GetRichEditTextLen(hwndEdit)))
    {
        Edit_SetSel(hwndEdit, cch, cch);
        HdrSetRichEditText(hwndEdit, L"; ", TRUE);
    }
    
    if (!lpAdrInfo->fResolved)
    {
        // Its an unresolved name
        AssertSz(lpAdrInfo->lpwszDisplay, "Recipient must have a Display Name");
        HdrSetRichEditText(hwndEdit, lpAdrInfo->lpwszDisplay, TRUE);
    }
    else
    {
        // Its a resolved name
        IF_FAILEXIT(hr = pAddrObj->QueryInterface(IID_IOleObject, (LPVOID *)&reobj.poleobj));
        
        IF_FAILEXIT(hr = reobj.poleobj->SetClientSite(reobj.polesite));
        
        IF_FAILEXIT(hr = preole->InsertObject(&reobj));
    }
    
exit:
    ReleaseObj(reobj.poleobj);
    ReleaseObj(reobj.polesite);
    ReleaseObj(pAddrObj);
    return hr;
}

HRESULT CAddrWells::HrSelectNames(HWND hwnd, int iFocus, BOOL fNews)
{
    HRESULT     hr;
    ULONG       ulWell;


    m_lpWabal->Reset();

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            hr=HrAddNamesToList(m_rgHwnd[ulWell], m_rgRecipType[ulWell]);

    hr=m_lpWabal->HrPickNames(hwnd, m_rgRecipType, m_cWells, iFocus, fNews);
    if(FAILED(hr))
        goto error;

    hr=HrDisplayWells(hwnd);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\newsdlgs.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newsdlgs.h
//
//  PURPOSE:    Defines general news dialogs
//

#ifndef __NEWSDLGS_H__
#define __NEWSDLGS_H__


/////////////////////////////////////////////////////////////////////////////
// Dialog callbacks

typedef struct tagUPDATENEWSGROUPINFO 
    {
    BOOL fNews;
    DWORD dwGroupFlags;
    DWORD cMarked;
    int   idCmd;
    } UPDATENEWSGROUPINFO, *PUPDATENEWSGROUPINFO;

INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/////////////////////////////////////////////////////////////////////////////
// Control IDs

#define IDC_GET_CHECK                               1001
#define IDC_NEWHEADERS_RADIO                        1002
#define IDC_NEWMSGS_RADIO                           1003
#define IDC_ALLMSGS_RADIO                           1004
#define IDC_GETMARKED_CHECK                         1005



#endif // __NEWSDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\mail\wells.h ===
/*
 *  w e l l s . h
 *	
 *  Purpose:
 *  	implments name checking and stuff for the wells
 *	
 *	Author:brettm
 */

#ifndef _WELLS_H
#define _WELLS_H

#include <ipab.h>

#define cchUnresolvedMax 512

enum    // flags for check names
{
    CNF_DONTRESOLVE     =0x01,
    CNF_SILENTRESOLVEUI =0x02
};

class CAddrWells
{
public:
    CAddrWells();
    ~CAddrWells();

    HRESULT HrInit(ULONG cWells, HWND *rgHwnd, ULONG *rgRecipType);
    HRESULT HrSetWabal(LPWABAL lpWabal);
    HRESULT HrCheckNames(HWND hwnd, ULONG uFlags);
    HRESULT HrSelectNames(HWND hwnd, int iFocus, BOOL fNews);
    HRESULT HrDisplayWells(HWND hwnd);
    HRESULT OnFontChange();

private:
    HRESULT UnresolvedText(LPWSTR pwszText, LONG cch);
    HRESULT HrAddNamesToList(HWND hwndWell, LONG lRecipType);
    HRESULT HrAddUnresolvedName();
    HRESULT HrAddRecipientsToWells();

private:
    HWND    *m_rgHwnd;
    ULONG   *m_rgRecipType;
    ULONG   m_cWells;
    LPWABAL m_lpWabal;

    // stuff used for dynamic parsing
    HWND                m_hwndWell;
    WCHAR               m_rgwch[cchUnresolvedMax];
    ULONG               m_cchBuf;
    BOOL                m_fTruncated;
    LONG                m_lRecipType;

    HRESULT _UpdateFont(HWND hwndWell);

};

// utility function...
HRESULT HrAddRecipientToWell(HWND hwndEdit, LPADRINFO lpAdrInfo, BOOL fAddSemi=FALSE);

#endif // _WELLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\newsstor.h ===
/*
 *  n e w s s t o r . h
 *  
 *  Purpose:
 *      Derives from IMessageServer to implement news specific store communication
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _NEWSSTOR_H
#define _NEWSSTOR_H

#include "imnxport.h"
#include "range.h"

interface IMimeMessage;
typedef IMimeMessage *LPMIMEMESSAGE;
typedef DWORD MSGID;

class CNewsStore;
typedef HRESULT (CNewsStore::*PFNOPFUNC)(THIS_ void);

#define OPFLAG_DESCRIPTIONS     0x0001
#define OPFLAG_NOGROUPCMD       0x0002

typedef struct tagOPERATION
{
    STOREOPERATIONTYPE tyOperation;
    const PFNOPFUNC *pfnState;
    int iState;
    int cState;
    IStoreCallback *pCallback;
    NNTPSTATE nsPending;
    DWORD dwFlags;

    ULONG cPrevFolders;
    FOLDERID *pPrevFolders;
    FOLDERID idFolder;
    SYNCFOLDERFLAGS dwSyncFlags;
    SYSTEMTIME st;
    DWORD cHeaders;
    MESSAGEID idMessage;
    LPSTR pszArticleId;
    IStream *pStream;
    FILEADDRESS faStream;
    MESSAGEFLAGS dwMsgFlags;
    LPSTR pszGroup;
    DWORD idServerMessage;

    BOOL fCancel;
    STOREERROR error;
    DWORD dwProgress;
    DWORD dwTotal;
} OPERATION;

typedef struct tagSREFRESHOP {
    DWORD       dwFirstNew;
    DWORD       dwLast;
    DWORD       dwFirst;
    DWORD       dwChunk;
    DWORD       dwDlSize;
    UINT        uObtained;
    UINT        cOps;
    UINT        MaxOps;
    BOOL        fEnabled;
    BOOL        fOnlyNewHeaders;
} SREFRESHOP;

class CNewsStore :
        public IMessageServer,
        public INNTPCallback,
        public IOperationCancel,
        public INewsStore,
        public ITransportCallbackService
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CNewsStore(void);
    ~CNewsStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageServer Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder (SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback  *pCallback);
    STDMETHODIMP GetMessage (MESSAGEID idMessage, IStoreCallback  *pCallback);
    STDMETHODIMP PutMessage (FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream  *pStream, IStoreCallback  *pCallback);        
    STDMETHODIMP CopyMessages (IMessageFolder  *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteMessages (DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback  *pCallback);
    STDMETHODIMP SetMessageFlags (LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore (FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP CreateFolder (FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP MoveFolder (FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback);
    STDMETHODIMP RenameFolder (FOLDERID idFolder, LPCSTR pszName, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteFolder (FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP SubscribeToFolder (FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetAdBarUrl(IStoreCallback     *pCallback) {return E_NOTIMPL;};
    STDMETHODIMP GetMinPollingInterval(IStoreCallback     *pCallback) {return E_NOTIMPL;};
    HRESULT      Initialize(FOLDERID idStoreRoot, LPCSTR pszAccountId);
    HRESULT      GetArticle(LPCSTR pszArticleId, IStream *pStream, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel);

    //----------------------------------------------------------------------
    // INNTPCallback Members
    //----------------------------------------------------------------------
    STDMETHODIMP OnTimeout (DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt (LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt (HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus (IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError (IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand (CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);
    STDMETHODIMP OnResponse (LPNNTPRESPONSE pResponse);

    //----------------------------------------------------------------------
    // ITransportCallbackService
    //----------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);
    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAcount);

    //----------------------------------------------------------------------
    // INewsStore
    //----------------------------------------------------------------------
    STDMETHODIMP MarkCrossposts(LPMESSAGEIDLIST pList, BOOL fRead);

    HRESULT Connect(void);
    HRESULT Group(void);
    HRESULT GroupIfNecessary(void);
    HRESULT ExpireHeaders(void);
    HRESULT Headers(void);
    HRESULT Article(void);
    HRESULT Post(void);
    HRESULT List(void);
    HRESULT DeleteDeadGroups(void);
    HRESULT Descriptions(void);
    HRESULT NewGroups(void); 
    HRESULT XHdrReferences(void);
    HRESULT XHdrSubject(void);
    HRESULT WatchedArticles(void);

    static LRESULT CALLBACK NewsStoreWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    void        _FreeOperation(void);
    HRESULT     _DoOperation(void);
    HRESULT     _BeginDeferredOperation(void);
    HRESULT     _List(LPCSTR pszCommand);
    HRESULT     _ComputeHeaderRange(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, FOLDERINFO *pInfo, RANGE *pRange);
    void        _MarkCrossposts(LPCSTR szXRefs, BOOL fRead);

    BOOL        _CreateWnd(void);
    HRESULT     _CreateDataFilePath(LPCTSTR pszAccount, LPCTSTR pszFileName, LPTSTR pszPath);
    
    BOOL        _FConnected() { return (m_pTransport && m_ixpStatus != IXP_DISCONNECTING && m_ixpStatus != IXP_DISCONNECTED ); }
    HRESULT     _HandleArticleResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleListResponse(LPNNTPRESPONSE pResp, BOOL fNew);
    HRESULT     _HandleHeadResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleGroupResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandlePostResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleXHdrReferencesResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleXHdrSubjectResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleWatchedArticleResponse(LPNNTPRESPONSE pResp);

    void        _FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult, LPSTR pszGroup = NULL);
    BOOL        _IsWatchedThread(LPSTR pszRef, LPSTR pszSubject);
    HRESULT     _SaveMessageToStore(IMessageFolder *pFolder, DWORD id, LPSTREAM pstm);

    //----------------------------------------------------------------------
    // Class Member Data
    //----------------------------------------------------------------------
private:
    
    LONG                    m_cRef;         // Reference Counting
    HWND                    m_hwnd;
    IMessageStore          *m_pStore;
    IMessageFolder         *m_pFolder;
    FOLDERID                m_idFolder;
    FOLDERID                m_idParent;
    char                    m_szGroup[256];
    char                    m_szAccountId[CCHMAX_ACCOUNT_NAME];

    OPERATION               m_op;
    SREFRESHOP             *m_pROP;

    INNTPTransport         *m_pTransport;
    IXPSTATUS               m_ixpStatus;
    INETSERVER              m_rInetServerInfo;
    DWORD                   m_dwLastStatusTicks;

    // GetWatchInfo state
    DWORD                   m_dwWatchLow;
    DWORD                   m_dwWatchHigh;

    LPTSTR                 *m_rgpszWatchInfo;
    BOOL                    m_fXhdrSubject;
    CRangeList              m_cRange;
    DWORD                   m_cCurrent;
    DWORD                   m_cTotal;

    IMessageTable          *m_pTable; // Used for downloading Watched Messages.

#ifdef DEBUG
    DWORD                   m_dwThreadId;
#endif // DEBUG
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateNewsStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT NewsUtil_CreateDataFilePath(LPCTSTR pszAccount, LPCTSTR pszFileName, LPTSTR pszPath);

#endif  //_NEWSSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\newsutil.cpp ===
#include "pch.hxx"
#include "storutil.h"
#include <mailutil.h>
#include "range.h"
#include "shlwapip.h" 
#include <xpcomm.h>
#include <subscr.h>
#include "newsstor.h"
#include <storecb.h>
#include "newsutil.h"

ASSERTDATA

static const char c_szCancelFmt[] = "cancel %s";

//
//  FUNCTION:   NewsUtil_FCanCancel
//
//  PURPOSE:    This function determines whether cancel should be allowed
//
//  PARAMETERS: szDisplayFrom   - the display portion of the From: field
//              szEmailFrom     - the address portion of the From: field
//
//  RETURN VALUE: TRUE if cancel should be allowed
//
BOOL NewsUtil_FCanCancel(FOLDERID idFolder, LPMESSAGEINFO pInfo)
{
    HRESULT hr;
    BOOL fRet;
    FOLDERINFO info;
    char sz[CCHMAX_DISPLAY_NAME];
    IImnAccount *pAcct;
    
    Assert(pInfo != NULL);
    Assert(CCHMAX_EMAIL_ADDRESS <= CCHMAX_DISPLAY_NAME);

    fRet = FALSE;

    hr = g_pStore->GetFolderInfo(idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_NEWS &&
            0 == (pInfo->dwFlags & ARF_ARTICLE_EXPIRED) &&
            pInfo->pszAcctId != NULL &&
            pInfo->pszDisplayFrom != NULL &&
            pInfo->pszEmailFrom != NULL)
        {
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
            if (SUCCEEDED(hr))
            {
                // make sure the display name and the email address match
                if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, sz, ARRAYSIZE(sz))))
                {
                    if (!lstrcmp(pInfo->pszDisplayFrom, sz))
                    {
                        if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, sz, ARRAYSIZE(sz))))
                            fRet = (0 == lstrcmp(pInfo->pszEmailFrom, sz));
                    }
                }
    
                pAcct->Release();
            }
        }

        g_pStore->FreeRecord(&info);
    }

    return(fRet);
}

//
//  FUNCTION:   NewsUtil_HrCancelPost
//
//  PURPOSE:    This function cancels the specified article
//
//  PARAMETERS: hwnd        - the hwnd for ui
//              pszAccount  - the account to use to cancel the article
//              szMsgId     - the Message-ID:   of the article to cancel
//              szFrom      - the From:         of the article to cancel
//              szSubj      - the Subject:      of the article to cancel
//              szGroups    - the Newsgroups:   of the article to cancel
//              szDistrib   - the Distribution: of the article to cancel
//
//  RETURN VALUE: HRESULT
//
HRESULT NewsUtil_HrCancelPost(HWND hwnd, FOLDERID idGroup, LPMESSAGEINFO pInfo)
{
    HRESULT         hr;
    FOLDERINFO      info;
    LPMIMEMESSAGE   pMsg;
    LPSTR           pszCancel;
    IImnAccount    *pAcct;

    Assert(pInfo != NULL);
    
    if (!NewsUtil_FCanCancel(idGroup, pInfo) && DwGetOption(OPT_CANCEL_ALL_NEWS))
    {
        if (AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsVerifyCancel),
                          NULL,
                          MB_YESNO) == IDNO)
        {
            return (FALSE);
        }
    }


    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
    if (FAILED(hr))
        return(hr);

    if (!MemAlloc((void **)&pszCancel, lstrlen(pInfo->pszMessageId) + 20))
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pStore->GetFolderInfo(idGroup, &info);
        if (SUCCEEDED(hr))
        {
            hr = HrCreateMessage(&pMsg);
            if (SUCCEEDED(hr))
            {
                wsprintf(pszCancel, c_szCancelFmt, pInfo->pszMessageId);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CONTROL), NOFLAGS, pszCancel);
                
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), PDF_ENCODED | PDF_SAVENOENCODE, pInfo->pszFromHeader);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pInfo->pszSubject);
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, info.pszName);
                
                HrSetAccountByAccount(pMsg, pAcct);
    
                hr = pMsg->Commit(0);
                if (SUCCEEDED(hr))
                {
                    hr = HrSendMailToOutBox(hwnd, pMsg, TRUE, FALSE, FALSE);
                    if (SUCCEEDED(hr))
                    {
                        DoDontShowMeAgainDlg(hwnd, c_szDSCancelNews, 
                            MAKEINTRESOURCE(idsAthena), 
                            MAKEINTRESOURCE(idsDelSentToServer), 
                            MB_OK);
                    }
                    else
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                            MAKEINTRESOURCEW(idsCancelFailed), NULL, MB_OK);
                    }
                }

                pMsg->Release();
            }
    
            g_pStore->FreeRecord(&info);
        }
    
        MemFree(pszCancel);
    }

    pAcct->Release();

    return(hr);
}

DWORD NewsUtil_GetNotDownloadCount(FOLDERINFO *pInfo)
{
    DWORD dw, curr, cOverlap, dwMax;
    CRangeList *pRange;

    Assert(pInfo != NULL);

    dw = 0;

    if (pInfo->dwServerHigh != 0 &&
        pInfo->dwServerLow <= pInfo->dwServerHigh)
    {
        pRange = new CRangeList;
        if (pRange != NULL)
        {
            dw = pInfo->dwServerCount;

            if (pInfo->Requested.cbSize > 0)
            {
                pRange->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

                dwMax = pRange->Max();

                Assert(pInfo->dwServerHigh >= dwMax);
                if ((pInfo->dwServerHigh - dwMax) >= dw)
                {
                    dw = 0;
                }
                else
                {
                    dw -= pInfo->dwServerHigh - dwMax;

                    curr = pInfo->dwServerLow - 1;
                    cOverlap = 0;

                    while (-1 != (curr = pRange->Next(curr)))
                        cOverlap++;
                    if (cOverlap < dw)
                        dw -= cOverlap;
                    else
                        dw = 0;
                }

                Assert(dwMax >= pInfo->dwClientHigh);
                if (pInfo->dwServerHigh > dwMax)
                    dw += pInfo->dwServerHigh - dwMax;
            }

            pRange->Release();
        }
    }

    return(dw);
}

HRESULT NewsUtil_CheckForNewGroups(HWND hwnd, FOLDERID idFolder, CGetNewGroups **ppGroups)
    {
    HRESULT     hr;
    FILETIME    ftLast;
    FILETIME    ftNow;
    SYSTEMTIME  stNow, stLast;
    BOOL        fUpdate;
    IImnAccount *pAcct;
    DWORD       dwSize;
    FOLDERINFO  info;
    CGetNewGroups *pGroups;

    Assert(ppGroups != NULL);
    Assert(*ppGroups == NULL);

    hr = GetFolderServer(idFolder, &info);
    if (FAILED(hr))
        return(hr);

    Assert(info.tyFolder == FOLDER_NEWS);
    if (FHasChildren(&info, FALSE))
    {
        fUpdate = FALSE;

        // Get the current  time
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &ftNow);

        // Get the account object for this server
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, info.pszAccountId, &pAcct)))
        {
            dwSize = sizeof(ftLast);
            if (SUCCEEDED(pAcct->GetProp(AP_LAST_UPDATED, (LPBYTE)&ftLast, &dwSize)))
            {
                FileTimeToSystemTime(&ftLast, &stLast);
                fUpdate = (stNow.wYear > stLast.wYear ||
                            stNow.wMonth > stLast.wMonth ||
                            stNow.wDay > stLast.wDay);
            }
            else
            {
                pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&ftNow, sizeof(ftNow));
                pAcct->SaveChanges();
            }

            pAcct->Release();
        }

        if (fUpdate)
        {
            pGroups = new CGetNewGroups(hwnd, info.idFolder, info.pszAccountId, &ftNow);
            if (pGroups == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = g_pStore->GetNewGroups(info.idFolder, &stLast, (IStoreCallback *)pGroups);
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                }
                else
                {
                    pGroups->Release();
                    pGroups = NULL;
                }
            }

            *ppGroups = pGroups;
        }
    }

    g_pStore->FreeRecord(&info);

    return(hr);
}

CGetNewGroups::CGetNewGroups(HWND hwnd, FOLDERID idFolder, LPCSTR pszAcctId, FILETIME *pft)
{
    Assert(hwnd != NULL);
    Assert(idFolder != FOLDERID_INVALID);
    Assert(pszAcctId != NULL);
    Assert(pft != NULL);

    m_cRef = 1;
    m_hr = E_FAIL;
    m_fComplete = FALSE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;

    m_hwnd = hwnd;
    m_idFolder = idFolder;
    lstrcpy(m_szAcctId, pszAcctId);
    m_ft = *pft;
}

CGetNewGroups::~CGetNewGroups()
{
    if (m_pCancel != NULL)
    {
        m_pCancel->Cancel(CT_ABORT);
        m_pCancel->Release();
    }
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGetNewGroups::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGetNewGroups::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CGetNewGroups::Close()
{
    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_ABORT);

    return(S_OK);
}

HRESULT CGetNewGroups::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation == SOT_GET_NEW_GROUPS);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(!m_fComplete);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Call into general OnLogonPrompt Utility
    return(S_FALSE);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwnd != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    PostMessage(m_hwnd, NVM_GETNEWGROUPS, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CGetNewGroups::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwnd != NULL);

    *phwndParent = m_hwnd;

    return(S_OK);
}

HRESULT CGetNewGroups::HandleGetNewGroups()
{
    FOLDERINFO info;
    IImnAccount *pAcct;
    HRESULT hr;

    Assert(m_fComplete);

    if (m_hr == S_OK)
    {
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAcctId, &pAcct)))
        {
            pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&m_ft, sizeof(m_ft));
            pAcct->SaveChanges();
            pAcct->Release();

            if (DwGetOption(OPT_NOTIFYGROUPS))
            {
                hr = g_pStore->GetFolderInfo(m_idFolder, &info);
                if (FAILED(hr))
                    return(hr);

                if (!!(info.dwFlags & FOLDER_HASNEWGROUPS))
                {
                    // If there are new groups, ask the user if they care.
                    if (IDYES == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena),
                                   MAKEINTRESOURCEW(idsNewGroups), 0,
                                   MB_ICONINFORMATION | MB_YESNO))
                    {
                        DoSubscriptionDialog(m_hwnd, TRUE, m_idFolder, TRUE);
                    }
                }

                g_pStore->FreeRecord(&info);
            }
        }
    }

    return(S_OK);
}

class CDownloadArticleCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CDownloadArticleCB(void);
        ~CDownloadArticleCB(void);

        HRESULT Download(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg);

        static INT_PTR CALLBACK DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndDlg;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
        LPCSTR      m_pszArticle;
        LPSTREAM    m_pStream;
        CNewsStore *m_pNewsStore;
};

INT_PTR CALLBACK CDownloadArticleCB::DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    CDownloadArticleCB *pThis = (CDownloadArticleCB *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            // replace some strings in the group download dialog
            AthLoadString(idsDownloadArtTitle, szRes, sizeof(szRes));
            SetWindowText(hwnd, szRes);
            AthLoadString(idsDownloadArtMsg, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
    
            CenterDialog(hwnd);
            Assert(lParam);
            pThis = (CDownloadArticleCB *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            pThis->m_hwndDlg = hwnd;

            Animate_Open(GetDlgItem(hwnd, idcAnimation), idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);
            AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
            wsprintf(szBuffer, szRes, 0);
            SetDlgItemText(hwnd, idcProgText, szBuffer);
            
            hr = pThis->m_pNewsStore->GetArticle(pThis->m_pszArticle, pThis->m_pStream, (IStoreCallback *)pThis);
            if (hr == E_PENDING)
                SetForegroundWindow(hwnd);
            else
                EndDialog(hwnd, 0);
            return (TRUE);
            
        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
            {                
                Animate_Stop(GetDlgItem(hwnd, idcAnimation));
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_ABORT);
                return TRUE;
            }
            break;
            
        case WM_STORE_COMPLETE:
            EndDialog(hwnd, 0);
            return(0);
    }

    return FALSE;        
}

CDownloadArticleCB::CDownloadArticleCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = FALSE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_pszArticle = NULL;
    m_pNewsStore = NULL;
    m_pStream = NULL;
}

CDownloadArticleCB::~CDownloadArticleCB()
{
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();

}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CDownloadArticleCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CDownloadArticleCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CDownloadArticleCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];

    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (tyOperation == SOT_GET_MESSAGE)
    {
        AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
        wsprintf(szBuffer, szRes, dwCurrent);
        SetDlgItemText(m_hwndDlg, idcProgText, szBuffer);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwndDlg,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CDownloadArticleCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}

HRESULT CDownloadArticleCB::Download(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    FOLDERID    idServer;
    HRESULT     hr;
    LPMIMEMESSAGE pMsg;

    Assert(pszAccountId != NULL);
    Assert(pszArticle != NULL);
    Assert(ppMsg != NULL);

    hr = g_pStore->FindServerId(pszAccountId, &idServer);
    if (FAILED(hr))
        return(hr);

    m_pNewsStore = new CNewsStore;
    if (m_pNewsStore == NULL)
        return(E_OUTOFMEMORY);

    hr = m_pNewsStore->Initialize(idServer, pszAccountId);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr = HrCreateMessage(&pMsg)))
        {
            if (SUCCEEDED(hr = MimeOleCreateVirtualStream(&m_pStream)))
            {
                m_pszArticle = pszArticle;
                DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddDownloadGroups), NULL, 
                                DownloadArticleDlg, (LPARAM)this);
                if (m_hr == S_OK)
                {
                    pMsg->Load(m_pStream);
                    *ppMsg = pMsg;
                    (*ppMsg)->AddRef();
                }

                hr = m_hr;

                m_pStream->Release();
            }

            pMsg->Release();
        }

        m_pNewsStore->Close(MSGSVRF_HANDS_OFF_SERVER);
    }

    m_pNewsStore->Release();

    return hr;
}

HRESULT HrDownloadArticleDialog(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    CDownloadArticleCB *pCB;
    HRESULT hr;

    pCB = new CDownloadArticleCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Download(pszAccountId, pszArticle, ppMsg);

    pCB->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\newsutil.h ===
#ifndef _INC_NEWSUTIL_H
#define _INC_NEWSUTIL_H

class CGetNewGroups : public IStoreCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        CGetNewGroups(HWND hwnd, FOLDERID idFolder, LPCSTR pszAcctId, FILETIME *pft);
        ~CGetNewGroups(void);

        HRESULT Close(void);
        HRESULT HandleGetNewGroups(void);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;

        HWND        m_hwnd;
        FOLDERID    m_idFolder;
        char        m_szAcctId[CCHMAX_ACCOUNT_NAME];
        FILETIME    m_ft;
};

BOOL NewsUtil_FCanCancel(FOLDERID idFolder, LPMESSAGEINFO pInfo);
HRESULT NewsUtil_HrCancelPost(HWND hwnd, FOLDERID idGroup, LPMESSAGEINFO pInfo);
DWORD NewsUtil_GetNotDownloadCount(FOLDERINFO *pInfo);
HRESULT NewsUtil_CheckForNewGroups(HWND hwnd, FOLDERID idFolder, CGetNewGroups **ppGroups);
HRESULT HrDownloadArticleDialog(LPCSTR pszAccountId, LPCSTR pszArticle, LPMIMEMESSAGE *ppMsg);

#endif // _INC_NEWSUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\newsstor.cpp ===
/*
 *    n e w s s t o r . c p p 
 *    
 *    Purpose:
 *      Derives from IMessageServer to implement news specific store communication
 *    
 *    Owner:
 *      cevans.
 *
 *    History:
 *      May '98: Created
 *      June '98 Rewrote
 *
 *    Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "newsstor.h"
#include "xpcomm.h"
#include "xputil.h"
#include "conman.h"
#include "IMsgSite.h"
#include "note.h"
#include "storutil.h"
#include "storfldr.h"
#include "oerules.h"
#include "ruleutil.h"
#include <rulesmgr.h>
#include <serverq.h>
#include "newsutil.h"
#include "range.h"

#define AssertSingleThreaded AssertSz(m_dwThreadId == GetCurrentThreadId(), "Multi-threading make me sad.")

#define WM_NNTP_BEGIN_OP (WM_USER + 69)

static const char s_szNewsStoreWndClass[] = "Outlook Express NewsStore";

// Get XX Header consts
const BYTE   MAXOPS = 3;            // maxnumber of HEADER commands to issue
const BYTE   DLOVERKILL = 10;       // percent to grab more than user's desired chunk [10,..)
const BYTE   FRACNEEDED = 8;        // percent needed to satisfy user's amount [1,10]

void AddRequestedRange(FOLDERINFO *pInfo, DWORD dwLow, DWORD dwHigh, BOOL *pfReq, BOOL *pfRead);

// SOT_SYNC_FOLDER
static const PFNOPFUNC c_rgpfnSyncFolder[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group,
    &CNewsStore::ExpireHeaders,
    &CNewsStore::Headers
};

// SOT_GET_MESSAGE
static const PFNOPFUNC c_rgpfnGetMessage[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::GroupIfNecessary,  // only issue group command if necessary
    &CNewsStore::Article
};

// SOT_PUT_MESSAGE
static const PFNOPFUNC c_rgpfnPutMessage[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Post
};

// SOT_SYNCING_STORE
static const PFNOPFUNC c_rgpfnSyncStore[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::List,
    &CNewsStore::DeleteDeadGroups,
    &CNewsStore::Descriptions
};

// SOT_GET_NEW_GROUPS
static const PFNOPFUNC c_rgpfnGetNewGroups[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::NewGroups
};

// SOT_UPDATE_FOLDER
static const PFNOPFUNC c_rgpfnUpdateFolder[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group
};

// SOT_GET_WATCH_INFO
static const PFNOPFUNC c_rgpfnGetWatchInfo[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group,
    &CNewsStore::XHdrReferences,
    &CNewsStore::XHdrSubject,
    &CNewsStore::WatchedArticles
};


//
//  FUNCTION:   CreateNewsStore()
//
//  PURPOSE:    Creates the CNewsStore object and returns it's IUnknown 
//              pointer.
//
//  PARAMETERS: 
//      [in]  pUnkOuter - Pointer to the IUnknown that this object should
//                        aggregate with.
//      [out] ppUnknown - Returns the pointer to the newly created object.
//
HRESULT CreateNewsStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr;
    IMessageServer *pServer;

    // Trace
    TraceCall("CreateNewsStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNewsStore *pNew = new CNewsStore();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    hr = CreateServerQueue((IMessageServer *)pNew, &pServer);

    pNew->Release();
    if (FAILED(hr))
        return(hr);

    // Cast to unknown
    *ppUnknown = SAFECAST(pServer, IMessageServer *);

    // Done
    return S_OK;
}

//----------------------------------------------------------------------
// CNewsStore
//----------------------------------------------------------------------

//
//
//  FUNCTION:   CNewsStore::CNewsStore()
//
//  PURPOSE:    Constructor
//
CNewsStore::CNewsStore()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_pStore = NULL;
    m_pFolder = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_idParent = FOLDERID_INVALID;
    m_szGroup[0] = 0;
    m_szAccountId[0] = 0;

    ZeroMemory(&m_op, sizeof(m_op));
    m_pROP = NULL;

    m_pTransport = NULL;
    m_ixpStatus = IXP_DISCONNECTED;
    m_dwLastStatusTicks = 0;

    ZeroMemory(&m_rInetServerInfo, sizeof(INETSERVER));

    m_dwWatchLow = 0;
    m_dwWatchHigh = 0;
    m_rgpszWatchInfo = 0;
    m_fXhdrSubject = 0;
    m_cRange.Clear();

    m_pTable = NULL;

#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif // DEBUG
}

//
//
//  FUNCTION:   CNewsStore::~CNewsStore()
//
//  PURPOSE:    Destructor
//
CNewsStore::~CNewsStore()
{
    AssertSingleThreaded;
    
    if (m_hwnd != NULL)
        DestroyWindow(m_hwnd);

    if (m_pTransport)
    {
        // If we're still connected, drop the connection and then release
        if (_FConnected())
            m_pTransport->DropConnection();

        SideAssert(m_pTransport->Release() == 0);
        m_pTransport = NULL;
    }

    _FreeOperation();
    if (m_pROP != NULL)
        MemFree(m_pROP);

    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
    SafeRelease(m_pTable);
}

//
//  FUNCTION:   CNewsStore::QueryInterface()
//
STDMETHODIMP CNewsStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CNewsStore::QueryInterface");

    AssertSingleThreaded;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_ITransportCallback == riid)
        *ppv = (ITransportCallback *)this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *)this;
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    else if (IID_INewsStore == riid)
        *ppv = (INewsStore *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//
//  FUNCTION:   CNewsStore::AddRef()
//
STDMETHODIMP_(ULONG) CNewsStore::AddRef(void)
{
    TraceCall("CNewsStore::AddRef");

    AssertSingleThreaded;

    return InterlockedIncrement(&m_cRef);
}

//
//  FUNCTION:   CNewsStore::Release()
//
STDMETHODIMP_(ULONG) CNewsStore::Release(void)
{
    TraceCall("CNewsStore::Release");

    AssertSingleThreaded;

    LONG cRef = InterlockedDecrement(&m_cRef);
    
    Assert(cRef >= 0);

    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

HRESULT CNewsStore::Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder)
{
    HRESULT hr;
    FOLDERINFO info;

    AssertSingleThreaded;

    if (pStore == NULL || idStoreRoot == FOLDERID_INVALID)
        return(E_INVALIDARG);

    if (!_CreateWnd())
        return(E_FAIL);

    m_idParent = idStoreRoot;
    m_idFolder = idFolder;
    ReplaceInterface(m_pStore, pStore);
    ReplaceInterface(m_pFolder, pFolder);

    hr = m_pStore->GetFolderInfo(idStoreRoot, &info);
    if (FAILED(hr))
        return(hr);

    Assert(!!(info.dwFlags & FOLDER_SERVER));

    lstrcpy(m_szAccountId, info.pszAccountId);

    m_pStore->FreeRecord(&info);

    return(S_OK);
}

HRESULT CNewsStore::ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder)
{
    AssertSingleThreaded;

    if (pFolder == NULL || idFolder == FOLDERID_INVALID)
        return(E_INVALIDARG);

    m_idFolder = idFolder;
    ReplaceInterface(m_pFolder, pFolder);

    return(S_OK);
}

HRESULT CNewsStore::Initialize(FOLDERID idStoreRoot, LPCSTR pszAccountId)
{
    AssertSingleThreaded;

    if (idStoreRoot == FOLDERID_INVALID || pszAccountId == NULL)
        return(E_INVALIDARG);

    if (!_CreateWnd())
        return(E_FAIL);

    m_idParent = idStoreRoot;
    m_idFolder = FOLDERID_INVALID;
#pragma prefast(suppress:282, "this macro uses the assignment as part of a test for NULL")
    ReplaceInterface(m_pStore, NULL);
#pragma prefast(suppress:282, "this macro uses the assignment as part of a test for NULL")
    ReplaceInterface(m_pFolder, NULL);

    lstrcpy(m_szAccountId, pszAccountId);

    return(S_OK);
}

BOOL CNewsStore::_CreateWnd()
{
    WNDCLASS wc;

    Assert(m_hwnd == NULL);

    if (!GetClassInfo(g_hInst, s_szNewsStoreWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc          = CNewsStore::NewsStoreWndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hInst;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szNewsStoreWndClass;
        
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST,
                        s_szNewsStoreWndClass,
                        s_szNewsStoreWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hInst,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailServer::_WndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK CNewsStore::NewsStoreWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNewsStore *pThis = (CNewsStore *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (msg)
    {
        case WM_NCCREATE:
            Assert(pThis == NULL);
            pThis = (CNewsStore *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
            break;
    
        case WM_NNTP_BEGIN_OP:
            Assert(pThis != NULL);
            pThis->_DoOperation();
            break;
    }

    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

HRESULT CNewsStore::_BeginDeferredOperation(void)
{
    return (PostMessage(m_hwnd, WM_NNTP_BEGIN_OP, 0, 0) ? E_PENDING : E_FAIL);
}

HRESULT CNewsStore::Close(DWORD dwFlags)
{
    AssertSingleThreaded;

    // let go of the transport, so that it let's go of us

    if (m_op.tyOperation != SOT_INVALID)
        m_op.fCancel = TRUE;

    if (dwFlags & MSGSVRF_DROP_CONNECTION || dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (_FConnected())
            m_pTransport->DropConnection();
    }

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_pTransport->HandsOffCallback();
            m_pTransport->Release();
            m_pTransport = NULL;
        }
    }

    return(S_OK);
}

void CNewsStore::_FreeOperation()
{
    FILEADDRESS faStream;
    if (m_op.pCallback != NULL)
        m_op.pCallback->Release();
    if (m_pFolder != NULL && m_op.faStream != 0)
        m_pFolder->DeleteStream(m_op.faStream);
    if (m_op.pStream != NULL)
        m_op.pStream->Release();
    if (m_op.pPrevFolders != NULL)
        MemFree(m_op.pPrevFolders);
    if (m_op.pszGroup != NULL)
        MemFree(m_op.pszGroup);
    if (m_op.pszArticleId != NULL)
        MemFree(m_op.pszArticleId);

    ZeroMemory(&m_op, sizeof(OPERATION));
    m_op.tyOperation = SOT_INVALID;
}

HRESULT CNewsStore::Connect()
{
    INETSERVER      rInetServerInfo;
    HRESULT         hr;
    BOOL            fInetInit;
    IImnAccount     *pAccount = NULL;
    char            szAccountName[CCHMAX_ACCOUNT_NAME];
    char            szLogFile[MAX_PATH];
    DWORD           dwLog;

    AssertSingleThreaded;
    Assert(m_op.pCallback != NULL);

    //Bug# 68339
    if (g_pAcctMan)
    {
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &pAccount);
        if (FAILED(hr))
            return(hr);

        fInetInit = FALSE;

        if (_FConnected())
        {
            Assert(m_pTransport != NULL);

            hr = m_pTransport->InetServerFromAccount(pAccount, &rInetServerInfo);
            if (FAILED(hr))
                goto exit;

            Assert(m_rInetServerInfo.szServerName[0] != 0);
            if (m_rInetServerInfo.rasconntype == rInetServerInfo.rasconntype &&
                m_rInetServerInfo.dwPort == rInetServerInfo.dwPort &&
                m_rInetServerInfo.fSSL == rInetServerInfo.fSSL &&
                m_rInetServerInfo.fTrySicily == rInetServerInfo.fTrySicily &&
                m_rInetServerInfo.dwTimeout == rInetServerInfo.dwTimeout &&
                0 == lstrcmp(m_rInetServerInfo.szUserName, rInetServerInfo.szUserName) &&
                ('\0' == rInetServerInfo.szPassword[0] ||
                    0 == lstrcmp(m_rInetServerInfo.szPassword, rInetServerInfo.szPassword)) &&
                0 == lstrcmp(m_rInetServerInfo.szServerName, rInetServerInfo.szServerName) &&
                0 == lstrcmp(m_rInetServerInfo.szConnectoid, rInetServerInfo.szConnectoid))
            {
                hr = S_OK;
                goto exit;
            }

            fInetInit = TRUE;

            m_pTransport->DropConnection();
        }

        hr = m_op.pCallback->CanConnect(m_szAccountId, NOFLAGS);
        if (hr != S_OK)
        {
            if (hr == S_FALSE)
                hr = HR_E_USER_CANCEL_CONNECT;
            goto exit;
        }

        if (!m_pTransport)
        {
            *szLogFile = 0;

            dwLog = DwGetOption(OPT_NEWS_XPORT_LOG);
            if (dwLog)
            {
                hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName));
                if (FAILED(hr))
                    goto exit;

                _CreateDataFilePath(m_szAccountId, szAccountName, szLogFile);
            }

            hr = CreateNNTPTransport(&m_pTransport);
            if (FAILED(hr))
                goto exit;            

            hr = m_pTransport->InitNew(*szLogFile ? szLogFile : NULL, this);
            if (FAILED(hr))
                goto exit;
        }

        // Convert the account name to an INETSERVER struct that can be passed to Connect()
        if (fInetInit)
        {
            CopyMemory(&m_rInetServerInfo, &rInetServerInfo, sizeof(INETSERVER));
        }
        else
        {
            hr = m_pTransport->InetServerFromAccount(pAccount, &m_rInetServerInfo);
            if (FAILED(hr))
                goto exit;
        }

        // Always connect using the most recently supplied password from the user
        GetPassword(m_rInetServerInfo.dwPort, m_rInetServerInfo.szServerName,
            m_rInetServerInfo.szUserName, m_rInetServerInfo.szPassword,
            sizeof(m_rInetServerInfo.szPassword));

        if (m_pTransport)
        {
            hr = m_pTransport->Connect(&m_rInetServerInfo, TRUE, TRUE);
            if (hr == S_OK)
            {
                m_op.nsPending = NS_CONNECT;
                hr = E_PENDING;
            }
        }

exit:
        if (pAccount)
            pAccount->Release();
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CNewsStore::Group()
{
    HRESULT hr;
    FOLDERINFO info;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
    if (SUCCEEDED(hr))
    {
        hr = m_pTransport->CommandGROUP(info.pszName);
        if (hr == S_OK)
        {
            m_op.pszGroup = PszDup(info.pszName);
            m_op.nsPending = NS_GROUP;
            hr = E_PENDING;
        }

        m_pStore->FreeRecord(&info);
    }

    return hr;
}

HRESULT CNewsStore::GroupIfNecessary()
{
    FOLDERINFO info;
    HRESULT hr = S_OK;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    if (0 == (m_op.dwFlags & OPFLAG_NOGROUPCMD))
    {
        hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
        if (SUCCEEDED(hr))
        {
            if (0 != lstrcmpi(m_szGroup, info.pszName))
            {
                hr = m_pTransport->CommandGROUP(info.pszName);
                if (hr == S_OK)
                {
                    m_op.nsPending = NS_GROUP;
                    hr = E_PENDING;
                }
            }

            m_pStore->FreeRecord(&info);
        }
    }

    return hr;
}

HRESULT CNewsStore::ExpireHeaders()
{
    HRESULT hr;
    FOLDERINFO info;
    MESSAGEINFO Message;
    DWORD dwLow, cid, cidBuf;
    MESSAGEIDLIST idList;
    HROWSET hRowset;
    HLOCK hNotify;

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
    if (FAILED(hr))
        return(hr);

    dwLow = min(info.dwServerLow - 1, info.dwClientHigh); 

    m_pStore->FreeRecord(&info);

    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    cid = 0;
    cidBuf = 0;
    idList.cAllocated = 0;
    idList.prgidMsg = NULL;

    hr = m_pFolder->LockNotify(NOFLAGS, &hNotify);
    if (SUCCEEDED(hr))
    {
        while (TRUE)
        {
            hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (FAILED(hr))
                break;

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            if ((DWORD_PTR)Message.idMessage <= dwLow ||
                !!(Message.dwFlags & ARF_ARTICLE_EXPIRED))
            {
                if (cid == cidBuf)
                {
                    cidBuf += 512;
                    if (!MemRealloc((void **)&idList.prgidMsg, cidBuf * sizeof(MESSAGEID)))
                    {
                        m_pFolder->FreeRecord(&Message);
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }

                idList.prgidMsg[cid] = Message.idMessage;
                cid++;
            }

            m_pFolder->FreeRecord(&Message);
        }

        m_pFolder->UnlockNotify(&hNotify);
    }

    m_pFolder->CloseRowset(&hRowset);

    // if it fails, its no big deal, they'll just have some stale headers until next time
    if (cid > 0)
    {
        Assert(idList.prgidMsg != NULL);

        idList.cMsgs = cid;

        // Delete the messages from the folder without a trashcan (after all, this is news)
        if (SUCCEEDED(m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &idList, NULL, NULL)) &&
            SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &info)))
        {
            info.dwClientLow = dwLow + 1;
            m_pStore->UpdateRecord(&info);

            m_pStore->FreeRecord(&info);
        }

        MemFree(idList.prgidMsg);
    }

    return(hr);
}

HRESULT CNewsStore::Headers(void)
{
    FOLDERINFO FolderInfo;
    HRESULT hr;
    RANGE rRange;
    BOOL fNew;

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &FolderInfo);
    if (FAILED(hr))
        return(hr);

    Assert(0 == lstrcmpi(m_szGroup, FolderInfo.pszName));

    hr = _ComputeHeaderRange(m_op.dwSyncFlags, m_op.cHeaders, &FolderInfo, &rRange);
    
    if (hr == S_OK)
    {
        // Transport will not allow dwFirst to be 0.  
        // In this case, there are no messages to be received.
        Assert(rRange.dwFirst > 0);
        Assert(rRange.dwFirst <= rRange.dwLast);

        hr = m_pTransport->GetHeaders(&rRange);
        if (hr == S_OK)
        {
            m_op.nsPending = NS_HEADERS;
            hr = E_PENDING;
        }
    }

    if (hr != E_PENDING)
    {
        if (m_pROP != NULL)
        {
            MemFree(m_pROP);
            m_pROP = NULL;
        }
    }

    if (hr == S_FALSE)
        hr = S_OK;

    m_pStore->FreeRecord(&FolderInfo);

    return(hr);
}

HRESULT CNewsStore::_ComputeHeaderRange(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, FOLDERINFO *pInfo, RANGE *pRange)
{
    HRESULT hr;
    UINT uLeftToGet;
    ULONG ulMaxReq;
    BOOL fFullScan;
    DWORD dwDownload;
    CRangeList *pRequested;

    Assert(pInfo != NULL);
    Assert(pRange != NULL);

    // Bail if there are no messages to be gotten
    if (0 == pInfo->dwServerCount ||
        pInfo->dwServerLow > pInfo->dwServerHigh)
        {
        Assert(!m_pROP);
        return(S_FALSE);
        }

    pRequested = new CRangeList;
    if (pRequested == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if (pInfo->Requested.cbSize > 0)
        pRequested->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

    ulMaxReq = pRequested->Max();

    Assert(0 == pRequested->Min());
    fFullScan = (0 == pRequested->MinOfRange(ulMaxReq));
    
    // Bail if we've scanned the whole group
    if (fFullScan && (pRequested->Max() == pInfo->dwServerHigh))
        goto endit;

    if (m_pROP != NULL)
    {
        // Bail if we've gotten all the user wants
        if (m_pROP->uObtained >= ((FRACNEEDED * m_pROP->dwChunk) / 10))
            goto endit;

        // Bail if this has gone on for too many calls
        if (m_pROP->cOps > m_pROP->MaxOps)
            goto endit;
    }
    else
    {
        m_op.dwProgress = 0;

        // Do setup
        if (!MemAlloc((LPVOID*)&m_pROP, sizeof(SREFRESHOP)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        ZeroMemory(m_pROP, sizeof(SREFRESHOP));
        m_pROP->fOnlyNewHeaders = !!(dwFlags & SYNC_FOLDER_NEW_HEADERS);

        if (!!(dwFlags & SYNC_FOLDER_XXX_HEADERS))
        {
            Assert(cHeaders > 0);
            m_pROP->dwChunk = cHeaders;
            m_pROP->dwDlSize = (DWORD)((m_pROP->dwChunk * DLOVERKILL) / 10);
            m_pROP->MaxOps = MAXOPS;
            m_pROP->fEnabled = TRUE;
    
            m_op.dwTotal = m_pROP->dwDlSize;
        }    
        else
        {
            // user has turned off the X headers option
            // so we need to get all of the newest headers, but then also
            // grab any old headers on this refresh
            // we have to do all that here and now because there is no
            // UI available to the user

            // don't want to quit except on a full scan
            // m_pROP->fOnlyNewHeaders = FALSE;
            m_pROP->MaxOps = m_pROP->dwChunk = m_pROP->dwDlSize = pInfo->dwServerHigh;
            Assert(!m_pROP->fEnabled);

            m_op.dwTotal = pInfo->dwNotDownloaded;
        }
    }

    uLeftToGet = m_pROP->dwDlSize - m_pROP->uObtained;
    if (RANGE_ERROR == ulMaxReq)
    {
        AssertSz(0, TEXT("shouldn't be here, but you can ignore."));
        ulMaxReq = pInfo->dwServerLow - 1;
    }
    Assert(ulMaxReq <= pInfo->dwServerHigh);
    Assert(pRequested->IsInRange(pInfo->dwServerLow - 1));

    ///////////////////////////////////
    /// Compute begin and end numbers

    if (ulMaxReq < pInfo->dwServerHigh)
    {
        // get the newest headers
        Assert(0 == m_pROP->cOps);      // EricAn said this assert might not be valid
        Assert(ulMaxReq + 1 >= pInfo->dwServerLow);

        m_pROP->dwLast = pInfo->dwServerHigh;
        if (!m_pROP->fEnabled || (m_pROP->dwChunk - 1 > m_pROP->dwLast))
        {
            m_pROP->dwFirst =  ulMaxReq + 1;
        }
        else
        {
            // we use dwChunk here b/c headers will be nearly dense
            m_pROP->dwFirst = max(m_pROP->dwLast - (m_pROP->dwChunk - 1), ulMaxReq + 1);
        }
        m_pROP->dwFirstNew = ulMaxReq + 1;
    }
    else if (m_pROP->dwFirst > m_pROP->dwFirstNew)  // if init to zero, won't be true
    {
        // still new headers user hasn't seen
        Assert(m_pROP->cOps);                                   // can't happen at first
        Assert(m_pROP->dwFirstNew >= pInfo->dwServerLow);       // better be valid
        Assert(m_pROP->fEnabled);                               // should have gotten them all

        m_pROP->dwLast = m_pROP->dwFirst - 1;         // since cOps is pos, dwFirst is valid
        if (uLeftToGet - 1 > m_pROP->dwLast)
            m_pROP->dwFirst = m_pROP->dwFirstNew;
        else
            m_pROP->dwFirst = max(m_pROP->dwLast - (uLeftToGet - 1), m_pROP->dwFirstNew);
    }
    else if (!m_pROP->fOnlyNewHeaders) 
    {
        RangeType rt;
        // want to find the highest num header we've never requested
        
        m_pROP->dwFirstNew = pInfo->dwServerHigh;  // no new mesgs in this session
        if (!pRequested->HighestAntiRange(&rt))
        {
            AssertSz(0, TEXT("You can ignore if you want, but we shouldn't be here."));
            rt.low = max(pRequested->Max() + 1, pInfo->dwServerLow);
            rt.high = pInfo->dwServerHigh;
            if (rt.low == rt.high)
                goto endit;
        }

        m_pROP->dwLast = rt.high;
        if (!m_pROP->fEnabled || ((uLeftToGet - 1) > rt.high))
            m_pROP->dwFirst = rt.low;
        else
            m_pROP->dwFirst = max(rt.low, rt.high - (uLeftToGet - 1));
    }
    else
    {
        goto endit;
    }

    // check our math and logic about download range
    Assert(m_pROP->dwLast <= pInfo->dwServerHigh);
    Assert(m_pROP->dwFirst >= pInfo->dwServerLow);
    Assert(!pRequested->IsInRange(m_pROP->dwLast));
    Assert(!pRequested->IsInRange(m_pROP->dwFirst));
    Assert(!m_pROP->fEnabled || ((m_pROP->dwLast - m_pROP->dwFirst) < m_pROP->dwDlSize));

    if (!m_pROP->dwLast || (m_pROP->dwFirst > m_pROP->dwLast))
    {
        AssertSz(0, TEXT("You would have made a zero size HEADER call"));
        goto endit;
    }

    pRequested->Release();

    pRange->idType = RT_RANGE;
    pRange->dwFirst = m_pROP->dwFirst;
    pRange->dwLast = m_pROP->dwLast;    

    dwDownload = pRange->dwLast - pRange->dwFirst + 1;
    if (dwDownload + m_op.dwProgress > m_op.dwTotal)
        m_op.dwTotal = dwDownload + m_op.dwProgress;

    return(S_OK);

endit:
    hr = S_FALSE;

error:
    if (m_pROP != NULL)
    {
        MemFree(m_pROP);
        m_pROP = NULL;
    }
    if(pRequested) pRequested->Release();

    return(hr);
}

HRESULT CNewsStore::Article()
{
    HRESULT hr;
    MESSAGEINFO info;
    DWORD dwTotalLines;
    ARTICLEID rArticleId;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    dwTotalLines = 0;

    if (m_op.pszArticleId != NULL)
    {
        rArticleId.idType = AID_MSGID;
        rArticleId.pszMessageId = m_op.pszArticleId;
        m_op.pszArticleId = NULL;
    }
    else if (m_op.idMessage)
    {
        ZeroMemory(&info, sizeof(info));
        info.idMessage = m_op.idMessage;

        hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &info, NULL);
        if (DB_S_FOUND == hr)
        {
            dwTotalLines = info.cLines;
            m_pFolder->FreeRecord(&info);
        }

        rArticleId.idType = AID_ARTICLENUM;
        rArticleId.dwArticleNum = (DWORD_PTR)m_op.idMessage;
    }
    else
    {
        Assert(m_op.idServerMessage);
        rArticleId.idType = AID_ARTICLENUM;
        rArticleId.dwArticleNum = m_op.idServerMessage;
    }

    m_op.dwProgress = 0;
    m_op.dwTotal = dwTotalLines;

    hr = m_pTransport->CommandARTICLE(&rArticleId);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_ARTICLE;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::Post()
{
    HRESULT hr;
    NNTPMESSAGE rMsg;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    rMsg.pstmMsg = m_op.pStream;
    rMsg.cbSize = 0;

    hr = m_pTransport->CommandPOST(&rMsg);
    if (SUCCEEDED(hr))
    {
        m_op.nsPending = NS_POST;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::NewGroups()
{
    HRESULT hr;
    NNTPMESSAGE rMsg;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    hr = m_pTransport->CommandNEWGROUPS(&m_op.st, NULL);
    if (SUCCEEDED(hr))
    {
        m_op.nsPending = NS_NEWGROUPS;
        hr = E_PENDING;
    }

    return(hr);
}

int __cdecl CompareFolderIds(const void *elem1, const void *elem2)
{
    return(*((DWORD *)elem1) - *((DWORD *)elem2));
}

HRESULT CNewsStore::List()
{
    HRESULT hr;
    ULONG cFolders;
    FOLDERINFO info;
    IEnumerateFolders *pEnum;

    Assert(0 == m_op.dwFlags);
    Assert(m_op.pPrevFolders == NULL);

    m_op.cPrevFolders = 0;

    hr = m_pStore->EnumChildren(m_idParent, FALSE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            if (!MemAlloc((void **)&m_op.pPrevFolders, cFolders * sizeof(FOLDERID)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    m_op.pPrevFolders[m_op.cPrevFolders] = info.idFolder;
                    m_op.cPrevFolders++;

                    m_pStore->FreeRecord(&info);
                }

                Assert(m_op.cPrevFolders == cFolders);

                qsort(m_op.pPrevFolders, m_op.cPrevFolders, sizeof(FOLDERID), CompareFolderIds);
            }
        }

        pEnum->Release();
    }

    if (SUCCEEDED(hr))
        hr = _List(NULL);

    return(hr);
}

HRESULT CNewsStore::DeleteDeadGroups()
{
    ULONG i;
    HRESULT hr;
    FOLDERID *pId;

    if (m_op.pPrevFolders != NULL)
    {
        Assert(m_op.cPrevFolders > 0);

        for (i = 0, pId = m_op.pPrevFolders; i < m_op.cPrevFolders; i++, pId++)
        {
            if (*pId != 0)
            {
                hr = m_pStore->DeleteFolder(*pId, DELETE_FOLDER_NOTRASHCAN, NULL);
                Assert(SUCCEEDED(hr));
            }
        }

        MemFree(m_op.pPrevFolders);
        m_op.pPrevFolders = NULL;
    }

    return(S_OK);
}

static const char c_szNewsgroups[] = "NEWSGROUPS";

HRESULT CNewsStore::Descriptions()
{
    HRESULT hr;

    m_op.dwFlags = OPFLAG_DESCRIPTIONS;
    hr = _List(c_szNewsgroups);

    return(hr);
}

HRESULT CNewsStore::_List(LPCSTR pszCommand)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    m_op.dwProgress = 0;
    m_op.dwTotal = 0;

    hr = m_pTransport->CommandLIST((LPSTR)pszCommand);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_LIST;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::_DoOperation()
{
    HRESULT             hr;
    STOREOPERATIONINFO  soi;
    STOREOPERATIONINFO  *psoi;

    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pfnState != NULL);
    Assert(m_op.cState > 0);
    Assert(m_op.iState <= m_op.cState);

    hr = S_OK;

    if (m_op.iState == 0)
    {
        if (m_op.tyOperation == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.cbSize = sizeof(STOREOPERATIONINFO);
            soi.idMessage = m_op.idMessage;
            psoi = &soi;
        }
        else
        {
            psoi = NULL;
        }

        m_op.pCallback->OnBegin(m_op.tyOperation, psoi, (IOperationCancel *)this);
    }

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState]))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if ((m_op.iState == m_op.cState) ||
        (FAILED(hr) && hr != E_PENDING))
    {
        if (hr == HR_E_USER_CANCEL_CONNECT)
        {
            // if operation is canceled, add the flush flag
            m_op.error.dwFlags |= SE_FLAG_FLUSHALL;
        }

        if (FAILED(hr))
        {
            IXPRESULT   rIxpResult;

            // Fake an IXPRESULT
            ZeroMemory(&rIxpResult, sizeof(rIxpResult));
            rIxpResult.hrResult = hr;

            // Return meaningful error information
            _FillStoreError(&m_op.error, &rIxpResult);
            Assert(m_op.error.hrResult == hr);
        }
        else
            m_op.error.hrResult = hr;

        m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, &m_op.error);
        _FreeOperation();
    }

    return(hr);
}

//
//  FUNCTION:   CNewsStore::SynchronizeFolder()
//
//  PURPOSE:    Load all of the new messages headers for this folder
//              as appropriate based on the flags
//
//  PARAMETERS: 
//      [in]  dwFlags - 
//
HRESULT CNewsStore::SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders,
                                      IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::SynchronizeFolder");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pROP == NULL);

    m_op.tyOperation = SOT_SYNC_FOLDER;
    m_op.pfnState = c_rgpfnSyncFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.dwSyncFlags = dwFlags;
    m_op.cHeaders = cHeaders;

    hr = _BeginDeferredOperation();

    return hr;   
}

// 
//  FUNCTION:   CNewsStore::GetMessage()
//
//  PURPOSE:    Start the retrieval of a single message as specified 
//              by idMessage.
//
//  PARAMETERS: 
//      [in]  idFolder - 
//      [in]  idMessage - 
//      [in]  pStream - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetMessage");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    // create a persistent stream
    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pStream, &m_op.faStream)))
        goto exit;

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.dwFlags = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.idMessage = idMessage;

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

HRESULT CNewsStore::GetArticle(LPCSTR pszArticleId, IStream *pStream,
                               IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetArticle");

    AssertSingleThreaded;
    Assert(pStream != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.pszArticleId = PszDup(pszArticleId);
    if (m_op.pszArticleId == NULL)
        return(E_OUTOFMEMORY);

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.dwFlags = OPFLAG_NOGROUPCMD;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.idMessage = 0;
    m_op.pStream = pStream;
    m_op.pStream->AddRef();

    hr = _BeginDeferredOperation();

    return hr;
}

//
//  FUNCTION:   CNewsStore::PutMessage()
//
//  PURPOSE:    Posting news messages
//
//  PARAMETERS: 
//      [in]  idFolder - 
//      [in]  dwFlags - 
//      [in]  pftReceived - 
//      [in]  pStream - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags,
                            LPFILETIME pftReceived, IStream *pStream,
                            IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetMessage");

    AssertSingleThreaded;
    Assert(pStream != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_PUT_MESSAGE;
    m_op.pfnState = c_rgpfnPutMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnPutMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;
    m_op.dwMsgFlags = dwFlags;
    m_op.pStream = pStream;
    m_op.pStream->AddRef();

    hr = _BeginDeferredOperation();

    return hr;
}

//
//  FUNCTION:   CNewsStore::SynchronizeStore()
//
//  PURPOSE:    Synchronize the list of mail groups
//
//  PARAMETERS: 
//      [in]  idParent - 
//      [in]  dwFlags - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::SynchronizeStore(FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_SYNCING_STORE;
    m_op.pfnState = c_rgpfnSyncStore;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncStore);

    if (0 == (dwFlags & SYNC_STORE_GET_DESCRIPTIONS))
    {
        // we don't need to do the descriptions command
        m_op.cState -= 1;
    }

    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idParent;

    hr = _BeginDeferredOperation();

    return(hr);
}

HRESULT CNewsStore::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(pSysTime != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_GET_NEW_GROUPS;
    m_op.pfnState = c_rgpfnGetNewGroups;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetNewGroups);

    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.st = *pSysTime;
    m_op.idFolder = m_idParent;

    hr = _BeginDeferredOperation();

    return(hr);
}

//
//  FUNCTION:   CNewsStore::GetFolderCounts()
//
//  PURPOSE:    Update folder statistics for the passed in folder
//
//  PARAMETERS: 
//      [in]  idFolder - folder id associated with the newsgroup
//      [in]  pCallback - callbacks to send OnComplete to.
//
HRESULT CNewsStore::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetFolderCounts");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_UPDATE_FOLDER;
    m_op.pfnState = c_rgpfnUpdateFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnUpdateFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;

    hr = _BeginDeferredOperation();

    return hr;   
}

HRESULT CNewsStore::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    // Stack
    TraceCall("CNewsStore::SetIdleCallback");

    return E_NOTIMPL;
}

HRESULT CNewsStore::CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions,
                                 LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags,
                                 IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::CopyMessages");

    return E_NOTIMPL;
}

HRESULT CNewsStore::DeleteMessages(DELETEMESSAGEFLAGS dwOptions,
                                   LPMESSAGEIDLIST pList, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::DeleteMessages");
    
    AssertSingleThreaded;
    Assert(pList != NULL);
    Assert(pCallback != NULL);
    Assert(m_pFolder != NULL);
    
    return(m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | dwOptions, pList, NULL, NULL));
}

HRESULT CNewsStore::SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags,
                                    IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::SetMessageFlags");
    Assert(NULL == pList || pList->cMsgs > 0);
    return E_NOTIMPL;
}

HRESULT CNewsStore::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    return S_FALSE;
}

HRESULT CNewsStore::CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial,
                                 LPCSTR pszName, FLDRFLAGS dwFlags,
                                 IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::CreateFolder");
    
    return E_NOTIMPL;
}

HRESULT CNewsStore::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew,
                               IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::MoveFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::RenameFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::DeleteFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe,
                                      IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::SubscribeToFolder");

    return E_NOTIMPL;
}

//
//  FUNCTION:   CNewsStore::Cancel()
//
//  PURPOSE:    Cancel the operation
//
//  PARAMETERS: 
//      [in]  tyCancel - The way that the operation was canceled.
//                       Generally CT_ABORT or CT_CANCEL
//
HRESULT CNewsStore::Cancel(CANCELTYPE tyCancel)
{
    if (m_op.tyOperation != SOT_INVALID)
    {
        m_op.fCancel = TRUE;

        if (_FConnected())
            m_pTransport->DropConnection();
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnTimeout()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pdwTimeout - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnTimeout");

    AssertSingleThreaded;
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);
        
    m_op.pCallback->OnTimeout(&m_rInetServerInfo, pdwTimeout, IXP_NNTP);

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnLogonPrompt()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pInetServer - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    HRESULT hr;
    char    szPassword[CCHMAX_PASSWORD];

    // Stack
    TraceCall("CNewsStore::OnLogonPrompt");

    AssertSingleThreaded;
    Assert(pInetServer != NULL);
    Assert(pTransport != NULL);
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, szPassword, sizeof(pInetServer->szPassword));
        return S_OK;
    }

    hr = m_op.pCallback->OnLogonPrompt(pInetServer, IXP_NNTP);

    // Cache the password for this session
    if (S_OK == hr)
    {
        SavePassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName, pInetServer->szPassword);

        // copy the password/user name into our local inetserver
        lstrcpyn(m_rInetServerInfo.szPassword, pInetServer->szPassword, sizeof(m_rInetServerInfo.szPassword));
        lstrcpyn(m_rInetServerInfo.szUserName, pInetServer->szUserName, sizeof(m_rInetServerInfo.szUserName));
    }

    return(hr);
}

//
//  FUNCTION:   CNewsStore::OnPrompt()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  hrError - 
//      [in]  pszText - 
//      [in]  pszCaption - 
//      [in]  uType - 
//      [in]  pTransport - 
//
int CNewsStore::OnPrompt(HRESULT hrError, LPCSTR pszText, LPCSTR pszCaption,
                          UINT uType, IInternetTransport *pTransport)
{
    int iResponse = 0;

    // Stack
    TraceCall("CNewsStore::OnPrompt");

    AssertSingleThreaded;
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    m_op.pCallback->OnPrompt(hrError, pszText, pszCaption, uType, &iResponse);

    return(iResponse);
}

//
//  FUNCTION:   CNewsStore::OnStatus()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  ixpstatus - status code passed in from the transport
//      [in]  pTransport - The NNTP transport that is calling us
//
HRESULT CNewsStore::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::OnStatus");

    AssertSingleThreaded;

    m_ixpStatus = ixpstatus;

    if (m_op.pCallback != NULL)
        m_op.pCallback->OnProgress(SOT_CONNECTION_STATUS, ixpstatus, 0, m_rInetServerInfo.szServerName);

    // If we were disconnected, then clean up some internal state.
    if (IXP_DISCONNECTED == ixpstatus)
    {
        // Reset the group name so we know to reissue it later.
        m_szGroup[0] = 0;

        if (m_op.tyOperation != SOT_INVALID)
        {
            Assert(m_op.pCallback != NULL);
        
            if (m_op.fCancel)
            {
                IXPRESULT   rIxpResult;

                // if operation is canceled, add the flush flag
                m_op.error.dwFlags |= SE_FLAG_FLUSHALL;

                // Fake the IXPRESULT
                ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                rIxpResult.hrResult = STORE_E_OPERATION_CANCELED;

                // Return meaningful error information
                _FillStoreError(&m_op.error, &rIxpResult);
                Assert(STORE_E_OPERATION_CANCELED == m_op.error.hrResult);

                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);

                _FreeOperation();
            }
        }
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnError()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  ixpstatus - 
//      [in]  pResult - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult,
                            IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnError");

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnCommand()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  cmdtype - 
//      [in]  pszLine - 
//      [in]  hrResponse - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse,
                              IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnCommand");
    
    return E_NOTIMPL;
}

HRESULT CNewsStore::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    AssertSingleThreaded;

    Assert(m_op.pCallback != NULL);
    hr = m_op.pCallback->GetParentWindow(dwReserved, phwndParent);

    return hr;
}

HRESULT CNewsStore::GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Args
    Assert(ppAccount);
    Assert(g_pAcctMan);

    // Initialize
    *ppAccount = NULL;

    // Find the Account
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, ppAccount));

    // Set server type
    *pdwServerType = SRV_NNTP;

exit:
    // Done
    return(hr);
}

//
//  FUNCTION:   CNewsStore::OnResponse()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pResponse - response data from the query
//
HRESULT CNewsStore::OnResponse(LPNNTPRESPONSE pResponse)
{
    HRESULT hr, hrResult;

    AssertSingleThreaded;

    // If we got disconnected etc while there was still socket activity pending
    // this can happen.
    if (m_op.tyOperation == SOT_INVALID)
        return(S_OK);
    Assert(m_op.pCallback != NULL);

    // Here's a little special something.  If the caller is waiting for a connect
    // response, and the connect fails the transport's returns a response with the
    // state set to NS_DISCONNECTED.  If this is the case, we coerce it a bit to
    // make the states happy.
    if (m_op.nsPending == NS_CONNECT && pResponse->state == NS_DISCONNECTED)
        pResponse->state = NS_CONNECT;

    if (pResponse->state == NS_IDLE)
        return(S_OK);

    // Check to see if we're in the right state.  If we're out of sync, good 
    // luck trying to recover without disconnecting.
    Assert(pResponse->state == m_op.nsPending);

    hr = S_OK;
    hrResult = pResponse->rIxpResult.hrResult;

    // If this is a GROUP command, we need to update our internal state to show
    // what group we're now in if we need to switch later.  Also update the 
    // folderinfo with current stats from the server.
    if (pResponse->state == NS_GROUP)
        hr = _HandleGroupResponse(pResponse);

    // We need to handle the article response to copy the lines to the caller's
    // stream.
    else if (pResponse->state == NS_ARTICLE)
        hr = _HandleArticleResponse(pResponse);

    //pump the data into the store
    else if (pResponse->state == NS_LIST)
        hr = _HandleListResponse(pResponse, FALSE);

    //pump the headers into the folder
    else if (pResponse->state == NS_HEADERS)
        hr = _HandleHeadResponse(pResponse);

    //callback to the poster with result
    else if (pResponse->state == NS_POST)
        hr = _HandlePostResponse(pResponse);

    else if (pResponse->state == NS_NEWGROUPS)
        hr = _HandleListResponse(pResponse, TRUE);

    else if (pResponse->state == NS_XHDR)
    {
        if (m_fXhdrSubject)
            hr = _HandleXHdrSubjectResponse(pResponse);
        else
            hr = _HandleXHdrReferencesResponse(pResponse);
    }


    else if (FAILED(pResponse->rIxpResult.hrResult))
    {
        Assert(pResponse->fDone);

        _FillStoreError(&m_op.error, &pResponse->rIxpResult);

        if (pResponse->state == NS_CONNECT)
        {
            // if connection fails, then add the flush-flag
            m_op.error.dwFlags |= SE_FLAG_FLUSHALL;
        }

        m_op.pCallback->OnComplete(m_op.tyOperation, pResponse->rIxpResult.hrResult, NULL, &m_op.error);
    }

    pResponse->pTransport->ReleaseResponse(pResponse);

    if (FAILED(hrResult))
    {
        _FreeOperation();
        return(S_OK);
    }

    if (FAILED(hr))
    {
        m_op.error.hrResult = hr;

        if (_FConnected())
            m_pTransport->DropConnection();
    
        m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, NULL);
        _FreeOperation();
        return (S_OK);
    }

    // Check to see if we can issue the next command
    else if (pResponse->fDone)
    {
        m_op.iState++;
        _DoOperation();
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleHeadResponse
//
//  PURPOSE:    Stuff the headers into the message store
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleHeadResponse(LPNNTPRESPONSE pResp)
{
    DWORD              dwLow, dwHigh;
    BOOL               fFreeReq, fFreeRead;
    HRESULT            hr;
    CRangeList        *pRange;
    LPSTR              lpsz;
    ADDRESSLIST        addrList;
    PROPVARIANT        rDecoded;
    NNTPHEADER        *pHdrOld;
    FOLDERINFO         FolderInfo;
    MESSAGEINFO        rMessageInfo;
    MESSAGEINFO       *pHdrNew = &rMessageInfo;
    IOERule           *pIRuleSender = NULL;
    BOOL               fDontSave = FALSE;
    HLOCK              hNotifyLock = NULL;
    ACT_ITEM *         pActions = NULL;
    ULONG              cActions = 0;
    IOEExecRules *     pIExecRules = NULL;

    Assert(m_pFolder);
    Assert(pResp);
    Assert(m_pROP != NULL);
    
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if (m_pROP != NULL)
        {
            MemFree(m_pROP);
            m_pROP = NULL;
        }

        return(S_OK);
    }

    if (pResp->rHeaders.cHeaders == 0)
    {
        Assert(pResp->fDone);

        if (SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
        {   
            AddRequestedRange(&FolderInfo, m_pROP->dwFirst, m_pROP->dwLast, &fFreeReq, &fFreeRead);
            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);

            m_pStore->UpdateRecord(&FolderInfo);

            if (fFreeReq)
                MemFree(FolderInfo.Requested.pBlobData);
            if (fFreeRead)
                MemFree(FolderInfo.Read.pBlobData);

            m_pROP->cOps++;
            m_op.iState--;

            m_pStore->FreeRecord(&FolderInfo);
        }

        return(S_OK);
    }

    pRange = NULL;
    if (SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {   
        if (FolderInfo.Read.cbSize > 0)
        {
            pRange = new CRangeList;
            if (pRange != NULL)
                pRange->Load(FolderInfo.Read.pBlobData, FolderInfo.Read.cbSize);
        }

        m_pStore->FreeRecord(&FolderInfo);
    }

    m_pROP->uObtained += pResp->rHeaders.cHeaders;

    // Get the block sender rule if it exists
    Assert(NULL != g_pRulesMan);
    (VOID) g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_NEWS, 0, &pIRuleSender);

    m_pFolder->LockNotify(NOFLAGS, &hNotifyLock);
    
    // Loop through the headers in pResp and convert each to a MESSAGEINFO
    // and write it to the store
    for (UINT i = 0; i < pResp->rHeaders.cHeaders; i++)
    {
        m_op.dwProgress++;

        pHdrOld = &(pResp->rHeaders.rgHeaders[i]);

        ZeroMemory(&rMessageInfo, sizeof(rMessageInfo));
        fDontSave = FALSE;

        // Article ID
        pHdrNew->idMessage = (MESSAGEID)((DWORD_PTR)pHdrOld->dwArticleNum);

        if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &rMessageInfo, NULL))
        {
            m_pFolder->FreeRecord(&rMessageInfo);
            m_op.dwProgress++;
            continue;
        }

        // Account ID
        pHdrNew->pszAcctId = m_szAccountId;
        pHdrNew->pszAcctName = m_rInetServerInfo.szAccount;
        
        // Subject
        rDecoded.vt = VT_LPSTR;
        if (FAILED(MimeOleDecodeHeader(NULL, pHdrOld->pszSubject, &rDecoded, NULL)))
            pHdrNew->pszSubject = PszDup(pHdrOld->pszSubject);
        else
            pHdrNew->pszSubject = rDecoded.pszVal;

        // Strip trailing whitespace from the subject
        ULONG cb = 0;
        UlStripWhitespace(pHdrNew->pszSubject, FALSE, TRUE, &cb);
        
        // Normalize the subject
        pHdrNew->pszNormalSubj = SzNormalizeSubject(pHdrNew->pszSubject);

        // From
        pHdrNew->pszFromHeader = pHdrOld->pszFrom;
        if (S_OK == MimeOleParseRfc822Address(IAT_FROM, IET_ENCODED, pHdrNew->pszFromHeader, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pHdrNew->pszDisplayFrom = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;
                pHdrNew->pszEmailFrom = addrList.prgAdr[0].pszEmail;
                addrList.prgAdr[0].pszEmail = NULL;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        // Date
        MimeOleInetDateToFileTime(pHdrOld->pszDate, &pHdrNew->ftSent);

        // Set the Reveived date (this will get set right when we download the message)
        pHdrNew->ftReceived = pHdrNew->ftSent;

        // Message-ID
        pHdrNew->pszMessageId = pHdrOld->pszMessageId;

        // References
        pHdrNew->pszReferences = pHdrOld->pszReferences;

        // Article Size in bytes
        pHdrNew->cbMessage = pHdrOld->dwBytes;

        // Lines
        pHdrNew->cLines = pHdrOld->dwLines;

        // XRef
        if (pHdrOld->pszXref)
            pHdrNew->pszXref = pHdrOld->pszXref;
        else
            pHdrNew->pszXref = NULL;

        // Its a news message
        FLAGSET(pHdrNew->dwFlags, ARF_NEWSMSG);

        if (NULL != pIRuleSender)
        {
            pIRuleSender->Evaluate(pHdrNew->pszAcctId, pHdrNew, m_pFolder, 
                                    NULL, NULL, pHdrOld->dwBytes, &pActions, &cActions);
            if ((1 == cActions) && (ACT_TYPE_DELETE == pActions[0].type))
            {
                fDontSave = TRUE;
            }
        }
        
        //Add it to the database
        hr = S_OK;
        if (FALSE == fDontSave)
        {
            if (pRange != NULL)
            {
                if (pRange->IsInRange(pHdrOld->dwArticleNum))
                    FLAGSET(pHdrNew->dwFlags, ARF_READ);
            }

            hr = m_pFolder->InsertRecord(pHdrNew);
            if (SUCCEEDED(hr))
            {
                if (NULL == pIExecRules)
                {
                    CExecRules *    pExecRules;
                    
                    pExecRules = new CExecRules;
                    if (NULL != pExecRules)
                    {
                        hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules);
                        if (FAILED(hr))
                        {
                            delete pExecRules;
                        }
                    }
                }
                
                g_pRulesMan->ExecuteRules(RULE_TYPE_NEWS, NOFLAGS, NULL, pIExecRules, pHdrNew, m_pFolder, NULL);
            }
        }
        
        // Free the memory in rMessageInfo so we can start anew with the next entry
        SafeMemFree(pHdrNew->pszSubject);
        SafeMemFree(pHdrNew->pszDisplayFrom);
        SafeMemFree(pHdrNew->pszEmailFrom);

        // Free up any actions done by rules
        if (NULL != pActions)
        {
            RuleUtil_HrFreeActionsItem(pActions, cActions);
            MemFree(pActions);
            pActions = NULL;
        }
        
        if (FAILED(hr) && hr != DB_E_DUPLICATE)
        {
            SafeRelease(pRange);
            SafeRelease(pIRuleSender);
            SafeRelease(pIExecRules);
            m_pFolder->UnlockNotify(&hNotifyLock);
            return(hr);
        }

        m_op.pCallback->OnProgress(SOT_SYNC_FOLDER, m_op.dwProgress, m_op.dwTotal, m_szGroup);
    }

    m_pFolder->UnlockNotify(&hNotifyLock);
    SafeRelease(pIRuleSender);
    SafeRelease(pIExecRules);
    SafeRelease(pRange);

    Assert(m_op.dwProgress <= m_op.dwTotal);
    if (m_op.pCallback)
    {
        m_op.pCallback->OnProgress(SOT_SYNC_FOLDER, m_op.dwProgress, m_op.dwTotal, m_szGroup);

        // We have to re-fetch the folder info because m_pFolder->InsertRecord may have update this folder....
        if (m_pStore && SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
        {   
            dwLow = pResp->rHeaders.rgHeaders[0].dwArticleNum;
            dwHigh = pResp->rHeaders.rgHeaders[pResp->rHeaders.cHeaders - 1].dwArticleNum;

            AddRequestedRange(&FolderInfo, m_pROP->dwFirst, pResp->fDone ? m_pROP->dwLast : dwHigh, &fFreeReq, &fFreeRead);

            if (FolderInfo.dwClientLow == 0 || dwLow < FolderInfo.dwClientLow)
                FolderInfo.dwClientLow = dwLow;
            if (dwHigh > FolderInfo.dwClientHigh)
                FolderInfo.dwClientHigh = dwHigh;

            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);

            m_pStore->UpdateRecord(&FolderInfo);

            if (fFreeReq)
                MemFree(FolderInfo.Requested.pBlobData);
            if (fFreeRead)
                MemFree(FolderInfo.Read.pBlobData);

            if (pResp->fDone)
            {
                m_pROP->cOps++;
                m_op.iState--;
            }

            m_pStore->FreeRecord(&FolderInfo);
        }
    }
    return(S_OK);
}

void MarkExistingFolder(FOLDERID idFolder, FOLDERID *pId, ULONG cId)
{
    // TODO: if this linear search is too slow, use a binary search
    // (but we'll have to switch to a struct with folderid and bool)
    ULONG i;

    Assert(pId != NULL);
    Assert(cId > 0);

    for (i = 0; i < cId; i++, pId++)
    {
        if (idFolder == *pId)
        {
            *pId = 0;
            break;
        }
        else if (idFolder < *pId)
        {
            break;
        }
    }
}

//
//  FUNCTION:   CNewsStore::HandleListResponse
//
//  PURPOSE:    Callback function used by the protocol to give us one line
//              at a time in response to a "LIST" command.  Add each line
//              as a folder in the global folder store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleListResponse(LPNNTPRESPONSE pResp, BOOL fNew)
{
    LPSTR psz, pszCount;
    int nSize;
    char szGroupName[CCHMAX_FOLDER_NAME], szNumber[15];
    FLDRFLAGS fFolderFlags;
    HRESULT hr;
    BOOL fDescriptions;      
    UINT lFirst, lLast;
    FOLDERINFO Folder;
    STOREOPERATIONTYPE type;
    LPNNTPLIST pnl = &pResp->rList;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        return(S_OK);
    }

    fDescriptions = !!(m_op.dwFlags & OPFLAG_DESCRIPTIONS);

    if ((fNew && pnl->cLines > 0) ||
        (!fNew && pResp->fDone))
    {
        if (SUCCEEDED(m_pStore->GetFolderInfo(m_idParent, &Folder)))
        {
            if (fNew ^ !!(Folder.dwFlags & FOLDER_HASNEWGROUPS))
            {
                Folder.dwFlags ^= FOLDER_HASNEWGROUPS;
                m_pStore->UpdateRecord(&Folder);
            }

            m_pStore->FreeRecord(&Folder);
        }
    }

    for (DWORD i = 0; i < pnl->cLines; i++, m_op.dwProgress++)
    {
        // Parse out just the group name.
        psz = pnl->rgszLines[i];
        Assert(*psz);
        
        if (fDescriptions && *psz == '#')
            continue;

        while (*psz && !IsSpace(psz))
            psz = CharNext(psz);

        nSize = (int)(psz - pnl->rgszLines[i]);
        
        if (nSize >= CCHMAX_FOLDER_NAME)
            nSize = CCHMAX_FOLDER_NAME - 1;

        CopyMemory(szGroupName, pnl->rgszLines[i], nSize);
        szGroupName[nSize] = 0;
        
        // this is the first article in the group
        while (*psz && IsSpace(psz))
            psz = CharNext(psz);

        if (fDescriptions)
        {
            // psz now points to the description which should be 
            // null terminated in the response.
            // Load the folder, if possible, and set the description
            // on it.
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = szGroupName;
            Folder.idParent = m_idParent;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if (Folder.pszDescription == NULL ||
                    0 != lstrcmp(psz, Folder.pszDescription))
                {
                    Folder.pszDescription = psz;
                    m_pStore->UpdateRecord(&Folder);
                }

                m_pStore->FreeRecord(&Folder);
            }
        }
        else
        {
            pszCount = psz;
            while (*psz && !IsSpace(psz))
                psz = CharNext(psz);
        
            nSize = (int) (psz - pszCount);
            CopyMemory(szNumber, pszCount, nSize);
            szNumber[nSize] = 0;
            lLast = StrToInt(szNumber);

            // this is the last article in the group
            while (*psz && IsSpace(psz))
                psz = CharNext(psz);
        
            pszCount = psz;
            while (*psz && !IsSpace(psz))
                psz = CharNext(psz);

            nSize = (int)(psz - pszCount);
            CopyMemory(szNumber, pszCount, nSize);
            szNumber[nSize] = 0;
            lFirst = StrToInt(szNumber);

            // Now go see if the group allows posting or not.
            while (*psz && IsSpace(psz))
                psz = CharNext(psz);
        
#define FOLDER_LISTMASK (FOLDER_NEW | FOLDER_NOPOSTING | FOLDER_MODERATED | FOLDER_BLOCKED)

            if (fNew)
                fFolderFlags = FOLDER_NEW;
            else
                fFolderFlags = 0;

            if (*psz == 'n')
                fFolderFlags |= FOLDER_NOPOSTING;
            else if (*psz == 'm')
                fFolderFlags |= FOLDER_MODERATED;
            else if (*psz == 'x')
                fFolderFlags |= FOLDER_BLOCKED;

            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = szGroupName;
            Folder.idParent = m_idParent;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if (m_op.pPrevFolders != NULL)
                    MarkExistingFolder(Folder.idFolder, m_op.pPrevFolders, m_op.cPrevFolders);

                Assert(0 == (fFolderFlags & ~FOLDER_LISTMASK));

                if ((Folder.dwFlags & FOLDER_LISTMASK) != fFolderFlags)
                {
                    Folder.dwFlags = (Folder.dwFlags & ~FOLDER_LISTMASK);
                    Folder.dwFlags |= fFolderFlags;
                    m_pStore->UpdateRecord(&Folder);
                }

                // TODO: should we update server high, low and count here???

                m_pStore->FreeRecord(&Folder);
            }
            else
            {
                // ZeroMemory(&Folder, sizeof(FOLDERINFO));
                // Folder.idParent = m_idParent;
                // Folder.pszName = szGroupName;
                Folder.tySpecial = FOLDER_NOTSPECIAL;
                Folder.dwFlags = fFolderFlags;
                Folder.dwServerLow = lFirst;
                Folder.dwServerHigh = lLast;
                if (Folder.dwServerLow <= Folder.dwServerHigh)
                {
                    Folder.dwServerCount = Folder.dwServerHigh - Folder.dwServerLow + 1;
                    Folder.dwNotDownloaded = Folder.dwServerCount;
                }

                hr = m_pStore->CreateFolder(NOFLAGS, &Folder, NULL);           
                Assert(hr != STORE_S_ALREADYEXISTS);
                if (FAILED(hr))
                    return(hr);
            }
        }
    }

    // only send status every 1/2 second or so.
    if (GetTickCount() > (m_dwLastStatusTicks + 500))
    {
        if (fNew)
            type = SOT_GET_NEW_GROUPS;
        else
            type = fDescriptions ? SOT_SYNCING_DESCRIPTIONS : SOT_SYNCING_STORE;

        m_op.pCallback->OnProgress(type, m_op.dwProgress, 0, m_rInetServerInfo.szServerName);
        m_dwLastStatusTicks = GetTickCount();
    }

    if (!fNew &&
        !fDescriptions &&
        pResp->fDone &&
        SUCCEEDED(pResp->rIxpResult.hrResult))
    {
        IImnAccount *pAcct;
        SYSTEMTIME stNow;
        FILETIME ftNow;

        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &pAcct);
        if (SUCCEEDED(hr))
        {
            GetSystemTime(&stNow);
            SystemTimeToFileTime(&stNow, &ftNow);
            pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&ftNow, sizeof(ftNow));
            pAcct->SaveChanges();

            pAcct->Release();
        }
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandlePostResponse
//
//  PURPOSE:    Callback function used by the protocol to give us one line
//              at a time in response to a "POST" command.  Add each line
//              as a folder in the global folder store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandlePostResponse(LPNNTPRESPONSE pResp)
{    
    Assert(pResp != NULL);
    
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        return(S_OK);
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleGroupResponse
//
//  PURPOSE:    Callback function when a GROUP command completes
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleGroupResponse(LPNNTPRESPONSE pResp)
{
    FOLDERINFO FolderInfo;
    FOLDERID idFolder;
    BOOL fFreeReq, fFreeRead;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);
        Assert(m_op.pszGroup != NULL);

        _FillStoreError(&m_op.error, &pResp->rIxpResult, m_op.pszGroup);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if (pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_NEWSGROUP)
        {
            // HACK: this is so the treeview gets the notification that this folder is being deleted
            m_pStore->SubscribeToFolder(m_op.idFolder, TRUE, NULL);
            m_pStore->DeleteFolder(m_op.idFolder, DELETE_FOLDER_NOTRASHCAN, NULL);
        }

        return(S_OK);
    }

    IxpAssert(pResp->rGroup.pszGroup);
    lstrcpyn(m_szGroup, pResp->rGroup.pszGroup, ARRAYSIZE(m_szGroup));

    if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &FolderInfo)))
    {
        fFreeReq = FALSE;
        fFreeRead = FALSE;

        if (pResp->rGroup.dwFirst <= pResp->rGroup.dwLast)
        {
            FolderInfo.dwServerLow = pResp->rGroup.dwFirst;
            FolderInfo.dwServerHigh = pResp->rGroup.dwLast;
            FolderInfo.dwServerCount = pResp->rGroup.dwCount;

            if (FolderInfo.dwServerLow > 0)
                AddRequestedRange(&FolderInfo, 0, FolderInfo.dwServerLow - 1, &fFreeReq, &fFreeRead);

            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);
        }
        else
        {
            FolderInfo.dwServerLow = 0;
            FolderInfo.dwServerHigh = 0;
            FolderInfo.dwServerCount = 0;
            FolderInfo.dwNotDownloaded = 0;
        }

        m_pStore->UpdateRecord(&FolderInfo);

        if (fFreeReq)
            MemFree(FolderInfo.Requested.pBlobData);
        if (fFreeRead)
            MemFree(FolderInfo.Read.pBlobData);

        m_pStore->FreeRecord(&FolderInfo);
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleArticleResponse
//
//  PURPOSE:    Callback function used by the protocol write a message
//              into the store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleArticleResponse(LPNNTPRESPONSE pResp)
{
    HRESULT hr;
    ADJUSTFLAGS flags;
    MESSAGEIDLIST list;
    ULONG cbWritten;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if ((pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_NUM ||
            pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_FOUND) &&
            m_pFolder != NULL)
        {
            list.cAllocated = 0;
            list.cMsgs = 1;
            list.prgidMsg = &m_op.idMessage;

            flags.dwAdd = ARF_ARTICLE_EXPIRED;
            flags.dwRemove = ARF_DOWNLOAD;

            m_pFolder->SetMessageFlags(&list, &flags, NULL, NULL);
            m_pFolder->SetMessageStream(m_op.idMessage, m_op.pStream);
            m_op.faStream = 0;
        }

        return(S_OK);
    }

    // We need to write the bytes that are returned on to the stream the
    // caller provided

    Assert(m_op.pStream);

    hr = m_op.pStream->Write(pResp->rArticle.pszLines,
                        pResp->rArticle.cbLines, &cbWritten);
    // if (FAILED(hr) || (pResp->rArticle.cbLines != cbWritten))
    if (FAILED(hr))
        return(hr);

    Assert(pResp->rArticle.cbLines == cbWritten);

    // The NNTPRESPONSE struct is going to get sent to the caller anyway,
    // so we need to doctor the cLines member to be the total line count
    // for the message.
    m_op.dwProgress += pResp->rArticle.cLines;

    m_op.pCallback->OnProgress(SOT_GET_MESSAGE, m_op.dwProgress, m_op.dwTotal, NULL);

    // If we're done, then we also rewind the stream
    if (pResp->fDone)
    {
        HrRewindStream(m_op.pStream);
        
        // Articles coming in from news: article urls do not have an IMessageFolder associated with them.
        if (m_pFolder)
        {
            flags.dwAdd = 0;
            flags.dwRemove = ARF_DOWNLOAD;

            if (m_op.idServerMessage)
                _SaveMessageToStore(m_pFolder, m_op.idServerMessage, m_op.pStream);
            else
                CommitMessageToStore(m_pFolder, &flags, m_op.idMessage, m_op.pStream);

            m_op.faStream = 0;
        }

        if (m_op.pStream != NULL)
        {
            m_op.pStream->Release();
            m_op.pStream = NULL;
        }
    }

    SafeMemFree(pResp->rArticle.pszLines);

    return(S_OK);
}

void CNewsStore::_FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult, LPSTR pszGroup)
{
    TraceCall("CNewsStore::FillStoreError");
    Assert(m_cRef >= 0); // Can be called during destruction
    Assert(NULL != pErrorInfo);

    if (pszGroup == NULL)
        pszGroup = m_szGroup;

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    pErrorInfo->hrResult = pResult->hrResult;
    pErrorInfo->uiServerError = pResult->uiServerError; 
    pErrorInfo->hrServerError = pResult->hrServerError;
    pErrorInfo->dwSocketError = pResult->dwSocketError; 
    pErrorInfo->pszProblem = pResult->pszProblem;
    pErrorInfo->pszDetails = pResult->pszResponse;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszFolder = pszGroup;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "NNTP";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_NNTP;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = 0;
}

//
//  FUNCTION:   CNewsStore::_CreateDataFilePath()
//
//  PURPOSE:    Creates a full path to a data file based on an account and a filename
//
//  PARAMETERS:
//      <in>  pszAccount    - account name
//      <in>  pszFileName   - file name to be appended
//      <out> pszPath       - full path to data file
//
HRESULT CNewsStore::_CreateDataFilePath(LPCTSTR pszAccountId, LPCTSTR pszFileName, LPTSTR pszPath)
{
    HRESULT hr = NOERROR;
    TCHAR   szDirectory[MAX_PATH];

    Assert(pszAccountId && *pszAccountId);
    Assert(pszFileName);
    Assert(pszPath);

    // Get the Store Root Directory
    hr = GetStoreRootDirectory(szDirectory, ARRAYSIZE(szDirectory));

    // Validate that I have room
    if (lstrlen(szDirectory) + lstrlen((LPSTR)pszFileName) + 2 >= MAX_PATH)
    {
        Assert(FALSE);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    if (SUCCEEDED(hr))
        hr = OpenDirectory(szDirectory);

    // Format the filename
    wsprintf(pszPath, "%s\\%s.log", szDirectory, pszFileName);

exit:
    return hr;
}

void AddRequestedRange(FOLDERINFO *pInfo, DWORD dwLow, DWORD dwHigh, BOOL *pfReq, BOOL *pfRead)
{
    CRangeList *pRange;

    Assert(pInfo != NULL);
    Assert(dwLow <= dwHigh);
    Assert(pfReq != NULL);
    Assert(pfRead != NULL);

    *pfReq = FALSE;
    *pfRead = FALSE;

    pRange = new CRangeList;
    if (pRange != NULL)
    {
        if (pInfo->Requested.cbSize > 0)
            pRange->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

        pRange->AddRange(dwLow, dwHigh);

        *pfReq = pRange->Save(&pInfo->Requested.pBlobData, &pInfo->Requested.cbSize);

        pRange->Release();
    }

    if (pInfo->Read.cbSize > 0)
    {
        pRange = new CRangeList;
        if (pRange != NULL)
        {
            pRange->Load(pInfo->Read.pBlobData, pInfo->Read.cbSize);

            pRange->DeleteRange(dwLow, dwHigh);

            *pfRead = pRange->Save(&pInfo->Read.pBlobData, &pInfo->Read.cbSize);

            pRange->Release();
        }
    }
}

HRESULT CNewsStore::MarkCrossposts(LPMESSAGEIDLIST pList, BOOL fRead)
{
    PROPVARIANT var;
    IMimeMessage *pMimeMsg;
    IStream *pStream;
    DWORD i;
    MESSAGEINFO Message;
    HRESULT hr;
    LPSTR psz;
    HROWSET hRowset = NULL;

    if (NULL == pList)
    {
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        psz = NULL;

        if (Message.pszXref == NULL &&
            !!(Message.dwFlags & ARF_HASBODY))
        {
            if (SUCCEEDED(MimeOleCreateMessage(NULL, &pMimeMsg)))
            {
                if (SUCCEEDED(m_pFolder->OpenStream(ACCESS_READ, Message.faStream, &pStream)))
                {
                    if (SUCCEEDED(hr = pMimeMsg->Load(pStream)))
                    {
                        var.vt = VT_EMPTY;
                        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(STR_HDR_XREF), NOFLAGS, &var)))
                        {
                            Message.pszXref = var.pszVal;
                            psz = var.pszVal;
                            m_pFolder->UpdateRecord(&Message);
                        }
                    }

                    pStream->Release();
                }

                pMimeMsg->Release();
            }
        }

        if (Message.pszXref != NULL && *Message.pszXref != 0)
            _MarkCrossposts(Message.pszXref, fRead);

        if (psz != NULL)
            MemFree(psz);

        m_pFolder->FreeRecord(&Message);
    }

    if (hRowset != NULL)
        m_pFolder->CloseRowset(&hRowset);

    return(hr);
}

void CNewsStore::_MarkCrossposts(LPCSTR szXRefs, BOOL fRead)
{
    HRESULT    hr;
    CRangeList *pRange;
    BOOL       fReq, fFree;
    DWORD      dwArtNum;
    IMessageFolder *pFolder;
    MESSAGEINFO Message;
    FOLDERINFO info;
    LPSTR      szT = StringDup(szXRefs);
    LPSTR      psz = szT, pszNum;

    if (!szT)
        return;

    // skip over the server field
    // $BUGBUG - we should really verify that our server generated the XRef
    while (*psz && *psz != ' ')
        psz++;

    while (1)
        {
        // skip whitespace
        while (*psz && (*psz == ' ' || *psz == '\t'))
            psz++;
        if (!*psz)
            break;

        // find the article num
        pszNum = psz;
        while (*pszNum && *pszNum != ':')
            pszNum++;
        if (!*pszNum)
            break;
        *pszNum++ = 0;
        
        // Bug #47253 - Don't pass NULL pointers to SHLWAPI.
        if (!*pszNum)
            break;
        dwArtNum = StrToInt(pszNum);

        if (lstrcmpi(psz, m_szGroup) != 0)
        {
            ZeroMemory(&info, sizeof(FOLDERINFO));
            info.idParent = m_idParent;
            info.pszName = psz;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &info, NULL))
            {
                if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
                {
                    fReq = FALSE;

                    if (info.Requested.cbSize > 0)
                    {
                        pRange = new CRangeList;
                        if (pRange != NULL)
                        {
                            pRange->Load(info.Requested.pBlobData, info.Requested.cbSize);
                            fReq = pRange->IsInRange(dwArtNum);
                            pRange->Release();
                        }
                    }

                    if (fReq)
                    {
                        hr = m_pStore->OpenFolder(info.idFolder, NULL, NOFLAGS, &pFolder);
                        if (SUCCEEDED(hr))
                        {
                            ZeroMemory(&Message, sizeof(MESSAGEINFO));
                            Message.idMessage = (MESSAGEID)((DWORD_PTR)dwArtNum);

                            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
                            if (DB_S_FOUND == hr)
                            {
                                if (fRead ^ !!(Message.dwFlags & ARF_READ))
                                {
                                    Message.dwFlags ^= ARF_READ;

                                    if (fRead && !!(Message.dwFlags & ARF_DOWNLOAD))
                                        Message.dwFlags ^= ARF_DOWNLOAD;

                                    pFolder->UpdateRecord(&Message);
                                }

                                pFolder->FreeRecord(&Message);
                            }

                            pFolder->Release();
                        }
                    }
                    else
                    {
                        pRange = new CRangeList;
                        if (pRange != NULL)
                        {
                            if (info.Read.cbSize > 0)
                                pRange->Load(info.Read.pBlobData, info.Read.cbSize);
                            if (fRead)
                                pRange->AddRange(dwArtNum);
                            else
                                pRange->DeleteRange(dwArtNum);
                            fFree = pRange->Save(&info.Read.pBlobData, &info.Read.cbSize);
                            pRange->Release();

                            m_pStore->UpdateRecord(&info);

                            if (fFree)
                                MemFree(info.Read.pBlobData);
                        }
                    }
                }

                m_pStore->FreeRecord(&info);
            }
        }

        // skip over digits
        while (IsDigit(pszNum))
            pszNum++;
        psz = pszNum;        
        }

    MemFree(szT);
}


HRESULT CNewsStore::GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetWatchedInfo");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_GET_WATCH_INFO;
    m_op.pfnState = c_rgpfnGetWatchInfo;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetWatchInfo);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;

    hr = _BeginDeferredOperation();

    return hr;  
}


HRESULT CNewsStore::XHdrReferences(void)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fi;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        if (fi.dwClientWatchedHigh < fi.dwServerHigh)
        {
            m_dwWatchLow = max(fi.dwClientHigh + 1, fi.dwClientWatchedHigh + 1);
            m_dwWatchHigh = fi.dwServerHigh;

            // Save our new high value
            fi.dwClientWatchedHigh = fi.dwServerHigh;
            m_pStore->UpdateRecord(&fi);

            // Check to see if we have any work to do
            if (m_dwWatchLow <= m_dwWatchHigh)
            {
                // Allocate an array for the retreived data
                if (!MemAlloc((LPVOID *) &m_rgpszWatchInfo, sizeof(LPTSTR) * (m_dwWatchHigh - m_dwWatchLow + 1)))
                {
                    m_pStore->FreeRecord(&fi);
                    return (E_OUTOFMEMORY);
                }
                ZeroMemory(m_rgpszWatchInfo, sizeof(LPTSTR) * (m_dwWatchHigh - m_dwWatchLow + 1));

                m_cRange.Clear();
                m_cTotal = 0;
                m_cCurrent = 0;
            
                m_op.dwProgress = 0;
                m_op.dwTotal = m_dwWatchHigh - m_dwWatchLow;

                m_fXhdrSubject = FALSE;

                RANGE range;
                range.idType = RT_RANGE;
                range.dwFirst = m_dwWatchLow;
                range.dwLast = m_dwWatchHigh;

                hr = m_pTransport->CommandXHDR("References", &range, NULL);
                if (hr == S_OK)
                {
                    m_op.nsPending = NS_XHDR;
                    hr = E_PENDING;
                }
            }
        }

        m_pStore->FreeRecord(&fi);
    }

    return(hr);
}


HRESULT CNewsStore::_HandleXHdrReferencesResponse(LPNNTPRESPONSE pResp)
{
    NNTPXHDR *pHdr;

    // Check for error
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);
        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);
        return(S_OK);
    }

    // Loop through the returned data and insert those values into our array
    for (DWORD i = 0; i < pResp->rXhdr.cHeaders; i++)
    {
        pHdr = &(pResp->rXhdr.rgHeaders[i]);
        Assert(pHdr->dwArticleNum <= m_dwWatchHigh);

        // Some servers return "(none)" for articles that don't have that 
        // header.  Smart servers just don't return anything.
        if (0 != lstrcmpi(pHdr->pszHeader, "(none)"))
        {            
            m_rgpszWatchInfo[pHdr->dwArticleNum - m_dwWatchLow] = PszDupA(pHdr->pszHeader);
        }
    }

    // Show a little progress here.  This is actually a little complicated.  The
    // data returned might have a single line for each header, or might be sparse.
    // we need to show progress proportional to how far we are through the headers.
    m_op.dwProgress = (pResp->rXhdr.rgHeaders[pResp->rXhdr.cHeaders - 1].dwArticleNum - m_dwWatchLow);
    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, m_op.dwProgress, m_op.dwTotal, 
                               m_rInetServerInfo.szServerName);

    return (S_OK);
}


HRESULT CNewsStore::XHdrSubject(void)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fi;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    // Check to see if we have any work to do
    if ((m_dwWatchLow > m_dwWatchHigh) || (m_dwWatchLow == 0 && m_dwWatchHigh == 0))
        return (S_OK);

    m_op.dwProgress = 0;
    m_op.dwTotal = m_dwWatchHigh - m_dwWatchLow;

    RANGE range;
    range.idType = RT_RANGE;
    range.dwFirst = m_dwWatchLow;
    range.dwLast = m_dwWatchHigh;

    m_fXhdrSubject = TRUE;

    hr = m_pTransport->CommandXHDR("Subject", &range, NULL);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_XHDR;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::_HandleXHdrSubjectResponse(LPNNTPRESPONSE pResp)
{
    NNTPXHDR *pHdr;

    // Check for error
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);
        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);
        return(S_OK);
    }

    // Loop through the returned data see which ones are watched
    for (DWORD i = 0; i < pResp->rXhdr.cHeaders; i++)
    {
        pHdr = &(pResp->rXhdr.rgHeaders[i]);
        Assert(pHdr->dwArticleNum <= m_dwWatchHigh);

        // Check to see if this is part of a watched thread
        if (_IsWatchedThread(m_rgpszWatchInfo[pHdr->dwArticleNum - m_dwWatchLow], pHdr->pszHeader))
        {
            m_cRange.AddRange(pHdr->dwArticleNum);
            m_cTotal++;
        }
    }

    // Show a little progress here.
    m_op.dwProgress += pResp->rXhdr.cHeaders;
    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, m_op.dwProgress, m_op.dwTotal, 
                               m_rInetServerInfo.szServerName);

    // If this is the end of the xhdr data, we can free our array of references
    if (pResp->fDone)
    {
        for (UINT i = 0; i < (m_dwWatchHigh - m_dwWatchLow + 1); i++)
        {
            if (m_rgpszWatchInfo[i])
                MemFree(m_rgpszWatchInfo[i]);
        }

        MemFree(m_rgpszWatchInfo);
        m_rgpszWatchInfo = 0;

        m_dwWatchLow = 0;
        m_dwWatchHigh = 0;
    }

    return (S_OK);
}


BOOL CNewsStore::_IsWatchedThread(LPSTR pszRef, LPSTR pszSubject)
{
    // Get the Parent
    Assert(m_pFolder);
    return(S_OK == m_pFolder->IsWatched(pszRef, pszSubject) ? TRUE : FALSE);
}


HRESULT CNewsStore::WatchedArticles(void)
{
    HRESULT     hr = S_OK;
    ARTICLEID   rArticleId;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    // Check to see if we have any work to do
    if (m_cRange.Cardinality() == 0)
        return (S_OK);

    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, ++m_cCurrent, m_cTotal, NULL);

    m_op.idServerMessage = m_cRange.Min();
    m_op.idMessage = 0;

    m_cRange.DeleteRange(m_cRange.Min());

    // Create a stream
    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pStream, &m_op.faStream)))
        return (E_OUTOFMEMORY);

    hr = Article();

    if (hr == E_PENDING)
        m_op.iState--;

    return (hr);
}


HRESULT CNewsStore::_SaveMessageToStore(IMessageFolder *pFolder, DWORD id, LPSTREAM pstm)
{
    FOLDERINFO info;
    BOOL fFreeReq, fFreeRead;
    IMimeMessage *pMsg = 0;
    HRESULT       hr;
    MESSAGEID     idMessage = (MESSAGEID)((DWORD_PTR)id);

    // Create a new message
    if (SUCCEEDED(hr = MimeOleCreateMessage(NULL, &pMsg)))
    {
        if (SUCCEEDED(hr = pMsg->Load(pstm)))
        {
            if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &info)))
            {
                fFreeReq = FALSE;
                fFreeRead = FALSE;

                AddRequestedRange(&info, id, id, &fFreeReq, &fFreeRead);
                info.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&info);

                m_pStore->UpdateRecord(&info);

                if (fFreeReq)
                    MemFree(info.Requested.pBlobData);
                if (fFreeRead)
                    MemFree(info.Read.pBlobData);
            }

            hr = m_pFolder->SaveMessage(&idMessage, 0, 0, m_op.pStream, pMsg, NOSTORECALLBACK);
        }

        pMsg->Release();
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\order.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Order.h
//
//  PURPOSE:    Header file for the order articles dialog
//


#define IDC_MESSAGE_LIST                1001
#define IDC_MOVE_UP                     1002
#define IDC_MOVE_DOWN                   1003

#define IDC_DOWNLOAD_AVI                2001
#define IDC_GENERAL_TEXT                2002
#define IDC_SPECIFIC_TEXT               2003
#define IDC_DOWNLOAD_PROG               2004



/////////////////////////////////////////////////////////////////////////////
// Class CCombineAndDecode
//

class CCombineAndDecode : public IStoreCallback, public ITimeoutCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CCombineAndDecode();
    ~CCombineAndDecode();

    HRESULT Start(HWND hwndParent, IMessageTable *pTable, ROWINDEX *rgRows, 
                  DWORD cRows, FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback interface
    //
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // Order dialog message handling stuff
    //
public:
    static INT_PTR CALLBACK OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    INT_PTR CALLBACK _OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _Order_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void    _Order_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    _Order_OnClose(HWND hwnd);
    LRESULT _Order_OnDragList(HWND hwnd, int idCtl, LPDRAGLISTINFO lpdli);

    /*
    void _Order_OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    void _Order_OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _Order_OnPaint(HWND hwnd);
    */

    /////////////////////////////////////////////////////////////////////////
    // Order dialog message handling stuff
    //
public:
    static INT_PTR CALLBACK CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    INT_PTR CALLBACK _CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _Combine_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void    _Combine_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    _Combine_OnDestroy(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _Combine_GetNextArticle(HWND hwnd);
    void _Combine_OnMsgAvail(HWND hwnd);
    void _Combine_OpenNote(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //
private:
    ULONG               m_cRef;

    // Groovy Window Handles
    HWND                m_hwndParent;

    // Interface pointers and all that
    IMessageTable      *m_pTable;
    ROWINDEX           *m_rgRows;
    DWORD               m_cRows;
    FOLDERID            m_idFolder;

    // Order dialog state variables
    LPTSTR              m_pszBuffer;
    LPARAM              m_lpData;
    UINT                m_iItemToMove;

    // Combine dialog state variables
    DWORD               m_cLinesTotal;
    DWORD               m_cCurrentLine;
    DWORD               m_cPrevLine;
    DWORD               m_dwCurrentArt;
    IMimeMessageParts  *m_pMsgParts;
    IOperationCancel   *m_pCancel;
    STOREOPERATIONTYPE  m_type;
    HTIMEOUT            m_hTimeout;
    HWND                m_hwndDlg;
};


#if 0
typedef struct tagORDERPARAMS
    {
    // This stuff get's passed in
    PINETMSGHDR    *rgpMsgs;
    DWORD           cMsgs;
    HWND            hwndOwner;
    CNNTPServer    *pNNTPServer;
    CGroup         *pGroup;      
    TCHAR           szGroup[256];
    
    // This stuff is private data for the dialog
    DWORD           cLinesTotal;
    DWORD           cCurrentLine;
    DWORD           cPrevLine;
    DWORD           dwCurrentArt;
    LPMIMEMESSAGEPARTS  pMsgParts;
    } ORDERPARAMS, *PORDERPARAMS;


BOOL CALLBACK OrderMsgsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK CombineAndDecodeProg(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                   LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\pickgrp.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     PickGrp.h
//
//  PURPOSE:    Contains id's and prototypes for the pick group dialog.
//

#ifndef __PICKGRP_H__
#define __PICKGRP_H__

#include <grplist2.h>

#define c_cchLineMax    1000
#define idtFindDelay    1
#define dtFindDelay     600

class CPickGroupDlg : public IGroupListAdvise
    {
public:    
    /////////////////////////////////////////////////////////////////////////
    // Initialization
    
    CPickGroupDlg();
    ~CPickGroupDlg();
    
    // IUnknown 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IGroupListAdvise
    HRESULT STDMETHODCALLTYPE ItemUpdate(void);
    HRESULT STDMETHODCALLTYPE ItemActivate(FOLDERID id);

    BOOL FCreate(HWND hwndOwner, FOLDERID idServer, LPSTR *ppszGroups, BOOL fPoster);

    static INT_PTR CALLBACK PickGrpDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


private:
    /////////////////////////////////////////////////////////////////////////
    // Message Handlers

    BOOL _OnInitDialog(HWND hwnd);
    BOOL _OnFilter(HWND hwnd);
    void _OnChangeServers(HWND hwnd);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT _OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void _OnClose(HWND hwnd);
    void _OnPaint(HWND hwnd);
    void _OnTimer(HWND hwnd, UINT id);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions

    void _UpdateStateUI(HWND hwnd);
    BOOL _OnOK(HWND hwnd);
    void _AddGroup(void);
    void _InsertList(FOLDERID id);
    void _RemoveGroup(void);
    
    /////////////////////////////////////////////////////////////////////////
    // Class Data
    ULONG           m_cRef;
    LPSTR          *m_ppszGroups;
    HWND            m_hwnd;
    HWND            m_hwndPostTo;
    BOOL            m_fPoster;
    HICON           m_hIcon;
    CGroupList     *m_pGrpList;
    LPCSTR          m_pszAcct;
    FOLDERID        m_idAcct;
    };

/////////////////////////////////////////////////////////////////////////////
// Dialog Control ID's
// 
#define idcAddGroup                                 1004
#define idcSelectedGroups                           1005
#define idcRemoveGroup                              1006
#define idcPostTo                                   1007
#define idcEmailAuthor                              1008
#define idcGroupList                                2001            // Group list listview
#define idcFindText                                 2002            // Find query edit box
#define idcShowFavorites                            2003            // Filter favorites toggle

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\pickgrp.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     PickGrp.cpp
//
//  PURPOSE:    Dialog to allow the user to select groups to post to in the
//              send note window.
//

#include "pch.hxx"
#include <iert.h>
#include "pickgrp.h"
#include "grplist2.h"
#include "shlwapip.h" 
#include "resource.h"
#include "strconst.h"
#include "demand.h"

CPickGroupDlg::CPickGroupDlg()
{
    m_cRef = 1;
    m_ppszGroups = 0;
    m_hwndPostTo = 0;
    m_fPoster = FALSE;
    m_hIcon = NULL;
    m_pGrpList = NULL;
    m_pszAcct = NULL;
    m_idAcct = FOLDERID_INVALID;
}

CPickGroupDlg::~CPickGroupDlg()
{
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));
    if (m_pGrpList != NULL)
        m_pGrpList->Release();
}    

HRESULT STDMETHODCALLTYPE CPickGroupDlg::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IGroupListAdvise *)this;
    else if (IsEqualIID(riid, IID_IGroupListAdvise))
        *ppvObj = (void*) (IGroupListAdvise *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CPickGroupDlg::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CPickGroupDlg::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//  FUNCTION:   CPickGroupsDlg::FCreate()
//
//  PURPOSE:    Handles initialization of the data and creation of the pick
//              groups dialog.
//
//  PARAMETERS:
//      hwndOwner         - Window that will own this dialog.
//      pszAccount        - account to use initially.
//      ppszGroups        - This is where we return the last selected group
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//
BOOL CPickGroupDlg::FCreate(HWND hwndOwner, FOLDERID idServer, LPSTR *ppszGroups, BOOL fPoster)
{
    int iret;
    HRESULT hr;
    FOLDERID idAcct;
    FOLDERINFO info;
    char szAcct[CCHMAX_ACCOUNT_NAME];

    Assert(ppszGroups != NULL);
     
    m_pGrpList = new CGroupList;
    if (m_pGrpList == NULL)
        return(FALSE);
    
    m_ppszGroups = ppszGroups;
    m_fPoster = fPoster;
    
    hr = g_pStore->GetFolderInfo(idServer, &info);
    if (FAILED(hr))
        return(FALSE);

    lstrcpy(szAcct, info.pszName);

    g_pStore->FreeRecord(&info);

    m_pszAcct = szAcct;
    m_idAcct = idServer;

    // Now create the dialog.
    iret = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPickGroup), hwndOwner, PickGrpDlgProc, (LPARAM)this);

    return(iret == IDOK);
}
    
INT_PTR CALLBACK CPickGroupDlg::PickGrpDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet;
    CPickGroupDlg *pThis;

    fRet = TRUE;

    pThis = (CPickGroupDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            Assert(pThis == NULL);
            Assert(lParam != NULL);
            pThis = (CPickGroupDlg *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pThis);

            fRet = pThis->_OnInitDialog(hwnd);
            break;

        case WM_CLOSE:
            pThis->_OnClose(hwnd);
            break;

        case WM_COMMAND:
            pThis->_OnCommand(hwnd, LOWORD(wParam), (HWND)lParam, HIWORD(wParam));
            break;

        case WM_NOTIFY:
            pThis->_OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_TIMER:
            pThis->_OnTimer(hwnd, (UINT)wParam);
            break;

        case WM_PAINT:
            pThis->_OnPaint(hwnd);
            break;

        case NVM_CHANGESERVERS:
            pThis->_OnChangeServers(hwnd);
            break;

        default:
            fRet = FALSE;
            break;
    }

    return(fRet);
}

//
//  FUNCTION:   CPickGroupDlg::OnInitDialog()
//
//  PURPOSE:    Handles initializing the PickGroup dialog.  Initializes the
//              dependant classes, list view, buttons, etc.
//
//  PARAMETERS:
//      hwnd      - Handle of the dialog box.
//      hwndFocus - Handle of the control that will get focus if TRUE is returned.
//      lParam    - Contains a pointer to a string of newsgroups the user has
//                  already selected.
//
//  RETURN VALUE:
//      Returns TRUE to set the focus to hwndFocus, or FALSE otherwise.
//
BOOL CPickGroupDlg::_OnInitDialog(HWND hwnd)
{
    char szTitle[256];
    LV_COLUMN lvc;
    RECT rc;
    LONG cx;
    HDC hdc;
    TEXTMETRIC tm;
    HIMAGELIST himl;
    HRESULT hr;
    HWND hwndList;
    CColumns *pColumns;
    
    m_hwnd = hwnd;
    m_hwndPostTo = GetDlgItem(hwnd, idcPostTo);
    
    hwndList = GetDlgItem(hwnd, idcGroupList);

    pColumns = new CColumns;
    if (pColumns == NULL)
    {
        EndDialog(hwnd, IDCANCEL);
        return(FALSE);
    }

    pColumns->Initialize(hwndList, COLUMN_SET_PICKGRP);
    pColumns->ApplyColumns(COLUMN_LOAD_DEFAULT, 0, 0);

    Assert(m_pGrpList != NULL);
    hr = m_pGrpList->Initialize((IGroupListAdvise *)this, pColumns, hwndList, FOLDER_NEWS);
    Assert(SUCCEEDED(hr));

    pColumns->Release();

    // Bug #21471 - Add the server name to the dialog box title    
    GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle));
    Assert(m_pszAcct);
    lstrcat(szTitle, m_pszAcct);
    SetWindowText(hwnd, szTitle);
    
    GetClientRect(m_hwndPostTo, &rc);
    
    // Set the image lists for the listview
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
    Assert(himl);
    
    // Group name column
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.cx = rc.right;
    lvc.iSubItem = 0;
    
    ListView_InsertColumn(m_hwndPostTo, 0, &lvc);
    
    // Make the second listview have images too
    ListView_SetImageList(m_hwndPostTo, himl, LVSIL_SMALL);
    
    hdc = GetDC(hwndList);
    if (GetTextMetrics(hdc, &tm))
    {
        cx = tm.tmAveCharWidth * 150;
        ListView_SetColumnWidth(hwndList, 0, cx);
        ListView_SetColumnWidth(m_hwndPostTo, 0, cx);
    }
    ReleaseDC(hwndList, hdc);

    SendDlgItemMessage(hwnd, idcShowFavorites, BM_SETCHECK, TRUE, 0L);    
    
    if (!m_fPoster)    
        ShowWindow(GetDlgItem(hwnd, idcEmailAuthor), SW_HIDE);
    
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiNewsGroup), IMAGE_ICON, 16, 16, 0);
    SendDlgItemMessage(hwnd, idcShowFavorites, BM_SETIMAGE, IMAGE_ICON, (LPARAM)m_hIcon); 
    
    PostMessage(hwnd, NVM_CHANGESERVERS, 0, 0L);
    
    return(FALSE);    
}

BOOL CPickGroupDlg::_OnFilter(HWND hwnd)
{
    UINT cch;
    LPSTR pszText;
    HRESULT hr;
    BOOL fSub;
    HWND hwndEdit;

    pszText = NULL;

    hwndEdit = GetDlgItem(hwnd, idcFindText);

    cch = GetWindowTextLength(hwndEdit);
    if (cch > 0)
    {
        cch++;
        if (!MemAlloc((void **)&pszText, cch + 1))
            return(FALSE);

        GetWindowText(hwndEdit, pszText, cch);
    }

    fSub = (IsDlgButtonChecked(hwnd, idcShowFavorites));

    hr = m_pGrpList->Filter(pszText, fSub ? SUB_TAB_SUBSCRIBED : SUB_TAB_ALL, FALSE);
    Assert(SUCCEEDED(hr));

    if (pszText != NULL)
        MemFree(pszText);

    return(TRUE);    
}

void CPickGroupDlg::_OnChangeServers(HWND hwnd)
{
    LPSTR pszTok, pszToken;
    UINT index;
    HRESULT hr;
    FOLDERINFO Folder;

    // TODO: we need to fix the initialization so the filtering is only performed
    // once (we should call IGroupList::Filter once and then IGroupList::SetServer once
    // during creation of the dialog)

    UpdateWindow(hwnd);

    _OnFilter(hwnd);

    hr = m_pGrpList->SetServer(m_idAcct);
    Assert(SUCCEEDED(hr));

    if (m_ppszGroups)
    {
        pszTok = *m_ppszGroups;
        pszToken = StrTokEx(&pszTok, c_szDelimiters);

        while (pszToken != NULL)
            {
            if (m_fPoster && 0 == lstrcmpi(pszToken, c_szPosterKeyword))
                CheckDlgButton(hwnd, idcEmailAuthor, TRUE);
                
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.idParent = m_idAcct;
            Folder.pszName = pszToken;
            
            if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                _InsertList(Folder.idFolder);

                g_pStore->FreeRecord(&Folder);
            }

            pszToken = StrTokEx(&pszTok, c_szDelimiters);    
            }
        
        MemFree(*m_ppszGroups);
        *m_ppszGroups = 0;    
    }

    // Bug #17674 - Make sure the post-to listview has an initial selection.    
    ListView_SetItemState(m_hwndPostTo, 0, LVIS_SELECTED, LVIS_SELECTED);
    _UpdateStateUI(hwnd);    
}

//
//  FUNCTION:   CPickGroupDlg::OnCommand()
//
//  PURPOSE:    Processes the WM_COMMAND messages for the pick group dialog.
//
//  PARAMETERS:
//      hwnd        - Handle of the dialog window.
//      id          - ID of the control which sent the message.
//      hwndCtl     - Handle of the control sending the message.
//      codeNotify  - Notification code being sent.
//
void CPickGroupDlg::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case idcAddGroup:
            _AddGroup();
            break;
            
        case idcRemoveGroup:
            _RemoveGroup();
            break;
            
        case IDOK:
            if (_OnOK(hwnd))
                EndDialog(hwnd, IDOK);
            break;
            
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;

        case idcShowFavorites:
            _OnFilter(hwnd);
            _UpdateStateUI(hwnd);
            break;

        case idcFindText:
            // This is generated when someone types in the find text edit box.
            // We set a timer and when that timer expires we assume the user is
            // done typing and go ahead and perform the query.
            if (EN_CHANGE == codeNotify)
                {
                KillTimer(hwnd, idtFindDelay);
                SetTimer(hwnd, idtFindDelay, dtFindDelay, NULL);
                }
            break;
    }
}

HRESULT CPickGroupDlg::ItemUpdate(void)
    {
    _UpdateStateUI(m_hwnd);

    return(S_OK);
    }

HRESULT CPickGroupDlg::ItemActivate(FOLDERID id)
{
    _AddGroup();

    return(S_OK);
}

//
//  FUNCTION:   CPickGroupDlg::OnNotify()
//
//  PURPOSE:    Handles notification messages from the group list listview.
//
//  PARAMETERS:
//      hwnd   - Handle of the pick group dialog.
//      idFrom - ID of the control sending the notification.
//      pnmhdr - Pointer to the NMHDR struct with the notification info.
//
//  RETURN VALUE:
//      Dependent on the notification.
//
LRESULT CPickGroupDlg::_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    HRESULT hr;
    LRESULT lRes;

    hr = m_pGrpList->HandleNotify(hwnd, idFrom, pnmhdr, &lRes);
    if (hr == S_OK)
        return(lRes);

    switch (pnmhdr->code)
    {
        case NM_DBLCLK:
            if (pnmhdr->hwndFrom == m_hwndPostTo)
                _RemoveGroup();    
            break;    
            
        case LVN_ITEMCHANGED:
            _UpdateStateUI(hwnd);
            break;
    }

    return(0);    
}

void CPickGroupDlg::_OnTimer(HWND hwnd, UINT id)
    {
    KillTimer(hwnd, id);

    _OnFilter(hwnd);
    _UpdateStateUI(hwnd);
    }

void CPickGroupDlg::_OnClose(HWND hwnd)
{
    int iReturn;
    
    iReturn = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews), 
                MAKEINTRESOURCEW(idsDoYouWantToSave), 0, 
                MB_YESNOCANCEL | MB_ICONEXCLAMATION );
    if (iReturn == IDYES)
        _OnCommand(hwnd, IDOK, 0, 0);
    else if (iReturn == IDNO)
        _OnCommand(hwnd, IDCANCEL, 0, 0);   
}

//
//  FUNCTION:   CPickGroupDlg::OnOK()
//
//  PURPOSE:    This function copies the group names from the dialog that
//              the user has selected and returns them in the pointer the
//              caller provided.
//
//  RETURN VALUE:
//      Returns TRUE if the copy was successful, or FALSE otherwise.
//
//  COMMENTS:
//      Note - 1000 characters is a good maximum line length (specified by the 
//             Son-of-RFC 1036 doc) so we limit the number of groups based on
//             this line limit.
//
//
BOOL CPickGroupDlg::_OnOK(HWND hwnd)
{
    // OK, we've got the entire sorted list.  Create a string with all the groups
    // and put it in the edit control.
    char szGroups[c_cchLineMax], szGroup[256];
    int cGroups;
    LPSTR psz;
    LV_ITEM lvi;
    int cchGroups = 0, cch;
    
    szGroups[0] = 0;
    
    if (m_fPoster && IsDlgButtonChecked(hwnd, idcEmailAuthor))
    {
        lstrcat(szGroups, c_szPosterKeyword);
        cchGroups += lstrlen(c_szPosterKeyword);
    }
    
    if (cGroups = ListView_GetItemCount(m_hwndPostTo))
    {
        lvi.mask = LVIF_TEXT;
        lvi.iSubItem = 0;
        lvi.pszText = szGroup;
        lvi.cchTextMax = ARRAYSIZE(szGroup);
        for (lvi.iItem = 0; lvi.iItem < cGroups; lvi.iItem++)
        {
            // Get the item
            ListView_GetItem(m_hwndPostTo, &lvi);
            
            // Make sure the length of this next group doesn't push us over
            // the max line length.
            cch = lstrlen(lvi.pszText);
            if ((cch + cchGroups + 2) > c_cchLineMax)
            {
                // Bug #24156 - If we have to truncate, then let the user know.
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews), 
                    MAKEINTRESOURCEW(idsErrNewsgroupLineTooLong), 0, MB_OK | MB_ICONINFORMATION);
                return (FALSE);
            }                
            
            if (cchGroups)
                lstrcat(szGroups, ", ");
            lstrcat(szGroups, lvi.pszText);
            cchGroups += (cch + 2);
        }
    }
    
    // Now that we're done building this marvelous string, copy it to
    // the buffer for returning.
    if (!MemAlloc((LPVOID *)&psz, cchGroups + 1))
        return(FALSE);
    lstrcpy(psz, szGroups);    
    *m_ppszGroups = psz;
    
    return(TRUE);
}

//
//  FUNCTION:   CPickGroupDlg::AddGroup()
//
//  PURPOSE:    Takes the group names selected in the ListView and adds them
//              to the selected groups Post To list.
//
void CPickGroupDlg::_AddGroup(void)
{
    FOLDERID *pid;
    DWORD cid, i;
    HCURSOR hcur;
    HRESULT hr;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    SetWindowRedraw(m_hwndPostTo, FALSE);
    
    hr = m_pGrpList->GetSelectedCount(&cid);
    if (SUCCEEDED(hr) && cid > 0)
    {
        if (MemAlloc((void **)&pid, cid * sizeof(FOLDERID)))
        {
            hr = m_pGrpList->GetSelected(pid, &cid);
            if (SUCCEEDED(hr))
            {
                for (i = 0; i < cid; i++)
                {
                    _InsertList(pid[i]);
                }
            }

            MemFree(pid);
        }
    }

    if (-1 == ListView_GetNextItem(m_hwndPostTo, -1, LVNI_ALL | LVNI_SELECTED))
        ListView_SetItemState(m_hwndPostTo, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    
    SetWindowRedraw(m_hwndPostTo, TRUE);
    InvalidateRect(m_hwndPostTo, NULL, TRUE);

    SetCursor(hcur);    
}

//
//  FUNCTION:   CPickGroupDlg::InsertList()
//
//  PURPOSE:    Given a index into the CGroupList's newsgroup list, that group
//              is inserted into the Post To list.
//
//  PARAMETERS:
//      index - Index of a newsgroup in the CGroupList newsgroup list.
//
void CPickGroupDlg::_InsertList(FOLDERID id)
{
    LV_ITEM lvi;
    int count;
    FOLDERINFO info;
    HRESULT hr;

    count = ListView_GetItemCount(m_hwndPostTo);
    
    // First make sure this isn't a duplicate.
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    
    for (lvi.iItem = 0; lvi.iItem < count; lvi.iItem++)
    {
        ListView_GetItem(m_hwndPostTo, &lvi);
        if (id == (FOLDERID)lvi.lParam)
            return;
    }
    
    hr = g_pStore->GetFolderInfo(id, &info);
    if (SUCCEEDED(hr))
    {
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.pszText = info.pszName;
        if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
        {
            lvi.iImage = iNewsGroup;
            lvi.mask |= LVIF_IMAGE;
        }
        lvi.lParam = (LPARAM)id;
        ListView_InsertItem(m_hwndPostTo, &lvi);

        g_pStore->FreeRecord(&info);
    }
}    

void CPickGroupDlg::_RemoveGroup(void)
{
    int index, count, iItemFocus;
    HCURSOR hcur;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    SetWindowRedraw(m_hwndPostTo, FALSE);
    
    count = ListView_GetItemCount(m_hwndPostTo);
    iItemFocus = ListView_GetNextItem(m_hwndPostTo, -1, LVNI_FOCUSED);

    // Loop through all the selected items and remove them from the ListView
    for (index = count; index >= 0; index--)
    {
        if (ListView_GetItemState(m_hwndPostTo, index, LVIS_SELECTED))
            ListView_DeleteItem(m_hwndPostTo, index);
    }
    
    // Bug #22189 - Make sure the focus/selection goes somewhere after we delete.
    iItemFocus--;
    if (iItemFocus < 0 || ListView_GetItemCount(m_hwndPostTo) < iItemFocus)
        iItemFocus = 0;
    ListView_SetItemState(m_hwndPostTo, iItemFocus, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    SetWindowRedraw(m_hwndPostTo, TRUE);
    InvalidateRect(m_hwndPostTo, NULL, TRUE);
    SetCursor(hcur);    
}

void CPickGroupDlg::_UpdateStateUI(HWND hwnd)
{
    DWORD cid;
    HRESULT hr;

    hr = m_pGrpList->GetSelectedCount(&cid);
    if (FAILED(hr))
        return;

    EnableWindow(GetDlgItem(hwnd, idcAddGroup), cid > 0);
    EnableWindow(GetDlgItem(hwnd, idcRemoveGroup), ListView_GetSelectedCount(m_hwndPostTo));
}

void CPickGroupDlg::_OnPaint(HWND hwnd)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    HFONT hf;
    char szBuffer[CCHMAX_STRINGRES];

    hdc = BeginPaint(hwnd, &ps); 
    // Only do this if the button is available
    if (IsWindow(GetDlgItem(hwnd, idcShowFavorites)))    
    {
        // Get the position of the toggle button
        GetClientRect(GetDlgItem(hwnd, idcShowFavorites), &rc);
        MapWindowPoints(GetDlgItem(hwnd, idcShowFavorites), hwnd, (LPPOINT) &rc, 1);
        rc.left += (rc.right + 4);
        rc.right = rc.left + 300;
        rc.top += 1;
        rc.bottom += rc.top;
        AthLoadString(idsShowFavorites, szBuffer, ARRAYSIZE(szBuffer));
        
        hf = (HFONT) SelectObject(hdc, (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        DrawText(hdc, szBuffer, lstrlen(szBuffer),
                 &rc, DT_SINGLELINE | DT_VCENTER | DT_NOCLIP);        
        SelectObject(hdc, hf);     
    }

    EndPaint(hwnd, &ps);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\range.cpp ===
//
// RANGE.CPP
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
//

// -*- C -*-
//
//  Copyright 1992 Software Innovations, Inc.
//
//  $Source: D:\CLASS\SOURCE\range.c-v $
//  $Author: martin $
//  $Date: 92/07/15 05:09:24 $
//  $Revision: 1.1 $
//
//

#include "pch.hxx"
#include "range.h"
#include "rangetst.h"

// QUANTUM defines the number of m_rangeTable cells to be allocated at
//   one time.  Whenever the m_rangeTable becomes full, it is expanded
//   by QUANTUM range cells.  m_rangeTable's never shrink.
const int QUANTUM = 64;

inline int inRange(RangeType r, ULONG x) { return ((x>=r.low) && (x<=r.high)); };

CRangeList::CRangeList()
{
    m_cRef = 1;
    m_numRanges = 0;
    m_rangeTableSize = 0;
    m_rangeTable = NULL;
}

#if 0
/*
CRangeList::CRangeList(CRangeList& r)
{
    m_numRanges = r.m_numRanges;
    m_rangeTableSize = r.m_rangeTableSize;
    m_rangeTable = new RangeType[m_rangeTableSize];
    CopyMemory(m_rangeTable, r.m_rangeTable, m_numRanges * sizeof(RangeType));
}
*/
#endif

CRangeList::~CRangeList()
{
    if (m_rangeTable)
        MemFree(m_rangeTable);
}

ULONG CRangeList::AddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&m_cRef);
}

ULONG CRangeList::Release(void)
{    
    ULONG cRefT = (ULONG)InterlockedDecrement((LPLONG)&m_cRef);

    if (cRefT == 0)
        delete this;

    return (cRefT);
}

BOOL CRangeList::IsInRange(const ULONG value) const
{
    for (int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return TRUE;
    return FALSE;
}

ULONG CRangeList::MinOfRange(const ULONG value) const
{
    if (RANGE_ERROR == value)
        return RANGE_ERROR;
    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return m_rangeTable[i].low;
    return RANGE_ERROR;
}

ULONG CRangeList::MaxOfRange(const ULONG value) const
{
    if (RANGE_ERROR == value)
        return RANGE_ERROR;
    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return m_rangeTable[i].high;
    return RANGE_ERROR;
}

ULONG CRangeList::Max() const
{
    if (m_numRanges==0)
        return RANGE_ERROR;
    return m_rangeTable[m_numRanges-1].high;
}

ULONG CRangeList::Min() const
{
    if (m_numRanges==0)
        return RANGE_ERROR;
    return m_rangeTable[0].low;
}

BOOL CRangeList::Save(LPBYTE *const ppb, ULONG *const pcb) const
{
    Assert(ppb);
    Assert(pcb);

    *pcb = m_numRanges * sizeof(RangeType);
    if (*pcb)
        {
        if (!MemAlloc((LPVOID*)ppb, *pcb))
            return FALSE;
        CopyMemory(*ppb, m_rangeTable, *pcb);
        }
    else
        *ppb = NULL;
    return TRUE;
}

BOOL CRangeList::Load(const LPBYTE pb, const ULONG cb)
{
    RangeType *pRangeTable;

    Assert(pb != NULL);
    Assert(cb > 0);

    if (!MemAlloc((void **)&pRangeTable, cb))
        return(FALSE);

    m_numRanges = m_rangeTableSize = cb / sizeof(RangeType);
    if (m_rangeTable)
        MemFree(m_rangeTable);
    CopyMemory(pRangeTable, pb, cb);
    m_rangeTable = pRangeTable;

    return TRUE;
}

BOOL CRangeList::NextLowerAntiRange(const ULONG value, RangeType *const rt) const
{
    if (RANGE_ERROR == value || m_numRanges < 2 || !rt)
        return FALSE;

    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            {
            if (0 == i)
                return FALSE;
            rt->high = m_rangeTable[i].low-1;
            rt->low = m_rangeTable[i-1].high+1;
            return TRUE;
            }
    return FALSE;
}

BOOL CRangeList::NextHigherAntiRange(const ULONG value, RangeType *const rt) const
{
    if (RANGE_ERROR == value || m_numRanges < 2 || !rt)
        return FALSE;

    for (register int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            {
            if (m_numRanges-1 == i)
                return FALSE;
            rt->low = m_rangeTable[i].high+1;
            rt->high = m_rangeTable[i+1].low-1;
            return TRUE;
            }
    return FALSE;
}

BOOL CRangeList::HighestAntiRange(RangeType *const rt) const
{
    if (m_numRanges < 2 || !rt)
        return FALSE;
    rt->high = m_rangeTable[m_numRanges-1].low-1;
    rt->low = m_rangeTable[m_numRanges-2].high+1;
    return TRUE;
}

BOOL CRangeList::LowestAntiRange(RangeType *const rt) const
{
    if (m_numRanges < 2 || !rt)
        return FALSE;
    rt->high = m_rangeTable[1].low-1;
    rt->low = m_rangeTable[0].high+1;
    return TRUE;
}

BOOL CRangeList::AddRange(const ULONG value)
{
    RangeType r = { value, value };
    return AddRange(r);
}

BOOL CRangeList::AddRange(const ULONG low, const ULONG high)
{
    RangeType r = { low, high };
    return AddRange(r);
}

BOOL CRangeList::AddRange(CRangeList& r)
{
    for (int i=0 ; i<r.m_numRanges ; ++i)
        if (!AddRange(r.m_rangeTable[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::AddRange(RangeType *rt, int count)
{
    for (int i=0 ; i<count ; ++i)
        if (!AddRange(rt[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::AddRange(const RangeType range)
{
    int  possibleLoc;
    int  insertPosition;

    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to AddRange()");
        return FALSE;
        }

    if (m_numRanges==0) 
        {
        if (m_rangeTableSize == 0)
            if (!Expand())
                return FALSE;
        m_numRanges = 1;
        CopyMemory(&m_rangeTable[0], &range, sizeof(RangeType));
        } 
    else 
        {
        possibleLoc = BinarySearch(range.low);
        if (!((possibleLoc > -1) &&
              (inRange(m_rangeTable[possibleLoc], range.low)) &&
              (inRange(m_rangeTable[possibleLoc], range.high)))) 
            {
            insertPosition = possibleLoc + 1;
            if (m_numRanges == m_rangeTableSize)
                if (!Expand())
                    return FALSE;
            ShiftRight(insertPosition, 1);
            CopyMemory(&m_rangeTable[insertPosition], &range, sizeof(RangeType));
            if (insertPosition > 0)
                SubsumeDown(insertPosition);
            if (insertPosition < m_numRanges)
                SubsumeUpwards(insertPosition);
            }
        }
    return TRUE;
}

BOOL CRangeList::DeleteRange(const ULONG value)
{
    RangeType r = { value, value };
    return DeleteRange(r);
}

BOOL CRangeList::DeleteRange(const ULONG low, const ULONG high)
{
    RangeType r = { low, high };
    return DeleteRange(r);
}

BOOL CRangeList::DeleteRange(CRangeList& r)
{
    for (int i=0 ; i<r.m_numRanges ; ++i)
        if (!DeleteRange(r.m_rangeTable[i]))
            return FALSE;
    return TRUE;
}

BOOL CRangeList::DeleteRange(const RangeType range)
{
    int lowEndChange;
    int highEndChange;

    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to DeleteRange()");
        return FALSE;
        }

    lowEndChange = BinarySearch(range.low);
    highEndChange = BinarySearch(range.high);

    if ((lowEndChange != -1) && (highEndChange == lowEndChange))  
        {
        if (inRange(m_rangeTable[lowEndChange], range.low)) 
            {
            if (inRange(m_rangeTable[lowEndChange], range.high)) 
                {
                if ((m_rangeTable[lowEndChange].low == range.low) &&
                    (m_rangeTable[lowEndChange].high == range.high)) 
                    {
                    if (lowEndChange == (m_numRanges-1))  
                        {
                        m_numRanges--;
                        } 
                    else 
                        {
                        ShiftLeft(lowEndChange + 1, 1);
                        }
                    } 
                else 
                    {
                    if (m_rangeTable[lowEndChange].low == range.low)  
                        {
                        m_rangeTable[lowEndChange].low = range.high + 1;
                        } 
                    else 
                        {
                        if (m_rangeTable[lowEndChange].high == range.high) 
                            {
                            Assert(range.low > 0);
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            } 
                        else 
                            {
                            // the range to be deleted is properly contained in 
                            //  m_rangeTable[lowEndChange]
                            if (m_numRanges == m_rangeTableSize)
                                if (!Expand())
                                    return FALSE;
                            ShiftRight(lowEndChange + 1, 1);
                            m_rangeTable[lowEndChange + 1].low = range.high + 1;
                            m_rangeTable[lowEndChange + 1].high = m_rangeTable[lowEndChange].high;
                            Assert(range.low > 0);    
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            }
                        }
                    }
                } 
            else 
                {
                // range.low is in m_rangeTable[lowEndChange], but range.high
                //  is not
                if (m_rangeTable[lowEndChange].low == range.low) 
                    {
                    ShiftLeft(lowEndChange + 1, 1);
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }  // of the cases where range.low actually in m_rangeTable[lowEndChange]
        } 
    else 
        { // of the cases where highEndChange == lowEndChange
        if (lowEndChange != -1)  
            {
            if (inRange(m_rangeTable[lowEndChange], range.low))  
                {
                if (range.low == m_rangeTable[lowEndChange].low) 
                    {
                    lowEndChange = lowEndChange - 1;
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }
        if (highEndChange != -1)  
            {
            if (inRange(m_rangeTable[highEndChange], range.high))  
                {
                if (range.high == m_rangeTable[highEndChange].high)  
                    {
                    highEndChange = highEndChange + 1;
                    } 
                else 
                    {
                    m_rangeTable[highEndChange].low = range.high + 1;
                    }
                } 
            else 
                {
                highEndChange++;
                }
            }
        if (!(lowEndChange > highEndChange)) 
            {
            // (0 <= lowEndChange < m_numRanges => m_rangeTable[lowEndChange] has received
            //                 any requisite adjustments and is to be kept)
            //  and (0 <= highEndChange < m_numRanges => m_rangeTable[highEndChange]
            //                 has received any requistie adjs. and is a keeper)
            //  and "forall" i [ lowEndChange < i < highEndChange => 
            //                   m_rangeTable[i] is to be overwritten]
            if (highEndChange >= m_numRanges)  
                {
                m_numRanges = lowEndChange + 1;
                } 
            else 
                {
                if ((highEndChange - lowEndChange - 1) > 0)  
                    {
                    ShiftLeft(highEndChange, (highEndChange-lowEndChange-1));
                    }
                }
            } //  else there's a problem with this code...
        }
    return TRUE;
}


ULONG CRangeList::Next(const ULONG current) const
{
    int loc;

    if (m_numRanges == 0)
        return RANGE_ERROR;

    if ((loc = BinarySearch(current)) == -1)
        return m_rangeTable[0].low;
    else if (loc == (m_numRanges-1))
        {
        if (inRange(m_rangeTable[m_numRanges-1], current))
            {
            if (inRange(m_rangeTable[m_numRanges-1], current + 1))
                return current + 1;
            else
                return RANGE_ERROR;
            }
        else
            return RANGE_ERROR;
        }
    else // case where loc == m_numRanges-1
        {
        // 1 <= loc < m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (inRange(m_rangeTable[loc], current + 1))
                return current + 1;
            else
                return m_rangeTable[loc + 1].low;
            }
        else
            return m_rangeTable[loc + 1].low;
        }
}

ULONG CRangeList::Prev(const ULONG current) const
{
    int loc;

    if (m_numRanges == 0)
        return RANGE_ERROR;

    if ((loc = BinarySearch(current)) == -1) 
        {
        return RANGE_ERROR;
        } 
    else if (loc == 0)
        {
        if (inRange(m_rangeTable[0], current))
            {
            if (current > 0 && inRange(m_rangeTable[0], current - 1))
                return current - 1;
            else
                return RANGE_ERROR;
            }
        else
            return m_rangeTable[0].high;
        }
    else
        {
        // 1 < loc <= m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (current > 0 && inRange(m_rangeTable[loc], current - 1))
                return current - 1;
            else
                return m_rangeTable[loc-1].high;
            }
        else
            return m_rangeTable[loc].high;
        }
}

ULONG CRangeList::Cardinality(void) const
{
    ULONG card = 0;

    for (int i=0 ; i<m_numRanges ; i++)
        card += (m_rangeTable[i].high - m_rangeTable[i].low + 1);
    return card;
}



int CRangeList::BinarySearch(const ULONG value) const
{
//  We are looking for `value' in the m_rangeTable.  If value is in the
//  set of valid ranges, we return the array subscript of the range
//  containing `value'.  If `value' is not contained in any of the 
//  ranges then return `loc' where
//        (0 <= loc < m_numRanges =>
//                 (m_rangeTable[loc].low < rangeNum)
//           "and" (m_rangeTable[loc + 1].low > rangeNum))
//    "and" (loc = m_numRanges => rangeNum > m_rangeTable[m_numRanges].low)
//    "and" (loc = -1 =>     m_numRanges = 0
//                     "or" rangeNum < m_rangeTable[0].low) }
    long low, high, mid;
    int loc=-1;

    if (m_numRanges == 0)
        return -1;

    if (value < m_rangeTable[0].low)
        return -1;

    low = 0;
    high = m_numRanges - 1;
    while (low <= high) {
        // inv: low < high - 1, and if rngNum is any where in m_rangeTable, it is in
        //      the range from m_rangeTable[low] to m_rangeTable[high]
        mid = (low + high) / 2;
        if ((value >= m_rangeTable[mid].low) && 
            ((mid == (m_numRanges-1)) || (value < m_rangeTable[mid + 1].low))) 
            {
            loc = mid;
            high = low - 1;
            } 
        else 
            {
            if (value > m_rangeTable[mid].low)
                low = mid + 1;
            else
                high = mid - 1;
            }
    }
    return loc;
}

// Expand() will grow the m_rangeTable by QUANTUM range cells.
BOOL CRangeList::Expand()
{
    RangeType *newRangeTable;

    if (!MemAlloc((LPVOID*)&newRangeTable, (m_rangeTableSize + QUANTUM) * sizeof(RangeType)))
        return FALSE;

    m_rangeTableSize += QUANTUM;
    if (m_rangeTable) 
        {
        if (m_numRanges > 0)
            CopyMemory(newRangeTable, m_rangeTable, m_numRanges * sizeof(RangeType));
        MemFree(m_rangeTable);
        }
    m_rangeTable = newRangeTable;
    return TRUE;
}

void CRangeList::ShiftLeft(int low, int distance)
{
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low-distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges -= distance;
}

void CRangeList::ShiftRight(int low, int distance)
{
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low+distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges += distance;
}

// pre: (m_rangeTable[anchorPosition] has probably just been added to m_rangeTable.)
//          1 <= anchorPosition <= m_numRanges
//      and (   anchorPosition = 1
//           or (m_rangeTable[anchorPosition].low >
//                 m_rangeTable[anchorPosition - 1].high) )
// post: No overlapping or contiguous ranges from 1 to m_numRanges. }
void CRangeList::SubsumeUpwards(const int anchor)
{
    int posOfLargerLow;
    int copyDownDistance;
    int copyPos;

    posOfLargerLow = anchor + 1;
    while ((posOfLargerLow < m_numRanges) && 
           (m_rangeTable[posOfLargerLow].low <= m_rangeTable[anchor].high + 1))
        posOfLargerLow++;

    if (posOfLargerLow == m_numRanges) 
        {
        if (m_rangeTable[m_numRanges-1].high > m_rangeTable[anchor].high)
            m_rangeTable[anchor].high = m_rangeTable[m_numRanges-1].high;
        m_numRanges = anchor + 1;
        } 
    else 
        {
        // posOfLargerLow now indexes the first element of m_rangeTable, looking from
        // m_rangeTable[anchor], with .low > m_rangeTable[anchor].high + 1
        if (posOfLargerLow > (anchor + 1)) 
            {
            if (m_rangeTable[posOfLargerLow - 1].high > m_rangeTable[anchor].high) 
                m_rangeTable[anchor].high = m_rangeTable[posOfLargerLow - 1].high;
            copyDownDistance = posOfLargerLow - anchor - 1;
            copyPos = posOfLargerLow;
            while (copyPos < m_numRanges) 
                {
                m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
                copyPos = copyPos + 1;
                }
            m_numRanges -= copyDownDistance;
            }
        }
}

void CRangeList::SubsumeDown(int& anchor)
{
    int posOfSmallerHigh;
    int copyDownDistance;
    int copyPos;

    posOfSmallerHigh = anchor - 1;
    while ((posOfSmallerHigh >= 0) &&
           (m_rangeTable[posOfSmallerHigh].high + 1 >= m_rangeTable[anchor].low)) 
        {
        posOfSmallerHigh--;
        }

    if (posOfSmallerHigh < 0) 
        {
        if (m_rangeTable[0].low < m_rangeTable[anchor].low)
            m_rangeTable[anchor].low = m_rangeTable[0].low;
        }

    // posOfSmallerHigh either has value 0 or subscripts the first element of
    //  m_rangeTable, looking down from anchor, with a .high that is
    //  less than m_rangeTable[anchor].low - 1.
    if (m_rangeTable[posOfSmallerHigh + 1].low < m_rangeTable[anchor].low)
        m_rangeTable[anchor].low = m_rangeTable[posOfSmallerHigh + 1].low;
    copyDownDistance = anchor - posOfSmallerHigh - 1;
    if (copyDownDistance > 0) 
        {
        copyPos = anchor;
        while (copyPos < m_numRanges) 
            {
            m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
            copyPos++;
            }
        m_numRanges -= copyDownDistance;
        anchor -= copyDownDistance;
        }
}



#if 0
/* 
 * We might need these ones again if we decide to import .newsrc files
 *
void CRangeList::AddRange(const char *s)
{
    char *token, *q;
    char *p = new char[strlen(s)+1];

    strcpy(p, s);

    if ((token = strtok(p, ","))==NULL)
        return;
    while (token!=NULL) {
        if ((q = strchr(token, '-'))==NULL) {  // no dash - single value
            AddRange(atol(token));
        } else {
            long low, high;
            low = atol(token);
            high = atol(q+1);
            if (low<=high)
                AddRange(low, high);
        }
        token = strtok(NULL, ",");
    }
}

void CRangeList::DeleteRange(const char *s)
{
    char *token, *q;
    char *p = new char[strlen(s)+1];

    strcpy(p, s);

    if ((token = strtok(p, ","))==NULL)
        return;
    while (token!=NULL) {
        if ((q = strchr(token, '-'))==NULL) {  // no dash - single value
            DeleteRange(atol(token));
        } else {
            long low, high;
            low = atol(token);
            high = atol(q+1);
            if (low<=high)
                DeleteRange(low, high);
        }
        token = strtok(NULL, ",");
    }
}
*/
#endif

#ifdef DEBUG

#define WORK_BUFSIZ 256

LPTSTR CRangeList::RangeToString()
{
    LPTSTR  p, buffer;
    TCHAR   temp[20];
    int     buffsize = m_numRanges ? WORK_BUFSIZ : 1;

    if (!MemAlloc((LPVOID*)&buffer, buffsize * sizeof(TCHAR)))
        return NULL;
    *buffer = '\0';

    // nothing to do?
    if (m_numRanges == 0) 
        return buffer;

    // dump the ranges as a string: "low-high, low-high, singleton, low-high\n"
    for (int i=0; i<m_numRanges; i++) 
        {
        if (m_rangeTable[i].low == m_rangeTable[i].high)
            wsprintf(temp, "%ld", m_rangeTable[i].low);
        else
            wsprintf(temp, "%ld-%ld", m_rangeTable[i].low, m_rangeTable[i].high);

        if ((lstrlen(temp) + lstrlen(buffer) + 2) > buffsize) 
            {
            // buffer is about to overflow... double its size
            if (!MemAlloc((LPVOID*)&p, 2 * buffsize))
                {
                MemFree(buffer);
                return NULL;
                }
            buffsize *= 2;
            lstrcpy(p, buffer);
            MemFree(buffer);
            buffer = p;
            }
        lstrcat(buffer, temp);
        if (i < (m_numRanges-1))
            lstrcat(buffer, ",");
        }

    // save some space, trim the buffer down
    if (MemAlloc((LPVOID*)&p, (lstrlen(buffer)+1) * sizeof(TCHAR)))
        {
        lstrcpy(p, buffer);
        MemFree(buffer);
        buffer = p;
        }
    return buffer;
}

void CRangeList::DebugOutput(LPTSTR szComment)
{
    LPTSTR  szRange = RangeToString();
    OutputDebugString(szComment);
    if (szRange)
        {
        OutputDebugString(szRange);
        MemFree(szRange);
        }
    OutputDebugString("\r\n");
}

#endif

#ifdef DEBUG
INT_PTR CALLBACK RangeTestDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CRangeList *pRL = (CRangeList *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg)
        {
        case WM_INITDIALOG:
            {
            pRL = new CRangeList();
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pRL);
            break;
            }

        case WM_COMMAND:
            {
            int     i1 = GetDlgItemInt(hwnd, idcInput1, NULL, FALSE);
            int     i2 = GetDlgItemInt(hwnd, idcInput2, NULL, FALSE);
            BOOL    fRet;
            LPTSTR  szRange;

            switch(GET_WM_COMMAND_ID(wp,lp))
                {
                case IDOK:
                case IDCANCEL:
                    delete pRL;
                    SetWindowLongPtr(hwnd, DWLP_USER, 0);
                    EndDialog(hwnd, TRUE);
                    return TRUE;
                case idcAddRange:
                    fRet = pRL->AddRange(i1, i2);
                    szRange = pRL->RangeToString();
                    SetDlgItemText(hwnd, idcPrint, szRange);
                    if (szRange)
                        MemFree(szRange);
                    SetDlgItemInt(hwnd, idcResult, fRet, FALSE);
                    return TRUE;
                case idcDeleteRange:
                    fRet = pRL->DeleteRange(i1, i2);
                    szRange = pRL->RangeToString();
                    SetDlgItemText(hwnd, idcPrint, szRange);
                    if (szRange)
                        MemFree(szRange);
                    SetDlgItemInt(hwnd, idcResult, fRet, FALSE);
                    return TRUE;
                case idcIsInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->IsInRange(i1), FALSE);
                    return TRUE;
                case idcNextInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->Next(i1), TRUE);
                    return TRUE;
                case idcPrevInRange:
                    SetDlgItemInt(hwnd, idcResult, pRL->Prev(i1), TRUE);
                    return TRUE;
                case idcClear:
                    pRL->Clear();
                    SetDlgItemText(hwnd, idcPrint, NULL);
                    SetDlgItemInt(hwnd, idcResult, TRUE, FALSE);
                    return TRUE;
                }
            }
            break;
        }
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\order.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Order.cpp
//
//  PURPOSE:    Implements the order articles dialog.  Allows the user to
//              sequence multipart articles for decoding.
//

#include "pch.hxx"
#include "storutil.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "resource.h"
#include "shlwapip.h" 
#include "thormsgs.h"
#include "order.h"
#include "error.h"
#include "demand.h"
#include "imsgsite.h"
#include "note.h"
#include "xputil.h"

// NOTE - The drag list control requires us to register a message and use that
//        for notifications sent from the list to the dialog.  This message
//        is defined only for this dialog. -- SteveSer.

static UINT g_mDragList = 0;

#define CND_GETNEXTARTICLE  (WM_USER + 101)
#define CND_OPENNOTE        (WM_USER + 102)
#define CND_MESSAGEAVAIL    (WM_USER + 103)

CCombineAndDecode::CCombineAndDecode()
{
    m_cRef = 1;

    m_hwndParent = NULL;

    m_pTable = NULL;
    m_rgRows = NULL;
    m_cRows = 0;

    m_pszBuffer = NULL;
    m_iItemToMove = -1;

    m_cLinesTotal = 0;
    m_cCurrentLine = 0;
    m_cPrevLine = 0;
    m_dwCurrentArt = 0;
    m_pMsgParts = NULL;
    m_pCancel = 0;
    m_hTimeout = 0;
    m_hwndDlg = 0;
}


CCombineAndDecode::~CCombineAndDecode()
{
    SafeRelease(m_pTable);
    SafeRelease(m_pMsgParts);
    SafeRelease(m_pCancel);
    CallbackCloseTimeout(&m_hTimeout);
}


HRESULT STDMETHODCALLTYPE CCombineAndDecode::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CCombineAndDecode::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CCombineAndDecode::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//  FUNCTION:   CCombineAndDecode::Start()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in] hwndParent
//      [in] pTable
//      [in] rgRows
//      [in] cRows
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CCombineAndDecode::Start(HWND hwndParent, IMessageTable *pTable, 
                                 ROWINDEX *rgRows, DWORD cRows, FOLDERID idFolder)
{
    int nResult = -1;

    TraceCall("CCombineAndDecode::Start");

    // Verify we got everything we needed
    if (!IsWindow(hwndParent) || !pTable || !rgRows || 0 == cRows)
        return (E_INVALIDARG);

    // Keep these for later
    m_hwndParent = hwndParent;
    m_pTable = pTable;
    m_pTable->AddRef();

    m_rgRows = rgRows;
    m_cRows = cRows;

    m_idFolder = idFolder;
    // Create the order dialog and get to work
    nResult = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddOrderMessages), 
                             m_hwndParent, OrderDlgProc, (LPARAM) this);

    // If the user pressed OK, then we go ahead and decode
    if (nResult == IDOK)
    {
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCombineAndDecode), m_hwndParent,
                       CombineDlgProc, (LPARAM) this);
    }

    return (S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OrderDlgProc()
//
//  PURPOSE:    Public callback function for the message ordering dialog proc
//
INT_PTR CALLBACK CCombineAndDecode::OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCombineAndDecode *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CCombineAndDecode *) lParam;
    }
    else
        pThis = (CCombineAndDecode *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->_OrderDlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);

}


//
//  FUNCTION:   CCombineAndDecode::_OrderDlgProc()
//
//  PURPOSE:    Private callback function for the message ordering dialog proc
//
INT_PTR CALLBACK CCombineAndDecode::_OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _Order_OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _Order_OnCommand);
            return (TRUE);
        
        case WM_CLOSE:
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, _Order_OnClose);
            return (TRUE);
        
        default:
            if (uMsg == g_mDragList)
                return (_Order_OnDragList(hwnd, (int) wParam, (DRAGLISTINFO*) lParam));
    }
    
    return (FALSE);
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnInitDialog()
//
//  PURPOSE:    Initializes the order dialog by filling in the message headers.
//
BOOL CCombineAndDecode::_Order_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND        hwndList;
    HDC         hdc;
    SIZE        size;
    int         cx = 0;
    HFONT       hfontOld;
    HFONT       hfont;
    int         cxScrollBar;
    LPMESSAGEINFO pInfo;
    int         iItem;
    LPSTR       pszSubject = NULL;
    CHAR        szNoSubject[CCHMAX_STRINGRES] = "";
   
    CenterDialog(hwnd);

    // Get some drawing information about the ListBox so we can set the scroll
    // bar width correctly later.
    hwndList = GetDlgItem(hwnd, IDC_MESSAGE_LIST);
    hdc = GetDC(hwndList);
    hfont = (HFONT) SendMessage(hwndList, WM_GETFONT, 0, 0L);
    hfontOld = (HFONT) SelectObject(hdc, hfont);
    cxScrollBar = GetSystemMetrics(SM_CXHTHUMB);

    // Fill the listbox with the article subjects
    for (DWORD i = 0; i < m_cRows; i++)
    {
        // Get the message header from the table
        if (SUCCEEDED(m_pTable->GetRow(m_rgRows[i], &pInfo)))
        {
            if(pInfo->pszSubject)
                pszSubject = pInfo->pszSubject;
            else
            {
                LoadString(g_hLocRes, idsEmptySubjectRO, szNoSubject, sizeof(szNoSubject));
                pszSubject = szNoSubject;
            }

            Assert(pszSubject);

            // Figure out which string is widest before inserting
            GetTextExtentPoint32(hdc, pszSubject, lstrlen(pszSubject), &size);
            if (cx < size.cx)
                cx = size.cx;

            // Add the string
            iItem = (int) SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) pszSubject);
            if (LB_ERR != iItem)
                SendMessage(hwndList, LB_SETITEMDATA, iItem, (LPARAM) m_rgRows[i]);

            // Free the memory
            m_pTable->ReleaseRow(pInfo);
        }
    }
    
    // Clean up the GDI objects
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwndList, hdc);
    
    // Make sure there are scroll bars if needed.
    SendMessage(hwndList, LB_SETHORIZONTALEXTENT, cx + cxScrollBar, 0L);
    
    // Make the list box a drag list box
    if (MakeDragList(hwndList))
        g_mDragList = RegisterWindowMessage(DRAGLISTMSGSTRING);
    
    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
    
    return (FALSE);
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnCommand()
//
//  PURPOSE:    Handle the commands generated by the buttons on the dialog.
//
void CCombineAndDecode::_Order_OnCommand(HWND hwnd, int id, HWND hwndCtl, 
                                         UINT codeNotify)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_MESSAGE_LIST);

    switch (id)
    {
        case IDOK:
        {
            // Get the info we need out of the ListBox
            for (DWORD i = 0; i < m_cRows; i++)
            {
                m_rgRows[i] = (ROWINDEX) ListBox_GetItemData(hwndList, i);
            }

            EndDialog(hwnd, 1);
            break;
        }
        
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;
        
        case IDC_MOVE_UP:
        case IDC_MOVE_DOWN:
        {
            LPTSTR  pszBuffer;
            DWORD   cch;
            UINT    index;
            LPARAM  lpData;
        
            // Get the currently selected item
            index = (DWORD) SendMessage(hwndList, LB_GETCURSEL, 0, 0);

            // If nothing is selected the listbox returns LB_ERR
            if (index == LB_ERR)
                return;
        
            // Check the bounds
            if ((id == IDC_MOVE_UP && index == 0) ||
                (id == IDC_MOVE_DOWN && (int) index == (ListBox_GetCount(hwndList) - 1)))
                return;
        
            // Move the item in the listbox
            cch = (DWORD) SendMessage(hwndList, LB_GETTEXTLEN, index, 0L);
            if (!MemAlloc((LPVOID*) &pszBuffer, sizeof(TCHAR) * (cch + 1)))
                return;
        
            // Get the source string and data
            SendMessage(hwndList, LB_GETTEXT, index, (LPARAM) pszBuffer);
            lpData = SendMessage(hwndList, LB_GETITEMDATA, index, 0);

            // Delete the source
            SendMessage(hwndList, LB_DELETESTRING, index, 0L);

            // Insert the new one
            if (id == IDC_MOVE_UP)
                index--;
            else
                index++;

            SendMessage(hwndList, LB_INSERTSTRING, index, (LPARAM) pszBuffer);
            SendMessage(hwndList, LB_SETITEMDATA, index, lpData);
            SendMessage(hwndList, LB_SETCURSEL, index, 0L);

            MemFree(pszBuffer);
            break;
        }
    }
}


//
//  FUNCTION:   Order_OnDragList()
//
//  PURPOSE:    Handles the drag list notifications which reorder the messages.
//
//  PARAMETERS:
//      hwnd    - handle of the parent of the drag list
//      idCtl   - identifer of the drag list sending the notification
//      lpdli   - pointer to a DRAGLISTINFO struct with info about the
//                notification.
//
//  RETURN VALUE:
//      Dependant on the notification.
//
//  COMMENTS:
//      This function uses the SetDlgMsgResult() macro defined in WINDOWSX.H to
//      set the return value for each message since the parent window is a
//      dialog.
//
LRESULT CCombineAndDecode::_Order_OnDragList(HWND hwnd, int idCtl, LPDRAGLISTINFO lpdli)
{
    UINT    iItem;
    UINT    cch;
    
    Assert(((int) m_iItemToMove) >= 0);
    
    switch (lpdli->uNotification)
    {
        // The user has started dragging one of the list control's items
        case DL_BEGINDRAG:
        {
            // Find out which item is being dragged
            m_iItemToMove = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);

            // Allocate a buffer for the string
            Assert(m_pszBuffer == NULL);
            cch = ListBox_GetTextLen(lpdli->hWnd, m_iItemToMove) + 1;
            MemAlloc((LPVOID *) &m_pszBuffer, cch);
            SendMessage(lpdli->hWnd, LB_GETTEXT, m_iItemToMove, (LPARAM) m_pszBuffer);
            m_lpData = SendMessage(lpdli->hWnd, LB_GETITEMDATA, m_iItemToMove, 0);
        
            DOUT("DL_BEGINDRAG: iItem = %d, text = %100s\r\n", m_iItemToMove, m_pszBuffer);
        
            // Draw the insert icon
            DrawInsert(hwnd, lpdli->hWnd, m_iItemToMove);
        
            // Set the return value to allow the drag to contine
            SetDlgMsgResult(hwnd, g_mDragList, TRUE);
            return TRUE;
        }
        
        case DL_CANCELDRAG:
        {
            DOUT("DL_CANCELDRAG\r\n");
            DrawInsert(hwnd, lpdli->hWnd, -1);
            SafeMemFree(m_pszBuffer);
            return 0;   // Return value is ignored
        }
        
        // The user is in the process of dragging, update the position
        // and move the insert icon
        case DL_DRAGGING:
        {
            // Find out where the cursor is now
            iItem = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);
        
            // Dump some debug info
            DOUT("DL_DRAGGING: iItem = %d\r\n", iItem);
        
            // Update the insert icon position
            DrawInsert(hwnd, lpdli->hWnd, iItem);
        
            // If the cursor is over a valid position set the cursor to
            // DL_MOVECURSOR, otherwise use the DL_STOPCURSOR
            if (-1 != iItem)
                SetDlgMsgResult(hwnd, g_mDragList, DL_MOVECURSOR);
            else
                SetDlgMsgResult(hwnd, g_mDragList, DL_STOPCURSOR);
        
            return (LRESULT) TRUE;
        }

        // The user has dropped the item somewhere, if valid update it's
        // position
        case DL_DROPPED:
        {
            // Where are we now.
            iItem = LBItemFromPt(lpdli->hWnd, lpdli->ptCursor, TRUE);
            DOUT("DL_DROPPED: iItem = %d\r\n", iItem);
        
            // If the drop was somewhere valid
            if (iItem != -1)
            {
                // Remove the insert icon
                DrawInsert(hwnd, lpdli->hWnd, -1);
            
                // Move the item in the listbox
                if (m_iItemToMove != iItem)
                {
                    SendMessage(lpdli->hWnd, LB_DELETESTRING, m_iItemToMove, 0L);
                    SendMessage(lpdli->hWnd, LB_INSERTSTRING, iItem, (LPARAM) m_pszBuffer);
                    SendMessage(lpdli->hWnd, LB_SETITEMDATA, iItem, m_lpData);
                    SendMessage(lpdli->hWnd, LB_SETCURSEL, iItem, 0L);
                }
            }
        
            m_iItemToMove = (UINT) -1;
            SafeMemFree(m_pszBuffer);
            m_lpData = -1;

            // Set the return value to reset the cursor
            SetDlgMsgResult(hwnd, g_mDragList, DL_CURSORSET);
            return 0;
        }
    }
    
    return TRUE;
}


//
//  FUNCTION:   CCombineAndDecode::_Order_OnClose()
//
//  PURPOSE:    This get's called when the user clicks on the "x" button in the
//              title bar.
//
void CCombineAndDecode::_Order_OnClose(HWND hwnd)
{
    SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
}



/////////////////////////////////////////////////////////////////////////////
//
// Combine and Decode Progress dialog
//
/////////////////////////////////////////////////////////////////////////////


INT_PTR CALLBACK CCombineAndDecode::CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCombineAndDecode *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CCombineAndDecode *) lParam;
    }
    else
        pThis = (CCombineAndDecode *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->_CombineDlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}

INT_PTR CALLBACK CCombineAndDecode::_CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _Combine_OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _Combine_OnCommand);
            return (TRUE);
        
        case WM_DESTROY:
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, _Combine_OnDestroy);
            return (TRUE);

        case CND_GETNEXTARTICLE:
            _Combine_GetNextArticle(hwnd);
            return (TRUE);

        case CND_OPENNOTE:
            _Combine_OpenNote(hwnd);
            return (TRUE);

        case CND_MESSAGEAVAIL:
            _Combine_OnMsgAvail(m_hwndDlg);
            return (TRUE);
    
    }
    
    return (FALSE);
}



//
//  FUNCTION:   CCombineAndDecode::_Combine_OnInitDialog()
//
//  PURPOSE:    Initializes the progress dialog by figuring out how many lines
//              will be downloaded, etc.  To finish, we post a message to start
//              the first message downloading.
//
BOOL CCombineAndDecode::_Combine_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HRESULT         hr = S_OK;
    LPMESSAGEINFO   pInfo;

    m_hwndDlg = hwnd;

    // Create the CNewsMsgList for Opie's groovy combiner
    hr = MimeOleCreateMessageParts(&m_pMsgParts);
    if (FAILED(hr))
    {
        EndDialog(hwnd, 0);
        return (FALSE);
    }
    
    // Get a sum of the lines we need to download for the total messages
    m_cLinesTotal = 0;
    for (DWORD i = 0; i < m_cRows; i++)
    {
        // Get the message header from the table
        if (SUCCEEDED(m_pTable->GetRow(m_rgRows[i], &pInfo)))
        {
            m_cLinesTotal += pInfo->cbMessage;
            m_pTable->ReleaseRow(pInfo);
        }
    }
    
    // Set the initial state of the progress bar
    SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETRANGE, 0, MAKELONG(0, 100));
    SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETPOS, 0, 0);
    
    // Set up the animation
    if (Animate_Open(GetDlgItem(hwnd, IDC_DOWNLOAD_AVI), MAKEINTRESOURCE(idanDecode)))
    {
        Animate_Play(GetDlgItem(hwnd, IDC_DOWNLOAD_AVI), 0, -1, -1);
    }
    
    // Start the download
    m_dwCurrentArt = 0;
    m_cCurrentLine = 0;
    
    PostMessage(hwnd, CND_GETNEXTARTICLE, 0, 0L);
    
    CenterDialog(hwnd);
    ShowWindow(hwnd, SW_SHOW);

    return (TRUE);
}


//
//  FUNCTION:   CCombineAndDecode::_Combine_OnCommand()
//
//  PURPOSE:    When the user hit's the Cancel button, we in turn tell the store
//              to stop downloading.
//
void CCombineAndDecode::_Combine_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (id == IDCANCEL && m_pCancel)
        m_pCancel->Cancel(CT_CANCEL);
}


void CCombineAndDecode::_Combine_OnDestroy(HWND hwnd)
{

}


//
//  FUNCTION:   CCombineAndDecode::_Combine_GetNextArticle()
//
//  PURPOSE:    Called when we can start downloading another message.  
//
void CCombineAndDecode::_Combine_GetNextArticle(HWND hwnd)
{
    LPMIMEMESSAGE pMsg = NULL;
    LPMESSAGEINFO pInfo;
    TCHAR         szProg[CCHMAX_STRINGRES];
    TCHAR         szBuf[CCHMAX_STRINGRES];
    HRESULT       hr;
    
    if (SUCCEEDED(m_pTable->GetRow(m_rgRows[m_dwCurrentArt], &pInfo)))
    {
        // Set the progress for the current article
        AthLoadString(idsProgDLMessage, szProg, ARRAYSIZE(szProg));
        wsprintf(szBuf, szProg, pInfo->pszSubject);
        SetDlgItemText(hwnd, IDC_GENERAL_TEXT, szBuf);
    
        // Reset the line count
        m_cPrevLine = 0;
    
        // Check to see if the message is cached
        if (!(pInfo->dwFlags & ARF_HASBODY))
        {
            // Request the message
            hr = m_pTable->OpenMessage(m_rgRows[m_dwCurrentArt], 0, &pMsg, (IStoreCallback *) this);
            if (FAILED(hr) && hr != E_PENDING)
            {
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCantCombineNotConnected),
                              0, MB_OK | MB_ICONSTOP);
                EndDialog(m_hwndDlg, 0);
            }
        }
        else
            _Combine_OnMsgAvail(hwnd);
    
        if (pMsg)
            pMsg->Release();

        m_pTable->ReleaseRow(pInfo);
    }
}


//
//  FUNCTION:   CCombineAndDecode::_Combine_OnMsgAvail()
//
//  PURPOSE:    Called once we've finished downloading an article.
//
void CCombineAndDecode::_Combine_OnMsgAvail(HWND hwnd)
{
    LPMIMEMESSAGE   pMsg = NULL;
    DWORD           increment;
    TCHAR           szProg[CCHMAX_STRINGRES];
    HRESULT         hr;
    
    // Mark it read
    m_pTable->Mark(&(m_rgRows[m_dwCurrentArt]), 1, APPLY_CHILDREN, MARK_MESSAGE_READ, (IStoreCallback *) this);
    
    // Get the message now that it's available and add it to the combine list
    if (SUCCEEDED(hr = m_pTable->OpenMessage(m_rgRows[m_dwCurrentArt], 0, &pMsg, (IStoreCallback *) this)))
    {
        // Add this to the pMsgList    
        m_pMsgParts->AddPart(pMsg);
        pMsg->Release();
    }
    
    // Update the progress
    LPMESSAGEINFO pInfo;
    if (SUCCEEDED(m_pTable->GetRow(m_rgRows[m_dwCurrentArt], &pInfo)))
    {
        increment = pInfo->cbMessage - m_cPrevLine;
        m_cCurrentLine += increment;
        m_pTable->ReleaseRow(pInfo);
    }
    
    if (m_cLinesTotal)
    {
        increment = m_cCurrentLine * 100 / m_cLinesTotal;
        SendDlgItemMessage(hwnd, IDC_DOWNLOAD_PROG, PBM_SETPOS, increment, 0);
    }

    // Increment the number of messages we've retrieved
    m_dwCurrentArt++;

    // If there are more to get, go get 'em
    if (m_dwCurrentArt < m_cRows)
    {
        PostMessage(hwnd, CND_GETNEXTARTICLE, 0, 0L);
    }
    else
    {
        PostMessage(hwnd, CND_OPENNOTE, 0, 0);
    }
}

void CCombineAndDecode::_Combine_OpenNote(HWND hwnd)
{
    LPMIMEMESSAGE   pMsgComb;
    LPMIMEMESSAGE   pMsg = NULL;
    DWORD           increment;
    TCHAR           szProg[CCHMAX_STRINGRES];
    HRESULT         hr;
    
    // Update the progress
    AthLoadString(idsProgCombiningMsgs, szProg, ARRAYSIZE(szProg));
    SetDlgItemText(hwnd, IDC_GENERAL_TEXT, szProg);
    SetDlgItemText(hwnd, IDC_SPECIFIC_TEXT, TEXT(""));
    
    // All the articles are downloaded.  Merge the message list
    // and open the note.        
    hr = m_pMsgParts->CombineParts(&pMsgComb);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                      MAKEINTRESOURCEW(idsGenericError), 0, MB_OK | MB_ICONSTOP);
    }
    else
    {
        FOLDERINFO info;
        INIT_MSGSITE_STRUCT initStruct;
        DWORD               dwCreateFlags = 0;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &info)))
        {
            // If this is a find folder, we need to put the account on the message
            if (!!(info.dwFlags & FOLDER_FINDRESULTS))
            {
                FOLDERID id;
                if (SUCCEEDED(m_pTable->GetRowFolderId(*m_rgRows, &id)))
                {
                    FOLDERINFO fiServer = {0};

                    if (SUCCEEDED(GetFolderServer(id, &fiServer)))
                    {
                        HrSetAccount(pMsgComb, fiServer.pszName);
                        g_pStore->FreeRecord(&fiServer);
                    }
                }
            }

            g_pStore->FreeRecord(&info);
        }

        // Initialize note struct
        initStruct.dwInitType = OEMSIT_MSG;
        initStruct.folderID   = m_idFolder;
        initStruct.pMsg       = pMsgComb;

        // Decide whether it is news or mail
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            FOLDERINFO rServer;
            if (SUCCEEDED(GetFolderServer(m_idFolder, &rServer)))
            {
                HrSetAccount(pMsgComb, rServer.pszAccountId);
                g_pStore->FreeRecord(&rServer);
            }

            dwCreateFlags = OENCF_NEWSFIRST;
        }

        // Create and Open Note
        hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwndParent);
        pMsgComb->Release();
    }

    EndDialog(m_hwndDlg, 0);
}

//
//  FUNCTION:   CCombineAndDecode::OnBegin()
//
//  PURPOSE:    Called when the store starts downloading an article.
//
HRESULT CCombineAndDecode::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnProgress()
//
//  PURPOSE:    Called while the messages are downloading to give us some 
//              progress.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    int increment;
    TCHAR szProg[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];

    Assert(m_hwndDlg != NULL);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Connection progress
    if (tyOperation == SOT_CONNECTION_STATUS)
    {
        Assert(dwCurrent < IXP_LAST);

        // Create some lovely status text
        int ids = XPUtil_StatusToString((IXPSTATUS) dwCurrent);
        AthLoadString(ids, szBuf, ARRAYSIZE(szBuf));
        SetDlgItemText(m_hwndDlg, IDC_GENERAL_TEXT, szBuf);
    }

    AthLoadString(idsProgDLGetLines, szProg, ARRAYSIZE(szProg));
    wsprintf(szBuf, szProg, dwCurrent, dwMax);
    SetDlgItemText(m_hwndDlg, IDC_SPECIFIC_TEXT, szBuf);

    increment = dwCurrent - m_cPrevLine;
    m_cCurrentLine += increment;
    m_cPrevLine = dwCurrent;

    if (m_cLinesTotal)
    {
        increment = m_cCurrentLine * 100 / m_cLinesTotal;
        SendDlgItemMessage(m_hwndDlg, IDC_DOWNLOAD_PROG, PBM_SETPOS, increment, 0);
    }

    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnTimeout()
//
//  PURPOSE:    If a timeout occurs, we call through to the default timeout handler.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}


//
//  FUNCTION:   CCombineAndDecode::OnTimeoutResponse()
//
//  PURPOSE:    Called when the user responds to a timeout dialog.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


//
//  FUNCTION:   CCombineAndDecode::CanConnect()
//
//  PURPOSE:    Called if the store needs to connect to download the requested
//              messages.  We just call through to the default handlers.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent, TRUE);
}



//
//  FUNCTION:   CCombineAndDecode::OnLogonPrompt()
//
//  PURPOSE:    If the user needs to logon, we present them with the default
//              logon UI.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}


//
//  FUNCTION:   CCombineAndDecode::OnComplete()
//
//  PURPOSE:    When we finish downloading a message, this get's hit.  We add
//              this message to the list for the combiner and then request the
//              next message.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
        EndDialog(m_hwndDlg, 0);
    }
    else
    {
        if (tyOperation == SOT_GET_MESSAGE)
            PostMessage(m_hwndDlg, CND_MESSAGEAVAIL, 0, 0);
    }
    return(S_OK);
}


//
//  FUNCTION:   CCombineAndDecode::OnPrompt()
//
//  PURPOSE:    Last time I checked, this was SSL related goo.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}


//
//  FUNCTION:   CCombineAndDecode::GetParentWindow()
//
//  PURPOSE:    Called if the store needs to show UI.  We return our dialog
//              window handle.
//
HRESULT STDMETHODCALLTYPE CCombineAndDecode::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}



#if 0
BOOL CALLBACK CombineAndDecodeProg(HWND hwnd, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    PORDERPARAMS    pop = (PORDERPARAMS) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR           szProg[CCHMAX_STRINGRES];
    TCHAR           szBuf[CCHMAX_STRINGRES];
    LPMIMEMESSAGE   pMsg=0;
    DWORD           increment;
    HRESULT         hr;
    
    switch (uMsg)
    {
        case IMC_BODYAVAIL:
        {
            LPMIMEMESSAGE pMsg = NULL;
            BOOL          fCached = FALSE;
            
            Assert(pop->pGroup);
            if (SUCCEEDED(wParam) && SUCCEEDED(pop->pGroup->GetArticle(pop->rgpMsgs[pop->dwCurrentArt], &pMsg, hwnd, &fCached, FALSE, GETMSG_INSECURE)) && fCached)
            {
                Assert(pMsg);
                Order_OnMsgAvail(hwnd, pop, pMsg);
            }
            else
            {
                if ((HRESULT)wParam != hrUserCancel)
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                    MAKEINTRESOURCEW(idsErrNewsCantOpen), 0, MB_OK | MB_ICONSTOP);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
            
            if (pMsg)
                pMsg->Release();
            return (TRUE);
        }
        
        
    }

    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\range.h ===
//
// RANGE.H
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
// 8-96:    Functions added to facilitate finding of "anti" lists 
//

// -*- C -*-
//--------------------------------------------------------------------------------------
//
// Module:       range.h
//
// Description:  Definition of a class to manipulate range lists
//               (e.g. 1-6,7,10-11,19,24,33-40 ...)
//
// Copyright Microsoft Corporation 1995, All Rights Reserved
//
//--------------------------------------------------------------------------------------

#ifndef _RANGE_H
#define _RANGE_H
//
//  Copyright 1992 Software Innovations, Inc
//      All Rights Reserved
//
//  $Source: D:\CLASS\INCLUDE\range.h-v $
//  $Author: martin $
//  $Date: 92/07/15 04:56:38 $
//  $Revision: 1.1 $
//

#define RANGE_ERROR ((ULONG)-1)
#define rlLAST_MESSAGE ((ULONG)-2)

//  a CRangeList is a dynamic array of these...
typedef struct {
    ULONG low;
    ULONG high;
} RangeType;

class CRangeList
{
public:
    CRangeList();
    //CRangeList(CRangeList&);
    ~CRangeList();

    ULONG AddRef(void);
    ULONG Release(void);

    void Clear() { m_numRanges = 0; };
    BOOL IsInRange(const ULONG value) const;    // is `value' in one of the ranges
                                                // in this CRangeList?

    ULONG Min(void) const;    // return the minimum in-range value
    ULONG Max(void) const;    // return the maximum in-range value

    BOOL Save(LPBYTE *const, ULONG *const) const;
    BOOL Load(const LPBYTE, const ULONG);

    // void AddRange(const char *);
                                     // a string in the form "low-high,..."
                                     //  or just "value,..."
    BOOL AddRange(const ULONG low, const ULONG high);
    BOOL AddRange(const ULONG value);
    BOOL AddRange(const RangeType);
    BOOL AddRange(RangeType*, int);
    BOOL AddRange(CRangeList&);

    // void DeleteRange(const char *);
                                     // (same form as for AddRange(char *)
    BOOL DeleteRange(const ULONG low, const ULONG high);
    BOOL DeleteRange(const ULONG value);
    BOOL DeleteRange(const RangeType);
    BOOL DeleteRange(CRangeList&);

    // finds the range "value" is in and returns the min/max of that
    ULONG MinOfRange(const ULONG value) const;
    ULONG MaxOfRange(const ULONG value) const;

    // computes a range of values not in the RangeList
    BOOL HighestAntiRange(RangeType *const rt) const;
    BOOL LowestAntiRange(RangeType *const rt) const;

    // finds the range containing "value" and computes the next range of missing values
    BOOL NextHigherAntiRange(const ULONG value, RangeType *const rt) const;
    BOOL NextLowerAntiRange(const ULONG value, RangeType *const rt) const;


#ifdef DEBUG    
    LPTSTR RangeToString();   // return a string representing the rangelist
    void   DebugOutput(LPTSTR);
#endif

    // next() returns the smallest in-range value greater than `current', or -1
    ULONG Next(const ULONG current) const;
    // prev() returns the largest in-range value less than `current', or -1
    ULONG Prev(const ULONG current) const;

    ULONG Cardinality(void) const;  // return the cardinality of the set of
                                    //    in-range values

private:
    BOOL Expand();
    int  BinarySearch(const ULONG value) const;
    void ShiftLeft(int low, int distance);
    void ShiftRight(int low, int distance);
    void SubsumeDown(int&);
    void SubsumeUpwards(const int);

protected:
    ULONG      m_cRef;              // Ref count
    int        m_numRanges;         // number of ranges in the rangeTable
    int        m_rangeTableSize;    // range table has room for this many ranges
    RangeType *m_rangeTable;        // the array of ranges
};

#endif // _RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\basedisp.h ===
// --------------------------------------------------------------------------------
// basedisp.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __BASEDISP_H
#define __BASEDISP_H

#include "privunk.h"
//class CPrivateUnknown;

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CBaseDisp : 
    public IDispatch,
    public ISupportErrorInfo,
    public CPrivateUnknown
{
protected:
    LPTYPEINFO       m_pTypeInfo;
    LPVOID          *m_pUnkInvoke;

public:

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CBaseDisp(IUnknown *pUnkOuter=NULL);
    virtual ~CBaseDisp();

    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CPrivateUnknown::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // *** ISupportErrorInfo ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);


    virtual HRESULT EnsureTypeLibrary(LPVOID *pUnkInvoke, REFIID riid);

protected:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID *lplpObj);

    virtual HRESULT ReportError(REFCLSID rclsid, LONG ids);

};

#endif // __BASEDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\news\rangetst.h ===
#define idcAddRange                     1000
#define idcDeleteRange                  1001
#define idcIsInRange                    1002
#define idcNextInRange                  1003
#define idcPrevInRange                  1004
#define idcClear                        1005
#define idcInput1                       1006
#define idcInput2                       1007
#define idcResult                       1008
#define idcPrint                        1009

INT_PTR CALLBACK RangeTestDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\folders.cpp ===
/*
 *    f o l d e r s . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Folder' object and 'FolderCollection'
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "folders.h"
#include "instance.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COEFolderCollection::COEFolderCollection() : CBaseDisp()
{
    Assert (g_pInstance);
    m_pEnumChildren = 0;
    CoIncrementInit("COEFolderCollection::COEFolderCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COEFolderCollection::~COEFolderCollection()
{
    Assert (g_pInstance);
    CoDecrementInit("COEFolderCollection::COEFolderCollection", NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//              Constructor that can fail
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::Init(FOLDERID idFolder)
{
    m_idFolder = idFolder;
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEFolderCollection *)this, IID_IOEFolderCollection);
}


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//              Exposes supported interfaces
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return CBaseDisp::PrivateQueryInterface(riid, lplpObj);

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     get_folders
//
//  Synopsis:   
//              Returns the a folder collection, representing
//              the child folders of the current folder collection.
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(m_idFolder, p);
}

//+---------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   
//              returns the number of elements in the collection
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get_length(long *p)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pEnumChildren->Count((ULONG *)p);

exit:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     get__newEnum
//
//  Synopsis:   
//              Returns a folder enumerator
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::get__newEnum(IUnknown **p)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = E_NOTIMPL;

exit:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::item(VARIANT name, VARIANT index, IDispatch **ppdisp)
{
    HRESULT         hr;
    FOLDERID        idFolder;
    IOEFolder       *pFolder=NULL;

    if (!ppdisp)
        return E_INVALIDARG;

    *ppdisp = NULL;

    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    switch(name.vt)
        {
        case VT_BSTR:
            hr = _FindFolder(name.bstrVal, NULL, &idFolder);
            break;

        case VT_I4:
            hr = _FindFolder(NULL, name.lVal, &idFolder);
            break;
        }

    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = CreateOEFolder(idFolder, &pFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    ReleaseObj(pFolder);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::add(BSTR bstrName, IDispatch **ppDisp)
{
    HRESULT         hr;
    
    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = E_NOTIMPL;

exit:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     InterfaceSupportsErrorInfo
//
//  Synopsis:   
//              Override CBaseDisp's method to provide error
//              information
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (IsEqualIID(riid, IID_IOEFolderCollection))
        return S_OK;

    return CBaseDisp::InterfaceSupportsErrorInfo(riid);
}


//+---------------------------------------------------------------
//
//  Member:     _EnsureInit
//
//  Synopsis:   
//              Make sure the folder enumerator is up and running
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::_EnsureInit()
{

    if (g_pStore == NULL)
        return E_UNEXPECTED;

    SafeRelease(m_pEnumChildren);

    return g_pStore->EnumChildren(m_idFolder, TRUE, &m_pEnumChildren);
}




//+---------------------------------------------------------------
//
//  Member:     _FindFolder
//
//  Synopsis:   
//              find a folder by name or index
//
//---------------------------------------------------------------
HRESULT COEFolderCollection::_FindFolder(BSTR bstr, LONG lIndex, FOLDERID *pidFolder)
{
    HRESULT         hr=E_FAIL;
    LONG            c=0;
    FOLDERINFO      fi;
    LPSTR           pszFolder=0;


    *pidFolder = NULL;

    if (bstr)
        pszFolder = PszToANSI(CP_ACP, bstr);

    m_pEnumChildren->Reset();

    hr = m_pEnumChildren->Next(1, &fi, NULL);
    while (hr == S_OK)
    {
        // walk immediate children
        if (bstr)
        {
            if (lstrcmpi(fi.pszName, pszFolder)==0)
            {
                *pidFolder = fi.idFolder;
                break;
            }
        }
        else
        {
            if (lIndex == c++)
            {
                *pidFolder = fi.idFolder;
                break;
            }
        }
        hr = m_pEnumChildren->Next(1, &fi, NULL);
    }

    SafeMemFree(pszFolder);
    return *pidFolder ? S_OK : E_FAIL;
}











//+---------------------------------------------------------------
//
//  Member:     CreateFolderCollection
//
//  Synopsis:   
//              helper function to create an OE Folder Collection
//
//---------------------------------------------------------------
HRESULT CreateFolderCollection(FOLDERID idFolder, IOEFolderCollection **ppFolderCollection)
{
    // Locals
    COEFolderCollection  *pNew=NULL;
    HRESULT     hr=S_OK;

    if (ppFolderCollection == NULL)
        return E_INVALIDARG;

    *ppFolderCollection=NULL;

    pNew = new COEFolderCollection();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(idFolder);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IOEFolderCollection, (LPVOID *)ppFolderCollection);

error:
    ReleaseObj(pNew);
    return hr;
}











HRESULT CreateOEFolder(FOLDERID idFolder, IOEFolder **ppFolder)
{
    COEFolder *pNew;
    HRESULT     hr;

    if (!ppFolder)
        return E_INVALIDARG;

    *ppFolder =NULL;

    pNew = new COEFolder();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(idFolder);
    if (FAILED(hr))
        goto error;

    *ppFolder = pNew;
    pNew = NULL;

error:
    ReleaseObj(pNew);
    return hr;
}


COEFolder::COEFolder() : CBaseDisp()
{
    m_idFolder = FOLDERID_INVALID;
    CoIncrementInit("COEFolder::COEFolder", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEFolder::~COEFolder()
{
    CoDecrementInit("COEFolder::COEFolder", NULL);
}

HRESULT COEFolder::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolder))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolder::Init(FOLDERID idFolder)
{
    HRESULT hr;

    m_idFolder = idFolder;

    hr = _EnsureInit();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEFolder *)this, IID_IOEFolder);

exit:
    return hr;
}

HRESULT COEFolder::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(m_idFolder, p);
}

// *** COEFolder**
HRESULT COEFolder::get_messages(IOEMessageCollection **p)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_name(BSTR *pbstr)
{
    if (pbstr == NULL)
        return E_INVALIDARG;

    *pbstr = NULL;

    return HrLPSZToBSTR(m_fi.pszName, pbstr);
}

HRESULT COEFolder::put_name(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_size(LONG *pl)
{
    *pl = 1000;
    return S_OK;
}

HRESULT COEFolder::get_unread(LONG *pl)
{

    *pl = m_fi.cUnread;
    return S_OK;
}

HRESULT COEFolder::get_id(LONG *pl)
{
    *pl = (LONG)m_fi.idFolder;
    return S_OK;
}

HRESULT COEFolder::get_count(LONG *pl)
{
    *pl = m_fi.cMessages;
    return S_OK;
}


HRESULT COEFolder::_EnsureInit()
{
    return g_pStore->GetFolderInfo(m_idFolder, &m_fi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\folders.h ===
/*
 *    f o l d e r s
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _FOLDERS_H
#define _FOLDERS_H

#include "privunk.h"
#include "basedisp.h"

interface IOEFolderCollection;
interface IOEFolder;

HRESULT CreateInstance_OEFolderCollection(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COEFolderCollection:
    public IOEFolderCollection,
    public CBaseDisp
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CBaseDisp::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CBaseDisp::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CBaseDisp::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection ***
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);
	virtual HRESULT STDMETHODCALLTYPE add(BSTR bstrName, IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);

    // *** Override CBaseDisp ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);

    COEFolderCollection();
    virtual ~COEFolderCollection();

    HRESULT Init(FOLDERID idFolder);

private:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT _EnsureInit();
    HRESULT _FindFolder(BSTR bstr, LONG lIndex, FOLDERID *pidFolder);

    FOLDERID            m_idFolder;
    IEnumerateFolders   *m_pEnumChildren;
};


HRESULT CreateFolderCollection(FOLDERID idFolder, IOEFolderCollection **ppFolderCollection);


class COEFolder:
    public IOEFolder,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolder**
    virtual HRESULT STDMETHODCALLTYPE get_messages(IOEMessageCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_name(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_name(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_size(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_unread(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_count(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_id(LONG *pl);

    COEFolder();
    virtual ~COEFolder();

    HRESULT Init(FOLDERID idFolder);

private:
    ULONG           m_cRef;
    FOLDERID        m_idFolder;
    FOLDERINFO      m_fi;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    HRESULT _EnsureInit();

};


HRESULT CreateOEFolder(FOLDERID idFolder, IOEFolder **ppFolder);

#endif //_FOLDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\basedisp.cpp ===
/*
 *    b a s e d i s p . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "privunk.h"
#include "basedisp.h"
#include "dllmain.h"

CBaseDisp::CBaseDisp(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_pTypeInfo = NULL; 
    m_pUnkInvoke = NULL;
}      

CBaseDisp::~CBaseDisp()
{
    ReleaseObj(m_pTypeInfo);
}

HRESULT CBaseDisp::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
    else
        if (IsEqualIID(riid, IID_ISupportErrorInfo))
            *lplpObj = (LPVOID)(ISupportErrorInfo *)this;
        else
            return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseDisp::InterfaceSupportsErrorInfo(REFIID riid)
{
    return S_FALSE;
}


    // *** IDispatch ***
HRESULT CBaseDisp::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

HRESULT CBaseDisp::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    if (itinfo)
        return DISP_E_BADINDEX;

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;
    return S_OK;
}

HRESULT CBaseDisp::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

HRESULT CBaseDisp::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispInvoke(m_pUnkInvoke, m_pTypeInfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

HRESULT CBaseDisp::EnsureTypeLibrary(LPVOID *pUnkInvoke, REFIID riid)
{
    TCHAR               szDll[MAX_PATH];
    LPWSTR              pszW;
    HRESULT             hr = E_FAIL;

    // BUGBUG: this is weird. I want to defer the type library loading inside OE 
    // until the first MOM object is created. Every MOM object deriving from
    // CBaseDisp must call CBaseDisp::EnsureTypeLibrary. This check to see if the 
    // global ITypeLib object has been created (protected with a CS)

    AssertSz(pUnkInvoke, "You need to pass me a this pointer to callback on");

    EnterCriticalSection(&g_csOETypeLib);

    if (!g_pOETypeLib)
        {
        GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));
        pszW = PszToUnicode(GetACP(), szDll);
        if (pszW)
            {
            LoadTypeLib(pszW, &g_pOETypeLib);
            MemFree(pszW);
            }
        }
    
    if (g_pOETypeLib &&
        g_pOETypeLib->GetTypeInfoOfGuid(riid, &m_pTypeInfo)==S_OK)
        {
        m_pUnkInvoke = pUnkInvoke;
        hr = S_OK;
        }

    LeaveCriticalSection(&g_csOETypeLib);

    return hr;
}



HRESULT CBaseDisp::ReportError(REFCLSID rclsid, LONG ids)
{
    ICreateErrorInfo    *pICEI;
    IErrorInfo          *pErrInfo;
    TCHAR               rgch[CCHMAX_STRINGRES];
    LPWSTR              pszW;

    if (CreateErrorInfo(&pICEI)==S_OK)
        {
        pICEI->SetGUID(rclsid);
        pICEI->SetSource(L"OE Mail Object Model");
        
        if (LoadString(g_hLocRes, ids, rgch, ARRAYSIZE(rgch)))
            {
            pszW = PszToUnicode(GetACP(), rgch);
            if (pszW)
                {
                pICEI->SetDescription(pszW);
                MemFree(pszW);     // CoTaskMemFree
                }
            }
        if (pICEI->QueryInterface(IID_IErrorInfo, (LPVOID *)&pErrInfo)==S_OK)
            {
            SetErrorInfo(0, pErrInfo);
            pErrInfo->Release();
            }
        pICEI->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\message.cpp ===
/*
 *    m e s s a g e . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Message' object and 'MessageCollection'
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "message.h"
#include "instance.h"

void FreeOEMsgData(POEMSGDATA pMsgData);

COEMessageCollection::COEMessageCollection(IUnknown *pUnkOuter) : CBaseDisp()
{
    m_pTable=NULL;
    m_idFolder = FOLDERID_INVALID;

    CoIncrementInit("COEMessageCollection::COEMessageCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMessageCollection::~COEMessageCollection()
{
    ReleaseObj(m_pTable);
    CoDecrementInit("COEMessageCollection::COEMessageCollection", NULL);
}

HRESULT COEMessageCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessageCollection))
        *lplpObj = (LPVOID)(IOEMessageCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
 
HRESULT COEMessageCollection::Init(FOLDERID idFolder)
{
    HRESULT         hr;

    m_idFolder = idFolder;

    // Create a Message Table
//    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER, IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto exit;

    // Tell the table which folder to look at
    hr = m_pTable->Initialize(idFolder, NULL, FALSE, NULL);
    if (FAILED(hr))
        goto exit;
    
    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMessageCollection *)this, IID_IOEMessageCollection);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}

// *** COEMessageCollection **
HRESULT COEMessageCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::get_length(long * pl)
{
    *pl = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pl);

    return S_OK;
}

HRESULT COEMessageCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    if (name.vt == VT_I4)
        return _FindMessageByIndex(name.lVal, ppdisp);

    return E_NOTIMPL;
}


HRESULT COEMessageCollection::_FindMessageByIndex(LONG l, IDispatch** ppdisp)
{
    HRESULT         hr = E_FAIL;
    LPMESSAGEINFO   pmsginfo;
    POEMSGDATA      pMsgData;

    if (m_pTable->GetRow(l, &pmsginfo)==S_OK)
        {
        if (!MemAlloc((LPVOID *)&pMsgData, sizeof(OEMSGDATA)))
            return E_OUTOFMEMORY;
   
        pMsgData->pszSubj = PszDup(pmsginfo->pszSubject);
        pMsgData->pszTo = PszDup(pmsginfo->pszDisplayTo);
        pMsgData->pszCc = PszDup("<not available>");
        pMsgData->pszFrom = PszDup(pmsginfo->pszDisplayFrom);
        pMsgData->ftReceived = pmsginfo->ftReceived;
        pMsgData->msgid = pmsginfo->idMessage;

        //m_pFolder->OpenMessage(msginfo.dwMsgId, FALSE, NULL, &pMsg)==S_OK)

        // OEMessage frees the data object
        hr = CreateOEMessage(NULL, m_idFolder, pMsgData, ppdisp);
        if (FAILED(hr))
            FreeOEMsgData(pMsgData);
        
        }
    return hr;
}

void FreeOEMsgData(POEMSGDATA pMsgData)
{
    if (pMsgData)
        {
        MemFree(pMsgData->pszSubj);
        MemFree(pMsgData->pszTo);
        MemFree(pMsgData->pszCc);
        MemFree(pMsgData->pszFrom);
        MemFree(pMsgData);
        }
}

/*
 *  C O E M e s s a g e
 */

HRESULT CreateOEMessage(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp)
{
    COEMessage *pNew;
    HRESULT     hr;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pMsg, idFolder, pMsgData);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}


COEMessage::COEMessage()
{
    m_cRef=1;
    m_pMsg = NULL;
    m_pMsgData = NULL;
    CoIncrementInit("COEMessage::COEMessage", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMessage::~COEMessage()
{
    FreeOEMsgData(m_pMsgData);
    ReleaseObj(m_pMsg);
    CoDecrementInit("COEMessage::COEMessage", NULL);
}

HRESULT COEMessage::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessage))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEMessage::Init(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData)
{
    m_idFolder = idFolder;
    ReplaceInterface(m_pMsg, pMsg);
    m_pMsgData = pMsgData;
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMessage *)this, IID_IOEMessage);
}

// *** COEMessage **
HRESULT COEMessage::get_subject(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszSubj, pbstr);
        return S_OK;
        }

    if (MimeOleGetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        return S_OK;
        }
    return E_FAIL;
}

HRESULT COEMessage::put_subject(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_to(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszTo, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_to(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();
    
    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_cc(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszCc, pbstr);
        return S_OK;
        }

    *pbstr = NULL;
    if (m_pMsg->GetAddressFormat(IAT_CC, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_cc(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CC), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_sender(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszFrom, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_sender(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_text(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_text(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_html(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_html(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_HTML, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_url(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    // BUGBUGBUG: this is a terrible hack also. We can't get a persistent URL moniker to 
    // the MHTML document (not yet investigated), so for the purpose of this demo-code
    // we'll use a tmp file
    if (m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
        WriteStreamToFile(pstm, "c:\\oe_temp$.eml", CREATE_ALWAYS, GENERIC_WRITE);
        pstm->Release();
        }

    *pbstr = SysAllocString(L"c:\\oe_temp$.eml");
    return S_OK;
}

HRESULT COEMessage::get_date(BSTR *pbstr)
{
    PROPVARIANT     pv;
    TCHAR           rgch[MAX_PATH];
    FILETIME        *pft=0;

    *pbstr = NULL;

    if (!m_pMsg)
        {
        pft = &m_pMsgData->ftReceived;
        }
    else
        {
        // Get Receive Time
        pv.vt = VT_FILETIME;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &pv)))
            pft = &pv.filetime;
        }

    if (pft)
        {
        *rgch=0;
        CchFileTimeToDateTimeSz(pft, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
        HrLPSZToBSTR(rgch, pbstr);
        }
    return S_OK;
}



HRESULT COEMessage::send()
{
/*
    TCHAR   sz[MAX_PATH];

    // use default account to send
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountId(ACCT_MAIL, sz, ARRAYSIZE(sz))))
        {
        PROPVARIANT rUserData;
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = sz;
        m_pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rUserData);
        }

    HrSendMailToOutBox(g_hwndInit, m_pMsg, TRUE, TRUE);
*/
    return E_FAIL;
}



HRESULT COEMessage::BindToMessage()
{
    if (m_pMsg)
        return S_OK; 

    //Assert (m_pFolder && m_pMsgData);
    //return m_pFolder->OpenMessage(m_pMsgData->msgid, NULL, &m_pMsg, NULL);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\oedocs.h ===
/*
 *    o e d o c s . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _OEDOCS_H
#define _OEDOCS_H

#include "basedisp.h"
#include "msoeobj.h"
#include "simpdata.h"
#include "dispex.h"
#include "msdatsrc.h"

interface IMimeMessage;
interface IMessageTable;


class COEMessageCollection;
 
typedef struct OEMSGDATA_tag
{
    LPSTR       pszSubj,
                pszTo,
                pszCc,
                pszFrom;
    MESSAGEID   msgid;
    FILETIME    ftReceived;
} OEMSGDATA, *POEMSGDATA;


class COEFolderCollection:
    public IOEFolderCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEFolderCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEFolderCollection();

    HRESULT Init();

private:
    ULONG   m_cRef;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT FindFolderByName(BSTR bstrName, IDispatch** ppdisp);
    HRESULT FindFolderByIndex(LONG l, IDispatch** ppdisp);

};



class COEFolder:
    public IOEFolder,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolder**
    virtual HRESULT STDMETHODCALLTYPE get_messages(IOEMessageCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_name(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_name(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_size(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_unread(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_count(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE get_id(LONG *pl);

    COEFolder();
    virtual ~COEFolder();

    HRESULT Init(IMessageFolder *pFolder);

private:
    ULONG           m_cRef;
    IMessageFolder *m_pFolder;
    IOEMessageCollection *m_pMessages;
    FOLDERINFO      m_fi;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};


class COEMessageCollection:
    public IOEMessageCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEMessageCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEMessageCollection();

    HRESULT Init(IMessageFolder *pFolder);

private:
    ULONG   m_cRef;
    IMessageFolder *m_pFolder;
    IMessageTable   *m_pTable;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT FindMessageByIndex(LONG l, IDispatch** ppdisp);
};



class COEMessage:
    public IOEMessage,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEMessage**
    virtual HRESULT STDMETHODCALLTYPE get_subject(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_subject(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_to(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_to(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_cc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_cc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_sender(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sender(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_text(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_html(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_date(BSTR *pbstr);

    virtual HRESULT STDMETHODCALLTYPE get_url(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE send();

    COEMessage();
    virtual ~COEMessage();

    HRESULT Init(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData);
    HRESULT BindToMessage();

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    OEMSGDATA       *m_pMsgData;
    IMessageFolder  *m_pFolder;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};



HRESULT CreateInstance_OEMail(IUnknown *pUnkOuter, IUnknown **ppUnknown);

HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown);


class COEMsgTable:
    public OLEDBSimpleProvider,
    public CBaseDisp,
    public IOEMsgList,
    public IDispatchEx
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };
        
    // OLEDBSimpleProvider        
    virtual HRESULT STDMETHODCALLTYPE getRowCount(long *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(long *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(long iRow, long iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar);        
    virtual HRESULT STDMETHODCALLTYPE setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(long iRow, long cRows, long *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(long iRow, long cRows, long *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(long *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer();
        
    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IDispatchEx ***
    virtual HRESULT STDMETHODCALLTYPE GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID(DISPID id);
    virtual HRESULT STDMETHODCALLTYPE GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    virtual HRESULT STDMETHODCALLTYPE GetMemberName(DISPID id, BSTR *pbstrName);
    virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent(IUnknown **ppunk);

    // ** IOEMsgList **
    virtual HRESULT STDMETHODCALLTYPE put_sortColumn(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_sortColumn(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sortDirection(VARIANT_BOOL v);
    virtual HRESULT STDMETHODCALLTYPE get_sortDirection(VARIANT_BOOL *pv);
    virtual HRESULT STDMETHODCALLTYPE test();

    COEMsgTable();
    virtual ~COEMsgTable();

    HRESULT Init();

private:
    ULONG                           m_cRef;
    IMessageTable                   *m_pTable;
    OLEDBSimpleProviderListener     *m_pDSListen;
    DataSourceListener              *m_pDataSrcListener;
    BOOL                            m_fAsc;
    COLUMN_ID                       m_col;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

};

#endif //_OEDOCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\session.cpp ===
/*
 *    s e s s i o n  . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Session' object
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"

#include "session.h"
#include "folders.h"
#include "instance.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COESession::COESession(IUnknown *pUnkOuter) : CBaseDisp(pUnkOuter)
{
    Assert (g_pInstance);
    CoIncrementInit("COESession::COESession", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//              
//
//---------------------------------------------------------------
COESession::~COESession()
{
    Assert (g_pInstance);
    CoDecrementInit("COESession::COESession", NULL);
}

//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//              Constructor that can fail
//
//---------------------------------------------------------------
HRESULT COESession::Init()
{
    return CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOESession *)this, IID_IOESession);
}


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//              Exposes supported interfaces
//
//---------------------------------------------------------------
HRESULT COESession::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOESession *)this;
    else if (IsEqualIID(riid, IID_IOESession))
        *lplpObj = (LPVOID)(IOESession *)this;
    else
        return CBaseDisp::PrivateQueryInterface(riid, lplpObj);

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     get_folders
//
//  Synopsis:   
//              Returns the rootnode folder collection, representing
//              the top-most part of the OE heirarchy.
//
//---------------------------------------------------------------
HRESULT COESession::get_folders(IOEFolderCollection **p)
{
    return CreateFolderCollection(FOLDERID_ROOT, p);
}

//+---------------------------------------------------------------
//
//  Member:     get_version
//
//  Synopsis:   
//              Returns version information for OE.
//
//---------------------------------------------------------------
HRESULT COESession::get_version(BSTR *pbstr)
{
    // BUGBUG: build from OE string and APPVER
    *pbstr = SysAllocString(L"Outlook Express 6.0");
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     createMessage
//
//  Synopsis:   
//              Creates a new message object not associcated with 
//              any folder, until it is saved or sent
//
//---------------------------------------------------------------
HRESULT COESession::createMessage(IOEMessage **ppNewMsg)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     get_inbox
//
//  Synopsis:   
//              Allows fast access to the default inbox folder
//
//---------------------------------------------------------------
HRESULT COESession::get_inbox(IOEFolder **ppFolder)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     openFolder
//
//  Synopsis:   
//              Quick access to a folder by ID
//
//---------------------------------------------------------------
HRESULT COESession::openFolder(LONG idFolder, IOEFolder **ppFolder)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     openMessage
//
//  Synopsis:   
//              Quick access to a message by ID and folder
//
//---------------------------------------------------------------
HRESULT COESession::openMessage(LONG idFolder, LONG idMessage, IOEMessage **ppOEMsg)
{
    ReportError(CLSID_OESession, idsNYITitle);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     InterfaceSupportsErrorInfo
//
//  Synopsis:   
//              Override CBaseDisp's method to provide error
//              information
//
//---------------------------------------------------------------
HRESULT COESession::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (IsEqualIID(riid, IID_IOESession))
        return S_OK;

    return CBaseDisp::InterfaceSupportsErrorInfo(riid);
}




//+---------------------------------------------------------------
//
//  Member:     CreateInstance_OESession
//
//  Synopsis:   
//              Class Factory helper for OE Session object
//
//---------------------------------------------------------------
HRESULT CreateInstance_OESession(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COESession  *pNew=NULL;
    HRESULT     hr=S_OK;

    pNew = new COESession(pUnkOuter);
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init();
    if (FAILED(hr))
        goto error;

    *ppUnknown = (IUnknown *)(IOESession *)pNew;
    pNew=NULL;  // don't release

error:
    ReleaseObj(pNew);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\session.h ===
/*
 *    s e s s i o n. c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM 'Session' object 
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _SESSION_H
#define _SESSION_H

#include "privunk.h"
#include "basedisp.h"

interface IOESession;
interface IOEFolder;
interface IOEMessage;
interface IOEFolderCollection;

HRESULT CreateInstance_OESession(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COESession:
    public IOESession,
    public CBaseDisp
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CBaseDisp::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CBaseDisp::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CBaseDisp::Release(); };

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOESession ***
    virtual HRESULT STDMETHODCALLTYPE get_folders(IOEFolderCollection **p);
    virtual HRESULT STDMETHODCALLTYPE get_version(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE get_inbox(IOEFolder **ppFolder);
    virtual HRESULT STDMETHODCALLTYPE openFolder(LONG idFolder, IOEFolder **ppFolder);
    virtual HRESULT STDMETHODCALLTYPE openMessage(LONG idFolder, LONG idMessage, IOEMessage **ppOEMsg);
    virtual HRESULT STDMETHODCALLTYPE createMessage(IOEMessage **ppNewMsg);

    // *** Override CBaseDisp ***
    virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID riid);

    COESession(IUnknown *pUnkOuter=NULL);
    virtual ~COESession();

    HRESULT Init();

private:
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    IOESession *m_pFolders;
};


#endif //_SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\message.h ===
/*
 *    m e s s a g e 
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MESSAGE_H
#define _MESSAGE_H

#include "privunk.h"
#include "basedisp.h"

interface IOEMessageCollection;
interface IOEMessage;

typedef struct OEMSGDATA_tag
{
    LPSTR       pszSubj,
                pszTo,
                pszCc,
                pszFrom;
    MESSAGEID   msgid;
    FILETIME    ftReceived;
} OEMSGDATA, *POEMSGDATA;

class COEMessageCollection:
    public IOEMessageCollection,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEFolderCollection **
    virtual HRESULT STDMETHODCALLTYPE put_length(long v);
    virtual HRESULT STDMETHODCALLTYPE get_length(long * p);
    virtual HRESULT STDMETHODCALLTYPE get__newEnum(IUnknown **p);
    virtual HRESULT STDMETHODCALLTYPE item(VARIANT name, VARIANT index, IDispatch** pdisp);


    COEMessageCollection(IUnknown *pUnkOuter=NULL);
    virtual ~COEMessageCollection();

    HRESULT COEMessageCollection::Init(FOLDERID idFolder);

private:
    ULONG           m_cRef;
    FOLDERID        m_idFolder;
    IMessageTable   *m_pTable;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT _FindMessageByIndex(LONG l, IDispatch** ppdisp);
};



class COEMessage:
    public IOEMessage,
    public CBaseDisp
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };

    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IOEMessage**
    virtual HRESULT STDMETHODCALLTYPE get_subject(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_subject(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_to(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_to(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_cc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_cc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_sender(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sender(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_text(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_html(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE get_date(BSTR *pbstr);

    virtual HRESULT STDMETHODCALLTYPE get_url(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE send();

    COEMessage();
    virtual ~COEMessage();

    HRESULT Init(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData);
    HRESULT BindToMessage();

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    OEMSGDATA       *m_pMsgData;
    FOLDERID        m_idFolder;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
};

HRESULT CreateOEMessage(IMimeMessage *pMsg, FOLDERID idFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp);

#endif //_MESSAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\oedocs.cpp ===
/*
 *    o e d o c s . c p p
 *    
 *    Purpose:
 *      sample code for demo of OE object model. Implements a very limited
 *      subset of funcitonality
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include <strconst.h>
#include "demand.h"
#include "dllmain.h"
#include "msoert.h"
#include "msoeobj.h"
#include "oedocs.h"


#include "instance.h"
#include "msgfldr.h"
#include "msgtable.h"
#include "mailutil.h"
#include "oleutil.h"
#include "mshtmdid.h"
#include "shlwapi.h"

static ITypeLib    *g_pTypeLib=NULL;

HRESULT CreateOEFolder(IMessageFolder *pFolder, IDispatch **ppdisp);
HRESULT CreateOEMessage(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp);
HRESULT FindFolder(BSTR bstr, LONG lIndex, IMessageFolder **ppFolder);
void FreeOEMsgData(POEMSGDATA pMsgData);
HRESULT EnsureTypeLib();
LPWSTR StringFromColIndex(DWORD dw);
DWORD ColIndexFromString(LPWSTR pszW);

/*
 *  C O E M a i l
 */

COEMail::COEMail(IUnknown *pUnkOuter)
{
    m_cRef=1;
    m_pFolders = NULL;
    CoIncrementInit("COEMail::COEMail", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMail::~COEMail()
{
    ReleaseObj(m_pFolders);
    CoDecrementInit("COEMail::COEMail", NULL);
}

HRESULT COEMail::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMail *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMail))
        *lplpObj = (LPVOID)(IOEMail *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


// *** IOEMail **
HRESULT COEMail::get_folders(IOEFolderCollection **p)
{
    COEFolderCollection *pNew=NULL;
    HRESULT             hr=S_OK;

    if (!m_pFolders)
        {
        pNew = new COEFolderCollection(NULL);
        if (!pNew)
            return E_OUTOFMEMORY;

        hr = pNew->Init();
        if (FAILED(hr))
            goto error;

        m_pFolders = (IOEFolderCollection *)pNew;
        pNew = NULL;    // don't free
        }

    *p = m_pFolders;
    m_pFolders->AddRef();

error:
    ReleaseObj(pNew);
    return hr;
}

HRESULT COEMail::get_version(BSTR *pbstr)
{
    *pbstr = SysAllocString(L"Outlook Express v5.0");
    return S_OK;
}

HRESULT COEMail::get_newMsg(IDispatch **ppDisp)
{
    COEMessage      *pNew=NULL;
    HRESULT         hr;
    IMimeMessage    *pMsg=NULL;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
        goto error;

    hr = pNew->Init(pMsg, NULL, NULL);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppDisp);

error:
    ReleaseObj(pNew);
    ReleaseObj(pMsg);
    return hr;
}


HRESULT COEMail::Init()
{
    return InitBaseDisp((LPVOID *)(IOEMail *)this, IID_IOEMail, g_pTypeLib);
}

HRESULT EnsureTypeLib()
{
    TCHAR               szDll[MAX_PATH];
    LPWSTR              pszW;

    // BUG BUG BUG: hack to get typelib loaded quickly. NOT THREAD SAFE
    if (!g_pTypeLib)
        {
        GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));
        pszW = PszToUnicode(GetACP(), szDll);
        if (pszW)
            {
            LoadTypeLib(pszW, &g_pTypeLib);
            MemFree(pszW);
            }
        }

    if (!g_pTypeLib)
        return E_FAIL;

    // BUG BUG BUG: hack to get typelib loaded quickly. NOT THREAD SAFE
    return S_OK;
}

HRESULT CreateInstance_OEMail(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMail             *pMail=NULL;
    HRESULT             hr=S_OK;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMail = new COEMail(NULL);
    if (!pMail)
        return E_OUTOFMEMORY;

    hr = EnsureTypeLib();
    if (FAILED(hr))
        goto error;

    hr = pMail->Init();
    if (FAILED(hr))
        goto error;

    *ppUnknown = (IUnknown *)(IOEMail *)pMail;
    pMail->AddRef();

error:
    ReleaseObj(pMail);
    return hr;
}



/*
 *  C O E F o l d e r C o l l e c t i o n
 */
COEFolderCollection::COEFolderCollection(IUnknown *pUnkOuter)
{
    m_cRef=1;
    CoIncrementInit("COEFolderCollection::COEFolderCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEFolderCollection::~COEFolderCollection()
{
    CoDecrementInit("COEFolderCollection::COEFolderCollection", NULL);
}

HRESULT COEFolderCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolderCollection::Init()
{
    return InitBaseDisp((LPVOID *)(IOEFolderCollection *)this, IID_IOEFolderCollection, g_pTypeLib);
}

// *** COEFolderCollection **


HRESULT COEFolderCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEFolderCollection::get_length(long * p)
{
    FOLDERINFO      fi;
    *p = 0;

    Assert(g_pStore);

    if (!FAILED(g_pStore->GetFolderInfo(FOLDERID_LOCAL_STORE, &fi)))
        *p = fi.cChildren;

    return S_OK;
}

HRESULT COEFolderCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEFolderCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    switch(name.vt)
        {
        case VT_BSTR:
            return FindFolderByName(name.bstrVal, ppdisp);
        case VT_I4:
            return FindFolderByIndex(name.lVal, ppdisp);
        }
    return E_NOTIMPL;
}


HRESULT COEFolderCollection::FindFolderByName(BSTR bstrName, IDispatch** ppdisp)
{
    HRESULT         hr=E_FAIL;
    IMessageFolder  *pFolder;

    if (FindFolder(bstrName, NULL, &pFolder)==S_OK)
        {
        hr = CreateOEFolder(pFolder, ppdisp);
        pFolder->Release();
        }
    return hr;
}

HRESULT COEFolderCollection::FindFolderByIndex(LONG lIndex, IDispatch **ppdisp)
{
    HRESULT         hr=E_FAIL;
    IMessageFolder  *pFolder;

    *ppdisp=NULL;

    if (FindFolder(NULL, lIndex, &pFolder)==S_OK)
        {
        hr = CreateOEFolder(pFolder, ppdisp);
        pFolder->Release();
        }
    return hr;
}


/*
 *  C O E F o l d e r
 */

HRESULT CreateOEFolder(IMessageFolder *pFolder, IDispatch **ppdisp)
{
    COEFolder *pNew;
    HRESULT     hr;

    pNew = new COEFolder();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pFolder);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);

error:
    ReleaseObj(pNew);
    return hr;
}


COEFolder::COEFolder()
{
    m_cRef=1;
    m_pFolder = NULL;
    m_pMessages=NULL;
    CoIncrementInit("COEFolder::COEFolder", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEFolder::~COEFolder()
{
    ReleaseObj(m_pFolder);
    ReleaseObj(m_pMessages);
    CoDecrementInit("COEFolder::COEFolder", NULL);
}

HRESULT COEFolder::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolder))
        *lplpObj = (LPVOID)(IOEFolder *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEFolder::Init(IMessageFolder *pFolder)
{
    FOLDERID    dwFolder;

    ReplaceInterface(m_pFolder, pFolder);

    if (FAILED(pFolder->GetFolderId(&dwFolder)) ||
        FAILED(g_pStore->GetFolderInfo(dwFolder, &m_fi)))
        return E_FAIL;

    return InitBaseDisp((LPVOID *)(IOEFolder *)this, IID_IOEFolder, g_pTypeLib);
}

// *** COEFolder**
HRESULT COEFolder::get_messages(IOEMessageCollection **p)
{
    COEMessageCollection    *pNew=NULL;
    HRESULT                 hr=S_OK;

    *p = NULL;

    if (!m_pMessages)
        {
        pNew = new COEMessageCollection(NULL);
        if (!pNew)
            return E_OUTOFMEMORY;

        hr = pNew->Init(m_pFolder);
        if (FAILED(hr))
            goto error;

        m_pMessages = (IOEMessageCollection *)pNew;
        pNew = NULL;    // don't free
        } 

    *p = m_pMessages;
    m_pMessages->AddRef();

error:
    ReleaseObj(pNew);
    return S_OK;
}

HRESULT COEFolder::get_name(BSTR *pbstr)
{
    *pbstr = NULL;
    return HrLPSZToBSTR(m_fi.szName, pbstr);
}

HRESULT COEFolder::put_name(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT COEFolder::get_size(LONG *pl)
{
    
    
    *pl = 999;//;m_fi.cbUsed;
    return S_OK;
}

HRESULT COEFolder::get_unread(LONG *pl)
{
    *pl = m_fi.cUnread;
    return S_OK;
}

HRESULT COEFolder::get_id(LONG *pl)
{
    *pl = (LONG)m_fi.idFolder;
    return S_OK;
}

HRESULT COEFolder::get_count(LONG *pl)
{
    *pl = m_fi.cMessages;
    return S_OK;
}

HRESULT FindFolder(BSTR bstr, LONG lIndex, IMessageFolder **ppFolder)
{
    FOLDERID        idFolder=0;
    HRESULT         hr=E_FAIL;
    TCHAR           szFolder[MAX_PATH]; 
    LONG            c=0;
    FOLDERINFO      fi;

    if (bstr)
        WideCharToMultiByte(CP_ACP, 0, (WCHAR*)bstr, -1, szFolder, MAX_PATH, NULL, NULL);

    if (!FAILED(g_pStore->GetFolderInfo(FOLDERID_LOCAL_STORE, &fi)) &&
        !FAILED(g_pStore->GetFolderInfo(fi.idChild, &fi)))
        {
        do
            {
            // walk immediate children
            if (bstr)
                {
                if (lstrcmp(fi.szName, szFolder)==0)
                    {
                    idFolder = fi.idFolder;
                    break;
                    }
                }
            else
                {
                if (lIndex == c++)
                    {
                    idFolder = fi.idFolder;
                    break;
                    }
                }
            }
            while (!FAILED(g_pStore->GetFolderInfo(fi.idSibling, &fi)));
        }

    if (idFolder)
        hr = g_pStore->OpenFolder(idFolder, ppFolder);

    return hr;
}






/*
 *  C O E M e s s a g e C o l l e c t i o n
 */
COEMessageCollection::COEMessageCollection(IUnknown *pUnkOuter)
{
    m_cRef=1;
    m_pFolder=NULL;
    m_pTable=0;
    CoIncrementInit("COEMessageCollection::COEMessageCollection", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

COEMessageCollection::~COEMessageCollection()
{
    ReleaseObj(m_pFolder);
    ReleaseObj(m_pTable);
    CoDecrementInit("COEMessageCollection::COEMessageCollection", NULL);
}

HRESULT COEMessageCollection::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEFolderCollection))
        *lplpObj = (LPVOID)(IOEFolderCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
 
HRESULT COEMessageCollection::Init(IMessageFolder *pFolder)
{
    FOLDERID        idFolder;
    CMessageTable   *pNew=NULL;
    HRESULT         hr;

    if (!pFolder)
        return E_INVALIDARG;

    ReplaceInterface(m_pFolder, pFolder);

    pFolder->GetFolderId(&idFolder);

    pNew = new CMessageTable();
    if (pNew == NULL)
        return E_OUTOFMEMORY;

    hr = pNew->Initialize(idFolder, FALSE);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    hr = InitBaseDisp((LPVOID *)(IOEMessageCollection *)this, IID_IOEMessageCollection, g_pTypeLib);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}

// *** COEMessageCollection **


HRESULT COEMessageCollection::put_length(long v)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::get_length(long * pl)
{
    *pl = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pl);

    return S_OK;
}

HRESULT COEMessageCollection::get__newEnum(IUnknown **p)
{
    return E_NOTIMPL;
}

HRESULT COEMessageCollection::item(VARIANT name, VARIANT index, IDispatch** ppdisp)
{
    if (name.vt == VT_I4)
        return FindMessageByIndex(name.lVal, ppdisp);

    return E_NOTIMPL;
}


HRESULT COEMessageCollection::FindMessageByIndex(LONG l, IDispatch** ppdisp)
{
    HRESULT         hr = E_FAIL;
    MESSAGEINFO     msginfo;
    POEMSGDATA      pMsgData;

    if (m_pTable->GetRow(l, &msginfo)==S_OK)
        {
        if (!MemAlloc((LPVOID *)&pMsgData, sizeof(OEMSGDATA)))
            return E_OUTOFMEMORY;
   
        pMsgData->pszSubj = PszDup(msginfo.pszSubject);
        pMsgData->pszTo = PszDup(msginfo.pszDisplayTo);
        pMsgData->pszCc = PszDup("<not available>");
        pMsgData->pszFrom = PszDup(msginfo.pszDisplayFrom);
        pMsgData->ftReceived = msginfo.ftReceived;
        pMsgData->msgid = msginfo.idMessage;

        //m_pFolder->OpenMessage(msginfo.dwMsgId, FALSE, NULL, &pMsg)==S_OK)

        // OEMessage frees the data object
        hr = CreateOEMessage(NULL, m_pFolder, pMsgData, ppdisp);
        if (FAILED(hr))
            FreeOEMsgData(pMsgData);
        
        }
    return hr;
}

void FreeOEMsgData(POEMSGDATA pMsgData)
{
    if (pMsgData)
        {
        MemFree(pMsgData->pszSubj);
        MemFree(pMsgData->pszTo);
        MemFree(pMsgData->pszCc);
        MemFree(pMsgData->pszFrom);
        MemFree(pMsgData);
        }
}

/*
 *  C O E M e s s a g e
 */

HRESULT CreateOEMessage(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData, IDispatch **ppdisp)
{
    COEMessage *pNew;
    HRESULT     hr;

    pNew = new COEMessage();
    if (!pNew)
        return E_OUTOFMEMORY;

    hr = pNew->Init(pMsg, pFolder, pMsgData);
    if (FAILED(hr))
        goto error;

    hr = pNew->QueryInterface(IID_IDispatch, (LPVOID *)ppdisp);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pNew);
    return hr;
}


COEMessage::COEMessage()
{
    m_cRef=1;
    m_pMsg = NULL;
    m_pMsgData = NULL;
    m_pFolder = NULL;
    CoIncrementInit("COEMessage::COEMessage", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMessage::~COEMessage()
{
    FreeOEMsgData(m_pMsgData);
    ReleaseObj(m_pMsg);
    ReleaseObj(m_pFolder);
    CoDecrementInit("COEMessage::COEMessage", NULL);
}

HRESULT COEMessage::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IOEMessage))
        *lplpObj = (LPVOID)(IOEMessage *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT COEMessage::Init(IMimeMessage *pMsg, IMessageFolder *pFolder, OEMSGDATA *pMsgData)
{
    ReplaceInterface(m_pFolder, pFolder);
    ReplaceInterface(m_pMsg, pMsg);
    m_pMsgData = pMsgData;

    return InitBaseDisp((LPVOID *)(IOEMessage *)this, IID_IOEMessage, g_pTypeLib);
}

// *** COEMessage **


HRESULT COEMessage::get_subject(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszSubj, pbstr);
        return S_OK;
        }

    if (MimeOleGetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        return S_OK;
        }
    return E_FAIL;
}

HRESULT COEMessage::put_subject(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_to(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszTo, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_to(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();
    
    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_cc(BSTR *pbstr)
{
    LPSTR  psz;
    
    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszCc, pbstr);
        return S_OK;
        }

    *pbstr = NULL;
    if (m_pMsg->GetAddressFormat(IAT_CC, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_cc(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CC), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_sender(BSTR *pbstr)
{
    LPSTR  psz;
    
    *pbstr = NULL;

    if (!m_pMsg)
        {
        HrLPSZToBSTR(m_pMsgData->pszFrom, pbstr);
        return S_OK;
        }

    if (m_pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &psz)==S_OK)
        {
        HrLPSZToBSTR(psz, pbstr);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::put_sender(BSTR bstr)
{
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, psz);
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_text(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_text(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    BindToMessage();

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_html(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    if (m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)==S_OK)
        {
        HrIStreamToBSTR(GetACP(), pstm, pbstr);
        pstm->Release();
        return S_OK;
        }

    return E_FAIL;
}

HRESULT COEMessage::put_html(BSTR bstr)
{
    IStream *pstm;
    LPSTR   psz;

    if (HrBSTRToLPSZ(CP_ACP, bstr, &psz)==S_OK)
        {
        if (MimeOleCreateVirtualStream(&pstm)==S_OK)
            {
            pstm->Write(psz, lstrlen(psz), NULL);
            m_pMsg->SetTextBody(TXT_HTML, IET_BINARY, NULL, pstm, NULL);
            pstm->Release();
            }
        MemFree(psz);
        }
    return S_OK;
}

HRESULT COEMessage::get_url(BSTR *pbstr)
{
    IStream *pstm;

    BindToMessage();

    // BUGBUGBUG: this is a terrible hack also. We can't get a persistent URL moniker to 
    // the MHTML document (not yet investigated), so for the purpose of this demo-code
    // we'll use a tmp file
    if (m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
        WriteStreamToFile(pstm, "c:\\oe_temp$.eml", CREATE_ALWAYS, GENERIC_WRITE);
        pstm->Release();
        }

    *pbstr = SysAllocString(L"c:\\oe_temp$.eml");
    return S_OK;
}

HRESULT COEMessage::get_date(BSTR *pbstr)
{
    PROPVARIANT     pv;
    TCHAR           rgch[MAX_PATH];
    FILETIME        *pft=0;

    *pbstr = NULL;

    if (!m_pMsg)
        {
        pft = &m_pMsgData->ftReceived;
        }
    else
        {
        // Get Receive Time
        pv.vt = VT_FILETIME;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &pv)))
            pft = &pv.filetime;
        }

    if (pft)
        {
        *rgch=0;
        CchFileTimeToDateTimeSz(pft, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
        HrLPSZToBSTR(rgch, pbstr);
        }
    return S_OK;
}



HRESULT COEMessage::send()
{
    TCHAR   sz[MAX_PATH];

    // use default account to send
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, sz, ARRAYSIZE(sz))))
        {
        PROPVARIANT rUserData;
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = sz;
        m_pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNT), NOFLAGS, &rUserData);
        }

    HrSendMailToOutBox(g_hwndInit, m_pMsg, TRUE, TRUE);
    return S_OK;
}



HRESULT COEMessage::BindToMessage()
{
    if (m_pMsg)
        return S_OK; 

    Assert (m_pFolder && m_pMsgData);
    return m_pFolder->OpenMessage(m_pMsgData->msgid, NULL, &m_pMsg, NULL);
}






COEMsgTable::COEMsgTable()
{
    m_cRef=1;
    m_pTable=0;
    m_pDSListen=0;
    m_fAsc=TRUE;
    m_col=COLUMN_RECEIVED;
    m_pDataSrcListener=0;
    CoIncrementInit("COEMsgTable::COEMsgTable", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMsgTable::~COEMsgTable()
{
    ReleaseObj(m_pTable);
    ReleaseObj(m_pDSListen);
    ReleaseObj(m_pDataSrcListener);
    CoDecrementInit("COEMsgTable::COEMsgTable", NULL);
}

HRESULT COEMsgTable::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IDispatchEx))
        *lplpObj = (LPVOID)(IDispatchEx *)this;
    else if (IsEqualIID(riid, IID_IOEMsgList))
        *lplpObj = (LPVOID)(IOEMsgList *)this;
    else
        {
        DbgPrintInterface(riid, "COEMsgTable::", 1024);
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

HRESULT COEMsgTable::Init()
{
    FOLDERINFO    fi;
    HRESULT         hr;

    g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fi);

//    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    hr = m_pTable->Initialize(fi.idFolder, FALSE);
    if (FAILED(hr))
        goto error;

    hr = EnsureTypeLib();
    if (FAILED(hr))
        goto error;

    hr = InitBaseDisp((LPVOID *)(IOEMsgList *)this, IID_IOEMsgList, g_pTypeLib);

error:
    return hr;
}


HRESULT COEMsgTable::getRowCount(long *pcRows)
{
    *pcRows = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pcRows);

        
    return S_OK;
}

HRESULT COEMsgTable::getColumnCount(long *pcColumns)
{
    *pcColumns=COLUMN_MAX;
    return S_OK;
}

HRESULT COEMsgTable::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}

HRESULT COEMsgTable::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar)
{
    MESSAGEINFO     msginfo;
    LPSTR           pszData = NULL;
    TCHAR           rgch[MAX_PATH];

    pVar->vt = VT_NULL;

    if (iRow == 0)
        {
        // return headings if row==0
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(StringFromColIndex(iColumn-1));
        return S_OK;
        }

    if (m_pTable->GetRow(iRow-1, &msginfo)==S_OK)
        {
        switch (iColumn-1)
            {
            case COLUMN_MSGID:
                wsprintf(rgch, "%d", msginfo.idMessage);
                pszData = rgch;
                break;

            case COLUMN_SUBJECT:
                pszData = msginfo.pszSubject;
                break;

            case COLUMN_TO:
                pszData = msginfo.pszDisplayTo;
                break;

            case COLUMN_FROM:
                pszData = msginfo.pszDisplayFrom;
                break;

            case COLUMN_RECEIVED:
                pszData = rgch;
                *rgch=0;
                CchFileTimeToDateTimeSz(&msginfo.ftReceived, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
                break;

            default:
                pVar->vt = VT_NULL;
                pVar->lVal = NULL;
                return S_OK;
                
            }
        }
    if (pszData)
        {
        pVar->vt = VT_BSTR;
        HrLPSZToBSTR(pszData, &pVar->bstrVal);
        }
    else
        AssertSz(0, "bad");
    return S_OK;
}

HRESULT COEMsgTable::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::getLocale(BSTR *pbstrLocale)
{
    nyi("DATABINDING::getLocale");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::insertRows(long iRow, long cRows, long *pcRowsInserted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound)
{
    nyi("DATABINDING::find");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    ReplaceInterface(m_pDSListen, pospIListener);

    if (pospIListener)
        pospIListener->transferComplete(OSPXFER_COMPLETE);
    return S_OK;
}

HRESULT COEMsgTable::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    SafeRelease(m_pDSListen);
    return S_OK;
}

HRESULT COEMsgTable::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = FALSE;
    return S_OK;
}

HRESULT COEMsgTable::getEstimatedRows(long *piRows)
{
    return getRowCount(piRows);
}

HRESULT COEMsgTable::stopTransfer()
{
    return S_OK;
}


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMsgTable     *pMsgTable=NULL;
    HRESULT         hr;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMsgTable = new COEMsgTable();
    if (!pMsgTable)
        return E_OUTOFMEMORY;

    hr = pMsgTable->Init();
    if (FAILED(hr))
        goto error;

    hr = pMsgTable->QueryInterface(IID_IUnknown, (LPVOID *)ppUnknown);

error:
    ReleaseObj(pMsgTable);
    return hr;
}


HRESULT COEMsgTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    return DispGetIDsOfNames(m_pTypeInfo, &bstrName, 1, pid);
}

HRESULT COEMsgTable::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    switch (id)
        {
        case DISPID_MSDATASRCINTERFACE:
            pvarRes->vt = VT_UNKNOWN;
            pvarRes->punkVal = (OLEDBSimpleProvider *)this;
            AddRef();
            return S_OK;
        
        case DISPID_ADVISEDATASRCCHANGEEVENT:
            if (pdp->cArgs == 1 && pdp->rgvarg[0].vt == VT_UNKNOWN)
                {
                ReplaceInterface(m_pDataSrcListener, (DataSourceListener *)pdp->rgvarg[0].punkVal);
                return S_OK;
                }
            else
                return E_INVALIDARG;

        default:
            return DispInvoke(m_pUnkInvoke, m_pTypeInfo, id, wFlags, pdp, pvarRes, pei, NULL);
        }
    
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNameSpaceParent(IUnknown **ppunk)
{
    return E_NOTIMPL;
}


HRESULT COEMsgTable::put_sortColumn(BSTR bstr)
{
    FOLDERSORTINFO  fsi={0};

    m_col = (COLUMN_ID)ColIndexFromString(bstr);

    fsi.idSort = m_col;
    fsi.dwFlags = m_fAsc ? SORT_ASCENDING : 0;
    fsi.fForceSort = FALSE;

    if (m_pTable)
        m_pTable->SetSortInfo(&fsi);

    return S_OK;
}

HRESULT COEMsgTable::get_sortColumn(BSTR *pbstr)
{
 
    *pbstr = SysAllocString(StringFromColIndex(m_col));
    return S_OK;
}

HRESULT COEMsgTable::put_sortDirection(VARIANT_BOOL v)
{
    FOLDERSORTINFO  fsi;

    m_fAsc = (v == VARIANT_TRUE);

    fsi.idSort = m_col;
    fsi.dwFlags = m_fAsc ? SORT_ASCENDING : 0;
    fsi.fForceSort = FALSE;

    if (m_pTable)
        m_pTable->SetSortInfo(&fsi);

    return S_OK;
}

HRESULT COEMsgTable::get_sortDirection(VARIANT_BOOL *pv)
{
    *pv = m_fAsc ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

 
HRESULT COEMsgTable::test()
{
    if (m_pDataSrcListener)
        m_pDataSrcListener->dataMemberChanged(NULL);
    return S_OK;
}


static const WCHAR  c_szOESubjW[]       = L"oeSubj",
                    c_szOEToW[]         = L"oeTo",
                    c_szOEFromW[]       = L"oeFrom",
                    c_szOEMsgIdW[]      = L"oeMsgId",
                    c_szOEReceivedW[]   = L"oeDate";

DWORD ColIndexFromString(LPWSTR pszW)
{
    if (StrCmpIW(c_szOESubjW, pszW)==0)
        return COLUMN_SUBJECT;
    else
        if (StrCmpIW(c_szOEToW, pszW)==0)
            return COLUMN_TO;
        else
            if (StrCmpIW(c_szOEReceivedW, pszW)==0)
                return COLUMN_RECEIVED;
            else
                if (StrCmpIW(c_szOEFromW, pszW)==0)
                    return COLUMN_FROM;
                else
                    if (StrCmpIW(c_szOEMsgIdW, pszW)==0)
                        return COLUMN_MSGID;


    return (DWORD)-1;
}
 

LPWSTR StringFromColIndex(DWORD dw)
{
    switch (dw)
        {
        case COLUMN_MSGID:
            return (LPWSTR)c_szOEMsgIdW;

        case COLUMN_SUBJECT:
            return (LPWSTR)c_szOESubjW;

        case COLUMN_TO:
            return (LPWSTR)c_szOEToW;

        case COLUMN_FROM:
            return (LPWSTR)c_szOEFromW;
        
        case COLUMN_RECEIVED:
            return (LPWSTR)c_szOEReceivedW;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\table.cpp ===
/*
 *    t a b l e . c p p
 *    
 *    Purpose:
 *      Implements the OE-MOM DataBinding Table object
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "msoeobj.h"
#include "mshtmdid.h"

#include "table.h"
#include "instance.h"


COEMsgTable::COEMsgTable() : CBaseDisp()
{
    m_pTable=0;
    m_pDSListen=0;
    m_fAsc=TRUE;
    m_col=COLUMN_RECEIVED;
    m_pDataSrcListener=0;
    CoIncrementInit("COEMsgTable::COEMsgTable", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}
 
COEMsgTable::~COEMsgTable()
{
    ReleaseObj(m_pTable);
    ReleaseObj(m_pDSListen);
    ReleaseObj(m_pDataSrcListener);
    CoDecrementInit("COEMsgTable::COEMsgTable", NULL);
}

HRESULT COEMsgTable::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_OLEDBSimpleProvider))
        *lplpObj = (LPVOID)(OLEDBSimpleProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)(CBaseDisp *)this;
    else if (IsEqualIID(riid, IID_IDispatchEx))
        *lplpObj = (LPVOID)(IDispatchEx *)this;
    else if (IsEqualIID(riid, IID_IOEMsgList))
        *lplpObj = (LPVOID)(IOEMsgList *)this;
    else
        {
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

HRESULT COEMsgTable::Init()
{
    FOLDERINFO      fi;
    HRESULT         hr;

    g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fi);

    hr = CoCreateInstance(CLSID_MessageTable, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IMessageTable, (LPVOID *)&m_pTable);
    if (FAILED(hr))
        goto error;

    // Tell the table which folder to look at
    hr = m_pTable->Initialize(fi.idFolder, NULL, FALSE, NULL);
    if (FAILED(hr))
        goto error;

    hr = CBaseDisp::EnsureTypeLibrary((LPVOID *)(IOEMsgList *)this, IID_IOEMsgList);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT COEMsgTable::getRowCount(long *pcRows)
{
    *pcRows = 0;

    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *)pcRows);

        
    return S_OK;
}

HRESULT COEMsgTable::getColumnCount(long *pcColumns)
{
    *pcColumns=COLUMN_MAX;
    return S_OK;
}

HRESULT COEMsgTable::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}

HRESULT COEMsgTable::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar)
{
    LPMESSAGEINFO   pmsginfo;
    LPSTR           pszData = NULL;
    TCHAR           rgch[MAX_PATH];

    pVar->vt = VT_NULL;

    if (iRow == 0)
        {
        // return headings if row==0
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(_PszFromColIndex(iColumn-1));
        return S_OK;
        }

        if (m_pTable->GetRow(iRow-1, &pmsginfo)==S_OK)
        {
        switch (iColumn-1)
            {
            case COLUMN_MSGID:
                wsprintf(rgch, "%d", pmsginfo->idMessage);
                pszData = rgch;
                break;

            case COLUMN_SUBJECT:
                pszData = pmsginfo->pszSubject;
                break;

            case COLUMN_TO:
                pszData = pmsginfo->pszDisplayTo;
                break;

            case COLUMN_FROM:
                pszData = pmsginfo->pszDisplayFrom;
                break;

            case COLUMN_RECEIVED:
                pszData = rgch;
                *rgch=0;
                CchFileTimeToDateTimeSz(&pmsginfo->ftReceived, rgch, sizeof(rgch)/sizeof(TCHAR), DTM_NOSECONDS);
                break;

            default:
                pVar->vt = VT_NULL;
                pVar->lVal = NULL;
                return S_OK;
                
            }
        }
    if (pszData)
        {
        pVar->vt = VT_BSTR;
        HrLPSZToBSTR(pszData, &pVar->bstrVal);
        }
    else
        AssertSz(0, "bad");
    return S_OK;
}

HRESULT COEMsgTable::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::getLocale(BSTR *pbstrLocale)
{
    nyi("DATABINDING::getLocale");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::insertRows(long iRow, long cRows, long *pcRowsInserted)
{
    AssertSz(0, "READONLY Table");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound)
{
    nyi("DATABINDING::find");
    return E_NOTIMPL;
}

HRESULT COEMsgTable::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    ReplaceInterface(m_pDSListen, pospIListener);

    if (pospIListener)
        pospIListener->transferComplete(OSPXFER_COMPLETE);
    return S_OK;
}

HRESULT COEMsgTable::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    SafeRelease(m_pDSListen);
    return S_OK;
}

HRESULT COEMsgTable::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = FALSE;
    return S_OK;
}

HRESULT COEMsgTable::getEstimatedRows(long *piRows)
{
    return getRowCount(piRows);
}

HRESULT COEMsgTable::stopTransfer()
{
    return S_OK;
}


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    COEMsgTable     *pMsgTable=NULL;
    HRESULT         hr;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pMsgTable = new COEMsgTable();
    if (!pMsgTable)
        return E_OUTOFMEMORY;

    hr = pMsgTable->Init();
    if (FAILED(hr))
        goto error;

    hr = pMsgTable->QueryInterface(IID_IUnknown, (LPVOID *)ppUnknown);

error:
    ReleaseObj(pMsgTable);
    return hr;
}


HRESULT COEMsgTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    return DispGetIDsOfNames(m_pTypeInfo, &bstrName, 1, pid);
}

HRESULT COEMsgTable::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    switch (id)
        {
        case DISPID_MSDATASRCINTERFACE:
            pvarRes->vt = VT_UNKNOWN;
            pvarRes->punkVal = (OLEDBSimpleProvider *)this;
            AddRef();
            return S_OK;
        
        case DISPID_ADVISEDATASRCCHANGEEVENT:
            if (pdp->cArgs == 1 && pdp->rgvarg[0].vt == VT_UNKNOWN)
                {
                ReplaceInterface(m_pDataSrcListener, (DataSourceListener *)pdp->rgvarg[0].punkVal);
                return S_OK;
                }
            else
                return E_INVALIDARG;

        default:
            return DispInvoke(m_pUnkInvoke, m_pTypeInfo, id, wFlags, pdp, pvarRes, pei, NULL);
        }
    
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    return E_NOTIMPL;
}

HRESULT COEMsgTable::GetNameSpaceParent(IUnknown **ppunk)
{
    return E_NOTIMPL;
}


HRESULT COEMsgTable::put_sortColumn(BSTR bstr)
{
    return S_OK;
}

HRESULT COEMsgTable::get_sortColumn(BSTR *pbstr)
{
 
    *pbstr = SysAllocString(_PszFromColIndex(m_col));
    return S_OK;
}

HRESULT COEMsgTable::put_sortDirection(VARIANT_BOOL v)
{
    return S_OK;
}

HRESULT COEMsgTable::get_sortDirection(VARIANT_BOOL *pv)
{
    *pv = m_fAsc ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

HRESULT COEMsgTable::test()
{
    if (m_pDataSrcListener)
        m_pDataSrcListener->dataMemberChanged(NULL);
    return S_OK;
}


static const WCHAR  c_szOESubjW[]       = L"oeSubj",
                    c_szOEToW[]         = L"oeTo",
                    c_szOEFromW[]       = L"oeFrom",
                    c_szOEMsgIdW[]      = L"oeMsgId",
                    c_szOEReceivedW[]   = L"oeDate";

DWORD COEMsgTable::_colIndexFromString(LPWSTR pszW)
{
    if (StrCmpIW(c_szOESubjW, pszW)==0)
        return COLUMN_SUBJECT;
    else
        if (StrCmpIW(c_szOEToW, pszW)==0)
            return COLUMN_TO;
        else
            if (StrCmpIW(c_szOEReceivedW, pszW)==0)
                return COLUMN_RECEIVED;
            else
                if (StrCmpIW(c_szOEFromW, pszW)==0)
                    return COLUMN_FROM;
                else
                    if (StrCmpIW(c_szOEMsgIdW, pszW)==0)
                        return COLUMN_MSGID;


    return (DWORD)-1;
}
 

LPWSTR COEMsgTable::_PszFromColIndex(DWORD dw)
{
    switch (dw)
        {
        case COLUMN_MSGID:
            return (LPWSTR)c_szOEMsgIdW;

        case COLUMN_SUBJECT:
            return (LPWSTR)c_szOESubjW;

        case COLUMN_TO:
            return (LPWSTR)c_szOEToW;

        case COLUMN_FROM:
            return (LPWSTR)c_szOEFromW;
        
        case COLUMN_RECEIVED:
            return (LPWSTR)c_szOEReceivedW;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\om\table.h ===
/*
 *    t a b l e . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _TABLE_H
#define _TABLE_H

#include "privunk.h"
#include "basedisp.h"
#include "simpdata.h"
#include "dispex.h"
#include "msdatsrc.h"


HRESULT CreateInstance_OEMsgTable(IUnknown *pUnkOuter, IUnknown **ppUnknown);

class COEMsgTable:
    public OLEDBSimpleProvider,
    public CBaseDisp,
    public IOEMsgList,
    public IDispatchEx
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return PrivateQueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return ++m_cRef; };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { m_cRef--; if (m_cRef == 0) {delete this; return 0;} return m_cRef; };
        
    // OLEDBSimpleProvider        
    virtual HRESULT STDMETHODCALLTYPE getRowCount(long *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(long *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(long iRow, long iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT __RPC_FAR *pVar);        
    virtual HRESULT STDMETHODCALLTYPE setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(long iRow, long cRows, long *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(long iRow, long cRows, long *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(long iRowStart, long iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, long *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(long *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer();
        
    // *** IDispatch)
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo)
        { return CBaseDisp::GetTypeInfoCount(pctinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CBaseDisp::GetTypeInfo(itinfo, lcid, pptinfo); };
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CBaseDisp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); };
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CBaseDisp::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); };

    // *** IDispatchEx ***
    virtual HRESULT STDMETHODCALLTYPE GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID(DISPID id);
    virtual HRESULT STDMETHODCALLTYPE GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    virtual HRESULT STDMETHODCALLTYPE GetMemberName(DISPID id, BSTR *pbstrName);
    virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent(IUnknown **ppunk);

    // ** IOEMsgList **
    virtual HRESULT STDMETHODCALLTYPE put_sortColumn(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_sortColumn(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_sortDirection(VARIANT_BOOL v);
    virtual HRESULT STDMETHODCALLTYPE get_sortDirection(VARIANT_BOOL *pv);
    virtual HRESULT STDMETHODCALLTYPE test();

    COEMsgTable();
    virtual ~COEMsgTable();

    HRESULT Init();

private:
    ULONG                           m_cRef;
    IMessageTable                   *m_pTable;
    OLEDBSimpleProviderListener     *m_pDSListen;
    DataSourceListener              *m_pDataSrcListener;
    BOOL                            m_fAsc;
    COLUMN_ID                       m_col;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    LPWSTR _PszFromColIndex(DWORD dw);
    DWORD _colIndexFromString(LPWSTR pszW);

};

#endif //_TABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\offsync.cpp ===
/*
    File:   offsync.cpp
    Miscellaneous code not in the handler or the enumerator

    Based on sample code from OneStop
*/
#include "pch.hxx"
#include "onestop.h"
#include "multiusr.h"
#include "demand.h"

LPSYNCMGRHANDLERITEMS OHIL_Create()
{
    LPSYNCMGRHANDLERITEMS lpOffline;
    
    if (MemAlloc((LPVOID *)&lpOffline, sizeof(SYNCMGRHANDLERITEMS)))
	{
        lpOffline->cRefs = 0;
        lpOffline->dwNumOfflineItems=NULL;		    
        lpOffline->pFirstOfflineItem=NULL;
        OHIL_AddRef(lpOffline);

		// do any specific itemlist initialization here.
	}

	return lpOffline;
}

DWORD OHIL_AddRef(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
	return ++(lpOfflineItem->cRefs);
}

DWORD OHIL_Release(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
	DWORD cRefs = --lpOfflineItem->cRefs;
    LPSYNCMGRHANDLERITEM lpCurrent, lpDelete;

	if (0 == cRefs)
	{
		lpCurrent = lpOfflineItem->pFirstOfflineItem;
        while (lpCurrent)
        {
            lpDelete = lpCurrent;
            lpCurrent = lpCurrent->pNextOfflineItem;
            MemFree(lpDelete);
        }
        MemFree(lpOfflineItem);
	}

	return cRefs;
}

// allocates space for a new offline and adds it to the list,
// if successfull returns pointer to new item so caller can initialize it. 
LPSYNCMGRHANDLERITEM OHIL_AddItem(LPSYNCMGRHANDLERITEMS pOfflineItemsList)
{
    LPSYNCMGRHANDLERITEM pOfflineItem;
    
	if (MemAlloc((LPVOID *)&pOfflineItem, sizeof(SYNCMGRHANDLERITEM)))
	{
        // Add new node to the front
        pOfflineItem->pNextOfflineItem = pOfflineItemsList->pFirstOfflineItem;
	    pOfflineItemsList->pFirstOfflineItem = pOfflineItem;

	    ++pOfflineItemsList->dwNumOfflineItems;
	}

	return pOfflineItem;
}

// Only called from OE, so assumes OE init of dll vars has occurred
void InvokeSyncMgr(HWND hwnd, ISyncMgrSynchronizeInvoke ** ppSyncMgr, BOOL bPrompt)
{
    HRESULT hr;
    uCLSSPEC ucs;
    static s_fSyncAvail = FALSE;
    DWORD dwDummy=1;
    
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_MobilityFeature;

    // Try to fault in the Mobility pack if it is not around
    if (!s_fSyncAvail && FAILED(hr = FaultInIEFeature(hwnd, &ucs, NULL, FIEF_FLAG_FORCE_JITUI)))
    {
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsJITErrDenied), NULL, MB_OK);
        return;
    }

    AssertSz(S_FALSE != hr, "InvokeSyncMgr: URLMON Thinks that the Offline pack is not an IE feature!");

    // Avoid expensive URLMON call next time
    s_fSyncAvail = TRUE;

    if (!*ppSyncMgr)
    {
        // We've never grabbed the sync mgr invoker before
        if (FAILED(CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISyncMgrSynchronizeInvoke, (LPVOID *)ppSyncMgr)))
        {
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSYNCMGRErr), NULL, MB_OK);
            return;
        }
    }

    // Against all odds, the following call will create a new PROCESS!
    (*ppSyncMgr)->UpdateItems(bPrompt ? 0 : SYNCMGRINVOKE_STARTSYNC, CLSID_OEOneStopHandler, sizeof(dwDummy), (LPCBYTE)&dwDummy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\syncenum.h ===
/*
    File:   SyncEnum.h
    Private Header File for OneStop ENUMERATOR
*/
#ifndef _SYNCENUM_H
#define _SYNCENUM_H

#include <objbase.h>
#include <syncmgr.h>

#include "onestop.h"

class CEnumOfflineItems : public ISyncMgrEnumItems
{
public:
	CEnumOfflineItems(LPSYNCMGRHANDLERITEMS pOfflineItems, DWORD cOffset);
	~CEnumOfflineItems();

	//IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();
	
	//IEnumOfflineItems members
	STDMETHODIMP Next(ULONG celt, LPSYNCMGRITEM rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(ISyncMgrEnumItems **ppenum);

private:
	LONG  m_cRef;
	DWORD m_cOffset;
	LPSYNCMGRHANDLERITEMS m_pOfflineItems; // array of offline items, same format as give to OneStop
	LPSYNCMGRHANDLERITEM  m_pNextItem;
};

typedef CEnumOfflineItems *LPCEnumOfflineItems;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\onestop.h ===
#ifndef _ONESTOP_H
#define _ONESTOP_H
/*
    File: OneStop.h
    Public Header for OE's OneStop Implementation
*/

#include <syncmgr.h>
#include "imnact.h"

// ================================= DATA TYPES
// Base structure for an OfflineHandler item (one line in the listview)
// Specific implementations allocate extra space on the end for their specific data.
typedef struct  _SYNCMGRHANDLERITEM
{
    _SYNCMGRHANDLERITEM *pNextOfflineItem;
    SYNCMGRITEM         offlineItem;
    CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
    CHAR                szAcctName[CCHMAX_ACCOUNT_NAME];
    DWORD               dwUserID;
    ACCTTYPE            accttype;
}  SYNCMGRHANDLERITEM;

typedef SYNCMGRHANDLERITEM *LPSYNCMGRHANDLERITEM;

// structure for keeping track of items as a whole 
typedef struct  _tagSYNCMGRHANDLERITEMS
{
    LONG  cRefs;			            
    DWORD dwNumOfflineItems;		    
    LPSYNCMGRHANDLERITEM pFirstOfflineItem; 
} SYNCMGRHANDLERITEMS;

typedef SYNCMGRHANDLERITEMS *LPSYNCMGRHANDLERITEMS;


// ================================= FUNCTIONS
// Class Factory Entry Point
HRESULT CreateInstance_OneStopHandler(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// OfflineHandlerItemList Manipulation
DWORD                   OHIL_AddRef(LPSYNCMGRHANDLERITEMS lpOfflineItem);
DWORD                   OHIL_Release(LPSYNCMGRHANDLERITEMS lpOfflineItem);
LPSYNCMGRHANDLERITEMS   OHIL_Create();
LPSYNCMGRHANDLERITEM    OHIL_AddItem(LPSYNCMGRHANDLERITEMS pOfflineItemsList);

void InvokeSyncMgr(HWND hwnd, ISyncMgrSynchronizeInvoke ** ppSyncMgr, BOOL bPrompt);

#endif  // _ONESTOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\syncenum.cpp ===
/*
    File:   enum.cpp
    Implementation of OneStop Enumerator

    Based on sample code from OneStop.
*/
#include "pch.hxx"
#include "syncenum.h"

CEnumOfflineItems::CEnumOfflineItems(LPSYNCMGRHANDLERITEMS pOfflineItems, DWORD cOffset):
    m_cRef(1), m_pOfflineItems(pOfflineItems), m_cOffset(cOffset)
{
    DWORD dwItemIndex;
    TraceCall("CEnumOfflineItems::CEnumOfflineItems()");

	OHIL_AddRef(m_pOfflineItems);

	// Set the current item to point to next record.
	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	dwItemIndex = cOffset;
	
	Assert(dwItemIndex <= m_pOfflineItems->dwNumOfflineItems);

	while(dwItemIndex--)
	{
		m_pNextItem = m_pNextItem->pNextOfflineItem;
		++m_cOffset;
	}
}

CEnumOfflineItems::~CEnumOfflineItems()
{
	OHIL_Release(m_pOfflineItems);
}

STDMETHODIMP CEnumOfflineItems::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("CEnumOfflineItems::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_ISyncMgrEnumItems))
        *ppvObj = SAFECAST(this, ISyncMgrEnumItems *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::AddRef()
{
    TraceCall("CEnumOfflineItems::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::Release()
{
    TraceCall("CEnumOfflineItems::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    // OHIL released in destructor
    delete this;
    return 0;
}

STDMETHODIMP CEnumOfflineItems::Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched)
{
    HRESULT hr = NOERROR;
    ULONG ulFetchCount = celt;
    LPSYNCMGRITEM pOfflineItem;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		ulFetchCount = m_pOfflineItems->dwNumOfflineItems - m_cOffset;
		hr = S_FALSE;
	}

	pOfflineItem = rgelt;

	while (ulFetchCount--)
	{
		*pOfflineItem = m_pNextItem->offlineItem;
		m_pNextItem = m_pNextItem->pNextOfflineItem;
		++m_cOffset;
		++pOfflineItem;
	}

	return hr;
}

STDMETHODIMP CEnumOfflineItems::Skip(ULONG celt)
{
    HRESULT hr;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		m_cOffset = m_pOfflineItems->dwNumOfflineItems;
		m_pNextItem = NULL;
		hr = S_FALSE;
	}
	else
	{
		while (celt--)
		{
			++m_cOffset;
			m_pNextItem = m_pNextItem->pNextOfflineItem;
		}

		hr = NOERROR;
	}

	return hr;
}

STDMETHODIMP CEnumOfflineItems::Reset()
{
	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	return NOERROR;
}

STDMETHODIMP CEnumOfflineItems::Clone(ISyncMgrEnumItems **ppenum)
{
    *ppenum = new  CEnumOfflineItems(m_pOfflineItems,m_cOffset);
	return *ppenum ? NOERROR : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\resdummy\makefile.inc ===
ATHENA_RC_DEPENDS = thor.rcv		    \
                    ..\inc\resource.h

$O\mailnews.res : $(ATHENA_RC_DEPENDS)

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\syncprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     syncprop.h
//
//  PURPOSE:    Defines constants for Sync settings prop sheet
//

#ifndef __SYNCPROP_H__
#define __SYNCPROP_H__

#include "grplist2.h"

class CSyncPropDlg:
    public IGroupListAdvise
{
public:    
    // === IUnknown
	STDMETHODIMP		    QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    // === IGroupListAdvise
    STDMETHODIMP            ItemUpdate(void);
    STDMETHODIMP            ItemActivate(FOLDERID id);
    
    // === Constructors, destructors and initialization
    CSyncPropDlg();
    ~CSyncPropDlg();
    BOOL Initialize(HWND hwndOwner, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype);
    void Show();

private:
    static BOOL CALLBACK DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hwnd);

    LONG             m_cRef;

    PROPSHEETPAGE    m_pspage;
    PROPSHEETHEADER  m_pshdr;
    DWORD            m_dwIconID;
    LPSTR            m_pszAcctName;
    CColumns        *m_pColumns;
    CGroupList      *m_pGrpList;
    ACCTTYPE         m_accttype;
    HWND             m_hwndList;
    IF_DEBUG(BOOL    m_fInit;)

};

void ShowPropSheet(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype);

////////////////////////////////////////////////////////////////////////////
// Control IDs for iddSyncSettings

#define idcIcon                                     1001
#define idcAccount                                  1002
#define idcAccountName                              1003
#define idcList                                     1004
#define idcSynchronize                              1005
#define idcMode                                     1006
#define idcDownload                                 1007

#endif // __SYNCPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\syncprop.cpp ===
#include "pch.hxx"
#include "syncprop.h"
#include "imnact.h"
#include "grplist2.h"

static CSyncPropDlg *s_pSyncPropDlg = NULL;

CSyncPropDlg::CSyncPropDlg():
    m_cRef(1), m_pGrpList(NULL), m_pColumns(NULL), m_pszAcctName(NULL)
{
    IF_DEBUG(m_fInit = FALSE;)
}

CSyncPropDlg::~CSyncPropDlg()
{
    // We handed this out, so release it
    SafeRelease(m_pColumns);

    if (m_pGrpList)
        delete m_pGrpList;
    
    if (m_pszAcctName)
        MemFree(m_pszAcctName);
}

STDMETHODIMP CSyncPropDlg::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("CSyncPropDlg::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_IGroupListAdvise))
        *ppvObj = SAFECAST(this, IGroupListAdvise *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CSyncPropDlg::AddRef()
{
    TraceCall("CSyncPropDlg::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSyncPropDlg::Release()
{
    TraceCall("CSyncPropDlg::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSyncPropDlg::ItemUpdate(void)
{
    return S_OK;
}

STDMETHODIMP CSyncPropDlg::ItemActivate(FOLDERID id)
{
    return S_OK;
}

BOOL CSyncPropDlg::Initialize(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype)
{
    Assert(g_hLocRes);
    
    Assert(pszAcctID);
    Assert(pszAcctName);

    if (!(m_pColumns = new CColumns) || !(m_pGrpList = new CGroupList))
        return FALSE;

    ZeroMemory(&m_pspage, sizeof(PROPSHEETPAGE));
    ZeroMemory(&m_pshdr,  sizeof(PROPSHEETHEADER));

    m_accttype = accttype;
    
    if (MemAlloc((LPVOID*) &m_pszAcctName, lstrlen(pszAcctName)+1))
    {
        lstrcpyA(m_pszAcctName, pszAcctName);
    }
    else
        m_pszAcctName = NULL;

    // BUGBUG: Need to get some sync icons here...
    switch (accttype)
    {
    case ACCT_MAIL:
        m_dwIconID = idiMail;
        break;
    case ACCT_NEWS:
        m_dwIconID = idiDLNews;
        break;
    default:
        m_dwIconID = idiPhone;
    }

    m_pspage.dwSize       = sizeof(PROPSHEETPAGE);
    m_pspage.hInstance    = g_hLocRes;
    m_pspage.pszTemplate  = MAKEINTRESOURCE(iddSyncSettings);
    m_pspage.pfnDlgProc   = DlgProc;
        
    m_pshdr.dwSize        = sizeof(PROPSHEETHEADER);
    m_pshdr.dwFlags       = PSH_USEICONID | PSH_PROPSHEETPAGE | PSH_USEPAGELANG;
    m_pshdr.hwndParent    = hwnd;
    m_pshdr.hInstance     = g_hLocRes;
    m_pshdr.pszCaption    = (LPCSTR) m_pszAcctName;
    m_pshdr.nPages        = 1;
    m_pshdr.nStartPage    = 0;
    m_pshdr.ppsp          = &m_pspage;
    m_pshdr.pszIcon       = MAKEINTRESOURCE(m_dwIconID);
 
    IF_DEBUG(m_fInit = TRUE;)

    return TRUE;
}

void CSyncPropDlg::Show()
{
    Assert(m_fInit);

    // Stash our this pointer somewhere where the static dlgproc can access it
    s_pSyncPropDlg = this;

    // Actually show the dlg (modal)
    PropertySheet(&m_pshdr);
}

BOOL CSyncPropDlg::InitDlg(HWND hwnd)
{
    COLUMN_SET_TYPE set;
    m_hwndList = GetDlgItem(hwnd, idcList);
    
    m_pColumns->Initialize(m_hwndList, COLUMN_SET_OFFLINE);
    m_pColumns->ApplyColumns(COLUMN_LOAD_DEFAULT, NULL, 0);

    if (FAILED(m_pGrpList->Initialize((IGroupListAdvise *)this, m_pColumns, m_hwndList, m_accttype, FALSE)))
        return FALSE;

    SendDlgItemMessage (hwnd, idcIcon,        STM_SETICON, (WPARAM)LoadIcon(g_hLocRes, MAKEINTRESOURCE(m_dwIconID)), 0);
    SendDlgItemMessageA(hwnd, idcAccountName, WM_SETTEXT,  0, (LPARAM)m_pszAcctName);
    
    return TRUE;
}

BOOL CALLBACK CSyncPropDlg::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandledRet = TRUE;
    CSyncPropDlg *pThis = (CSyncPropDlg*)GetWindowLong(hwnd, GWL_USERDATA);
    
    switch (msg)
    {
    case WM_INITDIALOG:
        // Let the dlg know which CSyncPropDlg controls it
        Assert(s_pSyncPropDlg);
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)(pThis = s_pSyncPropDlg));
        s_pSyncPropDlg = NULL;
        
        fHandledRet = pThis->InitDlg(hwnd);    
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
        }
        break;

    default:
        return FALSE;

    }

    return fHandledRet;
}

// Normal way to get a sync properties dlg
void ShowPropSheet(HWND hwnd, LPCSTR pszAcctID, LPCSTR pszAcctName, ACCTTYPE accttype)
{
    CSyncPropDlg *pDlg;

    if (pDlg = new CSyncPropDlg())
    {
        if (pDlg->Initialize(hwnd, pszAcctID, pszAcctName, accttype))
            pDlg->Show();
        delete pDlg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\synchndl.h ===
#ifndef _SYNCHNDL_H
#define _SYNCHNDL_H
/*
    File:   Synchndl.h
    Private Header file for Synchronization HANDLER
*/
#include <objbase.h>
#include <syncmgr.h>

#include "onestop.h"
#include "imnact.h"

class COneStopHandler : public ISyncMgrSynchronize
{
public:
    // === IUnknown
	STDMETHODIMP		    QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// === IOfflineSynchronize
	STDMETHODIMP	Initialize          (DWORD dwReserved, DWORD dwSyncFlags, DWORD cbCookie, const BYTE *lpCooke);
	STDMETHODIMP	GetHandlerInfo      (LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
	STDMETHODIMP	EnumSyncMgrItems    (ISyncMgrEnumItems **ppenumOffineItems);
	STDMETHODIMP	GetItemObject       (REFSYNCMGRITEMID ItemID, REFIID riid,void** ppv);
	STDMETHODIMP	ShowProperties      (HWND hwnd, REFSYNCMGRITEMID ItemID);
	STDMETHODIMP	SetProgressCallback (ISyncMgrSynchronizeCallback *lpCallBack);
	STDMETHODIMP	PrepareForSync      (ULONG cbNumItems, SYNCMGRITEMID* pItemIDs, HWND hWndParent, DWORD dwReserved);
	STDMETHODIMP	Synchronize         (HWND hwnd);
	STDMETHODIMP    SetItemStatus       (REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus);
	STDMETHODIMP	ShowError           (HWND hWndParent, REFSYNCMGRERRORID ErrorID, ULONG *pcbNumItems, SYNCMGRITEMID **ppItemIDs);
    
    // === Constructor / Destructor
    COneStopHandler();
    virtual ~COneStopHandler();

    // === Get / Set
	inline LPSYNCMGRHANDLERITEMS GetOfflineItemsHolder() { return m_pOfflineHandlerItems; };
	inline void SetOfflineItemsHolder(LPSYNCMGRHANDLERITEMS pOfflineHandlerItems) 
				{ m_pOfflineHandlerItems = pOfflineHandlerItems; };
	inline LPSYNCMGRSYNCHRONIZECALLBACK GetOfflineSynchronizeCallback() 
					{ return m_pOfflineSynchronizeCallback; };

private:
    LONG                            m_cRef;
	LPSYNCMGRHANDLERITEMS           m_pOfflineHandlerItems;
	LPSYNCMGRSYNCHRONIZECALLBACK    m_pOfflineSynchronizeCallback;
    DWORD                           m_dwSyncFlags;
    BOOL                            m_fInOE:1;
    BOOL                            m_fInit:1;
    DWORD                           m_dwUserID;
};

typedef COneStopHandler *LPCOneStopHandler;

HRESULT SwitchContext(DWORD dwUserID);
HRESULT InitUser(DWORD dwUserID);

#endif // _SYNCHNDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\onestop\synchndl.cpp ===
/*
    PLEASE NOTE!
    OneStop and MultiUser do not get along well.  This code does some hacks to get stuff to work, and
    mobsync should not be invoked from the shell while OE is running.

    Some assumptions:
    There will never be a user 0
*/

/*
    File:   SyncHndl.cpp
    Implementation of OneStop Sync Handler
*/
#include "pch.hxx"
#include "resource.h"
#include "synchndl.h"
#include "syncenum.h"
#include "syncprop.h"
#include "spoolapi.h"
#include "imnact.h"
#include "multiusr.h"
#include "instance.h"

HRESULT CreateInstance_OneStopHandler(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr = S_OK;
    TraceCall("CreateInstance_OneStopHandler");
    
    // We don't support aggregation and our factory knows it
    Assert(NULL == pUnkOuter);

    // Shouldn't be getting bad args from the factory either
    Assert(NULL != ppUnknown);

    *ppUnknown = new COneStopHandler;

    if (NULL == *ppUnknown)
    	hr = E_OUTOFMEMORY;

    return hr;
}

COneStopHandler::COneStopHandler(): 
    m_cRef(1), m_pOfflineHandlerItems(NULL), m_pOfflineSynchronizeCallback(NULL),
    m_dwSyncFlags(0), m_fInOE(FALSE), m_dwUserID(0)
{ 
    Assert(g_pInstance);
    if (SUCCEEDED(CoIncrementInit("COneStopHandler::COneStopHandler", MSOEAPI_START_COMOBJECT, NULL, NULL)))
        m_fInit = 1;
    else
        m_fInit = 0;
}

COneStopHandler::~COneStopHandler()
{ 
    Assert(g_pInstance);

    if (m_pOfflineHandlerItems)
        OHIL_Release(m_pOfflineHandlerItems);

    if(m_fInit)
        g_pInstance->CoDecrementInit("COneStopHandler::COneStopHandler", NULL);
}

STDMETHODIMP COneStopHandler::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceCall("COneStopHandler::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronize))
        *ppvObj = SAFECAST(this, ISyncMgrSynchronize *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) COneStopHandler::AddRef()
{
    TraceCall("COneStopHandler::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COneStopHandler::Release()
{
    TraceCall("COneStopHandler::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    delete this;
    return 0;
}

BOOL CreateOneStopItems(IImnEnumAccounts *pEnum, LPSYNCMGRHANDLERITEMS pOfflineHandlerItems, DWORD dwUserID, HICON *hicn)
{
    BOOL                bAnything   = FALSE;
    IImnAccount         *pAccount   = NULL;
    LPWSTR              pwsz        = NULL;
    SYNCMGRHANDLERITEM  *pItem      = NULL;
    CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
    CHAR                szAcctName[CCHMAX_ACCOUNT_NAME];
    WCHAR               wszItemName[MAX_SYNCMGRITEMNAME];
    DWORD               dwAvail;
    int                 cDiff;
    ACCTTYPE            accttype;
    ULONG               cb;
    HRESULT             hr;

    // Iterate through the accounts
    pEnum->SortByAccountName();
    while(SUCCEEDED(pEnum->GetNext(&pAccount)) && 
          SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID,   szAcctID,   ARRAYSIZE(szAcctID))) &&
          SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcctName, ARRAYSIZE(szAcctName))) )
    {
        if (!(pwsz = PszToUnicode(CP_ACP, szAcctName)))
            break;
        
        // Safe to allocate this item, we have enough info to make the node
        if (pItem = OHIL_AddItem(pOfflineHandlerItems))
        {
            lstrcpyA(pItem->szAcctName, szAcctName);
            lstrcpynW(pItem->offlineItem.wszItemName, pwsz, MAX_SYNCMGRITEMNAME);
            lstrcpyA(pItem->szAcctID, szAcctID);
            
            // Handle the Account GUID
            cb = sizeof(SYNCMGRITEMID);
            if (FAILED(pAccount->GetProp(AP_UNIQUE_ID, (LPBYTE)&(pItem->offlineItem.ItemID), &cb)))
            {
                if (FAILED(CoCreateGuid(&(pItem->offlineItem.ItemID))) ||
                    FAILED(pAccount->SetProp(AP_UNIQUE_ID, (LPBYTE)(&(pItem->offlineItem.ItemID)), sizeof(SYNCMGRITEMID))) ||
                    FAILED(pAccount->SaveChanges()))
                    ZeroMemory(&(pItem->offlineItem.ItemID), sizeof(SYNCMGRITEMID));
            }
            
            // Need to do something with this...
            pItem->offlineItem.wszStatus[0] = 0;
            
            if (SUCCEEDED(pAccount->GetAccountType(&accttype)))
            {
                if (ACCT_MAIL == accttype)
                    pItem->offlineItem.hIcon = hicn[1];
                else
                    pItem->offlineItem.hIcon = hicn[2];

                pItem->accttype = accttype;
            }
            else
            {
                pItem->offlineItem.hIcon = hicn[0];
                pItem->accttype = ACCT_LAST;
            }

            // Default to syncing the server, no folders synced by default
            if (SUCCEEDED(pAccount->GetPropDw(AP_AVAIL_OFFLINE, &dwAvail)))
                pItem->offlineItem.dwItemState = dwAvail ? SYNCMGRITEMSTATE_CHECKED : 0;
            else
                // Default to checked
                pItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

            // Default to not roaming for now...
            pItem->offlineItem.dwFlags = SYNCMGRITEM_HASPROPERTIES;

            pItem->dwUserID = dwUserID;
            
            pItem->offlineItem.cbSize = sizeof(SYNCMGRITEM);
            bAnything = TRUE;
        }
        MemFree(pwsz);
        pAccount->Release();
    }

    return bAnything;
}

STDMETHODIMP COneStopHandler::Initialize(DWORD dwReserved, DWORD dwSyncFlags, 
                                         DWORD cbCookie, BYTE const*lpCookie)
{
    HRESULT             hr          = S_FALSE;
    IImnEnumAccounts    *pEnum      = NULL;
    HKEY                hkey        = NULL;
    HICON               hicn[3]     = {NULL, NULL, NULL};
    DWORD               dwIndex     = 0;
    DWORD               dwItemID    = 0;
    ULONG               ulCount     = 0;
    ULONG               ulTemp      = 0;
    BOOL                bAnything   = FALSE;
    BOOL                fMultiUser;
    TCHAR               szSubKey[80];
    TCHAR               szFullKey[MAX_PATH], szFullKey2[MAX_PATH];
    FILETIME            dummy;
    DWORD               cb;
    DWORD               dwUserID;

    Assert(g_hLocRes);
    Assert(g_pAcctMan);
    
    if (!m_fInit)
        return E_FAIL;

    // Allocate memory for the list
    if (!(m_pOfflineHandlerItems = OHIL_Create()))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Preload the icons for mail and news
    hicn[0] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiMailNews));
    hicn[1] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiMail));
    hicn[2] = LoadIcon(g_hLocRes,   MAKEINTRESOURCE(idiNews));
    
    // Save the flags away - they are good for the life of this sync
    m_dwSyncFlags = dwSyncFlags;

    // Were we invoked by OE with the UserID of the current user?
    if (m_fInOE = (lpCookie && (sizeof(DWORD) == cbCookie)))
    {
        // We only care about the current user
        if (SUCCEEDED(g_pAcctMan->InitUser(NULL, NULL, 0)))
        {
            if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
            {
                GetCurrentUserID(&m_dwUserID);
                CreateOneStopItems(pEnum, m_pOfflineHandlerItems, m_dwUserID, hicn);
                pEnum->Release();
            }
        }

        // Always want to handle if OE called us
        return S_OK;
    }

    // Need to enumerate all users in the current profile

    // Flush any changes
    SaveCurrentUserSettings();

    // Are there even any OE users in this profile to worry about?
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_PROFILE_ROOT, c_szRegLM, NULL, KEY_ENUMERATE_SUB_KEYS, &hkey))
        goto exit;

    hr = E_UNEXPECTED;

    cb = ARRAYSIZE(szSubKey);
    while (ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex++, szSubKey, &cb, 0, NULL, NULL, &dummy))
    {
        cb = ARRAYSIZE(szSubKey);
        
        // Tell Acct Manager where to look
        wsprintf(szFullKey, c_szPathFileFmt, c_szRegLM, szSubKey);
        wsprintf(szFullKey2, c_szPathFileFmt, szFullKey, c_szIAM);
        if (FAILED(g_pAcctMan->InitUser(NULL, szFullKey2, 0)))
            continue;
        
        // Does this user have any relevant accounts?
        if (FAILED(g_pAcctMan->GetAccountCount(ACCT_NEWS, &ulTemp)))
            continue;
        else 
        {    
            ulCount = ulTemp;
            if (FAILED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &ulTemp)))
                continue;
            ulCount += ulTemp;
            
            if (0 == ulCount)
            {
                continue;
            }
        }
        
        if (FAILED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
            continue;

        GetCurrentUserID(&dwUserID);
        bAnything = CreateOneStopItems(pEnum, m_pOfflineHandlerItems, dwUserID, hicn) || bAnything;
        
        pEnum->Release();
        pEnum = NULL;
    }

    RegCloseKey(hkey);
    hkey = NULL;

    // If there is nothing to enumerate, don't worry about this sync event
    if (!bAnything)
    {
        hr = S_FALSE;
        goto exit;
    }

    return S_OK;

exit:
    if (hkey)
        RegCloseKey(hkey);
    if (m_pOfflineHandlerItems)
        OHIL_Release(m_pOfflineHandlerItems);
    SafeRelease(pEnum);
    return hr;
}


STDMETHODIMP COneStopHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    SYNCMGRHANDLERINFO SMHI, *pSMHI;
    TCHAR szName[MAX_SYNCMGRHANDLERNAME];
    LPWSTR pwsz;
    
    if (!ppSyncMgrHandlerInfo)
        return E_INVALIDARG;
    
    *ppSyncMgrHandlerInfo = NULL;
    
    if (LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMailNews)) &&
        LoadString(g_hLocRes, idsAthena, szName, MAX_SYNCMGRHANDLERNAME))
    {
        if (MemAlloc((LPVOID *)&pSMHI, sizeof(SYNCMGRHANDLERINFO)))
        {
#ifdef UNICODE
            lstrcpy(pSMHI->wszHandlerName, szName);
#else
            if (pwsz = PszToUnicode(CP_ACP, szName))
            {
                lstrcpynW(pSMHI->wszHandlerName, pwsz, MAX_SYNCMGRHANDLERNAME);
                MemFree(pwsz);
            }
            else
            {
                MemFree(ppSyncMgrHandlerInfo);
                return E_OUTOFMEMORY;
            }
#endif
            pSMHI->cbSize = sizeof(SYNCMGRHANDLERINFO);
            *ppSyncMgrHandlerInfo = pSMHI;
            return S_OK;
        }
        else
            return E_OUTOFMEMORY;
    }
    else
        return E_UNEXPECTED;
}

STDMETHODIMP COneStopHandler::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{

	if (m_pOfflineHandlerItems)
	{
		*ppenumOffineItems = new CEnumOfflineItems(m_pOfflineHandlerItems, 0);
	}
	else
	{
		*ppenumOffineItems = NULL;
	}

	return *ppenumOffineItems ? NOERROR: E_OUTOFMEMORY;
}


STDMETHODIMP COneStopHandler::GetItemObject(REFSYNCMGRITEMID ItemID, REFIID riid, void** ppv)
{
    // Not implemented in OneStop v1 Spec
    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowProperties(HWND hwnd, REFSYNCMGRITEMID ItemID)
{
    DWORD dwLastUser=0;
    SYNCMGRHANDLERITEM  *pItem;
    BOOL fOkToEdit = TRUE;
    
    // We didn't provide any items, how can OneStop ask us about them?
    if (!m_pOfflineHandlerItems)
        return E_UNEXPECTED;

    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;

    // This is slow, but shouldn't be many accounts...
    while (pItem)
    {
        if (IsEqualGUID(ItemID, pItem->offlineItem.ItemID))
            break;
        else
            pItem = pItem->pNextOfflineItem;
    }
    
    if (pItem)
    {
        if (dwLastUser != pItem->dwUserID)
        {
            if (fOkToEdit = SUCCEEDED(SwitchContext(pItem->dwUserID)))
            {
                dwLastUser = pItem->dwUserID;
            }
        }

        if (fOkToEdit)
            ShowPropSheet(hwnd, pItem->szAcctID, pItem->szAcctName, pItem->accttype);
    }
    else
        // Gave us an ItemID we don't know about!
        return E_INVALIDARG;

	return S_OK;
}


STDMETHODIMP COneStopHandler::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    LPSYNCMGRSYNCHRONIZECALLBACK pCallbackCurrent = m_pOfflineSynchronizeCallback;

	m_pOfflineSynchronizeCallback = lpCallBack;

	if (m_pOfflineSynchronizeCallback)
		m_pOfflineSynchronizeCallback->AddRef();

	if (pCallbackCurrent)
		pCallbackCurrent->Release();

	return NOERROR;
}


STDMETHODIMP COneStopHandler::PrepareForSync(ULONG cbNumItems, SYNCMGRITEMID* pItemIDs, 
                                             HWND hwndParent, DWORD dwReserved)
{
    HRESULT hr;
    SYNCMGRHANDLERITEM  *pItem, *pPrev, *pTemp;
    IImnAccount *pAccount;
    DWORD dwLastUser;

    Assert(g_pAcctMan);

    if (cbNumItems > m_pOfflineHandlerItems->dwNumOfflineItems)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (!m_pOfflineHandlerItems)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (!m_pOfflineSynchronizeCallback)
    {
        hr = E_FAIL;
        goto exit;
    }
    
#if 0
    if (FAILED(hr = g_pSpooler->Init(NULL, FALSE)))
    {
        if (FACILITY_ITF == HRESULT_FACILITY(hr))
            hr = E_FAIL;
        goto exit;
    }
#endif

    if (m_fInOE)
        dwLastUser = m_dwUserID;
    else
        dwLastUser = 0;
    
    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;
    pPrev = NULL;

    // Go through all the servers that we know about
    while (pItem)
    {
        ULONG i=0;
        BOOL fOKToWrite = TRUE;

        // Is current server one that the user asked to sync?
        while (i < cbNumItems)
        {
            if (IsEqualGUID(pItemIDs[i], pItem->offlineItem.ItemID))
                break;
            else
                i++;
        }

        // No match?
        if (cbNumItems == i)
            pItem->offlineItem.dwItemState = 0;
        else
            pItem->offlineItem.dwItemState = 1;

        // Make sure the account manager is looking at the right user
        if (pItem->dwUserID != dwLastUser)
        {
            if (fOKToWrite = SUCCEEDED(InitUser(pItem->dwUserID)))
                dwLastUser = pItem->dwUserID;
        }

        // Only save changes if we know the registry is in sync with the account manager
        if (fOKToWrite)
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pItem->szAcctID, &pAccount)))
            {
                if (SUCCEEDED(pAccount->SetPropDw(AP_AVAIL_OFFLINE, pItem->offlineItem.dwItemState)))
                    pAccount->SaveChanges();
                pAccount->Release();
            }
        }

        // Can we delete this item from the list?
        if (0 == pItem->offlineItem.dwItemState)
        {
            if (pPrev)
                pPrev->pNextOfflineItem = pItem->pNextOfflineItem;
            else
                m_pOfflineHandlerItems->pFirstOfflineItem = pItem->pNextOfflineItem;

            m_pOfflineHandlerItems->dwNumOfflineItems--;

            // Move on to next item
            pTemp = pItem;
            pItem = pItem->pNextOfflineItem;
            MemFree(pTemp);
        }
        else
        {    
            // Move on to next item
            pPrev = pItem;
            pItem = pItem->pNextOfflineItem;
        }

    }

    Assert(m_pOfflineHandlerItems->dwNumOfflineItems == cbNumItems);
    
    hr = S_OK;

exit:
    m_pOfflineSynchronizeCallback->PrepareForSyncCompleted(hr);
    return hr;
}


STDMETHODIMP COneStopHandler::Synchronize(HWND hwndParent)
{
    HRESULT hr;
    SYNCMGRHANDLERITEM  *pItem;
    DWORD dwLastUser;
    
    Assert(g_pSpooler);

    if (!m_pOfflineSynchronizeCallback)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    if (!m_pOfflineHandlerItems)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (m_fInOE)
        dwLastUser = m_dwUserID;
    else
        dwLastUser = 0;

    pItem = m_pOfflineHandlerItems->pFirstOfflineItem;
    while (pItem)
    {
        BOOL fOkToSync = TRUE;

        if (dwLastUser != pItem->dwUserID)
        {
            if (fOkToSync = SUCCEEDED(SwitchContext(pItem->dwUserID)))
                dwLastUser = pItem->dwUserID;
        }

        if (fOkToSync)
            g_pSpooler->StartDelivery(hwndParent, pItem->szAcctID, FOLDERID_INVALID,
                DELIVER_UPDATE_ALL | DELIVER_NODIAL);

        pItem = pItem->pNextOfflineItem;
    }

    hr = S_OK;

exit:
    m_pOfflineSynchronizeCallback->SynchronizeCompleted(hr);
    return hr;
}

STDMETHODIMP COneStopHandler::SetItemStatus(REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus)
{
    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowError(HWND hWndParent, REFSYNCMGRERRORID ErrorID, 
                                        ULONG *pcbNumItems, SYNCMGRITEMID **ppItemIDs)
{
	// Can show any synchronization conflicts. Also gives a chance
	// to display any errors that occured during synchronization
	return E_NOTIMPL;
}

HRESULT SwitchContext(DWORD dwUserID)
{
    HRESULT hr = S_OK;
    char szUsername[CCH_USERNAME_MAX_LENGTH];

    Assert(g_pAcctMan);
    
    if (UserIdToUsername(dwUserID, szUsername, ARRAYSIZE(szUsername)) &&
        SwitchToUser(szUsername, FALSE) )
    {
        // Reinitialize AcctMan
        if (FAILED(hr = g_pAcctMan->InitUser(NULL, NULL, 0)) &&
            FACILITY_ITF == HRESULT_FACILITY(hr) )
            hr = E_FAIL;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT InitUser(DWORD dwUserID)
{
    HRESULT hr = S_OK;
    TCHAR   szFullKey[MAX_PATH], szFullKey2[MAX_PATH];
    TCHAR   szSubKey[80];

    Assert(g_pAcctMan);
    
    wsprintf(szSubKey, "%08lx", dwUserID);

    // Figure out the full path to the Account Info for the current user
    wsprintf(szFullKey, c_szPathFileFmt, c_szRegLM, szSubKey);
    wsprintf(szFullKey2, c_szPathFileFmt, szFullKey, c_szIAM);

    // Point account manager to an OE multiuser
    // Safe even if acct manager was already inited before - will reload accounts
    if (FAILED(hr = (g_pAcctMan->InitUser(NULL, szFullKey, 0))) &&
        (FACILITY_ITF == HRESULT_FACILITY(hr)))
        hr = E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\actions.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Actions.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "actions.h"
#include "storutil.h"
#include "ruleutil.h"

static const int ACT_GROW = 16;

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateActions
//
//  This creates an actions container.
//
//  ppIActions - pointer to return the criteria container
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the IOEActions object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateActions(IOEActions ** ppIActions)
{
    COEActions *    pActions = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppIActions)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIActions = NULL;

    // Create the rules manager object
    pActions = new COEActions;
    if (NULL == pActions)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pActions->QueryInterface(IID_IOEActions, (void **) ppIActions);
    if (FAILED(hr))
    {
        goto exit;
    }

    pActions = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pActions)
    {
        delete pActions;
    }
    
    return hr;
}

COEActions::~COEActions()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    Reset();
}

STDMETHODIMP_(ULONG) COEActions::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COEActions::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COEActions::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEActions))
    {
        *ppvObject = static_cast<IOEActions *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::Reset(void)
{
    HRESULT     hr = S_OK;

    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    RuleUtil_HrFreeActionsItem(m_rgItems, m_cItems);
    SafeMemFree(m_rgItems);
    m_cItems = 0;
    m_cItemsAlloc = 0;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    DWORD       dwState = ACT_STATE_NULL;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init the outgoing param
    *pdwState = ACT_STATE_NULL;
    
    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    // Walk through the actions to figure out the state
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if ((ACT_STATE_NULL == dwState) &&
                ((ACT_TYPE_DELETESERVER ==  m_rgItems[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD ==  m_rgItems[ulIndex].type)))
        {
            dwState = ACT_STATE_SERVER;
        }
        else
        {
            dwState = ACT_STATE_LOCAL;
        }
    }

    // Set the outgoing param
    *pdwState = dwState;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::GetActions(DWORD dwFlags, PACT_ITEM * ppItem, ULONG * pcItem)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming params
    if ((NULL == ppItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the out params
    *ppItem = NULL;
    if (NULL != pcItem)
    {
        *pcItem = 0;
    }
    
    // If we don't have any criteria, then return
    if (0 == m_cItems)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupActionsItem(m_rgItems, m_cItems, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    *ppItem = pItemNew;
    pItemNew = NULL;
    if (NULL != pcItem)
    {
        *pcItem = m_cItems;
    }
    
exit:
    RuleUtil_HrFreeActionsItem(pItemNew, m_cItems);
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COEActions::SetActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // If we have any criteria already, then reset
    if (0 != m_cItems)
    {
        Reset();
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupActionsItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    m_rgItems = pItemNew;
    pItemNew = NULL;
    m_cItems = cItem;
    m_cItemsAlloc = cItem;
    
exit:
    RuleUtil_HrFreeActionsItem(pItemNew, cItem);
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ValidateActions
//
//  This verifies each of the action values
//
//  Returns:    S_OK, if the actions were valid
//              S_FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COEActions::Validate(DWORD dwFlags)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    LPSTR               pszText = NULL;
    FOLDERINFO          Folder={0};
    RULEFOLDERDATA *    prfdData = NULL;

    // If we don't have any actions, then we must be valid
    if (0 == m_cItems)
    {
        hr = S_OK;
        goto exit;
    }

    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        switch(m_rgItems[ulIndex].type)
        {
            // These ones are always valid
            case ACT_TYPE_DELETESERVER:
            case ACT_TYPE_DONTDOWNLOAD:
            case ACT_TYPE_FLAG:
            case ACT_TYPE_READ:
            case ACT_TYPE_MARKDOWNLOAD:
            case ACT_TYPE_DELETE:
            case ACT_TYPE_JUNKMAIL:
            case ACT_TYPE_STOP:
                if (VT_EMPTY != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_HIGHLIGHT:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_WATCH:
            case ACT_TYPE_SHOW:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                if (ACT_DATA_NULL == m_rgItems[ulIndex].propvar.ulVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case ACT_TYPE_COPY:
            case ACT_TYPE_MOVE:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (m_rgItems[ulIndex].propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }        
                else
                    g_pStore->FreeRecord(&Folder);
                break;
                
            case ACT_TYPE_REPLY:
            case ACT_TYPE_NOTIFYSND:
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                Assert(lstrlen(m_rgItems[ulIndex].propvar.pszVal) <= MAX_PATH)
                    if (0xFFFFFFFF == GetFileAttributes(m_rgItems[ulIndex].propvar.pszVal))
                    {
                        hr = S_FALSE;
                        goto exit;
                    }
                    break;
                    
            case ACT_TYPE_FWD:
            {
                LPWSTR  pwszVal = NULL,
                        pwszText = NULL;
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    AssertSz(VT_LPWSTR != m_rgItems[ulIndex].propvar.vt, "We are getting UNICODE here.");
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Update the display string
                pwszVal = PszToUnicode(CP_ACP, m_rgItems[ulIndex].propvar.pszVal);
                if (!pwszVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
                MemFree(pwszText);
                MemFree(pwszVal);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // If either always encrypt or always sign is turned on
                // we can't do anything
                if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            }
                
            default:
                hr = S_FALSE;
                goto exit;
                break;
        }
    }

    // If we got here, the we must be AOK
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

STDMETHODIMP COEActions::AppendActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pItemNew = NULL;

    // Check incoming parameters
    if ((0 != dwFlags) || (NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's init our outgoing parameters
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = 0;
    }

    // Do we have to add more items?
    if (m_cItems == m_cItemsAlloc)
    {
        hr = HrRealloc((LPVOID *) &m_rgItems, sizeof(ACT_ITEM) * (m_cItemsAlloc + ACT_GROW));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(m_rgItems + m_cItemsAlloc, sizeof(ACT_ITEM) * ACT_GROW);
        m_cItemsAlloc += ACT_GROW;
    }

    // Let's duplicate the items that need to be added
    hr = RuleUtil_HrDupActionsItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Let's add them to the criteria array
    CopyMemory(m_rgItems + m_cItems, pItemNew, sizeof(ACT_ITEM) * cItem);
    m_cItems += cItem;
    
    // Set the proper outgoing parameter
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = cItem;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  LoadReg
//
//  This loads in the actions from the registry.  It loads in the actions
//  order from the Order value.  The string contains space delimitied values
//  and each value contains the subkey name for each action.  Each action 
//  is loaded in the order that is contained in the Order value.  The actions
//  are loaded with the Actions Type.  The Actions Value Type is loaded if it exists.
//  If an Action Value Type exists, then the corresponding Action Value is loaded in.
//
//  pszRegPath  - the path to load the actions from
//
//  Returns:    S_OK, if the actions were loaded without problems
//              E_OUTOFMEMORY, if we couldn't allocate memory to hold the actions
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COEActions::LoadReg(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = 0;
    HKEY            hkeyRoot = NULL;
    ULONG           cbData = 0;
    LPSTR           pszOrder = NULL;
    ULONG           cOrder = 0;
    LPSTR           pszWalk = NULL;
    ACT_ITEM *      pItems = NULL;
    LPSTR           pszNext = NULL;
    ULONG           ulOrder = 0;
    HKEY            hkeyAction = NULL;
    ACT_TYPE        typeAct;
    PROPVARIANT     propvar = {0};
    DWORD           dwType = 0;
    BYTE *          pbData = NULL;
    DWORD           dwFlags = ACT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & ACT_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the actions order
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szActionsOrder, NULL, (BYTE **) &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Make sure we actually have something to load
    if ('\0' == *pszOrder)
    {
        AssertSz(FALSE, "The order string for the actions is mis-formatted in the registry");
        hr = E_FAIL;
        goto exit;
    }
    
    // Convert the actions string to a more useful format
    pszWalk = pszOrder;
    cOrder = 1;
    for (pszWalk = StrStr(pszOrder, g_szSpace); NULL != pszWalk; pszWalk = StrStr(pszWalk, g_szSpace))
    {
        // Terminate the order item
        *pszWalk = '\0';
        pszWalk++;
        cOrder++;
    }


    // Allocate the space to hold all the actions
    cbData = cOrder * sizeof(ACT_ITEM);
    hr = HrAlloc((void **) &pItems, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pItems, cbData);
    
    // For each action in the order string
    pszWalk = pszOrder;
    for (ulOrder = 0, pszWalk = pszOrder; ulOrder < cOrder; ulOrder++, pszWalk += lstrlen(pszWalk) + 1)
    {
        // Open up the action reg key
        lErr = RegOpenKeyEx(hkeyRoot, pszWalk, 0, KEY_READ, &hkeyAction);
        if (ERROR_SUCCESS != lErr)
        {
            AssertSz(FALSE, "Part of the criteria is mis-formatted in the registry");
            hr = E_FAIL;
            goto exit;
        }

        // Get the action type
        cbData = sizeof(typeAct);
        lErr = RegQueryValueEx(hkeyAction, c_szActionsType, 0, NULL,
                                        (BYTE *) &(typeAct), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the action flags
        cbData = sizeof(dwFlags);
        lErr = RegQueryValueEx(hkeyAction, c_szActionsFlags, 0, NULL,
                                        (BYTE *) &(dwFlags), &cbData);
        if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
        {
            hr = E_FAIL;
            goto exit;
        }

        // If it didn't exist then assign it to the default
        if (ERROR_FILE_NOT_FOUND == lErr)
        {
            dwFlags = ACT_FLAG_DEFAULT;
        }

        // Does a action value type exist
        lErr = RegQueryValueEx(hkeyAction, c_szActionsValueType, 0, NULL, NULL, &cbData);
        if ((ERROR_SUCCESS == lErr) && (0 != cbData))
        {
            // Load the action value in
            cbData = sizeof(dwType);
            lErr = RegQueryValueEx(hkeyAction, c_szActionsValueType, 0, NULL,
                                            (BYTE *) &dwType, &cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            propvar.vt = (VARTYPE) dwType;
            
            switch (propvar.vt)
            {
                case VT_UI4:
                    // Get the action value
                    cbData = sizeof(propvar.ulVal);
                    lErr = RegQueryValueEx(hkeyAction, c_szActionsValue, 0, NULL,
                        (BYTE * ) &(propvar.ulVal), &cbData);
                    if (ERROR_SUCCESS != lErr)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                    break;
                    
                case VT_LPSTR:
                case VT_BLOB:
                    // Get the criteria value
                    hr = RuleUtil_HrGetRegValue(hkeyAction, c_szActionsValue, NULL, (BYTE **) &pbData, &cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Save the space so we can free it
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    
                    pbData = NULL;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we loading in an invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
        }

        // Save the value into the criteria array
        pItems[ulOrder].type = typeAct;
        pItems[ulOrder].dwFlags = dwFlags;
        pItems[ulOrder].propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
        
        // Close the action
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyAction));
        hkeyAction = NULL;        
    }
    
    // Free up the current actions
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cOrder;

    // Make sure we clear the dirty bit
    m_dwState &= ~ACT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= ACT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pbData);
    PropVariantClear(&propvar);
    RuleUtil_HrFreeActionsItem(pItems, cOrder);
    SafeMemFree(pItems);
    SafeMemFree(pszOrder);
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEActions::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LPSTR       pszOrder = NULL;
    ULONG       ulIndex = 0;
    ACT_ITEM *  pItem = NULL;
    CHAR        rgchTag[CCH_ACT_ORDER];
    HKEY        hkeyAction = NULL;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If there's nothing to save, then fail
    if (NULL == m_rgItems)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
    Assert(m_cItems < ACT_COUNT_MAX);

    // Allocate space to hold the order
    hr = HrAlloc((void **) &pszOrder, m_cItems * CCH_ACT_ORDER * sizeof(*pszOrder));
    if (FAILED(hr))
    {
        goto exit;
    }
    pszOrder[0] = '\0';
    
    // Write out each of the actions
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Get the new action tag
        wsprintf(rgchTag, "%03X", ulIndex);

        // Add the new tag to the order
        if (0 != ulIndex)
        {
            lstrcat(pszOrder, g_szSpace);
        }
        lstrcat(pszOrder, rgchTag);
        
        // Create the new action
        lErr = RegCreateKeyEx(hkeyRoot, rgchTag, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAction, &dwDisp);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        Assert(REG_CREATED_NEW_KEY == dwDisp);
        
        // Write out the action type
        lErr = RegSetValueEx(hkeyAction, c_szActionsType, 0, REG_DWORD,
                                        (BYTE *) &(pItem->type), sizeof(pItem->type));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the action type
        lErr = RegSetValueEx(hkeyAction, c_szActionsFlags, 0, REG_DWORD,
                                        (BYTE *) &(pItem->dwFlags), sizeof(pItem->dwFlags));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Do we have an action value?
        if (VT_EMPTY != pItem->propvar.vt)
        {
            // Write out the criteria value type
            dwDisp = pItem->propvar.vt;
            lErr = RegSetValueEx(hkeyAction, c_szActionsValueType, 0, REG_DWORD, (BYTE *) &dwDisp, sizeof(dwDisp));
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
            
            // Write out the action value
            switch (pItem->propvar.vt)
            {
                case VT_UI4:
                    dwDisp = REG_DWORD;
                    pbData = (BYTE * ) &(pItem->propvar.ulVal);
                    cbData = sizeof(pItem->propvar.ulVal);
                    break;
                    
                case VT_LPSTR:
                    dwDisp = REG_SZ;
                    pbData = (BYTE * ) (pItem->propvar.pszVal);
                    cbData = lstrlen(pItem->propvar.pszVal) + 1;
                    break;
                    
                case VT_BLOB:
                    dwDisp = REG_BINARY;
                    pbData = pItem->propvar.blob.pBlobData;
                    cbData = pItem->propvar.blob.cbSize;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in an invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
            
            // Write out the action value
            lErr = RegSetValueEx(hkeyAction, c_szActionsValue, 0, dwDisp, pbData, cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
        }

        // Close the action
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyAction));
        hkeyAction = NULL;        
    }

    // Write out the order string.
    lErr = RegSetValueEx(hkeyRoot, c_szActionsOrder, 0, REG_SZ,
                                    (BYTE *) pszOrder, lstrlen(pszOrder) + 1);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~ACT_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEActions::Clone(IOEActions ** ppIActions)
{
    HRESULT         hr = S_OK;
    COEActions *    pActions = NULL;
    
    // Check incoming params
    if (NULL == ppIActions)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIActions = NULL;
    
    // Create a new actions
    pActions = new COEActions;
    if (NULL == pActions)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the list of actions
    hr = pActions->SetActions(0, m_rgItems, m_cItems);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions interface
    hr = pActions->QueryInterface(IID_IOEActions, (void **) ppIActions);
    if (FAILED(hr))
    {
        goto exit;
    }

    pActions = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pActions)
    {
        delete pActions;
    }
    return hr;
}

STDMETHODIMP COEActions::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OEActions;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEActions::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (ACT_STATE_DIRTY == (m_dwState & ACT_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COEActions::Load(IStream * pStm)
{
    HRESULT         hr = S_OK;
    ULONG           cbData = 0;
    ULONG           cbRead = 0;
    DWORD           dwData = 0;
    ULONG           cItems = 0;
    ACT_ITEM *      pItems = NULL;
    ULONG           ulIndex = 0;
    ACT_ITEM *      pItem = NULL;
    ACT_TYPE        typeAct;
    PROPVARIANT     propvar = {0};
    BYTE *          pbData = NULL;
    DWORD           dwFlags = ACT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != ACT_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the number of actions
    hr = pStm->Read(&cItems, sizeof(cItems), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(cItems)) || (0 == cItems))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space to hold all the actions
    hr = HrAlloc( (void **) &pItems, cItems * sizeof(*pItems));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the actions to a known value
    ZeroMemory(pItems, cItems * sizeof(*pItems));
    
    // for each action
    for (ulIndex = 0, pItem = pItems; ulIndex < cItems; ulIndex++, pItem++)
    {
        // Read in the action type
        hr = pStm->Read(&typeAct, sizeof(typeAct), &cbRead);
        if (FAILED(hr))
        {
            goto exit;
        }

        if (cbRead != sizeof(typeAct))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the action flags
        hr = pStm->Read(&dwFlags, sizeof(dwFlags), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwFlags)))
        {
            goto exit;
        }

        // Read in the action value type
        hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
        {
            goto exit;
        }

        propvar.vt = (VARTYPE) dwData;
        
        if (VT_EMPTY != propvar.vt)
        {
            // Get the size of the action value
            hr = pStm->Read(&cbData, sizeof(cbData), &cbRead);
            if (FAILED(hr))
            {
                goto exit;
            }

            if (cbRead != sizeof(cbData))
            {
                hr = E_FAIL;
                goto exit;
            }

            // Allocate space to hold the action value data
            switch (propvar.vt)
            {
                case VT_UI4:
                    pbData = (BYTE * ) &(propvar.ulVal);
                    break;
                    
                case VT_BLOB:
                case VT_LPSTR:
                    hr = HrAlloc((void **) &pbData, cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in a invalid action type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }

            // Read in the action value
            hr = pStm->Read(pbData, cbData, &cbRead);
            if (FAILED(hr))
            {
                goto exit;
            }

            if (cbRead != cbData)
            {
                hr = E_FAIL;
                goto exit;
            }

        }

        pItem->type = typeAct;
        pItem->dwFlags = dwFlags;
        pItem->propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
    }

    // Free up the current actions
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cItems;

    // Make sure we clear the dirty bit
    m_dwState &= ~ACT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= ACT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    PropVariantClear(&propvar);
    RuleUtil_HrFreeActionsItem(pItems, cItems);
    SafeMemFree(pItems);
    return hr;
}

STDMETHODIMP COEActions::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    ULONG       cbData = 0;
    ULONG       cbWritten = 0;
    DWORD       dwData = 0;
    ULONG       ulIndex = 0;
    ACT_ITEM *  pItem = NULL;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Write out the version
    dwData = ACT_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the count of actions
    hr = pStm->Write(&m_cItems, sizeof(m_cItems), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(m_cItems));
    
    // Loop through each of the actions
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Write out the action type
        hr = pStm->Write(&(pItem->type), sizeof(pItem->type), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->type));

        // Write out the actions flags
        hr = pStm->Write(&(pItem->dwFlags), sizeof(pItem->dwFlags), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->dwFlags));
        
        // Write out the value type
        dwData = pItem->propvar.vt;
        hr = pStm->Write(&(dwData), sizeof(dwData), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(dwData));
        
        if (VT_EMPTY == pItem->propvar.vt)
        {
            continue;
        }
        
        // Figure out the size of the action value
        switch (pItem->propvar.vt)
        {
            case VT_UI4:
                pbData = (BYTE * ) &(pItem->propvar.ulVal);
                cbData = sizeof(pItem->propvar.ulVal);
                break;
                
            case VT_LPSTR:
                pbData = (BYTE * ) (pItem->propvar.pszVal);
                cbData = lstrlen(pItem->propvar.pszVal) + 1;
                break;
                
            case VT_BLOB:
                pbData = pItem->propvar.blob.pBlobData;
                cbData = pItem->propvar.blob.cbSize;
                break;
                
            default:
                AssertSz(FALSE, "Why are we trying to save in a invalid action type?");
                hr = E_FAIL;
                goto exit;
                break;                
        }
        
        // Write out the action value size
        hr = pStm->Write(&cbData, sizeof(cbData), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(cbData));
        
        // Write out the action value
        hr = pStm->Write(pbData, cbData, &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == cbData);            
    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~ACT_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\actions.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Actions.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ACTIONS_H_
#define _ACTIONS_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

class COEActions : public IOEActions, IPersistStream
{
    private:
        enum {ACT_COUNT_MIN = 0, ACT_COUNT_MAX = 0x1000};

        enum {CCH_ACT_ORDER = 4};
        
        enum {ACT_VERSION = 0x00050000};
        
    private:
        LONG        m_cRef;
        ACT_ITEM *  m_rgItems;
        ULONG       m_cItems;
        ULONG       m_cItemsAlloc;
        DWORD       m_dwState;
        
    public:
        // Constructor/destructor
        COEActions() : m_cRef(0), m_rgItems(NULL), m_cItems(0), m_cItemsAlloc(0), m_dwState(0) {}
        ~COEActions();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEActions members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP GetActions(DWORD dwFlags, PACT_ITEM * ppItem, ULONG * pcItem);
        STDMETHODIMP SetActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem);
        STDMETHODIMP Validate(DWORD dwFlags);
        
        STDMETHODIMP AppendActions(DWORD dwFlags, ACT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended);
        
        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOEActions ** ppIActions);
                                
        // IPersistStream members
        STDMETHODIMP GetClassID(CLSID * pclsid);
        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(IStream * pStm);
        STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }
};

HRESULT HrCreateActions(IOEActions ** ppIActions);
#endif  // !_ACTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\addrrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  AddrRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "addrrule.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateAddrList
//
//  This creates an address list.
//
//  ppIRule - pointer to return the address list
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Address List object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateAddrList(IUnknown * pIUnkOuter, const IID & riid, void ** ppvObject)
{
    COERuleAddrList *   pral = NULL;
    HRESULT             hr = S_OK;

    // Check the incoming params
    if ((NULL == ppvObject) || ((NULL != pIUnkOuter) && (IID_IUnknown != riid)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppvObject = NULL;

    // Create the rules address list object
    pral = new COERuleAddrList;
    if (NULL == pral)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule address list
    hr = pral->HrInit(0, pIUnkOuter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules address list interface
    hr = pral->NondlgQueryInterface(riid, (void **) ppvObject);
    if (FAILED(hr))
    {
        goto exit;
    }

    pral = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pral)
    {
        delete pral;
    }
    
    return hr;
}

VOID FreeRuleAddrList(RULEADDRLIST * pralList, ULONG cralList)
{
    ULONG   ulIndex = 0;
    
    // Check incoming param
    if (NULL == pralList)
    {
        goto exit;
    }
    
    for (ulIndex = 0; ulIndex < cralList; ulIndex++, pralList++)
    {
        SafeMemFree(pralList->pszAddr);
        pralList->dwFlags = 0;
    }

exit:
    return;
}

HRESULT _HrLoadExcptFromReg(HKEY hkeyRoot, LPSTR pszKeyname, RULEADDRLIST * pralItem)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyItem = NULL;
    DWORD       dwFlags = 0;
    ULONG       cbData = 0;
    LPSTR       pszExcpt = NULL;

    Assert(NULL != hkeyRoot);
    Assert(NULL != pszKeyname);
    Assert(NULL != pralItem);

    // Open up the entry
    lErr = RegOpenKeyEx(hkeyRoot, pszKeyname, 0, KEY_READ, &hkeyItem);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Get the flags
    cbData = sizeof(dwFlags);
    lErr = RegQueryValueEx(hkeyItem, c_szExcptFlags, NULL, NULL, (BYTE *) &dwFlags, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Get the size of the exception
    lErr = RegQueryValueEx(hkeyItem, c_szException, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Allocate space to hold the exception
    hr = HrAlloc((VOID **) &pszExcpt, cbData * sizeof(*pszExcpt));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the exception
    lErr = RegQueryValueEx(hkeyItem, c_szException, NULL, NULL, (BYTE *) pszExcpt, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Verify the values
    if (('\0' == pszExcpt[0]) || ((0 == (dwFlags & RALF_MAIL)) && (0 == (dwFlags & RALF_NEWS))))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the values into the item
    pralItem->dwFlags = dwFlags;
    pralItem->pszAddr = pszExcpt;
    pszExcpt = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszExcpt);
    if (NULL != hkeyItem)
    {
        RegCloseKey(hkeyItem);
    }
    return hr;
}

HRESULT _HrSaveExcptIntoReg(HKEY hkeyRoot, LPSTR pszKeyname, RULEADDRLIST * pralItem)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyItem = NULL;
    DWORD       dwDisp = 0;
    ULONG       cbData = 0;

    Assert(NULL != hkeyRoot);
    Assert(NULL != pszKeyname);
    Assert(NULL != pralItem);

    // Verify the values
    if (('\0' == pralItem->pszAddr[0]) ||
                ((0 == (pralItem->dwFlags & RALF_MAIL)) &&
                            (0 == (pralItem->dwFlags & RALF_NEWS))))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Create the entry
    lErr = RegCreateKeyEx(hkeyRoot, pszKeyname, 0, NULL,
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyItem, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the flags
    cbData = sizeof(pralItem->dwFlags);
    lErr = RegSetValueEx(hkeyItem, c_szExcptFlags, NULL,
                REG_DWORD, (CONST BYTE *) &(pralItem->dwFlags), cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the exception
    cbData = lstrlen(pralItem->pszAddr) + 1;
    lErr = RegSetValueEx(hkeyItem, c_szException, NULL,
                REG_SZ, (CONST BYTE *) (pralItem->pszAddr), cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyItem)
    {
        RegCloseKey(hkeyItem);
    }
    return hr;
}

COERuleAddrList::~COERuleAddrList()
{    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");

    FreeRuleAddrList(m_pralList, m_cralList);

    SafeMemFree(m_pralList);
    m_cralList = 0;
}

STDMETHODIMP_(ULONG) COERuleAddrList::NondlgAddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COERuleAddrList::NondlgRelease()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COERuleAddrList::NondlgQueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    if (riid == IID_IUnknown)
    {
        *ppvObject = static_cast<IOENondlgUnk *>(this);
    }
    else if (riid == IID_IOERuleAddrList)
    {
        *ppvObject = static_cast<IOERuleAddrList *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERuleAddrList::GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList)
{
    HRESULT         hr = S_OK;
    RULEADDRLIST *  pralListNew = NULL;
    ULONG           ulIndex = 0;
    RULEADDRLIST *  pralListWalk = NULL;
    
    // Check the incoming params
    if ((NULL == ppralList) || (NULL == pcralList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Do we have anything to copy
    if (0 != m_cralList)
    {
        // Create space to hold all the new items
        hr = HrAlloc((VOID **) &pralListNew, m_cralList * (sizeof(*pralListNew)));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the memory
        ZeroMemory(pralListNew, m_cralList * (sizeof(*pralListNew)));

        // Copy over each new address
        for (ulIndex = 0, pralListWalk = m_pralList; ulIndex < m_cralList; ulIndex++, pralListWalk++)
        {
            // Copy over the flags
            pralListNew[ulIndex].dwFlags = pralListWalk->dwFlags;

            // Copy over the address
            pralListNew[ulIndex].pszAddr = PszDupA(pralListWalk->pszAddr);
            if (NULL == pralListNew[ulIndex].pszAddr)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    // Save off the new items
    *ppralList = pralListNew;
    pralListNew = NULL;
    *pcralList = m_cralList;

    // Set the return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralListNew, m_cralList);
    SafeMemFree(pralListNew);
    return hr;
}

STDMETHODIMP COERuleAddrList::SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList)
{
    HRESULT         hr = S_OK;
    RULEADDRLIST *  pralListNew = NULL;
    ULONG           ulIndex = 0;
    
    // Check the incoming params
    if ((NULL == pralList) && (0 != cralList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Do we have anything to copy
    if (0 != cralList)
    {
        // Create space to hold all the new items
        hr = HrAlloc((VOID **) &pralListNew, cralList * (sizeof(*pralListNew)));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the memory
        ZeroMemory(pralListNew, cralList * (sizeof(*pralListNew)));

        // Copy over each new address
        for (ulIndex = 0; ulIndex < cralList; ulIndex++, pralList++)
        {
            // Copy over the flags
            pralListNew[ulIndex].dwFlags = pralList->dwFlags;

            // Copy over the address
            pralListNew[ulIndex].pszAddr = PszDupA(pralList->pszAddr);
            if (NULL == pralListNew[ulIndex].pszAddr)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    // Free up the old items
    FreeRuleAddrList(m_pralList, m_cralList);
    SafeMemFree(m_pralList);

    // Save off the new items
    m_pralList = pralListNew;
    pralListNew = NULL;
    m_cralList = cralList;

    // Mark the list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralListNew, cralList);
    SafeMemFree(pralListNew);
    return hr;
}

STDMETHODIMP COERuleAddrList::Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pMsgInfo) && (NULL == pIMMsg))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we haven't been initialized yet
    if (0 == (m_dwState & STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Search through each address for a match
    for (ulIndex = 0; ulIndex < m_cralList; ulIndex++)
    {
        // Is this the same type?
        if (0 != (dwFlags & m_pralList[ulIndex].dwFlags))
        {
            // If it exists in the Message info
            if (S_OK == RuleUtil_HrMatchSender(m_pralList[ulIndex].pszAddr, pMsgInfo, pIMMsg, NULL))
            {                
                break;
            }
        }
    }

    // Set the proper return value
    hr = (ulIndex < m_cralList) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP COERuleAddrList::LoadList(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = ERROR_SUCCESS;
    HKEY            hkeyRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           dwVer = 0;
    ULONG           cbData = 0;
    ULONG           cExcpts = 0;
    RULEADDRLIST *  pralList = NULL;
    CHAR            rgchKeyname[CCH_EXCPT_KEYNAME_MAX];
    ULONG           ulIndex = 0;
    
    // Check incoming params
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & STATE_LOADED), "We're already loaded!!!");
    
    // Open the registry location
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the version
    cbData = sizeof(dwVer);
    lErr = RegQueryValueEx(hkeyRoot, c_szExcptVersion, NULL, NULL, (BYTE *) &dwVer, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the version if it didn't exist
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwVer = RULEADDRLIST_VERSION;
        lErr = RegSetValueEx(hkeyRoot, c_szExcptVersion, 0, REG_DWORD, (CONST BYTE *) &dwVer, sizeof(dwVer));
        if (ERROR_SUCCESS != lErr)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            goto exit;
        }
    }

    Assert(RULEADDRLIST_VERSION == dwVer);
    
    // Get the total number of entries
    cbData = sizeof(cExcpts);
    lErr = RegQueryInfoKey(hkeyRoot, NULL, NULL, NULL, &cExcpts, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Is there something to do...
    if (0 != cExcpts)
    {
        // Allocate space to hold the entries
        hr = HrAlloc((VOID **) &pralList, cExcpts * sizeof(*pralList));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the Exception List
        ZeroMemory(pralList, cExcpts * sizeof(*pralList));
        
        // For each entry
        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            // Get the key for the entry
            cbData = sizeof(rgchKeyname);
            lErr = RegEnumKeyEx(hkeyRoot, ulIndex, rgchKeyname, &cbData, NULL, NULL, NULL, NULL);
            if ((ERROR_SUCCESS != lErr) && (ERROR_NO_MORE_ITEMS != lErr))
            {
                hr = HRESULT_FROM_WIN32(lErr);
                goto exit;
            }

            // If we've ran out of entries, we're done
            if (ERROR_NO_MORE_ITEMS == lErr)
            {
                break;
            }
            
            // Load the item
            hr = _HrLoadExcptFromReg(hkeyRoot, rgchKeyname, &(pralList[ulIndex]));
            if (FAILED(hr))
            {
                goto exit;
            }
        }
    }
    
    // Free up any old items
    FreeRuleAddrList(m_pralList, m_cralList);
    SafeMemFree(m_pralList);
    m_cralList = 0;

    // Save off the list
    m_pralList = pralList;
    pralList = NULL;
    m_cralList = cExcpts;
    
    // Make sure we clear the dirty bit
    m_dwState &= ~STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= STATE_LOADED;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralList, cExcpts);
    SafeMemFree(pralList);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERuleAddrList::SaveList(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwVer = 0;
    ULONG       ulIndex = 0;
    ULONG       cExcpts = 0;
    ULONG       cbData = 0;
    CHAR        rgchKeyname[CCH_EXCPT_KEYNAME_MAX];

    // Check incoming params
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the registry location
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Set the version
    dwVer = RULEADDRLIST_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szExcptVersion, 0, REG_DWORD, (CONST BYTE *) &dwVer, sizeof(dwVer));
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }
    
    // Get the total number of sub keys
    cbData = sizeof(cExcpts);
    lErr = RegQueryInfoKey(hkeyRoot, NULL, NULL, NULL, &cExcpts, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Delete any old entries
    for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
    {
        // Get the name of the next sub key
        cbData = sizeof(rgchKeyname);
        lErr = RegEnumKeyEx(hkeyRoot, ulIndex, rgchKeyname, &cbData, NULL, NULL, NULL, NULL);        
        if (ERROR_NO_MORE_ITEMS == lErr)
        {
            break;
        }

        // If the key exists
        if (ERROR_SUCCESS == lErr)
        {
            // Delete the sub key
            SHDeleteKey(hkeyRoot, rgchKeyname);
        }
    }
    
    // For each entry
    for (ulIndex = 0; ulIndex < m_cralList; ulIndex++)
    {
        // Get the key for the entry
        wsprintf(rgchKeyname, "%08X", ulIndex);

        // Load the item
        hr = _HrSaveExcptIntoReg(hkeyRoot, rgchKeyname, &(m_pralList[ulIndex]));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Should we clear out the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERuleAddrList::Clone(IOERuleAddrList ** ppIAddrList)
{
    HRESULT             hr = S_OK;
    COERuleAddrList *   pAddrList = NULL;
    
    // Check incoming params
    if (NULL == ppIAddrList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIAddrList = NULL;
    
    // Create a new Address list
    pAddrList = new COERuleAddrList;
    if (NULL == pAddrList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule address list
    hr = pAddrList->HrInit(m_dwFlags, m_pIUnkOuter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Copy over the list of addresses
    hr = pAddrList->SetList(0, m_pralList, m_cralList);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the Address list interface
    hr = pAddrList->QueryInterface(IID_IOERuleAddrList, (void **) ppIAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }

    pAddrList = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pAddrList)
    {
        delete pAddrList;
    }
    return hr;
}

HRESULT COERuleAddrList::HrInit(DWORD dwFlags, IUnknown * pIUnkOuter)
{
    HRESULT             hr = S_OK;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // Deal with the IUnknown
    if (NULL == pIUnkOuter)
    {
        m_pIUnkOuter = reinterpret_cast<IUnknown *>
                            (static_cast<IOENondlgUnk *> (this));
    }
    else
    {
        m_pIUnkOuter = pIUnkOuter;
    }
    
    // Mark it as initialized
    m_dwState |= STATE_INIT;
    
    // Set the proper return value
    hr = S_OK;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\aplyrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  AplyRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "aplyrule.h"
#include "ruledesc.h"
#include "rulesui.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <newfldr.h>
#include <storutil.h>
#include "shlwapip.h" 
#include <xpcomm.h>
#include <demand.h>

// Global data
const static HELPMAP g_rgCtxMapApplyMail[] = {
                        {idlvRulesApplyList,        idhRulesList},
                        {idcApplyRulesAll,          idhApplyRulesAll},
                        {idcApplyRulesNone,         idhApplyRulesNone},
                        {idredtApplyDescription,    idhApplyDescription},
                        {idcApplyFolder,            idhApplyFolder},
                        {idcBrowseApplyFolder,      idhBrowseApplyFolder},
                        {idcRulesApplySubfolder,    idhApplySubfolder},
                        {idcRulesApply,             idhApplyNow},
                        {0, 0}};

COEApplyRulesUI::~COEApplyRulesUI()
{
    RULENODE *  prnodeWalk = NULL;
    
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }

    // Free up any rules
    while (NULL != m_prnodeList)
    {
        prnodeWalk = m_prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        m_prnodeList = m_prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }
}

HRESULT COEApplyRulesUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, RULENODE * prnode, IOERule * pIRuleDef)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_typeRule = typeRule;

    m_pIRuleDef = pIRuleDef;
    
    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // We own the list now...
    m_prnodeList = prnode;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEApplyRulesUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRuleApplyTo),
                                        m_hwndOwner, COEApplyRulesUI::FOEApplyRulesDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEApplyRulesUI::FOEApplyRulesDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEApplyRulesUI *       pApplyRulesUI = NULL;
    HWND                    hwndRE = 0;

    pApplyRulesUI = (COEApplyRulesUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pApplyRulesUI = (COEApplyRulesUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pApplyRulesUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtApplyDescription);

            if (!hwndRE || (FALSE == pApplyRulesUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pApplyRulesUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_DESTROY:
            fRet = pApplyRulesUI->FOnDestroy();
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapApplyMail);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the mail rules UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    TCHAR               szRes[CCHMAX_STRINGRES];
    FOLDERID            idDefault;
    FOLDERINFO          fldinfo = {0};
    BOOL                fEnable = FALSE;
    IEnumerateFolders * pChildren=NULL;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvRulesApplyList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtApplyDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }

    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, RDF_READONLY | RDF_APPLYDLG)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Figure out the default folder to select
    if (RULE_TYPE_MAIL == m_typeRule)
    {
        if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &fldinfo)))
        {
        
            idDefault = fldinfo.idFolder;
        }
        else
        {
            idDefault = FOLDERID_LOCAL_STORE;
        }
    }
    else
    {
        // Get default news server from accoutn manager
        if (FAILED(GetDefaultServerId(ACCT_NEWS, &idDefault)))
        {
                idDefault = FOLDERID_ROOT;
                m_dwState |= STATE_NONEWSACCT;
        }
        else
        {
            if ((SUCCEEDED(g_pStore->EnumChildren(idDefault, TRUE, &pChildren))) &&
                    (S_OK == pChildren->Next(1, &fldinfo, NULL)))
            {
                idDefault = fldinfo.idFolder;
            }
        }
    }

    if (FAILED(InitFolderPickerEdit(GetDlgItem(m_hwndDlg, idcApplyFolder), idDefault)))
    {
        fRet = FALSE;
        goto exit;
    }

    // What should the default subfolder state be?
    fEnable = TRUE;
    if ((FOLDERID_ROOT == idDefault) || (FOLDERID_LOCAL_STORE == idDefault) || (0 != (fldinfo.dwFlags & FOLDER_SERVER)))
    {
        CheckDlgButton(m_hwndDlg, idcRulesApplySubfolder, BST_CHECKED);
        fEnable = FALSE;
    }
    else if (0 == (fldinfo.dwFlags & FOLDER_HASCHILDREN))
    {
        CheckDlgButton(m_hwndDlg, idcRulesApplySubfolder, BST_UNCHECKED);
        fEnable = FALSE;
    }
                    
    // Should the subfolder button be enabled?
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApplySubfolder, fEnable);
    
    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Get the proper title string
    AthLoadString((RULE_TYPE_MAIL == m_typeRule) ? idsRulesApplyMail : idsRulesApplyNews, szRes, ARRAYSIZE(szRes));
    
    // Set the proper window text
    SetWindowText(m_hwndDlg, szRes);
    
    // Note that we've been loaded
    m_dwState |= STATE_LOADED;

    // Everything's AOK
    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&fldinfo);
    SafeRelease(pChildren);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL                fRet = FALSE;
    FOLDERINFO          fldinfo;
    HWND                hwndFolder = NULL;
    FOLDERID            idFolder;
    BOOL                fEnable;
    FOLDERDIALOGFLAGS   dwFlags = 0;
    INT                 cItems = 0;
    INT                 iSelected = 0;
    CHAR                rgchTitle[CCHMAX_STRINGRES];

    switch (iCtl)
    {
        case IDCANCEL:
            if (FALSE != _FOnClose())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;
            
        case idcBrowseApplyFolder:
            if (BN_CLICKED == uiNotify )
            {
                dwFlags = TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_NONEWFOLDERS;
                if (RULE_TYPE_MAIL == m_typeRule)
                {
                    dwFlags |= TREEVIEW_NONEWS;
                }
                else
                {
                    dwFlags |= TREEVIEW_NOLOCAL;
                }

                AthLoadString(idsApplyRuleTitle, rgchTitle, sizeof(rgchTitle));
                
                if (SUCCEEDED(PickFolderInEdit(m_hwndDlg, GetDlgItem(m_hwndDlg, idcApplyFolder), dwFlags, rgchTitle, NULL, &idFolder)))
                {
                    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &fldinfo)))
                    {
                        if ((0 != (fldinfo.dwFlags & FOLDER_SERVER)) || (FOLDERID_ROOT == fldinfo.idFolder))
                        {
                            SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder,
                                        BM_SETCHECK, (WPARAM) BST_CHECKED, (LPARAM) 0);
                        }
                        else if (0 == (fldinfo.dwFlags & FOLDER_HASCHILDREN))
                        {
                            SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder,
                                        BM_SETCHECK, (WPARAM) BST_UNCHECKED, (LPARAM) 0);
                        }
                    
                        fEnable = (0 != (fldinfo.dwFlags & FOLDER_HASCHILDREN)) &&
                                            (0 == (fldinfo.dwFlags & FOLDER_SERVER)) && (FOLDERID_ROOT != fldinfo.idFolder);

                        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApplySubfolder, fEnable);
                    
                        g_pStore->FreeRecord(&fldinfo);
                    
                        fRet = TRUE;
                    }
                }
            }
            break;

        case idcRulesApply:
            // Check to see if we should handle this
            if (0 != (m_dwState & STATE_NONEWSACCT))
            {
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), 
                              MAKEINTRESOURCEW(idsApplyRulesNoNewsFolders), NULL, MB_OK | MB_ICONERROR);
                fRet = FALSE;
            }
            else
            {
                fRet = _FOnApplyRules();
            }
            break;

        case idcApplyRulesAll:
        case idcApplyRulesNone:
            if (NULL != m_hwndList)
            {
                cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
                if (LB_ERR != cItems)
                {
                    fEnable = (idcApplyRulesAll == iCtl);
                    SendMessage(m_hwndList, LB_SELITEMRANGE, (WPARAM) fEnable, (LPARAM) MAKELPARAM(0, cItems));

                    // Set the focus on the first item
                    SendMessage(m_hwndList, LB_SETCARETINDEX, (WPARAM) 0, (LPARAM) MAKELPARAM(FALSE, 0));

                    // Enable the buttons
                    _EnableButtons(0);
                }
            }
            break;

        case idlvRulesApplyList:
            if (LBN_SELCHANGE == uiNotify)
            {
                iSelected = (INT) SendMessage(hwndCtl, LB_GETCARETINDEX, (WPARAM) 0, (LPARAM) 0);

                // Enable the buttons
                _EnableButtons(iSelected);
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::FOnDestroy(VOID)
{
    BOOL		fRet = FALSE;
    INT			cRules = 0;
    INT			iIndex = 0;
    DWORD_PTR	dwData = 0;

    Assert(m_hwndList);
    
    // Get the number of rules in the list view
    cRules = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Release each of the rules from the list view
    for (iIndex = 0; iIndex < cRules; iIndex++)
    {        
        // Get the rule interface
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) iIndex, (LPARAM) 0);
        if ((LB_ERR == dwData) || (NULL == dwData))
        {
            continue;
        }
        
        // Release the rule
        ((IOERule *) (dwData))->Release();
    }

exit:
    return fRet;
}

BOOL COEApplyRulesUI::_FOnClose(VOID)
{
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULENODE *      prnodeWalk = NULL;
    INT             iDefault = 0;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add each filter to the list
    dwListIndex = 0;

    while (NULL != m_prnodeList)
    {
        // Add rule to the list
        if (NULL != m_prnodeList->pIRule)
        {
            if (FALSE != _FAddRuleToList(dwListIndex, m_prnodeList->pIRule))
            {
                if (m_pIRuleDef == m_prnodeList->pIRule)
                {
                    iDefault = dwListIndex;
                }
                dwListIndex++;
            }

            m_prnodeList->pIRule->Release();
        }

        prnodeWalk = m_prnodeList;
        
        m_prnodeList = m_prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }

    if (0 != dwListIndex)
    {
        // Select the default 
        SendMessage(m_hwndList, LB_SETSEL, (WPARAM) TRUE, (LPARAM) iDefault);

        // Set the focus on the item also
        SendMessage(m_hwndList, LB_SETCARETINDEX, (WPARAM) iDefault, (LPARAM) MAKELPARAM(FALSE, 0));
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != dwListIndex) ? iDefault : -1);

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FAddRuleToList(DWORD dwIndex, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Insert the rule name
    dwIndex = (DWORD) SendMessage(m_hwndList, LB_INSERTSTRING, (WPARAM) dwIndex, (LPARAM) propvar.pszVal);
    if (LB_ERR == dwIndex)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the rule into the item
    if (LB_ERR == SendMessage(m_hwndList, LB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) pIRule))
    {
        fRet = FALSE;
        goto exit;
    }

    // Hold a reference to the rule object
    pIRule->AddRef();
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Mail rules UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEApplyRulesUI::_EnableButtons(INT iSelected)
{
    BOOL    fRet = FALSE;
    INT     cRules = 0;
    INT     cRulesSel = 0;
    
    // How many rules do we have?
    cRules = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRules)
    {
        fRet = TRUE;
        goto exit;
    }
    
    if (0 != cRules)
    {
        // How many rules are selected?
        cRulesSel = (INT) SendMessage(m_hwndList, LB_GETSELCOUNT, (WPARAM) 0, (LPARAM) 0);
        if (LB_ERR == cRulesSel)
        {
            fRet = TRUE;
            goto exit;
        }
    }
    
    // Load the description field
    _LoadRule(iSelected);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRulesApply, cRulesSel != 0);

    // Enable the selection buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcApplyRulesNone, cRules != 0);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcApplyRulesAll, cRules != 0);

    // Set the return value
    fRet = TRUE;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadRule
//
//  This loads the selected rule into the description field.
//  If there isn't a selected rule, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEApplyRulesUI::_LoadRule(INT iSelected)
{
    DWORD_PTR   dwData = 0;
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) iSelected, (LPARAM) 0);
        if (LB_ERR != dwData)
        {
            pIRule = (IOERule *) (dwData);
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(m_typeRule, pIRule);

    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnApplyTo
//
//  This applies the rules into a folder
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEApplyRulesUI::_FOnApplyRules(VOID)
{
    BOOL                fRet = FALSE;
    FOLDERID            idFolder = 0;
    INT                 cRulesAlloc = 0;
    INT *               piItems = NULL;
    INT                 cRules = 0;
    INT                 iIndex = 0;
    DWORD_PTR           dwData = 0;
    RULENODE *          prnodeList = NULL;
    RULENODE *          prnodeWalk = NULL;
    RULENODE *          prnodeNew = NULL;
    CExecRules *        pExecRules = NULL;
    IOEExecRules *      pIExecRules = NULL;
    RECURSEAPPLY        rapply;
    DWORD               dwFlags;
    CProgress *         pProgress = NULL;
    ULONG               cMsgs = 0;
    FOLDERINFO          infoFolder = {0};
    CHAR                rgchTmpl[CCHMAX_STRINGRES];
    LPSTR               pszText = NULL;
    HRESULT             hr = S_OK;
#ifdef DEBUG
    DWORD               dwTime = 0;
#endif  // DEBUG
    
    Assert(NULL != m_hwndList);
    
    idFolder = _FldIdGetFolderSel();
    
    // Get the count of rules
    cRulesAlloc = (INT) SendMessage(m_hwndList, LB_GETSELCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cRulesAlloc)
    {
        fRet = FALSE;
        goto exit;
    }

    // Is there anything to do?
    if (0 == cRulesAlloc)
    {
        fRet = TRUE;
        goto exit;
    }

    // Allocate space tp hold the list of items
    if (FAILED(HrAlloc((VOID **) &piItems, sizeof(*piItems) * cRulesAlloc)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab the list of items
    cRules = (INT) SendMessage(m_hwndList, LB_GETSELITEMS, (WPARAM) cRulesAlloc, (LPARAM) piItems);
    if (LB_ERR == cRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab each of the enabled rules
    for (iIndex = 0; iIndex < cRules; iIndex++)
    {
        // Get the rule from the list
        dwData = SendMessage(m_hwndList, LB_GETITEMDATA, (WPARAM) piItems[iIndex], (LPARAM) 0);
        if ((LB_ERR == dwData) || (NULL == dwData))
        {
            continue;
        }
        
        // Save the rule
        prnodeNew = new RULENODE;
        if (NULL == prnodeNew)
        {
            continue;
        }

        prnodeNew->pIRule = (IOERule *) dwData;
        prnodeNew->pIRule->AddRef();

        if (NULL == prnodeWalk)
        {
            prnodeList = prnodeNew;
            prnodeWalk = prnodeList;
        }
        else
        {
            prnodeWalk->pNext = prnodeNew;
            prnodeWalk = prnodeWalk->pNext;
        }
        prnodeNew = NULL;
        prnodeWalk->pNext = NULL;
    }
    
    // If we don't have any rules then just return
    if (NULL == prnodeList)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Create the executor object
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize it with the list of rules
    if (FAILED(pExecRules->_HrInitialize(0, prnodeList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Grab the executor interface
    if (FAILED(pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules)))
    {
        fRet = FALSE;
        goto exit;
    }
    pExecRules = NULL;
    
    // Apply to rule to the folder
    rapply.pIExecRules = pIExecRules;

    dwFlags = RECURSE_INCLUDECURRENT;

    if (RULE_TYPE_MAIL == m_typeRule)
    {
        dwFlags |= RECURSE_ONLYLOCAL;
    }
    else
    {
        dwFlags |= RECURSE_ONLYNEWS;
    }
                
    if (BST_CHECKED == SendDlgItemMessage(m_hwndDlg, idcRulesApplySubfolder, BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
    {
        dwFlags |= RECURSE_SUBFOLDERS;
    }
    
    if (FAILED(RecurseFolderHierarchy(idFolder, dwFlags, 0, (DWORD_PTR)&cMsgs, (PFNRECURSECALLBACK)RecurseFolderCounts)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        fRet = FALSE;
        goto exit;
    }

    pProgress->Init(m_hwndDlg, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cMsgs, 0, TRUE, FALSE);

    // Show the progress dialog
    pProgress->Show(0);

    rapply.pProgress = pProgress;
    rapply.hwndOwner = pProgress->GetHwnd();

#ifdef DEBUG
    dwTime = GetTickCount();
#endif  // DEBUG

    // Set up the timer
    hr = RecurseFolderHierarchy(idFolder, dwFlags, 0, (DWORD_PTR) &rapply, (PFNRECURSECALLBACK)_HrRecurseApplyFolder);

#ifdef DEBUG
    // Time to Apply Rules
    TraceInfo(_MSG("Applying Rules Time: %d Milli-Seconds", GetTickCount() - dwTime));
#endif  // DEBUG

    // Close the progress window
    pProgress->Close();

    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the template string
    AthLoadString(idsApplyRulesFinished, rgchTmpl, sizeof(rgchTmpl));

    // Get the name of the folder
    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &infoFolder)))
    {
        // Allocate space to hold the final string
        if (SUCCEEDED(HrAlloc((VOID **) &pszText, (sizeof(rgchTmpl) * lstrlen(infoFolder.pszName)) * sizeof(*pszText))))
        {
            // Build up the final string
            wsprintf(pszText, rgchTmpl, infoFolder.pszName);
            
            // Show confirmation dialog
            AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthena), pszText, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pProgress);
    SafeRelease(pIExecRules);
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; // MemFree(prnodeWalk);
    }
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; //MemFree(prnodeNew);
    }
    SafeMemFree(piItems);
    if (FALSE == fRet)
    {
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsRulesApplyFail), NULL, MB_OK | MB_ICONERROR);
    }
    return fRet;
}

FOLDERID COEApplyRulesUI::_FldIdGetFolderSel(VOID)
{
    return(GetFolderIdFromEdit(GetDlgItem(m_hwndDlg, idcApplyFolder)));
}

// --------------------------------------------------------------------------------
HRESULT COEApplyRulesUI::_HrRecurseApplyFolder(FOLDERINFO * pfldinfo, BOOL fSubFolders,
    DWORD cIndent, DWORD_PTR dwpCookie)
{
    HRESULT             hr = S_OK;
    RECURSEAPPLY *      prapply = NULL;
    IMessageFolder *    pFolder = NULL;

    prapply = (RECURSEAPPLY *) dwpCookie;

    if (NULL == prapply)
    {
        goto exit;
    }

    // If not hidden
    if ((0 != (pfldinfo->dwFlags & FOLDER_HIDDEN)) || (FOLDERID_ROOT == pfldinfo->idFolder))
    {
        goto exit;
    }

    // Not Subscribed
    if (0 == (pfldinfo->dwFlags & FOLDER_SUBSCRIBED))
    {
        goto exit;
    }

    // Server node
    if (0 != (pfldinfo->dwFlags & FOLDER_SERVER))
    {
        goto exit;
    }

    hr = g_pStore->OpenFolder(pfldinfo->idFolder, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the struct to insert
    hr = RuleUtil_HrApplyRulesToFolder(RULE_APPLY_SHOWUI, (FOLDER_LOCAL != pfldinfo->tyFolder) ? DELETE_MESSAGE_NOTRASHCAN : 0,
                    prapply->pIExecRules, pFolder, prapply->hwndOwner, prapply->pProgress);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the user hit cancel then we're done
    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    
exit:
    SafeRelease(pFolder);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\addrrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  AddrRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

// Type definitions
typedef struct tagRULEADDRLIST
{
    DWORD   dwFlags;
    LPSTR   pszAddr;
} RULEADDRLIST, * PRULEADDRLIST;

// Interface definitions
interface IOENondlgUnk
{
    virtual STDMETHODIMP NondlgQueryInterface(const IID & riid, void ** ppvObject) = 0;
    virtual STDMETHODIMP_(ULONG) NondlgAddRef() = 0;
    virtual STDMETHODIMP_(ULONG) NondlgRelease() = 0;
};

interface IOERuleAddrList : IUnknown
{
    virtual STDMETHODIMP GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList) = 0;
    virtual STDMETHODIMP SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList) = 0;
    virtual STDMETHODIMP Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg) = 0;
    
    virtual STDMETHODIMP IsDirty() = 0;
    virtual STDMETHODIMP LoadList(LPCSTR pszRegPath) = 0;
    virtual STDMETHODIMP SaveList(LPCSTR pszRegPath, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP Clone(IOERuleAddrList ** ppIAddrList) = 0;
};

// Constants
const DWORD RALF_MAIL       = 0x00000001;
const DWORD RALF_NEWS       = 0x00000002;
const DWORD RALF_MAILNEWS   = RALF_MAIL | RALF_NEWS;

class COERuleAddrList : public IOERuleAddrList, IOENondlgUnk
{
    private:  
        enum
        {
            STATE_UNINIT   = 0x00000000,
            STATE_INIT     = 0x00000001,
            STATE_LOADED   = 0x00000002,
            STATE_DIRTY    = 0x00000004
        };    

        enum {RULEADDRLIST_VERSION  = 0x00050000};
        
        enum {CCH_EXCPT_KEYNAME_MAX = 9};
        
    private:
        LONG            m_cRef;
        DWORD           m_dwState;
        DWORD           m_dwFlags;
        RULEADDRLIST *  m_pralList;
        ULONG           m_cralList;
        IUnknown *      m_pIUnkOuter;
    
    public:
        // Constructor/destructor
        COERuleAddrList() : m_cRef(0), m_dwState(0), m_dwFlags(0), m_pralList(NULL),
                            m_cralList(0), m_pIUnkOuter(NULL) {}
        ~COERuleAddrList();

        // IUnknown members
        virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject)
                { return m_pIUnkOuter->QueryInterface(riid, ppvObject); }
        virtual STDMETHODIMP_(ULONG) AddRef(void)
                { return m_pIUnkOuter->AddRef(); }
        virtual STDMETHODIMP_(ULONG) Release(void)
                { return m_pIUnkOuter->Release(); }

        // IOENondlgUnk
        virtual STDMETHODIMP NondlgQueryInterface(REFIID riid, void ** ppvObject);
        virtual STDMETHODIMP_(ULONG) NondlgAddRef(void);
        virtual STDMETHODIMP_(ULONG) NondlgRelease(void);
                
        // IOERuleAddrList members
        virtual STDMETHODIMP GetList(DWORD dwFlags, RULEADDRLIST ** ppralList, ULONG * pcralList);
        virtual STDMETHODIMP SetList(DWORD dwFlags, RULEADDRLIST * pralList, ULONG cralList);
        virtual STDMETHODIMP Match(DWORD dwFlags, MESSAGEINFO * pMsgInfo, IMimeMessage * pIMMsg);
    
        virtual STDMETHODIMP IsDirty() {return ((0 != (m_dwState & STATE_DIRTY)) ? S_OK : S_FALSE);}
        virtual STDMETHODIMP LoadList(LPCSTR pszRegPath);
        virtual STDMETHODIMP SaveList(LPCSTR pszRegPath, BOOL fClearDirty);
        virtual STDMETHODIMP Clone(IOERuleAddrList ** ppIAddrList);

        // COERuleAddrList members
        HRESULT HrInit(DWORD dwFlags, IUnknown * pIUnkOuter);

};

HRESULT HrCreateAddrList(IUnknown * pIUnkOuter, const IID & riid, void ** ppvObject);
VOID FreeRuleAddrList(RULEADDRLIST * pralList, ULONG cralList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\aplyrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  AplyRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "rulesmgr.h"

// Forward declarations
class CProgress;
class CRuleDescriptUI;

class COEApplyRulesUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_LOADED        = 0x00000002,
            STATE_NONEWSACCT    = 0x00000004
        };

        enum
        {
            RULE_PAGE_MAIL      = 0x00000000,
            RULE_PAGE_NEWS      = 0x00000001,
            RULE_PAGE_MAX       = 0x00000002,
            RULE_PAGE_MASK      = 0x000000FF
        };
        
        struct RECURSEAPPLY
        {
            IOEExecRules *  pIExecRules;
            HWND            hwndOwner;
            CProgress *     pProgress;
        };
        
    private:
        HWND                    m_hwndOwner;
        DWORD                   m_dwFlags;
        DWORD                   m_dwState;
        HWND                    m_hwndDlg;
        HWND                    m_hwndList;
        HWND                    m_hwndDescript;
        CRuleDescriptUI *       m_pDescriptUI;
        RULENODE *              m_prnodeList;
        RULE_TYPE               m_typeRule;
        IOERule *               m_pIRuleDef;

    public:
        // Constructor/destructor
        COEApplyRulesUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                            m_hwndDlg(NULL), m_hwndList(NULL), m_hwndDescript(NULL),
                            m_pDescriptUI(NULL), m_prnodeList(NULL), m_typeRule(RULE_TYPE_MAIL),
                            m_pIRuleDef(NULL) {}
        ~COEApplyRulesUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, RULENODE * prnode, IOERule * pIRuleDef);
        HRESULT HrShow(VOID);
        
        // Dialog methods
        static INT_PTR CALLBACK FOEApplyRulesDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnDestroy(VOID);
        
        static HRESULT _HrRecurseApplyFolder(FOLDERINFO * pFolder, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);

    private:
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddRuleToList(DWORD dwIndex, IOERule * pIRule);
        VOID _EnableButtons(INT iSelected);

        // For dealing with the description field
        VOID _LoadRule(INT iSelected);

        // Functions to deal with the basic actions
        BOOL _FOnClose(VOID);
        BOOL _FOnApplyRules(VOID);
        FOLDERID _FldIdGetFolderSel(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\editrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  EditRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include "shlwapip.h" 
#include <instance.h>
#include <demand.h>

// Constants
static const int c_cCritItemGrow = 16;
static const int c_cActItemGrow = 16;
                         
const static HELPMAP g_rgCtxMapEditRule[] = {
                        {idlvCriteria,              idhCriteriaRule},
                        {idlvActions,               idhActionsRule},
                        {idredtDescription,         idhDescriptionRule},
                        {idedtRuleName,             idhRuleName},
                       {0, 0}};
                       
const static HELPMAP g_rgCtxMapEditView[] = {
                        {idlvCriteria,              idhCriteriaView},
                        {idredtDescription,         idhDescriptionView},
                        {idedtRuleName,             idhViewName},
                       {0, 0}};
                       
// The methods for the Rules Editor UI

CEditRuleUI::CEditRuleUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
            m_typeRule(RULE_TYPE_MAIL), m_hwndCrit(NULL), m_hwndAct(NULL), m_hwndDescript(NULL),
            m_hwndName(NULL), m_pIRule(NULL), m_pDescriptUI(NULL)
{
    ZeroMemory(m_rgfCritEnabled, sizeof(m_rgfCritEnabled));
    ZeroMemory(m_rgfActEnabled, sizeof(m_rgfActEnabled));
}

CEditRuleUI::~CEditRuleUI()
{    
    SafeRelease(m_pIRule);
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//  pIRule      - the rule to edit
//  pmsginfo    - the message to create the rule from
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditRuleUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule, MESSAGEINFO * pmsginfo)
{
    HRESULT         hr = S_OK;
    
    // If we're already initialized, then fail
    if ((0 != (m_dwState & STATE_INITIALIZED)) || (NULL == pIRule))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // Save off the type of rule to edit
    m_typeRule = typeRule;

    Assert(NULL == m_pDescriptUI);
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Save off the rule
    Assert(NULL == m_pIRule);
    m_pIRule = pIRule;
    pIRule->AddRef();
        
    // We're done
    m_dwState |= STATE_INITIALIZED;

    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the rules editor UI
//
//  Returns:    S_OK, if IDOK was selected
//              otherwise, S_FALSE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditRuleUI::HrShow(void)
{
    HRESULT hr = S_OK;
    int     iRet = 0;

    // If we aren't initialized, then fail
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, (RULE_TYPE_FILTER == m_typeRule) ?
                    MAKEINTRESOURCE(iddEditView) : MAKEINTRESOURCE(iddEditRule),
                    m_hwndOwner, CEditRuleUI::FEditRuleDlgProc, (LPARAM)this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditRuleDlgProc
//
//  This is the main dialog proc for the rules editor dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditRuleUI::FEditRuleDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CEditRuleUI *   pEditRuleUI = NULL;
    LPNMHDR         pnmhdr = NULL;
    LPNMLISTVIEW    pnmlv = NULL;
    LVHITTESTINFO   lvh;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    int             nIndex = 0;
    HWND            hwndRE = 0;

    pEditRuleUI = (CEditRuleUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pEditRuleUI = (CEditRuleUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pEditRuleUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtDescription);

            if (!hwndRE || (FALSE == pEditRuleUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idedtRuleName:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        pEditRuleUI->FOnNameChange((HWND) lParam);
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;
                
                case IDOK:
                    if (FALSE != pEditRuleUI->FOnOK())
                    {
                        EndDialog(hwndDlg, IDOK);
                        fRet = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR) lParam;
            
            switch (((LPNMHDR)lParam)->code)
            {
                case NM_CLICK:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlv = (LPNMLISTVIEW) lParam;
                        pEditRuleUI->FOnListClick(pnmhdr->hwndFrom, pnmlv);
                    }
                    break;

                case NM_DBLCLK:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlv = (LPNMLISTVIEW) lParam;
                    
                        ZeroMemory(&lvh, sizeof(lvh));
                        lvh.pt = pnmlv->ptAction;
                        ListView_HitTest(pnmhdr->hwndFrom, &lvh);
                        if ((-1 != pnmlv->iItem) && (0 != (lvh.flags & LVHT_ONITEMLABEL)))
                        {                  
                            pEditRuleUI->HandleEnabledState(pnmhdr->hwndFrom, pnmlv->iItem);
                        }
                    }
                    break;
                
                case LVN_KEYDOWN:
                    if ((idlvCriteria == GetDlgCtrlID(pnmhdr->hwndFrom)) ||
                            (idlvActions == GetDlgCtrlID(pnmhdr->hwndFrom)))
                    {
                        pnmlvkd = (NMLVKEYDOWN *) lParam;
                        if (VK_SPACE == pnmlvkd->wVKey)
                        {
                            nIndex = ListView_GetNextItem(pnmhdr->hwndFrom, -1, LVNI_SELECTED);
                            if (0 <= nIndex)
                            {
                                pEditRuleUI->HandleEnabledState(pnmhdr->hwndFrom, nIndex);
                            }
                        }
                    }
                    break;
            }
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = pEditRuleUI->FOnHelp(uMsg, wParam, lParam);
            break;
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This is the initialization routine for the rules editor dialog
//
//  hwndDlg - handle to the rules editor dialog
//
//  Returns:    TRUE, if the dialog was initialized successfully
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    INT         iSelect = 0;

    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndCrit = GetDlgItem(m_hwndDlg, idlvCriteria);
    if (RULE_TYPE_FILTER != m_typeRule)
    {
        m_hwndAct = GetDlgItem(hwndDlg, idlvActions);
    }
    m_hwndDescript = GetDlgItem(hwndDlg, idredtDescription);
    m_hwndName = GetDlgItem(hwndDlg, idedtRuleName);
    if ((NULL == m_hwndCrit) || ((RULE_TYPE_FILTER != m_typeRule) && (NULL == m_hwndAct)) ||
                (NULL == m_hwndDescript) || (NULL == m_hwndName))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize criteria listbox control
    if (FALSE == _FInitializeCritListCtrl())
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize criteria listbox control
    if (RULE_TYPE_FILTER != m_typeRule)
    {
        if (FALSE == _FInitializeActListCtrl())
        {
            fRet = FALSE;
            goto exit;
        }
    }

    // Load the criteria listbox control
    if (FALSE == _FLoadCritListCtrl(&iSelect))
    {
        fRet = FALSE;
        goto exit;
    }

    _SetTitleText();
    
    // Select the default item in the criteria list
    ListView_SetItemState(m_hwndCrit, iSelect, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    // Make sure the default item is visible
    ListView_EnsureVisible(m_hwndCrit, iSelect, FALSE);
    
    // Initialize the description field
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    if (FAILED(m_pDescriptUI->HrSetRule(m_typeRule, m_pIRule)))
    {
        fRet = FALSE;
        goto exit;
    }

    // If we are a filter and are new
    if ((RULE_TYPE_FILTER == m_typeRule) && (0 != (m_dwFlags & ERF_ADDDEFAULTACTION)))
    {
        // Set the default action
        if (FAILED(m_pDescriptUI->HrEnableActions(ACT_TYPE_SHOW, TRUE)))
        {
            goto exit;
        }
    }

    m_pDescriptUI->ShowDescriptionString();

    // Initialize the name field
    if (FAILED(m_pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    if ((VT_LPSTR != propvar.vt) || (NULL == propvar.pszVal) || ('\0' == propvar.pszVal[0]))
    {
        fRet = FALSE;
        goto exit;
    }

    Edit_SetText(m_hwndName, propvar.pszVal);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnListClick
//
//  This handles clicking on either of the lists
//
//  Returns:    TRUE, we handled the click message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnListClick(HWND hwndList, LPNMLISTVIEW pnmlv)
{
    BOOL            fRet = FALSE;
    int             iIndex = 0;
    int             iSelected = 0;
    LVHITTESTINFO   lvh;

    Assert(NULL != m_hwndCrit);
    
    if ((NULL == hwndList) || (NULL == pnmlv))
    {
        fRet = FALSE;
        goto exit;
    }
    
    ZeroMemory(&lvh, sizeof(lvh));
    lvh.pt = pnmlv->ptAction;
    iIndex = ListView_HitTest(hwndList, &lvh);
    if (-1 == iIndex)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Let's make sure this item is already selected
    iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (iSelected != iIndex)
    {
        ListView_SetItemState(hwndList, iIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if ((lvh.flags & LVHT_ONITEMSTATEICON) &&
                    !(lvh.flags & LVHT_ONITEMLABEL))
    {
        HandleEnabledState(hwndList, iIndex);
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnOK
//
//  This handles clicking on the links in the description field
//
//  Returns:    TRUE, we handled the click message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnOK(void)
{
    BOOL            fRet = FALSE;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar;
    HRESULT         hr = S_OK;
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;
    BOOL            fNewRule = FALSE;
    LPSTR           pszName = NULL;
    ULONG           cchName = 0;
    
    ZeroMemory(&propvar, sizeof(propvar));
    
    if (NULL == m_pIRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // First let's validate the name and all the criteria and actions

    // Get the name from the edit well
    cchName = Edit_GetTextLength(m_hwndName) + 1;
    if (FAILED(HrAlloc((void **) &pszName, cchName * sizeof(*pszName))))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pszName[0] = '\0';
    cchName = Edit_GetText(m_hwndName, pszName, cchName);
    
    // Check to see if the name is valid
    if (0 == UlStripWhitespace(pszName, TRUE, TRUE, NULL))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoName) : MAKEINTRESOURCEW(idsViewsErrorNoName),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }

    
    // Let's make sure they have the right parts

    // Get the criteria for the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have any criteria
    if (0 == cCritItem)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoCriteria) : MAKEINTRESOURCEW(idsViewsErrorNoCriteria),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Do we have any criteria
    if (0 == cActItem)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_FILTER != m_typeRule) ?
                        MAKEINTRESOURCEW(idsRulesErrorNoActions) : MAKEINTRESOURCEW(idsViewsErrorNoActions),
                        NULL, MB_OK | MB_ICONINFORMATION);
        fRet = FALSE;
        goto exit;
    }

    // Let's check to see if we really need to do anything
    hr = m_pDescriptUI->HrIsDirty();
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_FALSE == hr))
    {
        fRet = TRUE;
        goto exit;
    }
    
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRulesErrorFix), NULL,
                        MB_OK | MB_ICONINFORMATION);
        m_pDescriptUI->ShowDescriptionString();
        fRet = FALSE;
        goto exit;
    }

    // Set the criteria on the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = m_pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions on the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = m_pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the rule name
    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    hr = m_pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();

    // Note that we saved
    m_dwState &= ~STATE_DIRTY;
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    PropVariantClear(&propvar);
    SafeMemFree(pszName);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnHelp
//
//  This handles the WM_HELP message for the rules edit UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnHelp(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(OnContextHelp(m_hwndDlg, uiMsg, wParam, lParam, (RULE_TYPE_FILTER == m_typeRule) ? g_rgCtxMapEditView : g_rgCtxMapEditRule));
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNameChange
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::FOnNameChange(HWND hwndName)
{
    BOOL    fRet = FALSE;

    Assert(NULL != m_hwndName);
    Assert(hwndName == m_hwndName);

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
    // Disable the OK button if the name is empty
    fRet = RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndName));

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HandleEnabledState
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  nIndex      - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CEditRuleUI::HandleEnabledState(HWND hwndList, int nItem)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi;
    BOOL        fEnabled = FALSE;
    INT         iIndex = 0;
    LONG        lItem = 0;
    INT         cItems = 0;

    // Grab the list view item
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE | LVIF_PARAM;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.iItem = nItem;
    if (FALSE == ListView_GetItem(hwndList, &lvi))
    {
        goto exit;
    }

    lItem = (LONG) lvi.lParam;
    
    if (INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) == lvi.state)
    {
        goto exit;
    }
    
    // Get the new enabled value
    fEnabled = (lvi.state != INDEXTOSTATEIMAGEMASK(iiconStateChecked+1));

    // Build up the description string
    if (hwndList == m_hwndCrit)
    {
        if (FALSE == _FAddCritToList(nItem, fEnabled))
        {
            goto exit;
        }
    }
    else
    {
        // Set the UI to the opposite enabled state
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_STATE;
        lvi.iItem = nItem;
        lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateChecked+1) :
                                INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        ListView_SetItem(hwndList, &lvi);

        // Figure out the number of items in the list
        cItems = ListView_GetItemCount(hwndList);

        Assert(hwndList == m_hwndAct);
        m_pDescriptUI->HrEnableActions(c_rgEditActList[lItem].typeAct, fEnabled);
        
        // Do we need to go through and update all the items?
        if (0 != (c_rgEditActList[lItem].dwFlags & STATE_EXCLUSIVE))
        {
            for (iIndex = 0; iIndex < cItems; iIndex++)
            {
                // We already handled this one
                if (iIndex == nItem)
                {
                    continue;
                }
                
                // Change the state
                lvi.mask = LVIF_STATE;
                lvi.iItem = iIndex;
                lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) :
                                        INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                ListView_SetItem(hwndList, &lvi);

                if (FALSE != fEnabled)
                {
                    // Figure out which action the item corresponds to
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = iIndex;
                    if ((FALSE != ListView_GetItem(hwndList, &lvi)) && 
                            (lvi.lParam >= 0) && (lvi.lParam < c_cEditActList))
                    {
                        m_pDescriptUI->HrEnableActions(c_rgEditActList[lvi.lParam].typeAct, FALSE);
                    }
                }
            }
        }
    }

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitializeCritListCtrl
//
//  This initializes the criteria list view with the list of criteria
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FInitializeCritListCtrl(void)
{
    BOOL                fRet = FALSE;
    LVCOLUMN            lvc = {0};
    RECT                rc = {0};
    HIMAGELIST          himl = NULL;
    LVITEM              lvi = {0};
    TCHAR               szRes[CCHMAX_STRINGRES];
    UINT                uiEditCritList = 0;
    const CRIT_LIST *   pCritList = NULL;
    UINT                cchRes = 0;
    LPTSTR              pszMark = NULL;

    Assert(NULL != m_hwndCrit);

    // Initialize the list view column structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndCrit, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndCrit, 0, &lvc);

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndCrit, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndCrit, LVS_EX_FULLROWSELECT);

    // Initialize the list view item structure
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
    lvi.pszText = szRes;
    
    // Add each criteria to the list view
    for (uiEditCritList = 0; uiEditCritList < ARRAYSIZE(c_rgEditCritList); uiEditCritList++)
    {
        pCritList = &(c_rgEditCritList[uiEditCritList]);

        // Is this item editable
        if (0 != (pCritList->dwFlags & STATE_NOEDIT))
        {
            continue;
        }
        
        // Is this criteria valid for this type of rule?
        if (((RULE_TYPE_MAIL == m_typeRule) && (0 == (pCritList->dwFlags & STATE_MAIL))) ||
                    ((RULE_TYPE_NEWS == m_typeRule) && (0 == (pCritList->dwFlags & STATE_NEWS))) ||
                    ((RULE_TYPE_FILTER == m_typeRule) && (0 == (pCritList->dwFlags & STATE_FILTER))))
        {
            continue;
        }
                    
        // Load up the string to use.
        cchRes = LoadString(g_hLocRes, pCritList->uiText, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            continue;
        }

        // Parse out the string mark
        pszMark = StrStr(szRes, c_szRuleMarkStart);
        
        while (NULL != pszMark)
        {
            // Remove the mark start
            lstrcpy(pszMark, pszMark + lstrlen(c_szRuleMarkStart));

            // Search for the mark end
            pszMark = StrStr(pszMark, c_szRuleMarkEnd);
            if (NULL == pszMark)
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Remove the mark end
            lstrcpy(pszMark, pszMark + lstrlen(c_szRuleMarkEnd));
            
            // Search for the mark start
            pszMark = StrStr(pszMark, c_szRuleMarkStart);
        }
        
        lvi.cchTextMax = lstrlen(szRes);
        lvi.lParam = (LONG) uiEditCritList;

        if (-1 != ListView_InsertItem(m_hwndCrit, &lvi))
        {
            lvi.iItem++;
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadCritListCtrl
//
//  This load the criteria list view with the list of criteria
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FLoadCritListCtrl(INT * piSelect)
{
    BOOL                fRet = FALSE;
    PROPVARIANT         propvar = {0};
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    BOOL                fExclusive = FALSE;
    INT                 cItems = 0;
    LVITEM              lvi = {0};
    ULONG               ulIndex = 0;
    INT                 iSelect = 0;
    DWORD               dwState = 0;
    TCHAR               szRes[CCHMAX_STRINGRES];
    INT                 iItem = 0;
    
    Assert(NULL != m_hwndCrit);
    Assert(NULL != piSelect);

    // Initialize the outgoing param
    *piSelect = 0;

    // Make sure we have something to do...
    if (NULL == m_pIRule)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Get the criteria from the rule
    if (FAILED(m_pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        fRet = TRUE;
        goto exit;
    }

    Assert(NULL != propvar.blob.pBlobData);
    cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
    
    // Do we have any exclusive criteria set?
    if (1 == cCritItem)
    {
        // Find the criteria item in the list
        for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditCritList); ulIndex++)
        {
            // Is this the criteria item?
            if ((pCritItem->type == c_rgEditCritList[ulIndex].typeCrit) &&
                    (0 != (c_rgEditCritList[ulIndex].dwFlags & STATE_EXCLUSIVE)))
            {
                fExclusive = TRUE;
                break;
            }
        }
    }
    
    // Figure out how many items are in the list control
    cItems = ListView_GetItemCount(m_hwndCrit);
    iSelect = cItems;
    
    // Initialize the list view item structure
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    
    // If we're exclusive
    if (FALSE != fExclusive)
    {
        // Disable each of the items
        // except for the exclusive one
        for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
        {
            if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
            {
                continue;
            }

            // Is this the criteria item?
            if (pCritItem->type == c_rgEditCritList[lvi.lParam].typeCrit)
            {
                dwState = INDEXTOSTATEIMAGEMASK(iiconStateChecked+1);
                
                // Is this the first item we found in the list
                if (iSelect > lvi.iItem)
                {
                    iSelect = lvi.iItem;
                }
            }
            else
            {
                dwState = INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1);
            }

            // Set the state
            ListView_SetItemState(m_hwndCrit, lvi.iItem, dwState, LVIS_STATEIMAGEMASK);
        }
    }
    else
    {
        // Add each criteria to the list view
        for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
        {
            // Find the criteria item in the list
            for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
            {
                if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
                {
                    continue;
                }

                // Is this the criteria item?
                if ((pCritItem[ulIndex].type == c_rgEditCritList[lvi.lParam].typeCrit) &&
                        (INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1) == lvi.state))
                {
                    break;
                }
            }

            // Did we find anything?
            if (lvi.iItem >= cItems)
            {
                fRet = FALSE;
                goto exit;
            }

            // Save off the item
            iItem = lvi.iItem;
            
            // Is this the first item we found in the list
            if (iSelect > iItem)
            {
                iSelect = iItem;
            }

#ifdef NEVER
            // Can we add multiple items?
            if (0 == (c_rgEditCritList[lvi.lParam].dwFlags & STATE_NODUPS))
            {
                // Regrab the item
                lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                lvi.pszText = szRes;
                lvi.cchTextMax = sizeof(szRes);

                if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
                {
                    continue;
                }

                // Add the item to the list
                
                // Fix up the item to insert into the list
                lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);

                // Insert the item into the list
                lvi.iItem++;
                if (-1 == ListView_InsertItem(m_hwndCrit, &lvi))
                {
                    fRet = FALSE;
                    goto exit;
                }

                // Add one since we just added an item
                cItems++;
            }
#endif  // NEVER
            
            // Set the state
            ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateChecked+1), LVIS_STATEIMAGEMASK);
        }
    }

    // Set the outgoing param
    *piSelect = iSelect;
    
    // Set the return value
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the view passed in to the list view
//
//  dwIndex - the index on where to add the view to into the list
//  pIRule  - the actual view
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FAddCritToList(INT iItem, BOOL fEnable)
{
    BOOL                fRet = FALSE;
    LVITEM              lvitem = {0};
    TCHAR               szRes[CCHMAX_STRINGRES];
    INT                 cItems = 0;
    LVITEM              lvi = {0};
    DWORD               dwState = 0;

    Assert(NULL != m_hwndCrit);

    // If there's nothing to do...
    if (-1 == iItem)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view item structure
    lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvitem.iItem = iItem;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.pszText = szRes;
    lvitem.cchTextMax = sizeof(szRes);
    
    // Get the item from the list
    if (FALSE == ListView_GetItem(m_hwndCrit, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }

    if (INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1) == lvitem.state)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Do we need to go through and update all the items?
    if (0 != (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_EXCLUSIVE))
    {
        // Figure out how many items are in the list control
        cItems = ListView_GetItemCount(m_hwndCrit);
        
        // Initialize the list view item structure
        lvi.mask = LVIF_PARAM | LVIF_STATE;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        
        // For each item in the list
        for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
        {
            // Get the item from the list
            if (FALSE == ListView_GetItem(m_hwndCrit, &lvi))
            {
                fRet = FALSE;
                goto exit;
            }

            // We'll handle this item later
            if (lvitem.lParam == lvi.lParam)
            {
                iItem = lvi.iItem;
                continue;
            }
            
            // If it's enabled
            if (INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) == lvi.state)
            {
                // Remove it from the criteria
                if (FAILED(m_pDescriptUI->HrEnableCriteria(c_rgEditCritList[lvi.lParam].typeCrit, FALSE)))
                {
                    fRet = FALSE;
                    goto exit;
                }
    
#ifdef NEVER
                // if it allows dups
                if (0 == (c_rgEditCritList[lvi.lParam].dwFlags & STATE_NODUPS))
                {
                    // remove it
                    if (FALSE == ListView_DeleteItem(m_hwndCrit, lvi.iItem))
                    {
                        fRet = FALSE;
                        goto exit;
                    }

                    // Subtract the item
                    cItems--;
                    lvi.iItem--;
                }
                else
#endif  // NEVER
                {
                    // disable
                    ListView_SetItemState(m_hwndCrit, lvi.iItem, INDEXTOSTATEIMAGEMASK(iiconStateDisabled + 1), LVIS_STATEIMAGEMASK);
                }
            }
            else
            {
                if (FALSE == fEnable)
                {
                    dwState = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                }
                else
                {
                    dwState = INDEXTOSTATEIMAGEMASK(iiconStateDisabled + 1);
                }
                
                // uncheck/disable it
                ListView_SetItemState(m_hwndCrit, lvi.iItem, dwState, LVIS_STATEIMAGEMASK);
            }
                                
        }
    }

    // Add/Remove the item from the description
    if (FAILED(m_pDescriptUI->HrEnableCriteria(c_rgEditCritList[lvitem.lParam].typeCrit, fEnable)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FALSE != fEnable)
    {
#ifdef NEVER
        // Can we add another one?
        if (0 == (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_NODUPS))
        {
            // Fix up the item to insert into the list
            lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);

            // Insert the item into the list
            lvitem.iItem++;
            if (-1 == ListView_InsertItem(m_hwndCrit, &lvitem))
            {
                fRet = FALSE;
                goto exit;
            }
        }
#endif  // NEVER
        
        // Set the item to enabled
        ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateChecked+1), LVIS_STATEIMAGEMASK);
    }
    else
    {
#ifdef NEVER
        // Can we remove this one?
        if (0 == (c_rgEditCritList[lvitem.lParam].dwFlags & STATE_NODUPS))
        {
            // Remove the inserted item
            if (FALSE == ListView_DeleteItem(m_hwndCrit, iItem))
            {
                fRet = FALSE;
                goto exit;
            }
        }
        else
#endif  // NEVER
        {
            // Set the item to enabled
            ListView_SetItemState(m_hwndCrit, iItem, INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1), LVIS_STATEIMAGEMASK);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitializeActListCtrl
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditRuleUI::_FInitializeActListCtrl(void)
{
    BOOL                fRet = FALSE;
    LVCOLUMN            lvc;
    RECT                rc;
    HIMAGELIST          himl = NULL;
    HRESULT             hr = S_OK;
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               ulIndex = 0;
    UINT                uiEditActList = 0;
    DWORD               dwIndex = 0;
    const ACT_LIST *    pActList = NULL;
    LVITEM              lvi;
    TCHAR               szRes[CCHMAX_STRINGRES];
    UINT                cchRes = 0;
    LPTSTR              pszMark = NULL;
    BOOL                fEnabled = FALSE;
    BOOL                fExclusive = FALSE;
    PROPVARIANT         propvar;

    Assert(NULL != m_hwndAct);

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndAct, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndAct, 0, &lvc);

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndAct, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndAct, LVS_EX_FULLROWSELECT);

    // Get the list of actions from the rule
    hr = m_pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (SUCCEEDED(hr) && (0 != propvar.blob.cbSize))
    {
        cActItem = propvar.blob.cbSize / sizeof(ACT_ITEM);
        pActItem = (ACT_ITEM *) (propvar.blob.pBlobData);
        propvar.blob.pBlobData = NULL;
        propvar.blob.cbSize = 0;

    }
    
    // Do we have any exclusive actions
    for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
    {
        for (uiEditActList = 0; uiEditActList < ARRAYSIZE(c_rgEditActList); uiEditActList++)
        {
            pActList = &(c_rgEditActList[uiEditActList]);
            if ((pActItem[ulIndex].type == pActList->typeAct) && 
                            (0 != (pActList->dwFlags & STATE_EXCLUSIVE)))
            {
                fExclusive = TRUE;
                break;
            }
        }
    }
        
    // Add the actions to the list view
    for (uiEditActList = 0; uiEditActList < ARRAYSIZE(c_rgEditActList); uiEditActList++)
    {
        pActList = &(c_rgEditActList[uiEditActList]);
        
        // Is this item editable
        if (0 != (pActList->dwFlags & STATE_NOEDIT))
        {
            continue;
        }
        
        // Is this action valid for this type of rule?
        if (((RULE_TYPE_MAIL == m_typeRule) && (0 == (pActList->dwFlags & STATE_MAIL))) ||
                    ((RULE_TYPE_NEWS == m_typeRule) && (0 == (pActList->dwFlags & STATE_NEWS))) ||
                    ((RULE_TYPE_FILTER == m_typeRule) && (0 == (pActList->dwFlags & STATE_FILTER))) ||
                    ((RULE_TYPE_MAIL == m_typeRule) && (0 != (pActList->dwFlags & STATE_JUNK))
                    && (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
             ))
        {
            continue;
        }
                    
                    
        // Is this action enabled?
        fEnabled = FALSE;
        for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
        {
            if (pActItem[ulIndex].type == pActList->typeAct)
            {
                fEnabled = TRUE;
                break;
            }
        }
        
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lvi.iItem = dwIndex;
        lvi.iSubItem = 0;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        if (FALSE != fEnabled)
        {
            lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateChecked+1);
        }
        else
        {
            lvi.state = fExclusive ? INDEXTOSTATEIMAGEMASK(iiconStateDisabled+1)
                                : INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
        }

        // Load up the string to use.
        cchRes = LoadString(g_hLocRes, pActList->uiText, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            continue;
        }

        // Parse out the string mark
        pszMark = StrStr(szRes, c_szRuleMarkStart);
        
        while (NULL != pszMark)
        {
            // Remove the mark start
            lstrcpy(pszMark, pszMark + lstrlen(c_szRuleMarkStart));

            // Search for the mark end
            pszMark = StrStr(pszMark, c_szRuleMarkEnd);
            if (NULL == pszMark)
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Remove the mark end
            lstrcpy(pszMark, pszMark + lstrlen(c_szRuleMarkEnd));
            
            // Search for the mark start
            pszMark = StrStr(pszMark, c_szRuleMarkStart);
        }
        
        lvi.pszText = szRes;
        lvi.cchTextMax = lstrlen(szRes);
        lvi.lParam = (LONG) uiEditActList;

        if (-1 != ListView_InsertItem(m_hwndAct, &lvi))
        {
            dwIndex++;
        }
    }
    
    ListView_SetItemState(m_hwndAct, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

VOID CEditRuleUI::_SetTitleText(VOID)
{
    CHAR    rgchTitle[CCHMAX_STRINGRES];
    UINT    uiID = 0;
    
    // Figure out which string to load
    switch (m_typeRule)
    {
        case RULE_TYPE_MAIL:
            if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewMailRuleTitle;
            }
            else
            {
                uiID = idsEditMailRuleTitle;
            }
            break;

        case RULE_TYPE_NEWS:
            if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewNewsRuleTitle;
            }
            else
            {
                uiID = idsEditNewsRuleTitle;
            }
            break;

        case RULE_TYPE_FILTER:
            if (0 != (m_dwFlags & ERF_CUSTOMIZEVIEW))
            {
                uiID = idsCustomizeViewTitle;
            }
            else if (0 != (m_dwFlags & ERF_NEWRULE))
            {
                uiID = idsNewViewTitle;
            }
            else
            {
                uiID = idsEditViewTitle;
            }
            break;
    }

    // Is there anything to do?
    if (0 == uiID)
    {
        goto exit;
    }
    
    // Load the string
    AthLoadString(uiID, rgchTitle, sizeof(rgchTitle));
    
    // Set the title
    SetWindowText(m_hwndDlg, rgchTitle);

exit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\criteria.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Criteria.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CRITERIA_H_
#define _CRITERIA_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

class COECriteria : public IOECriteria, IPersistStream
{
    private:
        enum {CRIT_COUNT_MIN = 0, CRIT_COUNT_MAX = 0x1000};

        enum {CCH_CRIT_ORDER = 4};
        
        enum {CRIT_VERSION = 0x00050000};
        
    private:
        LONG        m_cRef;
        CRIT_ITEM * m_rgItems;
        ULONG       m_cItems;
        ULONG       m_cItemsAlloc;
        DWORD       m_dwState;
        
    public:
        // Constructor/destructor
        COECriteria() : m_cRef(0), m_rgItems(NULL), m_cItems(0), m_cItemsAlloc(0), m_dwState(0) {}
        ~COECriteria();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOECriteria members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP GetCriteria(DWORD dwFlags, PCRIT_ITEM * ppItem, ULONG * pcItem);
        STDMETHODIMP SetCriteria(DWORD dwFlags, CRIT_ITEM * pItem, ULONG cItem);
        
        STDMETHODIMP Validate(DWORD dwFlags);
        STDMETHODIMP AppendCriteria(DWORD dwFlags, CRIT_LOGIC logic, CRIT_ITEM * pItem,
                                    ULONG cItem, ULONG * pcItemAppended);
        STDMETHODIMP MatchMessage(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                            IMimeMessage * pIMMsg, ULONG cbMsgSize);

        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOECriteria ** ppICriteria);
                                
        // IPersistStream members
        STDMETHODIMP GetClassID(CLSID * pclsid);
        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(IStream * pStm);
        STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }
};

HRESULT HrCreateCriteria(IOECriteria ** ppICriteria);
#endif  // !_CRITERIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\criteria.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Criteria.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "criteria.h"
#include "ruleutil.h"
#include <xpcomm.h>
#include <flagconv.h>
#include <bodyutil.h>
#include <demand.h>

static const int CRIT_GROW = 16;

BOOL FMatchCritItem(CRIT_ITEM * pItem, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                        IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                        IMimeMessage * pIMMsg, ULONG cbMsgSize);
                        
BOOL FCritLoad_Account(IStream * pIStm, PROPVARIANT * ppropvar);
BOOL FCritSave_Account(IStream * pIStm, PROPVARIANT * ppropvar);

BOOL FCritLoad_Default(IStream * pIStm, PROPVARIANT * ppropvar);
BOOL FCritSave_Default(IStream * pIStm, PROPVARIANT * ppropvar);

DWORD DwGetFlagsFromMessage(IMimeMessage * pIMMsg);

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateCriteria
//
//  This creates a criteria container.
//
//  ppICriteria - pointer to return the criteria container
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Criteria object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateCriteria(IOECriteria ** ppICriteria)
{
    COECriteria *   pCriteria = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppICriteria)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppICriteria = NULL;

    // Create the rules manager object
    pCriteria = new COECriteria;
    if (NULL == pCriteria)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pCriteria->QueryInterface(IID_IOECriteria, (void **) ppICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }

    pCriteria = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pCriteria)
    {
        delete pCriteria;
    }
    
    return hr;
}

COECriteria::~COECriteria()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    Reset();
}

STDMETHODIMP_(ULONG) COECriteria::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COECriteria::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COECriteria::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOECriteria))
    {
        *ppvObject = static_cast<IOECriteria *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::Reset(void)
{
    HRESULT     hr = S_OK;

    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    RuleUtil_HrFreeCriteriaItem(m_rgItems, m_cItems);
    SafeMemFree(m_rgItems);
    m_cItems = 0;
    m_cItemsAlloc = 0;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    DWORD       dwState = CRIT_STATE_NULL;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init the outgoing param
    *pdwState = CRIT_STATE_NULL;
    
    // See if there is something to do
    if (0 == m_cItems)
    {
        Assert(NULL == m_rgItems);
        hr = S_OK;
        goto exit;
    }

    // Walk through the actions to figure out the state
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if ((CRIT_TYPE_SECURE == m_rgItems[ulIndex].type) ||
                (CRIT_TYPE_BODY == m_rgItems[ulIndex].type) ||
                (CRIT_TYPE_ATTACH == m_rgItems[ulIndex].type))
        {
            dwState = CRIT_STATE_ALL;
        }
        else if (CRIT_STATE_ALL != dwState)
        {
            dwState = CRIT_STATE_HEADER;
        }
    }

    // Set the outgoing param
    *pdwState = dwState;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::GetCriteria(DWORD dwFlags, PCRIT_ITEM * ppItem, ULONG * pcItem)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming params
    if ((NULL == ppItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the out params
    *ppItem = NULL;
    if (NULL != pcItem)
    {
        *pcItem = 0;
    }
    
    // If we don't have any criteria, then return
    if (0 == m_cItems)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupCriteriaItem(m_rgItems, m_cItems, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    *ppItem = pItemNew;
    pItemNew = NULL;
    if (NULL != pcItem)
    {
        *pcItem = m_cItems;
    }
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItemNew, m_cItems);
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COECriteria::SetCriteria(DWORD dwFlags, CRIT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem) || (0 != dwFlags))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // If we have any criteria already, then reset
    if (0 != m_cItems)
    {
        Reset();
    }

    // Allocate space for the criteria
    hr = RuleUtil_HrDupCriteriaItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the criteria
    m_rgItems = pItemNew;
    pItemNew = NULL;
    m_cItems = cItem;
    m_cItemsAlloc = cItem;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItemNew, cItem);
    SafeMemFree(pItemNew);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ValidateCriteria
//
//  This verifies each of the criteria values
//
//  Returns:    S_OK, if the criteria were valid
//              S_FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COECriteria::Validate(DWORD dwFlags)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    LPSTR               pszText = NULL;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    LPTSTR              pszWalk = NULL;
    ULONG               cchText = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    // If we don't have any criteria, then we must be valid
    if (0 == m_cItems)
    {
        hr = S_OK;
        goto exit;
    }

    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        if (0 != (m_rgItems[ulIndex].dwFlags & ~(CRIT_FLAG_INVERT | CRIT_FLAG_MULTIPLEAND)))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        switch(m_rgItems[ulIndex].type)
        {
            case CRIT_TYPE_NEWSGROUP:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (m_rgItems[ulIndex].propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Does the folder exist
                hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }        
                
                // Are we subscribed?
                if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
                {
                    hr = S_FALSE;
                    goto exit;
                }                    
                break;
                
            case CRIT_TYPE_ALL:
            case CRIT_TYPE_JUNK:
            case CRIT_TYPE_READ:
            case CRIT_TYPE_REPLIES:
            case CRIT_TYPE_DOWNLOADED:
            case CRIT_TYPE_DELETED:
            case CRIT_TYPE_ATTACH:
            case CRIT_TYPE_FLAGGED:
                if (VT_EMPTY != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_SUBJECT:
            case CRIT_TYPE_BODY:
            case CRIT_TYPE_TO:
            case CRIT_TYPE_CC:
            case CRIT_TYPE_TOORCC:
            case CRIT_TYPE_FROM:
                if ((VT_BLOB != m_rgItems[ulIndex].propvar.vt) ||
                    (0 == m_rgItems[ulIndex].propvar.blob.cbSize) ||
                    (NULL == m_rgItems[ulIndex].propvar.blob.pBlobData) ||
                    ('\0' == m_rgItems[ulIndex].propvar.blob.pBlobData[0]))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Spin through each item making sure it is perfect
                cchText = 0;
                for (pszWalk = (LPTSTR) m_rgItems[ulIndex].propvar.blob.pBlobData;
                '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
                {
                    cchText += lstrlen(pszWalk) + 1;
                }
                
                // For the terminator
                if ('\0' == pszWalk[0])
                {
                    cchText++;
                }
                if ('\0' == pszWalk[1])
                {
                    cchText++;
                }
                
                if (cchText != m_rgItems[ulIndex].propvar.blob.cbSize)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_SIZE:
            case CRIT_TYPE_THREADSTATE:
            case CRIT_TYPE_LINES:
            case CRIT_TYPE_PRIORITY:
            case CRIT_TYPE_AGE:
            case CRIT_TYPE_SECURE:
                if (VT_UI4 != m_rgItems[ulIndex].propvar.vt)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
                
            case CRIT_TYPE_ACCOUNT:
                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                
                Assert(g_pAcctMan);
                if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_rgItems[ulIndex].propvar.pszVal, &pAccount)))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                SafeRelease(pAccount);
                break;
                
            case CRIT_TYPE_SENDER:
            {
                LPWSTR  pwszText = NULL,
                        pwszVal = NULL;

                if ((VT_LPSTR != m_rgItems[ulIndex].propvar.vt) ||
                    (NULL == m_rgItems[ulIndex].propvar.pszVal))
                {
                    AssertSz(VT_LPWSTR != m_rgItems[ulIndex].propvar.vt, "We are getting UNICODE here.");
                    hr = S_FALSE;
                    goto exit;
                }
                
                // Verify the email string
                pwszVal = PszToUnicode(CP_ACP, m_rgItems[ulIndex].propvar.pszVal);
                if (!pwszVal)
                {
                    hr = S_FALSE;
                    goto exit;
                }
                hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
                MemFree(pwszText);
                MemFree(pwszVal);
                if (FAILED(hr))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            }
                
            default:
                hr = S_FALSE;
                goto exit;
                break;
        }
    }

    // If we got here, then we must be AOK
    hr = S_OK;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    return hr;
}

STDMETHODIMP COECriteria::AppendCriteria(DWORD dwFlags, CRIT_LOGIC logic,
                            CRIT_ITEM * pItem, ULONG cItem, ULONG * pcItemAppended)
{
    HRESULT     hr = S_OK;
    CRIT_ITEM * pItemNew = NULL;

    // Check incoming parameters
    if ((0 != dwFlags) || (CRIT_LOGIC_NULL == logic) || (NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's init our outgoing parameters
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = 0;
    }

    // Do we have to add more items?
    if (m_cItems == m_cItemsAlloc)
    {
        hr = HrRealloc((LPVOID *) &m_rgItems, sizeof(CRIT_ITEM) * (m_cItemsAlloc + CRIT_GROW));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(m_rgItems + m_cItemsAlloc, sizeof(CRIT_ITEM) * CRIT_GROW);
        m_cItemsAlloc += CRIT_GROW;
    }

    // Let's duplicate the items that need to be added
    hr = RuleUtil_HrDupCriteriaItem(pItem, cItem, &pItemNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Let's add them to the criteria array
    if (0 != m_cItems)
    {
        m_rgItems[m_cItems - 1].logic = logic;
    }
    CopyMemory(m_rgItems + m_cItems, pItemNew, sizeof(CRIT_ITEM) * cItem);
    m_cItems += cItem;
    
    // Set the proper outgoing parameter
    if (NULL != pcItemAppended)
    {
        *pcItemAppended = cItem;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pItemNew);
    return hr;
}

STDMETHODIMP COECriteria::MatchMessage(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                        IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    BOOL        fResult = FALSE;
    BOOL        fResultNew = FALSE;
    CRIT_LOGIC  logic;

    // Check incoming parameters
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || (0 == cbMsgSize))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Let's go through the criteria and see if we match
    fResult = FALSE;
    logic = CRIT_LOGIC_OR;
    for (ulIndex = 0; ulIndex < m_cItems; ulIndex++)
    {
        // Call matching function for this criteria item
        fResultNew = FMatchCritItem(&(m_rgItems[ulIndex]), pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize);
        
        // Slap it together with the old result
        if (CRIT_LOGIC_AND == logic)
        {
            fResult = (fResult && fResultNew);
        }
        else
        {
            Assert(CRIT_LOGIC_OR == logic);
            fResult = (fResult || fResultNew);
        }
        
        // Save of the next logical operation
        logic = m_rgItems[ulIndex].logic;
    }
    
    // Set the proper return value
    hr = (FALSE != fResult) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  LoadReg
//
//  This loads in the criteria from the registry.  It loads in the criteria
//  order from the Order value.  The string contains space delimitied values
//  and each value contains the subkey name for each criterion.  Each criterion 
//  is loaded in the order that is contained in the Order value.  The criterion
//  are loaded with the Criterion Type and Logical Operator.  The Criterion Value
//  Type is loaded if it exists.  If a Criterion Value Type exists, then the 
//  corresponding Criterion Value is loaded in.
//
//  pszRegPath  - the path to load the criteria from
//
//  Returns:    S_OK, if the criteria was loaded without problems
//              E_OUTOFMEMORY, if we couldn't allocate memory to hold the criteria
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP COECriteria::LoadReg(LPCSTR pszRegPath)
{
    HRESULT         hr = S_OK;
    LONG            lErr = 0;
    HKEY            hkeyRoot = NULL;
    ULONG           cbData = 0;
    LPSTR           pszOrder = NULL;
    ULONG           cOrder = 0;
    LPSTR           pszWalk = NULL;
    CRIT_ITEM *     pItems = NULL;
    LPSTR           pszNext = NULL;
    ULONG           ulOrder = 0;
    HKEY            hkeyCriteria = NULL;
    CRIT_TYPE       typeCrit;
    CRIT_LOGIC      logicCrit;
    PROPVARIANT     propvar;
    DWORD           dwType = 0;
    BYTE *          pbData = NULL;
    DWORD           dwFlags = CRIT_FLAG_DEFAULT;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & CRIT_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the criteria order
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szCriteriaOrder, NULL, (BYTE **) &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Make sure we actually have something to load
    if ('\0' == *pszOrder)
    {
        AssertSz(FALSE, "The order string for the criteria is mis-formatted in the registry");
        hr = E_FAIL;
        goto exit;
    }
    
    // Convert the criteria string to a more useful format
    pszWalk = pszOrder;
    cOrder = 1;
    for (pszWalk = StrStr(pszOrder, g_szSpace); NULL != pszWalk; pszWalk = StrStr(pszWalk, g_szSpace))
    {
        // Terminate the order item
        *pszWalk = '\0';
        pszWalk++;
        cOrder++;
    }


    // Allocate the space to hold all the criteria
    hr = HrAlloc((void **) &pItems, cOrder * sizeof(CRIT_ITEM));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pItems, cOrder * sizeof(CRIT_ITEM));
    
    // For each criteria in the order string
    pszWalk = pszOrder;
    for (ulOrder = 0, pszWalk = pszOrder; ulOrder < cOrder; ulOrder++, pszWalk += lstrlen(pszWalk) + 1)
    {
        // Open up the criteria reg key
        lErr = RegOpenKeyEx(hkeyRoot, pszWalk, 0, KEY_READ, &hkeyCriteria);
        if (ERROR_SUCCESS != lErr)
        {
            AssertSz(FALSE, "Part of the criteria is mis-formatted in the registry");
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria type
        cbData = sizeof(typeCrit);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaType, 0, NULL,
                                        (BYTE *) &(typeCrit), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria logicial op
        cbData = sizeof(logicCrit);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaLogic, 0, NULL,
                                        (BYTE *) &(logicCrit), &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get the criteria flags
        cbData = sizeof(dwFlags);
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaFlags, 0, NULL,
                                        (BYTE *) &(dwFlags), &cbData);
        if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
        {
            hr = E_FAIL;
            goto exit;
        }

        // If it didn't exist then assign it to the default
        if (ERROR_FILE_NOT_FOUND == lErr)
        {
            dwFlags = CRIT_FLAG_DEFAULT;
        }

        // Initialize the new space to a known value
        ZeroMemory(&propvar, sizeof(propvar));
        
        // Does a criteria value type exist
        lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValueType, 0, NULL, NULL, &cbData);
        if ((ERROR_SUCCESS == lErr) && (0 != cbData))
        {
            
            // Load the criteria value in
            cbData = sizeof(dwType);
            lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValueType, 0, NULL,
                                            (BYTE *) &dwType, &cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            propvar.vt = (VARTYPE) dwType;
            
            switch (propvar.vt)
            {
                case VT_UI4:
                    // Get the criteria value
                    cbData = sizeof(propvar.ulVal);
                    lErr = RegQueryValueEx(hkeyCriteria, c_szCriteriaValue, 0, NULL,
                        (BYTE * ) &(propvar.ulVal), &cbData);
                    if (ERROR_SUCCESS != lErr)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                    break;
                    
                case VT_LPSTR:
                case VT_BLOB:
                    // Get the criteria value
                    hr = RuleUtil_HrGetRegValue(hkeyCriteria, c_szCriteriaValue, NULL, (BYTE **) &pbData, &cbData);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Save the space so we can free it
                    if (VT_LPSTR == propvar.vt)
                    {
                        propvar.pszVal = (LPSTR) pbData;
                    }
                    else
                    {
                        propvar.blob.cbSize = cbData;
                        propvar.blob.pBlobData = pbData;
                    }
                    
                    pbData = NULL;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we loading in a invalid criteria type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }

        }

        // Save the value into the criteria array
        pItems[ulOrder].type = typeCrit;
        pItems[ulOrder].dwFlags = dwFlags;
        pItems[ulOrder].logic = logicCrit;
        pItems[ulOrder].propvar = propvar;
        
        // Close the criteria
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyCriteria));
        hkeyCriteria = NULL;        
    }
    
    // Free up the current criteria
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cOrder;

    // Make sure we clear the dirty bit
    m_dwState &= ~CRIT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= CRIT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pbData);
    RuleUtil_HrFreeCriteriaItem(pItems, cOrder);
    SafeMemFree(pItems);
    SafeMemFree(pszOrder);
    if (NULL != hkeyCriteria)
    {
        RegCloseKey(hkeyCriteria);
    }
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COECriteria::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LPSTR       pszOrder = NULL;
    ULONG       ulIndex = 0;
    CRIT_ITEM * pItem = NULL;
    CHAR        rgchTag[CCH_CRIT_ORDER];
    HKEY        hkeyCriteria = NULL;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If there's nothing to save, then fail
    if (NULL == m_rgItems)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
    Assert(m_cItems < CRIT_COUNT_MAX);

    // Allocate space to hold the order
    hr = HrAlloc((void **) &pszOrder, m_cItems * CCH_CRIT_ORDER * sizeof(*pszOrder));
    if (FAILED(hr))
    {
        goto exit;
    }
    pszOrder[0] = '\0';
    
    // Write out each of the criteria
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Get the new criteria tag
        wsprintf(rgchTag, "%03X", ulIndex);

        // Add the new tag to the order
        if (0 != ulIndex)
        {
            lstrcat(pszOrder, g_szSpace);
        }
        lstrcat(pszOrder, rgchTag);
        
        // Create the new criteria
        lErr = RegCreateKeyEx(hkeyRoot, rgchTag, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyCriteria, &dwDisp);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        Assert(REG_CREATED_NEW_KEY == dwDisp);
        
        // Write out the criteria type
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaType, 0, REG_DWORD,
                                        (BYTE *) &(pItem->type), sizeof(pItem->type));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the criteria logicial op
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaLogic, 0, REG_DWORD,
                                        (BYTE *) &(pItem->logic), sizeof(pItem->logic));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Write out the criteria flags
        lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaFlags, 0, REG_DWORD,
                                        (BYTE *) &(pItem->dwFlags), sizeof(pItem->dwFlags));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Do we have a criteria value?
        if (VT_EMPTY != pItem->propvar.vt)
        {
            // Write out the criteria value type
            dwDisp = pItem->propvar.vt;
            lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwDisp, sizeof(dwDisp));
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
            
            // Write out the criteria value
            switch (pItem->propvar.vt)
            {
                case VT_UI4:
                    dwDisp = REG_DWORD;
                    pbData = (BYTE * ) &(pItem->propvar.ulVal);
                    cbData = sizeof(pItem->propvar.ulVal);
                    break;
                    
                case VT_LPSTR:
                    dwDisp = REG_SZ;
                    pbData = (BYTE * ) (pItem->propvar.pszVal);
                    cbData = lstrlen(pItem->propvar.pszVal) + 1;
                    break;
                    
                case VT_BLOB:
                    dwDisp = REG_BINARY;
                    pbData = pItem->propvar.blob.pBlobData;
                    cbData = pItem->propvar.blob.cbSize;
                    break;
                    
                default:
                    AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
                    hr = E_FAIL;
                    goto exit;
                    break;                
            }
            
            // Write out the criteria value
            lErr = RegSetValueEx(hkeyCriteria, c_szCriteriaValue, 0, dwDisp, pbData, cbData);
            if (ERROR_SUCCESS != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }
        }

        // Close the criteria
        SideAssert(ERROR_SUCCESS == RegCloseKey(hkeyCriteria));
        hkeyCriteria = NULL;        
    }

    // Write out the order string.
    lErr = RegSetValueEx(hkeyRoot, c_szCriteriaOrder, 0, REG_SZ,
                                    (BYTE *) pszOrder, lstrlen(pszOrder) + 1);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~CRIT_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyCriteria)
    {
        RegCloseKey(hkeyCriteria);
    }
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COECriteria::Clone(IOECriteria ** ppICriteria)
{
    HRESULT         hr = S_OK;
    COECriteria *   pCriteria = NULL;
    
    // Check incoming params
    if (NULL == ppICriteria)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppICriteria = NULL;
    
    // Create a new criteria
    pCriteria = new COECriteria;
    if (NULL == pCriteria)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the list of criteria
    hr = pCriteria->SetCriteria(0, m_rgItems, m_cItems);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria interface
    hr = pCriteria->QueryInterface(IID_IOECriteria, (void **) ppICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }

    pCriteria = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pCriteria)
    {
        delete pCriteria;
    }
    return hr;
}

STDMETHODIMP COECriteria::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OECriteria;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COECriteria::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (CRIT_STATE_DIRTY == (m_dwState & CRIT_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COECriteria::Load(IStream * pStm)
{
    HRESULT         hr = S_OK;
    ULONG           cbData = 0;
    ULONG           cbRead = 0;
    DWORD           dwData = 0;
    ULONG           cItems = 0;
    CRIT_ITEM *     pItems = NULL;
    ULONG           ulIndex = 0;
    CRIT_ITEM *     pItem = NULL;
    CRIT_TYPE       typeCrit;
    CRIT_LOGIC      logicCrit;
    DWORD           dwFlags = CRIT_FLAG_DEFAULT;
    PROPVARIANT     propvar = {0};
    BYTE *          pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != CRIT_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the number of criteria
    hr = pStm->Read(&cItems, sizeof(cItems), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(cItems)) || (0 == cItems))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate space to hold all the criteria
    hr = HrAlloc( (void **) &pItems, cItems * sizeof(*pItems));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the criteria to a known value
    ZeroMemory(pItems, cItems * sizeof(*pItems));
    
    // for each criteria
    for (ulIndex = 0, pItem = pItems; ulIndex < cItems; ulIndex++, pItem++)
    {
        // Read in the criteria type
        hr = pStm->Read(&typeCrit, sizeof(typeCrit), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(typeCrit)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the criteria logical op
        hr = pStm->Read(&logicCrit, sizeof(logicCrit), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(logicCrit)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the criteria flags
        hr = pStm->Read(&dwFlags, sizeof(dwFlags), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(dwFlags)))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Read in the proper criteria value
        switch(typeCrit)
        {
            case CRIT_TYPE_ACCOUNT:
                if (FALSE == FCritLoad_Account(pStm, &propvar))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
                
            default:
                if (FALSE == FCritLoad_Default(pStm, &propvar))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
        }

        // Assign the values
        pItem->type = typeCrit;
        pItem->logic = logicCrit;
        pItem->dwFlags = dwFlags;
        pItem->propvar = propvar;
        ZeroMemory(&propvar, sizeof(propvar));
    }

    // Free up the current criteria
    SafeMemFree(m_rgItems);

    // Save the new values
    m_rgItems = pItems;
    pItems = NULL;
    m_cItems = cItems;

    // Make sure we clear the dirty bit
    m_dwState &= ~CRIT_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= CRIT_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pItems, cItems);
    SafeMemFree(pItems);
    PropVariantClear(&propvar);
    return hr;
}

STDMETHODIMP COECriteria::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    ULONG       cbData = 0;
    ULONG       cbWritten = 0;
    DWORD       dwData = 0;
    ULONG       ulIndex = 0;
    CRIT_ITEM * pItem = NULL;
    BYTE *      pbData = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Write out the version
    dwData = CRIT_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the count of criteria
    hr = pStm->Write(&m_cItems, sizeof(m_cItems), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(m_cItems));
    
    // Loop through each of the criteria
    for (ulIndex = 0, pItem = m_rgItems; ulIndex < m_cItems; ulIndex++, pItem++)
    {
        // Write out the criteria type
        hr = pStm->Write(&(pItem->type), sizeof(pItem->type), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->type));

        // Write out the criteria logical op
        hr = pStm->Write(&(pItem->logic), sizeof(pItem->logic), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->logic));

        // Write out the criteria flags
        hr = pStm->Write(&(pItem->dwFlags), sizeof(pItem->dwFlags), &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == sizeof(pItem->dwFlags));
        
        // Write out the proper criteria value
        switch(pItem->type)
        {
            case CRIT_TYPE_ACCOUNT:
                if (FALSE == FCritSave_Account(pStm, &(pItem->propvar)))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
                
            default:
                if (FALSE == FCritSave_Default(pStm, &(pItem->propvar)))
                {
                    hr = E_FAIL;
                    goto exit;
                }
                break;
        }

    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~CRIT_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

BOOL CritFunc_Query(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet);
BOOL CritFunc_Text(CRIT_ITEM * pItem, LPSTR pszText);
BOOL CritFunc_Sender(CRIT_ITEM * pItem, LPSTR pszAddr);
BOOL CritFunc_Priority(CRIT_ITEM * pItem, WORD wPriority);
BOOL CritFunc_Secure(CRIT_ITEM * pItem, DWORD dwFlags);
BOOL CritFunc_Age(CRIT_ITEM * pItem, FILETIME * pftSent);
BOOL CritFunc_Body(CRIT_ITEM * pItem, IMimeMessage * pIMMsg);
BOOL _FMatchBlobString(CRIT_ITEM * pItem, LPSTR pszText);
BOOL _FQueryBlobString(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet);

BOOL FMatchCritItem(CRIT_ITEM * pItem, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                        IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                        IMimeMessage * pIMMsg, ULONG cbMsgSize)
{
    BOOL                fRet = FALSE;
    ULONG               ulIndex = 0;
    PROPVARIANT         propvar = {0};
    ADDRESSLIST         addrList = {0};
    FOLDERID            idFolder = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    Assert((NULL != pItem) && ((NULL != pMsgInfo) || (NULL != pIMPropSet)) && (0 != cbMsgSize))

    switch (pItem->type)
    {
        case CRIT_TYPE_ALL:
            Assert(VT_EMPTY == pItem->propvar.vt);
            fRet = TRUE;
            break;

        case CRIT_TYPE_ACCOUNT:
            Assert(VT_LPSTR == pItem->propvar.vt);
            fRet = FALSE;
            if ((NULL != pszAcct) && (NULL != pItem->propvar.pszVal))
            {
                fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAcct));
            }
            break;

        case CRIT_TYPE_NEWSGROUP:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            if ((NULL != pFolder) && (0 != pItem->propvar.blob.cbSize))
            {
                // Make life simpler
                prfdData = (RULEFOLDERDATA *) (pItem->propvar.blob.pBlobData);
                
                // Validate the rule folder data
                if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
                {
                    fRet = FALSE;
                }
                else if (SUCCEEDED(pFolder->GetFolderId(&idFolder)))
                {
                    fRet = (idFolder == prfdData->idFolder);
                }
            }
            break;

        case CRIT_TYPE_SIZE:
            Assert(VT_UI4 == pItem->propvar.vt);
            // Set the size of the message to Kilobytes
            cbMsgSize = cbMsgSize / 1024;
            
            fRet = (cbMsgSize > pItem->propvar.ulVal);
            break;

        case CRIT_TYPE_LINES:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            if (NULL != pMsgInfo)
            {
                fRet = (pMsgInfo->cLines > pItem->propvar.ulVal);
            }
            break;

        case CRIT_TYPE_AGE:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Age(pItem, &(pMsgInfo->ftSent));
            }
            else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &propvar))))
            {
                fRet = CritFunc_Age(pItem, &(propvar.filetime));
            }
            break;

        case CRIT_TYPE_ATTACH:
            Assert(VT_EMPTY == pItem->propvar.vt);
            fRet = TRUE;
            
            if (NULL != pMsgInfo)
            {
                fRet = (0 != (pMsgInfo->dwFlags & ARF_HASATTACH));
            }
            else if (NULL != pIMMsg)
            {
                fRet = (0 != (DwGetFlagsFromMessage(pIMMsg) & ARF_HASATTACH));
            }
            break;

        case CRIT_TYPE_PRIORITY:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Priority(pItem, pMsgInfo->wPriority);
            }
            else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &propvar))))
            {
                fRet = CritFunc_Priority(pItem, (WORD) (propvar.ulVal));
            }
            break;

        case CRIT_TYPE_SECURE:
            Assert(VT_UI4 == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pMsgInfo)
            {
                fRet = CritFunc_Secure(pItem, pMsgInfo->dwFlags);
            }
            else if (NULL != pIMMsg)
            {
                fRet = CritFunc_Secure(pItem, DwGetFlagsFromMessage(pIMMsg));
            }
            break;

        case CRIT_TYPE_TOORCC:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if (NULL != pIMPropSet)
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_TO), pIMPropSet);

                if (((0 != (pItem->dwFlags & CRIT_FLAG_INVERT)) && (FALSE != fRet)) ||
                            ((0 == (pItem->dwFlags & CRIT_FLAG_INVERT)) && (FALSE == fRet)))
                {
                    fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_CC), pIMPropSet);
                }
            }
            break;

        case CRIT_TYPE_SENDER:
            Assert(VT_LPSTR == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((NULL == pItem->propvar.pszVal) || ('\0' == pItem->propvar.pszVal[0]))
            {
                Assert(FALSE);
            }
            else if (S_OK == RuleUtil_HrMatchSender(pItem->propvar.pszVal, pMsgInfo, pIMMsg, pIMPropSet))
            {                
                fRet = TRUE;
            }
            break;

        case CRIT_TYPE_SUBJECT:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszSubject))
            {
                fRet = _FMatchBlobString(pItem, pMsgInfo->pszSubject);
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_SUBJECT), pIMPropSet);
            }
            break;

        case CRIT_TYPE_BODY:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if (NULL != pIMMsg)
            {
                fRet = CritFunc_Body(pItem, pIMMsg);
            }
            break;

        case CRIT_TYPE_FROM:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszFromHeader))
            {
                fRet = _FMatchBlobString(pItem, pMsgInfo->pszFromHeader);
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_FROM), pIMPropSet);
            }
            break;

        case CRIT_TYPE_TO:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_TO), pIMPropSet);
            }
            break;
            
        case CRIT_TYPE_CC:
            Assert(VT_BLOB == pItem->propvar.vt);
            fRet = FALSE;
            
            if ((0 == pItem->propvar.blob.cbSize) ||
                        (NULL == pItem->propvar.blob.pBlobData) ||
                        ('\0' == pItem->propvar.blob.pBlobData[0]))
            {
                Assert(FALSE);
                fRet = FALSE;
            }
            else
            {
                fRet = _FQueryBlobString(pItem, PIDTOSTR(PID_HDR_CC), pIMPropSet);
            }
            break;
            
        default:
            fRet = FALSE;
            break;
    }
    
    PropVariantClear(&propvar);
    return fRet;
}

BOOL CritFunc_Query(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    LPSTR           pszAddr = NULL;
    LPSTR           pszTerm = NULL;
    HRESULT         hr = S_OK;

    if (NULL == pIMPropSet)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Dup the string
    pszAddr = PszDupA(pItem->propvar.pszVal);
    if (NULL == pszAddr)
    {
        fRet = FALSE;
        goto exit;
    }

    pszWalk = pszAddr;
    pszTerm = pszWalk;
    while (NULL != pszTerm)
    {
        pszTerm = StrStr(pszWalk, g_szComma);
        if (NULL != pszTerm)
        {
            pszTerm[0] = '\0';
        }

        fRet = (S_OK == pIMPropSet->QueryProp(pszQuery, pszWalk, TRUE, FALSE));
        
        if (FALSE == fRet)
        {
            break;
        }

        pszWalk = pszWalk + lstrlen(pszWalk) + 1;
    }

exit:
    SafeMemFree(pszAddr);
    return fRet;
}

BOOL CritFunc_Priority(CRIT_ITEM * pItem, WORD wPriority)
{
    BOOL    fRet = FALSE;

    Assert(NULL != pItem);
    Assert(VT_UI4 == pItem->propvar.vt);
    
    if (CRIT_DATA_HIPRI == pItem->propvar.ulVal)
    {
        fRet = (wPriority == (WORD) IMSG_PRI_HIGH);
    }
    else if (CRIT_DATA_LOPRI == pItem->propvar.ulVal)
    {
        fRet = (wPriority == (WORD) IMSG_PRI_LOW);
    }
    else
    {
        fRet = (wPriority == (WORD) IMSG_PRI_NORMAL);
    }

    return fRet;
}

BOOL CritFunc_Secure(CRIT_ITEM * pItem, DWORD dwFlags)
{
    BOOL    fRet = FALSE;

    Assert(NULL != pItem);
    Assert(VT_UI4 == pItem->propvar.vt);
    
    // Should we be checking signed messages
    if (0 != (pItem->propvar.ulVal & CRIT_DATA_SIGNEDSECURE))
    {
        fRet = (0 != (dwFlags & ARF_SIGNED));
    }
    else if (0 != (pItem->propvar.ulVal & CRIT_DATA_ENCRYPTSECURE))
    // Should we be checking encrypted messages
    {
        fRet = (0 != (dwFlags & ARF_ENCRYPTED));
    }
    else
    {
        fRet = (0 == (dwFlags & (ARF_ENCRYPTED | ARF_SIGNED)));
    }

    return fRet;
}

BOOL CritFunc_Age(CRIT_ITEM * pItem, FILETIME * pftSent)
{
    BOOL        fRet = FALSE;
    SYSTEMTIME  sysTime = {0};
    FILETIME    ftTime = {0};
    ULONG       ulSeconds;

    Assert(VT_UI4 == pItem->propvar.vt);
    
    if ((NULL == pftSent) || ((0 == pftSent->dwLowDateTime) && (0 == pftSent->dwHighDateTime)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the current time
    GetSystemTime(&sysTime);
    SystemTimeToFileTime(&sysTime, &ftTime);

    ulSeconds = UlDateDiff(pftSent, &ftTime);
    fRet = ((ulSeconds / SECONDS_INA_DAY) > pItem->propvar.ulVal);

exit:
    return fRet;
}

BOOL CritFunc_Sender(CRIT_ITEM * pItem, LPSTR pszAddr)
{
    BOOL    fRet = FALSE;
    ULONG   cchVal = 0;
    ULONG   cchEmail = 0;
    CHAR    chTest = 0;

    Assert(VT_LPSTR == pItem->propvar.vt);
    
    // Check to make sure that there's something to match
    if ((NULL == pszAddr) || ('\0' == pszAddr[0]))
    {
        fRet = FALSE;
        goto exit;
    }

    // Check to see if it is an address
    if (NULL != StrStr(pItem->propvar.pszVal, "@"))
    {
        fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAddr));
    }
    else
    {
        cchVal = lstrlen(pItem->propvar.pszVal);
        cchEmail = lstrlen(pszAddr);
        if (cchVal <= cchEmail)
        {
            fRet = (0 == lstrcmpi(pItem->propvar.pszVal, pszAddr + (cchEmail - cchVal)));
            if ((FALSE != fRet) && (cchVal != cchEmail))
            {
                chTest = *(pszAddr + (cchEmail - cchVal - 1));
                if (('@' != chTest) && ('.' != chTest))
                {
                    fRet = FALSE;
                }
            }
        }
    }

exit:
    return fRet;
}

BOOL _FMatchBlobString(CRIT_ITEM * pItem, LPSTR pszText)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    
    // Walk each of the strings looking for a match    
    for (pszWalk = (LPSTR) (pItem->propvar.blob.pBlobData); '\0' != pszWalk[0];
                pszWalk = pszWalk + lstrlen(pszWalk) + 1)
    {
        // Do the comparison
        fRet = (NULL != StrStrI(pszText, pszWalk));

        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

    return fRet;
}

BOOL _FQueryBlobString(CRIT_ITEM * pItem, LPCSTR pszQuery, IMimePropertySet * pIMPropSet)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;

    if (NULL == pIMPropSet)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Walk each of the strings looking for a match    
    for (pszWalk = (LPSTR) (pItem->propvar.blob.pBlobData); '\0' != pszWalk[0];
                pszWalk = pszWalk + lstrlen(pszWalk) + 1)
    {
        // Do the comparison
        fRet = (S_OK == pIMPropSet->QueryProp(pszQuery, pszWalk, TRUE, FALSE));

        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

exit:
    return fRet;
}

BOOL CritFunc_Text(CRIT_ITEM * pItem, LPSTR pszText)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    LPSTR           pszAddr = NULL;
    LPSTR           pszTerm = NULL;
    
    // Dup the string
    pszAddr = PszDupA(pItem->propvar.pszVal);
    if (NULL == pszAddr)
    {
        fRet = FALSE;
        goto exit;
    }

    pszWalk = pszAddr;
    pszTerm = pszWalk;
    while (NULL != pszTerm)
    {
        pszTerm = StrStr(pszWalk, g_szComma);
        if (NULL != pszTerm)
        {
            pszTerm[0] = '\0';
        }
        
        fRet = (NULL != StrStrI(pszText, pszWalk));

        if (FALSE == fRet)
        {
            break;
        }

        pszWalk = pszWalk + lstrlen(pszWalk) + 1;
    }

exit:
    SafeMemFree(pszAddr);
    return fRet;
}

BOOL CritFunc_Body(CRIT_ITEM * pItem, IMimeMessage * pIMMsg)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;
    IStream *       pStream = NULL;
    IStream *       pStreamHtml = NULL;
    
    pszWalk = (LPTSTR) (pItem->propvar.blob.pBlobData);
    if (NULL == pszWalk)
    {
        fRet = FALSE;
        goto exit;
    }

    // Try to Get the Plain Text Stream
    if (FAILED(pIMMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
    {
        // Try to get the HTML stream and convert it to text...
        if (SUCCEEDED(pIMMsg->GetTextBody(TXT_HTML, IET_DECODED, &pStreamHtml, NULL)))
        {
            if (FAILED(HrConvertHTMLToPlainText(pStreamHtml, &pStream, CF_TEXT)))
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }

    if (NULL == pStream)
    {
        fRet = FALSE;
        goto exit;
    }
    
    for (; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        fRet = StreamSubStringMatch(pStream, pszWalk);
        
        // If we are doing an AND of the multiple criteria
        if (0 != (pItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
        {
            // if we don't have a match, then we're done
            if (FALSE == fRet)
            {
                break;
            }
        }
        else
        {
            // if we do have a match, then we're done
            if (FALSE != fRet)
            {
                break;
            }
        }
    }

    // Invert the result if needed
    if (0 != (pItem->dwFlags & CRIT_FLAG_INVERT))
    {
        fRet = !fRet;
    }

exit:
    SafeRelease(pStreamHtml);
    SafeRelease(pStream);
    return fRet;
}

BOOL FCrit_GetAcctInfo(DWORD dwServerTypes, DWORD * pdwServerType, DWORD * pdwPropTag)
{
    BOOL    fRet = FALSE;

    Assert((NULL != pdwServerType) && (NULL != pdwPropTag));
    
    // Figure out the type of the account
    // and the server property
    if (0 != (dwServerTypes & SRV_NNTP))
    {
        *pdwServerType = SRV_NNTP;
        *pdwPropTag = AP_NNTP_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_IMAP))
    {
        *pdwServerType = SRV_IMAP;
        *pdwPropTag = AP_IMAP_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_POP3))
    {
        *pdwServerType = SRV_POP3;
        *pdwPropTag = AP_POP3_SERVER;
    }
    else if (0 != (dwServerTypes & SRV_HTTPMAIL))
    {
        *pdwServerType = SRV_HTTPMAIL;
        *pdwPropTag = AP_HTTPMAIL_SERVER;
    }
    else
    {
        Assert(FALSE);
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL FCritLoad_Account(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    DWORD               dwData = 0;
    DWORD               dwPropTag = 0;
    ULONG               cbRead = 0;
    BYTE *              pbData = NULL;
    ULONG               cbData = 0;
    IImnEnumAccounts *  pIEnumAcct = NULL;
    IImnAccount *       pAccount = NULL;
    CHAR                szAccount[CCHMAX_SERVER_NAME];
    LPSTR               pszAcct = NULL;
    BOOL                fFound = FALSE;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the outgoing param
    ZeroMemory(ppropvar, sizeof(*ppropvar));
    
    // Read in the account server type
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the type of the account
    // and the server property
    fRet = FCrit_GetAcctInfo(dwData, &dwData, &dwPropTag);
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Get the size of the server name
    hr = pIStm->Read(&cbData, sizeof(cbData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(cbData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate the space to hold the server name
    hr = HrAlloc((VOID **) &pbData, cbData);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Read in the server name
    hr = pIStm->Read(pbData, cbData, &cbRead);
    if ((FAILED(hr)) || (cbRead != cbData))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get an account enumerator
    Assert(g_pAcctMan);
    if (FAILED(g_pAcctMan->Enumerate(dwData, &pIEnumAcct)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Search each account for the server name
    while(SUCCEEDED(pIEnumAcct->GetNext(&pAccount)))
    {
        // We can get back NULL accounts
        if (NULL == pAccount)
        {
            break;
        }
        
        // Get the server name
        if (FAILED(pAccount->GetPropSz(dwPropTag, szAccount, sizeof(szAccount))))
        {
            SafeRelease(pAccount);
            continue;
        }

        // Do we have a match?
        if (0 == lstrcmpi(szAccount, (LPSTR) pbData))
        {
            fFound = TRUE;
            break;
        }

        // We have a match

        // Release it
        SafeRelease(pAccount);
    }

    // Did we find anything?
    if (FALSE == fFound)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the account 
    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
    {
        fRet = FALSE;
        goto exit;
    }

    // Save off the account ID
    pszAcct = PszDupA(szAccount);
    if (NULL == pszAcct)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the outgoing param
    ppropvar->vt = VT_LPSTR;
    ppropvar->pszVal = pszAcct;
    pszAcct = NULL;
    
    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszAcct);
    SafeRelease(pAccount);
    SafeRelease(pIEnumAcct);
    SafeMemFree(pbData);
    return fRet;
}

BOOL FCritSave_Account(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    IImnAccount *   pAccount = NULL;
    DWORD           dwServerTypes = 0;
    DWORD           dwPropTag = 0;
    LPSTR           pszServer = NULL;
    ULONG           cbWritten = 0;
    ULONG           cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(g_pAcctMan);
    if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, ppropvar->pszVal, &pAccount)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Get the server type
    if (FAILED(pAccount->GetServerTypes(&dwServerTypes)))
    {
        fRet = FALSE;
        goto exit;
    }        

    // Figure out the type of the account
    // and the server property
    fRet = FCrit_GetAcctInfo(dwServerTypes, &dwServerTypes, &dwPropTag);
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Allocate space to hold the server name
    if (FAILED(HrAlloc((void **) &pszServer, CCHMAX_SERVER_NAME + 1)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the server name
    if (FAILED(pAccount->GetPropSz(dwPropTag, pszServer, CCHMAX_SERVER_NAME)))
    {
        fRet = FALSE;
        goto exit;
    }        

    // Write out the server type
    hr = pIStm->Write(&(dwServerTypes), sizeof(dwServerTypes), &cbWritten);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    Assert(cbWritten == sizeof(dwServerTypes));

    // Write out the count of chars in the name
    cbData = lstrlen(pszServer) + 1;
    hr = pIStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));
    
    // Write out the server name
    hr = pIStm->Write((BYTE *) pszServer, cbData, &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == cbData); 

    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszServer);
    SafeRelease(pAccount);
    return fRet;
}

BOOL FCritLoad_Default(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    DWORD   dwData = 0;
    ULONG   cbRead = 0;
    BYTE *  pbData = NULL;
    ULONG   cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the outgoing param
    ZeroMemory(ppropvar, sizeof(*ppropvar));
    
    // Read in the criteria value type
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if ((FAILED(hr)) || (cbRead != sizeof(dwData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Do we have any more data to get
    if (dwData != VT_EMPTY)
    {
        ppropvar->vt = (VARTYPE) dwData;
        
        // Get the size of the criteria value
        hr = pIStm->Read(&cbData, sizeof(cbData), &cbRead);
        if ((FAILED(hr)) || (cbRead != sizeof(cbData)))
        {
            fRet = FALSE;
            goto exit;
        }

        // Allocate space to hold the criteria value data
        switch (ppropvar->vt)
        {
            case VT_UI4:
                pbData = (BYTE * ) &(ppropvar->ulVal);
                break;

            case VT_BLOB:
            case VT_LPSTR:
                // Allocate the space to hold the data
                hr = HrAlloc((void **) &pbData, cbData);
                if (FAILED(hr))
                {
                    fRet = FALSE;
                    goto exit;
                }

                // Make sure we don't lose the allocated memory
                if (VT_LPSTR == ppropvar->vt)
                {
                    ppropvar->pszVal = (LPSTR) pbData;
                }
                else
                {
                    ppropvar->blob.cbSize = cbData;
                    ppropvar->blob.pBlobData = pbData;
                }
                break;

            default:
                AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
                fRet = FALSE;
                goto exit;
                break;                
        }

        // Read in the criteria value
        hr = pIStm->Read(pbData, cbData, &cbRead);
        if ((FAILED(hr)) || (cbRead != cbData))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    // Set the return value
    fRet = TRUE;

exit:
    return fRet;
}

BOOL FCritSave_Default(IStream * pIStm, PROPVARIANT * ppropvar)
{
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    DWORD   dwData = 0;
    ULONG   cbWritten = 0;
    BYTE *  pbData = NULL;
    ULONG   cbData = 0;

    // Check the incoming params
    if ((NULL == pIStm) || (NULL == ppropvar))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Write out the value type
    dwData = ppropvar->vt;
    hr = pIStm->Write(&(dwData), sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));

    // We don't have to save out the criteria value
    // if we don't have one
    if (VT_EMPTY == ppropvar->vt)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Figure out the size of the criteria value
    switch (ppropvar->vt)
    {
        case VT_UI4:
            pbData = (BYTE * ) &(ppropvar->ulVal);
            cbData = sizeof(ppropvar->ulVal);
            break;
            
        case VT_LPSTR:
            pbData = (BYTE * ) (ppropvar->pszVal);
            cbData = lstrlen(ppropvar->pszVal) + 1;
            break;
            
        case VT_BLOB:
            pbData = ppropvar->blob.pBlobData;
            cbData = ppropvar->blob.cbSize;
            break;
            
        default:
            AssertSz(FALSE, "Why are we trying to save in a invalid criteria type?");
            fRet = FALSE;
            goto exit;
            break;                
    }
    
    // Write out the criteria value size
    hr = pIStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));
    
    // Write out the criteria value
    hr = pIStm->Write(pbData, cbData, &cbWritten);
    if (FAILED(hr))
    {
        fRet = TRUE;
        goto exit;
    }
    Assert(cbWritten == cbData); 
    
    // Set the return value
    fRet = TRUE;

exit:
    return fRet;
}

DWORD DwGetFlagsFromMessage(IMimeMessage * pIMMsg)
{
    DWORD           dwFlags = 0;
    DWORD           dwImf = 0;

    Assert(NULL != pIMMsg);
    
    if (SUCCEEDED(pIMMsg->GetFlags(&dwImf)))
    {
        dwFlags = ConvertIMFFlagsToARF(dwImf);
    }

    return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\editrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  EditRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "ruledesc.h"

static const int c_cchNameMax = 257;

typedef struct tagCRIT_LIST
{
    CRIT_TYPE   typeCrit;
    DWORD       dwFlags;
    UINT        uiText;
    UINT        uiTextAlt;
} CRIT_LIST, * PCRIT_LIST;

typedef struct tagACT_LIST
{
    ACT_TYPE    typeAct;
    DWORD       dwFlags;
    UINT        uiText;
    UINT        uiTextAlt;
} ACT_LIST, * PACT_LIST;

static const int STATE_DEFAULT      = 0x00000000;
static const int STATE_INITIALIZED  = 0x00000001;
static const int STATE_DIRTY        = 0x00000002;
static const int STATE_EXCLUSIVE    = 0x00000004;
static const int STATE_MAIL         = 0x00000008;
static const int STATE_NEWS         = 0x00000010;
static const int STATE_FILTER       = 0x00000020;
static const int STATE_NOEDIT       = 0x00000040;
static const int STATE_JUNK         = 0x00000080;
static const int STATE_ALL          = STATE_MAIL | STATE_NEWS | STATE_FILTER;
static const int STATE_NOFILTER     = STATE_MAIL | STATE_NEWS;
static const int STATE_NOMAIL       = STATE_NEWS | STATE_FILTER;
static const int STATE_NONEWS       = STATE_MAIL | STATE_FILTER;


static const CRIT_LIST c_rgEditCritList[] =
{
    {CRIT_TYPE_NEWSGROUP,    STATE_NEWS,                        idsCriteriaNewsgroup,       idsCriteriaNewsgroup},
    {CRIT_TYPE_FROM,        STATE_ALL,                          idsCriteriaFrom,            idsCriteriaFromNot},
    {CRIT_TYPE_SUBJECT,     STATE_ALL,                          idsCriteriaSubject,         idsCriteriaSubjectNot},
    {CRIT_TYPE_BODY,        STATE_MAIL,                         idsCriteriaBody,            idsCriteriaBodyNot},
    {CRIT_TYPE_TO,          STATE_MAIL,                         idsCriteriaTo,              idsCriteriaToNot},
    {CRIT_TYPE_CC,          STATE_MAIL,                         idsCriteriaCC,              idsCriteriaCCNot},
    {CRIT_TYPE_TOORCC,      STATE_MAIL,                         idsCriteriaToOrCC,          idsCriteriaToOrCCNot},
    {CRIT_TYPE_PRIORITY,    STATE_NONEWS,                       idsCriteriaPriority,        idsCriteriaPriority},
    {CRIT_TYPE_ACCOUNT,     STATE_ALL,                          idsCriteriaAccount,         idsCriteriaAccount},
    {CRIT_TYPE_AGE,         STATE_NOMAIL,                       idsCriteriaAge,             idsCriteriaAge},
    {CRIT_TYPE_SIZE,        STATE_MAIL,                         idsCriteriaSize,            idsCriteriaSize},
    {CRIT_TYPE_LINES,       STATE_NOMAIL,                       idsCriteriaLines,           idsCriteriaLines},
    {CRIT_TYPE_ATTACH,      STATE_NONEWS,                       idsCriteriaAttachment,      idsCriteriaAttachment},
//    {CRIT_TYPE_DATE,        idsCriteriaDate},
//    {CRIT_TYPE_HEADER,      idsCriteriaHeader},
    {CRIT_TYPE_JUNK,        STATE_NOEDIT,                       idsCriteriaJunk,            idsCriteriaJunk},
    {CRIT_TYPE_SENDER,      STATE_NOEDIT,                       idsCriteriaSender,          idsCriteriaSender},
    {CRIT_TYPE_READ,        STATE_FILTER,                       idsCriteriaRead,            idsCriteriaNotRead},
//    {CRIT_TYPE_REPLIES,     STATE_FILTER,                       idsCriteriaReplies,         idsCriteriaReplies},
    {CRIT_TYPE_DOWNLOADED,  STATE_FILTER,                       idsCriteriaDownloaded,      idsCriteriaNotDownloaded},
//    {CRIT_TYPE_DELETED,     STATE_FILTER,                       idsCriteriaDeleted,         idsCriteriaNotDeleted},
    {CRIT_TYPE_FLAGGED,     STATE_FILTER,                       idsCriteriaFlagged,         idsCriteriaNotFlagged},
    {CRIT_TYPE_THREADSTATE, STATE_FILTER,                       idsCriteriaThreadState,     idsCriteriaThreadState},
    {CRIT_TYPE_SECURE,      STATE_NONEWS,                       idsCriteriaSecure,          idsCriteriaSecure},
    {CRIT_TYPE_ALL,         STATE_EXCLUSIVE | STATE_ALL,        idsCriteriaAll,             idsCriteriaAll}
};

static const ULONG c_cEditCritList = sizeof(c_rgEditCritList)/sizeof(c_rgEditCritList[0]);

static const ACT_LIST c_rgEditActList[] =
{
    {ACT_TYPE_MOVE,         STATE_MAIL,                         idsActionsMove,             idsActionsMove},
    {ACT_TYPE_COPY,         STATE_MAIL,                         idsActionsCopy,             idsActionsCopy},
    {ACT_TYPE_DELETE,       STATE_NOFILTER,                     idsActionsDelete,           idsActionsDelete},
    {ACT_TYPE_FWD,          STATE_MAIL,                         idsActionsFwd,              idsActionsFwd},
    {ACT_TYPE_JUNKMAIL,     STATE_MAIL | STATE_JUNK,            idsActionsJunkMail,         idsActionsJunkMail},
//    {ACT_TYPE_NOTIFYMSG,    idsActionsNotifyMsg},
//    {ACT_TYPE_NOTIFYSND,    STATE_NOFILTER,                     idsActionsNotifySound,      idsActionsNotifySound},
    {ACT_TYPE_HIGHLIGHT,    STATE_NOFILTER,                     idsActionsHighlight,        idsActionsHighlight},
    {ACT_TYPE_FLAG,         STATE_NOFILTER,                     idsActionsFlag,             idsActionsFlag},
    {ACT_TYPE_READ,         STATE_NOFILTER,                     idsActionsRead,             idsActionsRead},
    {ACT_TYPE_WATCH,        STATE_NOFILTER,                     idsActionsWatch,            idsActionsWatch},
    {ACT_TYPE_REPLY,        STATE_MAIL,                         idsActionsReply,            idsActionsReply},
    {ACT_TYPE_MARKDOWNLOAD, STATE_NEWS,                         idsActionsDownload,         idsActionsDownload},
    {ACT_TYPE_STOP,         STATE_NOFILTER,                     idsActionsStop,             idsActionsStop},
    {ACT_TYPE_DONTDOWNLOAD, STATE_EXCLUSIVE | STATE_MAIL,       idsActionsDontDownload,     idsActionsDontDownload},
    {ACT_TYPE_DELETESERVER, STATE_EXCLUSIVE | STATE_MAIL,       idsActionsDelServer,        idsActionsDelServer},
    {ACT_TYPE_SHOW,         STATE_EXCLUSIVE | STATE_FILTER,     idsActionsShow,             idsActionsShow}
};

static const ULONG c_cEditActList = sizeof(c_rgEditActList)/sizeof(c_rgEditActList[0]);

const int ERF_ADDDEFAULTACTION  = 0x00000001;
const int ERF_NEWRULE           = 0x00000002;
const int ERF_CUSTOMIZEVIEW     = 0x00000004;
const int ERF_CREATERULE        = 0x00000008;

class CEditRuleUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    HWND                m_hwndDlg;
    RULE_TYPE           m_typeRule;
    HWND                m_hwndCrit;
    HWND                m_hwndAct;
    HWND                m_hwndDescript;
    HWND                m_hwndName;
    IOERule *           m_pIRule;
    CRuleDescriptUI *   m_pDescriptUI;
    BOOL                m_rgfCritEnabled[c_cEditCritList];
    BOOL                m_rgfActEnabled[c_cEditActList];
    
  public:
    CEditRuleUI();
    ~CEditRuleUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule, MESSAGEINFO * pmsginfo);
    HRESULT HrShow(void);
            
    // The Rules Manager dialog function
    static INT_PTR CALLBACK FEditRuleDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

    // Message handling functions
    BOOL FOnInitDialog(HWND hwndDlg);
    BOOL FOnListClick(HWND hwndList, LPNMLISTVIEW pnmlv);
    BOOL FOnHelp(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    BOOL FOnOK(void);
    BOOL FOnNameChange(HWND hwndName);

    // Utility functions
    BOOL _FInitializeCritListCtrl(VOID);
    BOOL _FLoadCritListCtrl(INT * piSelect);
    BOOL _FAddCritToList(INT iItem, BOOL fEnable);
    BOOL _FInitializeActListCtrl(VOID);
    VOID _SetTitleText(VOID);
    void HandleEnabledState(HWND hwndList, int nItem);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\junkrule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  JunkRule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "msoejunk.h"
#include "addrrule.h"

class COEJunkRule : public IOERule
{
    private:  
        enum
        {
            RULE_STATE_UNINIT       = 0x00000000,
            RULE_STATE_INIT         = 0x00000001,
            RULE_STATE_LOADED       = 0x00000002,
            RULE_STATE_DIRTY        = 0x00000004,
            RULE_STATE_DISABLED     = 0x00000008,
            RULE_STATE_INVALID      = 0x00000010,
            RULE_STATE_EXCPT_WAB    = 0x00000020,
            RULE_STATE_DATA_LOADED  = 0x00000040
        };    

        enum {RULE_VERSION = 0x00050000};
        
    private:
        LONG                m_cRef;
        DWORD               m_dwState;
        HINSTANCE           m_hinst;
        IOEJunkFilter *     m_pIJunkFilter;
        DWORD               m_dwJunkPct;
        IOERuleAddrList *   m_pIAddrList;
        IUnknown *          m_pIUnkInner;
        LPSTR               m_pszJunkDll;
        LPSTR               m_pszDataFile;
    
    public:
        // Constructor/destructor
        COEJunkRule() : m_cRef(0), m_dwState(RULE_STATE_NULL), m_hinst(NULL),
                        m_pIJunkFilter(NULL), m_dwJunkPct(2), m_pIAddrList(NULL),
                        m_pIUnkInner(NULL), m_pszJunkDll(NULL), m_pszDataFile(NULL) {}
        ~COEJunkRule();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IRule members
        STDMETHODIMP Reset(void);
        STDMETHODIMP GetState(DWORD * pdwState);
        STDMETHODIMP Validate(DWORD dwFlags) {return S_OK;}
        
        STDMETHODIMP GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult);
        STDMETHODIMP SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarValue);

        STDMETHODIMP Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions);

        STDMETHODIMP LoadReg(LPCSTR szRegPath);
        STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
        STDMETHODIMP Clone(IOERule ** ppIRule);                            

        HRESULT HrInit(LPCSTR pszJunkDll, LPCSTR pszDataFile);

    private:
        HRESULT _HrGetDefaultActions(ACT_ITEM * pAct, ULONG cAct);
        HRESULT _HrSetSpamThresh(VOID);
        HRESULT _HrGetSpamFlags(LPCSTR pszAcct, IMimeMessage * pIMMsg, DWORD * pdwFlags);
        HRESULT _HrIsSenderInWAB(IMimeMessage * pIMMsg);
        HRESULT _HrLoadJunkFilter(VOID);
};

HRESULT HrCreateJunkRule(IOERule ** ppIRule);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\junkrule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  JunkRule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "junkrule.h"
#include "msoejunk.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"
#include <ipab.h>

typedef HRESULT (WINAPI * TYP_HrCreateJunkFilter) (DWORD dwFlags, IOEJunkFilter ** ppIJunkFilter);

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateJunkRule
//
//  This creates a junk rule.
//
//  ppIRule - pointer to return the junk rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the JunkRule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateJunkRule(IOERule ** ppIRule)
{
    COEJunkRule *   pRule = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIRule = NULL;

    // Create the rules manager object
    pRule = new COEJunkRule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Note that we have a reference
    pRule->AddRef();
    
    // Initialize the junk rule
    hr = pRule->HrInit(c_szJunkDll, c_szJunkFile);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules manager interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pRule);    
    return hr;
}

COEJunkRule::~COEJunkRule()
{
    IUnknown *  pIUnkOuter = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");

    // Prevent recursive destruction on the next
    // AddRef/Release pair
    if (NULL != m_pIAddrList)
    {
        m_cRef = 1;

        // Counter the Release call in the creation function
        pIUnkOuter = this;
        pIUnkOuter->AddRef();

        // Release the aggregated interface
        m_pIAddrList->Release();
        m_pIAddrList = NULL;
    }
    
    SafeRelease(m_pIUnkInner);
    SafeRelease(m_pIJunkFilter);
    SafeMemFree(m_pszJunkDll);
    SafeMemFree(m_pszDataFile);
    if (NULL != m_hinst)
    {
        FreeLibrary(m_hinst);
    }
}

STDMETHODIMP_(ULONG) COEJunkRule::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COEJunkRule::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COEJunkRule::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERule))
    {
        *ppvObject = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_IOERule)
    {
        *ppvObject = static_cast<IOERule *>(this);
    }
    else if (riid == IID_IOERuleAddrList)
    {
        *ppvObject = m_pIAddrList;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::Reset(void)
{
    HRESULT     hr = S_OK;

    // Set the current state
    m_dwState |= RULE_STATE_INIT;

    // Clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Set the return value
    hr = S_OK;
    
    return hr;
}

STDMETHODIMP COEJunkRule::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we're not enabled
    if ((0 != (m_dwState & RULE_STATE_DISABLED)) || (0 != (m_dwState & RULE_STATE_INVALID)))
    {
        *pdwState = RULE_STATE_NULL;
    }
    else
    {
        *pdwState = CRIT_STATE_ALL | ACT_STATE_LOCAL;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    LPSTR       pszName = NULL;
    CRIT_ITEM * pCrit = NULL;
    ACT_ITEM *  pAct = NULL;
    ULONG       cItem = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    
    switch(prop)
    {
      case RULE_PROP_NAME:
        // Get the name
        szRes[0] = '\0';
        LoadString(g_hLocRes, idsJunkMail, szRes, ARRAYSIZE(szRes));
        
        pszName = PszDupA(szRes);
        pvarResult->vt = VT_LPSTR;
        pvarResult->pszVal = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(m_dwState & RULE_STATE_DISABLED);
        break;
        
      case RULE_PROP_CRITERIA:
        pCrit = new CRIT_ITEM;
        if (NULL == pCrit)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        ZeroMemory(pCrit, sizeof(*pCrit));
        
        pCrit->type = CRIT_TYPE_JUNK;
        pCrit->logic = CRIT_LOGIC_AND;
        pCrit->dwFlags = CRIT_FLAG_DEFAULT;
        pCrit->propvar.vt = VT_EMPTY;

        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = sizeof(CRIT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pCrit;
        pCrit = NULL;
        break;
        
      case RULE_PROP_ACTIONS:
        pAct = new ACT_ITEM;
        if (NULL == pAct)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = _HrGetDefaultActions(pAct, 1);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = sizeof(ACT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pAct;
        pAct = NULL;
        break;
        
      case RULE_PROP_JUNKPCT:
        pvarResult->vt = VT_UI4;
        pvarResult->ulVal = m_dwJunkPct;
        break;
        
      case RULE_PROP_EXCPT_WAB:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(0 != (m_dwState & RULE_STATE_EXCPT_WAB));
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    RuleUtil_HrFreeCriteriaItem(pCrit, 1);
    SafeMemFree(pCrit);
    RuleUtil_HrFreeActionsItem(pAct, cItem);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COEJunkRule::SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    switch(prop)
    {
      case RULE_PROP_DISABLED:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_DISABLED;
        }
        else
        {
            Assert(0 == (m_dwState & RULE_STATE_INVALID));
            m_dwState &= ~RULE_STATE_DISABLED;
        }
        break;

      case RULE_PROP_JUNKPCT:
        if (VT_UI4 != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        m_dwJunkPct = pvarResult->ulVal;
        break;
                
      case RULE_PROP_EXCPT_WAB:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_EXCPT_WAB;
        }
        else
        {
            m_dwState &= ~RULE_STATE_EXCPT_WAB;
        }
        break;

      default:
        hr = E_INVALIDARG;
        goto exit;
    }

    // Mark the rule as dirty
    m_dwState |= RULE_STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COEJunkRule::Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT             hr = S_OK;
    DOUBLE              dblProb = 0.0;
    ACT_ITEM *          pAct = NULL;
    ULONG               cAct = 0;
    DWORD               dwFlags = 0;
    IMimeMessage *      pIMMsgNew = NULL;
    
    // Check incoming variables
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || ((NULL == pIMMsg) && ((NULL == pMsgInfo) || (NULL == pFolder))) ||
                (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set outgoing params to default
    *ppActions = NULL;
    *pcActions = 0;

    // Load up the junk mail filter
    hr = _HrLoadJunkFilter();
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Set the spam threshold
    hr = _HrSetSpamThresh();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (NULL != pIMMsg)
    {
        // Hold onto the message
        pIMMsgNew = pIMMsg;
        pIMMsgNew->AddRef();
    }
    else
    {
        // Get the message
        hr = pFolder->OpenMessage(pMsgInfo->idMessage, 0, &pIMMsgNew, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Do we need to see if this is in the WAB
    if (0 != (m_dwState & RULE_STATE_EXCPT_WAB))
    {
        if (S_OK == _HrIsSenderInWAB(pIMMsgNew))
        {
            hr = S_FALSE;
            goto exit;
        }
    }
    
    // Check to see if it's in the exceptions list
    if (NULL != m_pIAddrList)
    {
        hr = m_pIAddrList->Match(RALF_MAIL, pMsgInfo, pIMMsgNew);
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we found a match then we are done
        if (S_OK == hr)
        {
            hr = S_FALSE;
            goto exit;
        }
    }
    
    // Figure out the proper flags
    hr = _HrGetSpamFlags(pszAcct, pIMMsgNew, &dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Is it Spam?
    hr = m_pIJunkFilter->CalcJunkProb(dwFlags, pIMPropSet, pIMMsgNew, &dblProb);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // If we didn't match then just return
    if (S_FALSE == hr)
    {
        goto exit;
    }

    // Create an action
    pAct = new ACT_ITEM;
    if (NULL == pAct)
    {
        hr = E_FAIL;
        goto exit;
    }

    cAct = 1;
    
    // Grab the actions and return them to the caller
    hr = _HrGetDefaultActions(pAct, cAct);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing parameters
    *ppActions = pAct;
    pAct = NULL;
    *pcActions = cAct;
    
    // Set proper return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pAct, cAct);
    SafeMemFree(pAct);
    SafeRelease(pIMMsgNew);
    return hr;
}

STDMETHODIMP COEJunkRule::LoadReg(LPCSTR pszRegPath)
{
    HRESULT             hr = S_OK;
    LONG                lErr = 0;
    HKEY                hkeyRoot = NULL;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    BOOL                fDisabled = FALSE;
    LPSTR               pszRegPathNew = NULL;
    ULONG               cchRegPath = 0;
    
    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & RULE_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchRegPath + lstrlen(c_szRulesExcpts) + 2)))
    {
        goto exit;
    }

    // Build reg path to criteria
    lstrcpy(pszRegPathNew, pszRegPath);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        lstrcat(pszRegPathNew, g_szBackSlash);
        cchRegPath++;
    }

    lstrcat(pszRegPathNew, c_szRulesExcpts);
    
    // Get the Exceptions List
    hr = m_pIAddrList->LoadList(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the enabled state
    if (FALSE != DwGetOption(OPT_FILTERJUNK))
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }

    // Get the junk percent
    m_dwJunkPct = DwGetOption(OPT_JUNKPCT);

    // Get the WAB Exception state
    if (FALSE != DwGetOption(OPT_EXCEPTIONS_WAB))
    {
        m_dwState |= RULE_STATE_EXCPT_WAB;
    }
    else
    {
        m_dwState &= ~RULE_STATE_EXCPT_WAB;
    }

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEJunkRule::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LPSTR       pszRegPathNew = NULL;
    ULONG       cchRegPath = 0;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't save out a rule if we don't have criteria or actions
    // or a rule name
    if (NULL == m_pIAddrList)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);
   
    // Set the enabled state
    SetDwOption(OPT_FILTERJUNK, (DWORD) !(0 != (m_dwState & RULE_STATE_DISABLED)), NULL, 0);

    // Set the junk percent
    SetDwOption(OPT_JUNKPCT, m_dwJunkPct, NULL, 0);

    // Set the WAB Exception state
    SetDwOption(OPT_EXCEPTIONS_WAB, (DWORD) (0 != (m_dwState & RULE_STATE_EXCPT_WAB)), NULL, 0);

    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchRegPath + lstrlen(c_szRulesExcpts) + 2)))
    {
        goto exit;
    }

    // Build reg path to criteria
    lstrcpy(pszRegPathNew, pszRegPath);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        lstrcat(pszRegPathNew, g_szBackSlash);
        cchRegPath++;
    }

    lstrcat(pszRegPathNew, c_szRulesExcpts);
    
    // Write out the Exceptions List
    hr = m_pIAddrList->SaveList(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COEJunkRule::Clone(IOERule ** ppIRule)
{
    HRESULT             hr = S_OK;
    COEJunkRule *       pRule = NULL;
    IOERuleAddrList *   pIAddrList = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               cralList = 0;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIRule = NULL;
    
    // Create a new rule
    pRule = new COEJunkRule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Note that we have a reference
    pRule->AddRef();
    
    // Initialize the junk rule
    hr = pRule->HrInit(c_szJunkDll, c_szJunkFile);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the WAB Exception state
    if (0 != (m_dwState & RULE_STATE_DISABLED))
    {
        pRule->m_dwState |= RULE_STATE_DISABLED;
    }
    else
    {
        pRule->m_dwState &= ~RULE_STATE_DISABLED;
    }
    
    // Set the junk percent
    pRule->m_dwJunkPct = m_dwJunkPct;
    
    // Set the WAB Exception state
    if (0 != (m_dwState & RULE_STATE_EXCPT_WAB))
    {
        pRule->m_dwState |= RULE_STATE_EXCPT_WAB;
    }
    else
    {
        pRule->m_dwState &= ~RULE_STATE_EXCPT_WAB;
    }
    
    // Do we have an Exceptions List?
    if (NULL != m_pIAddrList)
    {
        // Get the interface from the new object
        hr = pRule->QueryInterface(IID_IOERuleAddrList, (void **) &pIAddrList);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the list of exceptions
        hr = m_pIAddrList->GetList(0, &pralList, &cralList);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Set the list of exceptions
        hr = pIAddrList->SetList(0, pralList, cralList);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Get the rule interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    FreeRuleAddrList(pralList, cralList);
    SafeMemFree(pralList);
    SafeRelease(pIAddrList);
    SafeRelease(pRule);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the junk rule.
//
//  ppIRule - pointer to return the junk rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the JunkRule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRule::HrInit(LPCSTR pszJunkDll, LPCSTR pszDataFile)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pIUnkOuter = NULL;
    IUnknown *              pIUnkInner = NULL;
    IOERuleAddrList *       pIAddrList = NULL;
    
    // Check the incoming params
    if ((NULL == pszJunkDll) || (NULL == pszDataFile))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we've already been initialized
    if (0 != (m_dwState & RULE_STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    Assert(NULL == m_hinst);

    // Safe off the paths
    m_pszJunkDll = PszDupA(pszJunkDll);
    if (NULL == m_pszJunkDll)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    m_pszDataFile = PszDupA(pszDataFile);
    if (NULL == m_pszDataFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Create an address list object
    pIUnkOuter = static_cast<IUnknown *> (this);
    hr = HrCreateAddrList(pIUnkOuter, IID_IUnknown, (void **) &pIUnkInner);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the Rule Address list interface
    hr = pIUnkInner->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Save off the address list
    m_pIAddrList = pIAddrList;

    // Save off the inner IUnknown
    m_pIUnkInner = pIUnkInner;
    pIUnkInner = NULL;
    
    // Note that wab exceptions is on by default
    m_dwState |= RULE_STATE_EXCPT_WAB;
    
    // Note that we have been initialized
    m_dwState |= RULE_STATE_INIT;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pIAddrList)
    {
        SafeRelease(pIUnkOuter);
    }
    SafeRelease(pIUnkInner);
    return hr;
}

HRESULT COEJunkRule::_HrGetDefaultActions(ACT_ITEM * pAct, ULONG cAct)
{
    HRESULT             hr = S_OK;
    FOLDERINFO          fldinfo = {0};
    RULEFOLDERDATA *    prfdData = NULL;
    STOREUSERDATA       UserData = {0};

    // Check incoming vars
    if ((NULL == pAct) || (0 == cAct))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    ZeroMemory(pAct, cAct * sizeof(*pAct));
    
    // Fill up the action
    pAct->type = ACT_TYPE_JUNKMAIL;
    pAct->dwFlags = ACT_FLAG_DEFAULT;
    pAct->propvar.vt = VT_EMPTY;

    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEJunkRule::_HrSetSpamThresh(VOID)
{
    HRESULT hr = S_OK;
    ULONG   ulThresh = 0;

    // If we haven't been loaded
    if (0 == (m_dwState & RULE_STATE_DATA_LOADED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    // Get the threshold
    switch (m_dwJunkPct)
    {
        case 0:
            ulThresh = STF_USE_MOST;
            break;
            
        case 1:
            ulThresh = STF_USE_MORE;
            break;
            
        case 2:
            ulThresh = STF_USE_DEFAULT;
            break;
            
        case 3:
            ulThresh = STF_USE_LESS;
            break;
            
        case 4:
            ulThresh = STF_USE_LEAST;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }

    // Set the threshold
    hr = m_pIJunkFilter->SetSpamThresh(ulThresh);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEJunkRule::_HrGetSpamFlags(LPCSTR pszAcct, IMimeMessage * pIMMsg, DWORD * pdwFlags)
{
    HRESULT         hr = S_OK;
    IImnAccount *   pAccount = NULL;
    CHAR            szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    CHAR            szReplyToAddress[CCHMAX_EMAIL_ADDRESS];
    ADDRESSLIST     rAddrList ={0};
    ULONG           ulIndex = 0;
    BOOL            fFound = FALSE;

    Assert(NULL != g_pAcctMan);

    // Initialize the flags
    *pdwFlags = 0;
    
    // Get the account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcct, &pAccount);
    
    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Get the default address on the account
    if (FAILED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, sizeof(szEmailAddress))))
    {
        szEmailAddress[0] = '\0';
    }

    // Get the reply to address on the account
    if (FAILED(pAccount->GetPropSz(AP_SMTP_REPLY_EMAIL_ADDRESS, szReplyToAddress, sizeof(szReplyToAddress))))
    {
        szReplyToAddress[0] = '\0';
    }

    // Get the addresses
    hr = pIMMsg->GetAddressTypes(IAT_TO | IAT_CC | IAT_BCC, IAP_EMAIL, &rAddrList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search through the address list
    for (ulIndex = 0; ulIndex < rAddrList.cAdrs; ulIndex++)
    {
        // Skip blank addresses
        if (NULL == rAddrList.prgAdr[ulIndex].pszEmail)
        {
            continue;
        }

        // Search for the email address
        if ('\0' != szEmailAddress[0])
        {
            fFound = !!(0 == lstrcmpi(rAddrList.prgAdr[ulIndex].pszEmail, szEmailAddress));
        }

        // Search for the reply to address
        if ((FALSE == fFound) && ('\0' != szReplyToAddress[0]))
        {
            fFound = !!(0 == lstrcmpi(rAddrList.prgAdr[ulIndex].pszEmail, szReplyToAddress));
        }

        if (FALSE != fFound)
        {
            break;
        }
    }
    
    // If we found something
    if (FALSE != fFound)
    {
        *pdwFlags |= CJPF_SENT_TO_ME;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    g_pMoleAlloc->FreeAddressList(&rAddrList);
    SafeRelease(pAccount);
    return hr;
}

HRESULT COEJunkRule::_HrIsSenderInWAB(IMimeMessage * pIMMsg)
{
    HRESULT             hr = S_OK;
    IMimeAddressTable * pIAddrTable = NULL;
    ADDRESSPROPS        rSender = {0};
    LPWAB               pWAB = NULL;
    LPADRBOOK           pAddrBook = NULL;
    LPWABOBJECT         pWabObject = NULL;
    ULONG               cbeidWAB = 0;
    LPENTRYID           peidWAB = NULL;
    ULONG               ulDummy = 0;
    LPABCONT            pabcWAB = NULL;
    ADRLIST *           pAddrList = NULL;
    FlagList            rFlagList = {0};
    
    Assert(NULL != pIMMsg);
    
    // Get the address table from the message
    hr = pIMMsg->GetAddressTable(&pIAddrTable);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the sender of the message
    rSender.dwProps = IAP_EMAIL;
    hr = pIAddrTable->GetSender(&rSender);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto exit;
    }

    // If the sender is empty,
    // then we are done...
    if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get the WAB
    hr = HrCreateWabObject(&pWAB);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the AB object
    hr = pWAB->HrGetAdrBook(&pAddrBook);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWAB->HrGetWabObject(&pWabObject);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the PAB
    hr = pAddrBook->GetPAB(&cbeidWAB, &peidWAB);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the address container
    hr = pAddrBook->OpenEntry(cbeidWAB, peidWAB, NULL, 0, &ulDummy, (IUnknown **) (&pabcWAB));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Allocate space to hold the address list
    hr = pWabObject->AllocateBuffer(sizeof(ADRLIST), (VOID **)&(pAddrList));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the Address list
    Assert(NULL != pAddrList);
    pAddrList->cEntries = 1;
    pAddrList->aEntries[0].ulReserved1 = 0;
    pAddrList->aEntries[0].cValues = 1;

    // Allocate space to hold the address props
    hr = pWabObject->AllocateBuffer(sizeof(SPropValue), (VOID **)&(pAddrList->aEntries[0].rgPropVals));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the address props
    pAddrList->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS;
    pAddrList->aEntries[0].rgPropVals[0].Value.LPSZ = rSender.pszEmail;
    
    // Resolve the sender address
    rFlagList.cFlags = 1;
    hr = pabcWAB->ResolveNames(NULL, WAB_RESOLVE_ALL_EMAILS, pAddrList, &rFlagList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Check to see if it was found
    if ((MAPI_RESOLVED == rFlagList.ulFlag[0]) || (MAPI_AMBIGUOUS == rFlagList.ulFlag[0]))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
        
exit:
    if (pAddrList)
    {
        for (ULONG ul = 0; ul < pAddrList->cEntries; ul++)
            pWabObject->FreeBuffer(pAddrList->aEntries[ul].rgPropVals);
        pWabObject->FreeBuffer(pAddrList);
    }
    SafeRelease(pabcWAB);
    if (NULL != peidWAB)
    {
        pWabObject->FreeBuffer(peidWAB);
    }
    SafeRelease(pWAB);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pIAddrTable);
    return hr;
}

HRESULT COEJunkRule::_HrLoadJunkFilter(VOID)
{
    HRESULT                 hr = S_OK;
    ULONG                   cbData = 0;
    LPSTR                   pszPath = NULL;
    ULONG                   cchPath = 0;
    TYP_HrCreateJunkFilter  pfnHrCreateJunkFilter = NULL;
    IOEJunkFilter *         pIJunk = NULL;
    LPSTR                   pszFirst = NULL;
    LPSTR                   pszLast = NULL;
    LPSTR                   pszCompany = NULL;

    // If we haven't been initialized yet
    if (0 == (m_dwState & RULE_STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we've already been loaded, we're done
    if (0 != (m_dwState & RULE_STATE_DATA_LOADED))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    Assert(NULL != m_pszJunkDll);
    Assert(NULL != m_pszDataFile);
    
    // Get the size of the path to Outlook Express
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, NULL, &cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    // How much room do we need to build up the path
    cbData += max(lstrlen(m_pszJunkDll), lstrlen(m_pszDataFile)) + 2;

    // Allocate space to hold the path
    hr = HrAlloc((VOID **) &pszPath, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the path to Outlook Express
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, (BYTE *) pszPath, &cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Build up the path to the Junk DLL
    lstrcat(pszPath, g_szBackSlash);
    cchPath = lstrlen(pszPath);
    lstrcpy(&(pszPath[cchPath]), m_pszJunkDll);
    
    // Load the Dll
    Assert(NULL == m_hinst);
    m_hinst = LoadLibrary(pszPath);
    if (NULL == m_hinst)
    {
        AssertSz(FALSE, "Can't find the Dll");
        hr = E_FAIL;
        goto exit;
    }
    
    // Find the entry points
    pfnHrCreateJunkFilter = (TYP_HrCreateJunkFilter) GetProcAddress(m_hinst, c_szHrCreateJunkFilter);
    if (NULL == pfnHrCreateJunkFilter)
    {
        AssertSz(FALSE, "Can't find the function HrCreateJunkFilter");
        hr = E_FAIL;
        goto exit;
    }

    // Get the junk filter
    hr = pfnHrCreateJunkFilter(0, &pIJunk);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the path to the Junk DLL data file
    lstrcpy(&(pszPath[cchPath]), m_pszDataFile);
    
    // Load the test file
    hr = pIJunk->LoadDataFile(pszPath);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get user specifics
    RuleUtil_HrGetUserData(0, &pszFirst, &pszLast, &pszCompany);
    
    // Set the user specifics
    hr = pIJunk->SetIdentity(pszFirst, pszLast, pszCompany);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save of the data
    m_pIJunkFilter = pIJunk;
    pIJunk = NULL;

    // Note that we've loaded the data
    m_dwState |= RULE_STATE_DATA_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszCompany);
    SafeMemFree(pszLast);
    SafeMemFree(pszFirst);
    SafeRelease(pIJunk);
    SafeMemFree(pszPath);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rule.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Rule.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rule.h"
#include "strconst.h"
#include "goptions.h"
#include "criteria.h"
#include "actions.h"
#include "ruleutil.h"

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRule
//
//  This creates a rule.
//
//  ppIRule - pointer to return the rule
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rule object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRule(IOERule ** ppIRule)
{
    COERule *   pRule = NULL;
    HRESULT     hr = S_OK;

    // Check the incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIRule = NULL;

    // Create the rules manager object
    pRule = new COERule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pRule->QueryInterface(IID_IOERule, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRule = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pRule)
    {
        delete pRule;
    }
    
    return hr;
}

COERule::COERule()
{
    m_cRef = 0;
    m_dwState = RULE_STATE_NULL;
    m_pszName = NULL;
    m_pICrit = NULL;
    m_pIAct = NULL;
    m_dwVersion = 0;
}

COERule::~COERule()
{
    ULONG   ulIndex = 0;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);
}

STDMETHODIMP_(ULONG) COERule::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) COERule::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP COERule::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERule))
    {
        *ppvObject = static_cast<IOERule *>(this);
    }
    else if ((riid == IID_IPersistStream) || (riid == IID_IPersist))
    {
        *ppvObject = static_cast<IPersistStream *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::Reset(void)
{
    HRESULT     hr = S_OK;
    LPSTR       pszKeyPath = NULL;
    LPCSTR       pszKeyStart = NULL;

    // Release the criteria
    SafeRelease(m_pICrit);

    // Release the actions
    SafeRelease(m_pIAct);

    // Free up the rule name
    SafeMemFree(m_pszName);
    
    // Set the current state
    m_dwState |= RULE_STATE_INIT;

    // Clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Set the return value
    hr = S_OK;
    
    return hr;
}

STDMETHODIMP COERule::GetState(DWORD * pdwState)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we're not enabled
    if ((0 != (m_dwState & RULE_STATE_DISABLED)) || (0 != (m_dwState & RULE_STATE_INVALID)))
    {
        *pdwState = RULE_STATE_NULL;
    }
    else
    {
        *pdwState = m_dwState;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::Validate(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    BOOL        fValid = FALSE;

    // If we don't have a criteria or actions object then we fail
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Validate the criteria 
    hr = m_pICrit->Validate(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    fValid = TRUE;
    if (S_OK != hr)
    {
        fValid = FALSE;
    }
    
    // Validate the actions 
    hr = m_pIAct->Validate(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK != hr)
    {
        fValid = FALSE;
    }
    
    // If the rule is invalid, make sure we disable it
    if (FALSE == fValid)
    {
        m_dwState |= RULE_STATE_INVALID;
    }
    else
    {
        m_dwState &= ~RULE_STATE_INVALID;
    }
    
    // Set the proper return value
    hr = fValid ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP COERule::GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    LPSTR       pszName = NULL;
    CRIT_ITEM * pCrit = NULL;
    ACT_ITEM *  pAct = NULL;
    ULONG       cItem = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    
    switch(prop)
    {
      case RULE_PROP_NAME:
        if (NULL == m_pszName)
        {
            pszName = PszDupA("");
        }
        else
        {
            pszName = PszDupA(m_pszName);
        }
        pvarResult->vt = VT_LPSTR;
        pvarResult->pszVal = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        pvarResult->vt = VT_BOOL;
        pvarResult->boolVal = !!(m_dwState & RULE_STATE_DISABLED);
        break;
        
      case RULE_PROP_VERSION:
        pvarResult->vt = VT_UI4;
        pvarResult->ulVal = m_dwVersion;
        break;
        
      case RULE_PROP_CRITERIA:
        if (NULL == m_pICrit)
        {
            cItem = 0;
            pCrit = NULL;
        }
        else
        {
            hr = m_pICrit->GetCriteria(0, &pCrit, &cItem);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = cItem * sizeof(CRIT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pCrit;
        pCrit = NULL;
        break;
        
      case RULE_PROP_ACTIONS:
        if (NULL == m_pIAct)
        {
            cItem = 0;
            pAct = NULL;
        }
        else
        {
            hr = m_pIAct->GetActions(0, &pAct, &cItem);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        pvarResult->vt = VT_BLOB;
        pvarResult->blob.cbSize = cItem * sizeof(ACT_ITEM);
        pvarResult->blob.pBlobData = (BYTE *) pAct;
        pAct = NULL;
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    RuleUtil_HrFreeCriteriaItem(pCrit, cItem);
    SafeMemFree(pCrit);
    RuleUtil_HrFreeActionsItem(pAct, cItem);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COERule::SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult)
{
    HRESULT     hr = S_OK;
    LPSTR       pszName = NULL;
    DWORD       dwState = 0;
    ULONG       cItems = 0;

    // Check incoming params
    if (NULL == pvarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    switch(prop)
    {
      case RULE_PROP_NAME:
        if ((VT_LPSTR != pvarResult->vt) || (NULL == pvarResult->pszVal))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Create a new copy
        pszName = PszDupA(pvarResult->pszVal);
        if (NULL == pszName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Free up any old value
        SafeMemFree(m_pszName);
        
        // Set the new value
        m_pszName = pszName;
        pszName = NULL;
        break;

      case RULE_PROP_DISABLED:
        if (VT_BOOL != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        if (FALSE != !!(pvarResult->boolVal))
        {
            m_dwState |= RULE_STATE_DISABLED;
        }
        else
        {
            Assert(0 == (m_dwState & RULE_STATE_INVALID));
            m_dwState &= ~RULE_STATE_DISABLED;
        }
        break;

      case RULE_PROP_VERSION:
        if (VT_UI4 != pvarResult->vt)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        // Set the new value
        m_dwVersion = pvarResult->ulVal;
        break;
        
      case RULE_PROP_CRITERIA:
        if ((VT_BLOB != pvarResult->vt) || (0 == pvarResult->blob.cbSize) ||
                            (NULL == pvarResult->blob.pBlobData))
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        if (NULL == m_pICrit)
        {
            hr = HrCreateCriteria(&m_pICrit);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        
        cItems = pvarResult->blob.cbSize / sizeof(CRIT_ITEM);
        Assert(cItems * sizeof(CRIT_ITEM) == pvarResult->blob.cbSize);
        
        hr = m_pICrit->SetCriteria(0, (CRIT_ITEM *) pvarResult->blob.pBlobData, cItems);
        if (FAILED(hr))
        {
            goto exit;
        }

        hr = m_pICrit->GetState(&dwState);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
        break;
        
      case RULE_PROP_ACTIONS:
        if ((VT_BLOB != pvarResult->vt) || (0 == pvarResult->blob.cbSize) ||
                            (NULL == pvarResult->blob.pBlobData))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        if (NULL == m_pIAct)
        {
            hr = HrCreateActions(&m_pIAct);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        
        cItems = pvarResult->blob.cbSize / sizeof(ACT_ITEM);
        Assert(cItems * sizeof(ACT_ITEM) == pvarResult->blob.cbSize);
        
        hr = m_pIAct->SetActions(0, (ACT_ITEM *) pvarResult->blob.pBlobData, cItems);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        hr = m_pIAct->GetState(&dwState);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_dwState = (m_dwState & ~ACT_STATE_MASK) | (dwState & ACT_STATE_MASK);
        break;
        
      default:
        hr = E_INVALIDARG;
        goto exit;
    }

    // Mark the rule as dirty
    m_dwState |= RULE_STATE_DIRTY;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszName);
    return hr;
}

STDMETHODIMP COERule::Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder,
                                IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pAct = NULL;
    ULONG       cAct = 0;
    
    // Check incoming variables
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) || (0 == cbMsgSize) ||
                (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set outgoing params to default
    *ppActions = NULL;
    *pcActions = 0;

    // If we don't have a criteria or actions object then we fail
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = S_FALSE;
        goto exit;
    }

    // If we ain't valid then we can just bail
    if (0 != (m_dwState & RULE_STATE_INVALID))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Do we match??
    hr = m_pICrit->MatchMessage(pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we didn't match then just return
    if (S_FALSE == hr)
    {
        goto exit;
    }

    // Grab the actions and return them to the caller
    hr = m_pIAct->GetActions(0, &pAct, &cAct);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing parameters
    *ppActions = pAct;
    pAct = NULL;
    *pcActions = cAct;
    
    // Set proper return value
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pAct, cAct);
    SafeMemFree(pAct);
    return hr;
}

STDMETHODIMP COERule::LoadReg(LPCSTR pszRegPath)
{
    HRESULT             hr = S_OK;
    LONG                lErr = 0;
    HKEY                hkeyRoot = NULL;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    LPSTR               pszName = NULL;
    BOOL                fDisabled = FALSE;
    IOECriteria *       pICriteria = NULL;
    IOEActions *        pIActions = NULL;
    LPSTR               pszRegPathNew = NULL;
    ULONG               cchRegPath = 0;
    DWORD               dwState = 0;
    
    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Should we fail if we're already loaded?
    AssertSz(0 == (m_dwState & RULE_STATE_LOADED), "We're already loaded!!!");

    // Open the reg key from the path
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the rule name
    hr = RuleUtil_HrGetRegValue(hkeyRoot, c_szRuleName, NULL, (BYTE **) &pszName, NULL);
    if (FAILED(hr))
    {
        SafeMemFree(pszName);
    }

    // Get the enabled state
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRuleEnabled, 0, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    Assert(cbData == sizeof(dwData));
    
    fDisabled = ! (BOOL) dwData;

    // Get the version of the rule
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = 0;
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    m_dwVersion = dwData;
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    Assert(lstrlen(c_szRuleCriteria) >= lstrlen(c_szRuleActions));
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchRegPath + lstrlen(c_szRuleCriteria) + 2)))
    {
        goto exit;
    }

    // Build reg path to criteria
    lstrcpy(pszRegPathNew, pszRegPath);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        lstrcat(pszRegPathNew, g_szBackSlash);
        cchRegPath++;
    }

    lstrcat(pszRegPathNew, c_szRuleCriteria);
    
    // Create a new criteria object
    hr = HrCreateCriteria(&pICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria
    hr = pICriteria->LoadReg(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the state of the criteria
    hr = pICriteria->GetState(&dwState);
    if (FAILED(hr))
    {
        goto exit;
    }

    m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
    
    // Build reg path to actions
    lstrcpy(pszRegPathNew + cchRegPath, c_szRuleActions);

    // Create a new actions object
    hr = HrCreateActions(&pIActions);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions
    hr = pIActions->LoadReg(pszRegPathNew);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the state of the actions
    hr = pIActions->GetState(&dwState);
    if (FAILED(hr))
    {
        goto exit;
    }

    m_dwState = (m_dwState & ~ACT_STATE_MASK) | (dwState & ACT_STATE_MASK);
    
    // Free up the current values
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);

    // Save the new values
    m_pszName = pszName;
    pszName = NULL;
    if (FALSE == fDisabled)
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }
    m_pICrit = pICriteria;
    pICriteria = NULL;
    m_pIAct = pIActions;
    pIActions = NULL;

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    SafeRelease(pIActions);
    SafeRelease(pICriteria);
    SafeMemFree(pszName);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERule::SaveReg(LPCSTR pszRegPath, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LPSTR       pszRegPathNew = NULL;
    ULONG       cchRegPath = 0;

    // Check incoming param
    if (NULL == pszRegPath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't save out a rule if we don't have criteria or actions
    // or a rule name
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Let's make sure we clear out the key first
    AthUserDeleteKey(pszRegPath);
    
    // Create the reg key from the path
    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    Assert(REG_CREATED_NEW_KEY == dwDisp);

    // Write out the rule name
    if (NULL != m_pszName)
    {
        lErr = RegSetValueEx(hkeyRoot, c_szRuleName, 0, REG_SZ,
                                        (BYTE *) m_pszName, lstrlen(m_pszName) + 1);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Write out the disabled state
    dwData = !(m_dwState & RULE_STATE_DISABLED);
    lErr = RegSetValueEx(hkeyRoot, c_szRuleEnabled, 0, REG_DWORD,
                                    (BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Allocate space to hold the new reg path
    cchRegPath = lstrlen(pszRegPath);
    Assert(lstrlen(c_szRuleCriteria) >= lstrlen(c_szRuleActions));
    if (FAILED(HrAlloc((void **) &pszRegPathNew, cchRegPath + lstrlen(c_szRuleCriteria) + 2)))
    {
        goto exit;
    }

    // Build reg path to criteria
    lstrcpy(pszRegPathNew, pszRegPath);
    if ('\\' != pszRegPath[cchRegPath]) 
    {
        lstrcat(pszRegPathNew, g_szBackSlash);
        cchRegPath++;
    }

    lstrcat(pszRegPathNew, c_szRuleCriteria);
    
    // Write out the criteria
    hr = m_pICrit->SaveReg(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build reg path to actions
    lstrcpy(pszRegPathNew + cchRegPath, c_szRuleActions);

    // Write out the actions
    hr = m_pIAct->SaveReg(pszRegPathNew, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bump up the version
    if (0 != (m_dwState & RULE_STATE_DIRTY))
    {
        m_dwVersion++;
    }
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (BYTE *) &m_dwVersion, sizeof(m_dwVersion));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Should we clear the dirty bit?
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszRegPathNew);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

STDMETHODIMP COERule::Clone(IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    COERule *   pRule = NULL;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppIRule = NULL;
    
    // Create a new rule
    pRule = new COERule;
    if (NULL == pRule)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy over the rule name
    if (NULL != m_pszName)
    {
        pRule->m_pszName = PszDupA(m_pszName);
        if (NULL == pRule->m_pszName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    
    // Copy over the enabled state
    pRule->m_dwState = m_dwState;

    // Copy over the version
    pRule->m_dwVersion = m_dwVersion;

    // Clone the criteria
    if (FAILED(m_pICrit->Clone(&(pRule->m_pICrit))))
    {
        goto exit;
    }

    // Clone the actions
    if (FAILED(m_pIAct->Clone(&(pRule->m_pIAct))))
    {
        goto exit;
    }

    // Get the rule interface
    hr = pRule->QueryInterface(IID_IOERule