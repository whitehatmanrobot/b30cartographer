e explicit
//              07-Dec-93 alexgo    merged 16bit RC9 changes
//              29-Nov-93 alexgo    32bit port
//              04-Jun-93 srinik    support for demand loading and discarding
//                                  of caches
//              13-Mar-92 srinik    created
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <qd2gdi.h>
#include "mf.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#define M_HPRES()               (m_hPres ? m_hPres : LoadHPRES())

/*
 *      IMPLEMENTATION of CMfObject
 *
 */


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CMfObject
//
//  Synopsis:   constructor for the metafile object
//
//  Effects:
//
//  Arguments:  [pCacheNode]    -- pointer to the cache node for this object
//              [dwAspect]      -- drawing aspect for the object
//              [fConvert]      -- specifies whether to convert from Mac
//                                 QuickDraw format
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              13-Feb-95 t-ScottH  initialize m_pfnContinue
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

CMfObject::CMfObject(LPCACHENODE pCacheNode, DWORD dwAspect, BOOL fConvert)
{
	VDATEHEAP();

	m_ulRefs        = 1;
	m_hPres         = NULL;
	m_dwSize        = 0;
	m_dwAspect      = dwAspect;
	m_pCacheNode    = pCacheNode;
	m_dwContinue    = 0;
        m_pfnContinue   = NULL;
	m_lWidth        = 0;
	m_lHeight       = 0;
		
	m_fConvert      = fConvert;
	m_pMetaInfo     = NULL;
	m_pCurMdc       = NULL;
	m_fMetaDC       = FALSE;
	m_nRecord       = 0;
	m_error         = NOERROR;
	m_pColorSet     = NULL;

        m_hPalDCOriginal = NULL;
        m_hPalLast = NULL;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::~CMfObject
//
//  Synopsis:   Destroys a metafile presentation object
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

CMfObject::~CMfObject (void)
{
	VDATEHEAP();

	CMfObject::DiscardHPRES();
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::QueryInterface
//
//  Synopsis:   returns supported interfaces
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::QueryInterface (REFIID iid, void FAR* FAR* ppvObj)
{
	VDATEHEAP();

	if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IOlePresObj))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::AddRef
//
//  Synopsis:   Increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG  -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMfObject::AddRef(void)
{
	VDATEHEAP();
	
	return ++m_ulRefs;
}
			
//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes the object once the ref count goes to zero
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMfObject::Release(void)
{
	VDATEHEAP();

	if (--m_ulRefs == 0) {
		delete this;
		return 0;
	}

	return m_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetData
//
//  Synopsis:   Retrieves data in the specified format from the object
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObject
//
//  Algorithm:  Does error checking and then gets a copy of the metafilepict
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE   sc;
	
	// null out in case of error
	pmedium->tymed = (DWORD) TYMED_NULL;
	pmedium->pUnkForRelease = NULL;

	if (!(pformatetcIn->tymed & (DWORD) TYMED_MFPICT))
	{
		sc = DV_E_TYMED;
	}
	else if (pformatetcIn->cfFormat != CF_METAFILEPICT)
	{
		sc = DV_E_CLIPFORMAT;
	}
	else if (IsBlank())
	{
		sc = OLE_E_BLANK;
	}
	// here we actually try to get the data
	else if (NULL == (pmedium->hGlobal = GetHmfp()))
	{
		sc = E_OUTOFMEMORY;
	}
	else {
		pmedium->tymed = (DWORD) TYMED_MFPICT;
		return NOERROR;
	}

	return ResultFromScode(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetDataHere
//
//  Synopsis:   Retrieves data of the specified format into the specified
//              medium
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Does error checking and then copies the metafile into a
//              stream.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetDataHere
	(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE   sc;
	
	if (pformatetcIn->cfFormat != CF_METAFILEPICT)
	{
		sc = DV_E_CLIPFORMAT;
	}
	else if (pmedium->tymed != (DWORD) TYMED_ISTREAM)
	{
		sc = DV_E_TYMED;
	}
	else if (pmedium->pstm == NULL)
	{
		sc = E_INVALIDARG;
	}
	else if (IsBlank())
	{
		sc = OLE_E_BLANK;
	}
	else
	{
		HANDLE hpres = M_HPRES();
		return UtHMFToPlaceableMFStm(&hpres, m_dwSize, m_lWidth,
						m_lHeight, pmedium->pstm);
	}

	return ResultFromScode(sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetDataWDO
//
//  Synopsis:   Stores a metafile in this object
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- format of the data coming in
//              [pmedium]       -- the new metafile (data)
//              [fRelease]      -- if true, then we'll release the [pmedium]
//              [pDataObj]      -- unused for MF objects
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  does error checking and then stores the new data.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::SetDataWDO (LPFORMATETC    pformatetc,
				    STGMEDIUM *    pmedium,
				    BOOL           fRelease,
				    IDataObject *  /* UNUSED */)
{
	VDATEHEAP();

	HRESULT         error;
	BOOL            fTakeData = FALSE;
	
	if (pformatetc->cfFormat != CF_METAFILEPICT)
	{
		return ResultFromScode(DV_E_CLIPFORMAT);
	}
	
	if (pmedium->tymed != (DWORD) TYMED_MFPICT)
	{
		return ResultFromScode(DV_E_TYMED);
	}

	if ((pmedium->pUnkForRelease == NULL) && fRelease)
	{
		// we can take the ownership of the data
		fTakeData = TRUE;
	}
	
	// ChangeData will keep the data if fRelease is TRUE, else it copies
	error = ChangeData (pmedium->hGlobal, fTakeData);

	if (fTakeData)
	{
		pmedium->tymed = (DWORD) TYMED_NULL;
	}
	else if (fRelease)
	{
		ReleaseStgMedium(pmedium);
	}
	
	return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetHmfp (internal)
//
//  Synopsis:   Gets a copy of the stored metafile presentation
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CMfObject::GetHmfp (void)
{
	VDATEHEAP();

	return UtGetHMFPICT((HMETAFILE)GetCopyOfHPRES(), TRUE, m_lWidth,
		m_lHeight);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ChangeData (internal)
//
//  Synopsis:   Swaps the stored metafile presentation
//
//  Effects:
//
//  Arguments:  [hMfp]          -- the new metafile
//              [fDelete]       -- if TRUE, then delete [hMfp]
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port, fixed GlobalUnlock bug
//  Notes:
//
// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.
//
//--------------------------------------------------------------------------

INTERNAL CMfObject::ChangeData (HANDLE hMfp, BOOL fDelete)
{
	VDATEHEAP();


	HANDLE                  hNewMF;
	LPMETAFILEPICT          lpMetaPict;
	DWORD                   dwSize;
	HRESULT                 error = NOERROR;

	if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMfp)) == NULL)
	{
		if (fDelete)
		{
			LEVERIFY( NULL == GlobalFree (hMfp) );
		}
		return E_OUTOFMEMORY;
	}

	if (!fDelete) {
		if (NULL == (hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		hNewMF = lpMetaPict->hMF;
	}

		
	if (lpMetaPict->mm != MM_ANISOTROPIC)
	{
		error = ResultFromScode(E_UNSPEC);
		LEWARN( error, "Mapping mode is not anisotropic" );

	}
	else if (0 == (dwSize =  MfGetSize (&hNewMF)))
	{
		error = ResultFromScode(OLE_E_BLANK);
	}
	else
	{
		if (m_hPres)
		{
			LEVERIFY( DeleteMetaFile (m_hPres) );
		}
		m_hPres         = (HMETAFILE)hNewMF;
		m_dwSize        = dwSize;
		m_lWidth        = lpMetaPict->xExt;
		m_lHeight       = lpMetaPict->yExt;
	}

	GlobalUnlock (hMfp);
	
	if (error != NOERROR)
	{
		LEVERIFY( DeleteMetaFile ((HMETAFILE)hNewMF) );
	}

	if (fDelete)
	{
		LEVERIFY( NULL == GlobalFree (hMfp) );
	}

	return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Draw
//
//  Synopsis:   Draws the stored presentation
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect
//              [hicTargetDev]  -- the target device
//              [hdcDraw]       -- hdc to draw into
//              [lprcBounds]    -- bounding rectangle to draw into
//              [lprcWBounds]   -- bounding rectangle for the metafile
//              [pfnContinue]   -- function to call while drawing
//              [dwContinue]    -- parameter to [pfnContinue]
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Sets the viewport and metafile boundaries, then plays
//              the metafile
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Draw (void *     /* UNUSED pvAspect */,
			      HDC        /* UNUSED hicTargetDev */,
			      HDC        hdcDraw,
			      LPCRECTL   lprcBounds,
			      LPCRECTL   lprcWBounds,
			      BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
			      ULONG_PTR      dwContinue)
{
	VDATEHEAP();

	m_error = NOERROR;
	
	int		iRgn;
	int             iOldDc;
	RECT            rect;
	LPRECT          lpRrc = (LPRECT) &rect;

	Assert(lprcBounds);

	if (!M_HPRES())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	rect.left   = lprcBounds->left;
	rect.right  = lprcBounds->right;
	rect.top    = lprcBounds->top;
	rect.bottom = lprcBounds->bottom;

	iOldDc = SaveDC (hdcDraw);
	if (0 == iOldDc)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}

	m_nRecord = RECORD_COUNT;
	m_fMetaDC = OleIsDcMeta (hdcDraw);

	if (!m_fMetaDC) {
	    iRgn = IntersectClipRect (hdcDraw, lpRrc->left, lpRrc->top,
						   lpRrc->right, lpRrc->bottom);
	    Assert( ERROR != iRgn );

	    if (iRgn == NULLREGION) {
		goto errRtn;
	    }
	    if (iRgn == ERROR) {
		m_error = ResultFromScode(E_UNSPEC);
		goto errRtn;
	    }


		// Because the LPToDP conversion takes the current world
                // transform into consideration, we must check to see
                // if we are in a GM_ADVANCED device context.  If so,
                // save its state and reset to GM_COMPATIBLE while we
                // convert LP to DP (then restore the DC).

                if (GM_ADVANCED == GetGraphicsMode(hdcDraw))
                {
                    HDC screendc = GetDC(NULL);
                    RECT rect = {0, 0, 1000, 1000};
                    HDC emfdc = CreateEnhMetaFile(screendc, NULL, &rect, NULL);
                    PlayMetaFile( emfdc, m_hPres);
                    HENHMETAFILE hemf = CloseEnhMetaFile(emfdc);
                    PlayEnhMetaFile( hdcDraw, hemf, lpRrc);
                    DeleteEnhMetaFile( hemf );

                    goto errRtn;
                }
                else
                {
                    LEVERIFY( LPtoDP (hdcDraw, (LPPOINT) lpRrc, 2) );
                }

                LEVERIFY( 0 != SetMapMode (hdcDraw, MM_ANISOTROPIC) );
                LEVERIFY( SetViewportOrg (hdcDraw, lpRrc->left, lpRrc->top) );
                LEVERIFY( SetViewportExt (hdcDraw, lpRrc->right - lpRrc->left,
					     lpRrc->bottom - lpRrc->top) );

	}
	else
	{
		iOldDc = -1;

		if (!lprcWBounds)
		{
			return ResultFromScode(E_DRAW);
		}

		m_pMetaInfo = (LPMETAINFO)PrivMemAlloc(sizeof(METAINFO));
		if( !m_pMetaInfo )
		{
			AssertSz(m_pMetaInfo, "Memory allocation failed");
			m_error = ResultFromScode(E_OUTOFMEMORY);
			goto errRtn;
		}
		
		m_pCurMdc = (LPMETADC) (m_pMetaInfo);

		m_pMetaInfo->xwo  = lprcWBounds->left;
		m_pMetaInfo->ywo  = lprcWBounds->top;
		m_pMetaInfo->xwe  = lprcWBounds->right;
		m_pMetaInfo->ywe  = lprcWBounds->bottom;

		m_pMetaInfo->xro  = lpRrc->left - lprcWBounds->left;
		m_pMetaInfo->yro  = lpRrc->top - lprcWBounds->top;
		
		m_pCurMdc->xre    = lpRrc->right - lpRrc->left;
		m_pCurMdc->yre    = lpRrc->bottom - lpRrc->top;
		m_pCurMdc->xMwo   = 0;
		m_pCurMdc->yMwo   = 0;
		m_pCurMdc->xMwe   = 0;
		m_pCurMdc->yMwe   = 0;
		m_pCurMdc->pNext  = NULL;
	}

	m_pfnContinue = pfnContinue;
	m_dwContinue = dwContinue;

	// m_hPalDCOriginal and m_hPalLast are used to clean up any 
	// palettes that are selected into a DC during the metafile 
	// enumeration.
        m_hPalDCOriginal = NULL;
        m_hPalLast = NULL;

	LEVERIFY( EnumMetaFile(hdcDraw, m_hPres, MfCallbackFuncForDraw,
						(LPARAM) this) );

	if (m_fMetaDC)
	{
	    CleanStack();

	}

	// if m_hPalLast exists at this point, we have duped a palette
	// and it needs to be freed.
        if (m_hPalLast)
	{
	    HPALETTE hPalTemp;

	    // when calling SelectPalette on a Metafile DC, the old
	    // palette is not returned.  We need to select another
	    // palette into the metafile DC so DeleteObject can be
	    // called.  To do this, we will use the stock palette.
	    if (m_fMetaDC)
	    {
	        hPalTemp = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
	    }
	    else
	    {
	        // Get the original palette selected in the DC.
	        hPalTemp = m_hPalDCOriginal;
	    }

	    // hPalTemp could be NULL...

	    if (hPalTemp)
	    {
	        // Should this palette be selected in the foreground?
	        // [Probably not, this code is well-tested]
	        SelectPalette(hdcDraw, hPalTemp, TRUE);
	    }

	    DeleteObject(m_hPalLast);
	}

	m_fMetaDC = FALSE;

errRtn:

	LEVERIFY( RestoreDC (hdcDraw, iOldDc) );
	return m_error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetColorSet
//
//  Synopsis:   Retrieves the logical palette associated with the metafile
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect
//              [hicTargetDev]  -- target device
//              [ppColorSet]    -- where to put the logical palette pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Plays the metafile into a new metafile.  The play callback
//              function stores the metafile palette which is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


STDMETHODIMP CMfObject::GetColorSet (LPVOID         /* UNUSED pvAspect     */,
				     HDC            /* UNUSED hicTargetDev */,
				     LPLOGPALETTE * ppColorSet)
{
	VDATEHEAP();

	if (IsBlank() || !M_HPRES())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	m_pColorSet = NULL;
	
	HDC hdcMeta = CreateMetaFile(NULL);
	if (NULL == hdcMeta)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}

	m_error = NOERROR;


	LEVERIFY( EnumMetaFile(hdcMeta, m_hPres, MfCallbackFuncForGetColorSet,
			       (LPARAM) this) );

	HMETAFILE hMetaFile = CloseMetaFile(hdcMeta);

	if( hMetaFile )
	{
		DeleteMetaFile(hMetaFile);
	}
	
	if( m_error != NOERROR )
	{
		return m_error;
	}
		
	if ((*ppColorSet = m_pColorSet) == NULL)
	{
		return ResultFromScode(S_FALSE);
	}

	return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   MfCallBackFunForDraw
//
//  Synopsis:   callback function for drawing metafiles -- call's the caller's
//              draw method (via a passed in this pointer)
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


int CALLBACK __loadds MfCallbackFuncForDraw
    (HDC hdc, HANDLETABLE FAR* lpHTable, METARECORD FAR* lpMFR, int nObj,
     LPARAM lpobj)
{
	VDATEHEAP();

    return ((CMfObject FAR*) lpobj)->CallbackFuncForDraw(hdc, lpHTable,
					lpMFR, nObj);
}

//+-------------------------------------------------------------------------
//
//  Function:   MfCallbackFuncForGetColorSet
//
//  Synopsis:   callback function for grabbing the palette from a metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CALLBACK __loadds MfCallbackFuncForGetColorSet
    (HDC hdc, HANDLETABLE FAR* lpHTable, METARECORD FAR* lpMFR, int nObj,
     LPARAM lpobj)
{
	VDATEHEAP();

    return ((CMfObject FAR*) lpobj)->CallbackFuncForGetColorSet(hdc, lpHTable,
								lpMFR, nObj);
}




//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CallbackFuncForGetColorSet
//
//  Synopsis:   Merges all the color palettes in the metafile into
//              one palette (called when GetColorSet enumerates the metafile)
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CMfObject::CallbackFuncForGetColorSet(HDC           /* UNUSED hdc */,
					  LPHANDLETABLE /* UNUSED lpHTable */,
					  LPMETARECORD  lpMFR,
					  int           /* UNUSED nObj */)
{
	VDATEHEAP();

	if (lpMFR->rdFunction == META_CREATEPALETTE)
	{
		LPLOGPALETTE    lplogpal = (LPLOGPALETTE) &(lpMFR->rdParm[0]);
		UINT            uPalSize =   (lplogpal->palNumEntries) *
						sizeof(PALETTEENTRY)
						+ 2 * sizeof(WORD);
		
		if (m_pColorSet == NULL)
		{
			// This is the first CreatePalette record.

			m_pColorSet = (LPLOGPALETTE)PubMemAlloc(uPalSize);
			if(NULL == m_pColorSet)
			{
				m_error = ResultFromScode(E_OUTOFMEMORY);
				return FALSE;
			}
			_xmemcpy(m_pColorSet, lplogpal, (size_t) uPalSize);
		}
		
		// if we hit more than one CreatePalette record then, we need to
		// merge those palette records.

		// REVIEW32:: err, we don't ever seem to do this
		// mergeing referred to above :(
	}

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CallbackFuncForDraw
//
//  Synopsis:   Draws the metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              17-Dec-93 ChrisWe   fixed second argument to SelectPalette calls
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CMfObject::CallbackFuncForDraw
	(HDC hdc, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    VDATEHEAP();

	
    if (!--m_nRecord)
    {
        m_nRecord = RECORD_COUNT;
		
	if (m_pfnContinue && !((*(m_pfnContinue))(m_dwContinue)))
	{
	    m_error = ResultFromScode(E_ABORT);
	    return FALSE;
	}
    }

    if (m_fMetaDC)
    {
        switch (lpMFR->rdFunction)
	{
	    case META_SETWINDOWORG:
	        SetPictOrg (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0],
				FALSE);
		    return TRUE;
			
	    case META_OFFSETWINDOWORG:
	        SetPictOrg (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0],
			TRUE);
		    return TRUE;
		
	    case META_SETWINDOWEXT:
	        SetPictExt (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		    return TRUE;
		
	    case META_SCALEWINDOWEXT:
		ScalePictExt (hdc, (SHORT)lpMFR->rdParm[3], (SHORT)lpMFR->rdParm[2],
				(SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		return TRUE;
	
	    case META_SCALEVIEWPORTEXT:
		ScaleRectExt (hdc, (SHORT)lpMFR->rdParm[3], (SHORT)lpMFR->rdParm[2],
			(SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		return TRUE;
	
	    case META_SAVEDC:
	    {
	        BOOL fSucceeded = PushDc();
		LEVERIFY( fSucceeded );
		if (!fSucceeded)
		    return FALSE;
		break;
	    }

	    case META_RESTOREDC:
	 	LEVERIFY( PopDc() );
		break;

	    case META_SELECTPALETTE:
	    {
		// All selectpalette records are recorded such that the
                // palette is rendered in foreground mode.  Rather than
                // allowing the record to play out in this fashion, we
                // grab the handle and select it ourselves, forcing it
                // to background (using colors already mapped in the DC)

		// Dupe the palette.
 	        HPALETTE hPal = UtDupPalette((HPALETTE) lpHTable->objectHandle[lpMFR->rdParm[0]]);
                
		// Select the dupe into the DC.  EnumMetaFile calls DeleteObject
		// on the palette handle in the metafile handle table.  If that 
		// palette is currently selected into a DC, we rip and leak the
		// resource.
                LEVERIFY( NULL != SelectPalette(hdc, hPal, TRUE) );

		// if we had previously saved a palette, we need to delete
		// it (for the case of multiple SelectPalette calls in a 
		// MetaFile).
		if (m_hPalLast)
		{
		    DeleteObject(m_hPalLast);
		}

		// remember our duped palette so that it can be properly destroyed
		// later.
		m_hPalLast = hPal;

		return TRUE;
            }
	
	    case META_OFFSETVIEWPORTORG:
		AssertSz(0, "OffsetViewportOrg() in metafile");
		return TRUE;
		
	    case META_SETVIEWPORTORG:
		AssertSz(0, "SetViewportOrg() in metafile");
		return TRUE;
		
	    case META_SETVIEWPORTEXT:
		AssertSz(0, "SetViewportExt() in metafile");
		return TRUE;
		
	    case META_SETMAPMODE:
		AssertSz(lpMFR->rdParm[0] == MM_ANISOTROPIC,
			"SetmapMode() in metafile with invalid mapping mode");
		return TRUE;
		
	    default:
		break;
	}
    }
    else
    {       // non-metafile DC. (ScreenDC or other DC...)

        if (lpMFR->rdFunction == META_SELECTPALETTE)
	{
	// All selectpalette records are recorded such that the
        // palette is rendered in foreground mode.  Rather than
        // allowing the record to play out in this fashion, we
        // grab the handle and select it ourselves, forcing it
        // to background (using colors already mapped in the DC)

	    
	    HPALETTE hPal = UtDupPalette((HPALETTE) lpHTable->objectHandle[lpMFR->rdParm[0]]);

	    HPALETTE hPalOld = SelectPalette(hdc, hPal, TRUE);

	    if (!m_hPalDCOriginal)
	    {
	        m_hPalDCOriginal = hPalOld;
        }
	    else
	    {
	        // This case gets hit if we have already stored
			// the original palette from the DC.  This means
			// that hPalOld is a palette we have created using
			// UtDupPal above.  This means we need to delete
			// the old palette and remember the new one.

			if(hPalOld)
				DeleteObject(hPalOld);
  	    }

            m_hPalLast = hPal;

	    return TRUE;
        }
    }
	
    LEVERIFY( PlayMetaFileRecord (hdc, lpHTable, lpMFR, (unsigned) nObj) );
    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetPictOrg (private)
//
//  Synopsis:   Sets the hdc's origin via SetWindowOrg
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xOrg]          -- the x origin
//              [yOrg]          -- the y origin
//              [fOffset]       -- if TRUE, [xOrg] and [yOrg] are offsets
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::SetPictOrg
	(HDC hdc, int xOrg, int yOrg, BOOL fOffset)
{
	VDATEHEAP();

	if (fOffset)
	{

		m_pCurMdc->xMwo += xOrg;
		m_pCurMdc->yMwo += yOrg;
	}
	else
	{
		m_pCurMdc->xMwo = xOrg;
		m_pCurMdc->yMwo = yOrg;
	}

	if (m_pCurMdc->xMwe && m_pCurMdc->yMwe)
	{
		LEVERIFY ( SetWindowOrg (hdc,  // Review (davepl) MEIN GOT!
					(m_pCurMdc->xMwo -
				MulDiv (m_pMetaInfo->xro, m_pCurMdc->xMwe,
					m_pCurMdc->xre)),
			(m_pCurMdc->yMwo -
				MulDiv (m_pMetaInfo->yro, m_pCurMdc->yMwe,
					m_pCurMdc->yre))) );
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetPictExt
//
//  Synopsis:   Sets teh metafile's extents
//
//  Effects:
//
//  Arguments:  [hdc]   -- the device context
//              [xExt]  -- the X-extent
//              [yExt]  -- the Y-extent
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::SetPictExt (HDC hdc, int xExt, int yExt)
{
	VDATEHEAP();

	m_pCurMdc->xMwe = xExt;
	m_pCurMdc->yMwe = yExt;

	// Assert( m_pCurMdc->xre && m_pCurMdc->yre );

	int xNewExt = MulDiv (m_pMetaInfo->xwe, xExt, m_pCurMdc->xre);
	int yNewExt = MulDiv (m_pMetaInfo->ywe, yExt, m_pCurMdc->yre);

	int xNewOrg = m_pCurMdc->xMwo
		      - MulDiv (m_pMetaInfo->xro, xExt, m_pCurMdc->xre);
	int yNewOrg = m_pCurMdc->yMwo
		      - MulDiv (m_pMetaInfo->yro, yExt, m_pCurMdc->yre);

	LEVERIFY( SetWindowExt (hdc, xNewExt, yNewExt) );
	LEVERIFY( SetWindowOrg (hdc, xNewOrg, yNewOrg) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ScalePictExt
//
//  Synopsis:   Scales the metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xNum]          -- the x numerator
//              [xDenom]        -- the x demominator
//              [yNum]          -- the y numberator
//              [yDenom]        -- the y demoninator
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::ScalePictExt (HDC hdc,
					 int xNum,
					 int xDenom,
					 int yNum,
					 int yDenom)
{
	VDATEHEAP();

	Assert( xDenom && yDenom );

	int xNewExt = MulDiv (m_pCurMdc->xMwe, xNum, xDenom);
	int yNewExt = MulDiv (m_pCurMdc->yMwe, yNum, yDenom);

	SetPictExt(hdc, xNewExt, yNewExt);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ScaleRectExt
//
//  Synopsis:   scales the viewport
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xNum]          -- the x numerator
//              [xDenom]        -- the x demominator
//              [yNum]          -- the y numberator
//              [yDenom]        -- the y demoninator
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      Used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::ScaleRectExt(HDC hdc,
					int xNum,
					int xDenom,
					int yNum,
					int yDenom)
{
	VDATEHEAP();

	AssertSz( xDenom, "Denominator is 0 for x-rect scaling");
        AssertSz( yDenom, "Denominator is 0 for y-rect scaling");

	m_pCurMdc->xre = MulDiv (m_pCurMdc->xre, xNum, xDenom);
	m_pCurMdc->yre = MulDiv (m_pCurMdc->yre, yNum, yDenom);

	SetPictExt (hdc, m_pCurMdc->xMwe, m_pCurMdc->yMwe);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::PushDC
//
//  Synopsis:   pushes metafile info onto a stack
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    BOOL -- TRUE if successful, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      Used by the metafile interpreter engine.
//
//--------------------------------------------------------------------------

INTERNAL_(BOOL) CMfObject::PushDc (void)
{
	VDATEHEAP();

	LPMETADC        pNode = NULL;

	pNode = (LPMETADC) PrivMemAlloc(sizeof(METADC));
	
	if (pNode)
	{
		*pNode =  *m_pCurMdc;
		m_pCurMdc->pNext = pNode;
		pNode->pNext = NULL;
		m_pCurMdc = pNode;
		return TRUE;
	}

	m_error = ResultFromScode(E_OUTOFMEMORY);
	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::PopDC
//
//  Synopsis:   pops metafile info from the metafile info stack
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    BOOL -- TRUE if successful, FALSE otherwise (more pops
//              than pushes)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used in the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(BOOL) CMfObject::PopDc (void)
{
	VDATEHEAP();

	LPMETADC        pPrev = (LPMETADC) (m_pMetaInfo);
	LPMETADC        pCur  = ((LPMETADC) (m_pMetaInfo))->pNext;

	if (NULL == pCur)
	{
		LEWARN( NULL == pCur, "More pops than pushes from DC stack" );
		return FALSE;
	}

	while (pCur->pNext)
	{
		pPrev = pCur;
		pCur  = pCur->pNext;
	}

	if (pCur)
	{
		PrivMemFree(pCur);
	}
	
	pPrev->pNext = NULL;
	m_pCurMdc    = pPrev;

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CleanStack
//
//  Synopsis:   Deletes the stack of metafile info
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used in the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::CleanStack (void)
{
	VDATEHEAP();

	LPMETADC        pCur;

	while (NULL != (pCur = ((LPMETADC) (m_pMetaInfo))->pNext))
	{
		((LPMETADC) (m_pMetaInfo))->pNext = pCur->pNext;
		PrivMemFree(pCur);
	}

	PrivMemFree(m_pMetaInfo);
	
	m_pCurMdc      = NULL;
	m_pMetaInfo    = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   QD2GDI
//
//  Synopsis:   Converts macintosh pictures to Win32 GDI metafiles
//
//  Effects:
//
//  Arguments:  [hBits]         -- handle to the mac picture bits
//
//  Requires:
//
//  Returns:    HMETAFILE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Loads ole2conv.dll and calls QD2GDI in that dll
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(HMETAFILE) QD2GDI (HANDLE hBits)
{
	VDATEHEAP();

	USERPREFS userPrefs =
	{
		{'Q','D','2','G','D','I'},      //signature
		2,                              //structure version number
		sizeof(USERPREFS),              //structure size
		NULL,                           //source filename
		NULL,                           //or source handle
		NULL,                           //returned memory-based
						//metafile
		3,                              //simulated pattern lines
		5,                              //use max dimension
						//non-squarer pen
		1,                              //arithmetic transfer
		1,                              //create opaque text
		1,                              //simulate non-rectangular
						//regions
		0,                              //don't optimize for PowerPoint
		{0,0,0,0,0,0}                   //reserved
	};
	


	HINSTANCE       hinstFilter;
	void (FAR PASCAL *qd2gdiPtr)( USERPREFS FAR *, PICTINFO FAR *);
	PICTINFO        pictinfo;

	hinstFilter = LoadLibrary(OLESTR("OLECNV32.DLL"));

#if 0
	//REVIEW:CHICAGO

	//HINSTANCE_ERROR not defined in chicago

	if (hinstFilter < (HINSTANCE)HINSTANCE_ERROR)
	{
		return NULL;
	}
#endif

    if (hinstFilter == NULL)
    {
	return NULL;
    }

	*((FARPROC*)&qd2gdiPtr)  = GetProcAddress(hinstFilter, "QD2GDI");

	userPrefs.sourceFilename        = NULL;
	userPrefs.sourceHandle          = hBits;
	pictinfo.hmf                    = NULL;

	if (qd2gdiPtr == NULL)
	{
		goto errRtn;
	}
	
	(*qd2gdiPtr)( (USERPREFS FAR *)&userPrefs, (PICTINFO FAR *)&pictinfo);
	
errRtn:
	LEVERIFY( FreeLibrary(hinstFilter) );
	return (HMETAFILE)pictinfo.hmf;

}

//+-------------------------------------------------------------------------
//
//  Function:   MfGetSize
//
//  Synopsis:   Returns the size of a metafile
//
//  Effects:
//
//  Arguments:  [lphmf]         -- pointer to the metafile handle
//
//  Requires:
//
//  Returns:    DWORD -- the size of the metafile
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(DWORD) MfGetSize (LPHANDLE lphmf)
{
	VDATEHEAP();

	return GetMetaFileBitsEx((HMETAFILE)*lphmf,0,NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleIsDcMeta
//
//  Synopsis:   Returns whether a device context is really a metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//
//  Requires:
//
//  Returns:    BOOL (TRUE if a metafile)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)   OleIsDcMeta (HDC hdc)
{
	VDATEHEAP();

	return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Load
//
//  Synopsis:   Loads an metafile object from the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]              -- the stream from which to load
//              [fReadHeaderOnly]       -- if TRUE, then only the header is
//                                         read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Load(LPSTREAM lpstream, BOOL fReadHeaderOnly)
{
	VDATEHEAP();

	DWORD           dwBuf[4];
	HRESULT         error;
	
	/* read dwCompression, width, height, size of data */
	error = StRead(lpstream, dwBuf, 4*sizeof(DWORD));
	if (error)
	{
		return error;
	}

	AssertSz (dwBuf[0] == 0, "Picture compression factor is non-zero");
	
	m_lWidth  = (LONG) dwBuf[1];
	m_lHeight = (LONG) dwBuf[2];
	m_dwSize  = dwBuf[3];

	if (!m_dwSize || fReadHeaderOnly)
	{
		return NOERROR;
	}
	
	return UtGetHMFFromMFStm(lpstream, m_dwSize, m_fConvert,
		(LPLPVOID) &m_hPres);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Save
//
//  Synopsis:   Saves the metafile to the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]      -- the stream to save to
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Save(LPSTREAM lpstream)
{
	VDATEHEAP();

	HRESULT         error;
	DWORD           dwBuf[4];
	
	/* write dwCompression, width, height, size of data */

	dwBuf[0]  = 0L;
	dwBuf[1]  = (DWORD) m_lWidth;
	dwBuf[2]  = (DWORD) m_lHeight;
	dwBuf[3]  = m_dwSize;

	error = StWrite(lpstream, dwBuf, sizeof(dwBuf));
	if (error)
	{
		return error;
	}


	// if blank object, don't write any more; no error.
	if (IsBlank() || m_hPres == NULL)
	{
		StSetSize(lpstream, 0, TRUE);
		return NOERROR;
	}
	
	return UtHMFToMFStm((LPLPVOID)&m_hPres, m_dwSize, lpstream);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetExtent
//
//  Synopsis:   Retrieves the extents of the metafile
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect we're interested in
//                                 (must match the aspect of the current
//                                 metafile)
//              [lpsizel]       -- where to put the extent info
//
//  Requires:
//
//  Returns:    NOERROR, DV_E_DVASPECT, OLE_E_BLANK
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	VDATEHEAP();

	if (0 == (dwDrawAspect & m_dwAspect))
	{
		return ResultFromScode(DV_E_DVASPECT);
	}
	
	if (IsBlank())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	lpsizel->cx = m_lWidth;
	lpsizel->cy = m_lHeight;
	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::IsBlank
//
//  Synopsis:   Returns whether or not the metafile is blank
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CMfObject::IsBlank(void)
{
	VDATEHEAP();

	return (m_dwSize ? FALSE : TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::LoadHPRES (private)
//
//  Synopsis:   Loads the presentation from the cache's stream and returns
//              a handle to it
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE to the metafile
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CMfObject::LoadHPRES(void)
{
	VDATEHEAP();

	LPSTREAM        pstm;
	
	pstm = m_pCacheNode->GetStm(TRUE /*fSeekToPresBits*/, STGM_READ);
	if (pstm)
	{
		LEVERIFY( SUCCEEDED(Load(pstm)));
		pstm->Release();
	}
	
	return m_hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::DiscardHPRES
//
//  Synopsis:   deletes the stored metafile
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CMfObject::DiscardHPRES(void)
{
	VDATEHEAP();

	if (m_hPres)
	{
		LEVERIFY( DeleteMetaFile (m_hPres) );
		m_hPres = NULL;
	}
}
	

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetCopyOfHPRES (private)
//
//  Synopsis:   makes a copy of the metafile (if one is present), otherwise
//              just load it from the stream (but don't store it in [this]
//              object)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE to the metafile
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(HANDLE) CMfObject::GetCopyOfHPRES(void)
{
	VDATEHEAP();

	HANDLE          hPres;
	
	// Make a copy if the presentation data is already loaded
	if (m_hPres)
	{
		return CopyMetaFile(m_hPres, NULL);
	}
	
	// Load the presentation data now and return the same handle.
	// No need to copy the data. If the caller wants the m_hPres to be
	// set he would call LoadHPRES() directly.

	hPres = LoadHPRES();
	m_hPres = NULL;	    // NULL this, LoadHPRES set it.
	return hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMfObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszHRESULT;
    char *pszDVASPECT;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References                 = " << m_ulRefs     << endl;

    dstrDump << pszPrefix << "pMETAINFO (Metafile information)  = " << m_pMetaInfo  << endl;

    dstrDump << pszPrefix << "pMETADC (current device context)  = " << m_pCurMdc    << endl;

    dstrDump << pszPrefix << "IsMetaDeviceContext?              = ";
    if (m_fMetaDC == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    dstrDump << pszPrefix << "No. of Records in Metafile        = " << m_nRecord    << endl;

    pszHRESULT = DumpHRESULT(m_error);
    dstrDump << pszPrefix << "Error code                        = " << pszHRESULT   << endl;
    CoTaskMemFree(pszHRESULT);

    dstrDump << pszPrefix << "pLOGPALETTE (Color set palette)   = " << m_pColorSet  << endl;

    dstrDump << pszPrefix << "ConvertFromMac?                   = ";
    if (m_fConvert == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    dstrDump << pszPrefix << "Continue                          = " << ((ULONG) m_dwContinue) << endl;

    dstrDump << pszPrefix << "fp Continue                       = " << m_pfnContinue<< endl;

    pszDVASPECT = DumpDVASPECTFlags(m_dwAspect);
    dstrDump << pszPrefix << "Aspect flags                      = " << pszDVASPECT  << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "Size                              = " << m_dwSize     << endl;

    dstrDump << pszPrefix << "Width                             = " << m_lWidth     << endl;

    dstrDump << pszPrefix << "Height                            = " << m_lHeight    << endl;

    dstrDump << pszPrefix << "pCacheNode                        = " << m_pCacheNode << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMfObject, public (_DEBUG only)
//
//  Synopsis:   calls the CMfObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMFO]          - pointer to CMfObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMfObject(CMfObject *pMFO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMFO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMFO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\stdimpl\olereg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olereg.cpp
//
//  Contents:   Helper routines to interrogate the reg database
//
//  Classes:
//
//  Functions:  OleRegGetUserType
//              OleRegGetMiscStatus
//              OleGetAutoConvert
//              OleSetAutoConvert
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              30-Nov-93 alexgo    32bit port
//              11-Nov-92 jasonful  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(olereg)

#include <reterr.h>
#include "oleregpv.h"
#include <ctype.h>

ASSERTDATA
#define MAX_STR 512

// Reg Db Keys
static const OLECHAR szAuxUserTypeKey[]         = OLESTR("AuxUserType");
static const OLECHAR szMiscStatusKey[]          = OLESTR("MiscStatus") ;
static const OLECHAR szProgIDKey[]              = OLESTR("ProgID");
static const OLECHAR szClsidKey[]               = OLESTR("Clsid");
static const OLECHAR szAutoConverTo[]    = OLESTR("AutoConvertTo");

// this is really a global variable
const OLECHAR szClsidRoot[]     = OLESTR("CLSID\\");


static INTERNAL OleRegGetDword
        (HKEY           hkey,
        LPCOLESTR       szKey,
        DWORD FAR*      pdw);

static INTERNAL OleRegGetDword
        (HKEY           hkey,
        DWORD           dwKey,
        DWORD FAR*      pdw);

static INTERNAL OleRegGetString
        (HKEY           hkey,
        LPCOLESTR       szKey,
        LPOLESTR FAR*   pszValue);


static  INTERNAL OleRegGetString
        (HKEY           hkey,
        DWORD           dwKey,
        LPOLESTR FAR*   pszValue);

//+-------------------------------------------------------------------------
//
//  Function:   Atol (static)
//
//  Synopsis:   Converts string to integer
//
//  Effects:
//
//  Arguments:  [sz]    -- the string
//
//  Requires:
//
//  Returns:    LONG
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      32bit OLE just uses wcstol as a #define
//
//              original 16bit comment:
//
//              Replacement for stdlib atol,
//              which didn't work and doesn't take far pointers.
//              Must be tolerant of leading spaces.
//
//--------------------------------------------------------------------------
#ifndef WIN32
#pragma SEG(Atol)
FARINTERNAL_(LONG) Atol
        (LPOLESTR sz)
{
        VDATEHEAP();

        signed int      sign = +1;
        UINT            base = 10;
        LONG            l = 0;

        if (NULL==sz)
        {
                Assert (0);
                return 0;
        }
        while (isspace(*sz))
        {
                sz++;
        }

        if (*sz== OLESTR('-'))
        {
                sz++;
                sign = -1;
        }
        if (sz[0]==OLESTR('0') && sz[1]==OLESTR('x'))
        {
                base = 16;
                sz+=2;
        }

        if (base==10)
        {
                while (isdigit(*sz))
                {
                        l = l * base + *sz - OLESTR('0');
                        sz++;
                }
        }
        else
        {
                Assert (base==16);
                while (isxdigit(*sz))
                {
                        l = l * base + isdigit(*sz) ? *sz - OLESTR('0') :
                                toupper(*sz) - OLESTR('A') + 10;
                        sz++;
                }
        }
        return l * sign;
}
#endif  //!WIN32



//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetDword
//
//  Synopsis:   returns the value of subkey "szKey" as a DWORD
//
//  Effects:
//
//  Arguments:  [hkey]  -- handle to a key in the regdb
//              [szKey] -- the subkey to look for
//              [pdw]   -- where to put the dword
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetDword)
static INTERNAL OleRegGetDword
        (HKEY           hkey,
        LPCOLESTR       szKey,
        DWORD FAR*      pdw)
{
        VDATEHEAP();

        VDATEPTRIN (pdw, DWORD);

        LPOLESTR        szLong = NULL;

        HRESULT hresult = OleRegGetString (hkey, szKey, &szLong);
        if (hresult != NOERROR)
        {
                return hresult;
        }
        *pdw = Atol (szLong);
        PubMemFree(szLong);
        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetDword (overloaded)
//
//  Synopsis:   Gets a dword from a sub-key given as a dword
//
//  Effects:
//
//  Arguments:  [hkey]  -- handle to a key in the regdb
//              [dwKey] -- number to convert to a string key to lookup in
//                         the regdb
//              [pdw]   -- where to put the dword
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  This deep layering is kinda strange, as each
//              overloaded function is used exactly once.  It might be
//              better just to inline the stuff and be done with it.
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetDword)
static  INTERNAL OleRegGetDword
        (HKEY           hkey,
        DWORD           dwKey,
        DWORD FAR*      pdw)
{
        VDATEHEAP();

        OLECHAR szBuf[MAX_STR];
        wsprintf(szBuf, OLESTR("%ld"), dwKey);

        return OleRegGetDword (hkey, szBuf, pdw);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetString
//
//  Synopsis:   Return the value of subkey [szKey] of key [hkey] as a string
//
//  Effects:
//
//  Arguments:  [hkey]          -- a handle to a key in the reg db
//              [szKey]         -- the subkey to get the value of
//              [ppszValue]     -- where to put the value string
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR, E_OUTOFMEMORY, REGDB_E_KEYMISSING)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//              15-Dec-93 ChrisWe   cb is supposed to be the size of the
//                                  buffer in bytes; changed to use sizeof()
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetString)
static INTERNAL OleRegGetString
        (HKEY           hkey,
        LPCOLESTR       szKey,
        LPOLESTR FAR*   ppszValue)
{
        VDATEHEAP();

        OLECHAR         szBuf [MAX_STR];
        LONG            cb = sizeof(szBuf);

        *ppszValue = NULL;

        if (ERROR_SUCCESS == RegQueryValue (hkey, (LPOLESTR) szKey,
                szBuf, &cb))
        {
                *ppszValue = UtDupString (szBuf);
                return *ppszValue ? NOERROR : ResultFromScode (E_OUTOFMEMORY);
        }
        return ReportResult(0, REGDB_E_KEYMISSING, 0, 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetString (overloaded)
//
//  Synopsis:   Gets the string value of the DWORD subkey
//
//  Effects:
//
//  Arguments:  [hkey]          -- handle to a key in the regdb
//              [dwKey]         -- the subkey value
//              [ppszValue]     -- where to put the return value
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL OleRegGetString
        (HKEY           hkey,
        DWORD           dwKey,
        LPOLESTR FAR*   ppszValue)
{
        VDATEHEAP();

        OLECHAR szBuf[MAX_STR];
        wsprintf(szBuf, OLESTR("%ld"), dwKey);

        return OleRegGetString (hkey, szBuf, ppszValue);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetUserType
//
//  Synopsis:   Returns the user type name for the class id.
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID to look up
//              [dwFormOfType]  -- flag indicating whether the fullname,
//                                 shortname, or app name is desired
//              [ppszUserType]  -- where to put the type string
//
//  Requires:   returned string must be deleted
//
//  Returns:    HRESULT (NOERROR, OLE_E_CLSID)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetUserType)
STDAPI OleRegGetUserType
        (REFCLSID       clsid,
        DWORD           dwFormOfType,  // as in IOleObject::GetUserType
        LPOLESTR FAR*   ppszUserType)   // out parm
{
        OLETRACEIN((API_OleRegGetUserType, PARAMFMT("clsid= %I, dwFormOfType= %x, ppszUserType= %p"),
                        &clsid, dwFormOfType, ppszUserType));

        VDATEHEAP();

        LPOLESTR    pszTemp;
        HKEY        hkeyClsid = NULL;
        HKEY        hkeyAux   = NULL;
        HRESULT     hresult   = NOERROR;

        VDATEPTROUT_LABEL (ppszUserType, LPOLESTR, safeRtn, hresult);
        *ppszUserType = NULL;

        ErrRtnH(CoOpenClassKey(clsid, FALSE, &hkeyClsid));

        if (dwFormOfType == USERCLASSTYPE_FULL ||
                ERROR_SUCCESS != RegOpenKey (hkeyClsid, szAuxUserTypeKey,
                &hkeyAux))
        {
                // use Main User Type Name (value of key CLSID(...))
                hresult = OleRegGetString(hkeyClsid, (LPOLESTR)NULL,
                                          &pszTemp);
                if (SUCCEEDED(hresult))
                {
                    // If no user type string is registered under the class key,
                    // OleRegGetString returns NOERROR and returns an empty string.
                    // We need to check for this and return the appropriate error.
                    if ( !pszTemp[0] )
                    {
                        PubMemFree(pszTemp);
                        hresult = ResultFromScode(REGDB_E_INVALIDVALUE);
                        goto errRtn;
                    }
                    *ppszUserType = pszTemp;
                }
        }
        else
        {
                // look under key AuxUserType
                if (NOERROR !=
                        OleRegGetString (hkeyAux, dwFormOfType, ppszUserType)
                        || NULL==*ppszUserType
                        || '\0'==(*ppszUserType)[0])
                {
                        // Couldn't find the particular FormOfType requested,
                        // so use Full User Type Name (value of main
                        // CLSID key), as per spec
                        ErrRtnH (OleRegGetString (hkeyClsid, (LPOLESTR)NULL,
                                ppszUserType));
                }
        }

  errRtn:

        CLOSE (hkeyClsid);
        CLOSE (hkeyAux);

  safeRtn:
        OLETRACEOUT((API_OleRegGetUserType, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetMiscStatus
//
//  Synopsis:   Retrieves misc status bits from the reg db
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID
//              [dwAspect]      -- specify the aspect (used in querrying
//                                 the reg db)
//              [pdwStatus]     -- return to return the status bits
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:      Uses default (0) is the MiscStatus key is missing
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetMiscStatus)
STDAPI OleRegGetMiscStatus
        (REFCLSID       clsid,
        DWORD           dwAspect,
        DWORD FAR*      pdwStatus)
{
        OLETRACEIN((API_OleRegGetMiscStatus, PARAMFMT("clsid= %I, dwAspect= %x, pdwStatus= %p"),
                        &clsid, dwAspect, pdwStatus));

        VDATEHEAP();

        HKEY            hkeyClsid       = NULL;
        HKEY            hkeyMisc        = NULL;
        HRESULT         hresult         = NOERROR;

        VDATEPTROUT_LABEL(pdwStatus, DWORD, safeRtn, hresult);
        *pdwStatus = 0;

        ErrRtnH(CoOpenClassKey(clsid, FALSE, &hkeyClsid));

        // Open MiscStatus key
        if (ERROR_SUCCESS != RegOpenKey (hkeyClsid, szMiscStatusKey,
                &hkeyMisc))
        {
                // MiscStatus key not there, so use default.
                hresult = NOERROR;
                goto errRtn;
        }
        if (OleRegGetDword (hkeyMisc, dwAspect, pdwStatus) != NOERROR)
        {
                // Get default value from main Misc key
                ErrRtnH (OleRegGetDword (hkeyMisc,
                        (LPOLESTR)NULL, pdwStatus));
                // Got default value
        }
        // Got value for dwAspect

  errRtn:
        CLOSE (hkeyMisc);
        CLOSE (hkeyClsid);

  safeRtn:
        OLETRACEOUT((API_OleRegGetMiscStatus, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleGetAutoConvert
//
//  Synopsis:   Retrieves the class ID that [clsidOld] should be converted
//              to via auto convert
//
//  Effects:
//
//  Arguments:  [clsidOld]      -- the original class ID
//              [pClsidNew]     -- where to put the new convert-to class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Apr-94 kevinro   removed bogus assert, restructured
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleGetAutoConvert)
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew)
{
        OLETRACEIN((API_OleGetAutoConvert, PARAMFMT("clsidOld= %I, pClsidNew= %p"),
                        &clsidOld, pClsidNew));

        VDATEHEAP();

        HRESULT hresult;
        HKEY hkeyClsid = NULL;
        LPOLESTR lpszClsid = NULL;
        VDATEPTROUT_LABEL (pClsidNew, CLSID, errRtn, hresult);
        *pClsidNew = CLSID_NULL;

        hresult = CoOpenClassKey(clsidOld, FALSE, &hkeyClsid);
        if (FAILED(hresult))
        {
            goto errRtn;
        }

        hresult = OleRegGetString(hkeyClsid, szAutoConverTo, &lpszClsid);

        if (SUCCEEDED(hresult))
        {
                // Its Possible there is an AutoConvert Key under the CLSID but it has not value

                if (OLESTR('\0') == lpszClsid[0])
                {
                        hresult = REGDB_E_KEYMISSING;
                }
                else
                {
                        // convert string into CLSID
                        hresult = CLSIDFromString(lpszClsid, pClsidNew);
                }
        }

        CLOSE(hkeyClsid);
        PubMemFree(lpszClsid);

errRtn:
        OLETRACEOUT((API_OleGetAutoConvert, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetAutoConvert
//
//  Synopsis:   Sets the autoconvert information in the regdb
//
//  Effects:
//
//  Arguments:  [clsidOld]      -- the original class id
//              [clsidNew]      -- that class id that [clsidOld] should be
//                                 auto-converted to
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleSetAutoConvert)
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew)
{
        OLETRACEIN((API_OleSetAutoConvert, PARAMFMT("clsidOld= %I, clsidNew= %I"),
                                &clsidOld, &clsidNew));

        VDATEHEAP();

        HRESULT         hresult;
        HKEY            hkeyClsid = NULL;

        ErrRtnH(CoOpenClassKey(clsidOld, TRUE, &hkeyClsid));

        if (IsEqualCLSID(clsidNew, CLSID_NULL))
        {
                // ignore error since there may not be a value at present
                (void)RegDeleteKey(hkeyClsid, szAutoConverTo);
        }
        else
        {
                OLECHAR szClsid[MAX_STR];
                Verify(StringFromCLSID2(clsidNew, szClsid, sizeof(szClsid))
                        != 0);

                if (RegSetValue(hkeyClsid, szAutoConverTo, REG_SZ, szClsid,
                        _xstrlen(szClsid)) != ERROR_SUCCESS)
                {
                        hresult = ResultFromScode(REGDB_E_WRITEREGDB);
                }
        }

errRtn:
        CLOSE(hkeyClsid);

        OLETRACEOUT((API_OleSetAutoConvert, hresult));

        return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\stdimpl\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   stdimpl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\com\dcomrem;..\..\..\com\objact
INCLUDES=     $(INCLUDES);..\..\..\com\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)

C_DEFINES=    \
              $(C_DEFINES)          \
              -D_TRACKLINK_=1

SOURCES=      \
              ..\defcf.cpp    \
              ..\defhndlr.cpp \
              ..\deflink.cpp  \
              ..\defutil.cpp  \
              ..\gen.cpp      \
              ..\icon.cpp     \
              ..\mf.cpp       \
              ..\emf.cpp      \
              ..\olereg.cpp   \
              ..\oregfmt.cpp  \
              ..\oregverb.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\stdimpl\oregverb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oregverb.cpp
//
//  Contents:   Implementation of the enumerator for regdb verbs
//
//  Classes:    CEnumVerb
//
//  Functions:  OleRegEnumVerbs
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  made cache thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              12-Jul-95 t-gabes   cache verbs and enumerator
//              01-Feb-95 t-ScottH  add Dump method to CEnumVerb and API
//                                  DumpCEnumVerb
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              31-Dec-93 erikgav   chicago port
//              01-Dec-93 alexgo    32bit port
//              12-Nov-93 jasonful  author
//
//--------------------------------------------------------------------------


#include <le2int.h>
#pragma SEG(oregverb)

#include <reterr.h>
#include "oleregpv.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

ASSERTDATA

#define MAX_STR                 256
#define MAX_VERB                33
#define OLEIVERB_LOWEST         OLEIVERB_HIDE

// reg db key
static const OLECHAR VERB[] = OLESTR("\\Verb");

// stdfileediting key
static const OLECHAR STDFILE[] = OLESTR("\\Protocol\\StdFileEditing");

// default verbs
static const OLECHAR DEFVERB[] =
        OLESTR("Software\\Microsoft\\OLE1\\UnregisteredVerb");

// default verb
static const OLECHAR EDIT[] = OLESTR("Edit");

//+-------------------------------------------------------------------------
//
//  Struct:     VerbList
//
//  Purpose:    to hold the enumerator's list of verbs
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   author
//
//  Notes:
//
//--------------------------------------------------------------------------

typedef struct VerbList
{
    ULONG       cRef;           // reference count
    CLSID       clsid;          // CLSID of the cached verbs
    ULONG       cVerbs;         // count of verbs in oleverb array
    OLEVERB     oleverb[1];     // variable-size list of verbs
} VERBLIST, *LPVERBLIST;

STDAPI MakeVerbList(HKEY hkey, REFCLSID rclsid, LPVERBLIST *ppVerbList);
STDAPI OleReleaseEnumVerbCache(void);

//+-------------------------------------------------------------------------
//
//  Class:      CEnumVerb
//
//  Purpose:    enumerates the verbs listed in the reg db for a given class
//
//  Interface:  IEnumOLEVERB
//
//  History:    dd-mmm-yy Author    Comment
//              02-Aug-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CEnumVerb : public IEnumOLEVERB, public CPrivAlloc
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB reelt,
            ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (THIS_ ULONG celt);
    STDMETHOD(Reset) (THIS);
    STDMETHOD(Clone) (THIS_ LPENUMOLEVERB FAR* ppenm);

    ULONG GetRefCount (void);

#ifdef _DEBUG
    HRESULT Dump (char **ppszDump, ULONG ulFlag, int nIndentLevel);
    friend char *DumpCEnumVerb (CEnumVerb *pEV, ULONG ulFlag, int nIndentLevel);
#endif // _DEBUG

private:
    CEnumVerb (LPVERBLIST pVerbs, LONG iVerb=0);

    ULONG       m_cRef;         // reference count
    LONG        m_iVerb;        // current verb number (0 is the first)
    LPVERBLIST  m_VerbList;     // all the verbs for this class

    friend HRESULT STDAPICALLTYPE OleRegEnumVerbs (REFCLSID, LPENUMOLEVERB FAR*);
    friend HRESULT STDAPICALLTYPE OleReleaseEnumVerbCache(void);
};

//+-------------------------------------------------------------------------
//
//  Struct:     EnumVerbCache
//
//  Purpose:    to cache the enumerator for the last enumerated class
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   author
//
//
//--------------------------------------------------------------------------

typedef struct
{
    CEnumVerb*  pEnum;      // pointer to the cached enumerator
#ifdef _DEBUG
    LONG        iCalls;     // total calls counter
    LONG        iHits;      // cache hit counter
#endif // _DEBUG
} EnumVerbCache;

// Last enumerator used
EnumVerbCache g_EnumCache = { NULL };

//+-------------------------------------------------------------------------
//
//  Function:   OleRegEnumVerbs
//
//  Synopsis:   Creates an enumerator to go through the verbs in the reg db
//              for the given class ID
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID we're interested in
//              [ppenum]        -- where to put the enumerator pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Makes sure that the info is in the database and then
//              creates the enumerator
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              12-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegEnumVerbs)
STDAPI OleRegEnumVerbs
        (REFCLSID           clsid,
        LPENUMOLEVERB FAR*  ppenum)
{
    OLETRACEIN((API_OleRegEnumVerbs, PARAMFMT("clsid= %I, ppenum= %p"),
                    &clsid, ppenum));
    VDATEHEAP();

    CEnumVerb*  pEnum;
    LPVERBLIST  pVerbList;
    BOOL        fOle1Class;
    OLECHAR     szKey[MAX_STR];
    int         cchBase;
    HKEY        hkey;
    HRESULT     hresult;

    VDATEPTROUT_LABEL (ppenum, LPENUMOLEVERB, errSafeRtn, hresult);
    *ppenum = NULL;

#ifdef _DEBUG
    // Increment total calls counter
    InterlockedIncrement(&g_EnumCache.iCalls);
#endif // _DEBUG
    // Grab the global enumerator and put a NULL in its place. If another
    // thread calls into OleRegEnumVerbs during this operation they won't
    // be able to mess with the enumerator we're working with.
    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, 0);
    if (pEnum != NULL)
    {
        if (IsEqualCLSID(clsid, pEnum->m_VerbList->clsid))
        {
#ifdef _DEBUG
            // Increment cache hits counter
            InterlockedIncrement(&g_EnumCache.iHits);
#endif

            if (1 == pEnum->GetRefCount())
            {
                // No other references -> AddRef and return this copy
                *ppenum = pEnum;
                pEnum->AddRef();
                pEnum->Reset();
                LEDebugOut((DEB_TRACE, "VERB Enumerator cache handed out\n"));
            }
            else
            {
                // Has additional references -> return a Cloned copy
                if (NOERROR == pEnum->Clone(ppenum))
                {
                    (*ppenum)->Reset();
                    LEDebugOut((DEB_TRACE, "VERB Enumerator cache cloned\n"));
                }
            }

            // Swap our enumerator with the current contents of the global. If
            // another thread called OleRegEnumVerbs during this operation and
            // stored an enumerator in the global, we need to Release it.
            pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, (PVOID)pEnum);
            if (pEnum != NULL)
            {
                pEnum->Release();
                LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (replacing global)\n"));
            }

            goto errRtn;
        }
        else
        {
            // Our clsid didn't match the clsid of the cache so we'll release the
            // cached enumerator and proceed with creating a new enumerator to
            // store in the global cache.
            pEnum->Release();
            LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (different CLSID)\n"));
        }
    }

    fOle1Class = CoIsOle1Class(clsid);

    if (fOle1Class)
    {
        // Fills out szKey and cchBase as follows:
        //   szKey   - "<ProgID>\Protocol\StdFileEditing"
        //   cchBase - length of "<ProgID>" portion

        LPOLESTR    psz;

        RetErr(ProgIDFromCLSID(clsid, &psz));

        cchBase = _xstrlen(psz);

        memcpy(szKey, psz, cchBase * sizeof(OLECHAR));
        memcpy(&szKey[cchBase], STDFILE, sizeof(STDFILE));

        PubMemFree(psz);
    }
    else
    {
        // Fills out szKey and cchBase as follows:
        //   szKey   - "CLSID\{clsid}"
        //   cchBase - length of full szKey string

        memcpy(szKey, szClsidRoot, sizeof(szClsidRoot));

        if (0 == StringFromCLSID2(clsid, &szKey[sizeof(szClsidRoot) / sizeof(OLECHAR) - 1], sizeof(szKey)))
            return ResultFromScode(E_OUTOFMEMORY);

        cchBase = _xstrlen(szKey);
    }

    // append "\Verb" to the end
    _xstrcat(szKey, VERB);

    if (ERROR_SUCCESS != RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                szKey,
                NULL,
                KEY_READ,
                &hkey))
    {
        // verb key doesn't exist, so figure out why

        szKey[cchBase] = OLESTR('\0');
        // szKey now contains one of the following:
        //   OLE1 - "<ProgID>"
        //   OLE2 - "CLSID\{clsid}"

        if (ERROR_SUCCESS != RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    szKey,
                    NULL,
                    KEY_READ,
                    &hkey))
        {
            // the class isn't registered
            return ReportResult(0, REGDB_E_CLASSNOTREG, 0, 0);
        }

        CLOSE(hkey);

        // The class has no verbs. This is fine for OLE1 but not OLE2
        if (!fOle1Class)
            return ResultFromScode(OLEOBJ_E_NOVERBS);

        // if hkey is NULL, MakeVerbList will use the default verb
        hkey = NULL;
    }

    // make the verb list
    RetErr(MakeVerbList(hkey, clsid, &pVerbList));
    Assert(pVerbList != NULL);

    // create a CEnumVerb object (this calls AddRef on pVerbList)
    pEnum = new FAR CEnumVerb(pVerbList);
    if (NULL == pEnum)
    {
        PrivMemFree(pVerbList);
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errSafeRtn;
    }

    // set the out parameter and AddRef on behalf of the caller
    *ppenum = pEnum;
    pEnum->AddRef();

    LEDebugOut((DEB_TRACE, "VERB Enumerator cache created\n"));

    // Swap our enumerator with the current contents of the global. If
    // another thread called OleRegEnumVerbs during this operation and
    // stored an enumerator in the global, we need to Release it.
    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, (PVOID)pEnum);
    if (pEnum != NULL)
    {
        pEnum->Release();
        LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (replacing global)\n"));
    }

errRtn:
    hresult = *ppenum ? NOERROR : ResultFromScode (E_OUTOFMEMORY);

    // hook the new interface
    CALLHOOKOBJECTCREATE(S_OK, CLSID_NULL, IID_IEnumOLEVERB, (IUnknown **)ppenum);

errSafeRtn:
    LEDebugOut((DEB_TRACE, "VERB Enumerator cache hits/calls: (%d/%d)\n", g_EnumCache.iHits, g_EnumCache.iCalls));
    OLETRACEOUT((API_OleRegEnumVerbs, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   MakeVerbList
//
//  Synopsis:   gets the list of verbs from the reg db
//
//  Effects:
//
//  Arguments:  [hkey]          -- handle to reg key to get verbs from
//                                 NULL for default verb
//              [rclsid]        -- CLSID to store with verb list
//              [ppVerbList]    -- OUT paramater for where to put result
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: none
//
//  Algorithm:  Calls RegEnumKey to loop through the reg keys and create a
//              list of verbs, which are then collected into one
//              larger list.  Also, flags and attribs are parsed out.
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              14-Jul-95 t-gabes   Author
//
//  Notes:
//              OLEVERB flags are given default values if they are not in
//              reg db. This works well for OLE 1.0
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_MakeVerbList)
STDAPI MakeVerbList
        (HKEY       hkey,
        REFCLSID    rclsid,
        LPVERBLIST  *ppVerbList)
{
    VDATEHEAP();

    LONG        cbValue;
    LPVERBLIST  pVerbList;
    OLECHAR     szBuf[MAX_VERB];        // regdb buffer
    OLEVERB *   rgVerbs = NULL;         // verb info array
    OLECHAR *   pszNames = NULL;        // list of NULL-delimited verb names
    DWORD       cchSpace = 0;           // space left for verb names (in bytes)
    DWORD       cchName;                // size of one name (in bytes)
    DWORD       cVerbs;                 // number of verbs
    DWORD       iVerbs;                 // verb array index
    LONG        maxVerbIdx = 0;
    LONG        maxVerbNum = OLEIVERB_LOWEST;
    LONG        minVerbNum = OLEIVERB_LOWEST - 1;
    HRESULT     hresult = NOERROR;

    VDATEPTROUT(ppVerbList, LPVERBLIST);
    *ppVerbList = NULL;

    if (NULL == hkey)
    {
        /*
         * No verbs registered
         */

        cbValue = sizeof(szBuf);

        // read the default verb name from the reg db
        if (ERROR_SUCCESS != RegQueryValue(
                HKEY_CLASSES_ROOT,
                DEFVERB,
                szBuf,
                &cbValue))
        {
            // when all else fails, use the string "Edit"
            _xstrcpy(szBuf, EDIT);
            cbValue = sizeof(EDIT);
        }

        pVerbList = (LPVERBLIST)PrivMemAlloc(sizeof(VERBLIST) + cbValue);
        if (NULL == pVerbList)
            return ResultFromScode(E_OUTOFMEMORY);

        // fill out a single verb with the defaults
        pVerbList->cRef = 0;
        pVerbList->clsid = rclsid;
        pVerbList->cVerbs = 1;
        pVerbList->oleverb[0].lVerb = 0;
        pVerbList->oleverb[0].fuFlags = MF_STRING | MF_UNCHECKED | MF_ENABLED;
        pVerbList->oleverb[0].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;
        pVerbList->oleverb[0].lpszVerbName = (LPOLESTR)&pVerbList->oleverb[1];
        memcpy(pVerbList->oleverb[0].lpszVerbName, szBuf, cbValue);

        *ppVerbList = pVerbList;
        return NOERROR;
    }

    /*
     * Have registered verbs
     */

    // determine number of subkeys
    hresult = RegQueryInfoKey(
            hkey, NULL, NULL, NULL, &cVerbs,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != hresult || !cVerbs)
    {
        // they have a "Verb" key but no verb subkeys
        hresult = ResultFromScode(OLEOBJ_E_NOVERBS);
        goto errRtn;
    }

    // preallocate this much space for verb names (in bytes)
    cchSpace = sizeof(OLECHAR) * cVerbs * 32;

    // allocate the VerbList with space for each OLEVERB
    // and space for 32 characters for each verb name
    pVerbList = (LPVERBLIST)PrivMemAlloc(
            sizeof(VERBLIST) +
            sizeof(OLEVERB) * (cVerbs - 1) +
            cchSpace);

    if (NULL == pVerbList)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pVerbList->cRef = 0;
    pVerbList->clsid = rclsid;
    pVerbList->cVerbs = cVerbs;

    // Allocate temporary storage for the verbs. Later we'll move the verbs
    // from this list into the final VerbList in sorted order.
    rgVerbs = (OLEVERB *)PrivMemAlloc(sizeof(OLEVERB) * cVerbs);

    if (NULL == rgVerbs)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // point pszNames at the first verb name
    pszNames = (OLECHAR *)&pVerbList->oleverb[cVerbs];

    for (iVerbs = 0; iVerbs < cVerbs; iVerbs++)
    {
        LPOLESTR    psz = pszNames;

        // read a verb number
        hresult = RegEnumKey(hkey, iVerbs, szBuf, MAX_VERB);
        if (NOERROR != hresult)
            goto errRtn;

        // this is how much space remains
        cbValue = cchSpace;

        // read a verb name on the verb number
        hresult = RegQueryValue(hkey, szBuf, pszNames, &cbValue);
        if (NOERROR != hresult)
            goto errRtn;

        // for safety, make sure verb name isn't too long
        if (cbValue > (MAX_VERB + 8) * sizeof(OLECHAR))
        {
            cbValue = (MAX_VERB + 8) * sizeof(OLECHAR);
            pszNames[MAX_VERB + 8 - 1] = OLESTR('\0');
        }

        rgVerbs[iVerbs].lVerb = Atol(szBuf);

        if (rgVerbs[iVerbs].lVerb > maxVerbNum)
        {
            maxVerbNum = rgVerbs[iVerbs].lVerb;
            maxVerbIdx = iVerbs;
        }

        rgVerbs[iVerbs].fuFlags = MF_STRING | MF_UNCHECKED | MF_ENABLED;
        rgVerbs[iVerbs].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;

        // see if the verb name is followed by a delimiter
        while (*psz && *psz != DELIM[0])
            psz++;

        // determine size of verb name (in characters)
        cchName = (ULONG)(psz - pszNames + 1);

        if (*psz == DELIM[0])
        {
            // Parse the menu flags and attributes by finding each delimiter
            // and stuffing a 0 over it. This breaks the string into three
            // parts which can be handled separately.
            LPOLESTR    pszFlags;

            *psz++ = OLESTR('\0');              // replace delimiter with 0
            pszFlags = psz;                     // remember start of flags

            while (*psz && *psz != DELIM[0])
                psz++;

            if (*psz == DELIM[0])
            {
                *psz++ = OLESTR('\0');          // replace delimiter with 0
                if (*psz != 0)
                    rgVerbs[iVerbs].grfAttribs = Atol(psz);
            }

            // now that the flags portion ends with a 0 we can parse it
            if (*pszFlags != 0)
                rgVerbs[iVerbs].fuFlags = Atol(pszFlags);
        }

        rgVerbs[iVerbs].lpszVerbName = pszNames;

        pszNames += cchName;    // move pointer to next verb name position
        cchSpace -= cchName;    // calculate how much space is left
    }

    // sort the verbs while putting them in the final verb list
    for (iVerbs = 0; iVerbs < cVerbs; iVerbs++)
    {
        LONG    minCurNum = maxVerbNum,
                minCurIdx = maxVerbIdx;
        LONG    idx, num;

        // find next verb
        for (idx = 0; idx < (LONG)cVerbs; idx++)
        {
            num = rgVerbs[idx].lVerb;
            if (num < minCurNum && num > minVerbNum)
            {
                minCurNum = num;
                minCurIdx = idx;
            }
        }

        pVerbList->oleverb[iVerbs].lVerb        = rgVerbs[minCurIdx].lVerb;
        pVerbList->oleverb[iVerbs].fuFlags      = rgVerbs[minCurIdx].fuFlags;
        pVerbList->oleverb[iVerbs].grfAttribs   = rgVerbs[minCurIdx].grfAttribs;
        pVerbList->oleverb[iVerbs].lpszVerbName = rgVerbs[minCurIdx].lpszVerbName;

        minVerbNum = minCurNum;
    }

    *ppVerbList = pVerbList;

errRtn:
    if (rgVerbs)
        PrivMemFree(rgVerbs);
    if (hkey)
        CLOSE(hkey);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleReleaseEnumVerbCache
//
//  Synopsis:   Releases the cache if necessary
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Just call Release method
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              18-Jul-95 t-gabes   Author
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleReleaseEnumVerbCache)
STDAPI OleReleaseEnumVerbCache(void)
{
    CEnumVerb*  pEnum;

    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, 0);

    if (NULL != pEnum)
    {
        pEnum->Release();
        LEDebugOut((DEB_TRACE, "VERB Enumerator cache released\n"));
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::CEnumVerb
//
//  Synopsis:   Constructor for the verb enumerator
//
//  Effects:
//
//  Arguments:
//              [pVerbs]        -- ptr to the verb list
//              [iVerb]         -- the index of the verb we're on
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_ctor)
CEnumVerb::CEnumVerb
        (LPVERBLIST pVerbs,
        LONG        iVerb)
{
    VDATEHEAP();

    m_cRef     = 1;
    m_iVerb    = iVerb;
    m_VerbList = pVerbs;

    // AddRef the VerbList since we now have a reference to it
    InterlockedIncrement((long *)&m_VerbList->cRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::QueryInterface
//
//  Synopsis:   returns the interface implementation
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface id
//              [ppv]           -- where to put a pointer to the interface
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_QueryInterface)
STDMETHODIMP CEnumVerb::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    VDATEHEAP();

    VDATEPTROUT(ppv, LPVOID);

    if (IsEqualIID(iid, IID_IUnknown) ||
        IsEqualIID(iid, IID_IEnumOLEVERB))
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    *ppv = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_AddRef)
STDMETHODIMP_(ULONG) CEnumVerb::AddRef(void)
{
    VDATEHEAP();

    return InterlockedIncrement((long *)&m_cRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    will delete the object when ref count goes to zero
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              18-Jul-95 t-gabes   release verb cache when finished
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Release)
STDMETHODIMP_(ULONG) CEnumVerb::Release(void)
{
    VDATEHEAP();

    ULONG   cRef;

    cRef = InterlockedDecrement((long *)&m_cRef);
    if (0 == cRef)
    {
        if (0 == InterlockedDecrement((long *)&m_VerbList->cRef))
        {
            // no more references to m_VerbList so free it
            PrivMemFree(m_VerbList);
            LEDebugOut((DEB_TRACE, "VERB Enumerator verb list released\n"));
        }

        delete this;
        return 0;
    }

    return cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Next
//
//  Synopsis:   gets the next [cverb] verbs from the verb list
//
//  Effects:
//
//  Arguments:  [cverb]         -- the number of verbs to get
//              [rgverb]        -- where to put the verbs
//              [pcverbFetched] -- where to put the num of verbs retrieved
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:  loops through [cverb] times and grabs the info from the
//              reg db
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Next)
STDMETHODIMP CEnumVerb::Next
        (ULONG      cverb,
        LPOLEVERB   rgverb,
        ULONG FAR*  pcverbFetched)
{
    VDATEHEAP();

    ULONG       iVerb;  // number successfully fetched
    HRESULT     hresult = NOERROR;

    if (!rgverb)
    {
        if (pcverbFetched)
            *pcverbFetched = 0;
        VDATEPTROUT(rgverb, OLEVERB);
    }

    if (pcverbFetched)
    {
        VDATEPTROUT(pcverbFetched, ULONG);
    }
    else if (cverb != 1)
    {
        // the spec says that if pcverbFetched == NULL, then
        // the count of elements to fetch must be 1
        return ResultFromScode(E_INVALIDARG);
    }

    for (iVerb = 0; iVerb < cverb; iVerb++)
    {
        if (m_iVerb >= (LONG)m_VerbList->cVerbs)
        {
            // no more
            hresult = ResultFromScode(S_FALSE);
            goto errRtn;
        }

        OLEVERB *lpov = &m_VerbList->oleverb[m_iVerb++];

        rgverb[iVerb].lVerb        = lpov->lVerb;
        rgverb[iVerb].fuFlags      = lpov->fuFlags;
        rgverb[iVerb].grfAttribs   = lpov->grfAttribs;
        rgverb[iVerb].lpszVerbName = UtDupString(lpov->lpszVerbName);
    }

errRtn:
    if (pcverbFetched)
    {
        *pcverbFetched = iVerb;
    }

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Skip
//
//  Synopsis:   skips [c] verbs in the enumeration
//
//  Effects:
//
//  Arguments:  [c]     -- the number of verbs to skip
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:  adds [c] to the verb index
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Skip)
STDMETHODIMP CEnumVerb::Skip(ULONG c)
{
    VDATEHEAP();

    m_iVerb += c;
    if (m_iVerb > (LONG)m_VerbList->cVerbs)
    {
        // skipping too many
        m_iVerb = m_VerbList->cVerbs;
        return ResultFromScode(S_FALSE);
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Reset
//
//  Synopsis:   resets the verb enumeration to the beginning
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Reset)
STDMETHODIMP CEnumVerb::Reset(void)
{
    VDATEHEAP();

    m_iVerb = 0;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Clone
//
//  Synopsis:   creates a copy of the enumerator
//
//  Effects:
//
//  Arguments:  [ppenum]        -- where to put a pointer to the new clone
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Clone)
STDMETHODIMP CEnumVerb::Clone(LPENUMOLEVERB FAR* ppenum)
{
    VDATEHEAP();

    VDATEPTROUT(ppenum, LPENUMOLEVERB);

    *ppenum = new FAR CEnumVerb(m_VerbList, m_iVerb);
    if (!*ppenum)
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::GetRefCount
//
//  Synopsis:   Gets the reference count for the class
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   Author
//
//  Notes:      This is needed so OleRegEnumVerbs knows when to dup the cache
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_GetRefCount)
ULONG CEnumVerb::GetRefCount (void)
{
    VDATEHEAP();

    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumVerb::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References     = " << m_cRef     << endl;

    dstrDump << pszPrefix << "Address of verb list  = " << m_VerbList << endl;

    dstrDump << pszPrefix << "Current Verb Number   = " << m_iVerb    << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumVerb, public (_DEBUG only)
//
//  Synopsis:   calls the CEnumVerb::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pEV]          - pointer to CEnumVerb
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumVerb(CEnumVerb *pEV, ULONG ulFlag, int nIndentLevel)
{
    char *pszDump;

    if (NULL == pEV)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    pEV->Dump(&pszDump, ulFlag, nIndentLevel);

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\stdimpl\srvhndlr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvhndlr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------


#ifndef _SRVHNDLR_H_DEFINED_
#define _SRVHNDLR_H_DEFINED_

class CStdIdentity;
class CEmbServerClientSite;


//+---------------------------------------------------------------------------
//
//  Class:      CServerHandler ()
//
//  Purpose:
//
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
class CServerHandler : public IServerHandler
{
public:


    CServerHandler(CStdIdentity *pStdId);
    ~CServerHandler();

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IServerHandler
    STDMETHOD(Run) (DWORD dwDHFlags, REFIID riidClientInterface, MInterfacePointer* pIRDClientInterface, BOOL fHasIPSite, LPOLESTR szContainerApp,
                         LPOLESTR szContainerObj,IStorage *  pStg,IAdviseSink* pAdvSink,DWORD *pdwConnection,
                         HRESULT *hresultClsidUser, CLSID *pContClassID, HRESULT *hresultContentMiscStatus,
                         DWORD *pdwMiscStatus
                        );

    STDMETHOD(DoVerb) (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect);

    STDMETHOD(SetClientSite) (IOleClientSite* pClientSite);

    // Delegating IDataObject facing container

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
            LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);



private:
    STDMETHOD_(void, ReleaseObject)();

    INTERNAL(QueryServerInterface) (REFIID riid,void ** ppInterface);
    INTERNAL(ReleaseServerInterface) (void * ppInterface);
    INTERNAL(GetClientSiteFromMInterfacePtr) (REFIID riidClientInterface, MInterfacePointer* pIRDClientSite,BOOL fHasIPSite, LPOLECLIENTSITE* ppOleClientSite);

    ULONG           _cRefs;             // refcount on IServerHandler
    CStdIdentity *m_pStdId;             // Pointer to StdIdentity for Embedding Handler.

    LPOLECLIENTSITE m_pOleEmbServerClientSite; // Review, shouldn't need Pointer to client site if have one.
    CEmbServerClientSite *m_pCEmbServerClientSite; //  member pointing to ClientSiteObject.
};

// Wrapper object for Serverhandler Interfaces on the ClientSite.

class CEmbServerWrapper : public IServerHandler, public IDataObject
{
public:

    CEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler);
    ~CEmbServerWrapper();

    // Controlling Unknown.
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);
        
        CEmbServerWrapper *m_EmbServerWrapper;
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    // IUnknown Methods
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IServerHandler
    STDMETHOD(Run) (DWORD dwDHFlags, REFIID riidClientInterface, MInterfacePointer* pIRDClientInterface, 
                     BOOL fHasIPSite,LPOLESTR szContainerApp,
                     LPOLESTR szContainerObj,IStorage *  pStg,IAdviseSink* pAdvSink,DWORD *pdwConnection,
                     HRESULT *hresultClsidUser, CLSID *pContClassID, HRESULT *hresultContentMiscStatus,
                     DWORD *pdwMiscStatus
                        );

    STDMETHOD(DoVerb) (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect);

    STDMETHOD(SetClientSite) (IOleClientSite* pClientSite);

    // Delegating IDataObject facing container

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
            LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);

public: 
    IUnknown *m_pUnkOuter; // Controlling Unknown
    ULONG m_cRefs;

    IServerHandler *m_ServerHandler; // pointer to real server Handler.


};


HRESULT CreateServerHandler(const CLSID *pClsID, IUnknown *punk,
                            IClientSiteHandler *pClntHndlr,
                            IServerHandler **ppSrvHdlr);


CEmbServerWrapper* CreateEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler);


#endif //  _SRVHNDLR_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\stdimpl\srvhndlr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvhndlr.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:     9-18-95    JohannP     Created
//              10-30-96    rogerg      Changed to New Embed ServerHandler Model.                            
//
//----------------------------------------------------------------------------



#include <le2int.h>

#include <ole2int.h>
#include <stdid.hxx>        // CStdIdentity
#include <marshal.hxx>      // CStdMarshal
#include <idtable.hxx>      // Indentity Table
#include <ipidtbl.hxx>      // IpidTable.
#include "xmit.hxx"

#include "srvhndlr.h"
#include "clthndlr.h"
#include "defhndlr.h"

extern HRESULT UnMarshalHelper(MInterfacePointer *pIFP, REFIID riid, void **ppv);
extern INTERNAL_(BOOL) ChkIfLocalOID(OBJREF &objref, CStdIdentity **ppStdId);

// TODO: All Marshaling and set up for Run, DoVerb, SetClientSite should be moved
//       Into the EmbHelper so all DefHndlr has to do is call the Function as normal.

//+---------------------------------------------------------------------------
//
//  Method:     CreateEmbeddingServerHandler
//
//  Synopsis: Creates a New Instance of the Embedded Server Handler.
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//              ppunkESHandler - PlaceHolder to Return the New serverHandler.
//
//  Returns:    HRESULT
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CreateEmbeddingServerHandler(CStdIdentity *pStdId,IUnknown **ppunkESHandler)
{
    *ppunkESHandler = new CServerHandler(pStdId); 

    return *ppunkESHandler ? NOERROR : E_FAIL; 
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::CServerHandler
//
//  Synopsis:   Constructor
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CServerHandler::CServerHandler(CStdIdentity *pStdid)
{
    _cRefs = 1;         // this is the first addref for the serverhandler interface
    m_pStdId = pStdid;

    if (m_pStdId)
        m_pStdId->AddRef();

    m_pOleEmbServerClientSite = NULL;
    m_pCEmbServerClientSite = NULL;

    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::~CServerHandler
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CServerHandler::~CServerHandler()
{
    Win4Assert(NULL == m_pStdId);
    Win4Assert(NULL == m_pOleEmbServerClientSite);
    Win4Assert(NULL == m_pCEmbServerClientSite); 
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerHandler::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();

    LEDebugOut((DEB_TRACE,
        "%p _IN CServerHandler::QueryInterface "
        "( %p , %p )\n", this, riid, ppv));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IServerHandler) )
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        hresult = E_NOINTERFACE;
        *ppv = NULL;
    }


    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerHandler::AddRef( void )
{
    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::AddRef ( )\n", this));

    InterlockedIncrement((long *)&_cRefs);

    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::AddRef ( %ld ) ", this,
        _cRefs));

    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerHandler::Release( void )
{
ULONG   cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::Release ( )\n", this));

    if (0 == (cRefs = InterlockedDecrement( (long*) &_cRefs)) )
    {
        ReleaseObject(); 
        delete this;
        return 0;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        cRefs));

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::ReleaseObject
//
//  Synopsis:   Releases any references on StdIdentity or Real Object.
//
//  Arguments:  (none)
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CServerHandler::ReleaseObject()
{
LPUNKNOWN lpUnkForSafeRelease;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::ReleaseObject ( )\n", this));

    if (m_pOleEmbServerClientSite)
    {
        lpUnkForSafeRelease = (LPUNKNOWN) m_pOleEmbServerClientSite;
        m_pOleEmbServerClientSite = NULL;
        lpUnkForSafeRelease->Release();
    }
    
    if (m_pCEmbServerClientSite)
    {
    CEmbServerClientSite *pEmbServerClientSite = m_pCEmbServerClientSite;

        m_pCEmbServerClientSite = NULL;
        pEmbServerClientSite->Release();
    }

    if (m_pStdId)
    {
    CStdIdentity* pUnkObj = m_pStdId;

        m_pStdId = NULL;
        pUnkObj->Release();
    }

    LEDebugOut((DEB_TRACE, "%p _Out CServerHandler::ReleaseObject ( )\n", this));
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::QueryServerInterface
//
//  Synopsis:   Gets Requested Interface from the Server.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

INTERNAL  CServerHandler::QueryServerInterface(REFIID riid,void ** ppInterface)           
{                       
IPIDEntry *pIPIDEntry;
HRESULT hrDisconnect;
HRESULT hr = E_NOINTERFACE;

// TODO: Other option is for Stdid to hold onto EmbServerHandler and then has the Stdid
//    Call ReleaseObject, Release on the EmbServerHandler in its when the real server object
//    is being released or Disconnected. This option should be tried and if it works would 
//    be preferred.

    if (m_pStdId)
    {
        LOCK(gComLock);

        m_pStdId->LockServer();
    
        if (SUCCEEDED(hr = m_pStdId->FindIPIDEntry(riid,&pIPIDEntry)) )
        {
            UNLOCK(gComLock);
        }
        else
        {
            hrDisconnect = m_pStdId->PreventDisconnect();
            if (SUCCEEDED(hrDisconnect))
            {
                hr = m_pStdId->MarshalIPID(riid,1 /*cRefs */,MSHLFLAGS_NORMAL, &pIPIDEntry);

                if (SUCCEEDED(hr))
                {
                    m_pStdId->DecSrvIPIDCnt(pIPIDEntry,1, 0, NULL, MSHLFLAGS_NORMAL); // release Marshaled Ipid.
                }

            }

            UNLOCK(gComLock);
            m_pStdId->HandlePendingDisconnect(hrDisconnect);
        }
    

        if ( FAILED(hr) || (IPIDF_DISCONNECTED & pIPIDEntry->dwFlags) )
        {
            m_pStdId->UnLockServer();
            hr = (NOERROR == hr) ? RPC_E_DISCONNECTED : E_NOINTERFACE;
            *ppInterface  = NULL;
        }
        else
        {
            *ppInterface = pIPIDEntry->pv;
        }
    }
   
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::ReleaseServerInterface
//
//  Synopsis:   Releases Lock in Interface obtained from QueryServerInterface
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

INTERNAL  CServerHandler::ReleaseServerInterface(void * pInterface)
{

    if (m_pStdId)
    {
        m_pStdId->UnLockServer();
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Run
//
//  Synopsis:   Server Handler side of invoked when ::Run is Called.
//
//  Arguments:  
//              
//
//  Returns:   
//
//  Comments:   To be as identical to the ::Run in the Defhndlr as possible 
//              ::Run ignores errors if it fails to get the Interfaces and also
//              any error value that is returned from ::SetClientSite. 
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CServerHandler::Run(DWORD dwDHFlags,
                                    REFIID riidClientInterface,
                                    MInterfacePointer* pIRDClientInterface,
                                    BOOL fHasIPSite,
                                    LPOLESTR szContainerApp,
                                    LPOLESTR szContainerObj,
                                    IStorage *  pStg,
                                    IAdviseSink* pAdvSink,
                                    DWORD *pdwConnection,
                                    HRESULT *hresultClsidUser,
                                    CLSID *pContClassID,
                                    HRESULT *hresultContentMiscStatus,
                                    DWORD *pdwMiscStatus)

{
IPersistStorage *pIStorage = NULL;
IOleObject *pIOleObject = NULL;
HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::Run\n", this));

    *pdwConnection = 0; // make sure dwConnection is 0 on an error.

    QueryServerInterface(IID_IOleObject,(void **) &pIOleObject);

    if (pStg && (NOERROR == QueryServerInterface(IID_IPersistStorage,(void **) &pIStorage)) )
    {
        Win4Assert(pIStorage);

        if (DH_INIT_NEW & dwDHFlags)
        {
            hresult = pIStorage->InitNew(pStg);
        }
        else
        {
            hresult = pIStorage->Load(pStg);
        }
    }

    Win4Assert(NULL == m_pOleEmbServerClientSite);
    if ( (NOERROR == hresult) && pIRDClientInterface && pIOleObject)
    {
        hresult = GetClientSiteFromMInterfacePtr(riidClientInterface,pIRDClientInterface,fHasIPSite,&m_pOleEmbServerClientSite);
        
        if (SUCCEEDED(hresult))
        {
            hresult = pIOleObject->SetClientSite(m_pOleEmbServerClientSite);
        }

       hresult = NOERROR; // !!! don't fail on SetClientSite Failure.
    }

    if ((NOERROR == hresult) && (NULL != szContainerApp) && pIOleObject)
    {
        hresult = pIOleObject->SetHostNames(szContainerApp,szContainerObj);
    }

    if ( (NOERROR == hresult) && pAdvSink && pIOleObject )
    {
        hresult = pIOleObject->Advise(pAdvSink,pdwConnection);
    }

    if ( (NOERROR == hresult) && pIOleObject )
    {
        *hresultClsidUser = pIOleObject->GetUserClassID(pContClassID);
        *hresultContentMiscStatus = pIOleObject->GetMiscStatus(DVASPECT_CONTENT,pdwMiscStatus);
    }

    // m_pOleEmbServerClientSite gets set by SetClientSite called above.
    if ( (NOERROR == hresult) && (m_pOleEmbServerClientSite) && pIOleObject)
    {
    LPMONIKER pmk = NULL;

        if( m_pOleEmbServerClientSite->GetMoniker
                    (OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJREL, &pmk) == NOERROR)
        {
            AssertOutPtrIface(NOERROR, pmk);

            // SetMoniker Failure doesn't result in a ::Run Failure
            pIOleObject->SetMoniker(OLEWHICHMK_OBJREL, pmk);

            pmk->Release();
        }
    }

    if (pIStorage)
        ReleaseServerInterface((void *) pIStorage);

    if (pIOleObject)
        ReleaseServerInterface((void *) pIOleObject);

   LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::Run "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::DoVerb
//
//  Synopsis:   Server Handler side of invoked when ::DoVerb is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CServerHandler::DoVerb (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, IOleClientSite* pIOleClientSite, 
                                     LONG lindex,HWND hwndParent,LPCRECT lprcPosRect)
{
IOleObject *pIOleObject = NULL;
IOleClientSite *pDoVerbClientSite = NULL;
HRESULT hr = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::DoVerb "
        "( %ld , %p , %p , %ld , %lx , %p )\n", this,
        iVerb, lpmsg, pIOleClientSite, lindex, hwndParent, lprcPosRect));

    if (NOERROR == (hr = QueryServerInterface(IID_IOleObject,(void **) &pIOleObject))  )
    {
        Win4Assert(pIOleObject);

        if (fUseRunClientSite)
        {

            pDoVerbClientSite = m_pOleEmbServerClientSite;
            
            // inform client site of operation what interfaces to support
            // Todo: Send in Prefetched info for DoVerb here.
        if (m_pCEmbServerClientSite)
        {
                m_pCEmbServerClientSite->SetDoVerbState(TRUE);
        }

            // put addref on Clientsite so liveness is the same as if marshaled by DoVerb
            // TODO: This isn't really necessayr since Handler also holds a ref.
            if (m_pOleEmbServerClientSite)
            {
                m_pOleEmbServerClientSite->AddRef();
            }
            
        }
        else
        {
            pDoVerbClientSite = pIOleClientSite;

        }

        hr = pIOleObject->DoVerb(iVerb,lpmsg,pDoVerbClientSite,lindex,hwndParent,lprcPosRect);
        
    if (fUseRunClientSite)
    {
            if (m_pCEmbServerClientSite)
            {
                m_pCEmbServerClientSite->SetDoVerbState(FALSE);
            }

            if (m_pOleEmbServerClientSite)
            {
                m_pOleEmbServerClientSite->Release();
            }

    }

    }

   if (pIOleObject)
        ReleaseServerInterface((void *) pIOleObject);


    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::Run "
        "( %lx )\n", this, hr));

    return hr;
}

// helper function for creating ClientSite Handler
INTERNAL CServerHandler::GetClientSiteFromMInterfacePtr(REFIID riidClientInterface, 
                                 MInterfacePointer* pIRDClientSite, BOOL fHasIPSite, LPOLECLIENTSITE* ppOleClientSite)
{
HRESULT hr = E_UNEXPECTED;

    *ppOleClientSite = NULL;

    Win4Assert(NULL != pIRDClientSite);

    if (pIRDClientSite)
    {
    CXmitRpcStream Stm( (InterfaceData *) pIRDClientSite);
     
        if (IsEqualIID(IID_IClientSiteHandler,riidClientInterface))
        {
        OBJREF  objref;
        CEmbServerClientSite *pCEmbServerClientSite;

           // If there is a ClientSide Handler, set up server side.
            if (SUCCEEDED(hr = ReadObjRef(&Stm, objref)))
            {

                Win4Assert(IsEqualIID(objref.iid, IID_IClientSiteHandler));

                pCEmbServerClientSite = new CEmbServerClientSite(NULL);
            
                if (pCEmbServerClientSite)
                {
                    if (NOERROR == (hr = pCEmbServerClientSite->Initialize(objref,fHasIPSite)))
                    {
                        m_pCEmbServerClientSite = pCEmbServerClientSite; // set up member variable.
      
                        // TODO: should be a QI for the ClientSite.
                        *ppOleClientSite = (LPOLECLIENTSITE) pCEmbServerClientSite;
                        (*ppOleClientSite)->AddRef();
                    }
                    else
                    {
                        pCEmbServerClientSite->Release();
                    }
                
                }

               FreeObjRef(objref);
            }

        }
        else
        {
            m_pCEmbServerClientSite = NULL; // make sure EmbClientSite member var is NULL.

            // Didn't wrap ClientSite with ClientSiteHandler, just UnMarshal and hand back.
            hr = CoUnmarshalInterface(&Stm,IID_IOleClientSite, (void **) ppOleClientSite);

            if (FAILED(hr))
            {
                *ppOleClientSite = NULL;
            }
        }
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CServerHandler::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- pointer to the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

STDMETHODIMP CServerHandler::SetClientSite(IOleClientSite* pOleClientSite)
{
HRESULT hresult = NOERROR;
IOleObject *pIOleObject = NULL;

    if (NOERROR == (hresult = QueryServerInterface(IID_IOleObject,(void **) &pIOleObject)) )
    {
        if (NOERROR == hresult)
        {
            hresult = pIOleObject->SetClientSite(pOleClientSite);
        }
    }

    if (pIOleObject)
        ReleaseServerInterface(pIOleObject);

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:  Delagatory IDataObject impl facing container
//
//  Synopsis:
//
//  Arguments: 
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//+---------------------------------------------------------------------------

STDMETHODIMP CServerHandler::GetData(FORMATETC *pformatetcIn,STGMEDIUM *pmedium)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetData(pformatetcIn,pmedium);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::GetDataHere(FORMATETC *pformatetc,STGMEDIUM *pmedium)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetDataHere(pformatetc,pmedium);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::QueryGetData(FORMATETC *pformatetc)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->QueryGetData(pformatetc);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::GetCanonicalFormatEtc(FORMATETC *pformatetcIn,FORMATETC *pformatetcOut)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetCanonicalFormatEtc(pformatetcIn,pformatetcOut);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::SetData(FORMATETC *pformatetc,STGMEDIUM *pmedium,BOOL fRelease)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->SetData(pformatetc,pmedium,fRelease);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::EnumFormatEtc(DWORD dwDirection,IEnumFORMATETC **ppenumFormatEtc)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->EnumFormatEtc(dwDirection,ppenumFormatEtc);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::DAdvise(FORMATETC *pformatetc,DWORD advf, IAdviseSink *pAdvSink,
                    DWORD *pdwConnection)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->DAdvise(pformatetc,
                            advf, (IAdviseSink *)
                            pAdvSink,pdwConnection);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::DUnadvise(DWORD dwConnection)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->DUnadvise(dwConnection);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->EnumDAdvise(ppenumAdvise);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}



//////////////////////

// rogerg, wrapper object for ServerHandler on the ClientSide.

//////////////////////

// CEmbServerWrapper implementation for Server Handler.

CEmbServerWrapper* CreateEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler)
{
    return new CEmbServerWrapper(pUnkOuter,ServerHandler);
}



//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::CEmbServerWrapper
//
//  Synopsis:   Constructor
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CEmbServerWrapper::CEmbServerWrapper (IUnknown *pUnkOuter,IServerHandler *pServerHandler)
{
    VDATEHEAP();

    Win4Assert(pServerHandler);

    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }

    m_pUnkOuter  = pUnkOuter;
    m_Unknown.m_EmbServerWrapper = this;

    if(pServerHandler)
    {
        m_ServerHandler = pServerHandler;
        m_ServerHandler->AddRef();
    }

    m_cRefs = 1;

}



//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::~CServerHandler
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CEmbServerWrapper::~CEmbServerWrapper()
{
    Win4Assert(NULL == m_ServerHandler);
}


//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::QueryInterface
//
//  Synopsis:   Returns a pointer to one of the supported interfaces.
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppv]           -- where to put the iface pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::CPrivUnknown::QueryInterface(REFIID iid,
    LPLPVOID ppv)
{
HRESULT         hresult;

    VDATEHEAP();

    Win4Assert(m_EmbServerWrapper);

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::CUnknownImpl::QueryInterface "
        "( %p , %p )\n", m_EmbServerWrapper, iid, ppv));

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IDataObject))
    {
        *ppv = (void FAR *)(IDataObject *) m_EmbServerWrapper;
    }
    else if(m_EmbServerWrapper->m_ServerHandler)
    {

        Win4Assert(0 && "QI for non-Wrapped interface");

        hresult = m_EmbServerWrapper->m_ServerHandler->QueryInterface(iid,(void **) ppv);


        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerWrapper, hresult,
            (ppv) ? *ppv : 0 ));

        return hresult;
    }
    else
    {
        // Don't have a ServerHandler.
        *ppv = NULL;

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnkownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerWrapper, CO_E_OBJNOTCONNECTED,
            0 ));

        return E_NOINTERFACE;
    }

    // this indirection is important since there are different
    // implementationsof AddRef (this unk and the others).
    ((IUnknown FAR*) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE,
        "%p OUT CDefObject::CUnknownImpl::QueryInterface "
        "( %lx ) [ %p ]\n", m_EmbServerWrapper, NOERROR, *ppv));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::AddRef
//
//  Synopsis:   Increments the reference count.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG (the new reference count)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnkown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerWrapper::CPrivUnknown::AddRef( void )
{
ULONG cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::AddRef "
        "( )\n", m_EmbServerWrapper));

    Win4Assert(m_EmbServerWrapper->m_cRefs != 0);
    Win4Assert(m_EmbServerWrapper);

    // we need to keep track of the hander's reference count separately
    // from the handler/advise sink combination in order to handle
    // our running/stopped state transitions.

    cRefs = InterlockedIncrement((long *) &(m_EmbServerWrapper->m_cRefs)); 

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::AddRef "
        "( %lu )\n", m_EmbServerWrapper, m_EmbServerWrapper->m_cRefs));

    return cRefs;

}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::Release
//
//  Synopsis:   Decrements the ref count, cleaning up and deleting the
//              object if necessary
//
//  Effects:    May delete the object (and potentially objects to which the
//              handler has pointer)
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG--the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerWrapper::CPrivUnknown::Release( void )
{

    VDATEHEAP();

    ULONG           refcount;

    Win4Assert(m_EmbServerWrapper);


    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::Release "
        "( )\n", m_EmbServerWrapper));

    refcount = InterlockedDecrement((long *) &(m_EmbServerWrapper->m_cRefs));

    if (0 == refcount)
    {
        if (m_EmbServerWrapper->m_ServerHandler)
        {
        IServerHandler *pServerHandler = m_EmbServerWrapper->m_ServerHandler;

            m_EmbServerWrapper->m_ServerHandler = NULL; 
            pServerHandler->Release();
        }

        delete m_EmbServerWrapper;
        
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::Release "
        "( %lu )\n", m_EmbServerWrapper, refcount));

    return refcount;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP  CEmbServerWrapper::QueryInterface( REFIID riid, void **ppv )                                                        
{                                                                                                                                        
    HRESULT     hresult;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::QueryInterface ( %lx , "
        "%p )\n", this, riid, ppv));

    Assert(m_pUnkOuter);

    hresult = m_pUnkOuter->QueryInterface(riid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                
STDMETHODIMP_(ULONG) CEmbServerWrapper::AddRef( void )                                                                           
{                                                                                                                                         
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::AddRef ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::AddRef ( %ld ) ", this,
        crefs));

    return crefs;
}  

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
                                                                                                                                       
STDMETHODIMP_(ULONG) CEmbServerWrapper::Release( void )                                                                          
{                                                                                                                                         
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Release ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->Release();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        crefs));

    return crefs;
}

// IServerHandler Implementation
//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Run
//
//  Synopsis:   Server Handler side of invoked when ::Run is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::Run(DWORD dwDHFlags,
                                    REFIID riidClientInterface,
                                    MInterfacePointer* pIRDClientInterface,
                                    BOOL fHasIPSite,
                                    LPOLESTR szContainerApp,
                                    LPOLESTR szContainerObj,
                                    IStorage *  pStg,
                                    IAdviseSink* pAdvSink,
                                    DWORD *pdwConnection,
                                    HRESULT *hresultClsidUser,
                                    CLSID *pContClassID,
                                    HRESULT *hresultContentMiscStatus,
                                    DWORD *pdwMiscStatus)

{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->Run(dwDHFlags,riidClientInterface,pIRDClientInterface, fHasIPSite, szContainerApp,
                                szContainerObj,pStg,pAdvSink,pdwConnection,
                                hresultClsidUser,pContClassID,hresultContentMiscStatus,
                                pdwMiscStatus);
    }

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::DoVerb
//
//  Synopsis:   Server Handler side of invoked when ::DoVerb is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::DoVerb (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->DoVerb(iVerb,lpmsg,fUseRunClientSite,pIRDClientSite,
                    lindex,hwndParent,lprcPosRect);
    }

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CServerHandler::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- pointer to the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::SetClientSite(IOleClientSite* pOleClientSite)
{
HRESULT hresult = RPC_E_DISCONNECTED;

   Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->SetClientSite(pOleClientSite);
    }

    return hresult;
}


// IDataObject implementation.

STDMETHODIMP CEmbServerWrapper::GetData(FORMATETC *pformatetcIn,STGMEDIUM *pmedium)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->GetData(pformatetcIn,pmedium);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::GetDataHere(FORMATETC *pformatetc,STGMEDIUM *pmedium)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->GetDataHere(pformatetc,pmedium);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::QueryGetData(FORMATETC *pformatetc)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->QueryGetData(pformatetc);
    }
    
    return hresult;
}

STDMETHODIMP CEmbServerWrapper::GetCanonicalFormatEtc(FORMATETC *pformatetcIn,FORMATETC *pformatetcOut)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    return m_ServerHandler->GetCanonicalFormatEtc(pformatetcIn,pformatetcOut);
}

STDMETHODIMP CEmbServerWrapper::SetData(FORMATETC *pformatetc,STGMEDIUM *pmedium,BOOL fRelease)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->SetData(pformatetc,pmedium,fRelease);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::EnumFormatEtc(DWORD dwDirection,IEnumFORMATETC **ppenumFormatEtc)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->EnumFormatEtc(dwDirection,ppenumFormatEtc);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::DAdvise(FORMATETC *pformatetc,DWORD advf, 
                                     IAdviseSink *pAdvSink,DWORD *pdwConnection)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->DAdvise(pformatetc,
                            advf, (IAdviseSink *)
                            pAdvSink,pdwConnection);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::DUnadvise(DWORD dwConnection)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->DUnadvise(dwConnection);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->EnumDAdvise(ppenumAdvise);
    }

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\convert.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              convert.cpp
//
//      Contents:
//              This module contains the code to read/write DIB, metafile,
//              placeable metafiles, olepres stream, etc... This module also
//              contains routines for converting from one format to other.
//
//      Classes:
//
//      Functions:
//
//      History:
//              15-Feb-94 alexgo    fixed a bug in loading placeable metafiles
//                                  from a storage (incorrect size calculation).
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              01/11/93 - alexgo  - added VDATEHEAP macros to every function
//              12/08/93 - ChrisWe - fixed wPrepareBitmapHeader not to use
//                      (LPOLESTR) cast
//              12/07/93 - ChrisWe - make default params to StSetSize explicit
//              12/02/93 - ChrisWe - more formatting; fixed UtHMFToMFStm,
//                      32 bit version, which was doing questionable things
//                      with the hBits handle;  got rid of the OLESTR
//                      uses in favor of (void *) or (BYTE *) as appropriate
//              11/29/93 - ChrisWe - move CONVERT_SOURCEISICON, returned
//                      by UtOlePresStmToContentsStm(), to utils.h
//              11/28/93 - ChrisWe - begin file inspection and cleanup
//              06/28/93 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>

#pragma SEG(ole2)

NAME_SEG(convert)
ASSERTDATA

#ifndef _MAC
FARINTERNAL_(HMETAFILE) QD2GDI(HANDLE hBits);
#endif

void UtGetHEMFFromContentsStm(LPSTREAM lpstm, HANDLE * phdata);


/************************   FILE FORMATS   **********************************

Normal Metafile (memory or disk based):

         ------------ ---------------
        | METAHEADER | Metafile bits |
         ------------ ---------------

Placeable Metafile:

         --------------------- -----------------
        | PLACEABLEMETAHEADER | Normal metafile |
         --------------------- -----------------

Memory Based DIB:

         ------------------ --------------- ----------
        | BITMAPINFOHEADER | RGBQUAD array | DIB bits |
         ------------------ --------------- ----------

DIB file format:

         ------------------ ------------------
        | BITMAPFILEHEADER | Memory based DIB |
         ------------------ ------------------

Ole10NativeStream Format:

         -------- ----------------------
        | dwSize | Object's Native data |
         -------- ----------------------

PBrush Native data format:

         -----------------
        | Dib File format |
         -----------------

MSDraw Native data format:

         --------------------- ------------- ------------- -----------------
        | mapping mode (WORD) | xExt (WORD) | yExt (WORD) | Normal metafile |
         --------------------- ------------- ------------- -----------------

*****************************************************************************/


FARINTERNAL UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize,
                HANDLE FAR* lphPres)
{
        VDATEHEAP();

        HANDLE hBits = NULL;
        void FAR *lpBits = NULL;
        HRESULT error;

        // initialize this for error return cases
        *lphPres = NULL;

        // allocate a new handle
        if (!(hBits = GlobalAlloc(GMEM_MOVEABLE, dwSize))
                        || !(lpBits = (BYTE *)GlobalLock(hBits)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                goto errRtn;
        }

        // read the stream into the allocated memory
        if (error = StRead(lpstream, lpBits, dwSize))
                goto errRtn;

        // if we got this far, return new handle
        *lphPres = hBits;

errRtn:
        // unlock the handle, if it was successfully locked
        if (lpBits)
                GlobalUnlock(hBits);

        // free the handle if there was an error
        if ((error != NOERROR) && hBits)
                GlobalFree(hBits);

        return(error);
}


#ifndef _MAC

FARINTERNAL UtGetHDIBFromDIBFileStm(LPSTREAM pstm, HANDLE FAR* lphdata)
{
        VDATEHEAP();

        BITMAPFILEHEADER bfh;
        DWORD dwSize; // the size of the data to read
        HRESULT error;

        // read the bitmap file header
        if (error = pstm->Read(&bfh, sizeof(BITMAPFILEHEADER), NULL))
        {
                *lphdata = NULL;
                return(error);
        }

        // calculate the size of the DIB to read
        dwSize = bfh.bfSize - sizeof(BITMAPFILEHEADER);

        // read the DIB
        return(UtGetHGLOBALFromStm(pstm, dwSize, lphdata));
}


FARINTERNAL_(HANDLE) UtGetHMFPICT(HMETAFILE hMF, BOOL fDeleteOnError,
                DWORD xExt, DWORD yExt)
{
        VDATEHEAP();

        HANDLE hmfp; // handle to the new METAFILEPICT
        LPMETAFILEPICT lpmfp; // pointer to the new METAFILEPICT

        // if no METAFILE, nothing to do
        if (hMF == NULL)
                return(NULL);

        // allocate a new handle
        if (!(hmfp = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT))))
                goto errRtn;

        // lock the handle
        if (!(lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp)))
                goto errRtn;

        // make the METAFILEPICT
        lpmfp->hMF = hMF;
        lpmfp->xExt = (int)xExt;
        lpmfp->yExt = (int)yExt;
        lpmfp->mm = MM_ANISOTROPIC;

        GlobalUnlock(hmfp);
        return(hmfp);

errRtn:
        if (hmfp)
                GlobalFree(hmfp);

        if (fDeleteOnError)
                DeleteMetaFile(hMF);

        return(NULL);
}

#endif // _MAC

//+-------------------------------------------------------------------------
//
//  Function:   UtGetHMFFromMFStm
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpstream] -- stream containing metafile or PICT
//              [dwSize] -- data size within stream
//              [fConvert] -- FALSE for metafile, TRUE for PICT
//              [lphPres] -- placeholder for output metafile
//
//  Requires:   lpstream positioned at start of data
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    29-Apr-94 AlexT     Add comment block, enabled Mac conversion
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize,
                BOOL fConvert, HANDLE FAR* lphPres)
{
#ifdef WIN32
        LEDebugOut((DEB_ITRACE, "%p _IN UtGetHMFFromMFStm (%p, %d, %d, %p)\n",
                NULL, lpstream, dwSize, fConvert, lphPres));

        VDATEHEAP();

        BYTE *pbMFData = NULL;
        METAHEADER MetaHdr;
        HRESULT hrError;

        // initialize this in case of error return
        *lphPres = NULL;

        // allocate a global handle for the data (since QD2GDI needs a
        // handle)

        pbMFData = (BYTE *) GlobalAlloc(GMEM_FIXED, dwSize);
        if (NULL == pbMFData)
        {
            hrError = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }

        // read the stream into the bit storage

        ULONG cbRead;
        hrError = lpstream->Read(pbMFData, dwSize, &cbRead);
        if (FAILED(hrError))
        {
            return(hrError);
        }

        // As TOC is being written at the end of presentation, it is essential
        // to place the seek pointer at the end of presentation data. Hence,
        // seek past the extra meta header written by UtHMFToMFStm ignoring error
        lpstream->Read(&MetaHdr, sizeof(MetaHdr), NULL);

        // hrError = StRead(lpstream, pbMFData, dwSize);

        if (hrError != NOERROR)
        {
            goto errRtn;
        }

        if (fConvert)
        {
            //  It's a Mac PICT
            *lphPres = QD2GDI((HGLOBAL) pbMFData);
        }
        else
        {
            //  It's a Windows metafile
            *lphPres = SetMetaFileBitsEx(dwSize, pbMFData);
        }

        if (*lphPres == NULL)
            hrError = ResultFromScode(E_OUTOFMEMORY);

errRtn:
        if (NULL != pbMFData)
        {
            GlobalFree(pbMFData);
        }

        LEDebugOut((DEB_ITRACE, "%p OUT UtGetHMFFromMFStm ( %lx ) [ %p ]\n",
                    NULL, hrError, *lphPres));

        return(hrError);
#else
        HANDLE hBits; // handle to the new METAFILE
        void FAR* lpBits = NULL;
        HRESULT error;

        // initialize this in case of error return
        *lphPres = NULL;

        // allocate a new handle, and lock the bits
        if (!(hBits = GlobalAlloc(GMEM_MOVEABLE, dwSize))
                        || !(lpBits = GlobalLock(hBits)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                goto errRtn;
        }

        // read the stream into the bit storage
        error = StRead(lpstream, lpBits, dwSize);
        GlobalUnlock(hBits);

        if (error)
                goto errRtn;

        if (!fConvert)
                *lphPres = SetMetaFileBits(hBits);
        else
        {
                if (*lphPres = QD2GDI(hBits))
                {
                        // Need to free this handle upon success
                        GlobalFree(hBits);
                        hBits = NULL;
                }

        }

        if (!*lphPres)
                error = ResultFromScode(E_OUTOFMEMORY);

errRtn:
        if (error && hBits)
                GlobalFree(hBits);
        return(error);
#endif // WIN32
}


FARINTERNAL UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
                DWORD FAR* pdwSize, LONG FAR* plWidth, LONG FAR* plHeight)
{
        VDATEHEAP();

        HRESULT error;
        LARGE_INTEGER large_int; // used to set the seek pointer
        ULARGE_INTEGER ularge_int; // retrieves the new seek position
        LONG xExt; // the x extent of the metafile
        LONG yExt; // the y extent of the metafile
        METAHEADER mfh;
        PLACEABLEMETAHEADER plac_mfh;

        // read the placeable metafile header
        if (error = pstm->Read(&plac_mfh, sizeof(plac_mfh), NULL))
                return(error);

        // check the magic number in the header
        if (plac_mfh.key != PMF_KEY)
                return ResultFromScode(E_FAIL);

        // remember the seek pointer
        LISet32(large_int, 0);
        if (error = pstm->Seek(large_int, STREAM_SEEK_CUR, &ularge_int))
                return(error);

        // read metafile header
        if (error = pstm->Read(&mfh, sizeof(mfh), NULL))
                return(error);

        // seek back to the begining of metafile header
        LISet32(large_int,  ularge_int.LowPart);
        if (error = pstm->Seek(large_int, STREAM_SEEK_SET, NULL))
                return(error);

        // calculate the extents of the metafile
        xExt = (plac_mfh.bbox.right - plac_mfh.bbox.left);// metafile units
        yExt = (plac_mfh.bbox.bottom - plac_mfh.bbox.top);// metafile units

        // REVIEW, why aren't there constants for this?
        xExt = (xExt * 2540) / plac_mfh.inch; // HIMETRIC units
        yExt = (yExt * 2540) / plac_mfh.inch; // HIMETRIC units

        if (pdwSize)
        {
#ifdef WIN16
                //this code seems to work OK on Win16
                *pdwSize = 2 * (mfh.mtSize + mfh.mtHeaderSize);
                                // REVIEW NT: review METAHEADER
#else   //WIN32
                //mt.Size is the size in words of the metafile.
                //this fixes bug 6739 (static objects can't be copied
                //or loaded from a file).
                *pdwSize = sizeof(WORD) * mfh.mtSize;
#endif  //WIN16
        }

        if (plWidth)
                *plWidth = xExt;

        if (plHeight)
                *plHeight = yExt;

        return NOERROR;
}


FARINTERNAL UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, HANDLE FAR* lphdata)
{
        VDATEHEAP();

        HRESULT error; // error state so far
        DWORD dwSize; // size of the METAFILE we have to read from the stream
        LONG xExt; // x extent of the METAFILE we have to read from the stream
        LONG yExt; // y extent of the METAFILE we have to read from the stream
        HMETAFILE hMF; // handle to the METAFILE read from the stream

        if (lphdata == NULL)
                return ResultFromScode(E_INVALIDARG);

        // initialize this in case of error return
        *lphdata = NULL;

        // get the size of the METAFILE
        if (error = UtGetSizeAndExtentsFromPlaceableMFStm(pstm, &dwSize,
                        &xExt, &yExt))
                return(error);

        // fetch the METAFILE
        if (error = UtGetHMFFromMFStm(pstm, dwSize, FALSE /*fConvert*/,
                        (HANDLE FAR *)&hMF))
                return(error);

        // convert to a METAFILEPICT
        if (!(*lphdata = UtGetHMFPICT(hMF, TRUE /*fDeleteOnError*/, xExt,
                        yExt)))
                return ResultFromScode(E_OUTOFMEMORY);

        return NOERROR;
}



/****************************************************************************/
/*****************              Write routines          *********************/
/****************************************************************************/

#ifndef _MAC


//+----------------------------------------------------------------------------
//
//      Function:
//              iFindDIBits
//
//      Synopsis:
//              Returns offset from beginning of BITMAPINFOHEADER to the bits
//
//      Arguments:
//              [lpbih] -- pointer to the BITMAPINFOHEADER
//
//      History:
//              09/21/98 - DavidShi
//
//-----------------------------------------------------------------------------
FARINTERNAL_(int) iFindDIBits (LPBITMAPINFOHEADER lpbih)
{
   int iPalSize;   // size of palette info
   int iNumColors=0; // number of colors in DIB


   //
   // Find the number of colors
   //
   switch (lpbih->biBitCount)
   {
       case 1:
           iNumColors = 2;
           break;
       case 4:
           iNumColors = 16;
           break;
       case 8:
           iNumColors = 256;
           break;

   }
   if (lpbih->biSize >= sizeof(BITMAPINFOHEADER))
   {
       if (lpbih->biClrUsed)
       {
           iNumColors = (int)lpbih->biClrUsed;
       }

   }
   //
   // Calculate the size of the color table.
   //
   if (lpbih->biSize < sizeof(BITMAPINFOHEADER))
   {

       iPalSize =  iNumColors * sizeof(RGBTRIPLE);

   }
   else if (lpbih->biCompression==BI_BITFIELDS)
   {

        if (lpbih->biSize < sizeof(BITMAPV4HEADER))
        {
                iPalSize = 3*sizeof(DWORD);
        }
        else
                iPalSize = 0;
   }
   else
   {
        iPalSize = iNumColors * sizeof(RGBQUAD);
   }
   return lpbih->biSize + iPalSize;

}
//+----------------------------------------------------------------------------
//
//      Function:
//              wPrepareBitmapHeader, static
//
//      Synopsis:
//              Initializes the content of a BITMAPFILEHEADER. Forces bitmap
//              bits to immediately follow the header.
//
//      Arguments:
//              [lpbfh] -- pointer to the BITMAPFILEHEADER to initialize
//              [lpbih] -- pointer to DIB
//              [dwSize] -- the size of the file; obtained by dividing
//                      the size of the file by 4 (see win32 documentation.)
//
//      History:
//              12/08/93 - ChrisWe - made static
//
//-----------------------------------------------------------------------------

static INTERNAL_(void) wPrepareBitmapFileHeader(LPBITMAPFILEHEADER lpbfh,
              LPBITMAPINFOHEADER lpbih,
              DWORD dwSize  )
{
        VDATEHEAP();

        // NOTE THESE ARE NOT SUPPOSED TO BE UNICODE
        // see win32s documentation
        ((char *)(&lpbfh->bfType))[0] = 'B';
        ((char *)(&lpbfh->bfType))[1] = 'M';

        lpbfh->bfSize = dwSize + sizeof(BITMAPFILEHEADER);
        lpbfh->bfReserved1 = 0;
        lpbfh->bfReserved2 = 0;
        lpbfh->bfOffBits = sizeof(BITMAPFILEHEADER)+iFindDIBits (lpbih);
}


FARINTERNAL UtHDIBToDIBFileStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm)
{
        VDATEHEAP();

        HRESULT error;
        BITMAPFILEHEADER bfh;
        LPBITMAPINFOHEADER pbih;
        if (!(pbih = (LPBITMAPINFOHEADER)GlobalLock (hdata)))
            return E_OUTOFMEMORY;


        wPrepareBitmapFileHeader(&bfh, pbih, dwSize);
        GlobalUnlock (hdata);

        if (error = pstm->Write(&bfh, sizeof(bfh), NULL))
                return(error);

        return UtHGLOBALtoStm(hdata, dwSize, pstm);
}


FARINTERNAL UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, DWORD dwSize,
                LPSTREAM pstmDIBFile)
{
        VDATEHEAP();

        HRESULT error;
        
        BITMAPFILEHEADER bfh;
        BITMAPINFOHEADER bih;
        ULARGE_INTEGER ularge_int; // indicates how much to copy
        LARGE_INTEGER large_int;
        
        error = pstmDIB->Read (&bih, sizeof(bih), NULL);
        LISet32(large_int, 0);

        wPrepareBitmapFileHeader(&bfh, &bih, dwSize);

        if (error = pstmDIBFile->Write(&bfh, sizeof(bfh), NULL))
                return(error);

        if (error = pstmDIBFile->Write(&bih, sizeof(bih), NULL))
                return(error);

        ULISet32(ularge_int, (dwSize - sizeof(bih)));
        if ((error = pstmDIB->CopyTo(pstmDIBFile, ularge_int, NULL,
                        NULL)) == NOERROR)
                StSetSize(pstmDIBFile, 0, TRUE);

        return(error);
}


// REVIEW, move these to utils.h so that gen.cpp and mf.cpp can use them for
// the same purposes
// REVIEW, add some more comments; is HDIBFILEHDR a windows structure?
struct tagHDIBFILEHDR
{
        DWORD dwCompression;
        DWORD dwWidth;
        DWORD dwHeight;
        DWORD dwSize;
};
typedef struct tagHDIBFILEHDR HDIBFILEHDR;

struct tagOLEPRESSTMHDR
{
        DWORD dwAspect;
        DWORD dwLindex;
        DWORD dwAdvf;
};
typedef struct tagOLEPRESSTMHDR OLEPRESSTMHDR;

FARINTERNAL UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm)
{
        VDATEHEAP();

        HRESULT error;
        HDIBFILEHDR hdfh;
        LPBITMAPFILEHEADER lpbfh;
        LPBITMAPINFOHEADER lpbmi;

        if (!(lpbfh = (LPBITMAPFILEHEADER)GlobalLock(hdata)))
                return ResultFromScode(E_OUTOFMEMORY);

        lpbmi = (LPBITMAPINFOHEADER)(((BYTE *)lpbfh) +
                        sizeof(BITMAPFILEHEADER));

        hdfh.dwCompression = 0;
        // REVIEW, these casts are hosed
        UtGetDibExtents(lpbmi, (LPLONG)&hdfh.dwWidth, (LPLONG)&hdfh.dwHeight);

        hdfh.dwSize = lpbfh->bfSize - sizeof(BITMAPFILEHEADER);

        // write compesssion, Width, Height, size
        if (error = pstm->Write(&hdfh, sizeof(hdfh), 0))
                goto errRtn;

        // write the BITMAPINFOHEADER
        // REVIEW, does this size include the data?
        if ((error = pstm->Write(lpbmi, hdfh.dwSize, NULL)) == NOERROR)
                StSetSize(pstm, 0, TRUE);

errRtn:
        GlobalUnlock(hdata);
        return(error);
}

#endif // _MAC



FARINTERNAL UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, LPSTREAM lpstream)
{
        VDATEHEAP();

        HRESULT error;

        // if there's no handle, there's nothing to do
        if (*lphMF == 0)
                return ResultFromScode(OLE_E_BLANK);

#ifdef _MAC

        AssertSz(GetHandleSize((Handle)*lphMF) == dwSize,
                        "pic hdl size not correct");
        HLock( (HANDLE)*lphMF );

        error = StWrite(lpstream, * (*lphMF), dwSize);

        // Eric: We should be unlocking, right?
        HUnlock((HANDLE)(*lphMF));

        if (error != NOERROR)
                AssertSz(0, "StWrite failure" );

#else

        HANDLE hBits = NULL;
        void *lpBits;

#ifdef WIN32

        // allocate memory to hold the METAFILE bits
        // Bug 18346 - OLE16 use to get the Handle size of the Metafile which was a METAHEADER bigger than the
        //   actual Metafile.  Need to write out this much more worth of data so 16 bit dlls can read the Picture.

        dwSize += sizeof(METAHEADER);

        hBits = GlobalAlloc(GPTR, dwSize);
        if (hBits == NULL)
                return ResultFromScode(E_OUTOFMEMORY);

        if (!(lpBits = GlobalLock(hBits)))
                goto errRtn;

        // REVIEW, shouldn't we check the returned size?
        // REVIEW, what should we do about enhanced metafiles?  If we
        // convert and write those out (which have more features that 32 bit
        // apps might use,) then you can't read the same document on a win16
        // machine....
        GetMetaFileBitsEx((HMETAFILE)*lphMF, dwSize, lpBits);

        // write the metafile bits out to the stream
        error = StWrite(lpstream, lpBits, dwSize);

        GlobalUnlock(hBits);

errRtn:
        // free the metafile bits
        GlobalFree(hBits);

#else
        if (!(hBits = GetMetaFileBits(*lphMF)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                        goto errRtn;
        }

        if (lpBits = GlobalLock(hBits))
        {
                error = StWrite(lpstream, lpBits, dwSize);
                GlobalUnlock(hBits);
        }
        else
                error = ResultFromScode(E_OUTOFMEMORY);

        if (hBits)
                *lphMF = SetMetaFileBits(hBits);
errRtn:

#endif // WIN32
#endif // _MAC

        // set the stream size
        if (error == NOERROR)
                StSetSize(lpstream, 0, TRUE);

        return(error);
}


//+----------------------------------------------------------------------------
//
//      Function:
//              wPreparePlaceableMFHeader, static
//
//      Synopsis:
//              Initializes a PLACEABLEMETAHEADER.
//
//      Arguments:
//              [lpplac_mfh] -- pointer to the PLACEABLEMETAHEADER to initialize
//              [lWidth] -- Width of the metafile
//                      REVIEW, in what units?
//                      REVIEW, why is this not unsigned?
//              [lHeight] -- Height of the metafile
//                      REVIEW, in what units?
//                      REVIEW, why is this not unsigned?
//
//      Notes:
//
//      History:
//              12/08/93 - ChrisWe - made static
//
//-----------------------------------------------------------------------------
static INTERNAL_(void) wPreparePlaceableMFHeader(
                PLACEABLEMETAHEADER FAR* lpplac_mfh, LONG lWidth, LONG lHeight)
{
        VDATEHEAP();

        WORD FAR* lpw; // roves over the words included in the checksum

        lpplac_mfh->key = PMF_KEY;
        lpplac_mfh->hmf = 0;
        lpplac_mfh->inch = 576; // REVIEW, where's this magic number from?
        lpplac_mfh->bbox.left = 0;
        lpplac_mfh->bbox.top = 0;
        lpplac_mfh->bbox.right = (int) ((lWidth * lpplac_mfh->inch) / 2540);
                        // REVIEW, more magic
        lpplac_mfh->bbox.bottom = (int) ((lHeight * lpplac_mfh->inch) / 2540);
                        // REVIEW, more magic
        lpplac_mfh->reserved = NULL;

        // Compute the checksum of the 10 words that precede the checksum field.
        // It is calculated by XORing zero with those 10 words.
        for(lpplac_mfh->checksum = 0, lpw = (WORD FAR*)lpplac_mfh;
                        lpw < (WORD FAR*)&lpplac_mfh->checksum; ++lpw)
                lpplac_mfh->checksum ^= *lpw;
}


FARINTERNAL UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, DWORD dwSize,
                LONG lWidth, LONG lHeight, LPSTREAM pstm)
{
        VDATEHEAP();

        PLACEABLEMETAHEADER plac_mfh;
        HRESULT error;

        wPreparePlaceableMFHeader(&plac_mfh, lWidth, lHeight);

        // write the placeable header to the stream
        if (error = pstm->Write(&plac_mfh, sizeof(plac_mfh), NULL))
                return(error);

        // write the rest of the METAFILE to the stream
        return UtHMFToMFStm(lphMF, dwSize, pstm);
}


FARINTERNAL UtMFStmToPlaceableMFStm(LPSTREAM pstmMF, DWORD dwSize,
                LONG lWidth, LONG lHeight, LPSTREAM pstmPMF)
{
        VDATEHEAP();

        PLACEABLEMETAHEADER plac_mfh;
        HRESULT error;
        ULARGE_INTEGER ularge_int; // indicates how much data to copy

        wPreparePlaceableMFHeader(&plac_mfh, lWidth, lHeight);

        // write the placeable header to the stream
        if (error = pstmPMF->Write(&plac_mfh, sizeof(plac_mfh), NULL))
                return(error);

        // copy the METAFILE data from one stream to the other
        ULISet32(ularge_int, dwSize);
        if ((error = pstmMF->CopyTo(pstmPMF, ularge_int, NULL, NULL)) ==
                        NOERROR)
                StSetSize(pstmPMF, 0, TRUE);

        return(error);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtWriteOlePresStmHeader, private
//
//  Synopsis:   Write the presentation stream header
//
//  Effects:
//
//  Arguments:  [lpstream] -- destination stream
//              [pforetc]  -- FORMATETC for this presentation
//              [dwAdvf]   -- advise flags for the presentation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    11-May-94 AlexT     Added function header, translate to
//                                  ANSI before saving ptd
//
//  Notes:      This function can fail in low memory for presentations with
//              non-NULL ptds (since we allocate memory to do the conversion
//              to the persistent format).  NtIssue #2789
//
//--------------------------------------------------------------------------

FARINTERNAL UtWriteOlePresStmHeader(LPSTREAM lpstream, LPFORMATETC pforetc,
                DWORD dwAdvf)
{
    VDATEHEAP();

    HRESULT error;
    OLEPRESSTMHDR opsh;

    // write clip format
    // REVIEW, change name of this function?
    if (error = WriteClipformatStm(lpstream, pforetc->cfFormat))
        return(error);

    // write target device info
    if (pforetc->ptd)
    {
        DVTDINFO dvtdInfo;
        DVTARGETDEVICE *ptdA;

        error = UtGetDvtd32Info(pforetc->ptd, &dvtdInfo);
        if (FAILED(error))
        {
            return(error);
        }

        ptdA = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);
        if (NULL == ptdA)
        {
            return(E_OUTOFMEMORY);
        }

        error = UtConvertDvtd32toDvtd16(pforetc->ptd, &dvtdInfo, ptdA);

        if (SUCCEEDED(error))
        {
            error = StWrite(lpstream, ptdA, ptdA->tdSize);
        }

        PrivMemFree(ptdA);

        if (FAILED(error))
        {
            return(error);
        }
    }
    else
    {
        // if ptd is null then write 4 as size.
        // REVIEW, what is that the sizeof()?
        DWORD dwNullPtdLength = 4;

        if (error = StWrite(lpstream, &dwNullPtdLength, sizeof(DWORD)))
            return(error);
    }

    opsh.dwAspect = pforetc->dwAspect;
    opsh.dwLindex = pforetc->lindex;
    opsh.dwAdvf = dwAdvf;

    // write DVASPECT, lindex, advise flags
    return StWrite(lpstream, &opsh, sizeof(opsh));
}

//+-------------------------------------------------------------------------
//
//  Function:   UtReadOlePresStmHeader
//
//  Synopsis:   Reads in a presentation stream header
//
//  Arguments:  [pstm] -- source stream
//              [pforetc] -- FORMATETC to be filled in
//              [pdwAdvf] -- advise flags to be filled in
//              [pfConvert] -- Mac conversion required, to be filled in
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    11-May-94 AlexT     Added function header, translate ptd
//                                  from ANSI when loading
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL UtReadOlePresStmHeader(LPSTREAM pstm, LPFORMATETC pforetc,
                DWORD FAR* pdwAdvf, BOOL FAR* pfConvert)
{
    VDATEHEAP();

    HRESULT error;
    DWORD dwRead;
    OLEPRESSTMHDR opsh;

    // initialize this for error return cases
    // Check for NULL ptr, as caller may not need this information

    if (pfConvert)
    {
        *pfConvert = FALSE;
    }

    // there's no target device information yet
    pforetc->ptd = NULL;

    // REVIEW, rename this function to indicate its origin?
    error = ReadClipformatStm(pstm, &dwRead);

    if (error == NOERROR)
        pforetc->cfFormat = (CLIPFORMAT)dwRead;
    else
    {
#ifndef _MAC
        if (GetScode(error) == OLE_S_MAC_CLIPFORMAT)
        {
           // check whether the clipformat is "pict"
           // REVIEW, what's this cuteness?
           if (dwRead != *((DWORD *)"TCIP"))
                return(error);

           if (pfConvert)
                *pfConvert = TRUE;
           else
                return ResultFromScode(DV_E_CLIPFORMAT);

           pforetc->cfFormat = CF_METAFILEPICT;
        }
        else
#endif
            return(error);
    }

    // set the proper tymed
    if (pforetc->cfFormat == CF_METAFILEPICT)
    {
        pforetc->tymed = TYMED_MFPICT;
    }
    else if (pforetc->cfFormat == CF_ENHMETAFILE)
    {
        pforetc->tymed = TYMED_ENHMF;
    }
    else if (pforetc->cfFormat == CF_BITMAP)
    {
        AssertSz(0, "We don't read/save CF_BITMAP anymore");
        return ResultFromScode(DV_E_CLIPFORMAT);
    }
    else if (pforetc->cfFormat == NULL)
    {
        pforetc->tymed = TYMED_NULL;
    }
    else
    {
        pforetc->tymed = TYMED_HGLOBAL;
    }

    // Read targetdevice info.
    if (error = StRead(pstm, &dwRead, sizeof(dwRead)))
        return(error);

    // if the tdSize of ptd is non-null and is > 4, then go ahead read the
    // remaining data of the target device info
    if (dwRead > 4)
    {
        DVTARGETDEVICE *ptdA;
        DVTDINFO dvtdInfo;

        ptdA = (DVTARGETDEVICE *) PrivMemAlloc(dwRead);
        if (NULL == ptdA)
        {
            return ResultFromScode(E_OUTOFMEMORY);
        }

        ptdA->tdSize = dwRead;
        error = StRead(pstm, ((BYTE*)ptdA) + sizeof(dwRead),
                       dwRead - sizeof(dwRead));

        if (SUCCEEDED(error))
        {
            error = UtGetDvtd16Info(ptdA, &dvtdInfo);
            if (SUCCEEDED(error))
            {
                pforetc->ptd = (DVTARGETDEVICE *) PubMemAlloc(dvtdInfo.cbConvertSize);
                if (NULL == pforetc->ptd)
                {
                    error = E_OUTOFMEMORY;
                }
                else
                {
                    error = UtConvertDvtd16toDvtd32(ptdA, &dvtdInfo, pforetc->ptd);
                }
            }
        }

        PrivMemFree(ptdA);

        if (FAILED(error))
        {
            goto errRtn;
        }
    }
    else
        pforetc->ptd = NULL;

    // Read DVASPECT, lindex, advise flags
    if ((error = StRead(pstm, &opsh, sizeof(opsh))) != NOERROR)
        goto errRtn;

    pforetc->dwAspect = opsh.dwAspect;
    pforetc->lindex = opsh.dwLindex;
    if (pdwAdvf)
        *pdwAdvf = opsh.dwAdvf;

    return NOERROR;

errRtn:
    if (pforetc->ptd)
    {
        PubMemFree(pforetc->ptd);
        pforetc->ptd = NULL;
    }

    return(error);
}


FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
                BOOL fDeletePresStm, UINT FAR* puiStatus)
{
        VDATEHEAP();

        LPSTREAM pstmOlePres;
        LPSTREAM pstmContents = NULL;
        HRESULT error;
        FORMATETC foretc;
        HDIBFILEHDR hdfh;

        // there's no status yet
        *puiStatus = 0;

        // POSTPPC:
        //
        // This function needs to be rewritten to correctly handle the case described in
        // the comments below (rather than just skipping out of the function if the contents
        // stream already exists).  The best course of action will probably be to convert
        // DIBs->Metafiles and Metafiles->DIBs in the needed cases.

        // The code inside the #ifdef below is used to determine if the contents
        // stream has already been created (which is the case for an object that has
        // been converted to a bitmap) because in the case of an object that has been
        // converted to a static DIB and the object has a METAFILE presentation stream
        // we already have a cachenode created as a DIB and we will read the contents
        // stream after this call to get the DIB data.  However, this function sees
        // the metafile presentation, and converts it into the contents stream (which
        // when then try to load as a DIB) and bad things happen (it doesn't work).  If
        // the stream already exists, then we bail out of this function.
        if (pstg->CreateStream(OLE_CONTENTS_STREAM,(STGM_READWRITE | STGM_SHARE_EXCLUSIVE), NULL,
                         0, &pstmContents) != NOERROR)
        {
            return NOERROR;
        }

        // created stream, it must not have existed
        pstmContents->Release();
        pstg->DestroyElement(OLE_CONTENTS_STREAM);

        if ((error = pstg->OpenStream(lpszPresStm, NULL,
                        (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstmOlePres)) !=
                        NOERROR)
        {
                // we can't open the source stream
                *puiStatus |= CONVERT_NOSOURCE;

                // check whether "CONTENTS" stream exits
                if (pstg->OpenStream(OLE_CONTENTS_STREAM, NULL,
                                (STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
                                &pstmContents) != NOERROR)
                {
                        // we can't open the destination stream either
                        // REVIEW, since we can't open the source, who cares?
                        // REVIEW, is there a cheaper way to test existence
                        // other than opening?
                        *puiStatus |= CONVERT_NODESTINATION;
                }
                else
                        pstmContents->Release();

                return(error);
        }

        foretc.ptd = NULL;
        if (error = UtReadOlePresStmHeader(pstmOlePres, &foretc, NULL, NULL))
                goto errRtn;

        if (error = pstmOlePres->Read(&hdfh, sizeof(hdfh), 0))
                goto errRtn;

        AssertSz(hdfh.dwCompression == 0,
                        "Non-zero compression not supported");

        if (error = OpenOrCreateStream(pstg, OLE_CONTENTS_STREAM,
                        &pstmContents))
        {
                *puiStatus |= CONVERT_NODESTINATION;
                goto errRtn;
        }

        if (foretc.dwAspect == DVASPECT_ICON)
        {
                *puiStatus |= CONVERT_SOURCEISICON;
                fDeletePresStm = FALSE;
                error = NOERROR;
                goto errRtn;
        }

        if (foretc.cfFormat == CF_DIB)
                error = UtDIBStmToDIBFileStm(pstmOlePres, hdfh.dwSize,
                                pstmContents);
        else if (foretc.cfFormat == CF_METAFILEPICT)
                error = UtMFStmToPlaceableMFStm(pstmOlePres,
                                hdfh.dwSize, hdfh.dwWidth, hdfh.dwHeight,
                                pstmContents);
        else
                error = ResultFromScode(DV_E_CLIPFORMAT);

errRtn:
        if (pstmOlePres)
                pstmOlePres->Release();

        if (pstmContents)
                pstmContents->Release();

        if (foretc.ptd)
                PubMemFree(foretc.ptd);

        if (error == NOERROR)
        {
                if (fDeletePresStm && lpszPresStm)
                        pstg->DestroyElement(lpszPresStm);
        }
        else
        {
                pstg->DestroyElement(OLE_CONTENTS_STREAM);
        }

        return(error);
}

FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
				LPSTREAM pstmContents, UINT FAR* puiStatus)
{
	HRESULT error = S_OK;
    LPSTREAM pstmOlePres = NULL;
    FORMATETC foretc;
    HDIBFILEHDR hdfh;

    // there's no status yet
    *puiStatus = 0;

    if ((error = pstg->OpenStream(lpszPresStm, NULL,
                    (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstmOlePres)) !=
                    NOERROR)
    {
            // we can't open the source stream
            *puiStatus |= CONVERT_NOSOURCE;
            return(error);
    }

    foretc.ptd = NULL;
    if (error = UtReadOlePresStmHeader(pstmOlePres, &foretc, NULL, NULL))
            goto errRtn;

    if (error = pstmOlePres->Read(&hdfh, sizeof(hdfh), 0))
            goto errRtn;

    AssertSz(hdfh.dwCompression == 0,
                    "Non-zero compression not supported");

    if (foretc.dwAspect == DVASPECT_ICON)
    {
            *puiStatus |= CONVERT_SOURCEISICON;
            error = NOERROR;
            goto errRtn;
    }

    if (foretc.cfFormat == CF_DIB)
            error = UtDIBStmToDIBFileStm(pstmOlePres, hdfh.dwSize,
                            pstmContents);
    else if (foretc.cfFormat == CF_METAFILEPICT)
            error = UtMFStmToPlaceableMFStm(pstmOlePres,
                            hdfh.dwSize, hdfh.dwWidth, hdfh.dwHeight,
                            pstmContents);
    else
            error = ResultFromScode(DV_E_CLIPFORMAT);

errRtn:
    if (pstmOlePres)
            pstmOlePres->Release();

	return error;
}


FARINTERNAL_(HANDLE) UtGetHPRESFromNative(LPSTORAGE pstg, LPSTREAM pstm, CLIPFORMAT cfFormat,
                BOOL fOle10Native)
{
        VDATEHEAP();

        BOOL fReleaseStm = !pstm;
        HGLOBAL hdata = NULL;

        if ((cfFormat != CF_METAFILEPICT) &&
            (cfFormat != CF_DIB) &&
            (cfFormat != CF_ENHMETAFILE))
        {
                return(NULL);
        }

        if (fOle10Native)
        {
                DWORD dwSize;

				if(!pstm)
				{
					if (pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
									(STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
									&pstm) != NOERROR)
							return(NULL);
				}

                if (pstm->Read(&dwSize, sizeof(DWORD), NULL) == NOERROR)
                {
                        // is it PBrush native data?
                        if (cfFormat == CF_DIB)
                                UtGetHDIBFromDIBFileStm(pstm, &hdata);
                        else
                        {
                                // MSDraw native data or PaintBrush
                                //
                                UtGetHMFPICTFromMSDrawNativeStm(pstm, dwSize,
                                                &hdata);
                        }
                }
        }
        else
        {
				if(!pstm)
				{
					if (pstg->OpenStream(OLE_CONTENTS_STREAM, NULL,
									(STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
									&pstm) != NOERROR)
							return(NULL);
				}

                if (cfFormat == CF_DIB)
                {
                        UtGetHDIBFromDIBFileStm(pstm, &hdata);
                }
                else if (cfFormat == CF_METAFILEPICT)
                {
                        UtGetHMFPICTFromPlaceableMFStm(pstm, &hdata);
                }
                else
                {
                        UtGetHEMFFromContentsStm(pstm, &hdata);
                }
        }

		if(fReleaseStm)
			pstm->Release();

        return(hdata);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\global.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		global.cpp
//
//	Contents:
//		Ut functions that deal with HGlobals for debugging;
//		see le2int.h
//
//	Classes:
//
//	Functions:
//		UtGlobalAlloc
//		UtGlobalReAlloc
//		UtGlobalLock
//		UtGlobalUnlock
//		UtGlobalFree
//              UtGlobalFlush
//              UtSetClipboardData
//
//	History:
//		12/20/93 - ChrisWe - created
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//              02/25/94 AlexT      Add some generic integrity checking
//              03/30/94 AlexT      Add UtSetClipboardData
//
//  Notes:
//
//  These routines are designed to catch bugs that corrupt GlobalAlloc memory.
//  We cannot guarantee that all global memory will be manipulated with these
//  routines (e.g.  OLE might allocate a handle and the client application
//  might free it), so we can't require that these routines be used in pairs.
//
//-----------------------------------------------------------------------------


#include <le2int.h>

#if DBG==1 && defined(WIN32)
#include <olesem.hxx>

ASSERTDATA

// undefine these, so we don't call ourselves recursively
// if this module is used, these are defined in le2int.h to replace
// the existing allocator with the functions here
#undef GlobalAlloc
#undef GlobalReAlloc
#undef GlobalLock
#undef GlobalUnlock
#undef GlobalFree
#undef SetClipboardData

//  Same ones as in memapi.cxx
#define OLEMEM_ALLOCBYTE       0xde
#define OLEMEM_FREEBYTE        0xed

typedef struct s_GlobalAllocInfo
{
    HGLOBAL hGlobal;                        //  A GlobalAlloc'd HGLOBAL
    SIZE_T   cbGlobalSize;                   //  GlobalSize(hGlobal)
    SIZE_T   cbUser;                         //  size requested by caller
    ULONG   ulIndex;                        //  allocation index (1st, 2nd...)
    struct s_GlobalAllocInfo *pNext;
} SGLOBALALLOCINFO, *PSGLOBALALLOCINFO;

//+-------------------------------------------------------------------------
//
//  Class:      CGlobalTrack
//
//  Purpose:    GlobalAlloc memory tracking
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGlobalTrack
{
  public:

    //
    //  We only have a constructor for debug builds, to ensure this object
    //  is statically allocated. Statically allocated objects are initialized
    //  to all zeroes, which is what we need.
    //

    CGlobalTrack();

    HGLOBAL cgtGlobalAlloc(UINT uiFlag, SIZE_T cbUser);
    HGLOBAL cgtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag);
    HGLOBAL cgtGlobalFree(HGLOBAL hGlobal);
    LPVOID  cgtGlobalLock(HGLOBAL hGlobal);
    BOOL    cgtGlobalUnlock(HGLOBAL hGlobal);

    void    cgtVerifyAll(void);
    void    cgtFlushTracking(void);
    BOOL    cgtStopTracking(HGLOBAL hGlobal);

  private:
    SIZE_T CalculateAllocSize(SIZE_T cbUser);
    void InitializeRegion(HGLOBAL hGlobal, SIZE_T cbStart, SIZE_T cbEnd);
    void Track(HGLOBAL hGlobal, SIZE_T cbUser);
    void Retrack(HGLOBAL hOld, HGLOBAL hNew);
    void VerifyHandle(HGLOBAL hGlobal);

    ULONG _ulIndex;
    PSGLOBALALLOCINFO _pRoot;
    static COleStaticMutexSem _mxsGlobalMemory;
};

COleStaticMutexSem CGlobalTrack::_mxsGlobalMemory;

CGlobalTrack gGlobalTrack;



//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::CGlobalTrack, public
//
//  Synopsis:   constructor
//
//  History:    28-Feb-94 AlexT     Created
//
//--------------------------------------------------------------------------

CGlobalTrack::CGlobalTrack()
{
    Win4Assert (g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);
    Win4Assert (_pRoot == NULL && _ulIndex == 0);
}



//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalAlloc, public
//
//  Synopsis:   Debugging version of GlobalAlloc
//
//  Arguments:  [uiFlag] -- allocation flags
//              [cbUser] -- requested allocation size
//
//  Requires:   We must return a "real" GlobalAlloc'd pointer, because
//              we may not necessarily be the ones to free it.
//
//  Returns:    HGLOBAL
//
//  Algorithm:  We allocate an extra amount to form a tail and initialize it
//              to a known value.
//
//  History:    25-Feb-94 AlexT     Added this prologue
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalAlloc(UINT uiFlag, SIZE_T cbUser)
{
    VDATEHEAP();

    SIZE_T cbAlloc;
    HGLOBAL hGlobal;

    cbAlloc = CalculateAllocSize(cbUser);
    hGlobal = GlobalAlloc(uiFlag, cbAlloc);
    if (NULL == hGlobal)
    {
        LEDebugOut((DEB_WARN, "GlobalAlloc(%ld) failed - %lx\n", cbAlloc,
                   GetLastError()));
    }
    else
    {
        if (uiFlag & GMEM_ZEROINIT)
        {
            //   Caller asked for zeroinit, so we only initialize the tail
            InitializeRegion(hGlobal, cbUser, cbAlloc);
        }
        else
        {
            //  Caller did not ask for zeroinit, so we initialize the whole
            //  region
            InitializeRegion(hGlobal, 0, cbAlloc);
        }

        Track(hGlobal, cbUser);
    }

    return(hGlobal);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalReAlloc, public
//
//  Synopsis:   Debugging version of GlobalReAlloc
//
//  Arguments:  [hGlobal] -- handle to reallocate
//              [cbUser] -- requested allocation size
//              [uiFlag] -- allocation flags
//
//  Returns:    reallocated handle
//
//  Algorithm:
//
//    if (modify only)
//      reallocate
//    else
//      reallocate with tail
//      initialize tail
//
//    update tracking information
//
//  History:    25-Feb-94 AlexT     Added this prologue
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag)
{
    VDATEHEAP();

    HGLOBAL hNew;
    SIZE_T cbAlloc;

    VerifyHandle(hGlobal);

    if (uiFlag & GMEM_MODIFY)
    {
        //  We're not changing sizes, so there's no work for us to do

        LEDebugOut((DEB_WARN, "UtGlobalReAlloc modifying global handle\n"));
        hNew = GlobalReAlloc(hGlobal, cbUser, uiFlag);
    }
    else
    {
        cbAlloc = CalculateAllocSize(cbUser);
        hNew = GlobalReAlloc(hGlobal, cbAlloc, uiFlag);
        if (NULL == hNew)
        {
            LEDebugOut((DEB_WARN, "GlobalReAlloc failed - %lx\n",
                        GetLastError()));
        }
        else
        {
            InitializeRegion(hNew, cbUser, cbAlloc);
        }
    }

    if (NULL != hNew)
    {
        if (uiFlag & GMEM_MODIFY)
        {
            //  Retrack will only track hNew if we were tracking hGlobal
            Retrack(hGlobal, hNew);
        }
        else
        {
            //  We've allocated a new block, so we always want to track the
            //  new one
            cgtStopTracking(hGlobal);
            Track(hNew, cbUser);
        }
    }

    return(hNew);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalFree, public
//
//  Synopsis:   Debugging version of GlobalReAlloc
//
//  Arguments:  [hGlobal] -- global handle to free
//
//  Returns:    Same as GlobalFree
//
//  Algorithm:
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalFree(HGLOBAL hGlobal)
{
    VDATEHEAP();

    HGLOBAL hReturn;

    VerifyHandle(hGlobal);

    hReturn = GlobalFree(hGlobal);

    if (NULL == hReturn)
    {
        cgtStopTracking(hGlobal);
    }
    else
    {
        LEDebugOut((DEB_WARN, "GlobalFree did not free %lx\n", hGlobal));
    }

    return(hReturn);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalLock, public
//
//  Synopsis:   Debugging version of GlobalLock
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Returns:    Same as GlobalLock
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

LPVOID CGlobalTrack::cgtGlobalLock(HGLOBAL hGlobal)
{
    VDATEHEAP();

    VerifyHandle(hGlobal);
    return(GlobalLock(hGlobal));
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalUnlock, public
//
//  Synopsis:   Debugging version of GlobalUnlock
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Returns:    Same as GlobalUnlock
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGlobalTrack::cgtGlobalUnlock(HGLOBAL hGlobal)
{
    VDATEHEAP();

    VerifyHandle(hGlobal);
    return(GlobalUnlock(hGlobal));
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtVerifyAll, public
//
//  Synopsis:   Verify all tracked handles
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::cgtVerifyAll(void)
{
    VerifyHandle(NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtFlushTracking
//
//  Synopsis:   Stops all tracking
//
//  Effects:    Frees all internal memory
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::cgtFlushTracking(void)
{
    COleStaticLock lck(_mxsGlobalMemory);
    BOOL bResult;

    while (NULL != _pRoot)
    {
        bResult = cgtStopTracking(_pRoot->hGlobal);
        Assert(bResult && "CGT::cgtFlushTracking problem");
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::CalculateAllocSize, private
//
//  Synopsis:   calculate total allocation size (inluding tail)
//
//  Arguments:  [cbUser] -- requested size
//
//  Returns:    total count of bytes to allocate
//
//  Algorithm:  calculate bytes needed to have at least one guard page at the
//              end
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:      By keeping this calculation in one location we make it
//              easier to maintain.
//
//--------------------------------------------------------------------------

SIZE_T CGlobalTrack::CalculateAllocSize(SIZE_T cbUser)
{
    SYSTEM_INFO si;
    SIZE_T cbAlloc;

    GetSystemInfo(&si);

    //  Calculate how many pages are need to cover cbUser
    cbAlloc = ((cbUser + si.dwPageSize - 1) / si.dwPageSize) * si.dwPageSize;

    //  Add an extra page so that the tail is at least one page long
    cbAlloc += si.dwPageSize;

    return(cbAlloc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::InitializeRegion, private
//
//  Synopsis:   initialize region to bad value
//
//  Effects:    fills in memory region
//
//  Arguments:  [hGlobal] -- global memory handle
//              [cbStart] -- count of bytes to skip
//              [cbEnd]   -- end offset (exclusive)
//
//  Requires:   cbEnd > cbStart
//
//  Algorithm:  fill in hGlobal from cbStart (inclusive) to cbEnd (exclusive)
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::InitializeRegion(HGLOBAL hGlobal, SIZE_T cbStart, SIZE_T cbEnd)
{
    BYTE *pbStart;
    BYTE *pb;

    Assert(cbStart < cbEnd && "illogical parameters");
    Assert(cbEnd <= GlobalSize(hGlobal) && "global memory too small");

    //  GlobalLock on GMEM_FIXED memory is a nop, so this is a safe call
    pbStart = (BYTE *) GlobalLock(hGlobal);

    if (NULL == pbStart)
    {
        //  Shouldn't have failed - (we allocated > 0 bytes)

        LEDebugOut((DEB_WARN, "GlobalLock failed - %lx\n", GetLastError()));
        return;
    }

    //  Initialize the tail portion of the memory
    for (pb = pbStart + cbStart; pb < pbStart + cbEnd; pb++)
    {
        *pb = OLEMEM_ALLOCBYTE;
    }

    GlobalUnlock(hGlobal);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::Track, private
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hGlobal] -- global memory handle
//              [cbUser] -- user allocation size
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::Track(HGLOBAL hGlobal, SIZE_T cbUser)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi;

    if (cgtStopTracking(hGlobal))
    {
        //  If it's already in our list, it's possible that someone else
        //  freed the HGLOBAL without telling us - remove our stale one
        LEDebugOut((DEB_WARN, "CGT::Track - %lx was already in list!\n",
                    hGlobal));
    }

    pgi = (PSGLOBALALLOCINFO) PrivMemAlloc(sizeof(SGLOBALALLOCINFO));
    if (NULL == pgi)
    {
        LEDebugOut((DEB_WARN, "CGT::Insert - PrivMemAlloc failed\n"));

        //  Okay fine - we just won't track this one

        return;
    }

    pgi->hGlobal = hGlobal;
    pgi->cbGlobalSize = GlobalSize(hGlobal);
    Assert((0 == cbUser || pgi->cbGlobalSize > 0) && "GlobalSize failed - bad handle?");
    pgi->cbUser = cbUser;
    pgi->ulIndex = ++_ulIndex;
    pgi->pNext = _pRoot;
    _pRoot = pgi;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::Retrack, private
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hOld] -- previous handle
//              [hNew] -- new handle
//
//  Modifies:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::Retrack(HGLOBAL hOld, HGLOBAL hNew)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi;

    if (hOld != hNew && cgtStopTracking(hNew))
    {
        //  If hNew was already in the list, it's possible that someone else
        //  freed the HGLOBAL without telling us so we removed the stale one
        LEDebugOut((DEB_WARN, "CGT::Retrack - %lx was already in list!\n", hNew));
    }

    for (pgi = _pRoot; NULL != pgi; pgi = pgi->pNext)
    {
        if (pgi->hGlobal == hOld)
        {
            pgi->hGlobal = hNew;
            break;
        }
    }

    if (NULL == pgi)
    {
        //  We didn't find hOld
        LEDebugOut((DEB_WARN, "CGT::Retrack - hOld (%lx) not found\n", hOld));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtStopTracking, public
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hGlobal] -- global handle
//
//  Modifies:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGlobalTrack::cgtStopTracking(HGLOBAL hGlobal)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO *ppgi = &_pRoot;
    PSGLOBALALLOCINFO pgi;

    while (*ppgi != NULL && (*ppgi)->hGlobal != hGlobal)
    {
        ppgi = &((*ppgi)->pNext);
    }

    if (NULL == *ppgi)
    {
        return(FALSE);
    }

    pgi = *ppgi;
    Assert(pgi->hGlobal == hGlobal && "CGT::cgtStopTracking search problem");

    *ppgi = pgi->pNext;

    PrivMemFree(pgi);
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::VerifyHandle, private
//
//  Synopsis:   Verify global handle
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Signals:    Asserts if bad
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//              22-Jun-94 AlexT     Allow for handle to have been freed and
//                                  reallocated under us
//
//--------------------------------------------------------------------------

void CGlobalTrack::VerifyHandle(HGLOBAL hGlobal)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi, pgiNext;
    SIZE_T cbAlloc;
    BYTE *pbStart;
    BYTE *pb;

    //  Note that we use a while loop (recording pgiNext up front) instead
    //  of a for loop because pgi will get removed from the list if we call
    //  cgtStopTracking on it

    pgi = _pRoot;
    while (NULL != pgi)
    {
        pgiNext = pgi->pNext;

        if (NULL == hGlobal || pgi->hGlobal == hGlobal)
        {
            if (pgi->cbGlobalSize != GlobalSize(pgi->hGlobal))
            {
                //  pgi->hGlobal's size has changed since we started tracking
                //  it;  it must have been freed or reallocated by someone
                //  else.  Stop tracking it.

                //  This call will remove pgi from the list (so we NULL it to
                //  make sure we don't try reusing it)!

                cgtStopTracking(pgi->hGlobal);
                pgi = NULL;
            }
            else
            {
                cbAlloc = CalculateAllocSize(pgi->cbUser);

                pbStart = (BYTE *) GlobalLock(pgi->hGlobal);

                // it is legitimate to have a zero length (NULL memory) handle
                if (NULL == pbStart)
                {
                    LEDebugOut((DEB_WARN, "GlobalLock failed - %lx\n",
                               GetLastError()));
                }
                else
                {
                    for (pb = pbStart + pgi->cbUser;
                         pb < pbStart + cbAlloc;
                         pb++)
                    {
                        if (*pb != OLEMEM_ALLOCBYTE)
                            break;
                    }

                    if (pb < pbStart + cbAlloc)
                    {
                        //  In general an application may have freed and reallocated
                        //  any HGLOBAL, so we can only warn about corruption.

                        LEDebugOut((DEB_WARN, "HGLOBAL #%ld may be corrupt\n",
                                   pgi->ulIndex));
#ifdef GLOBALDBG
                        //  If GLOBALDBG is true, then all allocations should be
                        //  coming through these routines.  In this case we assert
                        //  if we've found corruption.
                        Assert(0 && "CGlobalTrack::VerifyHandle - HGLOBAL corrupt");
#endif
                    }

                    GlobalUnlock(pgi->hGlobal);
                }
            }
        }

        pgi = pgiNext;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGlobalAlloc, ReAlloc, Free, Lock, Unlock
//
//  Synopsis:   Debug versions of Global memory routines
//
//  Arguments:  Same as Windows APIs
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:      These entry points just call the worker routines
//
//--------------------------------------------------------------------------

extern "C" HGLOBAL WINAPI UtGlobalAlloc(UINT uiFlag, SIZE_T cbUser)
{
    return gGlobalTrack.cgtGlobalAlloc(uiFlag, cbUser);
}

extern "C" HGLOBAL WINAPI UtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag)
{
    return gGlobalTrack.cgtGlobalReAlloc(hGlobal, cbUser, uiFlag);
}

extern "C" LPVOID WINAPI UtGlobalLock(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalLock(hGlobal);
}

extern "C" BOOL WINAPI UtGlobalUnlock(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalUnlock(hGlobal);
}

extern "C" HGLOBAL WINAPI UtGlobalFree(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalFree(hGlobal);
}

extern "C" void UtGlobalFlushTracking(void)
{
    gGlobalTrack.cgtFlushTracking();
}

//+-------------------------------------------------------------------------
//
//  Function:   UtSetClipboardData
//
//  Synopsis:   Calls Windows SetClipboardData and stops tracking the handle
//
//  Arguments:  [uFormat] -- clipboard format
//              [hMem]    -- data handle
//
//  Returns:    Same as SetClipboard
//
//  Algorithm:  If SetClipboardData succeeds, stop tracking the handle
//
//  History:    30-Mar-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C" HANDLE WINAPI UtSetClipboardData(UINT uFormat, HANDLE hMem)
{
    HANDLE hRet;

    hRet = SetClipboardData(uFormat, hMem);

    if (NULL != hRet)
    {
        gGlobalTrack.cgtStopTracking(hMem);
    }

    return(hRet);
}

#endif  //  DBG==1 && defined(WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   util
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\convert.cpp  \
              ..\global.cpp   \
              ..\map_kv.cpp   \
              ..\ole2util.cpp \
              ..\plex.cpp     \
              ..\utils.cpp    \
              ..\utstream.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\ole2util.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              ole2util.cpp
//
//      Contents:
//              Ole internal utility routines
//
//      Classes:
//
//      Functions:
//
//      History:
//              06/01/94 - AlexGo  - UtQueryPictFormat now supports
//                      enhanced metafiles
//              03/18/94 - AlexGo  - fixed UtGetPresStreamName (incorrect
//                      string processing)
//              01/11/94 - ChrisWe - don't reference unlocked handle in
//                      UtConvertBitmapToDib
//              01/11/94 - alexgo  - added VDATEHEAP macro to every function
//              12/07/93 - ChrisWe - removed incorrect uses of (LPOLESTR);
//                      removed duplicate GetClassFromDataObj function, which
//                      is the same as UtGetClassID
//              11/30/93 - ChrisWe - continue file cleanup; don't open
//                      streams in UtRemoveExtraOlePresStreams()
//              11/28/93 - ChrisWe - file cleanup and inspection;
//                      reformatted many functions
//              11/22/93 - ChrisWe - replace overloaded ==, != with
//                      IsEqualIID and IsEqualCLSID
//              06/28/93 - SriniK - added UtGetDibExtents
//              11/16/92 - JasonFul - created; moved contents here from util.cpp
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(ole2util)

NAME_SEG(Ole2Utils)
ASSERTDATA

#define WIDTHBYTES(i)   ((i+31)/32*4)

#define PALETTESIZE     256    /* Number of entries in the system palette     */

// REVIEW, according to the spec, IDataObject::EnumFormatEtc() is only
// required to service one dwDirection DATADIR_ value at a time.  This
// function has been asking it to do more than one at a time, and expecting
// return of FORMATETCs that match all the requested directions.  Code
// seen in OleRegEnumFormatEtc() checks on creation, and fails if any
// value other than plain DATADIR_GET or plain DATADIR_SET is specified
// so this has clearly never worked for OLE1, or registration database lookups
// since the only caller of UtIsFormatSupported has always asked for both
// at the same time.
#pragma SEG(UtIsFormatSupported)
FARINTERNAL_(BOOL) UtIsFormatSupported(IDataObject FAR* lpDataObj,
		DWORD dwDirection, CLIPFORMAT cfFormat)
{
	VDATEHEAP();

	FORMATETC formatetc; // a place to fetch formats from the enumerator
	IEnumFORMATETC FAR* penm; // enumerates the formats of [lpDataObj]
	ULONG ulNumFetched; // a count of the number of formats fetched
	HRESULT error; // the error state so far

	// try to get the enumerator from the data object
	error = lpDataObj->EnumFormatEtc(dwDirection, &penm);

	if (error != NOERROR)
	{                       
		if (FAILED(error))
			return FALSE;
		else
		{
			CLSID clsid;

			// Use reg db; this case is primarily for the OLE1
			// compatibility code since it may talk to a data
			// object from a server in the same process as
			// the server.
			if (UtGetClassID(lpDataObj, &clsid) != TRUE)
				return(FALSE);

			// synthesize an enumerator
			// REVIEW, if the data object is synthesized for
			// the OLE1 object, why doesn't that implementation
			// go ahead and synthesize this?  Why does it have
			// to be done like this?  What if it's on the clipboard
			// and someone wants to use it?
			if (OleRegEnumFormatEtc(clsid, dwDirection, &penm)
					!= NOERROR)
				return FALSE;
			Assert(penm);
		}
	}

	// check for the format we're looking for
	while(NOERROR == (error = penm->Next(1, &formatetc, &ulNumFetched)))
	{
		if ((ulNumFetched == 1) && (formatetc.cfFormat == cfFormat))
			break;
	}
	
	// release the enumerator
	penm->Release();

	// if error isn't S_FALSE, we fetched an item, and broke out of the
	// while loop above --> the format was found.  Return TRUE indicating
	// that the format is supported
	return(error == NOERROR ? TRUE : FALSE);
}


#pragma SEG(UtDupPalette)
FARINTERNAL_(HPALETTE) UtDupPalette(HPALETTE hpalette)
{
	VDATEHEAP();

	WORD cEntries; // holds the number of entries in the palette
	HANDLE hLogPal; // ia a handle to a new logical palette
	LPLOGPALETTE pLogPal; // is a pointer to the new logical palette
	HPALETTE hpaletteNew = NULL; // the new palette we will return

	if (0 == GetObject(hpalette, sizeof(cEntries), &cEntries))
		return(NULL);

	if (NULL == (hLogPal = GlobalAlloc(GMEM_MOVEABLE,
			sizeof (LOGPALETTE) +
			cEntries * sizeof (PALETTEENTRY))))
		return(NULL);

	if (NULL == (pLogPal = (LPLOGPALETTE)GlobalLock(hLogPal)))
		goto errRtn;
		
	if (0 == GetPaletteEntries(hpalette, 0, cEntries,
			pLogPal->palPalEntry))
		goto errRtn;

	pLogPal->palVersion = 0x300;
	pLogPal->palNumEntries = cEntries;

	if (NULL == (hpaletteNew = CreatePalette(pLogPal)))
		goto errRtn;

errRtn:
	if (pLogPal)
		GlobalUnlock(hLogPal);

	if (hLogPal)
		GlobalFree(hLogPal);

	AssertSz(hpaletteNew, "Warning: UtDupPalette Failed");
	return(hpaletteNew);
}
	
//+-------------------------------------------------------------------------
//
//  Function:   UtFormatToTymed
//
//  Synopsis:   gets the right TYMED for the given rendering format
//
//  Effects:
//
//  Arguments:  [cf]    -- the clipboard format
//
//  Requires:
//
//  Returns:    one of the TYMED enumeration
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Jul-94 alexgo    added EMF's
//              
//  Notes:      This should only be called for formats that we can
//              render
//
//--------------------------------------------------------------------------

#pragma SEG(UtFormatToTymed)
FARINTERNAL_(DWORD) UtFormatToTymed(CLIPFORMAT cf)
{
	VDATEHEAP();

	if( cf == CF_METAFILEPICT )
	{
		return TYMED_MFPICT;
	}
	else if( cf == CF_BITMAP )
	{
		return TYMED_GDI;
	}
	else if( cf == CF_DIB )
	{
		return TYMED_HGLOBAL;
	}
	else if( cf == CF_ENHMETAFILE )
	{
		return TYMED_ENHMF;
	}
	else if( cf == CF_PALETTE )
	{
		LEWARN(1,"Trying to render CF_PALETTE");
		return TYMED_GDI;
	}

	LEDebugOut((DEB_WARN, "WARNING: trying to render clipformat (%lx)\n",
		cf));

	return TYMED_HGLOBAL;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtQueryPictFormat
//
//  Synopsis:   finds our "preferred" drawing formatetc from the given
//              data object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the source data object
//              [lpforetc]      -- where to stuff the preferred format
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 alexgo    rewrite/now supports Enhanced Metafiles
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(UtQueryPictFormat)
FARINTERNAL_(BOOL) UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj,
		LPFORMATETC lpforetc)
{
	FORMATETC foretctemp; // local copy of current values of format desc
	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtQueryPictFormat ( %p , %p )\n",
		NULL, lpSrcDataObj, lpforetc));

	// copy format descriptor
	foretctemp = *lpforetc;

	// set values and query for our preferred formats in order of
	// preference

	
	foretctemp.cfFormat = CF_METAFILEPICT;
	foretctemp.tymed = TYMED_MFPICT;        
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}

	foretctemp.cfFormat = CF_ENHMETAFILE;
	foretctemp.tymed = TYMED_ENHMF;
	if( lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR )
	{
		goto QuerySuccess;
	}
	foretctemp.cfFormat = CF_DIB;
	foretctemp.tymed = TYMED_HGLOBAL;       
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}
	
	foretctemp.cfFormat = CF_BITMAP;
	foretctemp.tymed = TYMED_GDI;   
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}

	LEDebugOut((DEB_ITRACE, "%p OUT UtQueryPictFormat ( %lu )\n",
		NULL, FALSE));

	return FALSE;

QuerySuccess:
	// data object supports this format; change passed in
	// format to match

	lpforetc->cfFormat = foretctemp.cfFormat;
	lpforetc->tymed = foretctemp.tymed;

	// return success

	LEDebugOut((DEB_ITRACE, "%p OUT UtQueryPictFormat ( %lu )\n",
		NULL, TRUE));

	return(TRUE);
}


#pragma SEG(UtConvertDibToBitmap)
FARINTERNAL_(HBITMAP) UtConvertDibToBitmap(HANDLE hDib)
{
	VDATEHEAP();

	LPBITMAPINFOHEADER lpbmih;
	HDC hdc; // the device context to create the bitmap for
	size_t uBitsOffset; // the offset to where the image begins in the DIB
	HBITMAP hBitmap; // the bitmap we'll return
	
	if (!(lpbmih = (LPBITMAPINFOHEADER)GlobalLock(hDib)))
		return(NULL);

	if (!(hdc = GetDC(NULL))) // Get screen DC.
	{
		// REVIEW: we may have to use the target device of this
		// cache node.
		return(NULL);
	}

	uBitsOffset =  sizeof(BITMAPINFOHEADER) +
			(lpbmih->biClrUsed ? lpbmih->biClrUsed :
			UtPaletteSize(lpbmih));
					
	hBitmap = CreateDIBitmap(hdc, lpbmih, CBM_INIT,
			((BYTE *)lpbmih)+uBitsOffset,
			(LPBITMAPINFO) lpbmih, DIB_RGB_COLORS);

	// release the DC
	ReleaseDC(NULL, hdc);

	return hBitmap;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              UtConvertBitmapToDib, internal
//
//      Synopsis:
//              Creates a Device Independent Bitmap capturing the content of
//              the argument bitmap.
//
//      Arguments:
//              [hBitmap] -- Handle to the bitmap to convert
//              [hpal] -- color palette for the bitmap; may be null for
//                      default stock palette
//
//      Returns:
//              Handle to the DIB.  May be null if any part of the conversion
//              failed.
//
//      Notes:
//
//      History:
//              11/29/93 - ChrisWe - file inspection and cleanup
//              07/18/94 - DavePl  - fixed for 16, 32, bpp bitmaps
//
//-----------------------------------------------------------------------------

FARINTERNAL_(HANDLE) UtConvertBitmapToDib(HBITMAP hBitmap, HPALETTE hpal)
{
    VDATEHEAP();

    HDC hScreenDC;      
    BITMAP bm;                  // bitmap for hBitmap
    UINT uBits;                 // number of color bits for bitmap
    size_t uBmiSize;            // size of bitmap info for the DIB
    size_t biSizeImage;         // temp to hold value in the handle memory
    HANDLE hBmi;                // handle for the new DIB bitmap we'll create
    LPBITMAPINFOHEADER lpBmi;   // pointer to the actual data area for DIB
    HANDLE hDib = NULL;         // the DIB we'll return
    BOOL fSuccess = FALSE;
    DWORD dwCompression;
    BOOL fDeletePalette = FALSE;
    
    if (NULL == hBitmap)
    {
	return(NULL);
    }

    // if no palette provided, use the default

    if (NULL == hpal)
    {
	// This block fixes NTBUG #13029.  The problem is that on a palette
	// device (ie a 256 color video driver), we don't get passed the palette
	// that is used by the DDB.  So, we build the palette based on what
	// is currently selected into the system palette.

	// POSTPPC:
	//
	// We should change the clipboard code that calls this to ask for 
	// CF_PALETTE from the IDataObject that the DDB was obtained from, that
	// way we know we get the colors that the calling app really intended
	HDC hDCGlobal = GetDC(NULL);
	if(!hDCGlobal)
		return NULL;
	int iRasterCaps = GetDeviceCaps(hDCGlobal, RASTERCAPS);

	ReleaseDC(NULL, hDCGlobal);

	if ((iRasterCaps & RC_PALETTE))
	{
	    // Based the following code from the win sdk MYPAL example program.
	    // this creates a palette out of the currently active palette.
            HANDLE hLogPal = GlobalAlloc (GHND,
                                   (sizeof (LOGPALETTE) +
                                   (sizeof (PALETTEENTRY) * (PALETTESIZE))));

	    // if we are OOM, return failure now, because we aren't going
	    // to make it through the allocations later on.

	    if (!hLogPal)
	        return NULL;

	    LPLOGPALETTE pLogPal = (LPLOGPALETTE)GlobalLock (hLogPal);

	    // 0x300 is a magic number required by GDI
            pLogPal->palVersion    = 0x300;
            pLogPal->palNumEntries = PALETTESIZE;

            // fill in intensities for all palette entry colors 
            for (int iLoop = 0; iLoop < PALETTESIZE; iLoop++) 
            {
                *((WORD *) (&pLogPal->palPalEntry[iLoop].peRed)) = (WORD)iLoop;
                pLogPal->palPalEntry[iLoop].peBlue  = 0;
                pLogPal->palPalEntry[iLoop].peFlags = PC_EXPLICIT;
            }

            // create a logical color palette according the information
            // in the LOGPALETTE structure.
            hpal = CreatePalette ((LPLOGPALETTE) pLogPal) ;

	    GlobalUnlock(hLogPal);
	    GlobalFree(hLogPal);

	    if (!hpal)
	        return NULL;

	    fDeletePalette = TRUE;
	}
	else
	{
	    hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
	}
    }
	
    if (NULL == GetObject(hBitmap, sizeof(bm), (LPVOID)&bm))
    {
	return(NULL);
    }


    uBits = bm.bmPlanes * bm.bmBitsPixel;

    // Based on the number of bits per pixel, set up the size
    // of the color table, and the compression type as per the
    // the following table:
    //
    //
    // BPP         Palette Size               Compression   
    // ~~~         ~~~~~~~~~~~~               ~~~~~~~~~~~   
    // 1,2,4,8     2^BPP * sizeof(RGBQUAD)    None          
    // 16, 32      3 * sizeof(DWORD) masks    BI_BITFIELDS  
    // 24          0                          None          


    if (16 == bm.bmBitsPixel || 32 == bm.bmBitsPixel)
    {
	uBmiSize = sizeof(BITMAPINFOHEADER) + 3 * sizeof(DWORD);
	dwCompression = BI_BITFIELDS;
    }
    else if (24 == bm.bmBitsPixel)
    {
	uBmiSize = sizeof(BITMAPINFOHEADER);
	dwCompression = BI_RGB;
    }
    else
    {
	Assert( bm.bmBitsPixel == 1 ||
		bm.bmBitsPixel == 2 ||
		bm.bmBitsPixel == 4 ||
		bm.bmBitsPixel == 8 );


    // VGA and EGA are planar devices on Chicago, so uBits needs
    // to be used when determining the size of the bitmap info +
    // the size of the color table.
	uBmiSize = sizeof(BITMAPINFOHEADER) + 
			(1 << uBits) * sizeof(RGBQUAD);
	dwCompression = BI_RGB;
    }

    // Allocate enough memory to hold the BITMAPINFOHEADER

    hBmi = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD)uBmiSize);
    if (NULL == hBmi)
    {
	return NULL;
    }

    lpBmi = (LPBITMAPINFOHEADER) GlobalLock(hBmi);
    if (NULL == lpBmi)
    {
	GlobalFree(hBmi);
	return NULL;
    }
    
    // Set up any interesting non-zero fields

    lpBmi->biSize        = (LONG)sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth       = (LONG) bm.bmWidth;
    lpBmi->biHeight      = (LONG) bm.bmHeight;
    lpBmi->biPlanes      = 1;
    lpBmi->biBitCount    = (WORD) uBits;
    lpBmi->biCompression = dwCompression;
    
    // Grab the screen DC and set out palette into it
		
    hScreenDC = GetDC(NULL);    
    if (NULL == hScreenDC)
    {
	GlobalUnlock(hBmi);
	goto errRtn;
    }


    // Call GetDIBits with a NULL lpBits parm, so that it will calculate
    // the biSizeImage field for us

    GetDIBits(hScreenDC,                // DC
	      hBitmap,                  // Bitmap handle
	      0,                        // First scan line
	      bm.bmHeight,              // Number of scan lines
	      NULL,                     // Buffer
	      (LPBITMAPINFO)lpBmi,      // BITMAPINFO
	      DIB_RGB_COLORS);

    // If the driver did not fill in the biSizeImage field, make one up
    
    if (0 == lpBmi->biSizeImage)
    {
	LEDebugOut((DEB_WARN, "WARNING: biSizeImage was not computed for us\n"));
   
	lpBmi->biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * uBits) * bm.bmHeight;
    }

    // Realloc the buffer to provide space for the bits.  Use a new handle so
    // that in the failure case we do not lose the exiting handle, which we
    // would need to clean up properly.
    
    biSizeImage = lpBmi->biSizeImage;
    GlobalUnlock(hBmi);

    hDib = GlobalReAlloc(hBmi, (uBmiSize + biSizeImage), GMEM_MOVEABLE);
    if (NULL == hDib)
    {
	goto errRtn;
    }

    // If the realloc succeeded, we can get rid of the old handle

    hBmi = NULL;

    // re-acquire the pointer to the handle
    
    lpBmi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (NULL == lpBmi)
    {
	goto errRtn;
    }

    hpal = SelectPalette(hScreenDC, hpal, FALSE);
    RealizePalette(hScreenDC);

    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits
    
    if (GetDIBits(hScreenDC,                    // DC
		  hBitmap,                      // HBITMAP
		  0,                            // First scan line
		  (WORD)lpBmi->biHeight,        // Count of scan lines
		  ((BYTE FAR *)lpBmi)+uBmiSize, // Bitmap bits
		  (LPBITMAPINFO)lpBmi,          // BITMAPINFOHEADER
		  DIB_RGB_COLORS)               // Palette style
	)
    {
	fSuccess = TRUE;        
    }

    GlobalUnlock(hDib);

errRtn:
    
    if (hScreenDC)
    {
	// Select back the old palette into the screen DC
	
	SelectPalette(hScreenDC, hpal, FALSE);     
	ReleaseDC(NULL, hScreenDC);
    }

    if (fDeletePalette)
    {
        DeleteObject(hpal);
    }

    // If we failed, we need to free up the header and the DIB
    // memory
	
    if (FALSE == fSuccess)
    {
	if (hBmi)
	{
	    GlobalFree(hBmi);
	}
	
	if (hDib)
	{
	    GlobalFree(hDib);
	    hDib = NULL;
	}
    }

    return(hDib);
}

//+----------------------------------------------------------------------------
//
//      Function:
//              UtPaletteSize, internal
//
//      Synopsis:
//              Returns the size of a color table for a palette given the
//              number of bits of color desired.
//
//		Basically, the number of color table entries is:
//
//		    1BPP
//			    1<<1 = 2
//
//		    4BPP
//			    if pbmi->biClrUsed is not zero and is less than 16, then use pbmi->biClrUsed, 
//			    otherwise use 1 << 4 = 16
//
//		    8BPP
//			    if pbmi->biClrUsed is not zero and is less than 256, then use pbmi->biClrUsed, 
//			    otherwise use 1 << 8 = 256
//
//		    16BPP
//			    if pbmi->biCompression is BITFIELDS then there are three color entries, 
//			    otherwise no color entries.
//
//		    24BPP 
//			    pbmi->biCompression must be BI_RGB, there is no color table.
//
//		    32BPP
//			    if pbmi->biCompression is BITFIELDS then there are three color entries, 
//			    otherwise no color entries.
//
//
//		    There is never a case with a color table larger than 256 colors.
//
//      Arguments:
//              [lpHeader] -- ptr to BITMAPINFOHEADER structure
//
//      Returns:
//              Size in bytes of color information
//
//      Notes:
//
//      History:
//              11/29/93 - ChrisWe - change bit count argument to unsigned,
//                      and return value to size_t
//
//              07/18/94 - DavePl - Fixed for 16, 24, 32bpp DIBs
//
//-----------------------------------------------------------------------------


FARINTERNAL_(size_t) UtPaletteSize(BITMAPINFOHEADER * pbmi)
{
DWORD dwSize;
WORD biBitCount = pbmi->biBitCount;


    VDATEHEAP();

    // Compute size of color table information in a DIB.

    if (8 >= biBitCount)
    {	
	if (pbmi->biClrUsed && (pbmi->biClrUsed <= (DWORD) (1 << biBitCount)) )
	{
	    dwSize = pbmi->biClrUsed * sizeof(RGBQUAD);
	}
	else
	{
	    Assert(0 == pbmi->biClrUsed);

	    dwSize = (1 << biBitCount) * sizeof(RGBQUAD);
	}
    }
    else if (BI_BITFIELDS == pbmi->biCompression)
    {
	Assert(24 != biBitCount);  // BI_BITFIELDS should never be set for 24 bit.
	dwSize = 3 * sizeof(RGBQUAD);
    }
    else
    {
	dwSize = 0;
    }

    Assert( (dwSize < 65536) && "Palette size overflows WORD");

    return dwSize;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDibExtents
//
//  Synopsis:   Returns the size of the DIB in HIMETRIC units
//
//  Effects:
//
//  Arguments:  [lpbmi]         -- the BITMAPINFOHEADER for the DIB
//              [plWidth]       -- OUT param for width
//              [plHeight]      -- OUT param for height
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Aug-94 Davepl    Corrected logic
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		LONG FAR* plWidth, LONG FAR* plHeight)
{
    VDATEHEAP();

    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter

    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter))
    {
	HDC hdc;
	hdc = GetDC(NULL);
	
	if(!hdc)
	{
		*plWidth = 0;
		*plHeight = 0;
		return;
	}

	lpbmi->biXPelsPerMeter = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX),
			10000, 254);
	lpbmi->biYPelsPerMeter = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY),
			10000, 254);

	ReleaseDC(NULL, hdc);
    }

    *plWidth = (lpbmi->biWidth * HIMET_PER_METER / lpbmi->biXPelsPerMeter);
    *plHeight= (lpbmi->biHeight * HIMET_PER_METER / lpbmi->biYPelsPerMeter);

    // no longer need this
    #undef HIMET_PER_METER
    
}


#pragma SEG(UtGetClassID)
FARINTERNAL_(BOOL) UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid)
{
	VDATEHEAP();

	LPOLEOBJECT lpOleObj; // IOleObject pointer
	LPPERSIST lpPersist; // IPersist pointer

	// try to ask it as an object
	if (lpUnk->QueryInterface(IID_IOleObject,
			(LPLPVOID)&lpOleObj) == NOERROR)
	{
		lpOleObj->GetUserClassID(lpClsid);
		lpOleObj->Release();
		return(TRUE);
	}       
	
	// try to ask it as a persistent object
	if (lpUnk->QueryInterface(IID_IPersist,
			(LPLPVOID)&lpPersist) == NOERROR)
	{
		lpPersist->GetClassID(lpClsid);
		lpPersist->Release();
		return(TRUE);
	}
	
	*lpClsid = CLSID_NULL;
	return(FALSE);
}


#pragma SEG(UtGetIconData)
FARINTERNAL UtGetIconData(LPDATAOBJECT lpSrcDataObj, REFCLSID rclsid,
		LPFORMATETC lpforetc, LPSTGMEDIUM lpstgmed)
{
	VDATEHEAP();

	CLSID clsid = rclsid;
	
	lpstgmed->tymed = TYMED_NULL;
	lpstgmed->pUnkForRelease = NULL;
	lpstgmed->hGlobal = NULL;
		
	if (lpSrcDataObj)
	{
	    if (lpSrcDataObj->GetData(lpforetc, lpstgmed) == NOERROR)
		    return NOERROR;
	    
	    if (IsEqualCLSID(clsid, CLSID_NULL))
		    UtGetClassID(lpSrcDataObj, &clsid);
	}
	
	// get data from registration database
	lpstgmed->hGlobal = OleGetIconOfClass(clsid, NULL, TRUE);
		
	if (lpstgmed->hGlobal == NULL)
	    return ResultFromScode(E_OUTOFMEMORY);
	else
	    lpstgmed->tymed = TYMED_MFPICT;

	return NOERROR;
}               



// Performs operation like COPY, MOVE, REMOVE etc.. on src, dst storages. The
// caller can specifiy which streams to be operated upon through
// grfAllowedStreams parameter.

STDAPI UtDoStreamOperation(LPSTORAGE pstgSrc, LPSTORAGE pstgDst, int iOpCode,
		DWORD grfAllowedStmTypes)
{
	VDATEHEAP();

	HRESULT error; // error status so far
	IEnumSTATSTG FAR* penumStg; // used to enumerate the storage elements
	ULONG celtFetched; // how many storage elements were fetched
	STATSTG statstg;
		
	// get an enumerator over the source storage
	if (error = pstgSrc->EnumElements(NULL, NULL, NULL, &penumStg))
		return error;
	
	// repeat for every storage
	while(penumStg->Next(1, &statstg, &celtFetched) == NOERROR)
	{
		
		// operate on streams that we're interested in
		if (statstg.type == STGTY_STREAM)
		{
			DWORD stmType;
			
			// find the type of the stream
			// REVIEW, we must have constants for these name
			// prefixes!!!
			switch (statstg.pwcsName[0])
			{
			case '\1':
				stmType = STREAMTYPE_CONTROL;
				break;
				
			case '\2':
				stmType = STREAMTYPE_CACHE;
				break;
				
			case '\3':
				stmType = STREAMTYPE_CONTAINER;
				break;
				
			default:
				stmType = (DWORD)STREAMTYPE_OTHER;
			}
			

			// check whether it should be operated upon
			if (stmType & grfAllowedStmTypes)
			{
				switch(iOpCode)
				{
#ifdef LATER                                    
				case OPCODE_COPY:
					pstgDst->DestroyElement(
							statstg.pwcsName);
					error = pstgSrc->MoveElementTo(
							statstg.pwcsName,
							pstgDst,
							statstg.pwcsName,
							STGMOVE_COPY);
					break;

				case OPCODE_MOVE:
					pstgDst->DestroyElement(
							statstg.pwcsName);
					error = pstgSrc->MoveElementTo(
							statstg.pwcsName,
							pstgDst,
							statstg.pwcsName,
							STGMOVE_MOVE);
					break;

				case OPCODE_EXCLUDEFROMCOPY:
					AssertSz(FALSE, "Not yet implemented");
					break;
					
#endif // LATER
				case OPCODE_REMOVE:
					error = pstgSrc->DestroyElement(
							statstg.pwcsName);
					break;
				
				default:
					AssertSz(FALSE, "Invalid opcode");
					break;
				}
			}
		}
		
		// if the enumerator allocated a new name string, get rid of it
		if (statstg.pwcsName)
			PubMemFree(statstg.pwcsName);

		// quit the enumeration loop if we've hit an error
		if (error != NOERROR)
			break;
	}

	// release the enumerator
	penumStg->Release();

	// return the error state
	return error;
}


FARINTERNAL_(void) UtGetPresStreamName(LPOLESTR lpszName, int iStreamNum)
{
	VDATEHEAP();
	int i; // counts down the digits of iStreamNum

	// count down the last three '0' characters of OLE_PRESENTATION_STREAM
	// the -2 backs us up to the last character (remember the NULL
	// terminator!)
	for(lpszName += sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR) - 2,
			i = 3; i; --lpszName, --i)
	{
		*lpszName = OLESTR("0123456789")[iStreamNum % 10];
		if( iStreamNum > 0 )
		{
			iStreamNum /= 10;
		}
	}
}


FARINTERNAL_(void) UtRemoveExtraOlePresStreams(LPSTORAGE pstg, int iStart)
{
	VDATEHEAP();

	HRESULT hr; // error code from stream deletion
	OLECHAR szName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];
		// space for the stream names

	// if the stream number is invalid, do nothing
	if ((iStart < 0)  || (iStart >= OLE_MAX_PRES_STREAMS))
		return;
	
	// create presentation stream name
	_xstrcpy(szName, OLE_PRESENTATION_STREAM);
	UtGetPresStreamName(szName, iStart);
	
	// for each of these streams that exists, get rid of it
	while((hr = pstg->DestroyElement(szName)) == NOERROR)
	{
		// if we've gotten to the end of the possible streams, quit
		if (++iStart >= OLE_MAX_PRES_STREAMS)
			break;
		
		// Get the next presentation stream name
		UtGetPresStreamName(szName, iStart);
	}       

	// since the only reason these streams should be open, the first
	// failure had better be that the file was not found, and not
	// anything else (such as STG_E_ACCESSDENIED)
	AssertSz(hr == STG_E_FILENOTFOUND,
			"UtRemoveExtraOlePresStreams failure");
}

//+-------------------------------------------------------------------------
//
//  Function:   ConvertPixelsToHIMETRIC
//
//  Synopsis:   Converts a pixel dimension to HIMETRIC units
//
//  Effects:
//
//  Arguments:  [hdcRef]        -- the reference DC
//              [ulPels]        -- dimension in pixel measurement
//              [pulHIMETRIC]   -- OUT param of converted HIMETRIC result
//              [tDimension]    -- indicates XDIMENSION or YDIMENSION of input
//
//  Returns:    S_OK, E_FAIL
//
//  Algorithm:  screen_mm * input_pels        HIMETRICS/
//              ----------------------    *           /    == HIMETRICS
//                    screen_pels                    /mm 
//
//  History:    dd-mmm-yy Author    Comment
//              04-Aug-94 Davepl    Created
//
//  Notes:      We need to know whether the input size is in the X or
//              Y dimension, since the aspect ratio could vary
//
//--------------------------------------------------------------------------

FARINTERNAL ConvertPixelsToHIMETRIC (HDC   hdcRef,
				     ULONG lPels, 
				     ULONG * pulHIMETRIC,
				     DIMENSION tDimension)
{
    VDATEHEAP();
    VDATEPTROUT(pulHIMETRIC, ULONG *);

    // Clear OUT parameter in case of error

    *pulHIMETRIC = 0;
		
    ULONG scrmm  = 0;
    ULONG scrpel = 0;

    const ULONG HIMETRIC_PER_MM = 100;

    // If we weren't given a reference DC, use the screen as a default
    
    BOOL fLocalDC = FALSE;
    if (NULL == hdcRef)
    {
	hdcRef = GetDC(NULL);
	if (hdcRef)
	{
	     fLocalDC = TRUE;
	}
    }
	
    if (hdcRef)
    {
	Assert(tDimension == XDIMENSION || tDimension == YDIMENSION);

	// Get the count of pixels and millimeters for the screen

	if (tDimension == XDIMENSION)
	{
	    scrmm   = GetDeviceCaps(hdcRef, HORZSIZE);
	    scrpel  = GetDeviceCaps(hdcRef, HORZRES);
	}
	else
	{
	    scrmm   = GetDeviceCaps(hdcRef, VERTSIZE);
	    scrpel  = GetDeviceCaps(hdcRef, VERTRES); 
	}
	
	// If we had to create a temporary DC, it can be released now

	if (TRUE == fLocalDC)
	{
	    ReleaseDC(NULL, hdcRef);
	}
    }

    // If we successfully obtained the DC's size and resolution,
    // we can compute the HIMETRIC value.

    if (scrmm && scrpel)
    {
	*pulHIMETRIC = (scrmm * lPels * HIMETRIC_PER_MM) / scrpel;
	
	return S_OK;
    }

    return E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\map_kv.cpp ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <le2int.h>
#pragma SEG(map_kv)

#include "map_kv.h"
#include "valid.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CMapKeyToValue_ctor)
CMapKeyToValue::CMapKeyToValue(UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	VDATEHEAP();

	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

#pragma SEG(CMapKeyToValue_dtor)
CMapKeyToValue::~CMapKeyToValue()
{
	VDATEHEAP();

	ASSERT_VALID(this);
	RemoveAll();
    Assert(m_nCount == 0);
}

#define LOCKTHIS
#define UNLOCKTHIS

#ifdef NEVER
void CMapKeyToValue::LockThis(void)
{
	VDATEHEAP();

    LOCKTHIS;
}

void CMapKeyToValue::UnlockThis(void)
{
	VDATEHEAP();

    UNLOCKTHIS;
}

#endif //NEVER

#pragma SEG(MKVDefaultHashKey)
// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	VDATEHEAP();

	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


#pragma SEG(CMapKeyToValue_InitHashTable)
BOOL CMapKeyToValue::InitHashTable()
{
	VDATEHEAP();

	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)PrivMemAlloc(m_nHashTableSize * 
		sizeof(CAssoc FAR*))) == NULL)
		return FALSE;

	_xmemset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveAll)
void CMapKeyToValue::RemoveAll()
{
	VDATEHEAP();

    LOCKTHIS;

	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		PrivMemFree(m_pHashTable);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;

    ASSERT_VALID(this);
    UNLOCKTHIS;
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

#pragma SEG(CMapKeyToValue_NewAssoc)
CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	VDATEHEAP();

	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


#pragma SEG(CMapKeyToValue_FreeAssoc)
// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	VDATEHEAP();

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


#pragma SEG(CMapKeyToValue_GetAssocAt)
// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	VDATEHEAP();

	if (m_lpfnHashKey)
	    nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


#pragma SEG(CMapKeyToValue_CompareAssocKey)
BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	VDATEHEAP();

	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && _xmemcmp(pKey1, pKey2, cbKey1) == 0;
}


#pragma SEG(CMapKeyToValue_SetAssocKey)
BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	VDATEHEAP();

	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = PrivMemAlloc(cbKey)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	_xmemcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_GetAssocKeyPtr)
// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	VDATEHEAP();

	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


#pragma SEG(CMapKeyToValue_FreeAssocKey)
void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	VDATEHEAP();

	if (m_cbKey == 0)
		PrivMemFree(pAssoc->key.pKey);
}


#pragma SEG(CMapKeyToValue_GetAssocValuePtr)
void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	VDATEHEAP();

	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


#pragma SEG(CMapKeyToValue_GetAssocValue)
void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	VDATEHEAP();

	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	_xmemcpy(pValue, pValueFrom, m_cbValue);
}


#pragma SEG(CMapKeyToValue_SetAssocValue)
void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	VDATEHEAP();

	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		_xmemset(pValueTo, 0, m_cbValue);
	else
		_xmemcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_Lookup)
// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	VDATEHEAP();

    UINT nHash;
    BOOL fFound;

    LOCKTHIS;
    fFound = LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_LookupHKey)
// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	VDATEHEAP();

    BOOL fFound = FALSE;

    LOCKTHIS;

	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		_xmemset(pValue, 0, m_cbValue);
                goto Exit;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
    fFound = TRUE;
Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_LookupAdd)
// lookup and if not found add; returns FALSE only if OOM; if added,
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	VDATEHEAP();

    BOOL fFound;

    LOCKTHIS;

    fFound = Lookup(pKey, cbKey, pValue);
    if (!fFound) // value set to zeros since lookup failed
        fFound = ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);

    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_SetAt)
// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	VDATEHEAP();

	UINT nHash;
    register CAssoc  FAR* pAssoc;
    BOOL fFound = FALSE;

    LOCKTHIS;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			goto Exit;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			goto Exit;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
                SetAssocValue(pAssoc, pValue);

    fFound = TRUE;
Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_SetAtHKey)
// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	VDATEHEAP();

    BOOL fDone = FALSE;
    LOCKTHIS;
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		goto Exit;       // not in map

	ASSERT_VALID(this);

    SetAssocValue(pAssoc, pValue);
    fDone = TRUE;
Exit:
    UNLOCKTHIS;
    return fDone;
}


#pragma SEG(CMapKeyToValue_RemoveKey)
// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	VDATEHEAP();

    BOOL fFound = FALSE;
    UINT i;

    LOCKTHIS;
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		goto Exit;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	if (m_lpfnHashKey)
	    i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	ppAssocPrev = &m_pHashTable[i];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
            fFound = TRUE;
            break;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
Exit:
     UNLOCKTHIS;
     return fFound;
}


#pragma SEG(CMapKeyToValue_RemoveHKey)
// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	VDATEHEAP();

    BOOL fFound = FALSE;

    // REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;

    LOCKTHIS;
    ASSERT_VALID(this);

	if (m_pHashTable == NULL)
        goto Exit;       // nothing in the table

    if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
        goto Exit; // null hkey or bad hash value

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
            fFound = TRUE;
            break;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_GetHKey)
HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	VDATEHEAP();

    UINT nHash;
    HMAPKEY hKey;

    LOCKTHIS;
	ASSERT_VALID(this);

    hKey = (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
    UNLOCKTHIS;
    return hKey;
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

#pragma SEG(CMapKeyToValue_GetNextAssoc)
void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition,
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	VDATEHEAP();

	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		_xmemcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_AssertValid)
void CMapKeyToValue::AssertValid() const
{
	VDATEHEAP();

#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(IsValidReadPtrIn(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	if (m_lpfnHashKey)
	    Assert(IsValidCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(IsValidReadPtrIn(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(IsValidReadPtrIn(m_pBlocks, SizeAssoc() * m_nBlockSize));

#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <le2int.h>
#pragma SEG(plex)

#include "plex.h"
ASSERTDATA

// Collection support
#ifdef OLE_COLL_SEG
#pragma code_seg(OLE_COLL_SEG)
#endif


#pragma SEG(CPlex_Create)  
CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, UINT nMax, UINT cbElement)
{
	VDATEHEAP();

	Assert(nMax > 0 && cbElement > 0);
	CPlex FAR* p = (CPlex FAR*)PrivMemAlloc(sizeof(CPlex) + nMax * cbElement);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

#pragma SEG(CPlex_FreeDataChain)  
void CPlex::FreeDataChain()     // free this one and links
{
	VDATEHEAP();

    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		PrivMemFree(pThis);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\utils.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		utils.cpp
//
//	Contents:
//		general OLE internal utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//              23-Jan-95 t-ScottH  -added Dump method to CSafeRefCount and
//                                   CThreadCheck class
//                                  -added DumpCSafeRefCount API
//		28-Jul-94 alexgo    added object stabilization classes
//              06-May-94 AlexT     Add DVTARGET conversion routines
//		25-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocations.
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//		12/15/93 - ChrisWe - UtDupString has to scale length by
//			sizeof(OLECHAR)
//		12/08/93 - ChrisWe - added necessary casts to GlobalLock() calls
//			resulting from removing bogus GlobalLock() macros in
//			le2int.h
//		11/28/93 - ChrisWe - removed unreferenced define for MAX_STR,
//			formatted UtDupGlobal, UtDupString
//		03/02/92 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(utils)

#include <memory.h>

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

NAME_SEG(Utils)
ASSERTDATA


#pragma SEG(UtDupGlobal)
FARINTERNAL_(HANDLE) UtDupGlobal(HANDLE hsrc, UINT uiFlags)
{
	VDATEHEAP();

	HANDLE hdst = NULL; // the newly create Handle DeSTination
	DWORD dwSize; // the size of the global
#ifndef _MAC
	void FAR *lpsrc; // a pointer to the source memory
	void FAR *lpdst; // a pointer to the destination memory
#endif

	// if no source, nothing to duplicate
	if (!hsrc)
		return(NULL);

#ifdef _MAC
	if (!(hdst = NewHandle(dwSize = GetHandleSize(hsrc))))
		return(NULL);
	BlockMove(*hsrc, *hdst, dwSize);
	return(hdst);
#else
	// if there's no content, do nothing
	if (!(lpsrc = GlobalLock(hsrc)))
		goto errRtn;

	// allocate a new global
	hdst = GlobalAlloc(uiFlags, (dwSize = (ULONG) GlobalSize(hsrc)));

	// if the allocation failed, get out
	if ((hdst == NULL) || ((lpdst = GlobalLock(hdst)) == NULL))
		goto errRtn;

	// copy the content
	_xmemcpy(lpdst, lpsrc, dwSize);

	// unlock the handles
	GlobalUnlock(hsrc);
	GlobalUnlock(hdst);
	return(hdst);

errRtn:
	// unlock the source handle
	GlobalUnlock(hsrc);

	// if we allocated a destination handle, free it
	if (hdst)
		GlobalFree(hdst);

	return(NULL);
#endif // _MAC
}


#pragma SEG(UtDupString)

// copies string using the TASK allocator; returns NULL on out of memory

// often when calling UtDupString, the caller knows the string length.
// a good speed boost would be to call UtDupPtr instead

// lpvIn must be non null
// note: we do an alloc even if dw == 0
FARINTERNAL_(LPVOID) UtDupPtr(LPVOID lpvIn, DWORD dw)
{
    VDATEHEAP();
    LPVOID lpvOut; // the newly allocated ptr

    Assert(lpvIn);	// internal fcn, lpvIn must be non-null
    if ((lpvOut = PubMemAlloc(dw)) != NULL) {
	memcpy(lpvOut, lpvIn, dw);
    }

    return lpvOut;
}

FARINTERNAL_(LPOLESTR) UtDupString(LPCOLESTR lpszIn)
{
    return (LPOLESTR) UtDupPtr( (LPVOID) lpszIn, 
		     (_xstrlen(lpszIn)+1) * sizeof(OLECHAR) );
}



//+-------------------------------------------------------------------------
//
//  Function: 	UtDupStringA
//
//  Synopsis: 	Duplicates an ANSI string using the TASK allocator
//
//  Effects:
//
//  Arguments:	[pszAnsi]	-- the string to duplicate
//
//  Requires:
//
//  Returns:	the newly allocated string duplicate or NULL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

LPSTR UtDupStringA( LPCSTR pszAnsi )
{
    return (LPSTR) UtDupPtr( (LPVOID) pszAnsi, 
		     strlen(pszAnsi) + 1 );
}

	

#pragma SEG(UtCopyTargetDevice)
FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd)
{
    // if nothing to copy, return
    if (ptd == NULL)
	return(NULL);

    return (DVTARGETDEVICE FAR*) UtDupPtr((LPVOID) ptd, ptd->tdSize);
}


#pragma SEG(UtCopyFormatEtc)
FARINTERNAL_(BOOL) UtCopyFormatEtc(FORMATETC FAR* pFetcIn,
		FORMATETC FAR* pFetcCopy)
{
	VDATEHEAP();

	// copy structures
	*pFetcCopy = *pFetcIn;

	if (pFetcIn->ptd == NULL) {
	    // all done, return true because the copy succeeded
	    return TRUE;
	}

	// create a copy of the td descriptor, which is allocated
	pFetcCopy->ptd = UtCopyTargetDevice(pFetcIn->ptd);

	// return TRUE if we copied the data if we were supposed to
	return(pFetcCopy->ptd != NULL);
}


#pragma SEG(UtCompareFormatEtc)
FARINTERNAL_(int) UtCompareFormatEtc(FORMATETC FAR* pFetcLeft,
		FORMATETC FAR* pFetcRight)
{
	VDATEHEAP();

	int iResult; // indicates whether the match is exact or partial

	// if the clipboard formats are different, there is no match
	if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
		return(UTCMPFETC_NEQ);

	// if the target devices don't match, there is no match
	if (!UtCompareTargetDevice(pFetcLeft->ptd, pFetcRight->ptd))
		return(UTCMPFETC_NEQ);

	// compare the aspects for the two formats
	if (pFetcLeft->dwAspect == pFetcRight->dwAspect)
	{
		// the match is exact
		iResult = UTCMPFETC_EQ;
	}
	else if ((pFetcLeft->dwAspect & ~pFetcRight->dwAspect) != 0)
	{
		// left not subset of aspects of right; not equal
		return(UTCMPFETC_NEQ);
	}
	else
	{
		// left aspects are a subset of the right aspects
		iResult = UTCMPFETC_PARTIAL;
	}

	// if we get here, iResult is set to one of UPCMPFETC_EQ or _PARTIAL

	// compare the media for the two formats
	if (pFetcLeft->tymed == pFetcRight->tymed)
	{
		// same medium flags; do not change value of iResult
		;
	}
	else if ((pFetcLeft->tymed & ~pFetcRight->tymed) != 0)
	{
		// left not subset of medium flags of right; not equal
		return(UTCMPFETC_NEQ);
	}
	else
	{
		// left subset of right
		iResult = UTCMPFETC_PARTIAL;
	}

	return(iResult);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtCompareTargetDevice
//
//  Synopsis:   Compare two DVTARGETDEVICEs
//
//  Arguments:  [ptdLeft] -- comparand
//              [ptdRight] -- comparee
//
//  Returns:    TRUE iff the two target devices are equivalent
//
//  Algorithm:
//
//  History:    09-May-94 AlexT     Rewrote to do more than just a binary
//                                  compare
//
//  Notes:
//
//--------------------------------------------------------------------------

#define UT_DM_COMPARISON_FIELDS (DM_ORIENTATION  |  \
                                 DM_PAPERSIZE    |  \
                                 DM_PAPERLENGTH  |  \
                                 DM_PAPERWIDTH   |  \
                                 DM_SCALE        |  \
                                 DM_PRINTQUALITY |  \
                                 DM_COLOR)

#pragma SEG(UtCompareTargetDevice)
FARINTERNAL_(BOOL) UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft,
                                         DVTARGETDEVICE FAR* ptdRight)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtCompareTargetDevice (%p, %p)\n",
		NULL, ptdLeft, ptdRight));

    VDATEHEAP();

    BOOL bRet = FALSE;  //  More often than not we return FALSE

    //  We use a do-while(FALSE) loop so that we can break out to common
    //  return code at the end (the joys of tracing)
    do
    {
        // if the addresses of the two target device descriptors are the same,
        // then they must be the same.  Note this handles the two NULL case.
        if (ptdLeft == ptdRight)
        {
            bRet = TRUE;
            break;
        }

        // if either td is NULL, can't compare them
        if ((ptdRight == NULL) || (ptdLeft == NULL))
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        // we ignore device name (My Printer vs. Your Printer doesn't matter)

        // check driver name
        if (ptdLeft->tdDriverNameOffset != 0)
        {
            if (ptdRight->tdDriverNameOffset == 0)
            {
                //  Left driver exists, but no right driver
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }

            //  Both drivers exist
            if (_xstrcmp((LPOLESTR)((BYTE*)ptdLeft +
                                    ptdLeft->tdDriverNameOffset),
                         (LPOLESTR)((BYTE*)ptdRight +
                                    ptdRight->tdDriverNameOffset)) != 0)
            {
                //  Driver names don't match
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }
        }
        else if (ptdRight->tdDriverNameOffset != 0)
        {
            //  Left driver doesn't exist, but right driver does
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        // we ignore port name

        if (0 == ptdLeft->tdExtDevmodeOffset)
        {
            if (0 == ptdRight->tdExtDevmodeOffset)
            {
                //  Nothing left to compare
                bRet = TRUE;
                break;
            }
            else
            {
                //  Only one Devmode
                AssertSz(bRet == FALSE, "bRet not set correctly");
                break;
            }
        }
        else if (0 == ptdRight->tdExtDevmodeOffset)
        {
            //  Only one Devmode exists
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        //  Both TDs have Devmodes
        DEVMODEW *pdmLeft, *pdmRight;

        pdmLeft = (DEVMODEW *)((BYTE*)ptdLeft +
                    ptdLeft->tdExtDevmodeOffset);
        pdmRight = (DEVMODEW *)((BYTE*)ptdRight +
                     ptdRight->tdExtDevmodeOffset);

        //  Check driver version
        if (pdmLeft->dmDriverVersion != pdmRight->dmDriverVersion)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        //  For a successful match, both device mode must specify the same
        //  values for each of the following:
        //    DM_ORIENTATION, DM_PAPERSIZE, DM_PAPERLENGTH.
        //    DM_PAPERWIDTH, DM_SCALE, DM_PRINTQUALITY, DM_COLOR

        if ((pdmLeft->dmFields & UT_DM_COMPARISON_FIELDS) ^
            (pdmRight->dmFields & UT_DM_COMPARISON_FIELDS))
        {
            //  Only one of pdmLeft and pdmRight specify at least one
            //  of the comparison fields
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_ORIENTATION) &&
            pdmLeft->dmOrientation != pdmRight->dmOrientation)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERSIZE) &&
            pdmLeft->dmPaperSize != pdmRight->dmPaperSize)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERLENGTH) &&
            pdmLeft->dmPaperLength != pdmRight->dmPaperLength)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PAPERWIDTH) &&
            pdmLeft->dmPaperWidth != pdmRight->dmPaperWidth)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_SCALE) &&
            pdmLeft->dmScale != pdmRight->dmScale)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_PRINTQUALITY) &&
            pdmLeft->dmPrintQuality != pdmRight->dmPrintQuality)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        if ((pdmLeft->dmFields & DM_COLOR) &&
            pdmLeft->dmColor != pdmRight->dmColor)
        {
            AssertSz(bRet == FALSE, "bRet not set correctly");
            break;
        }

        bRet = TRUE;
    } while (FALSE);

    LEDebugOut((DEB_ITRACE, "%p OUT UtCompareTargetDevice (%d)\n",
		NULL, bRet));

    return(bRet);
}

#pragma SEG(UtCopyStatData)
FARINTERNAL_(BOOL) UtCopyStatData(STATDATA FAR* pSDIn, STATDATA FAR* pSDCopy)
{
	VDATEHEAP();

	// copy structures
	*pSDCopy = *pSDIn;

	// create copy of target device description (which is allocated)
	pSDCopy->formatetc.ptd = UtCopyTargetDevice(pSDIn->formatetc.ptd);

	// if there is an advise sink, account for the copy/reference
	if (pSDCopy->pAdvSink != NULL)
		pSDCopy->pAdvSink->AddRef();

	// return TRUE if the copy was done if it was required
	return((pSDCopy->formatetc.ptd != NULL) ==
			(pSDIn->formatetc.ptd != NULL));
}

//+-------------------------------------------------------------------------
//
//  Function: 	UtReleaseStatData
//
//  Synopsis: 	nulls && releases members of the given stat data structure
//
//  Effects:
//
//  Arguments:	pStatData
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	We copy the data first and NULL out the stat data
//		because the Release on the Advise sink could cause us
//		to be re-entered.
//
//  History:    dd-mmm-yy Author    Comment
// 		20-Jul-94 alexgo    made safe for OLE sytle re-entrancy
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(void) UtReleaseStatData(STATDATA FAR* pStatData)
{
	STATDATA	sd;

	VDATEHEAP();

	sd = *pStatData;

	// zero out the original before doing any work

	_xmemset(pStatData, 0, sizeof(STATDATA));

	// if there's a target device description, free it
	if (sd.formatetc.ptd != NULL)
	{
		PubMemFree(sd.formatetc.ptd);
	}

	if( sd.pAdvSink )
	{
		sd.pAdvSink->Release();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:	UtCreateStorageOnHGlobal
//
//  Synopsis:	creates a storage on top of an HGlobal
//
//  Effects:
//
//  Arguments: 	[hGlobal]	-- the memory on which to create the
//				   storage
//		[fDeleteOnRelease]	-- if TRUE, then delete the hglobal
//					   once the storage is released.
//		[ppStg]		-- where to put the storage interface
//		[ppILockBytes]	-- where to put the underlying ILockBytes,
//				   maybe NULL.  The ILB must be released.

//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create an ILockBytes on HGLOBAL and then create the docfile
//		on top of the ILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtCreateStorageOnHGlobal( HGLOBAL hGlobal, BOOL fDeleteOnRelease,
		IStorage **ppStg, ILockBytes **ppILockBytes )
{
	HRESULT		hresult;
	ILockBytes *	pLockBytes;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtCreateStorageOnHGlobal ( %lx , %p )"
		"\n", NULL, hGlobal, ppStg));

	hresult = CreateILockBytesOnHGlobal(hGlobal, fDeleteOnRelease,
			&pLockBytes);

	if( hresult == NOERROR )
	{
		hresult = StgCreateDocfileOnILockBytes( pLockBytes,
				 STGM_CREATE | STGM_SALL, 0, ppStg);

		// no matter what the result of StgCreate is, we want
		// to release the LockBytes.  If hresult == NOERROR, then
		// the final release to the LockBytes will come when the
		// created storage is released.
	}

	if( ppILockBytes )
	{
		*ppILockBytes = pLockBytes;
	}
	else if (pLockBytes)
	{
		// we release here so the final release of the storage
		// will be the final release of the lockbytes
		pLockBytes->Release();
	}


	LEDebugOut((DEB_ITRACE, "%p OUT UtCreateStorageOnHGlobal ( %lx ) "
		"[ %p ]\n", NULL, hresult, *ppStg));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	UtGetTempFileName
//
//  Synopsis:	retrieves a temporary filename (for use in GetData, TYMED_FILE
//		and temporary docfiles)
//
//  Effects:
//
//  Arguments: 	[pszPrefix]	-- prefix of the temp filename
//		[pszTempName]	-- buffer that will receive the temp path.
//				   must be MAX_PATH or greater.
//
//  Requires:
//
//  Returns:	HRESULT;
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tries to get a file in the temp directory, failing that, in
//		the windows directory
//
//  History:    dd-mmm-yy Author    Comment
// 		07-Apr-94 alexgo    author
//
//  Notes: 	OPTIMIZATION: The storage code has a similar peice of code
//		for generating temporary docfiles.  We may want to use this
//		routine there as well.
//
//--------------------------------------------------------------------------

HRESULT	UtGetTempFileName( LPOLESTR pszPrefix, LPOLESTR pszTempName )
{
	HRESULT		hresult = NOERROR;
	OLECHAR		szPath[MAX_PATH + 1];

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtGetTempFilename ( \"%ws\" , "
		"\"%ws\")\n", NULL, pszPrefix, pszTempName));

	if( !GetTempPath(MAX_PATH, szPath) )
	{
		LEDebugOut((DEB_WARN, "WARNING: GetTempPath failed!\n"));
		if( !GetWindowsDirectory(szPath, MAX_PATH) )
		{
			LEDebugOut((DEB_WARN, "WARNING: GetWindowsDirectory"
				" failed!!\n"));
			hresult = ResultFromScode(E_FAIL);
			goto errRtn;
		}
	}

	if( !GetTempFileName( szPath, pszPrefix, 0, pszTempName ) )
	{
		LEDebugOut((DEB_WARN, "WARNING: GetTempFileName failed!!\n"));
		hresult = ResultFromScode(E_FAIL);
	}

errRtn:
	LEDebugOut((DEB_ITRACE, "%p OUT UtGetTempFilename ( %lx ) "
		"[ \"%ws\" ]\n", NULL, hresult, pszTempName));

	return hresult;
}


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHGLOBALtoStm, internal
//
//	Synopsis:
//		Write the contents of an HGLOBAL to a stream
//
//	Arguments:
//		[hdata] -- handle to the data to write out
//		[dwSize] -- size of the data to write out
//		[pstm] -- stream to write the data out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		04/10/94 - AlexGo  - added call tracing, moved from convert.cpp
//				     to utils.cpp, misc improvements.
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

HRESULT UtHGLOBALtoStm(HGLOBAL hGlobalSrc, DWORD dwSize, LPSTREAM pstm)
{
	HRESULT 	hresult = NOERROR;
	void *		lpdata;
	ULONG		cbWritten;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoStm ( %lx , %lu , %p )\n",
		NULL, hGlobalSrc, dwSize, pstm));
	
	lpdata = GlobalLock(hGlobalSrc);
	
	if (lpdata)
	{
		hresult = pstm->Write(lpdata, dwSize, &cbWritten);

		// if we didn't write enough data, then it's an error
		// condition for us.

		if( hresult == NOERROR && cbWritten != dwSize )
		{
			hresult = ResultFromScode(E_FAIL);
		}

		if( hresult == NOERROR )
		{
			// this call isn't strictly necessary, but may
			// be useful for compacting the size of presentations
			// stored on disk (when called by the presentation
			// code)
			hresult = StSetSize(pstm, 0, TRUE);
		}

		GlobalUnlock(hGlobalSrc);
	}


	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoStm ( %lx )\n", NULL,
		hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoHGLOBAL, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target HGLOBAL
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[hGlobalTgt] 	-- the target HGLOBAL
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the target hglobal is not large
//		enough
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoHGLOBAL( HGLOBAL hGlobalSrc, DWORD dwSize,
		HGLOBAL hGlobalTgt)
{
	DWORD	cbTarget;
	void *	pvSrc;
	void * 	pvTgt;
	HRESULT	hresult = ResultFromScode(E_OUTOFMEMORY);

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoHGLOBAL ( %lx , %lu , "
		"%lx )\n", NULL, hGlobalSrc, dwSize, hGlobalTgt));

	cbTarget = (ULONG) GlobalSize(hGlobalTgt);

	if( cbTarget == 0 || cbTarget < dwSize )
	{
		hresult = ResultFromScode(E_FAIL);
		goto errRtn;
	}

	pvSrc = GlobalLock(hGlobalSrc);

	if( pvSrc )
	{
 		pvTgt = GlobalLock(hGlobalTgt);

		if( pvTgt )
		{
			_xmemcpy( pvTgt, pvSrc, dwSize);

			GlobalUnlock(hGlobalTgt);
			hresult = NOERROR;
		}

		GlobalUnlock(hGlobalSrc);
	}

errRtn:
	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoHGLOBAL ( %lx )\n",
		NULL, hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoStorage, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target storage
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[pStgTgt] 	-- the target storage
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the source HGLOBAL did not
//		originally have a storage layered on top of it.
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoStorage( HGLOBAL hGlobalSrc, IStorage *pStgTgt)
{
	HRESULT		hresult;
	ILockBytes *	pLockBytes = NULL;
	IStorage *	pStgSrc;
	ULONG		cRefs;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoStroage ( %lx , %p )"
		"\n", NULL, hGlobalSrc, pStgTgt));

	hresult = CreateILockBytesOnHGlobal(hGlobalSrc,
			FALSE /*fDeleteOnRelease*/, &pLockBytes);

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	// now we make sure that the hglobal really has a storage
	// in it

	if( StgIsStorageILockBytes(pLockBytes) != NOERROR )
	{
		hresult = ResultFromScode(E_FAIL);
		goto errRtn;
	}

	hresult = StgOpenStorageOnILockBytes( pLockBytes, NULL,
			 STGM_SALL, NULL, 0, &pStgSrc);

	if( hresult == NOERROR )
	{
		hresult = pStgSrc->CopyTo( 0, NULL, NULL, pStgTgt);

		// no matter what the result, we want to free the
		// source storage

		pStgSrc->Release();
	}

errRtn:

	if( pLockBytes )
	{
		cRefs = pLockBytes->Release();
		Assert(cRefs == 0);
	}
		
	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoStorage ( %lx ) "
		"[ %p ]\n", NULL, hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoFile, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target file
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[pszFileName] 	-- the target file
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:	if the file already exists, we simply append to it
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoFile( HGLOBAL hGlobalSrc, DWORD dwSize,
		LPCOLESTR pszFileName)
{
	HRESULT		hresult;
	HANDLE		hFile;
	void *		pvSrc;
	DWORD		cbWritten;

	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtHGLOBALtoFile ( %lx , %lu , "
		"\"%ws\" )\n", NULL, hGlobalSrc, dwSize, pszFileName));


	hresult = ResultFromScode(E_NOTIMPL);
	(void)hFile;
	(void)pvSrc;
	(void)cbWritten;
	

// this doesn't compile for chicago [, but we don't need this anyway]
#ifdef LATER
	pvSrc = GlobalLock(hGlobalSrc);

	if( !pvSrc )
	{
		hresult = ResultFromScode(E_OUTOFMEMORY);
		goto errRtn;
	}

	// open the file for append, creating if it doesn't already exist.

	hFile = CreateFile( pszFileName, GENERIC_WRITE, 0, NULL,
			OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

	if( hFile != INVALID_HANDLE_VALUE )
	{
		if( !WriteFile( hFile, pvSrc, dwSize, &cbWritten, NULL) )
		{
			LEDebugOut((DEB_WARN, "WARNING: WriteFile failed!\n"));
			hresult = HRESULT_FROM_WIN32(GetLastError());
		}

		if( cbWritten != dwSize && hresult == NOERROR )
		{
			// still an error if we didn't write all the bytes
			// we wanted
			hresult = ResultFromScode(E_FAIL);
		}

		if( !CloseHandle(hFile) )
		{
			AssertSz(0, "CloseFile failed! Should not happen!");

			// if there's no error yet, set the error
			if( hresult == NOERROR )
			{
				hresult = HRESULT_FROM_WIN32(GetLastError());
			}
		}
	}
	else
	{
		LEDebugOut((DEB_WARN, "WARNING: CreateFile failed!!\n"));
		hresult = HRESULT_FROM_WIN32(GetLastError());
	}

	GlobalUnlock(hGlobalSrc);

errRtn:

#endif // LATER


	LEDebugOut((DEB_ITRACE, "%p OUT UtHGLOBALtoFile ( %lx )\n", NULL,
		hresult));

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd16Info
//
//  Synopsis:   Fills in pdvdtInfo
//
//  Arguments:  [pdvtd16] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtdInfo
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//              10-Jul-94 AlexT     Make sure DEVMODE ends up DWORD aligned
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

//  We can't use sizeof(DV_TARGETDEVICE) because MIDL keeps flipping back
//  and forth over whether to make the embedded array size 0 or size 1

#define UT_DVTARGETDEVICE_SIZE  (sizeof(DWORD) + sizeof(WORD) * 4)

//                      tdSize           td...Offset's
#define DVTD_MINSIZE    (sizeof(DWORD) + 4 * sizeof(WORD))

extern "C" HRESULT UtGetDvtd16Info(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                   PDVTDINFO pdvtdInfo)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtGetDvtd16Info (%p, %p)\n",
		NULL, pdvtd16, pdvtdInfo));

    DEVMODEA UNALIGNED *pdm16;

    //  Let's do some sanity checking on the incoming DVTARGETDEVICE
    if (pdvtd16->tdSize < DVTD_MINSIZE)
    {
        LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdSize\n"));
        return(E_INVALIDARG);
    }

    //  We need at least a DVTARGETDEVICE
    pdvtdInfo->cbConvertSize = UT_DVTARGETDEVICE_SIZE;

    //  Compute required size for Drv, Device, Port names
    if (pdvtd16->tdDriverNameOffset != 0)
    {
        if (pdvtd16->tdDriverNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdDriverNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdDriverNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDrvName = strlen((char *)pdvtd16 +
                                       pdvtd16->tdDriverNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDrvName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDrvName = 0;
    }

    if (pdvtd16->tdDeviceNameOffset != 0)
    {
        if (pdvtd16->tdDeviceNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdDeviceNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdDeviceNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDevName = strlen((char *)pdvtd16 +
                                       pdvtd16->tdDeviceNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDevName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDevName = 0;
    }

    if (pdvtd16->tdPortNameOffset != 0)
    {
        if (pdvtd16->tdPortNameOffset > pdvtd16->tdSize ||
            pdvtd16->tdPortNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdPortNameOffset\n"));
            return(E_INVALIDARG);
        }


        pdvtdInfo->cchPortName = strlen((char *)pdvtd16 +
                                        pdvtd16->tdPortNameOffset) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchPortName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchPortName = 0;
    }

    if (pdvtd16->tdExtDevmodeOffset != 0)
    {
        if (pdvtd16->tdExtDevmodeOffset > pdvtd16->tdSize ||
            pdvtd16->tdExtDevmodeOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd16Info - bad pdvtd16->tdExtDevmodeOffset\n"));
            return(E_INVALIDARG);
        }

        //  The DEVMODEW structure needs to be DWORD aligned, so here we make
        //  sure cbConvertSize (which will be the beginning of DEVMODEW) is
        //  DWORD aligned
        pdvtdInfo->cbConvertSize += (sizeof(DWORD) - 1);
        pdvtdInfo->cbConvertSize &= ~(sizeof(DWORD) - 1);

        //  Now compute the space needed for the DEVMODE
        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16 + pdvtd16->tdExtDevmodeOffset);

        //  We start with a basic DEVMODEW
        pdvtdInfo->cbConvertSize += sizeof(DEVMODEW);

        if (pdm16->dmSize > sizeof(DEVMODEA))
        {
            //  The input DEVMODEA is larger than a standard DEVMODEA, so
            //  add space for the extra amount
            pdvtdInfo->cbConvertSize += pdm16->dmSize - sizeof(DEVMODEA);
        }

        //  Finally we account for the extra driver data
        pdvtdInfo->cbConvertSize += pdm16->dmDriverExtra;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT UtGetDvtd16Info (%lx) [%ld]\n",
		NULL, S_OK, pdvtdInfo->cbConvertSize));

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtConvertDvtd16toDvtd32
//
//  Synopsis:   Fills in a 32-bit DVTARGETDEVICE based on a 16-bit
//              DVTARGETDEVICE
//
//  Arguments:  [pdvtd16] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//              [pdvtd32] -- pointer to UNICODE DVTARGETDEVICE
//
//  Requires:   pdvtdInfo must have been filled in by a previous call to
//              UtGetDvtd16Info
//
//              pdvtd32 must be at least pdvtdInfo->cbConvertSize bytes long
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtd32
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//              10-Jul-94 AlexT     Make sure DEVMODEW is DWORD aligned
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtConvertDvtd16toDvtd32(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE *pdvtd32)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtConvertDvtd16toDvtd32 (%p, %p, %p)\n",
		NULL, pdvtd16, pdvtdInfo, pdvtd32));

#if DBG==1
    {
        //  Verify the passed in pdvtdInfo is what we expect
        DVTDINFO dbgDvtdInfo;
        Assert(UtGetDvtd16Info(pdvtd16, &dbgDvtdInfo) == S_OK);
        Assert(0 == memcmp(&dbgDvtdInfo, pdvtdInfo, sizeof(DVTDINFO)));
    }
#endif

    HRESULT hr = S_OK;
    USHORT cbOffset;
    int cchWritten;
    DEVMODEA UNALIGNED *pdm16;
    DEVMODEW *pdm32;
	UINT	nCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    memset(pdvtd32, 0, pdvtdInfo->cbConvertSize);

    cbOffset = UT_DVTARGETDEVICE_SIZE;

    if (pdvtdInfo->cchDrvName != 0)
    {
        pdvtd32->tdDriverNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        CP_ACP, 0,
                        (char *)pdvtd16+pdvtd16->tdDriverNameOffset,
                        pdvtdInfo->cchDrvName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdDriverNameOffset),
                        pdvtdInfo->cchDrvName);
        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset += (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtdInfo->cchDevName != 0)
    {
        pdvtd32->tdDeviceNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        nCodePage, 0,
                        (char *)pdvtd16 + pdvtd16->tdDeviceNameOffset,
                        pdvtdInfo->cchDevName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdDeviceNameOffset),
                        pdvtdInfo->cchDevName);

        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset += (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtdInfo->cchPortName != 0)
    {
        pdvtd32->tdPortNameOffset = cbOffset;
        cchWritten = MultiByteToWideChar(
                        nCodePage, 0,
                        (char *)pdvtd16 + pdvtd16->tdPortNameOffset,
                        pdvtdInfo->cchPortName,
                        (LPOLESTR)((BYTE *)pdvtd32 +
                            pdvtd32->tdPortNameOffset),
                        pdvtdInfo->cchPortName);
        if (0 == cchWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }

        cbOffset += (USHORT)(cchWritten * sizeof(WCHAR));
    }

    if (pdvtd16->tdExtDevmodeOffset != 0)
    {
        //  Make sure DEVMODEW will be DWORD aligned
        cbOffset += (sizeof(DWORD) - 1);
        cbOffset &= ~(sizeof(DWORD) - 1);

        pdvtd32->tdExtDevmodeOffset = cbOffset;
        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16+pdvtd16->tdExtDevmodeOffset);

        //  The incoming DEVMODEA can have one of the following two forms:
        //
        //  1)  32 chars for dmDeviceName
        //      m bytes worth of fixed size data (where m <= 38)
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 32+m
        //
        //  2)  32 chars for dmDeviceName
        //      38 bytes worth of fixed size data
        //      32 chars for dmFormName
        //      m additional bytes of fixed size data
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 32 + 38 + 32 + m
        //
        //  We have to be careful to translate the dmFormName string, if it
        //  exists

        //  First, translate the dmDeviceName
        if (MultiByteToWideChar(nCodePage, 0, (char *)pdm16->dmDeviceName,
                                CCHDEVICENAME,
                                pdm32->dmDeviceName, CCHDEVICENAME) == 0)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }


        //  Now check to see if we have a dmFormName to translate
        if (pdm16->dmSize <= FIELD_OFFSET(DEVMODEA, dmFormName))
        {
            //  No dmFormName, just copy the remaining m bytes
            memcpy(&pdm32->dmSpecVersion, &pdm16->dmSpecVersion,
                   pdm16->dmSize - CCHDEVICENAME);
        }
        else
        {
            //  There is a dmFormName;  copy the bytes between the names first
            memcpy(&pdm32->dmSpecVersion, &pdm16->dmSpecVersion,
                   FIELD_OFFSET(DEVMODEA, dmFormName) -
                    FIELD_OFFSET(DEVMODEA, dmSpecVersion));

            //  Now translate the dmFormName
            if (MultiByteToWideChar(CP_ACP, 0, (char *)pdm16->dmFormName,
                                    CCHFORMNAME,
                                    pdm32->dmFormName, CCHFORMNAME) == 0)
            {
                hr = E_UNEXPECTED;
                goto ErrRtn;
            }

            //  Now copy the remaining m bytes

            if (pdm16->dmSize > FIELD_OFFSET(DEVMODEA, dmLogPixels))
            {
                memcpy(&pdm32->dmLogPixels, &pdm16->dmLogPixels,
                       pdm16->dmSize - FIELD_OFFSET(DEVMODEA, dmLogPixels));
            }
        }

        pdm32->dmSize = sizeof(DEVMODEW);
        if (pdm16->dmSize > sizeof(DEVMODEA))
        {
            pdm32->dmSize += pdm16->dmSize - sizeof(DEVMODEA);
        }

        //  Copy the extra driver bytes
        memcpy(((BYTE*)pdm32) + pdm32->dmSize, ((BYTE*)pdm16) + pdm16->dmSize,
               pdm16->dmDriverExtra);

        cbOffset += pdm32->dmSize + pdm32->dmDriverExtra;
    }

    //  Finally, set pdvtd32's size
    pdvtd32->tdSize = cbOffset;


ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT UtConvertDvtd16toDvtd32 (%lx)\n",
                            NULL, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd32Info
//
//  Synopsis:   Fills in pdvdtInfo
//
//  Arguments:  [pdvtd32] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtdInfo
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//
//  Notes:      Do we need to do any error checking on the strings?
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtGetDvtd32Info(DVTARGETDEVICE const *pdvtd32, PDVTDINFO pdvtdInfo)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtGetDvtd32Info (%p, %p)\n",
		NULL, pdvtd32, pdvtdInfo));

    DEVMODEW *pdm32;

    //  Let's do some sanity checking on the incoming DVTARGETDEVICE
    if (pdvtd32->tdSize < DVTD_MINSIZE)
    {
        LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdSize\n"));
        return(E_INVALIDARG);
    }

    pdvtdInfo->cbConvertSize = UT_DVTARGETDEVICE_SIZE;

    //  Compute required size for Drv, Device, Port names
    if (pdvtd32->tdDriverNameOffset != 0)
    {
        if (pdvtd32->tdDriverNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdDriverNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdDriverNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDrvName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                       pdvtd32->tdDriverNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDrvName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDrvName = 0;
    }

    if (pdvtd32->tdDeviceNameOffset != 0)
    {
        if (pdvtd32->tdDeviceNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdDeviceNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdDeviceNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchDevName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                       pdvtd32->tdDeviceNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchDevName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchDevName = 0;
    }

    if (pdvtd32->tdPortNameOffset != 0)
    {
        if (pdvtd32->tdPortNameOffset > pdvtd32->tdSize ||
            pdvtd32->tdPortNameOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdPortNameOffset\n"));
            return(E_INVALIDARG);
        }

        pdvtdInfo->cchPortName = lstrlenW((WCHAR *)((BYTE *)pdvtd32 +
                                        pdvtd32->tdPortNameOffset)) + 1;

        pdvtdInfo->cbConvertSize += pdvtdInfo->cchPortName * sizeof(WCHAR);
    }
    else
    {
        pdvtdInfo->cchPortName = 0;
    }

    //  Now compute the space needed for the DEVMODE
    if (pdvtd32->tdExtDevmodeOffset != 0)
    {
        if (pdvtd32->tdExtDevmodeOffset > pdvtd32->tdSize ||
            pdvtd32->tdExtDevmodeOffset < DVTD_MINSIZE)
        {
            //  Offset can't be larger than size or fall within base
            //  structure
            LEDebugOut((DEB_WARN, "UtGetDvtd32Info - bad pdvtd32->tdExtDevmodeOffset\n"));
            return(E_INVALIDARG);
        }

        //  The DEVMODEA structure needs to be DWORD aligned, so here we make
        //  sure cbConvertSize (which will be the beginning of DEVMODEA) is
        //  DWORD aligned
        pdvtdInfo->cbConvertSize += (sizeof(DWORD) - 1);
        pdvtdInfo->cbConvertSize &= ~(sizeof(DWORD) - 1);

        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        //  We start with a basic DEVMODEA
        pdvtdInfo->cbConvertSize += sizeof(DEVMODEA);

        if (pdm32->dmSize > sizeof(DEVMODEW))
        {
            //  The input DEVMODEW is larger than a standard DEVMODEW, so
            //  add space for the extra amount
            pdvtdInfo->cbConvertSize += pdm32->dmSize - sizeof(DEVMODEW);
        }

        //  Finally we account for the extra driver data
        pdvtdInfo->cbConvertSize += pdm32->dmDriverExtra;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT UtGetDvtd32Info (%lx) [%ld]\n",
		NULL, S_OK, pdvtdInfo->cbConvertSize));

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtConvertDvtd32toDvtd16
//
//  Synopsis:   Fills in a 32-bit DVTARGETDEVICE based on a 16-bit
//              DVTARGETDEVICE
//
//  Arguments:  [pdvtd32] -- pointer to ANSI DVTARGETDEVICE
//              [pdvtdInfo] -- pointer to DVDT_INFO block
//              [pdvtd16] -- pointer to UNICODE DVTARGETDEVICE
//
//  Requires:   pdvtdInfo must have been filled in by a previous call to
//              UtGetDvtd32Info
//
//              pdvtd16 must be at least pdvtdInfo->cbSizeConvert bytes long
//
//  Returns:    HRESULT
//
//  Modifies:   pdvtd16
//
//  Algorithm:
//
//  History:    06-May-94 AlexT     Created from DrewB's original functions
//
//  Notes:      Do we need to do any error checking on the strings?
//
//              On Chicago we'll have to provide helper code to do this
//              translation
//
//--------------------------------------------------------------------------

extern "C" HRESULT UtConvertDvtd32toDvtd16(DVTARGETDEVICE const *pdvtd32,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE UNALIGNED *pdvtd16)
{
    LEDebugOut((DEB_ITRACE, "%p _IN UtConvertDvtd32toDvtd16 (%p, %p, %p)\n",
		NULL, pdvtd32, pdvtdInfo, pdvtd16));

#if DBG==1
    {
        //  Verify the passed in pdvtdInfo is what we expect
        DVTDINFO dbgDvtdInfo;
        Assert(UtGetDvtd32Info(pdvtd32, &dbgDvtdInfo) == S_OK);
        Assert(0 == memcmp(&dbgDvtdInfo, pdvtdInfo, sizeof(DVTDINFO)));
    }
#endif

    HRESULT hr = S_OK;
    USHORT cbOffset;
    int cbWritten;
    DEVMODEA UNALIGNED *pdm16;
    DEVMODEW *pdm32;
	UINT	nCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    memset(pdvtd16, 0, pdvtdInfo->cbConvertSize);

    cbOffset = UT_DVTARGETDEVICE_SIZE;

    if (pdvtdInfo->cchDrvName != 0)
    {
        pdvtd16->tdDriverNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(CP_ACP, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdDriverNameOffset),
                                pdvtdInfo->cchDrvName,
                                (char *)pdvtd16 + pdvtd16->tdDriverNameOffset,
                                pdvtdInfo->cchDrvName * sizeof(WCHAR),
                                NULL, NULL);

        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset += (USHORT) cbWritten;
    }

    if (pdvtdInfo->cchDevName != 0)
    {
        pdvtd16->tdDeviceNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(
                                nCodePage, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdDeviceNameOffset),
                                pdvtdInfo->cchDevName,
                                (char *)pdvtd16 + pdvtd16->tdDeviceNameOffset,
                                pdvtdInfo->cchDevName * sizeof(WCHAR),
                                NULL, NULL);

        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset += (USHORT) cbWritten;
    }

    if (pdvtdInfo->cchPortName != 0)
    {
        pdvtd16->tdPortNameOffset = cbOffset;
        cbWritten = WideCharToMultiByte(nCodePage, 0,
                                (WCHAR *)((BYTE *)pdvtd32 +
                                    pdvtd32->tdPortNameOffset),
                                pdvtdInfo->cchPortName,
                                (char *)pdvtd16 + pdvtd16->tdPortNameOffset,
                                pdvtdInfo->cchPortName * sizeof(WCHAR),
                                NULL, NULL);
        if (0 == cbWritten)
        {
            hr = E_UNEXPECTED;
            goto ErrRtn;
        }
        cbOffset += (USHORT) cbWritten;
    }

    if (pdvtd32->tdExtDevmodeOffset != 0)
    {
        //  Make sure DEVMODEA will be DWORD aligned
        cbOffset += (sizeof(DWORD) - 1);
        cbOffset &= ~(sizeof(DWORD) - 1);

        pdvtd16->tdExtDevmodeOffset = cbOffset;
        pdm16 = (DEVMODEA *)((BYTE *)pdvtd16+pdvtd16->tdExtDevmodeOffset);

        pdm32 = (DEVMODEW *)((BYTE *)pdvtd32+pdvtd32->tdExtDevmodeOffset);

        //  The incoming DEVMODEW can have one of the following two forms:
        //
        //  1)  32 WCHARs for dmDeviceName
        //      m bytes worth of fixed size data (where m <= 38)
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 64+m
        //
        //  2)  32 WCHARs for dmDeviceName
        //      38 bytes worth of fixed size data
        //      32 WCHARs for dmFormName
        //      m additional bytes of fixed size data
        //      n bytes of dmDriverExtra data
        //
        //      and dmSize will be 64 + 38 + 64 + m
        //
        //  We have to be careful to translate the dmFormName string, if it
        //  exists


		// Need to attempt to copy the entire buffer since old UI lib does a memcmp to verify if ptd's are equal

        if (WideCharToMultiByte(nCodePage, 0, pdm32->dmDeviceName,CCHDEVICENAME,
                                (char *)pdm16->dmDeviceName, CCHDEVICENAME,
                                NULL, NULL) == 0)
        {
     		 
			 // in DBCS case we can run out of pdm16->dmDeviceName buffer space
			 // Current Implementation of WideCharToMultiByte copies in what fit before error 
			 // but in case this behavior changes copy again up to NULL char if error out above

       	 	if (WideCharToMultiByte(nCodePage, 0, pdm32->dmDeviceName,-1,
                                (char *)pdm16->dmDeviceName, CCHDEVICENAME,
                                NULL, NULL) == 0)
			{
		    	hr = E_UNEXPECTED;
				goto ErrRtn;
		  	}
        }

        //  Now check to see if we have a dmFormName to translate
        if (pdm32->dmSize <= FIELD_OFFSET(DEVMODEW, dmFormName))
        {
            //  No dmFormName, just copy the remaining m bytes
            memcpy(&pdm16->dmSpecVersion, &pdm32->dmSpecVersion,
                   pdm32->dmSize - FIELD_OFFSET(DEVMODEW, dmSpecVersion));
        }
        else
        {
            //  There is a dmFormName;  copy the bytes between the names first
            memcpy(&pdm16->dmSpecVersion, &pdm32->dmSpecVersion,
                   FIELD_OFFSET(DEVMODEW, dmFormName) -
                     FIELD_OFFSET(DEVMODEW, dmSpecVersion));

            //  Now translate the dmFormName
            if (WideCharToMultiByte(CP_ACP, 0,
                                    pdm32->dmFormName, CCHFORMNAME,
                                    (char *) pdm16->dmFormName, CCHFORMNAME,
                                    NULL, NULL) == 0)
            {

	            if (WideCharToMultiByte(CP_ACP, 0,
	                                    pdm32->dmFormName, -1,
	                                    (char *) pdm16->dmFormName, CCHFORMNAME,
	                                    NULL, NULL) == 0)
				{
			    	hr = E_UNEXPECTED;
					goto ErrRtn;
			  	}
            }

            //  Now copy the remaining m bytes

            if (pdm32->dmSize > FIELD_OFFSET(DEVMODEW, dmLogPixels))
            {
                memcpy(&pdm16->dmLogPixels, &pdm32->dmLogPixels,
                       pdm32->dmSize - FIELD_OFFSET(DEVMODEW, dmLogPixels));
            }
        }

        pdm16->dmSize = sizeof(DEVMODEA);
        if (pdm32->dmSize > sizeof(DEVMODEW))
        {
            pdm16->dmSize += pdm32->dmSize - sizeof(DEVMODEW);
        }

        //  Copy the extra driver bytes
        memcpy(((BYTE*)pdm16) + pdm16->dmSize, ((BYTE*)pdm32) + pdm32->dmSize,
               pdm32->dmDriverExtra);

        cbOffset += pdm16->dmSize + pdm16->dmDriverExtra;
    }

    //  Finally, set pdvtd16's size
    pdvtd16->tdSize = cbOffset;

ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT UtConvertDvtd32toDvtd16 (%lx)\n",
                            NULL, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given a string length, and two pointers (one ANSI, one
//              OLESTR), returns the UNICODE version of whichever string
//              is valid.
//
//  Effects:    Memory is allocated on the caller's pointer for new OLESTR
//
//  Arguments:  [ulLength]      -- length of string in CHARACTERS (not bytes)
//                                 (including terminator)
//              [szANSI]        -- candidate ANSI string
//              [szOLESTR]      -- candidate OLESTR string
//              [pstr]          -- OLESTR OUT parameter
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//              E_ANSITOUNICODE      if ANSI cannot be converted to UNICODE
//
//  Algorithm:  If szOLESTR is available, a simple copy is performed
//              If szOLESTR is not available, szANSI is converted to UNICODE
//              and the result is copied.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//  Notes:      Only one of the two input strings (ANSI or UNICODE) should
//              be set on entry.
//
//--------------------------------------------------------------------------

INTERNAL UtGetUNICODEData
    ( ULONG      ulLength,
      LPSTR      szANSI,
      LPOLESTR   szOLESTR,
      LPOLESTR * pstr )
{
    VDATEHEAP();

    // This fn is only called when one of the input strings
    // has valid data... assert the impossible.

    Win4Assert(pstr);		    // must have an out string
    Win4Assert(ulLength);	    // must have a non-zero length
    Win4Assert(szANSI || szOLESTR); // must have at least one source string

    // If neither the ANSI nor the OLESTR version has data,
    // there is nothing to return.

#if 0
// This is no better than what was there!!!
    *pstr = NULL;
    if (szOLESTR) {
	*pstr = (LPOLESTR) UtDupPtr(szOLESTR, ulLength * sizeof(OLECHAR));
    }
    else if (szANSI) {
        if (FALSE == MultiByteToWideChar(CP_ACP,    // Code page ANSI
                                              0,    // Flags (none)
                                         szANSI,    // Source ANSI str
                                       ulLength,    // length of string
                                          *pstr,    // Dest UNICODE buffer
                      ulLength * sizeof(OLECHAR) )) // size of UNICODE buffer
        {
            PubMemFree(*pstr);
            *pstr = NULL;
            return ResultFromScode(E_UNSPEC);
        }

    }

    if (NULL == *pstr)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

#else

    if (!(szANSI || szOLESTR))
    {
        *pstr = NULL;
    }

    // Allocate memory for the UNICODE return string

    *pstr = (LPOLESTR) PubMemAlloc(ulLength * sizeof(OLECHAR));
    if (NULL == *pstr)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Trivial case: we already have UNICODE, just copy it
    if (szOLESTR)
    {
        _xstrcpy(*pstr, szOLESTR);
        return(NOERROR);
    }

    // Otherwise, we have to convert the ANSI string to UNICODE
    // and return that.

    else
    {
        if (FALSE == MultiByteToWideChar(CP_ACP,    // Code page ANSI
                                              0,    // Flags (none)
                                         szANSI,    // Source ANSI str
                                       ulLength,    // length of string
                                          *pstr,    // Dest UNICODE buffer
                      ulLength * sizeof(OLECHAR) )) // size of UNICODE buffer
        {
            PubMemFree(*pstr);
            *pstr = NULL;
            return ResultFromScode(E_UNSPEC);
        }
    }
    return NOERROR;
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   UtPutUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given an OLESTR and two possible buffer pointer, one ANSI
//              and the other OLESTR, this fn tries to convert the string
//              down to ANSI.  If it succeeds, it allocates memory on the
//              ANSI ptr for the result.  If it fails, it allocates memory
//              on the UNICODE ptr and copies the input string over.  The
//              length of the final result (ANSI or UNICODE) is returned
//              in dwResultLen.
//
//  Arguments:  [ulLength]      -- input length of OLESTR str
//				   NB!!!! this value must include the
//				   null terminator character.
//              [str]           -- the OLESTR to store
//              [pszANSI]       -- candidate ANSI str ptr
//              [pszOLESTR]     -- candidate OLESTR str ptr.  May be NULL,
//				   in which case no copy is made of the
//				   original string if the ANSI conversion
//				   fails.
//              [pdwResultLen]  -- where to store the length of result.  This
//				   length includes the terminating NULL.
//				   Length is in CHARACTERS.
//
//  Returns:    NOERROR            on success
//              E_OUTOFMEMORY      on allocation failure
//		E_FAIL		   can't convert ANSI string and no
//				   pszOLESTR is NULL
//
//  History:    dd-mmm-yy Author    Comment
//		10-Jun-94 alexgo    allow pszOLESTR to be NULL
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

// this function is poorly coded. But, it looks like it only gets called when a 1.0 
// clip format is needed.  That is not very often!

INTERNAL UtPutUNICODEData
    ( ULONG        ulLength,
      LPOLESTR     str,
      LPSTR      * pszANSI,
      LPOLESTR   * pszOLESTR,
      DWORD      * pdwResultLen )
{
    VDATEHEAP();

    Win4Assert(pszANSI);
    Win4Assert(str);
    Win4Assert(pdwResultLen);
    Win4Assert(ulLength);

    // Free any strings currently attached to these pointers; if we wind
    // up setting one here, we can't leave the other valid.

    if (*pszANSI)
    {
        PubMemFree(*pszANSI);
        *pszANSI = NULL;
    }
    if (pszOLESTR && *pszOLESTR)
    {
        PubMemFree(*pszOLESTR);
        *pszOLESTR = NULL;
    }

    // Create a working buffer for UNICODE->ANSI conversion
    LPSTR szANSITEMP = (LPSTR) PubMemAlloc((ulLength+1) * 2);
    if (NULL == szANSITEMP)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Try to convert the UNICODE down to ANSI.  If it succeeds,
    // we just copy the result to the ANSI dest.  If it fails,
    // we copy the UNICODE version direct to the UNICODE dest.

    LPCSTR pDefault = "?";
    BOOL   fUseDef  = 0;

    if (FALSE == WideCharToMultiByte (CP_ACP,
                                           0,
                                         str,
                                    ulLength,
                                  szANSITEMP,
                          (ulLength + 1) * 2,
                                    pDefault,
                                     &fUseDef) || fUseDef )
    {
        // UNICODE->ANSI failed!

        // Won't be needing the ANSI buffer anymore...
        PubMemFree(szANSITEMP);

	if( pszOLESTR )
	{
	    *pszANSI = NULL;
	    *pszOLESTR = (LPOLESTR) PubMemAlloc((ulLength + 1) * sizeof(OLECHAR));
	    if (NULL == *pszOLESTR)
	    {
		*pdwResultLen = 0;
		return ResultFromScode(E_OUTOFMEMORY);
	    }
	    // Move the UNICODE source to UNICODE dest
	    _xstrcpy(*pszOLESTR, str);
	    *pdwResultLen = _xstrlen(str) + 1;

	    // That's it... return success
	    return(NOERROR);
	}
	else
	{
            return ResultFromScode(E_FAIL);
	}
    }

    // This code path is taken when the conversion to ANSI was
    // successful.  We copy the ANSI result to the ANSI dest.

    if( pszOLESTR )
    {
	*pszOLESTR = NULL;
    }

    *pdwResultLen = strlen(szANSITEMP) + 1;
    *pszANSI = (LPSTR) PubMemAlloc(*pdwResultLen);
    if (NULL == *pszANSI)
    {
        *pdwResultLen = 0;
        return ResultFromScode(E_OUTOFMEMORY);
    }
    strcpy(*pszANSI, szANSITEMP);

    PubMemFree(szANSITEMP);

    return(NOERROR);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSafeRefCount::SafeRefCount()
//
//  Purpose:    CSafeRefCount implements reference counting rules for objects.
//              It keeps track of reference count and zombie state.
//              It helps object manage their liveness properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Rewritten to handle aggregation
//
//--------------------------------------------------------------------------
ULONG CSafeRefCount::SafeRelease()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &m_cRefs);        
    // Check if this is the last release
    if(cRefs == 0) {
        // As this function is reentrant on the current
        // thread, gaurd against double destruction
        if(!m_fInDelete) {
            // There are no race conditions here
            // Mark object as in destructor
            m_fInDelete = TRUE;
            
            // Here is the need for the destructor to be virtual
            delete this;
        }
    }

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRefExportCount::SafeRelease
//
//  Purpose:    CRefExportCount implements reference counting rules for server
//              objects that export their nested objects on behalf of their
//              clients like DEFHANDLER abd CACHE. It keeps track of 
//              reference count, export count, zombie state, etc.
//              It helps object manage their shutdown logic properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Creation
//
//--------------------------------------------------------------------------
ULONG CRefExportCount::SafeRelease()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &m_cRefs);
    // Check if ref count has become zero
    if(cRefs == 0) {
        // As this function is reentrant on the current
        // thread, gaurd against double destruction
        if(!m_IsZombie) {
            // There are no race conditions here
            // Mark object as a zombie
            m_IsZombie = TRUE;
            
            // Call cleanup function while destruction is not allowed
            CleanupFn();

            // Allow destruction
            InterlockedExchange((LONG *) &m_Status, KILL);

            // Check for any exported objects
            if(m_cExportCount == 0) {
                // Gaurd against double destruction
                if(InterlockedExchange((LONG *) &m_Status, DEAD) == KILL) {
                    // Here is the need for the destructor to be virtual
                    delete this;
                }
            }
        }
    }

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRefExportCount::DecrementExportCount
//
//  Purpose:    CRefExportCount implements reference counting rules for server
//              objects that export their nested objects on behalf of their
//              clients like DEFHANDLER abd CACHE. It keeps track of 
//              reference count, export count, zombie state, etc.
//              It helps object manage their shutdown logic properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Creation
//
//--------------------------------------------------------------------------
ULONG CRefExportCount::DecrementExportCount()
{
    ULONG cExportCount;

    // Decrement export count 
    cExportCount = InterlockedDecrement((LONG *) &m_cExportCount);
    // Check if the export count has become zero
    if(cExportCount == 0) {
        // Check if destruction is allowed
        if(m_Status == KILL) {
            // Gaurd against double destruction
            if(InterlockedExchange((LONG *) &m_Status, DEAD) == KILL) {
                // Here is the need for the destructor to be virtual
                delete this;
            }
        }
    }

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CThreadCheck::VerifyThreadId
//
//  Synopsis: 	makes sure that the calling thread is the same as the thread
//		the object was created on if the threading model is *not*
//		free threading.
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns:  	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CThreadCheck::VerifyThreadId( void )
{
    if( m_tid == GetCurrentThreadId() )
    {
	return TRUE;
    }
    else
    {
	LEDebugOut((DEB_ERROR, "ERROR!: Called on thread %lx, should be"
	    " %lx \n", GetCurrentThreadId(), m_tid));
	return FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CThreadCheck::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef _DEBUG

HRESULT CThreadCheck::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Thread ID = "  << m_tid << endl;

    // clean up and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif //_DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCThreadCheck, public (_DEBUG only)
//
//  Synopsis:   calls the CThreadCheck::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pTC]           - pointer to CThreadCheck
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCThreadCheck(CThreadCheck *pTC, ULONG ulFlag, int nIndentLevel)
{
    char *pszDump;
    HRESULT hresult;

    if (pTC == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pTC->Dump( &pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\util\utstream.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		utstream.cpp
//
//	Contents:
//		Ole stream utilities
//
//	Classes:
//
//	Functions:
//
//	History:
//		10-May-94 KevinRo   Added ansi versions of StringStream stuff
//		25-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocations.
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//		12/07/93 - ChrisWe - file inspection and cleanup; fixed
//			String reading and writing to cope with OLESTR, and
//			with differing alignment requirements
//		06/23/93 - SriniK - moved ReadStringStream(),
//			WriteStringStream(), and OpenOrCreateStream() here
//			from api.cpp and ole2.cpp
//		03/14/92 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(utstream)

#include <reterr.h>
#include <limits.h>

NAME_SEG(UtStream)
ASSERTDATA

// this constant is used to size string buffers when we attempt to write out
// a string and its length in one write call
#define UTSTRINGBUF_SIZE 100

// REVIEW, I thought that OpenStream already had an option to do this.  If
// so, this function shouldn't be used in our code.  But we can't remove it
// because it is exported to the outside.
// this is exported to the outside
#pragma SEG(OpenOrCreateStream)
STDAPI OpenOrCreateStream(IStorage FAR * pstg, LPCOLESTR pwcsName,
		IStream FAR* FAR* ppstm)
{
	VDATEHEAP();

	HRESULT error;

	error = pstg->CreateStream(pwcsName, STGM_SALL | STGM_FAILIFTHERE,
			0, 0, ppstm);
	if (GetScode(error) == STG_E_FILEALREADYEXISTS)
		error = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, ppstm);

	return(error);
}

// returns S_OK when string read and allocated (even if zero length)
STDAPI ReadStringStream(CStmBufRead & StmRead, LPOLESTR FAR * ppsz)
{
	VDATEHEAP();

	ULONG cb; // the length of the string in *bytes* (NOT CHARACTERS)
	HRESULT hresult;
	
	// initialize the the string pointer for error returns
	*ppsz = NULL;

        if ((hresult = StmRead.Read((void FAR *)&cb, sizeof(ULONG))) != NOERROR)
		return hresult;

	// is string empty?
	if (cb == 0)
		return(NOERROR);

	// allocate memory to hold the string
	if (!(*ppsz = (LPOLESTR)PubMemAlloc(cb)))
		return(ReportResult(0, E_OUTOFMEMORY, 0, 0));

	// read the string; this includes a trailing NULL
        if ((hresult = StmRead.Read((void FAR *)(*ppsz), cb)) != NOERROR)
		goto errRtn;
	
	return(NOERROR);

errRtn:	
	// delete the string, and return without one
	PubMemFree(*ppsz);
	*ppsz = NULL;
	return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadStringStreamA
//
//  Synopsis:   Read a ANSI stream from the stream
//
//  Effects:
//
//  Arguments:  [pstm] -- Stream to read from
//		[ppsz] -- Output pointer
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//              2-20-95   KentCe    Converted to buffer stream reads.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadStringStreamA(CStmBufRead & StmRead, LPSTR FAR * ppsz)
{
	VDATEHEAP();

	ULONG cb; // the length of the string in *bytes* (NOT CHARACTERS)
	HRESULT hresult;
	
	// initialize the the string pointer for error returns
	*ppsz = NULL;

        if ((hresult = StmRead.Read((void FAR *)&cb, sizeof(ULONG))) != NOERROR)
		return hresult;

	// is string empty?
	if (cb == 0)
		return(NOERROR);

	// allocate memory to hold the string
	if (!(*ppsz = (LPSTR)PubMemAlloc(cb)))
		return(ReportResult(0, E_OUTOFMEMORY, 0, 0));

	// read the string; this includes a trailing NULL
        if ((hresult = StmRead.Read((void FAR *)(*ppsz), cb)) != NOERROR)
		goto errRtn;
	
	return(NOERROR);

errRtn:	
	// delete the string, and return without one
	PubMemFree(*ppsz);
	*ppsz = NULL;
	return(hresult);
}


// this is exported to the outside
STDAPI WriteStringStream(CStmBufWrite & StmWrite, LPCOLESTR psz)
{
	VDATEHEAP();

	HRESULT error;
	ULONG cb; // the count of bytes (NOT CHARACTERS) to write to the stream

	// if the string pointer is NULL, use zero length
	if (!psz)
		cb = 0;
	else
	{
		// count is length of string, plus terminating null
		cb = (1 + _xstrlen(psz))*sizeof(OLECHAR);

		// if possible, do a single write instead of two
		
		if (cb <= UTSTRINGBUF_SIZE)
		{
			BYTE bBuf[sizeof(ULONG)+
					UTSTRINGBUF_SIZE*sizeof(OLECHAR)];
					// buffer for count and string
		
			// we have to use _xmemcpy to copy the length into
			// the buffer to avoid potential boundary faults,
			// since bBuf might not be aligned strictly enough
			// to do *((ULONG FAR *)bBuf) = cb;
			_xmemcpy((void FAR *)bBuf, (const void FAR *)&cb,
					sizeof(cb));
			_xmemcpy((void FAR *)(bBuf+sizeof(cb)),
					(const void FAR *)psz, cb);
			
			// write contents of buffer all at once
                        return( StmWrite.Write((VOID FAR *)bBuf,
                                        cb+sizeof(ULONG)));
		}
	}

	// if we got here, our buffer isn't large enough, so we do two writes
	// first, write the length
        if (error = StmWrite.Write((VOID FAR *)&cb, sizeof(ULONG)))
		return error;
	
	// are we are done writing the string?
	if (psz == NULL)
		return NOERROR;
		
	// write the string
        return(StmWrite.Write((VOID FAR *)psz, cb));
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteStringStreamA
//
//  Synopsis:   Writes an ANSI string to a stream in a length prefixed format.
//
//  Effects:
//
//  Arguments:  [pstm] -- Stream
//		[psz] -- Ansi string to write
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//              2-20-95   KentCe    Converted to buffer stream writes.
//
//  Notes:
//
//----------------------------------------------------------------------------
FARINTERNAL_(HRESULT) WriteStringStreamA(CStmBufWrite & StmWrite, LPCSTR psz)
{
	VDATEHEAP();

	HRESULT error;
	ULONG cb; // the count of bytes (NOT CHARACTERS) to write to the stream

	// if the string pointer is NULL, use zero length
	if (!psz)
		cb = 0;
	else
	{
		// count is length of string, plus terminating null
		cb = (1 + strlen(psz));

		// if possible, do a single write instead of two
		
		if (cb <= UTSTRINGBUF_SIZE)
		{
			BYTE bBuf[sizeof(ULONG)+
					UTSTRINGBUF_SIZE];
					// buffer for count and string
		
			// we have to use _xmemcpy to copy the length into
			// the buffer to avoid potential boundary faults,
			// since bBuf might not be aligned strictly enough
			// to do *((ULONG FAR *)bBuf) = cb;
			_xmemcpy((void FAR *)bBuf, (const void FAR *)&cb,
					sizeof(cb));
			_xmemcpy((void FAR *)(bBuf+sizeof(cb)),
					(const void FAR *)psz, cb);
			
			// write contents of buffer all at once
                        return(StmWrite.Write((VOID FAR *)bBuf,
                                        cb+sizeof(ULONG)));
		}
	}

	// if we got here, our buffer isn't large enough, so we do two writes
	// first, write the length
        if (error = StmWrite.Write((VOID FAR *)&cb, sizeof(ULONG)))
		return error;
	
	// are we are done writing the string?
	if (psz == NULL)
		return NOERROR;
		
	// write the string
        return(StmWrite.Write((VOID FAR *)psz, cb));
}

//+-------------------------------------------------------------------------
//
//  Function:   StRead
//
//  Synopsis:   Stream read that only succeeds if all requested bytes read
//
//  Arguments:  [pStm]     -- source stream
//              [pvBuffer] -- destination buffer
//              [ulcb]     -- bytes to read
//
//  Returns:    S_OK if successful, else error code
//
//  Algorithm:
//
//  History:    18-May-94 AlexT     Added header block, fixed S_FALSE case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(StRead)
FARINTERNAL_(HRESULT) StRead(IStream FAR * pStm, LPVOID pvBuffer, ULONG ulcb)
{
	VDATEHEAP();

	HRESULT hr;
	ULONG cbRead;

	hr = pStm->Read(pvBuffer, ulcb, &cbRead);
        if (FAILED(hr))
        {
            return(hr);
        }

        if (ulcb == cbRead)
        {
            return(S_OK);
        }

        //  We got a success code but not enough bytes - turn it into an error

        return(STG_E_READFAULT);
}


// if fRelative is FALSE then dwSize is the size of the stream
// if it is TRUE then find the current seek position and add dwSize to that
// and then set it as the stream size.
FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize, BOOL fRelative)
{
	VDATEHEAP();

	LARGE_INTEGER large_int; // indicates where to seek to
	ULARGE_INTEGER ularge_int; // indicates absolute position
	ULARGE_INTEGER ularge_integer; // the size we will set for the stream
	HRESULT error;
	
	LISet32(large_int, 0);
	ULISet32(ularge_integer, dwSize);
	
	if (fRelative)
	{
		if (error = pstm->Seek(large_int, STREAM_SEEK_CUR, &ularge_int))
			return(error);
		
		// REVIEW: is there a routine to do 64 bit addition ???
		ularge_integer.LowPart += ularge_int.LowPart;
	}

	return(pstm->SetSize(ularge_integer));
}	


// REVIEW, is this actually used?
#pragma SEG(StSave10NativeData)
FARINTERNAL_(HRESULT) StSave10NativeData(IStorage FAR* pstgSave,
		HANDLE hNative, BOOL fIsOle1Interop)
{
	VDATEHEAP();

	DWORD dwSize;
	HRESULT error;

	if (!hNative)
		return ReportResult(0, E_UNSPEC, 0, 0);

	if (!(dwSize = (ULONG) GlobalSize (hNative)))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);

#ifdef OLE1INTEROP
	if ( fIsOle1Interop )
    {
		LPLOCKBYTES plkbyt;
		LPSTORAGE   pstgNative= NULL;
		const DWORD grfStg = STGM_READWRITE | STGM_SHARE_EXCLUSIVE
									| STGM_DIRECT ;

		if ((error = CreateILockBytesOnHGlobal (hNative, FALSE, &plkbyt))!=NOERROR)
			goto errRtn;

		if ((error = StgOpenStorageOnILockBytes (plkbyt, (LPSTORAGE)NULL, grfStg,
									(SNB)NULL, 0, &pstgNative)) != NOERROR){
			error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
			plkbyt->Release();
            goto errRtn;
		}

		pstgNative->CopyTo (0, NULL, 0, pstgSave);
		plkbyt->Release();
		pstgNative->Release();
	}
	else
#endif
	{
		LPSTREAM   	lpstream = NULL;

		if (error = OpenOrCreateStream(pstgSave, OLE10_NATIVE_STREAM, &lpstream))
			goto errRtn;

		if (error = StWrite(lpstream, &dwSize, sizeof(DWORD))) {
			lpstream->Release();
			goto errRtn;
		}
	
		error = UtHGLOBALtoStm(hNative, dwSize, lpstream);
		
		lpstream->Release();
	}

errRtn:
	return error;
}



#pragma SEG(StSave10ItemName)
FARINTERNAL StSave10ItemName
	(IStorage FAR* pstg,
	LPCSTR szItemNameAnsi)
{
	VDATEHEAP();

        CStmBufWrite StmWrite;
        HRESULT      hresult;


        if ((hresult = StmWrite.OpenOrCreateStream(pstg, OLE10_ITEMNAME_STREAM))
		!= NOERROR)
	{
		return hresult;
	}

        hresult = WriteStringStreamA(StmWrite, szItemNameAnsi);
        if (FAILED(hresult))
        {
            goto errRtn;
        }

        hresult = StmWrite.Flush();

errRtn:
        StmWrite.Release();

	return hresult;
}


#pragma SEG(StRead10NativeData)
FARINTERNAL StRead10NativeData
	(IStorage FAR*  pstg,
	HANDLE FAR* 	phNative)
{
DWORD		dwSize;
LPSTREAM   	pstream = NULL;
HRESULT		hresult;
HANDLE hBits = NULL;
void FAR *lpBits = NULL;

    
    VDATEHEAP();


    *phNative = NULL;
    
    RetErr (pstg->OpenStream (OLE10_NATIVE_STREAM, NULL, STGM_SALL, 0, &pstream));
    ErrRtnH (StRead (pstream, &dwSize, sizeof (DWORD)));

    // initialize this for error return cases
    // allocate a new handle
    if (!(hBits = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize)) // going to pass this to DDE.
		    || !(lpBits = (BYTE *)GlobalLock(hBits)))
    {
	hresult = ResultFromScode(E_OUTOFMEMORY);
	goto errRtn;
    }
    
    // read the stream into the allocated memory
    if (hresult = StRead(pstream, lpBits, dwSize))
	    goto errRtn;
    
    // if we got this far, return new handle
    *phNative = hBits;

errRtn:
    // unlock the handle, if it was successfully locked
    if (lpBits)
	    GlobalUnlock(hBits);

    // free the handle if there was an error
    if ((hresult != NOERROR) && hBits)
	    GlobalFree(hBits);

    if (pstream)
	    pstream->Release();

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBuf::CStmBuf, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStmBuf::CStmBuf(void)
{
    m_pStm = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBuf::~CStmBuf, public
//
//  Synopsis:   Destructor.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStmBuf::~CStmBuf(void)
{
    //
    //  Verify that the programmer released the stream interface.
    //
    Assert(m_pStm == NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Init, public
//
//  Synopsis:   Define the stream interface to read from.
//
//  Arguments:  [pstm] -- Pointer to stream to read.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
void CStmBufRead::Init(IStream * pstm)
{
    Assert(m_pStm == NULL);

    m_pStm = pstm;

    m_pStm->AddRef();

    Reset();
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::OpenStream, public
//
//  Synopsis:   Open a stream for reading.
//
//  Arguments:  [pstg]     -- Pointer to storage that contains stream to open.
//              [pwcsName] -- Name of stream to open.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::OpenStream(IStorage * pstg, const OLECHAR * pwcsName)
{
    VDATEHEAP();
    HRESULT hr;


    Assert(m_pStm == NULL);

    hr = pstg->OpenStream(pwcsName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, 0,
            &m_pStm);

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Read, public
//
//  Synopsis:   Read data from the stream.
//
//  Arguments:  [pBuf] - Address to store read bytes in.
//              [cBuf] - Maximum number of bytes to read.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::Read(PVOID pBuf, ULONG cBuf)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  While more bytes to read.
    //
    while (cBuf)
    {
        //
        //  If our buffer is empty, read more data.
        //
        if (m_cBuffer == 0)
        {
           hr = m_pStm->Read(m_aBuffer, sizeof(m_aBuffer), &m_cBuffer);
           if (FAILED(hr))
              return hr;

           if (m_cBuffer == 0)
              return STG_E_READFAULT;

           m_pBuffer = m_aBuffer;
        }

        //
        //  Determine number of bytes to read.
        //
        cnt = min(m_cBuffer, cBuf);

        //
        //  Copy the input from the input buffer, update variables.
        //
        memcpy(pBuf, m_pBuffer, cnt);
        pBuf = (PBYTE)pBuf + cnt;
        cBuf   -= cnt;
        m_pBuffer += cnt;
        m_cBuffer -= cnt;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::ReadLong, public
//
//  Synopsis:   Read a long value from the stream.
//
//  Arguments:  [plValue] - Address of long to fill.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufRead::ReadLong(LONG * plValue)
{
    return Read(plValue, sizeof(LONG));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Reset
//
//  Synopsis:   Reset buffer variables.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufRead::Reset(void)
{
    m_pBuffer = m_aBuffer;
    m_cBuffer = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::Release, public
//
//  Synopsis:   Release read stream interface.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufRead::Release()
{
    if (m_pStm)
    {
       m_pStm->Release();
       m_pStm = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Init, public
//
//  Synopsis:   Define the stream interface to write to.
//
//  Arguments:  [pstm] -- Pointer to stream to write.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
void CStmBufWrite::Init(IStream * pstm)
{
    Assert(m_pStm == NULL);

    m_pStm = pstm;

    m_pStm->AddRef();

    Reset();
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::OpenOrCreateStream, public
//
//  Synopsis:   Open/Create a stream for writing.
//
//  Arguments:  [pstg]     -- Pointer to storage that contains stream to open.
//              [pwcsName] -- Name of stream to open.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::OpenOrCreateStream(IStorage * pstg,
        const OLECHAR * pwcsName)
{
    VDATEHEAP();
    HRESULT hr;


    hr = pstg->CreateStream(pwcsName, STGM_SALL | STGM_FAILIFTHERE, 0, 0,
            &m_pStm);

    if (hr == STG_E_FILEALREADYEXISTS)
    {
        hr = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, &m_pStm);
    }

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufRead::CreateStream, public
//
//  Synopsis:   Create a stream for writing.
//
//  Arguments:  [pstg]     -- Pointer storage that contains stream to create.
//              [pwcsName] -- Name of stream to create.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Release method must be called.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::CreateStream(IStorage * pstg, const OLECHAR * pwcsName)
{
    VDATEHEAP();

    HRESULT hr;


    hr = pstg->CreateStream(pwcsName, STGM_CREATE | STGM_READWRITE |
            STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStm);

    Reset();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Write, public
//
//  Synopsis:   Write data to the stream.
//
//  Arguments:  [pBuf] - Address to store write bytes to.
//              [cBuf] - Maximum number of bytes to write.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::Write(void const * pBuf, ULONG cBuf)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  Keep writing until the caller's buffer is empty.
    //
    while (cBuf)
    {
        //
        //  Compute the number of bytes to copy.
        //
        cnt = min(m_cBuffer, cBuf);

        //
        //  Copy to the internal write buffer and update variables.
        //
        memcpy(m_pBuffer, pBuf, cnt);
        pBuf = (PBYTE)pBuf + cnt;
        cBuf   -= cnt;
        m_pBuffer += cnt;
        m_cBuffer -= cnt;

        //
        //  On full internal buffer, flush.
        //
        if (m_cBuffer == 0)
        {
            LEDebugOut((DEB_WARN, "WARNING: Multiple buffer flushes.\n"));

            hr = Flush();
            if (FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::WriteLong, public
//
//  Synopsis:   Write long value to the stream.
//
//  Arguments:  [lValue] - Long value to write.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::WriteLong(LONG lValue)
{
    return Write(&lValue, sizeof(LONG));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Flush, public
//
//  Synopsis:   Flush write buffer to the system.
//
//  Arguments:  None.
//
//  Returns:    HRESULT.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:      Performs a write of the stream buffer to the system, does not
//              force a flush to disk.
//
//----------------------------------------------------------------------------
HRESULT CStmBufWrite::Flush(void)
{
    ULONG   cnt;
    HRESULT hr;


    //
    //  This might be an overactive assert, but shouldn't happen.
    //
    Assert(m_cBuffer != sizeof(m_aBuffer));

    hr = m_pStm->Write(m_aBuffer, sizeof(m_aBuffer) - m_cBuffer, &cnt);
    if (FAILED(hr))
    {
        return hr;
    }

    if (cnt != sizeof(m_aBuffer) - m_cBuffer)
    {
        return STG_E_MEDIUMFULL;
    }

    Reset();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Reset, public
//
//  Synopsis:   Reset buffer variables.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufWrite::Reset(void)
{
    m_pBuffer = m_aBuffer;
    m_cBuffer = sizeof(m_aBuffer);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStmBufWrite::Release, public
//
//  Synopsis:   Release write stream interface.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  History:    20-Feb-95   KentCe   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CStmBufWrite::Release()
{
    if (m_pStm)
    {
       //
       //  Verify that flush was called.
       //
       Assert(m_cBuffer == sizeof(m_aBuffer));

       m_pStm->Release();
       m_pStm = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

#define DebugMsg(x)

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: GetUserSid returned NULL")));
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlUnicodeStringToAnsiString failed, status = 0x%x"),
                 status));
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser;
    PTOKEN_USER pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //
        pTemp = pUser;
        pUser = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pUser == NULL) {
            LocalFree( pTemp );
            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                      BytesRequired));
            return NULL;
        }

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\main.c ===
//
//
//

#include    "olecnfg.h"

const char * GlobalKeyNames[] =
    {
    0,
    "EnableDCOM",
    "DefaultLaunchPermission",
    "DefaultAccessPermission",
    "LegacyAuthenticationLevel"
    };

const char * ClsidKeyNames[] =
    {
    0,
    "InprocHandler32",
    "InprocServer32",
    "LocalServer32",
    "LocalService",
    "RemoteServerName",
    "RunAs",
    "ActivateAtStorage",
    "LaunchPermission",
    "AccessPermission"
    };

int      ArgsLeft;
char **  Args;

HKEY     hRegOle = 0;
HKEY     hRegClsid = 0;

#define IsDigit(c) (IsCharAlphaNumeric(c) && !IsCharAlpha(c))

void __cdecl main(int argc, char **argv)
{
    int     GlobalKeys[GLOBAL_KEYS+1];
    int     Key;
    int     n;
    DWORD   Disposition;
    long    RegStatus;

    memset( GlobalKeys, 0, sizeof(GlobalKeys) );

    ArgsLeft = argc - 1;
    Args = argv + 1;

    if ( (argc > 1) &&
         ((strcmp( "/?", argv[1] ) == 0) || (strcmp( "-?", argv[1] ) == 0)) )
    {
        DisplayHelp();
        return;
    }

    //
    // With no arguments, display the global registry activation values.
    //
    if ( ArgsLeft == 0 )
    {
        DisplayGlobalSettings();
        return;
    }

    //
    // Look for specified global registry keys and operations
    //
    for ( ; ArgsLeft > 0; )
    {
        if ( _stricmp( *Args, "EnableDCOM" ) == 0 )
            Key = ENABLE_NETWORK_OLE;
        else if ( _stricmp( *Args, "DefaultLaunchPermission" ) == 0 )
            Key = DEFAULT_LAUNCH_PERMISSION;
        else if ( _stricmp( *Args, "DefaultAccessPermission" ) == 0 )
            Key = DEFAULT_ACCESS_PERMISSION;
        else if ( _stricmp( *Args, "LegacyAuthenticationLevel" ) == 0 )
            Key = LEGACY_AUTHENTICATION_LEVEL;
        else
            break;

        EAT_ARG();

        if ( Key >= 100 )
        {
            if ( Key == MERGE )
                {
                MergeHives( );
                }
            else if ( Key == SAVE_USER )
                {
                SaveChangesToUser( );
                }
            else if ( Key == SAVE_COMMON )
                {
                SaveChangesToCommon( );
                }
            continue;
        }

        if ( Key == DEFAULT_ACCESS_PERMISSION )
        {
            GlobalKeys[Key] = YES;
            continue;
        }

        if ( Key == LEGACY_AUTHENTICATION_LEVEL )
        {
            if ( ! IsDigit(**Args) || (**Args < '1') || (**Args > '6') )
            {
                printf( "LegacyAuthenticationLevel must be followed by a 1 to 6.\n" );
                return;
            }

            GlobalKeys[Key] = **Args;
        }
        else if ( (GlobalKeys[Key] = ReadYesOrNo()) == INVALID )
        {
            printf( "%s must be followed by 'y' or 'n'\n", Args[-1] );
            return;
        }

        EAT_ARG();
    }

    //
    // Set global keys on or off.
    //
    for ( Key = 1; Key < sizeof(GlobalKeys)/sizeof(int); Key++ )
    {
        if ( (Key == LEGACY_AUTHENTICATION_LEVEL) && (GlobalKeys[Key] != 0) )
        {
            if ( ! SetGlobalKey( Key, GlobalKeys[Key] - '0' ) )
                return;
            continue;
        }

        if ( (GlobalKeys[Key] == YES) || (GlobalKeys[Key] == NO) )
            if ( ! SetGlobalKey( Key, GlobalKeys[Key] ) )
                return;
    }

    //
    // Process any CLSID/ProgID specification.
    //
    ParseClsidProgId();

    if ( hRegOle )
        RegCloseKey( hRegOle );
    if ( hRegClsid )
        RegCloseKey( hRegClsid );
}

void ParseClsidProgId()
{
    CLSID_INFO  ClsidInfo;
    BOOL        NoKeys;
    int         ClsidKey;

    if ( ArgsLeft == 0 )
        return;

    memset( &ClsidInfo, 0, sizeof(CLSID_INFO) );

    NoKeys = TRUE;

    if ( (ArgsLeft > 0) && (**Args != '{') )
    {
        ClsidInfo.ProgId = *Args;
        EAT_ARG();

        if ( (ArgsLeft > 0) &&
             (**Args != '{') &&
             (NextClsidKey() == UNKNOWN) )
        {
            ClsidInfo.ProgIdDescription = *Args;
            EAT_ARG();
        }
    }

    if ( (ArgsLeft > 0) && (**Args == '{') )
    {
        ClsidInfo.Clsid = *Args;
        EAT_ARG();

        if ( (ArgsLeft > 0) &&
             (NextClsidKey() == UNKNOWN) )
        {
            ClsidInfo.ClsidDescription = *Args;
            EAT_ARG();
        }
    }

    for (; ArgsLeft > 0;)
    {
        ClsidKey = NextClsidKey();
        if ( (1 <= ClsidKey) && (ClsidKey <= CLSID_KEYS) )
            NoKeys = FALSE;

        EAT_ARG();

        switch ( ClsidKey )
        {
        case LAUNCH_PERMISSION :
            if ( (ClsidInfo.LaunchPermission = ReadYesOrNo()) == INVALID )
            {
                printf( "%s must be followed by 'y' or 'n'\n",
                        ClsidKeyNames[LAUNCH_PERMISSION] );
                goto ErrorReturn;
            }
            EAT_ARG();
            break;

        case ACCESS_PERMISSION :
            ClsidInfo.AccessPermission = YES;
            break;

        case ACTIVATE_AT_STORAGE :
            if ( (ClsidInfo.ActivateAtStorage = ReadYesOrNo()) == INVALID )
            {
                printf( "%s must be followed by 'y' or 'n'\n",
                        ClsidKeyNames[ACTIVATE_AT_STORAGE] );
                goto ErrorReturn;
            }
            EAT_ARG();
            break;

        case INPROC_HANDLER32 :
        case INPROC_SERVER32 :
        case LOCAL_SERVER32 :
        case LOCAL_SERVICE :
            if ( NextClsidKey() == UNKNOWN )
            {
                ClsidInfo.ServerPaths[ClsidKey] = *Args;
                EAT_ARG();
            }
            else
            {
                ClsidInfo.ServerPaths[ClsidKey] = "";
            }
            break;

        case REMOTE_SERVER_NAME :
            if ( NextClsidKey() == UNKNOWN )
            {
                ClsidInfo.RemoteServerName = *Args;
                EAT_ARG();
            }
            else
            {
                ClsidInfo.RemoteServerName = "";
            }
            break;

        case RUN_AS :
            if ( NextClsidKey() == UNKNOWN )
            {
                ClsidInfo.RunAsUserName = *Args;
                EAT_ARG();

                if ( _stricmp(ClsidInfo.RunAsUserName,"Interactive User") == 0 )
                    break;

                if ( _stricmp(ClsidInfo.RunAsUserName,"Interactive") == 0 )
                {
                    if ( (ArgsLeft > 0) && (_stricmp(*Args,"User") == 0) )
                    {
                        EAT_ARG();
                        ClsidInfo.RunAsUserName = "Interactive User";
                        break;
                    }
                }

                if ( NextClsidKey() != UNKNOWN )
                {
                    printf( "RunAs password or '*' must follow the user name.\n" );
                    goto ErrorReturn;
                }

                ClsidInfo.RunAsPassword = *Args;
                EAT_ARG();
            }
            else
            {
                ClsidInfo.RunAsUserName = "";
            }
            break;

        default :
            printf( "Invalid CLSID/ProgID specification given (%s)\n", Args[-1] );
            goto ErrorReturn;
            break;
        } // switch
    } // for

    //
    // Display current CLSID/ProgID settings if no keys were specified and
    // only a CLSID or ProgID (but not both) was given.
    //
    if ( NoKeys &&
        (ClsidInfo.ProgIdDescription == 0) &&
        (ClsidInfo.ClsidDescription == 0) &&
        ((ClsidInfo.Clsid == 0) || (ClsidInfo.ProgId == 0)) )
        DisplayClsidKeys( &ClsidInfo );
    else
        UpdateClsidKeys( &ClsidInfo );

    return;

ErrorReturn:
    printf( "No CLSID/ProgID entries were modified\n" );
}

int NextClsidKey()
{
    if ( ArgsLeft == 0 )
        return END_OF_ARGS;

    if ( _stricmp( *Args, "InprocHandler32" ) == 0 )
        return INPROC_HANDLER32;
    if ( _stricmp( *Args, "InprocServer32" ) == 0 )
        return INPROC_SERVER32;
    if ( _stricmp( *Args, "LocalServer32" ) == 0 )
        return LOCAL_SERVER32;
    if ( _stricmp( *Args, "LocalService" ) == 0 )
        return LOCAL_SERVICE;
    if ( _stricmp( *Args, "RemoteServerName" ) == 0 )
        return REMOTE_SERVER_NAME;
    if ( _stricmp( *Args, "RunAs" ) == 0 )
        return RUN_AS;
    if ( _stricmp( *Args, "ActivateAtStorage" ) == 0 )
        return ACTIVATE_AT_STORAGE;
    if ( _stricmp( *Args, "LaunchPermission" ) == 0 )
        return LAUNCH_PERMISSION;
    if ( _stricmp( *Args, "AccessPermission" ) == 0 )
        return ACCESS_PERMISSION;

    return UNKNOWN;
}

int ReadYesOrNo()
{
    if ( ArgsLeft == 0 )
        return INVALID;

    if ( (char)CharUpperA((LPSTR)**Args) == 'Y' )
        return YES;
    if ( (char)CharUpperA((LPSTR)**Args) == 'N' )
        return NO;

    return INVALID;
}


void DisplayHelp()
{
    puts( "\nolecnfg\n"
          "\t[EnableDCOM <y,n>]\n"
          "\t[DefaultLaunchPermission <y,n>]\n"
          "\t[DefaultAccessPermission]\n"
          "\t[LegacyAuthenticationLevel <1,2,3,4,5,6>]\n" );
    puts( "\t[[ProgID [Description]] [CLSID [Description]]\n"
          "\t\t[InprocHandler32 [Path]]\n"
          "\t\t[InprocServer32 [Path]]\n"
          "\t\t[LocalServer32 [Path]]\n"
          "\t\t[LocalService [Path]]\n"
          "\t\t[RemoteServerName [MachineName]]\n"
          "\t\t[RunAs [UserName Password]] ]\n"
          "\t\t[ActivateAtStorage <y,n>]\n"
          "\t\t[LaunchPermission <y,n>]\n"
          "\t\t[AccessPermission]\n"
          "\t]\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\clshive.c ===
//*************************************************************
//
//  Personal Classes Profile management routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

BOOL
MergeUserClasses(
    HKEY UserClassStore,
    HKEY CommonClassStore,
    HKEY MergedClassStore,
    BOOL ForceNew);

BOOL
CloneRegistryTree(
    HKEY hkSourceTree,
    HKEY hkDestinationTree,
    LPTSTR lpDestTreeName );

BOOL
AddSharedValuesToSubkeys( HKEY hkShared, LPTSTR pszSubtree );

BOOL
AddSharedValues( HKEY hkShared );
void CreateMachineClassHive( )
{
    HKEY        hkUser = NULL;
    HKEY        hkMachine = NULL;
    LONG        result;
    DWORD       dwDisp;

    result =
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 TEXT("Software\\Classes"),
                 0,
                 KEY_READ,
                 &hkUser);
    if (ERROR_SUCCESS != result) 
    {
       return;
    }
    result =
    RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                 TEXT("Software\\MachineClasses"),
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   NULL,
                   &hkMachine,
                   &dwDisp );

    if (ERROR_SUCCESS != result) 
    {
       RegCloseKey( hkUser );
       return;
    }
    CloneRegistryTree(hkUser, hkMachine, NULL);

    AddSharedValues( hkMachine );

    RegCloseKey( hkUser );
    RegCloseKey( hkMachine );
}


LPTSTR
GetUserMergedHivePath(
    LPTSTR SidString )
{
    // open HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\ProfileList
    // open ...\SidString
    // get value for ProfileImagePath, and if it is reg_expand_sz, expand it
    // append Classes as the last component of the hive file name
    long    result;
    HKEY    hkProfileListKey;
    HKEY    hkProfileKey;
    TCHAR   ProfilePath[256];
    TCHAR   ExpandedProfilePath[256];
    LPTSTR  pszProfileDirectory = NULL;
    LPTSTR  pszReturnedHivePath = NULL;
    DWORD   dwType;
    DWORD   dwSize = sizeof( ProfilePath );


    result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                           0,
                           KEY_READ,
                           &hkProfileListKey );

    //  Bug 45992
    if (ERROR_SUCCESS != result) {
       return NULL;
    }
    result = RegOpenKeyEx( hkProfileListKey,
                           SidString,
                           0,
                           KEY_READ,
                           &hkProfileKey );

    if (ERROR_SUCCESS != result) {
       RegCloseKey(hkProfileListKey);
       return NULL;
    }
    result = RegQueryValueEx( hkProfileKey,
                              L"ProfileImagePath",
                              NULL,
                              &dwType,
                              (BYTE*)&ProfilePath,
                              &dwSize );

    // Close them keys
    
    RegCloseKey(hkProfileListKey);
    RegCloseKey(hkProfileKey);
    
    if (ERROR_SUCCESS != result) {
       return NULL;
    }
    if ( dwType == REG_EXPAND_SZ )
    {
        ExpandEnvironmentStrings( ProfilePath,
                                  ExpandedProfilePath,
                                  sizeof(ExpandedProfilePath)/sizeof(TCHAR) );
        pszProfileDirectory = ExpandedProfilePath;
    }
    else
    {
        pszProfileDirectory = ProfilePath;
    }

    pszReturnedHivePath = (LPTSTR) LocalAlloc( LPTR,
                                               (lstrlenW( pszProfileDirectory )+1) * sizeof(TCHAR) +
                                               sizeof( L"\\ClsRoot" ) );
    // Bug 45993
    if (pszReturnedHivePath) 
    {
       // make up the returned string as the profile directory with \ClsRoot on the end
       lstrcpyW( pszReturnedHivePath, pszProfileDirectory );
       lstrcatW( pszReturnedHivePath, L"\\ClsRoot" );
    }

    return pszReturnedHivePath;
}

void
FreeUserMergedHivePath( LPTSTR hivepath )
{
    LocalFree( hivepath );
}

// see if the desired hive file already exists.  If so, load it and return
// otherwise, create a hive containing a single key, load it and return
BOOL
CreateUserMergedClasses(
    LPTSTR SidString,
    LPTSTR MergedClassesString,
    HKEY * phkMerged )
{
    LPTSTR      HivePath;
    long        result;
    HKEY        DummyKey = NULL;
    DWORD       dwDisp;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    HivePath = GetUserMergedHivePath( SidString );
    if (!HivePath) 
    {
       return FALSE;
    }
    // see if the desired hive file already exists.  If so, load it and return
    if ( 0xFFFFFFFF == GetFileAttributes( HivePath ) )
    {
        // create a hive containing a single key, load it and return
        result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               L"Software\\Microsoft\\DummyKey",
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &DummyKey,
                               &dwDisp );
	if (ERROR_SUCCESS != result) 
	{
	   FreeUserMergedHivePath( HivePath );
	   return FALSE;
	}
        //
        // Enable the backup privilege
        //

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

        // do this by doing a RegSaveKey of a small subtree
        result = RegSaveKey( DummyKey,
                             HivePath,
                             NULL );

        result = RegCloseKey( DummyKey );
        //
        // Restore the privilege to its previous state
        //

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }

    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);


    result = RegLoadKey( HKEY_USERS,
                         MergedClassesString,
                         HivePath );

    // if result is OK, then open the subkey and return it
    result = RegOpenKeyEx( HKEY_USERS,
                           MergedClassesString,
                           0,
                           KEY_ALL_ACCESS,
                           phkMerged );

    FreeUserMergedHivePath( HivePath );
    // close keys?

    //
    // Restore the privilege to its previous state
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    return TRUE;
}




void MergeUserClassHives( HANDLE Token )
{
    HKEY        hkUser = NULL;
    HKEY        hkMachine = NULL;
    HKEY        hkMerged = NULL;
    LONG        result;
    LPTSTR      SidString;
    LPTSTR      MergedClassesString;
    DWORD       dwDisp;
    BOOL        ForceNew = FALSE;

    result =
    RegCreateKeyEx(HKEY_CURRENT_USER,
                 TEXT("Software\\Classes"),
                 0,
                 NULL,
                 REG_OPTION_NON_VOLATILE,
                 KEY_READ,
                 NULL,
                 &hkUser,
                 &dwDisp);

    result =
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 TEXT("Software\\MachineClasses"),
                 0,
                 KEY_READ,
                 &hkMachine);

    if ( result == ERROR_FILE_NOT_FOUND )
    {
        CreateMachineClassHive();
        result =
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\MachineClasses"),
                     0,
                     KEY_READ,
                     &hkMachine);

    }

    // Bugs 45996 and 45997
    SidString = GetSidString( Token );
    if (SidString) 
    {
       MergedClassesString = (LPTSTR) LocalAlloc( LPTR,
						   (lstrlenW( SidString ) + 1) * sizeof(WCHAR) +
						   sizeof(L"_MergedClasses" ) );
       if (MergedClassesString) 
       {
       
	  lstrcpyW( MergedClassesString, SidString );
	  lstrcatW( MergedClassesString, L"_MergedClasses" );
      
	  result = RegOpenKeyEx( HKEY_USERS,
				 MergedClassesString,
				 0,
				 KEY_ALL_ACCESS,
				 &hkMerged );
      
	  if ( result == ERROR_FILE_NOT_FOUND )
	  {
	      CreateUserMergedClasses(SidString, MergedClassesString, &hkMerged );
	      ForceNew = TRUE;
	  }
      
	  MergeUserClasses(hkUser, hkMachine, hkMerged, ForceNew );
	  LocalFree( MergedClassesString );
       }
    }


    RegCloseKey( hkUser );
    RegCloseKey( hkMachine );
    RegCloseKey( hkMerged );


    DeleteSidString( SidString );
}

void MergeHives( )
{
    HANDLE      Token;
    NTSTATUS    Status;

    Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_QUERY, &Token );

    MergeUserClassHives( Token );

    NtClose( Token );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\uenv.h ===
//*************************************************************
//
//  Personal Classes Profile management routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#define	    UNICODE	1

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "userenv.h"

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\olecnfg.c ===
//
//
//

#include "olecnfg.h"

BOOL SetGlobalKey( int Key, int Value )
{
    DWORD   RegStatus;
    HKEY    hReg;
    DWORD   Disposition;
    char *  ValueName;

    if ( hRegOle == 0 )
    {
        RegStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\OLE",
                        0,
                        "REG_SZ",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hRegOle,
                        &Disposition );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Could not open HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\OLE for writing\n" );
            return FALSE;
        }
    }

    // TODO : Extra stuff to do for PersonalClasses and InstallCommon.

    if ( (Key == DEFAULT_LAUNCH_PERMISSION) ||
         (Key == DEFAULT_ACCESS_PERMISSION) )
    {
        RegStatus = RegCreateKeyEx(
                        hRegOle,
                        GlobalKeyNames[Key],
                        0,
                        "REG_SZ",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hReg,
                        &Disposition );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Unable to open or add global key %s (status %d)\n",
                    GlobalKeyNames[Key],
                    RegStatus );
            return FALSE;
        }

        ValueName = NULL;
    }
    else
    {
        hReg = hRegOle;
        ValueName = (char *)GlobalKeyNames[Key];
    }

    if ( Key == LEGACY_AUTHENTICATION_LEVEL )
    {
        RegStatus = RegSetValueEx(
                        hReg,
                        ValueName,
                        0,
                        REG_DWORD,
                        (LPBYTE)&Value,
                        sizeof(DWORD) );
    }
    else if ( Key != DEFAULT_ACCESS_PERMISSION )
    {
        RegStatus = RegSetValueEx(
                        hReg,
                        ValueName,
                        0,
                        REG_SZ,
                        (LPBYTE)(Value == YES ? "Y" : "N"),
                        2 * sizeof(char) );
    }
    else
        RegStatus = ERROR_SUCCESS;

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Unable to set value for %s (status %d)\n",
                GlobalKeyNames[Key],
                RegStatus );
        return FALSE;
    }

    if ( Key == LEGACY_AUTHENTICATION_LEVEL )
    {
        printf( "Global setting %s set to %d.\n",
                GlobalKeyNames[Key],
                Value );
    }
    else if ( Key == DEFAULT_ACCESS_PERMISSION )
    {
        printf( "Global setting %s set to on.\n",
                GlobalKeyNames[Key] );
    }
    else
    {
        printf( "Global setting %s set to %c.\n",
                GlobalKeyNames[Key],
                Value == YES ? 'Y' : 'N' );
    }

    return TRUE;
}

void DisplayGlobalSettings()
{
    HKEY    hReg;
    DWORD   RegStatus;
    int     Key;
    DWORD   Type;
    DWORD   Value;
    DWORD   BufSize;
    char *  ValueName;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "SOFTWARE\\Microsoft\\OLE",
                    0,
                    KEY_READ,
                    &hRegOle );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not open HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\OLE\n" );
        return;
    }

    printf( "\nGlobal OLE registry settings :\n" );

    for ( Key = 1; Key <= GLOBAL_KEYS; Key++ )
    {
        if ( (Key == DEFAULT_LAUNCH_PERMISSION) ||
             (Key == DEFAULT_ACCESS_PERMISSION) )
        {
            RegStatus = RegOpenKeyEx(
                            hRegOle,
                            GlobalKeyNames[Key],
                            0,
                            KEY_READ,
                            &hReg );

            if ( RegStatus != ERROR_SUCCESS )
            {
                printf( "    %-28sN (key does not exist or could not be opened)\n",
                        GlobalKeyNames[Key] );
                continue;
            }

            ValueName = NULL;
        }
        else
        {
            hReg = hRegOle;
            ValueName = (char *)GlobalKeyNames[Key];
        }

        if ( Key != DEFAULT_ACCESS_PERMISSION )
        {
            BufSize = sizeof(DWORD);

            RegStatus = RegQueryValueEx(
                            hReg,
                            ValueName,
                            0,
                            &Type,
                            (LPBYTE) &Value,
                            &BufSize );
        }
        else
            RegStatus = ERROR_SUCCESS;

        if ( RegStatus != ERROR_SUCCESS )
        {
            if ( Key == DEFAULT_LAUNCH_PERMISSION )
                printf( "    %-28sN (key value could not be read)\n",
                        GlobalKeyNames[Key] );
            else
                printf( "    %-28s%c (value not present)\n",
                        GlobalKeyNames[Key],
                        (Key == LEGACY_AUTHENTICATION_LEVEL) ? '2' : 'N' );
            continue;
        }

        if ( Key == LEGACY_AUTHENTICATION_LEVEL )
        {
            printf( "    %-28s%d\n",
                    GlobalKeyNames[Key],
                    Value );
        }
        else if ( Key == DEFAULT_ACCESS_PERMISSION )
        {
            printf( "    %-28son\n",
                    GlobalKeyNames[Key] );
        }
        else
        {
            printf( "    %-28s%c\n",
                    GlobalKeyNames[Key],
                    (char)CharUpper((LPSTR)((char *)&Value)[0]) );
        }
    }
}

void DisplayClsidKeys(
    CLSID_INFO * ClsidInfo )
{
    HKEY                    hProgId;
    HKEY                    hClsid;
    HKEY                    hProgIdClsid;
    HKEY                    hKey;
    DWORD                   RegStatus;
    DWORD                   RegType;
    DWORD                   BufSize;
    char                    ProgIdClsid[64];
    char                    Value[128];
    int                     Key;
    BOOL                    HasRunAs;
    char                    Password[64];
    LSA_HANDLE              hPolicy;
    LSA_OBJECT_ATTRIBUTES   ObjAttributes;
    LSA_UNICODE_STRING      LsaKey;
    LSA_UNICODE_STRING *    LsaData;
    WCHAR                   wszKey[64];
    WCHAR                   wszPassword[64];
    NTSTATUS                NtStatus;

    RegStatus = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_READ,
                    &hRegClsid );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not open HKEY_CLASSES_ROOT\\CLSID for reading.\n" );
        return;
    }

    if ( ClsidInfo->ProgId )
    {
        RegStatus = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        ClsidInfo->ProgId,
                        0,
                        KEY_READ,
                        &hProgId );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Couldn't open ProgID %s\n", ClsidInfo->ProgId );
            return;
        }

        RegStatus = RegOpenKeyEx(
                        hProgId,
                        "CLSID",
                        0,
                        KEY_READ,
                        &hProgIdClsid );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Couldn't open CLSID key for ProgID %s\n", ClsidInfo->ProgId );
            return;
        }

        BufSize = sizeof(ProgIdClsid);

        RegStatus = RegQueryValueEx(
                        hProgIdClsid,
                        NULL,
                        0,
                        &RegType,
                        (LPBYTE) ProgIdClsid,
                        &BufSize );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Couldn't open CLSID value for ProgID %s\n", ClsidInfo->ProgId );
            return;
        }

        if ( ClsidInfo->Clsid &&
             (_stricmp( ClsidInfo->Clsid, ProgIdClsid ) != 0) )
        {
            printf( "ProgID %s CLSID key value %s differs from given CLSID %s.\n",
                    ClsidInfo->ProgId,
                    ProgIdClsid,
                    ClsidInfo->Clsid );
            return;
        }
        else
            ClsidInfo->Clsid = ProgIdClsid;
    }


    if ( ! ClsidInfo->Clsid )
    {
        printf( "Could not determine CLSID.\n" );
        return;
    }

    RegStatus = RegOpenKeyEx(
                    hRegClsid,
                    ClsidInfo->Clsid,
                    0,
                    KEY_READ,
                    &hClsid );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not open CLSID %s\n", ClsidInfo->Clsid );
        return;
    }

    putchar( '\n' );
    if ( ClsidInfo->ProgId )
        printf( "Server settings for ProgID %s, ", ClsidInfo->ProgId );
    else
        printf( "Server settings for " );

    printf( "CLSID %s\n", ClsidInfo->Clsid );

    HasRunAs = FALSE;

    for ( Key = 1; Key <= CLSID_KEYS; Key++ )
    {
        RegStatus = RegOpenKeyEx(
                        hClsid,
                        ClsidKeyNames[Key],
                        0,
                        KEY_READ,
                        &hKey );

        if ( RegStatus != ERROR_SUCCESS )
            continue;

        BufSize = sizeof(Value);

        if ( Key != ACCESS_PERMISSION )
        {
            RegStatus = RegQueryValueEx(
                            hKey,
                            NULL,
                            0,
                            &RegType,
                            (LPBYTE) Value,
                            &BufSize );
        }
        else
            RegStatus = ERROR_SUCCESS;

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "    %-28s(key exists, but value could not be read)\n",
                    ClsidKeyNames[Key] );
            continue;
        }

        printf( "    %-28s%s\n",
                ClsidKeyNames[Key],
                (Key == ACCESS_PERMISSION) ? "on" : Value );

        if ( (Key == RUN_AS) && (_stricmp(Value,"Interactive User") != 0) )
            HasRunAs = TRUE;
    }

    if ( ! HasRunAs )
        return;

    //
    // Give the option of verifying the RunAs password.
    //

    printf( "\nCLSID configured with RunAs.  Would you like to verify the password? " );

    if ( (char)CharUpper((LPSTR)UIntToPtr(getchar())) != 'Y' )
        return;

    while ( getchar() != '\n' )
        ;

    putchar( '\n' );

    lstrcpyW( wszKey, L"SCM:" );
    MultiByteToWideChar( CP_ACP,
                         MB_PRECOMPOSED,
                         ClsidInfo->Clsid,
                         -1,
                         &wszKey[lstrlenW(wszKey)],
                         sizeof(wszKey)/2 - lstrlenW(wszKey) );

    LsaKey.Length = (USHORT)((lstrlenW(wszKey) + 1) * sizeof(WCHAR));
    LsaKey.MaximumLength = sizeof(wszKey);
    LsaKey.Buffer = wszKey;

    InitializeObjectAttributes( &ObjAttributes, NULL, 0L, NULL, NULL );

    // Open the local security policy
    NtStatus = LsaOpenPolicy( NULL,
                              &ObjAttributes,
                              POLICY_CREATE_SECRET,
                              &hPolicy );

    if ( ! NT_SUCCESS( NtStatus ) )
    {
        printf( "Could not open RunAs password (0x%x)\n", NtStatus );
        return;
    }

    // Retrive private data
    NtStatus = LsaRetrievePrivateData( hPolicy, &LsaKey, &LsaData );

    if ( ! NT_SUCCESS(NtStatus) )
    {
        printf( "Could not open RunAs password (0x%x)\n", NtStatus );
        return;
    }

    LsaClose(hPolicy);

    for (;;)
    {
        printf( "Password : " );
        ReadPassword( Password );

        if ( strcmp( Password, "dcom4ever" ) == 0 )
        {
            printf( "\nThe RunAs password is %ws\n", LsaData->Buffer );
            return;
        }

        MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             Password,
                             -1,
                             wszPassword,
                             sizeof(wszPassword) / sizeof(WCHAR) );

        if ( lstrcmpW( wszPassword, LsaData->Buffer ) != 0 )
        {
            printf( "\nPassword does not match RunAs password.\n" );
            printf( "Enter another password or hit Control-C to exit.\n\n" );
        }
        else
        {
            printf( "\nPasswords match.\n" );
            return;
        }
    }
}

void UpdateClsidKeys( CLSID_INFO * ClsidInfo )
{
    HKEY    hProgId;
    HKEY    hClsid;
    HKEY    hProgIdClsid;
    HKEY    hKey;
    DWORD   RegStatus;
    DWORD   Disposition;
    DWORD   RegType;
    char    ProgIdClsid[64];
    char    Response[64];
    DWORD   BufSize;
    int     n;

    RegStatus = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hRegClsid );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not open HKEY_CLASSES_ROOT\\CLSID for writing\n" );
        return;
    }

    hProgId = 0;
    hClsid = 0;

    if ( ClsidInfo->ProgId )
    {
        RegStatus = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        ClsidInfo->ProgId,
                        0,
                        "REG_SZ",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hProgId,
                        &Disposition );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Could not open or create ProgID key %s.\n",
                    ClsidInfo->ProgId);
            return;
        }

        if ( Disposition == REG_CREATED_NEW_KEY )
            printf( "ProgId key %s created.\n", ClsidInfo->ProgId );

        if ( ClsidInfo->ProgIdDescription )
        {
            RegStatus = RegSetValueEx(
                            hProgId,
                            NULL,
                            0,
                            REG_SZ,
                            (LPBYTE) ClsidInfo->ProgIdDescription,
                            strlen(ClsidInfo->ProgIdDescription) + sizeof(char) );

            if ( RegStatus != ERROR_SUCCESS )
            {
                printf( "Could not set description value for ProgID %s.\n", ClsidInfo->ProgId );
                return;
            }

            printf( "Setting description value %s for ProgID %s.\n",
                    ClsidInfo->ProgIdDescription,
                    ClsidInfo->ProgId );
        }

        RegStatus = RegCreateKeyEx(
                        hProgId,
                        "CLSID",
                        0,
                        "REG_SZ",
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hProgIdClsid,
                        &Disposition );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Could not open or create CLSID key for ProgID %s.\n",
                    ClsidInfo->ProgId );
            return;
        }

        //
        // Check if a CLSID key value already exists for this ProgID.  If so,
        // and a CLSID was specified to us then check if they differ.
        //

        BufSize = sizeof(ProgIdClsid);

        RegStatus = RegQueryValueEx(
                        hProgIdClsid,
                        NULL,
                        0,
                        &RegType,
                        (LPBYTE) ProgIdClsid,
                        &BufSize );

        if ( RegStatus == ERROR_SUCCESS )
        {
            if ( ClsidInfo->Clsid &&
                 (_stricmp(ClsidInfo->Clsid, ProgIdClsid) != 0) )
            {
                printf( "ProgID %s has existing CLSID key value %s\n",
                        ClsidInfo->ProgId,
                        ProgIdClsid );
                printf( "which differs from given CLSID %s.\n",
                        ClsidInfo->Clsid );
                printf( "Would you like to replace the existing CLSID value with the new CLSID value? " );
                gets( Response );
                if ( (char)CharUpper((LPSTR)Response[0]) != 'Y' )
                    ClsidInfo->Clsid = ProgIdClsid;
            }
            else
                ClsidInfo->Clsid = ProgIdClsid;
        }

        if ( ! ClsidInfo->Clsid )
        {
            printf( "CLSID for ProgID %s not specified.\n",
                    ClsidInfo->ProgId );
            return;
        }

        if ( ClsidInfo->Clsid != ProgIdClsid )
        {
            RegStatus = RegSetValueEx(
                            hProgIdClsid,
                            NULL,
                            0,
                            REG_SZ,
                            (LPBYTE) ClsidInfo->Clsid,
                            strlen(ClsidInfo->Clsid) + sizeof(char) );

            if ( RegStatus != ERROR_SUCCESS )
            {
                printf( "Could not set CLSID value for ProgID %s.\n", ClsidInfo->ProgId );
                return;
            }

            printf( "Setting CLSID value %s for ProgID %s.\n",
                    ClsidInfo->Clsid,
                    ClsidInfo->ProgId );
        }
    }

    RegStatus = RegCreateKeyEx(
                    hRegClsid,
                    ClsidInfo->Clsid,
                    0,
                    "REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hClsid,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not open or create CLSID key %s.\n", ClsidInfo->Clsid );
        return;
    }

    if ( Disposition == REG_CREATED_NEW_KEY )
        printf( "CLSID key %s created.\n", ClsidInfo->Clsid );

    if ( ClsidInfo->ClsidDescription )
    {
        RegStatus = RegSetValueEx(
                        hClsid,
                        NULL,
                        0,
                        REG_SZ,
                        (LPBYTE) ClsidInfo->ClsidDescription,
                        strlen(ClsidInfo->ClsidDescription) + sizeof(char) );

        if ( RegStatus != ERROR_SUCCESS )
        {
            printf( "Could not set description value for CLSID %s.\n", ClsidInfo->Clsid );
            return;
        }

        printf( "Setting description value %s for CLSID %s.\n",
                ClsidInfo->ClsidDescription,
                ClsidInfo->Clsid );
    }

    //
    // Now add and delete individual keys on this CLSID.
    //

    if ( (ClsidInfo->LaunchPermission == YES) ||
         (ClsidInfo->LaunchPermission == NO) )
    {
        SetClsidKey( hClsid,
                     ClsidInfo->Clsid,
                     ClsidKeyNames[LAUNCH_PERMISSION],
                     (ClsidInfo->LaunchPermission == YES) ? "Y" : "N" );
    }

    if ( ClsidInfo->AccessPermission == YES )
    {
        SetClsidKey( hClsid,
                     ClsidInfo->Clsid,
                     ClsidKeyNames[ACCESS_PERMISSION],
                     NULL );
    }

    if ( (ClsidInfo->ActivateAtStorage == YES) ||
         (ClsidInfo->ActivateAtStorage == NO) )
    {
        SetClsidKey( hClsid,
                     ClsidInfo->Clsid,
                     ClsidKeyNames[ACTIVATE_AT_STORAGE],
                     (ClsidInfo->ActivateAtStorage == YES) ? "Y" : "N" );
    }

    for ( n = 1; n <= CLSID_PATH_KEYS; n++ )
    {
        if ( ! ClsidInfo->ServerPaths[n] )
            continue;
        if ( ClsidInfo->ServerPaths[n][0] == '\0' )
            DeleteClsidKey( hClsid,
                            ClsidInfo->Clsid,
                            ClsidKeyNames[n] );
        else
            SetClsidKey( hClsid,
                         ClsidInfo->Clsid,
                         ClsidKeyNames[n],
                         ClsidInfo->ServerPaths[n] );
    }

    if ( ClsidInfo->RemoteServerName )
    {
        if ( ClsidInfo->RemoteServerName[0] == '\0' )
            DeleteClsidKey( hClsid,
                            ClsidInfo->Clsid,
                            ClsidKeyNames[REMOTE_SERVER_NAME] );
        else
            SetClsidKey( hClsid,
                         ClsidInfo->Clsid,
                         ClsidKeyNames[REMOTE_SERVER_NAME],
                         ClsidInfo->RemoteServerName );
    }

    if ( ClsidInfo->RunAsUserName )
    {
        DWORD                   CharRead;
        char                    Password1[64];
        char                    Password2[64];
        LSA_HANDLE              hPolicy;
        LSA_OBJECT_ATTRIBUTES   ObjAttributes;
        LSA_UNICODE_STRING      LsaKey;
        LSA_UNICODE_STRING      LsaData;
        WCHAR                   wszKey[64];
        WCHAR                   wszPassword[64];
        NTSTATUS                NtStatus;
        BOOL                    Status;
        BOOL                    RunAsInteractiveUser;

        RunAsInteractiveUser = (_stricmp(ClsidInfo->RunAsUserName,"Interactive User") == 0);

        if ( ! RunAsInteractiveUser )
        {
            InitializeObjectAttributes( &ObjAttributes, NULL, 0L, NULL, NULL );

            // Open the local security policy
            NtStatus = LsaOpenPolicy( NULL,
                                      &ObjAttributes,
                                      POLICY_CREATE_SECRET,
                                      &hPolicy );

            if ( ! NT_SUCCESS( NtStatus ) )
            {
                printf( "Could not setup RunAs (0x%x)\n", NtStatus );
                return;
            }

            lstrcpyW( wszKey, L"SCM:" );
            MultiByteToWideChar( CP_ACP,
                                 MB_PRECOMPOSED,
                                 ClsidInfo->Clsid,
                                 -1,
                                 &wszKey[lstrlenW(wszKey)],
                                 sizeof(wszKey)/2 - lstrlenW(wszKey) );

            LsaKey.Length = (USHORT)((lstrlenW(wszKey) + 1) * sizeof(WCHAR));
            LsaKey.MaximumLength = sizeof(wszKey);
            LsaKey.Buffer = wszKey;
        }

        if ( ClsidInfo->RunAsUserName[0] == '\0' )
        {
            DeleteClsidKey( hClsid,
                            ClsidInfo->Clsid,
                            ClsidKeyNames[RUN_AS] );

            LsaStorePrivateData( hPolicy, &LsaKey, NULL );
        }
        else
        {
            Status = SetClsidKey( hClsid,
                                  ClsidInfo->Clsid,
                                  ClsidKeyNames[RUN_AS],
                                  ClsidInfo->RunAsUserName );

            if ( ! Status )
                return;

            if ( ! RunAsInteractiveUser && (ClsidInfo->RunAsPassword[0] == '*') )
            {
                for (;;)
                {
                    printf( "Enter RunAs password for %s : ", ClsidInfo->RunAsUserName );
                    ReadPassword( Password1 );

                    printf( "Confirm password : " );
                    ReadPassword( Password2 );

                    if ( strcmp( Password1, Password2 ) != 0 )
                    {
                        printf( "Passwords differ, try again or hit Control-C to exit.\n" );
                        continue;
                    }

                    if ( Password1[0] == '\0' )
                    {
                        printf( "Do you really want a blank password? " );
                        gets( Response );
                        if ( (char)CharUpper((LPSTR)Response[0]) != 'Y' )
                            continue;
                    }

                    break;
                }

                ClsidInfo->RunAsPassword = Password1;
            } // if password == "*"

            // Got a good one!

            if ( ! RunAsInteractiveUser )
            {
                MultiByteToWideChar( CP_ACP,
                                     MB_PRECOMPOSED,
                                     ClsidInfo->RunAsPassword,
                                     -1,
                                     wszPassword,
                                     sizeof(wszPassword)/2 );

                LsaData.Length = (USHORT)((lstrlenW(wszPassword) + 1) * sizeof(WCHAR));
                LsaData.MaximumLength = sizeof(wszPassword);
                LsaData.Buffer = wszPassword;

                // Store private data
                NtStatus = LsaStorePrivateData( hPolicy, &LsaKey, &LsaData );

                if ( ! NT_SUCCESS(NtStatus) )
                {
                    printf( "Could not store password securely (0x%x)\n", NtStatus );
                    return;
                }

                LsaClose(hPolicy);
            }
        }
    }

    printf( "CLSID keys updated successfully.\n" );
}

BOOL SetClsidKey(
    HKEY            hClsid,
    char *          Clsid,
    const char *    Key,
    char *          Value )
{
    HKEY    hKey;
    DWORD   RegStatus;
    DWORD   Disposition;
    DWORD   ValueType;
    DWORD   ValueSize;
    char    OldValue[256];
    BOOL    HasOldValue;

    HasOldValue = FALSE;

    RegStatus = RegCreateKeyEx(
                    hClsid,
                    Key,
                    0,
                    "REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not create key %s for CLSID %s\n", Key, Clsid );
        return FALSE;
    }

    if ( Disposition == REG_CREATED_NEW_KEY )
    {
        printf( "Added key %s for CLSID %s\n", Key, Clsid );
    }
    else
    {
        ValueSize = sizeof(OldValue);

        RegStatus = RegQueryValueEx(
                        hKey,
                        NULL,
                        0,
                        &ValueType,
                        OldValue,
                        &ValueSize );

        HasOldValue = (RegStatus == ERROR_SUCCESS);
    }

    if ( ! Value )
        return TRUE;

    RegStatus = RegSetValueEx(
                    hKey,
                    NULL,
                    0,
                    REG_SZ,
                    (LPBYTE) Value,
                    strlen(Value) + sizeof(char) );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not set value %s for key %s\n", Value, Key );
        return FALSE;
    }

    if ( HasOldValue )
        printf( "Changed value from %s to %s for key %s\n", OldValue, Value, Key );
    else
        printf( "Added value %s for key %s\n", Value, Key );

    return TRUE;
}

BOOL DeleteClsidKey(
    HKEY            hClsid,
    char *          Clsid,
    const char *    Key )
{
    DWORD   RegStatus;

    RegStatus = RegDeleteKey( hClsid, Key );

    if ( RegStatus != ERROR_SUCCESS )
    {
        printf( "Could not delete key %s for CLSID %s\n", Key, Clsid );
        return FALSE;
    }

    printf( "Deleted key %s for CLSID %s\n", Key, Clsid );
    return TRUE;
}

void ReadPassword( char * Password )
{
    int c, n;

    n = 0;

    for (;;)
    {
         c = _getch();

         // ^C
         if ( c == 0x3 )
         {
             putchar( '\n' );
             ExitProcess( 0 );
         }

         // Backspace
         if ( c == 0x8 )
         {
             if ( n )
             {
                n--;
                _putch( 0x8 );
                _putch( ' ' );
                _putch( 0x8 );
             }
             continue;
         }

         // Return
         if ( c == '\r' )
             break;

         Password[n++] = (char) c;
         _putch( '*' );
    }

    Password[n] = 0;
    putchar( '\n' );
}

BOOL ControlCConsoleHandler( DWORD ControlType )
{
    if ( (ControlType == CTRL_C_EVENT) || (ControlType == CTRL_BREAK_EVENT) )
    {
        printf( "RunAs password unchanged\n" );
        ExitProcess( 0 );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\olecnfg.h ===
//
//
//

#ifndef _OLECONFIG_
#define _OLECONFIG_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#define ENABLE_NETWORK_OLE          1
#define DEFAULT_LAUNCH_PERMISSION   2
#define DEFAULT_ACCESS_PERMISSION   3
#define LEGACY_AUTHENTICATION_LEVEL 4

#define GLOBAL_KEYS                 4

#define MERGE                       101
#define SAVE_USER                   102
#define SAVE_COMMON                 103

#define GLOBAL_OPERATIONS           103

#define INPROC_HANDLER32            1
#define INPROC_SERVER32             2
#define LOCAL_SERVER32              3
#define LOCAL_SERVICE               4
#define REMOTE_SERVER_NAME          5
#define RUN_AS                      6
#define ACTIVATE_AT_STORAGE         7
#define LAUNCH_PERMISSION           8
#define ACCESS_PERMISSION           9

#define CLSID_KEYS                  9
#define CLSID_PATH_KEYS             4

#define UNKNOWN                     0
#define END_OF_ARGS                 -1

#define INVALID                     -1
#define NO                          1
#define YES                         2

#define EAT_ARG()                   Args++; ArgsLeft--;

typedef struct
    {
    char *  Clsid;
    char *  ClsidDescription;
    char *  ProgId;
    char *  ProgIdDescription;

    int     LaunchPermission;
    int     AccessPermission;
    int     ActivateAtStorage;

    char *  ServerPaths[CLSID_PATH_KEYS+1];
    char *  RemoteServerName;
    char *  RunAsUserName;
    char *  RunAsPassword;
    } CLSID_INFO;

extern const char * GlobalKeyNames[];
extern const char * ClsidKeyNames[];

extern int      ArgsLeft;
extern char **  Args;
extern char *   ProgramName;

extern HKEY     hRegOle;
extern HKEY     hRegClsid;

// main.c
void ParseClsidProgId();
int NextClsidKey();
int ReadYesOrNo();
void DisplayHelp();

// oleconfig.c
BOOL SetGlobalKey(
    int Key,
    int Value );

void DisplayGlobalSettings();

void DisplayClsidKeys(
    CLSID_INFO * ClsidInfo );

void UpdateClsidKeys(
    CLSID_INFO * ClsidInfo );

BOOL SetClsidKey(
    HKEY hClsid,
    char * Clsid,
    const char * Key,
    char * Value );

BOOL DeleteClsidKey(
    HKEY hClsid,
    char * Clsid,
    const char * Key );

void ReadPassword(
    char * Password );

BOOL ControlCConsoleHandler(
    DWORD ControlType );

void MergeHives( );

void SaveChangesToUser( );

void SaveChangesToCommon( );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnfg\treemgmt.c ===
//*************************************************************
//
//  Personal Classes Profile management routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "windows.h"

// Local Data Structures

LPTSTR SpecialSubtrees[] = 
    {
    TEXT("CLSID"),
    TEXT("Interface"),
    TEXT("TypeLib"),
    TEXT("Licenses"),
    TEXT("FileType")
    };

#define MAX_SPECIAL_SUBTREE (sizeof(SpecialSubtrees)/sizeof(LPTSTR))
//
// Local function proto-types
//
typedef struct _RegKeyInfo {
	DWORD	SubKeyCount;
	DWORD	MaxSubKeyLen;
	DWORD	ValueCount;
	DWORD	MaxValueNameLen;
	DWORD	MaxValueLen;
	DWORD	SDLen;
	LPTSTR	pSubKeyName;
	LPTSTR	pValueName;
	LPTSTR	pValue;
    } REGKEYINFO, *PREGKEYINFO;

//*************************************************************
//
//  PrepForEnumRegistryTree()
//
//  Purpose:    prepare to duplicate a source bunch of keys into the destination.
//
//  Parameters: hkSourceTree   - source registry tree
//		pRegKeyInfo    - info block for use doing enumeration
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              1/30/96     GregJen    Created
//
//*************************************************************
BOOL
PrepForEnumRegistryTree( 
    HKEY hkSourceTree, 
    PREGKEYINFO pRegKeyInfo
    )
{
    LPTSTR  pStringsBuffer;
    LONG    result;

    result = RegQueryInfoKey(hkSourceTree, 
			     NULL, 
			     NULL,
			     0,
			     &pRegKeyInfo->SubKeyCount,
			     &pRegKeyInfo->MaxSubKeyLen,
			     NULL,
			     &pRegKeyInfo->ValueCount,
			     &pRegKeyInfo->MaxValueNameLen,
			     &pRegKeyInfo->MaxValueLen,
			     &pRegKeyInfo->SDLen,
			     NULL);

    if ( result != ERROR_SUCCESS )
	return FALSE;

    // allocate a block of memory to use for enumerating subkeys and values
    pStringsBuffer = (LPTSTR) LocalAlloc( LPTR, 
					  (pRegKeyInfo->MaxSubKeyLen +
					      pRegKeyInfo->MaxValueNameLen +
					      pRegKeyInfo->MaxValueLen + 3)
					      * sizeof( TCHAR ) );
    if ( !pStringsBuffer )
	return FALSE;

    pRegKeyInfo->pSubKeyName	= pStringsBuffer;
    pRegKeyInfo->pValueName	= pStringsBuffer + pRegKeyInfo->MaxSubKeyLen + 1;
    pRegKeyInfo->pValue		= pRegKeyInfo->pValueName + 
					pRegKeyInfo->MaxValueNameLen + 1;

    return TRUE;
}

//*************************************************************
//
//  CleanupAfterEnumRegistryTree()
//
//  Purpose:    duplicate a source bunch of keys into the destination.
//
//  Parameters: hkSourceTree   - source registry tree
//		pRegKeyInfo    - info block for use doing enumeration
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              1/30/96     GregJen    Created
//
//*************************************************************
void
CleanupAfterEnumRegistryTree(
    HKEY hkSourceTree, 
    PREGKEYINFO pRegKeyInfo)
{
    LocalFree( pRegKeyInfo->pSubKeyName );
}
BOOL
DeleteRegistrySubtree (
    HKEY    hkTree )
{
    HKEY hkCurrentSourceKey;
    DWORD idx;
    DWORD   NameLen;
    LONG    result  = ERROR_SUCCESS;
    REGKEYINFO RegKeyInfo;
    BOOL    Success = FALSE;

    if ( !PrepForEnumRegistryTree( hkTree, &RegKeyInfo ) )
	return FALSE;  // nothing to clean up here yet

    // enumerate all the source subkeys
    // for each: if dest subkey is older than source, delete it
    //		 if dest subkey does not exist (or was deleted) clone the subkey
    //
    // Clone all the subkeys
    //
    for ( idx = 0; 
          (result == ERROR_SUCCESS) && 
	      ( result != ERROR_MORE_DATA ) && 
	      ( idx < RegKeyInfo.SubKeyCount ); 
	  idx++ ) {
	NameLen = RegKeyInfo.MaxSubKeyLen + sizeof( TCHAR );
	result = RegEnumKeyEx( hkTree, 
			       idx,
			       RegKeyInfo.pSubKeyName,
			       &NameLen,
			       NULL,
			       NULL,
			       NULL,
			       NULL );
        
        if ( ( result != ERROR_SUCCESS ) && ( result != ERROR_MORE_DATA ) )
	    goto cleanup;

	// TBD: open the subkey in the source tree AS CurrentSourceKey
	result = RegOpenKeyEx(hkTree,
			      RegKeyInfo.pSubKeyName,
			      0,
			      KEY_ALL_ACCESS,
			      &hkCurrentSourceKey);

	DeleteRegistrySubtree( hkCurrentSourceKey );
	
	RegCloseKey( hkCurrentSourceKey );

	RegDeleteKey( hkTree, RegKeyInfo.pSubKeyName );
	
	result = ERROR_SUCCESS;
    }

cleanup:
    CleanupAfterEnumRegistryTree( hkTree, &RegKeyInfo );

    return TRUE;
}

//*************************************************************
//
//  CloneRegistryValues()
//
//  Purpose:    copy the values from under the source key to the dest key
//
//  Parameters: SourceTree   -  source registry tree
//              DestinationTree -  destintation registry tree
//              RegKeyInfo -  handy information from the RegEnumKeyEx call.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              1/14/96     GregJen    Created
//
//*************************************************************
BOOL
CloneRegistryValues( 
    HKEY hkSourceTree, 
    HKEY hkDestinationTree,
    REGKEYINFO RegKeyInfo )
{
    LONG    result  = ERROR_SUCCESS;
    DWORD   idx;
    DWORD   ValueLen;
    DWORD   ValueType;
    DWORD   DataLen;

    for ( idx = 0; 
          (result == ERROR_SUCCESS) && 
	      ( result != ERROR_MORE_DATA ) && 
	      ( idx < RegKeyInfo.ValueCount ); 
	  idx++ ) 
    {
	DataLen	    = RegKeyInfo.MaxValueLen + sizeof( TCHAR );
	ValueLen    = RegKeyInfo.MaxValueNameLen + sizeof( TCHAR );

        result = RegEnumValue( hkSourceTree,
			       idx,
			       RegKeyInfo.pValueName,
			       &ValueLen,
			       NULL,
			       &ValueType,
			       (BYTE*) RegKeyInfo.pValue,
			       &DataLen);

	// TBD: check errors

    	// now add the value to the destination key

	result = RegSetValueEx( hkDestinationTree,
				RegKeyInfo.pValueName,
				0,
				ValueType,
				(BYTE*) RegKeyInfo.pValue,
				DataLen );
	// TBD: check errors
    }
    return TRUE;
}
//*************************************************************
//
//  CloneRegistryTree()
//
//  Purpose:    duplicate a source bunch of keys into the destination.
//
//  Parameters: SourceTree   -  source registry tree
//              DestinationTree -  destintation registry tree
//              lpSubKeyName -  if present this is a subkey name that
//                              corresponds to the SourceTree HKEY.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              1/14/96     GregJen    Created
//
//*************************************************************
BOOL
CloneRegistryTree( 
    HKEY hkSourceTree, 
    HKEY hkDestinationTree, 
    LPTSTR lpDestTreeName )
{
    HKEY hkCurrentSourceKey;
    DWORD idx;
    DWORD   NameLen;
    LONG    result  = ERROR_SUCCESS;
    REGKEYINFO RegKeyInfo;
    BOOL    Success = FALSE;

    if ( !PrepForEnumRegistryTree( hkSourceTree, &RegKeyInfo ) )
	return FALSE;  // nothing to clean up here yet

    if ( lpDestTreeName ) {
	HKEY			hkNewKey = NULL;
	DWORD			dwSDLen = RegKeyInfo.SDLen;
	DWORD			dwDisp;
	SECURITY_INFORMATION	SI  = DACL_SECURITY_INFORMATION; // for now...
	PSECURITY_DESCRIPTOR	pSD = (PSECURITY_DESCRIPTOR)
					LocalAlloc( LPTR, dwSDLen );
	// TBD: check for NULL;

        // Get the registry security information from the old key
	result = RegGetKeySecurity( hkSourceTree,
				    SI,
				    pSD,
				    &dwSDLen);
	// TBD: check for errors, free pSD
        // create a key with the given name, and registry info
	result = RegCreateKeyEx( hkDestinationTree,
				 lpDestTreeName,
				 0,
				 NULL,
				 REG_OPTION_NON_VOLATILE,
				 KEY_ALL_ACCESS,
				 pSD,
				 &hkNewKey,
				 &dwDisp );
	// TBD: check for errors, free pSD

	// TBD: and update the hkDestinationTree variable to point to it
	
	hkDestinationTree = hkNewKey;
	LocalFree( pSD );
	if (ERROR_SUCCESS != result) 
	{
	   goto cleanup;
	}
    }
    
    //
    // clone the values
    //
    
    if ( ! CloneRegistryValues( hkSourceTree, hkDestinationTree, RegKeyInfo ) )
	goto cleanup;

    //
    // Clone all the subkeys
    //
    for ( idx = 0; 
          (result == ERROR_SUCCESS) && 
	      ( result != ERROR_MORE_DATA ) && 
	      ( idx < RegKeyInfo.SubKeyCount ); 
	  idx++ ) {
	NameLen = RegKeyInfo.MaxSubKeyLen + sizeof( TCHAR );
	result = RegEnumKeyEx( hkSourceTree, 
			       idx,
			       RegKeyInfo.pSubKeyName,
			       &NameLen,
			       NULL,
			       NULL,
			       NULL,
			       NULL );
        
        if ( ( result != ERROR_SUCCESS ) && ( result != ERROR_MORE_DATA ) )
	    goto cleanup;

	// TBD: open the subkey in the source tree AS CurrentSourceKey
	result = RegOpenKeyEx(hkSourceTree,
			      RegKeyInfo.pSubKeyName,
			      0,
			      KEY_READ,
			      &hkCurrentSourceKey);
	
	//
	// recurse passing the subkey name
	//
        CloneRegistryTree( hkCurrentSourceKey, 
	                   hkDestinationTree, 
			   RegKeyInfo.pSubKeyName );

	//
	// close our open key
	//

	RegCloseKey( hkCurrentSourceKey );
    }

    Success = TRUE;

cleanup:
    if ( lpDestTreeName ) 
    {
	RegCloseKey( hkDestinationTree );
    }
    
    CleanupAfterEnumRegistryTree( hkSourceTree, &RegKeyInfo );

    return Success;
}

void SaveChangesToUser( )
{
}

void SaveChangesToCommon( )
{
}

BOOL
AddSharedValuesToSubkeys( HKEY hkShared, LPTSTR pszSubtree )
{
    HKEY    hkSourceKey;
    HKEY    hkCurrentSourceKey;
    DWORD idx;
    DWORD   NameLen;
    LONG    result  = ERROR_SUCCESS;
    REGKEYINFO RegKeyInfo;
    BOOL    Success = FALSE;


    // for every subkey, set "Shared" value 
    result = RegOpenKeyEx( hkShared,
			   pszSubtree,
			   0,
			   KEY_READ,
			   &hkSourceKey );

    // TBD: if no subtree in source, skip ahead to next special subtree
    if ( result == ERROR_FILE_NOT_FOUND )
	return TRUE;
	
    // If any other errors occurred, return FALSE
    if ( result != ERROR_SUCCESS)
        return FALSE;

    if ( !PrepForEnumRegistryTree( hkSourceKey, &RegKeyInfo ) )
	goto cleanup2;

    // enumerate all the source subkeys
    // for each: if dest subkey is older than source, delete it
    //		 if dest subkey does not exist (or was deleted) clone the subkey
    //
    // Clone all the subkeys
    //
    for ( idx = 0; 
          (result == ERROR_SUCCESS) && 
	      ( result != ERROR_MORE_DATA ) && 
	      ( idx < RegKeyInfo.SubKeyCount ); 
	  idx++ ) 
    {
	NameLen = RegKeyInfo.MaxSubKeyLen + sizeof( TCHAR );
	result = RegEnumKeyEx( hkSourceKey, 
			       idx,
			       RegKeyInfo.pSubKeyName,
			       &NameLen,
			       NULL,
			       NULL,
			       NULL,
			       NULL );
        
        if ( ( result != ERROR_SUCCESS ) && ( result != ERROR_MORE_DATA ) )
	    goto cleanup;

	result = RegOpenKeyEx( hkSourceKey,
			       RegKeyInfo.pSubKeyName,
			       0,
			       KEY_ALL_ACCESS,
			       &hkCurrentSourceKey );
	// Bug 45994
	if (result != ERROR_SUCCESS )
	   goto cleanup;
	
	result = RegSetValueEx( hkCurrentSourceKey,
				L"Shared",
				0,
				REG_SZ,
				(LPBYTE) L"Y",
				sizeof( L"Y" ) );

	RegCloseKey( hkCurrentSourceKey );
    
    }

    Success = TRUE;

cleanup:
    CleanupAfterEnumRegistryTree( hkSourceKey, &RegKeyInfo );

cleanup2:
    RegCloseKey( hkSourceKey );

    return Success;
    
}

BOOL
AddSharedValues( HKEY hkShared )
{
    // for each of the special subtrees, add "Shared" values
    int		idx;

    // now, for each of the special top-level keys, process the level below them
    // these keys are: CLSID, Interface, TypeLib, Licenses, FileType

    for ( idx = 0; idx < MAX_SPECIAL_SUBTREE; idx++ )
    {
	AddSharedValuesToSubkeys( hkShared, SpecialSubtrees[idx] );
    }

    // now do all the top level keys (file extensions and progids)
    AddSharedValuesToSubkeys( hkShared, NULL  );

    return TRUE;
}


//*************************************************************
//
//  MergeUserClasses()
//
//  Purpose:    Merges the user's class information with the
//              common class information.
//
//  Parameters: UserClassStore   -  Per-user class information
//              CommonClassStore -  Machine-wide class information
//              MergedClassStore -  Destination for merged information.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   UserClassStore may be a null HKEY, implying
//              just copy the information from the common
//              portion into the merged portion
//
//  History:    Date        Author     Comment
//              1/14/96     GregJen    Created
//
//*************************************************************
BOOL
MergeRegistrySubKeys (
    HKEY    hkSourceTree,
    HKEY    hkDestTree )
{
    HKEY hkCurrentSourceKey = NULL;
    HKEY hkCurrentDestKey = NULL;
    DWORD idx;
    DWORD   NameLen;
    LONG    result  = ERROR_SUCCESS;
    REGKEYINFO RegKeyInfo;
    BOOL    Success = FALSE;
    FILETIME	SourceFileTime;
    FILETIME	DestFileTime;
	LONG cmp;

    if ( !PrepForEnumRegistryTree( hkSourceTree, &RegKeyInfo ) )
	return FALSE;  // nothing to clean up here yet

    // enumerate all the source subkeys
    // for each: if dest subkey is older than source, delete it
    //		 if dest subkey does not exist (or was deleted) clone the subkey
    //
    // Clone all the subkeys
    //
    for ( idx = 0; 
          (result == ERROR_SUCCESS) && 
	      ( result != ERROR_MORE_DATA ) && 
	      ( idx < RegKeyInfo.SubKeyCount ); 
	  idx++ ) {
	NameLen = RegKeyInfo.MaxSubKeyLen + sizeof( TCHAR );
	result = RegEnumKeyEx( hkSourceTree, 
			       idx,
			       RegKeyInfo.pSubKeyName,
			       &NameLen,
			       NULL,
			       NULL,
			       NULL,
			       &SourceFileTime );
        
        if ( ( result != ERROR_SUCCESS ) && ( result != ERROR_MORE_DATA ) )
	    goto cleanup;

	// TBD: open the subkey in the source tree AS CurrentSourceKey
	result = RegOpenKeyEx(hkSourceTree,
			      RegKeyInfo.pSubKeyName,
			      0,
			      KEY_READ,
			      &hkCurrentSourceKey);
	if (result != ERROR_SUCCESS)
		goto cleanup;
	
	result = RegOpenKeyEx(hkDestTree,
			      RegKeyInfo.pSubKeyName,
			      0,
			      KEY_READ,
			      &hkCurrentDestKey);

	// if current dest key does not exist,  
	if ( result == ERROR_FILE_NOT_FOUND )
	{
	    //
	    // recurse passing the subkey name
	    //
	    CloneRegistryTree( hkCurrentSourceKey, 
			       hkDestTree, 
			       RegKeyInfo.pSubKeyName );
	}
	// if current dest key is older than current source key, delete dest
	// then recreate new
	else if (result == ERROR_SUCCESS)
	{
	    RegQueryInfoKey( hkCurrentDestKey,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     &DestFileTime );


	    cmp = CompareFileTime( &SourceFileTime, &DestFileTime );
	    if ( cmp > 0 )
	    {
		// delete dest
		//
		DeleteRegistrySubtree( hkCurrentDestKey );

		//
		// recurse passing the subkey name
		//
		CloneRegistryTree( hkCurrentSourceKey, 
				   hkDestTree, 
				   RegKeyInfo.pSubKeyName );
	    }
		
	    RegCloseKey(hkCurrentDestKey);
	}

	//
	// close our open key
	//

	RegCloseKey( hkCurrentSourceKey );

	result = ERROR_SUCCESS;
    }

cleanup:
    CleanupAfterEnumRegistryTree( hkSourceTree, &RegKeyInfo );

    return TRUE;
}




//*************************************************************
//
//  MergeUserClasses()
//
//  Purpose:    Merges the user's class information with the
//              common class information.
//
//  Parameters: UserClassStore   -  Per-user class information
//              CommonClassStore -  Machine-wide class information
//              MergedClassStore -  Destination for merged information.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   UserClassStore may be a null HKEY, implying
//              just copy the information from the common
//              portion into the merged portion
//
//  History:    Date        Author     Comment
//              1/14/96     GregJen    Created
//
//*************************************************************
BOOL
MergeRegistrySubtree (
    HKEY    hkSourceParent,
    HKEY    hkDestParent,
    LPTSTR  pszSubtree )
{
    HKEY    hkCurrentSourceKey = NULL;
    HKEY    hkCurrentDestKey = NULL;
    LONG    result;
    DWORD   dummy   = 0;

    // open the special subtree in the source tree
    result = RegOpenKeyEx( hkSourceParent,
                           pszSubtree,
                           0,
                           KEY_READ,
                           &hkCurrentSourceKey );

    // TBD: if no subtree in source, skip ahead to next special subtree
    if ( result == ERROR_FILE_NOT_FOUND )
        return TRUE;

    // If any other errors occurred, return FALSE
    if ( result != ERROR_SUCCESS)
        return FALSE;

    result = RegOpenKeyEx( hkDestParent,
                           pszSubtree,
                           0,
                           KEY_ALL_ACCESS,
                           &hkCurrentDestKey );
    // TBD: if no such subtree in dest, do CloneRegistry etc
    if ( result == ERROR_FILE_NOT_FOUND )
    {
        //
        // recurse passing the subkey name
        //
        CloneRegistryTree( hkCurrentSourceKey, 
                   hkDestParent, 
                   pszSubtree );
    }
    // TBD:if timestamp on source is newer than timestamp on dest, 
    //     delete dest and recreate??
    
    // Bug 45995
    if (hkCurrentDestKey) 
    {
        MergeRegistrySubKeys( hkCurrentSourceKey,
                              hkCurrentDestKey );

        // make sure the timestamp on the special trees is updated
        result = RegSetValueEx( hkCurrentDestKey,
                                TEXT("Updated"),
                                0,
                                REG_DWORD,
                                (BYTE*) &dummy,
                                sizeof( DWORD ) );
        RegCloseKey( hkCurrentDestKey );
    }


    // close special subtrees
    RegCloseKey( hkCurrentSourceKey );

    return TRUE;
}

long 
CompareRegistryTimes(
    HKEY hkLHS,
    HKEY hkRHS )
{
    FILETIME	LHSTime;
    FILETIME	RHSTime;

    	    RegQueryInfoKey( hkLHS,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     &LHSTime );

    	    RegQueryInfoKey( hkRHS,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     NULL,
			     &RHSTime );

    return CompareFileTime( &LHSTime, &RHSTime );
}

//*************************************************************
//
//  MergeUserClasses()
//
//  Purpose:    Merges the user's class information with the
//              common class information.
//
//  Parameters: UserClassStore   -  Per-user class information
//              CommonClassStore -  Machine-wide class information
//              MergedClassStore -  Destination for merged information.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   UserClassStore may be a null HKEY, implying
//              just copy the information from the common
//              portion into the merged portion
//
//  History:    Date        Author     Comment
//              1/14/96     GregJen    Created
//
//*************************************************************
BOOL
MergeUserClasses( 
    HKEY UserClassStore, 
    HKEY CommonClassStore,
    HKEY MergedClassStore,
    BOOL ForceNew )
{
    BOOL	fNotCorrectUser = FALSE;
    HKEY	hkOverridingSubtree = CommonClassStore;
    HKEY	hkMergingSubtree    = UserClassStore;
    int		idx;

    //TBD: check time stamps on source and destination
    // if same user, and timestamps are in sync, do nothing

    // if destination does not belong to the current user, then
    // delete everything under it
 
    if ( fNotCorrectUser ) {
        DeleteRegistrySubtree( MergedClassStore );
    }

    
    if ( !ForceNew &&
	 ( CompareRegistryTimes( MergedClassStore, CommonClassStore ) > 0 ) &&
	 ( CompareRegistryTimes( MergedClassStore, UserClassStore ) > 0 ) )
    {
	return TRUE;
    }

    // TBD: copy everything from the overriding store into the
    // destination store
    // At this moment, the common store overrides the user store;
    // this will eventually reverse.

    CloneRegistryTree( hkOverridingSubtree, MergedClassStore, NULL );

    // now, for each of the special top-level keys, process the level below them
    // these keys are: CLSID, Interface, TypeLib, Licenses, FileType

    for ( idx = 0; idx < MAX_SPECIAL_SUBTREE; idx++ )
    {
	MergeRegistrySubtree( hkMergingSubtree, 
			      MergedClassStore, 
			      SpecialSubtrees[idx] );
    }

    // now do all the top level keys (file extensions and progids)
    // TBD: MergeRegistrySubtree( UserClassStore, MergedClassStore );
    MergeRegistrySubtree( hkMergingSubtree, 
			  MergedClassStore, 
			  NULL  );

return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\api.c ===
/****************************************************************************
                   QuickDraw Import Filter; Implementation
*****************************************************************************

   This file contains the source for a dynamically loaded graphics
   import filters that read QuickDraw PICT images.  The entry points
   support both Aldus version 1 style interface, embedded extensions,
   and a parameterized input control.

****************************************************************************/

#include <headers.c>
#pragma hdrstop

#include "api.h"        /* Own interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

#define  GraphicsImport    2
#define  PICTHeaderOffset  512

#define  USEDIALOG         TRUE
#define  NODIALOG          FALSE

private  USERPREFS   upgradePrefs;
private  USERPREFS   defaultPrefs =
{
   { 'Q','D','2','G','D','I' },  // signature
   2,                            // version = 2
   sizeof( USERPREFS ),          // size of structure
   NULL,                         // no sourceFilename, yet
   NULL,                         // no sourceHandle, yet
   NULL,                         // no destinationFilename, yet
   3,                            // penPatternAction = blend fore and background
   5,                            // nonSquarePenAction = use max dimension
   1,                            // penModeAction = use srcCopy
   1,                            // textModeAction = use srcCopy
   1,                            // nonRectRegionAction = create masks
   0,                            // optimize PowerPoint = false
   0,                            // noRLE = false
   0,                            // reservedByte
   { 0, 0, 0, 0, 0 }             // reserved initialized
};

private Handle       instanceHandle;


/*********************** Private Function Definitions ***********************/

LPUSERPREFS VerifyPrefBlock( LPUSERPREFS lpPrefs );
/* Perform cursory verification of the parameter block header */

private void ConvertPICT( LPUSERPREFS lpPrefs, PICTINFO far * lpPict,
                          Boolean doDialog );
/* perform conversion and return results once environment is set up */

/*********************** Function Implementation ****************************/
#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni,
                          HANDLE FAR * lphPrefMem,
                          HANDLE FAR * lphFileTypes )
/*=====================*/
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni,
                              HANDLE FAR * lphPrefMem,
                              HANDLE FAR * lphFileTypes )
/*=========================*/
#endif
/* Returns information about this filter.
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */
{
   LPUSERPREFS    lpPrefs;

   /* allocate the global memory block */
   *lphPrefMem = GlobalAlloc( GHND, Sizeof( USERPREFS ) );

   /* if allocation is unsuccessful, set global error */
   if (*lphPrefMem == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* lock down the memory and assign the default values */
      lpPrefs = (LPUSERPREFS)GlobalLock( *lphPrefMem );
      *lpPrefs = defaultPrefs;

      /* unlock the memory */
      GlobalUnlock( *lphPrefMem );
   }

   /* Indicate handles graphics import */
   return( GraphicsImport );

   UnReferenced( PM_Version );
   UnReferenced( lpIni );
   UnReferenced( lphFileTypes );

} /* GetFilterInfo */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd,
                           HANDLE hPrefMem, WORD wFlags )
/*======================*/
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd,
                               HANDLE hPrefMem, WORD wFlags )
/*==========================*/
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */
{
   return;

   UnReferenced( hInst );
   UnReferenced( hWnd );
   UnReferenced( hPrefMem );
   UnReferenced( wFlags );

}  /* GetFilterPref */


#ifndef _OLECNV32_

#ifdef WIN32
short WINAPI ImportGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                       PICTINFO FAR * lpPict, HANDLE hPrefMem )
/*==================*/
#else
short FAR PASCAL ImportGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                           PICTINFO FAR * lpPict, HANDLE hPrefMem )
/*======================*/
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The
   metafile generated will be returned in lpPict. */
{
   LPUSERPREFS    lpPrefs;

   /* Check for any errors from GetFilterInfo() or GetFilterPref() */
   if (ErGetGlobalError() != NOERR)
   {
      return ErInternalErrorToAldus();
   }

   /* Lock the preference memory and verify correct header */
   lpPrefs = (LPUSERPREFS)GlobalLock( hPrefMem );
   lpPrefs = VerifyPrefBlock( lpPrefs );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
      /* provide IO module with source file name and read begin offset */
      IOSetFileName( (StringLPtr) lpFileSpec->fullName );
      IOSetReadOffset( PICTHeaderOffset );

      /* save the source filename for the status dialog box */
      lpPrefs->sourceFilename = lpFileSpec->fullName;

      /* Tell Gdi module to create a memory-based metafile */
      lpPrefs->destinationFilename = NULL;

      /* convert the image, provide status update */
      ConvertPICT( lpPrefs, lpPict, USEDIALOG );
   }

   /* Unlock preference memory */
   GlobalUnlock( hPrefMem );

   /* return the translated error code (if any problems encoutered) */
   return ErInternalErrorToAldus();

   UnReferenced( hdcPrint );
   UnReferenced( hPrefMem );

} /* ImportGR */

#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName )
/*==========================*/
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec,
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName )
/*==============================*/
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */
{
   LPUSERPREFS    lpPrefs;

   /* Check for any errors from GetFilterInfo() or GetFilterPref() */
   if (ErGetGlobalError() != NOERR)
   {
      return ErInternalErrorToAldus();
   }

   /* Lock the preference memory and verify correct header */
   lpPrefs = (LPUSERPREFS)GlobalLock( hPrefMem );
   lpPrefs = VerifyPrefBlock( lpPrefs );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
      /* provide IO module with source file handle and read begin offset */
      IOSetFileHandleAndSize( lpFileSpec->handle, dwSize );
      IOSetReadOffset( lpFileSpec->filePos );

      /* save the source filename for the status dialog box */
      lpPrefs->sourceFilename = lpFileSpec->fullName;

      /* Tell Gdi module to create metafile passed as parameter */
      lpPrefs->destinationFilename = lpMetafileName;

      /* convert the image, provide status update */
      ConvertPICT( lpPrefs, lpPict, USEDIALOG );
   }

   /* Unlock preference memory */
   GlobalUnlock( hPrefMem );

   /* return the translated error code (if any problems encoutered) */
   return ErInternalErrorToAldus();

   UnReferenced( hdcPrint );
   UnReferenced( hPrefMem );

}  /* ImportEmbeddedGr */

#endif  // !_OLECNV32_


#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict )
/*================*/
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict )
/*====================*/
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */
{
   /* verify correct header, and return if something is wrong */
   lpPrefMem = VerifyPrefBlock( lpPrefMem );

   /* if there is no error from the header verification, proceed */
   if (ErGetGlobalError() == NOERR)
   {
#ifndef _OLECNV32_
      /* Determine if there is a fully-qualified source file name */
      if (lpPrefMem->sourceFilename != NIL)
      {
         /* Set the filename and read offset */
         IOSetFileName( (StringLPtr) lpPrefMem->sourceFilename );
         IOSetReadOffset( 0 );

      }
      /* otherwise, we are performing memory read from a global memory block */
      else
#endif  // !_OLECNV32_
           if (lpPrefMem->sourceHandle != NIL)
      {
         /* Set the memory handle and read offset */
         IOSetMemoryHandle( (HANDLE) lpPrefMem->sourceHandle );
         IOSetReadOffset( 0 );
      }
      else
      {
         /* Problem with input parameter block */
         ErSetGlobalError( ErNoSourceFormat );
#ifdef _OLECNV32_
         return((short) ErGetGlobalError());
#else
         return ErInternalErrorToAldus();
#endif
      }

      /* convert the image - no status updates */
      ConvertPICT( lpPrefMem, lpPict, NODIALOG );
   }

   /* return the translated error code (if any problems encoutered) */
#ifdef _OLECNV32_
   return((short) ErGetGlobalError());
#else
   return ErInternalErrorToAldus();
#endif

}  /* QD2GDI */


#ifdef WIN32
BOOL LibMain( HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
/*=========*/
#else
int FAR PASCAL LibMain( HANDLE hInst, WORD wDataSeg, WORD cbHeap,
                        LPSTR lpszCmdline )
/*===================*/
#endif
/* Needed to get an instance handle */
{
   instanceHandle = hInst;

   /* default return value */
   return( 1 );

#ifndef WIN32
   UnReferenced( wDataSeg );
   UnReferenced( cbHeap );
   UnReferenced( lpszCmdline );
#endif

} /* LibMain */

#ifdef WIN32
int WINAPI WEP( int nParameter )
/*===========*/
#else
int FAR PASCAL WEP( int nParameter )
/*===============*/
#endif
{
   /* default return value */
   return( 1 );

   UnReferenced( nParameter );

} /* WEP */



/******************************* Private Routines ***************************/


LPUSERPREFS VerifyPrefBlock( LPUSERPREFS lpPrefs )
/*-------------------------*/
/* Perform cursory verification of the parameter block header */
{
   Byte           i;
   Byte far *     prefs = (Byte far *)lpPrefs;
   Byte far *     check = (Byte far *)&defaultPrefs;

   /* loop through chars of signature verifying it */
   for (i = 0; i < sizeof( lpPrefs->signature); i++)
   {
      /* if any of the byte miscompare ... */
      if (*prefs++ != *check++)
      {
         /* ... set a global flag and return */
         ErSetGlobalError( ErInvalidPrefsHeader );
         return lpPrefs; // Sundown - According to callers, ErGetGlobalError() is used to check any error.
      }
   }

   /* check if this is a version 1 structure */
   if (lpPrefs->version == 1)
   {
      USERPREFS_V1   v1Prefs = *((LPUSERPREFS_V1)lpPrefs);

      /* convert the version 1 fields to version 2 fields */
      upgradePrefs                     = defaultPrefs;
      upgradePrefs.sourceFilename      = v1Prefs.sourceFilename;
      upgradePrefs.sourceHandle        = v1Prefs.sourceHandle;
      upgradePrefs.destinationFilename = v1Prefs.destinationFilename;
      upgradePrefs.nonSquarePenAction  = v1Prefs.nonSquarePenAction;
      upgradePrefs.penModeAction       = v1Prefs.penModeAction;
      upgradePrefs.textModeAction      = v1Prefs.textModeAction;
      upgradePrefs.optimizePP          = v1Prefs.optimizePP;

      /* since new functionality was added to the patterned pens and region
         records, upgrade to highest image fidelity setting if they didn't
         request omit or import abort actions. */
      upgradePrefs.penPatternAction    = (v1Prefs.penPatternAction == 1) ?
                                          (Byte)3 :
                                          v1Prefs.penPatternAction;
      upgradePrefs.nonRectRegionAction = (v1Prefs.nonRectRegionAction == 0) ?
                                          (Byte)1 :
                                          v1Prefs.nonRectRegionAction;

      /* return address of the converted fields data structure */
      return &upgradePrefs;
   }
   else if( lpPrefs->version <= 3 )
   {
      if( lpPrefs->version==2 )
      {  /* noRLE wasn't supported in version 2, so zero it */
         lpPrefs->noRLE = 0;
      }

      /* return address that was passed in */
      return lpPrefs;
   }
   else /* version > 3 is an error */  {
      ErSetGlobalError( ErInvalidPrefsHeader );
      return lpPrefs; // Sundown - According to callers, ErGetGlobalError() is used to check any error.
  }
}


private void ConvertPICT( LPUSERPREFS lpPrefs, PICTINFO far * lpPict,
                          Boolean doDialog )
/*----------------------*/
/* perform conversion and return results once environment is set up */
{
#ifndef _OLECNV32_
   FARPROC        dialogBoxProcedure;
   StatusParam    statusParams;
#endif

   /* Set conversion preferences */
   /* This is somewhat bogus in that it passes ptr to middle of USERPREFS
      to a function that wants a ptr to ConvPrefs (a trailing subset) */
   GdiSetConversionPrefs( (ConvPrefsLPtr)&lpPrefs->destinationFilename );

#ifndef _OLECNV32_
   if (doDialog)
   {
      /* save data in structure to be passed to dialog window */
      statusParams.sourceFilename = lpPrefs->sourceFilename;
      statusParams.instance = instanceHandle;

      /* make a callable address for status dialog */
      dialogBoxProcedure = MakeProcInstance( StatusProc, instanceHandle );

      /* make sure that the procedure address was obtained */
      if (dialogBoxProcedure == NULL)
      {
         /* set error if unable to proceed */
         ErSetGlobalError( ErNoDialogBox );
         return;
      }
      else
      {
         /* AR: GetActiveWindow() may be bad, since the ability to update
            !!! links may be performed in the background, shutting out
                any process which then becomes the active window */

         /* dialog module calls quickdraw entry point to convert image */
         DialogBoxParam( instanceHandle, MAKEINTRESOURCE( RS_STATUS ),
                         GetActiveWindow(), dialogBoxProcedure,
                         (DWORD)((StatusParamLPtr)&statusParams) );

         /* release the procedure instance */
         FreeProcInstance( dialogBoxProcedure );
      }
   }
   else
#endif  // !_OLECNV32_
   {
      /* convert image, NULL parameter means no status updates */
      QDConvertPicture( NULL );
   }

   /* Get conversion results in parameter block */
   GdiGetConversionResults( lpPict );

#ifdef DEBUG
   if (ErGetGlobalError() == ErNoError)
   {
      HANDLE          hPICT;
      LPMETAFILEPICT  lpPICT;

      OpenClipboard( GetActiveWindow() );

      hPICT = GlobalAlloc( GHND, sizeof( METAFILEPICT ) );

      if (hPICT)
      {
         lpPICT = (LPMETAFILEPICT)GlobalLock( hPICT );
         lpPICT->mm = MM_ANISOTROPIC;
         lpPICT->xExt = Width( lpPict->bbox );
         lpPICT->yExt = Height( lpPict->bbox );
         lpPICT->hMF  = CopyMetaFile( lpPict->hmf, NULL );
         GlobalUnlock( hPICT );

         SetClipboardData( CF_METAFILEPICT, hPICT );
         CloseClipboard();
      }
   }
#endif

}  /* ConvertPICT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\api.h ===
/****************************************************************************
                   Metafile Import Filter; Interface
*****************************************************************************

   This file contains the interface for the QuickDraw import filter 
   that reads Mac pictures from disk and/or memory.  In addition to the
   Aldus filter interface, it also supports a parameterized interface
   for Microsoft applications to control some conversion results.

****************************************************************************/

/*--- Aldus-defined file access block ---*/

typedef DWORD FILETYPE;

typedef struct 
{
   unsigned slippery : 1;  /* TRUE if file may disappear. */
   unsigned write : 1;     /* TRUE if open for write. */
   unsigned unnamed : 1;   /* TRUE if unnamed. */
   unsigned linked : 1;    /* Linked to an FS FCB. */
   unsigned mark : 1;      /* Generic mark bit. */
   FILETYPE fType;         /* The file type. */
#define IBMFNSIZE 124
   short    handle;        /* MS-DOS open file handle. */
   char     fullName[IBMFNSIZE]; /* Device, path, file names. */
   DWORD    filePos;    /* Our current file posn. */
} FILESPEC, FAR *LPFILESPEC;


/*--- Preferences memory block ---*/

typedef struct                   // "old" version 1 USERPREFS
{
   char     signature[6];
   WORD     version;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     charLock;
   BYTE     nonRectRegionAction;
   BOOL     PICTinComment;
   BOOL     optimizePP;
   WORD     lineClipWidthThreshold;
   WORD     reserved[6];   
} USERPREFS_V1, FAR *LPUSERPREFS_V1;


typedef struct                   // current version 3 USERPREFS
{
   char     signature[6];
   WORD     version;
   WORD     size;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     nonRectRegionAction;
   BOOL     optimizePP;
   BYTE     noRLE;         // new (split out from reserved[0] of version 2)
   BYTE     reservedByte;  // rest of first reserved word
   WORD     reserved[5];

} USERPREFS, FAR * LPUSERPREFS;


/*********************** Exported Function Definitions **********************/

#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni, 
                          HANDLE FAR * lphPrefMem, 
                          HANDLE FAR * lphFileTypes );
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni, 
                              HANDLE FAR * lphPrefMem, 
                              HANDLE FAR * lphFileTypes );
#endif
/* Returns information about this filter. 
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */


#ifdef WIN32
short WINAPI ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                       PICTINFO FAR * lpPict, HANDLE hPrefMem );
#else
short FAR PASCAL ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                           PICTINFO FAR * lpPict, HANDLE hPrefMem );
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The 
   metafile generated will be returned in lpPict. */


#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName );
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName );
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */

#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */

#ifdef WIN32
BOOL LibMain( HINSTANCE hInst, DWORD fdwReason, LPVOID lpvReserved);
#else
int FAR PASCAL LibMain( HANDLE hInst, WORD wDataSeg, WORD cbHeap,
                        LPSTR lpszCmdline );
#endif
/* Needed to get an instance handle */

#ifdef WIN32
int WINAPI WEP( int nParameter );
#else
int FAR PASCAL WEP( int nParameter );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\bufio.h ===
/****************************************************************************
                       Unit Bufio; Interface
*****************************************************************************

 Bufio implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

 This interface will also shield the calling application from knowledge of 
 the source format (file vs. memory).

   Module Prefix: IO

*****************************************************************************/


/*********************** Exported Function Definitions **********************/

void IOGetByte( Byte far * );
/* Retrieves an 8-bit unsigned char from the input stream */

void IOSkipBytes( LongInt byteCount );
/* Skip the designated number of bytes */

void IOAlignToWordOffset( void );
/* Align next memory read to Word boundary. */

void IOSetFileName( StringLPtr pictFileName );
/* Interface routine to set the source filename */

void IOSetFileHandleAndSize( Integer pictFileHandle, LongInt pictFileSize );
/* Interface routine to set the source file Handle */

void IOSetMemoryHandle( HANDLE pictMemoryHandle );
/* Interface routine to set the source file Handle */

void IOSetReadOffset( LongInt readOffset );
/* Set the beginning offset to seek to when the file is opened */

void IOOpenPicture( Handle dialog );
/* Open the input stream set by a previous IOSet___ interface routine. */

void IOClosePicture( void );
/* Close the source input stream */

void IOUpdateStatus( void );
/* Update the status bar dialog to reflect current progress */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\bufio.c ===
/****************************************************************************
                       Unit Bufio; Implementation
*****************************************************************************

 Bufio implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

 This interface will also shield the calling application from knowledge of
 the source format (file vs. memory).

   Module Prefix: IO

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "filesys.h"

#ifndef _OLECNV32_
//#include  "status.h"
#endif  // _OLECNV32_

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

#define  UNKNOWN     0
#define  FILE        1
#define  MEMORY      2
#define  RTF         3

#define  BUFFERSIZE  1024

private  LongInt     numBytesRead;
private  LongInt     pictureSize;
private  LongInt     beginOffset;

private  LongInt     bufferCount;
private  Byte        buffer[BUFFERSIZE];
private  Byte *      nextCharPtr;
private  Byte huge * nextCharHPtr;

private  Byte        sourceType = UNKNOWN;
private  Integer     fileHandle = (Integer)0;
private  Str255      fileName;
private  Boolean     openFile;

private  Byte huge * memoryHPtr;
private  Handle      memoryHandle;

private  Handle      dialogHandle;

/*********************** Private Function Definitions ***********************/

private void ReadNextBuffer( void );
/* Replenish the i/o buffer with the next set of characters */

/* Memory operations - check return values on usage */
#define MDisposHandle( h )      ((void) GlobalFree( h ))
#define MLock( h )              ((LPtr) GlobalLock( h ))
#define MUnlock( h )            ((void) GlobalUnlock( h ))
#define MDR( h )                ((LPtr) GlobalLock( h ))
#define MUR( h )                ((void) GlobalUnlock( h ))
#define MNewHandle( s )         GlobalAlloc( GMEM_MOVEABLE, s )

/*********************** Function Implementation ****************************/

void IOGetByte( Byte far * byteLPtr )
/*============*/
/* Read a byte from the input stream.  If the buffer is empty, then
   it is replenished. */
{
   /* Make sure that no global error code has been set before read */
   if (ErGetGlobalError() != NOERR )
   {
      *byteLPtr = 0;
      return;
   }

   /* Check for an attempt to read past the EOF or memory block.  This
      would indicate that the opcode parsing was thrown off somewhere. */
   if (numBytesRead >= pictureSize)
   {
      ErSetGlobalError( ErReadPastEOF );
      *byteLPtr = 0;
      return;
   }

   /* Check to see if we need to replenish the read buffer */
   if (bufferCount <= 0)
   {
      ReadNextBuffer();
   }

   /* Decrement the count of characters in the buffer, increment the total
      number of bytes read from the file, and return the next character. */
   bufferCount--;
   numBytesRead++;

   /* determine where to read the next byte from - use short or huge ptrs */
   *byteLPtr = (sourceType == FILE) ? *nextCharPtr++ : *nextCharHPtr++;

}  /* IOGetByte */



void IOSkipBytes( LongInt byteCount )
/*==============*/
/* Skip the designated number of bytes */
{
   /* make sure we are skipping a valid number of bytes */
   if (byteCount <= 0)
   {
      return;
   }

   /* Check for an attempt to read past the EOF or memory block.  This
      would indicate that the opcode parsing was thrown off somewhere. */
   if (numBytesRead + byteCount >= pictureSize)
   {
      ErSetGlobalError( ErReadPastEOF );
   }
   else
   {
      /* determine if there are sufficient bytes remaining in the buffer */
      if (bufferCount >= byteCount)
      {
         /* decrement # bytes remaining, increment # bytes read and pointer */
         bufferCount  -= byteCount;
         numBytesRead += byteCount;

         /* increment the appropriate pointer based on media type */
         if (sourceType == FILE)
         {
            /* increment near pointer to data segment buffer */
            nextCharPtr += byteCount;
         }
         else
         {
            /* increment huge pointer to global memory block */
            nextCharHPtr += byteCount;
         }
      }
      else /* sourceType == FILE and buffer needs to be replenished */
      {
         Byte     unusedByte;

         /* continue calling IOGetByte() until desired number are skipped */
         while (byteCount--)
         {
            /* call IOGetByte to make sure the cache is replenished */
            IOGetByte( &unusedByte );
         }
      }
   }

}  /* IOSkipBytes */



void IOAlignToWordOffset( void )
/*======================*/
/* Align next memory read to Word boundary. */
{
   /* check to see if we have read an odd number of bytes so far.  Skip
      the ensuing byte if necessary to align. */
   if (numBytesRead & 0x0001)
   {
      IOSkipBytes( 1 );
   }

}  /* IOAlignToWordOffset */


#ifndef _OLECNV32_
void IOSetFileName( StringLPtr pictFileName )
/*================*/
/* Interface routine to set the source filename */
{
   lstrcpy( fileName, pictFileName );
   sourceType = FILE;
   openFile = TRUE;

}  /* IOSetFileName */

void IOSetFileHandleAndSize( Integer pictFileHandle, LongInt pictFileSize )
/*=========================*/
/* Interface routine to set the source file Handle */
{
   fileHandle = pictFileHandle;
   pictureSize = pictFileSize;
   sourceType = FILE;
   openFile = FALSE;

}  /* IOSetFIleHandle */
#endif  // !_OLECNV32_



void IOSetMemoryHandle( HANDLE pictMemoryHandle )
/*==================*/
/* Interface routine to set the source file Handle */
{
   memoryHandle = ( Handle ) pictMemoryHandle;
   sourceType = MEMORY;

}  /* IOSetMemoryHandle */



void IOSetReadOffset( LongInt readOffset )
/*==================*/
/* Set the beginning offset to seek to when the file is opened */
{
   beginOffset = readOffset;
}



void IOOpenPicture( Handle dialog )
/*================*/
/* Open the input stream depending on the source type set by a previous
   IOSet___ interface routine.  Determine the size of the picture image. */
{
#ifndef _OLECNV32_
   OSErr    openError;
#endif  // !_OLECNV32_

   /* if the type isn't set, return error */
   if (sourceType == UNKNOWN)
   {
      ErSetGlobalError( ErNoSourceFormat );
      return;
   }

   /* initialize the various reader variables */
   numBytesRead = 0;
   bufferCount = 0;

   /* determine how to open the soure data stream */
#ifndef _OLECNV32_
   if (sourceType == FILE)
   {
      /* if we are openning and converting an entire file */
      if (openFile)
      {
         /* open the file */
         openError = FSOpen( (StringLPtr)fileName, OF_READ | OF_SHARE_DENY_WRITE, &fileHandle );
         if (openError)
         {
            ErSetGlobalError( ErOpenFail);
         }
         else
         {
            /* and determine the file length */
            FSSetFPos( fileHandle, FSFROMLEOF, 0L );
            FSGetFPos( fileHandle, &pictureSize );
         }
      }

      /* set position to the designated start position */
      FSSetFPos( fileHandle, FSFROMSTART, beginOffset );
      numBytesRead = beginOffset;
   }
   else /* if (sourceType == MEMORY) */
#endif  // !_OLECNV32_
   {
      /* lock the memory block */
      memoryHPtr = (Byte huge *) MLock( memoryHandle );
      if (memoryHPtr == NULL)
      {
         ErSetGlobalError( ErMemoryFail );
         return;
      }
      else
      {
         /* and determine the overall memory block size */
         pictureSize = (ULONG) GlobalSize( memoryHandle );
      }

      /* set the huge character read pointer, bytes read, and buffer count */
      nextCharHPtr = memoryHPtr  + beginOffset;
      bufferCount  = pictureSize - beginOffset;
      numBytesRead = beginOffset;
   }

#ifndef _OLECNV32_
   /* make sure that a dialog handle was supplied for update */
   if (dialog)
   {
      /* save off the dialog box handle */
      dialogHandle = dialog;

      /* calculate the interval to update the status dialog */
      SendMessage( dialogHandle, SM_SETRANGE, 0, pictureSize );
   }
#endif  // !OLECNV32

}  /* IOOpenPicture */



void IOClosePicture( void )
/*=================*/
/* Close the source input stream */
{
   /* if this is a file-based metafile */
#ifndef _OLECNV32_
   if (sourceType == FILE)
   {
      /* make sure this isn't the ImportEmbeddedGr() entry point */
      if (openFile)
      {
         /* close the file if necessary */
         FSCloseFile( fileHandle );
         fileHandle = ( Integer ) 0;
      }
   }
   else
#endif  // !_OLECNV32_
   {
      /* unlock the global memory block */
      MUnlock( memoryHandle );
      memoryHandle = NULL;
   }

   /* de-initialize the module variables */
   sourceType = UNKNOWN;
   dialogHandle = NULL;

}  /* IOClosePicture */



void IOUpdateStatus( void )
/*=================*/
/* Update the status bar dialog to reflect current progress */
{
#ifndef _OLECNV32_
   /* update only if a dialog box was created */
   if (dialogHandle)
   {
      /* calculate the interval to update the status dialog */
      SendMessage( dialogHandle, SM_SETPOSITION, 0, numBytesRead );
   }
#endif  // !_OLECNV32_

}  /* IOUpdateStatus */



/******************************* Private Routines ***************************/


private void ReadNextBuffer( void )
/*-------------------------*/
/* Replenish the i/o buffer with the next set of characters.  This should
   only be called if performing buffered I/O - not with MEMORY-based file */
{
#ifndef _OLECNV32_
   OSErr    fileError;

   /* Read the required number of bytes from the file.  Check the error
      code return and set the global status error if the read failed. */

   if (sourceType == FILE)
   {
      /* Calculate the number of bytes that should be read into the buffer.
         This needs to be done, since this may be a memory source picture,
         in which an invalid read could produce a GP violation */
      if (numBytesRead + BUFFERSIZE > pictureSize)
         bufferCount = pictureSize - numBytesRead;
      else
         bufferCount = BUFFERSIZE;

      /* read the bytes from the file */
      fileError = FSRead( fileHandle, &bufferCount, &buffer);

      /* if there is any error, notify the error module */
      if (fileError != 0)
      {
         ErSetGlobalError( ErReadFail );
         return;
      }

      /* reset the character read pointer to the beginning of the buffer */
      nextCharPtr = buffer;
   }
#endif  // _OLECNV32_

}  /* ReadNextBuffer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\cache.c ===
/****************************************************************************
                       Unit Cache; Implementation
*****************************************************************************

   Module Prefix: Ca

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "cache.h"        /* own interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

/*--- Gdi cache ---*/

typedef struct
{
   HPEN            handle;
   LOGPEN          logPen;
   Boolean         stockObject;

} Pen, far * PenLPtr;


typedef struct
{
   HBRUSH          handle;
   LOGBRUSH        logBrush;
   Boolean         stockObject;

} Brush, far * BrushLPtr;


typedef struct
{
   Handle          metafile;           // metafile handle

   Rect            prevClipRect;       // last cliprect before SaveDC()
   Rect            curClipRect;        // last clipping rectangle
   Boolean         forceNewClipRect;   // always emit new clipping rectangle?

   HPEN            nulPen;             // frequently used pens
   HPEN            whitePen;
   HPEN            blackPen;

   HBRUSH          nulBrush;           // frequently used brushes
   HBRUSH          whiteBrush;
   HBRUSH          blackBrush;

   Boolean         stockFont;          // current font selection
   HFONT           curFont;
   LOGFONT         curLogFont;

   Brush           curBrush;           // current pen and brush selections
   Pen             curPen;
   Pen             nextPen;            // cached frame(pen)

   CaPrimitive     nextPrim;           // cached primitive
   Boolean         samePrim;
   Handle          polyHandle;
   Integer         numPoints;
   Integer         maxPoints;
   Point far *     pointList;

   Word            iniROP2;            // initial value for ROP2 mode
   Word            iniTextAlign;       // initial value for text alignment
   Word            iniBkMode;
   RGBColor        iniTxColor;
   RGBColor        iniBkColor;

   Word            curROP2;            // current ROP codes setting
   Word            curBkMode;          // current background mode
   RGBColor        curBkColor;         // current background color
   Word            curStretchMode;     // current stretchblt mode

   RGBColor        curTextColor;       // last text color
   Word            curTextAlign;       // last text alignment value
   short           curCharExtra;       // last char extra value
   Fixed           spExtra;            // last space extra value
   Point           txNumer;            // last text scaling
   Point           txDenom;            // factors

   Boolean         restorePen;         // do any attribs need to be re-issued
   Boolean         restoreBrush;       // after RestoreDC() call?
   Boolean         restoreFont;
   Boolean         restoreCharExtra;
   Boolean         restoreStretchMode;

} GdiCache;

private  GdiCache  gdiCache;

/*********************** Private Function Definitions ***********************/

#define /* void */ NewPolygon( /* void */ )                          \
/* start a new polygon definition */                                 \
gdiCache.numPoints = 0


private void AddPolyPt( Point pt );
/* Add a point to the polygon buffer */


private void SelectCachedPen( void );
/* select the currently cached Pen into the metafile */


/*********************** Function Implementation ****************************/


void CaInit( Handle metafile )
/*=========*/
/* initialize the gdi cache module */
{
   /* save off the metafile handle into global structure */
   gdiCache.metafile = metafile;

   /* make sure that text and background colors will be set */
   gdiCache.curTextColor =
   gdiCache.curBkColor = RGB( 12, 34, 56 );

   /* get handles to some stock pen objects */
   gdiCache.nulPen = GetStockObject( NULL_PEN );
   gdiCache.whitePen = CreatePen( PS_INSIDEFRAME, 1, RGB( 255, 255, 255 ) );
   gdiCache.blackPen = CreatePen( PS_INSIDEFRAME, 1, RGB( 0, 0, 0 ) );

   /* get handles to some stock brush objects */
   gdiCache.nulBrush = GetStockObject( NULL_BRUSH );
   gdiCache.whiteBrush = GetStockObject( WHITE_BRUSH );
   gdiCache.blackBrush = GetStockObject( BLACK_BRUSH );

   /* allocate space for the polygon buffer */
   gdiCache.numPoints = 0;
   gdiCache.maxPoints = 16;
   gdiCache.polyHandle = GlobalAlloc( GHND, gdiCache.maxPoints * sizeof( Point ) );
   if (gdiCache.polyHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull);
   }
   else
   {
      /* get a pointer address for the memory block */
      gdiCache.pointList = (Point far *)GlobalLock( gdiCache.polyHandle );
   }

   /* mark the primitive cache as empty */
   gdiCache.nextPrim.type = CaEmpty;

   /* the current primitive isn't being repeated */
   gdiCache.samePrim = FALSE;

   /* turn off forcing of a new clipping rectangle */
   gdiCache.forceNewClipRect = FALSE;

}  /* CaInit */



void CaFini( void )
/*=========*/
/* close down the cache module */
{
   /* delete the current font selection if non-NULL and non-stock */
   if ((gdiCache.curFont != NULL) && !gdiCache.stockFont)
   {
      /* free the font object */
      DeleteObject( gdiCache.curFont );
   }

   /* remove the current brush selection if non-NULL and not a stock brush */
   if ((gdiCache.curBrush.handle != NULL) && !gdiCache.curBrush.stockObject)
   {
      /* see if the current brush has a DIB - if so, delete it */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN)
      {
         /* free the DIB memory used for brush */
         GlobalFree( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );
      }

      /* delte the brush object */
      DeleteObject( gdiCache.curBrush.handle );
   }

   /* remove the current pen selection if non-NULL and not a stock pen */
   if ((gdiCache.curPen.handle != NULL) && !gdiCache.curPen.stockObject)
   {
      DeleteObject( gdiCache.curPen.handle );
   }

   /* Remove other pens created at initialization time */
   DeleteObject( gdiCache.whitePen );
   DeleteObject( gdiCache.blackPen );

   /* deallocate the polygon buffer */
   GlobalUnlock( gdiCache.polyHandle );
   GlobalFree( gdiCache.polyHandle );

}  /* CaFini */



void CaSetMetafileDefaults( void )
/*========================*/
/* Set up any defaults that will be used throughout the metafile context */
{
   /* set up some metafile defaults */
   gdiCache.iniTextAlign = TA_LEFT | TA_BASELINE | TA_NOUPDATECP;
   gdiCache.iniROP2 = R2_COPYPEN;
   gdiCache.iniBkMode = TRANSPARENT;
   gdiCache.iniTxColor = RGB( 0, 0, 0 );
   gdiCache.iniBkColor = RGB( 255, 255, 255 );

   /* Put the records into the metafile */
   CaSetROP2( gdiCache.iniROP2 );
   CaSetTextAlign( gdiCache.iniTextAlign );
   CaSetBkMode( gdiCache.iniBkMode );
   CaSetTextColor( gdiCache.iniTxColor );
   CaSetBkColor( gdiCache.iniBkColor );

}  /* CaSetMetafileDefaults */



void CaSamePrimitive( Boolean same )
/*==================*/
/* indicate whether next primitive is the same or new */
{
   gdiCache.samePrim = same;

}  /* CaSamePrimitive */



void CaMergePen( Word verb )
/*=============*/
/* indicate that next pen should be merged with previous logical pen */
{
   if (gdiCache.nextPen.handle != NULL)
   {
      /* check to see if this is a NULL pen - the merge can happen */
      if (gdiCache.samePrim && verb == GdiFrame &&
          gdiCache.nextPen.handle == gdiCache.nulPen)
      {
         /* remove the cached pen - don't delte the pen object */
         gdiCache.nextPen.handle = NULL;
      }
      else
     {
         /* if not removing a null pen, then flush the cache.  This will most
            often result in a line segment being flushed. */
         CaFlushCache();
      }
   }

}  /* CaMergePen */



Word CaGetCachedPrimitive( void )
/*=======================*/
/* return the current cached primitive type */
{
   return gdiCache.nextPrim.type;

}  /* CaGetCachedPrimitive */



void CaCachePrimitive( CaPrimitiveLPtr primLPtr )
/*===================*/
/* Cache the primitive passed down.  This includes the current pen and brush. */
{
   /* not another line segment and/or not continuous - flush cache */
   CaFlushCache();

   /* save off the new primitive */
   gdiCache.nextPrim = *primLPtr;

   /* check if we need to copy over the polygon list, also */
   if ((gdiCache.nextPrim.type == CaPolygon) ||
       (gdiCache.nextPrim.type == CaPolyLine))
   {
      /* create new polygon */
      NewPolygon();

      /* add the polygon to the polygon buffer */
      while (gdiCache.nextPrim.a.poly.numPoints--)
      {
         AddPolyPt( *gdiCache.nextPrim.a.poly.pointList++);
      }
   }

}  /* CaCachePrimitive */



void CaFlushCache( void )
/*===============*/
/* Flush the current primitive stored in the cache */
{
   /* if the cache is empty, then just return - nothing to do */
   if (gdiCache.nextPrim.type == CaEmpty)
   {
      return;
   }

   /* select all cached attributes */
   CaFlushAttributes();

   /* emit any cached primitive, if necessary */
   switch (gdiCache.nextPrim.type)
   {
      case CaLine:
      {
         Rect        clip;
         Point       delta;
         Point       offset;

         /* determine the length in both directions */
         delta.x = gdiCache.nextPrim.a.line.end.x - gdiCache.nextPrim.a.line.start.x;
         delta.y = gdiCache.nextPrim.a.line.end.y - gdiCache.nextPrim.a.line.start.y;

         /* set clipRect extents based upon current point position */
         clip.left   = min( gdiCache.nextPrim.a.line.start.x, gdiCache.nextPrim.a.line.end.x );
         clip.top    = min( gdiCache.nextPrim.a.line.start.y, gdiCache.nextPrim.a.line.end.y );
         clip.right  = max( gdiCache.nextPrim.a.line.start.x, gdiCache.nextPrim.a.line.end.x );
         clip.bottom = max( gdiCache.nextPrim.a.line.start.y, gdiCache.nextPrim.a.line.end.y );

         /* extend clip rectangle for down-right pen stylus hang */
         clip.right  += gdiCache.nextPrim.a.line.pnSize.x;
         clip.bottom += gdiCache.nextPrim.a.line.pnSize.y;

         /* determine the new starting and ending points */
         gdiCache.nextPrim.a.line.start.x -= delta.x;
         gdiCache.nextPrim.a.line.start.y -= delta.y;
         gdiCache.nextPrim.a.line.end.x   += delta.x;
         gdiCache.nextPrim.a.line.end.y   += delta.y;

         /* ajust the clipping rect for vertical line penSize roundoff? */
         if (delta.x == 0)
         {
            /* vertical line - expand clip in x dimension */
            clip.left--;
         }
         /* are we are adjusting pen by 1/2 metafile unit - roundoff error? */
         else if (gdiCache.nextPrim.a.line.pnSize.x & 0x01)
         {
            /* adjust clipping rectangle to clip the rounding error */
            clip.right--;
         }

         /* ajust the clipping rect for horizontal line penSize roundoff? */
         if (delta.y == 0)
         {
            /* horizontal line - extend clip in y dimension */
            clip.top--;
         }
         /* are we are adjusting pen by 1/2 metafile unit - roundoff error? */
         else if (gdiCache.nextPrim.a.line.pnSize.y & 0x01)
         {
            /* adjust clipping rectangle to clip the rounding error */
            clip.bottom--;
         }

         /* cut the size of the pen dimensions in half for offsets */
         offset.x = gdiCache.nextPrim.a.line.pnSize.x / 2;
         offset.y = gdiCache.nextPrim.a.line.pnSize.y / 2;

         /* set the new clipping rectangle */
         SaveDC( gdiCache.metafile );
         IntersectClipRect( gdiCache.metafile,
                            clip.left,  clip.top, clip.right, clip.bottom );

         /* move to the first point and draw to second (with padding) */

// MoveTo is replaced by MoveToEx in win32
#ifdef WIN32
         MoveToEx( gdiCache.metafile,
                   gdiCache.nextPrim.a.line.start.x + offset.x,
                   gdiCache.nextPrim.a.line.start.y + offset.y, NULL );
#else
         MoveTo( gdiCache.metafile,
                 gdiCache.nextPrim.a.line.start.x + offset.x,
                 gdiCache.nextPrim.a.line.start.y + offset.y );
#endif

         LineTo( gdiCache.metafile,
                 gdiCache.nextPrim.a.line.end.x + offset.x,
                 gdiCache.nextPrim.a.line.end.y + offset.y );

         /* restore the previous clipping rectangle */
         RestoreDC( gdiCache.metafile, -1 );
         break;
      }

      case CaRectangle:
      {
         if (gdiCache.curPen.handle == gdiCache.nulPen)
         {
            Point    poly[5];

            /* set up the bounding coodinates */
            poly[0].x = poly[3].x = gdiCache.nextPrim.a.rect.bbox.left;
            poly[0].y = poly[1].y = gdiCache.nextPrim.a.rect.bbox.top;
            poly[1].x = poly[2].x = gdiCache.nextPrim.a.rect.bbox.right;
            poly[2].y = poly[3].y = gdiCache.nextPrim.a.rect.bbox.bottom;
            poly[4]   = poly[0];

            /* perform call to render rectangle */
            Polygon( gdiCache.metafile, poly, 5 );
         }
         else
         {
            Rectangle( gdiCache.metafile,
                       gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                       gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom );
         }
         break;
      }

      case CaRoundRect:
      {
         RoundRect( gdiCache.metafile,
                    gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                    gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom,
                    gdiCache.nextPrim.a.rect.oval.x,     gdiCache.nextPrim.a.rect.oval.y );
         break;
      }

      case CaEllipse:
      {
         Ellipse( gdiCache.metafile,
                  gdiCache.nextPrim.a.rect.bbox.left,  gdiCache.nextPrim.a.rect.bbox.top,
                  gdiCache.nextPrim.a.rect.bbox.right, gdiCache.nextPrim.a.rect.bbox.bottom );
         break;
      }

      case CaArc:
      {
         Arc( gdiCache.metafile,
              gdiCache.nextPrim.a.arc.bbox.left,  gdiCache.nextPrim.a.arc.bbox.top,
              gdiCache.nextPrim.a.arc.bbox.right, gdiCache.nextPrim.a.arc.bbox.bottom,
              gdiCache.nextPrim.a.arc.start.x,    gdiCache.nextPrim.a.arc.start.y,
              gdiCache.nextPrim.a.arc.end.x,      gdiCache.nextPrim.a.arc.end.y );
         break;
      }

      case CaPie:
      {
         Pie( gdiCache.metafile,
              gdiCache.nextPrim.a.arc.bbox.left,  gdiCache.nextPrim.a.arc.bbox.top,
              gdiCache.nextPrim.a.arc.bbox.right, gdiCache.nextPrim.a.arc.bbox.bottom,
              gdiCache.nextPrim.a.arc.start.x,    gdiCache.nextPrim.a.arc.start.y,
              gdiCache.nextPrim.a.arc.end.x,      gdiCache.nextPrim.a.arc.end.y );
         break;
      }

      case CaPolygon:
      case CaPolyLine:
      {
         Point       offset;
         Integer     i;

         /* see if centering of the pen is required  */
         if (gdiCache.curPen.handle == gdiCache.nulPen)
         {
            /* no - just filling the object without frame */
            offset.x = offset.y = 0;
         }
         else
         {
            /* transform all points to correct for down-right pen
               rendering in QuickDraw and make for a GDI centered pen */
            offset.x = gdiCache.nextPrim.a.poly.pnSize.x / 2;
            offset.y = gdiCache.nextPrim.a.poly.pnSize.y / 2;
         }

         /* transform end point for all points in the polygon */
         for (i = 0; i < gdiCache.numPoints; i++)
         {
            /* increment each coordinate pair off half of the pen size */
            gdiCache.pointList[i].x += offset.x;
            gdiCache.pointList[i].y += offset.y;
         }

         /* call the appropriate GDI routine based upon the type */
         if (gdiCache.nextPrim.type == CaPolygon)
         {
            Polygon( gdiCache.metafile,
                     gdiCache.pointList,
                     gdiCache.numPoints );
         }
         else
         {
            Polyline( gdiCache.metafile,
                      gdiCache.pointList,
                      gdiCache.numPoints );
         }
         break;
      }
   }

   /* mark the primitive cache as empty */
   gdiCache.nextPrim.type = CaEmpty;

}  /* CaFlushCache */



void CaFlushAttributes( void )
/*====================*/
/* flush any pending attribute elements */
{
   /* select the cached pen - the routine will determine if one exits */
   SelectCachedPen();

}  /* CaFlushAttributes */



void CaCreatePenIndirect( LOGPEN far * newLogPen )
/*======================*/
/* create a new pen */
{
   PenLPtr     compare;
   Boolean     different;

   /* determine which pen to compare against */
   compare = (gdiCache.nextPen.handle != NULL) ? &gdiCache.nextPen :
                                                 &gdiCache.curPen;

   /* compare the two pens */
   different = ((newLogPen->lopnStyle   != compare->logPen.lopnStyle) ||
                (newLogPen->lopnColor   != compare->logPen.lopnColor) ||
                (newLogPen->lopnWidth.x != compare->logPen.lopnWidth.x));

   /* if the pens are different ... */
   if (different)
   {
      /* if there is a cached pen ... */
      if (gdiCache.nextPen.handle != NULL)
      {
         /* flush the cached primitive - there is a change of pens */
         CaFlushCache();

         /* check to see if the new pen is changed by next selection */
         different = ((newLogPen->lopnStyle   != gdiCache.curPen.logPen.lopnStyle) ||
                      (newLogPen->lopnColor   != gdiCache.curPen.logPen.lopnColor) ||
                      (newLogPen->lopnWidth.x != gdiCache.curPen.logPen.lopnWidth.x));
      }
   }

   /* if the pen has changed from the current setting, cache the next pen */
   if (different || gdiCache.curPen.handle == NULL)
   {
      /* if there is a pending line or polyline, the flush the cache */
      if (gdiCache.nextPrim.type == CaLine || gdiCache.nextPrim.type == CaPolyLine)
      {
         CaFlushCache();
      }

      /* assign the new pen attributes */
      gdiCache.nextPen.logPen = *newLogPen;

      /* currently not using a stock pen object */
      gdiCache.nextPen.stockObject = FALSE;

      /* check for any pre-defined pen objects */
      if (gdiCache.nextPen.logPen.lopnStyle == PS_NULL)
      {
         /* and use them if possible */
         gdiCache.nextPen.handle = gdiCache.nulPen;
         gdiCache.nextPen.stockObject = TRUE;
      }
      else if (gdiCache.nextPen.logPen.lopnWidth.x == 1)
      {
         if (newLogPen->lopnColor == RGB( 0, 0, 0 ))
         {
            gdiCache.nextPen.handle = gdiCache.blackPen;
            gdiCache.nextPen.stockObject = TRUE;
         }
         else if (gdiCache.nextPen.logPen.lopnColor == RGB( 255, 255, 255 ))
         {
            gdiCache.nextPen.handle = gdiCache.whitePen;
            gdiCache.nextPen.stockObject = TRUE;
         }
      }

      if (!gdiCache.nextPen.stockObject)
      {
         /* otherwise, create a new pen */
         gdiCache.nextPen.handle = CreatePenIndirect( &gdiCache.nextPen.logPen );
      }
   }
   else
   {
      /* copy the current setting back into the next pen setting */
      gdiCache.nextPen = gdiCache.curPen;
   }

   /* check if cache was invalidated */
   if (gdiCache.restorePen && (gdiCache.curPen.handle != NULL))
   {
      /* if pen was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curPen.handle );
   }

   /* all is ok with cache now */
   gdiCache.restorePen = FALSE;

}  /* CaCreatePenIndirect */



void CaCreateBrushIndirect( LOGBRUSH far * newLogBrush )
/*========================*/
/* Create a new logical brush using structure passed in */
{
   /* assume that the DIB patterns are different */
   Boolean  differentDIB = TRUE;

   /* check if we are comparing two DIB patterned brushes */
   if ((newLogBrush->lbStyle == BS_DIBPATTERN) &&
       (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN))
   {
      Word  nextSize = (Word)GlobalSize( (HANDLE) newLogBrush->lbHatch ) / 2;
      Word  currSize = (Word)GlobalSize( (HANDLE) gdiCache.curBrush.logBrush.lbHatch ) / 2;

      /* make sure that the sizes are the same */
      if (nextSize == currSize)
      {
         Word far *  nextDIBPattern = (Word far *)GlobalLock( (HANDLE) newLogBrush->lbHatch );
         Word far *  currDIBPattern = (Word far *)GlobalLock( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );

         /* assume that the DIBs are the same so far */
         differentDIB = FALSE;

         /* compare all the bytes in the two brush patterns */
         while (currSize--)
         {
            /* are they the same ? */
            if (*nextDIBPattern++ != *currDIBPattern++)
            {
               /* if not, flag the difference and break from the loop */
               differentDIB = TRUE;
               break;
            }
         }

         /* Unlock the data blocks */
         GlobalUnlock( (HANDLE) newLogBrush->lbHatch );
         GlobalUnlock( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );

         /* see if these did compare exactly */
         if (!differentDIB)
         {
            /* if so, free the new DIB brush - it's no longer needed */
            GlobalFree( (HANDLE) newLogBrush->lbHatch );
         }
      }
   }

   /* see if we are requesting a new brush */
   if (differentDIB &&
      (newLogBrush->lbStyle != gdiCache.curBrush.logBrush.lbStyle ||
       newLogBrush->lbColor != gdiCache.curBrush.logBrush.lbColor ||
       newLogBrush->lbHatch != gdiCache.curBrush.logBrush.lbHatch ||
       gdiCache.curBrush.handle == NULL))
   {
      HBRUSH   brushHandle;
      Boolean  stockBrush;

      /* flush the primitive cache if changing brush selection */
      CaFlushCache();

      /* if current brush has a DIB, make sure to free memory */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_DIBPATTERN)
      {
         /* free the memory */
         GlobalFree( (HANDLE) gdiCache.curBrush.logBrush.lbHatch );
      }

      /* copy over the new structure */
      gdiCache.curBrush.logBrush = *newLogBrush;

      /* We currently aren't using a stock brush */
      stockBrush = FALSE;

      /* use stock objects if possible */
      if (gdiCache.curBrush.logBrush.lbStyle == BS_HOLLOW)
      {
         /* use null (hollow) brush */
         brushHandle = gdiCache.nulBrush;
         stockBrush = TRUE;
      }
      /* check for some standard solid colored brushes */
      else if (gdiCache.curBrush.logBrush.lbStyle == BS_SOLID)
      {
         if (gdiCache.curBrush.logBrush.lbColor == RGB( 0, 0, 0) )
         {
            /* use solid black brush */
            brushHandle = gdiCache.blackBrush;
            stockBrush = TRUE;
         }
         else if (gdiCache.curBrush.logBrush.lbColor == RGB( 255, 255, 255 ))
         {
            /* use solid white brush */
            brushHandle = gdiCache.whiteBrush;
            stockBrush = TRUE;
         }
      }

      /* if unable to find a stock brush, then create a new one */
      if (!stockBrush)
      {
         /* otherwise, create new brush using logbrush structure */
         brushHandle = CreateBrushIndirect( &gdiCache.curBrush.logBrush );
      }

      /* select the new brush */
      SelectObject( gdiCache.metafile, brushHandle );

      /* if this isn't the first brush selection and not a stock brush */
      if (gdiCache.curBrush.handle != NULL && !gdiCache.curBrush.stockObject)
      {
         /* delete the previous brush object */
         DeleteObject( gdiCache.curBrush.handle );
      }

      /* save brush handle in current cache variable */
      gdiCache.curBrush.handle = brushHandle;
      gdiCache.curBrush.stockObject = stockBrush;
   }
   else if (gdiCache.restoreBrush)
   {
      /* if brush was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curBrush.handle );
   }

   /* all is ok with cache now */
   gdiCache.restoreBrush = FALSE;

}  /* CaCreateBrushIndirect */



void CaCreateFontIndirect( LOGFONT far * newLogFont )
/*=======================*/
/* create the logical font passed as paramter */
{
   /* make sure we are requesting a new font */
   if (newLogFont->lfHeight != gdiCache.curLogFont.lfHeight ||
       newLogFont->lfWeight != gdiCache.curLogFont.lfWeight ||
       newLogFont->lfEscapement  != gdiCache.curLogFont.lfEscapement ||
       newLogFont->lfOrientation != gdiCache.curLogFont.lfOrientation ||
       newLogFont->lfItalic != gdiCache.curLogFont.lfItalic ||
       newLogFont->lfUnderline != gdiCache.curLogFont.lfUnderline ||
       newLogFont->lfPitchAndFamily != gdiCache.curLogFont.lfPitchAndFamily ||
       lstrcmp( newLogFont->lfFaceName, gdiCache.curLogFont.lfFaceName ) != 0 ||
       gdiCache.curFont == NULL)
   {
      HFONT       fontHandle;
      Boolean     stockFont;

      /* flush the primitive cache if changing font attributes */
      CaFlushCache();

      /* assign the new pen attributes */
      gdiCache.curLogFont = *newLogFont;

      /* currently not using a stock font object */
      stockFont = FALSE;

      /* check for any pre-defined pen objects */
      if (newLogFont->lfFaceName == NULL)
      {
         fontHandle = GetStockObject( SYSTEM_FONT );
         stockFont = TRUE;
      }
      else
      {
         /* otherwise, create a new pen */
         fontHandle = CreateFontIndirect( &gdiCache.curLogFont );
      }

      /* select the new font */
      SelectObject( gdiCache.metafile, fontHandle );

      /* if this isn't the first font selection and not a stock font */
      if (gdiCache.curFont != NULL && !gdiCache.stockFont)
      {
         /* delete the previous font object */
         DeleteObject( gdiCache.curFont );
      }

      /* save font handle in current cache variable */
      gdiCache.curFont = fontHandle;
      gdiCache.stockFont = stockFont;
   }
   else if (gdiCache.restoreFont)
   {
      /* if pen was invalidated by RestoreDC(), reselect it */
      SelectObject( gdiCache.metafile, gdiCache.curFont );
   }

   /* all is ok with cache now */
   gdiCache.restoreFont = FALSE;

}  /* CaCreateFontIndirect */



void CaSetBkMode( Word mode )
/*==============*/
/* set the backgound transfer mode */
{
   if (gdiCache.curBkMode != mode)
   {
      /* flush the primitive cache if changing mode */
      CaFlushCache();

      /* set the background mode and save in global cache */
      SetBkMode( gdiCache.metafile, mode );
      gdiCache.curBkMode = mode;
   }

   /* no need to worry about restoring BkMode, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetBkMode */



void CaSetROP2( Word ROP2Code )
/*============*/
/* set the transfer ROP mode according to ROP2Code */
{
   /* check for change in ROP code */
   if (gdiCache.curROP2 != ROP2Code)
   {
      /* flush the primitive cache if changing ROP mode */
      CaFlushCache();

      /* set the ROP code and save in global cache variable */
      SetROP2( gdiCache.metafile, ROP2Code );
      gdiCache.curROP2 = ROP2Code;
   }

   /* no need to worry about restoring ROP code, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetROP2 */



void CaSetStretchBltMode( Word mode )
/*======================*/
/* stretch blt mode - how to preserve scanlines using StretchDIBits() */
{
   if (gdiCache.curStretchMode != mode)
   {
      /* flush the primitive cache if changing mode */
      CaFlushCache();

      /* set the stretch blt mode and save in global cache variable */
      SetStretchBltMode( gdiCache.metafile, mode );
      gdiCache.curStretchMode = mode;
   }
   else if (gdiCache.restoreStretchMode)
   {
      /* if stretch blt mode was invalidated by RestoreDC(), re-issue */
      SetStretchBltMode( gdiCache.metafile, gdiCache.curStretchMode );
   }

   /* all is ok with cache now */
   gdiCache.restoreStretchMode = FALSE;

}  /* CaSetStretchBltMode */



void CaSetTextAlign( Word txtAlign )
/*=================*/
/* set text alignment according to parameter */
{
   if (gdiCache.curTextAlign != txtAlign)
   {
      /* flush the primitive cache if changing text alignment */
      CaFlushCache();

      /* Set the text color and save in cache */
      SetTextAlign( gdiCache.metafile, txtAlign );
      gdiCache.curTextAlign = txtAlign;
   }

   /* no need to worry about restoring text align, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetTextAlign */


void CaSetTextColor( RGBColor txtColor )
/*=================*/
/* set the text color if different from current setting */
{
   if (gdiCache.curTextColor != txtColor)
   {
      /* flush the primitive cache if changing text color */
      CaFlushCache();

      /* Set the text color and save in cache */
      SetTextColor( gdiCache.metafile, txtColor );
      gdiCache.curTextColor = txtColor;
   }

   /* no need to worry about restoring text color, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetTextColor */


void CaSetTextCharacterExtra( Integer chExtra )
/*==========================*/
/* set the character extra spacing */
{
   if (gdiCache.curCharExtra != chExtra)
   {
      /* flush the primitive cache if changing text char extra */
      CaFlushCache();

      /* set the char extra and same state in the cache */
      SetTextCharacterExtra( gdiCache.metafile, chExtra );
      gdiCache.curCharExtra = (WORD) chExtra;

   }
   else if (gdiCache.restoreCharExtra)
   {
      /* if text char extra was invalidated by RestoreDC(), re-issue */
      SetTextCharacterExtra( gdiCache.metafile, gdiCache.curCharExtra );
   }

   /* all is ok with cache now */
   gdiCache.restoreCharExtra = FALSE;

}  /* CaSetTextCharacterExtra */


void CaSetBkColor( RGBColor bkColor )
/*===============*/
/* set background color if different from current setting */
{
   if (gdiCache.curBkColor != bkColor)
   {
      /* flush the primitive cache if changing background color */
      CaFlushCache();

      /* Set the background color and save in cache */
      SetBkColor( gdiCache.metafile, bkColor );
      gdiCache.curBkColor = bkColor;
   }

   /* no need to worry about restoring background color, since this is set
      before the initial SaveDC() is issued and is restored after each
      RestoreDC() call back to the metafile default. */

}  /* CaSetBkColor */


Boolean CaIntersectClipRect( Rect rect )
/*=========================*/
/* Create new clipping rectangle - return FALSE if drawing is disabled */
{
   Rect     combinedRect;

   /* See if the clipping rectangle is empty, indicating that no drawing
      should occur into the metafile */
   if (Height( rect ) == 0 || Width( rect ) == 0)
   {
      /* indicate that drawing is disabled */
      return FALSE;
   }

   /* don't do anything if rectangle hasn't changed */
   if (!EqualRect( &rect, &gdiCache.curClipRect ) || gdiCache.forceNewClipRect)
   {
      /* flush the primitive cache if changing clip region */
      CaFlushCache();

      /* is new clip rect is completely enclosed by current cliprect? */
      IntersectRect( &combinedRect, &rect, &gdiCache.curClipRect );

      /* check for equality of intersection and new cliprect */
      if (!EqualRect( &combinedRect, &rect ) || gdiCache.forceNewClipRect)
      {
         /* must be called just to be able to change clipping rectangle */
         CaRestoreDC();
         CaSaveDC();
      }

      /* set the new clipping rectangle */
      IntersectClipRect( gdiCache.metafile,
                         rect.left, rect.top, rect.right, rect.bottom );

      /* save the current clip rectangle, since it has changed */
      gdiCache.curClipRect = rect;

      /* turn off forcing of the clipping rectangle */
      gdiCache.forceNewClipRect = FALSE;
   }

   /* return TRUE - drawing is enabled */
   return TRUE;

}  /* GdiIntersectClipRect */


void CaSetClipRect( Rect rect )
/*================*/
/* set the current cliprectangle to be equal to rect */
{
   gdiCache.curClipRect = rect;

}  /* CaSetClipRect */


Rect far * CaGetClipRect( void )
/*=====================*/
/* get the current cliprectangle */
{
   return &gdiCache.curClipRect;

}  /* CaGetClipRect */


void CaNonRectangularClip( void )
/*=======================*/
/* notify cache that a non-rectangular clipping region was set */
{
   gdiCache.forceNewClipRect = TRUE;

}  /* CaNonRectangularClip */


void CaSaveDC( void )
/*===========*/
/* save the current device context - used to set up clipping rects */
{
   /* the previous clipping rectangle is saved off */
   gdiCache.prevClipRect = gdiCache.curClipRect;

   /* issue call to GDI */
   SaveDC( gdiCache.metafile );
}


void CaRestoreDC( void )
/*==============*/
/* restore the device context and invalidate cached attributes */
{
   /* restore previous clipping rectangle */
   gdiCache.curClipRect = gdiCache.prevClipRect;

   /* invalidate all of the cached attributes and objects */
   gdiCache.restorePen =
   gdiCache.restoreBrush =
   gdiCache.restoreFont =
   gdiCache.restoreCharExtra = TRUE;

   /* reset metafile defaults */
   gdiCache.curROP2 = gdiCache.iniROP2;
   gdiCache.curTextAlign = gdiCache.iniTextAlign;
   gdiCache.curBkMode = gdiCache.iniBkMode;
   gdiCache.curTextColor = gdiCache.iniTxColor;
   gdiCache.curBkColor = gdiCache.iniBkColor;

   /* issue call to GDI */
   RestoreDC( gdiCache.metafile, -1 );
}

/******************************* Private Routines ***************************/


private void AddPolyPt( Point pt )
/*--------------------*/
/* Add a point to the polygon buffer */
{
   /* make sure that we haven't reached maximum size */
   if ((gdiCache.numPoints + 1) >= gdiCache.maxPoints)
   {
      /* expand the number of points that can be cached by 10 */
      gdiCache.maxPoints += 16;

      /* unlock to prepare for re-allocation */
      GlobalUnlock( gdiCache.polyHandle);

      /* re-allocate the memory handle by the given amount */
      gdiCache.polyHandle = GlobalReAlloc(
            gdiCache.polyHandle,
            gdiCache.maxPoints * sizeof( Point ),
            GMEM_MOVEABLE);

      /* make sure that the re-allocation succeeded */
      if (gdiCache.polyHandle == NULL)
      {
         /* if not, flag global error and exit from here */
         ErSetGlobalError( ErMemoryFull );
         return;
      }

      /* lock the memory handle to get a pointer address */
      gdiCache.pointList = (Point far *)GlobalLock( gdiCache.polyHandle );
   }

   /* insert the new point and increment the number of points in the buffer */
   gdiCache.pointList[gdiCache.numPoints++] = pt;

}  /* AddPolyPt */



private void SelectCachedPen( void )
/*--------------------------*/
/* select the currently cached Pen into the metafile */
{
   /* make sure that there is some new pen to select */
   if (gdiCache.nextPen.handle != NULL)
   {
      /* make sure that the pens are different */
      if (gdiCache.nextPen.handle != gdiCache.curPen.handle)
      {
        /* select the new pen */
         SelectObject( gdiCache.metafile, gdiCache.nextPen.handle);

         /* if this isn't the first pen selection and not a stock pen */
         if (gdiCache.curPen.handle != NULL && !gdiCache.curPen.stockObject)
         {
            /* delete the previous pen selection */
            DeleteObject( gdiCache.curPen.handle );
         }

         /* save pen handle in current cache variable */
         gdiCache.curPen = gdiCache.nextPen;
      }

      /* reset the cache pen to indicate no pre-existing cached pen */
      gdiCache.nextPen.handle = NULL;
   }

}  /* SelectCachedPen */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\error.c ===
/****************************************************************************
                       Unit Bufio; Implementation
*****************************************************************************

 Error handles all the interpretation, metafile creation, or read failures
 that may occur during the course of the translation.

 Currently it only supports saving a single error into a global variable.

   Module Prefix: Er

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#ifndef _OLECNV32_
#define IMPDEFS
#include "errdefs.h"       /* Aldus error return codes */
#endif

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

OSErr       globalError;         /* not declared private for macro calls */

/*********************** Private Function Definitions ***********************/


/*********************** Function Implementation ****************************/

#ifndef _OLECNV32_

OSErr ErInternalErrorToAldus( void )
/*==========================*/
/* returns the appropriate Aldus error code given the current global error */
{
   switch (globalError)
   {
      case ErNoError             : return NOERR;

      case ErInvalidVersion      :
      case ErInvalidVersionID    :
      case ErBadHeaderSequence   : return IE_NOT_MY_FILE;

      case ErCreateMetafileFail  :
      case ErCloseMetafileFail   :
      case ErMemoryFull          : return IE_MEM_FULL;

      case ErMemoryFail          : return IE_MEM_FAIL;

      case ErNullBoundingRect    :
      case ErReadPastEOF         : return IE_BAD_FILE_DATA;

      case ErEmptyPicture        : return IE_NOPICTURES;

      case Er32KBoundingRect     : return IE_TOO_BIG;

      case ErNoDialogBox         :
      case ErOpenFail            :
      case ErReadFail            : return IE_IMPORT_ABORT;

      case ErNoSourceFormat      :
      case ErNonSquarePen        :
      case ErInvalidXferMode     :
      case ErNonRectRegion       : return IE_UNSUPP_VERSION;

      default                    : return IE_IMPORT_ABORT;
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\cache.h ===
/****************************************************************************
                       Unit Cache; Interface
*****************************************************************************

   Module Prefix: Ca

*****************************************************************************/


#define     CaEmpty        0
#define     CaLine         1
#define     CaRectangle    2
#define     CaRoundRect    3
#define     CaEllipse      4
#define     CaArc          5
#define     CaPie          6
#define     CaPolygon      7
#define     CaPolyLine     8

typedef struct
{
   Word        type;
   Word        verb;
   union
   {
      struct
      {
         Point       start;
         Point       end;
         Point       pnSize;
      } line;

      struct
      {
         Rect        bbox;
         Point       oval;
      } rect;

      struct
      {
         Rect        bbox;
         Point       start;
         Point       end;
      } arc;

      struct
      {
         Integer     numPoints;
         Point far * pointList;
         Point       pnSize;
      } poly;

   } a;

} CaPrimitive, far * CaPrimitiveLPtr;


/*********************** Exported Function Definitions **********************/

void CaInit( Handle metafile );
/* initialize the gdi cache module */


void CaFini( void );
/* close down the cache module */


void CaSetMetafileDefaults( void );
/* Set up any defaults that will be used throughout the metafile context */


Word CaGetCachedPrimitive( void );
/* return the current cached primitive type */


void CaSamePrimitive( Boolean same );
/* indicate whether next primitive is the same or new */


void CaMergePen( Word verb );
/* indicate that next pen should be merged with previous logical pen */


void CaCachePrimitive( CaPrimitiveLPtr primLPtr );
/* Cache the primitive passed down.  This includes the current pen and brush. */


void CaFlushCache( void );
/* Flush the current primitive stored in the cache */
 

void CaFlushAttributes( void );
/* flush any pending attribute elements */


void CaCreatePenIndirect( LOGPEN far * newLogPen );
/* create a new pen */

   
void CaCreateBrushIndirect( LOGBRUSH far * newLogBrush );
/* Create a new logical brush using structure passed in */


void CaCreateFontIndirect( LOGFONT far * newLogFont );
/* create the logical font passed as paramter */


void CaSetBkMode( Word mode );
/* set the backgound transfer mode */


void CaSetROP2( Word ROP2Code );
/* set the transfer ROP mode according to ROP2Code */


void CaSetStretchBltMode( Word mode );
/* stretch blt mode - how to preserve scanlines using StretchDIBits() */


void CaSetTextAlign( Word txtAlign );
/* set text alignment according to parameter */


void CaSetTextColor( RGBColor txtColor );
/* set the text color if different from current setting */


void CaSetTextCharacterExtra( Integer chExtra );
/* set the character extra spacing */


void CaSetBkColor( RGBColor bkColor );
/* set background color if different from current setting */


Boolean CaIntersectClipRect( Rect rect );
/* Create new clipping rectangle - return FALSE if drawing is disabled */


void CaSetClipRect( Rect rect );
/* set the current cliprectangle to be equal to rect */

Rect far * CaGetClipRect( void );
/* return the current cached clip rectangle */

void CaNonRectangularClip( void );
/* notify cache that a non-rectangular clipping region was set */

void CaSaveDC( void );
/* save the current device context - used to set up clipping rects */


void CaRestoreDC( void );
/* restore the device context and invalidate cached attributes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\error.h ===
/****************************************************************************
                       Unit Error; Interface
*****************************************************************************

 Error handles all the interpretation, metafile creation, or read failures
 that may occur during the course of the translation.

   Module Prefix: Er

*****************************************************************************/


/********************* Exported Data ***************************************/

#define  ErNoError            NOERR
#define  ErInvalidVersion     1        /* file is not version 1 or 2       */
#define  ErInvalidVersionID   2        /* PICT 2 version ID invalid        */
#define  ErBadHeaderSequence  3        /* PICT 2 HeaderOp not found        */
#define  ErInvalidPrefsHeader 4        /* Preferences header invalid       */
#define  ErNoSourceFormat     5        /* no source filename/handle given  */

#define  ErMemoryFull         10       /* GlobalAlloc() fail               */
#define  ErMemoryFail         11       /* GlobalLock() fail                */
#define  ErCreateMetafileFail 12       /* CreateMetafile() fail            */
#define  ErCloseMetafileFail  13       /* CloseMetafile() fail             */

#define  ErEmptyPicture       20       /* no primitives found in file      */

#define  ErNullBoundingRect   30       /* BBox defines NULL area           */
#define  Er32KBoundingRect    31       /* BBox extents exceed 32K          */

#define  ErReadPastEOF        40       /* Attempt to read past end of file */
#define  ErOpenFail           41       /* OpenFile() failed                */
#define  ErReadFail           42       /* read from disk failed            */

#define  ErNonSquarePen       50       /* non-square pen & user pref abort */
#define  ErPatternedPen       51       /* patterned pen & user pref abort  */
#define  ErInvalidXferMode    52       /* invalid transfer mode & abort    */
#define  ErNonRectRegion      53       /* non-rectangular region abort     */

#define  ErNoDialogBox        60       /* unable to run status dialog box  */

extern   OSErr    globalError;

/*********************** Exported Function Definitions **********************/

#define  ErSetGlobalError( /* OSErr */ error ) \
/* callback function that allows any routine to set a global error state */ \
globalError = error

#define ErGetGlobalError( /* void */ ) \
/* callback function that allows any routine to get global error state */ \
globalError

OSErr ErInternalErrorToAldus( void );
/* returns the appropriate Aldus error code given the current global error */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\filesys.h ===
/****************************************************************************
                       Unit FileSys; Interface
*****************************************************************************

 FileSys implements the DOS file system calls used by the Presenter and BFile.
 The interface is preserved to be mostly the same as the MAC OS interface.
 All filenames and directories passed as arguments are assumned to be in Ansi,
 and all filenames and directories returned will be in Ansi.

   Module prefix: FS

****************************************************************************/


/********************* Exported Data ***************************************/

#define  FSFROMSTART    0     /* From Start of file */
#define  FSFROMMARK     1     /* From current file marker */
#define  FSFROMLEOF     2     /* From End of File */

/* File System errors */

#define  FSERROR       -1     /* failure flage for file I/O       */
#define  FUNCERR        1     /* invalid function */
#define  FNFERR         2     /* DOS file not found */
#define  DIRNFERR       3     /* Path not found */
#define  DUPFNERR       4     /* DOS too many files opened */
#define  TMFOERR        4
#define  OPWRERR        5     /* DOS Access denied error */
#define  FNOPNERR       6     /* DOS invalid handle */
#define  MEMFULLERR     8     /* Insufficient memory */
#define  IOERR         13     /* DOS invalid data */
#define  VOLOFFLINERR  15     /* DOS Drive not ready */
#define  WPRERR        19     /* DOS disk write-protected */
#define  POSERR        25     /* Invalid Seek */
#define  PERMERR       32     /* DOS sharing violation */
#define  VLCKDERR      33     /* DOS lock violation */
#define  WRPERMERR     65     /* Network Write Permission Error: access denied */
#define  DIRFULERR     82     /* DOS cannot make directory entry */
#define  ABORTERR      83     /* Fail DOS int24 critical handler */

#define  DSKFULERR    -34     /* MAC Disk full error */
#define  EOFERR       -39     /* MAC end-of-file error */
#define  FBSYERR      -47     /* MAC file busy error */
#define  FLCKDERR     -49     /* MAC file is locked error */

/* Scrap Manager errors */
#define  NOSCRAPERR   -100    /* MAC Desk scrap isn't initialized */
#define  NOFORMATERR  -101    /* MAC No data of the requested format */
#define  SPOPENERR    -102    /* PP Couldn't open the scrap */
#define  SPDATAERR    -103    /* PP the scrap had invalid data */

#define  MAXBLERR     - 2     /* Block too large error */

/* File attribute constants */
#define FS_NORMAL    0x00     /* Normal file - No read/write restrictions */
#define FS_RDONLY    0x01     /* Read only file */
#define FS_HIDDEN    0x02     /* Hidden file */
#define FS_SYSTEM    0x04     /* System file */
#define FS_VOLID     0x08     /* Volume ID file */
#define FS_SUBDIR    0x10     /* Subdirectory */
#define FS_ARCH      0x20     /* Archive file */


/********************* Exported Operations *********************************/

OSErr FSRead( Integer fileRef, LongInt far * lbytes, LPtr des);
/* Read lbytes long from file fileRef to buffer des. 'Lbytes' is updated to
   indicate the number of bytes actually read.  Error is returned by function
   if !FALSE. */

OSErr FSGetFPos( Integer fileRef, LongInt far * markPos );
/* Get the current mark position in fileRef. Return that position
   in markPos. Function returns error code if !NOERR. */

OSErr FSSetFPos(Integer fileRef, Word postype, LongInt Offset);
/* Move the fileRef file pointer to the new position Offset */

OSErr FSOpen( StringLPtr filename, Word mode, Integer far* fileRef);
/* Open filename with DOS OPEN 'mode' and return a valid 'fileRef' if NOERR.
   Create an entry in the internal file table and initialize it. The DOS
   handle is left opened (for performance reasons) until
   FSTempClose(fileRef) is called. Return the appropriate error
   if failed. */

OSErr FSCloseFile(Integer fileRef);
/* Close the file given its 'fileRef'. Also remove its file table entry. */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\gdiprim.c ===
/****************************************************************************
                       Unit GdiPrim; Implementation
*****************************************************************************

 The Gdi module is called directly by the QuickDraw (QD) module in order
 to emit metafile primitives.  It is responsible for accessing the current
 CGrafPort structure in order to access the individual attribute settings.

 It also supports the caching and redundant elimination of duplicate
 elements when writing to the metafile.

   Module Prefix: Gdi

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  "math.h"         /* for floating-point (sin, cos) calculations */
#include  "qdcoment.i"     /* for interpretation of picture comments */
#include  "cache.h"        /* for all drawing to metafile context */

/*********************** Exported Data **************************************/

/*********************** Private Data ***************************************/

/*--- mixture of grey values ---*/

#define  NOMIX       FALSE
#define  MIXGREY     TRUE

/*--- Gdi environment ---*/

typedef struct{
   Handle          metafile;              // metafile handle

   LOGBRUSH        newLogBrush;
   LOGFONT         newLogFont;
   LOGPEN          newLogPen;

   Rect            clipRect;              // current clip rectangle

   Boolean         drawingEnabled;        // is drawing currently enabled?
   Boolean         sameObject;            // same primitive being drawn?
   Boolean         useGdiFont;            // override font search w/Gdi name?

   Integer         hatchIndex;            // hatch pattern for fills

   Pattern         lastPattern;           // patterns used for the current
   Integer         lastPatType;           // brush selection
   RGBColor        lastFgColor;           // fore- and background colors
   RGBColor        lastBkColor;           // used to create selected brush

   HDC             infoContext;           // information context for fonts
   FONTENUMPROC    fontFunction;          // used to access font information

   Byte            state[GdiNumAttrib];   // have various attributes changed

} GdiEnv;

private  GdiEnv         gdiEnv;
private  ConvPrefsLPtr  gdiPrefsLPtr;
private  PICTINFO       gdiPict;


/*--- Font face translation ---*/

#define  FntSystemFont     0
#define  FntApplFont       1
#define  FntNewYork        2
#define  FntGeneva         3
#define  FntMonaco         4
#define  FntVenice         5
#define  FntLondon         6
#define  FntAthens         7
#define  FntSanFran        8
#define  FntToronto        9
#define  FntCairo          11
#define  FntLosAngeles     12
#define  FntZapfDingbats   13
#define  FntBookman        14
#define  FntHelvNarrow     15
#define  FntPalatino       16
#define  FntZapfChancery   18
#define  FntTimes          20
#define  FntHelvetica      21
#define  FntCourier        22
#define  FntSymbol         23
#define  FntMobile         24
#define  FntAvantGarde     33
#define  FntNewCentury     34
#define  FntMTExtra        2515
#define  FntUnknown        -1

#define  MaxFntName        LF_FACESIZE
#define  NumFntEntries     27
#define  NumTTSubs         12
#define  TTSubStart        11
#define  FntFromGdi        (NumFntEntries - 1)
#define  FntNoMatch        (NumFntEntries - 2)
#define  FntDefault        2

#define  MTEXTRA_CHARSET   160
#define  FENCES_CHARSET    161

typedef struct
{
   Integer     fontNum;
   Byte        macName[MaxFntName];
   Byte        gdiName[MaxFntName];
   Byte        family;
   Byte        charset;
} FontEntry, far * FontEntryLPtr;

private  FontEntry   fontTable[NumFntEntries] =
{
   { FntSystemFont,   "Chicago",            "Chicago",          FF_ROMAN,      ANSI_CHARSET },
   { FntNewYork,      "New York",           "New York",         FF_ROMAN,      ANSI_CHARSET },
   { FntGeneva,       "Geneva",             "Geneva",           FF_SWISS,      ANSI_CHARSET },
   { FntMonaco,       "Monaco",             "Monaco",           FF_MODERN,     ANSI_CHARSET },
   { FntVenice,       "Venice",             "Venice",           FF_ROMAN,      ANSI_CHARSET },
   { FntLondon,       "London",             "London",           FF_ROMAN,      ANSI_CHARSET },
   { FntAthens,       "Athens",             "Athens",           FF_ROMAN,      ANSI_CHARSET },
   { FntSanFran,      "San Francisco",      "San Francisco",    FF_SWISS,      ANSI_CHARSET },
   { FntToronto,      "Toronto",            "Toronto",          FF_SWISS,      ANSI_CHARSET },
   { FntCairo,        "Cairo",              "Cairo",            FF_DECORATIVE, SYMBOL_CHARSET },
   { FntLosAngeles,   "Los Angeles",        "Los Angeles",      FF_SWISS,      ANSI_CHARSET },
   { FntZapfDingbats, "Zapf Dingbats",      "ZapfDingbats",     FF_DECORATIVE, SYMBOL_CHARSET },
   { FntBookman,      "Bookman",            "Bookman",          FF_ROMAN,      ANSI_CHARSET },
   { FntHelvNarrow,   "N Helvetica Narrow", "Helvetica-Narrow", FF_SWISS,      ANSI_CHARSET },
   { FntPalatino,     "Palatino",           "Palatino",         FF_ROMAN,      ANSI_CHARSET },
   { FntZapfChancery, "Zapf Chancery",      "ZapfChancery",     FF_ROMAN,      ANSI_CHARSET },
   { FntTimes,        "Times",              "Times",            FF_ROMAN,      ANSI_CHARSET },
   { FntHelvetica,    "Helvetica",          "Helvetica",        FF_SWISS,      ANSI_CHARSET },
   { FntCourier,      "Courier",            "Courier",          FF_MODERN,     ANSI_CHARSET },
   { FntSymbol,       "Symbol",             "Symbol",           FF_DECORATIVE, SYMBOL_CHARSET },
   { FntMobile,       "Mobile",             "Mobile",           FF_DECORATIVE, SYMBOL_CHARSET },
   { FntAvantGarde,   "Avant Garde",        "AvantGarde",       FF_SWISS,      ANSI_CHARSET },
   { FntNewCentury,   "New Century Schlbk", "NewCenturySchlbk", FF_ROMAN,      ANSI_CHARSET },
   { FntMTExtra,      "MT Extra",           "MT Extra",         FF_DECORATIVE, MTEXTRA_CHARSET },
   { FntUnknown,      "Fences",             "Fences",           FF_DECORATIVE, FENCES_CHARSET },
   { FntUnknown,      "",                   "",                 FF_ROMAN,      ANSI_CHARSET },
   { FntUnknown,      "",                   "",                 FF_ROMAN,      ANSI_CHARSET }
};

private Byte trueTypeSub[NumTTSubs][MaxFntName] =
{
   "Monotype Sorts",
   "Bookman Old Style",
   "Arial Narrow",
   "Book Antiqua",
   "Monotype Corsiva",
   "Times New Roman",
   "Arial",
   "Courier New",
   "Symbol",
   "Mobile",
   "Century Gothic",
   "Century Schoolbook"
};

private Byte MacToAnsiTable[128] =
{
   0xC4, /* 80 -- upper case A with diaeresis or umlaut mark */
   0xC5, /* 81 -- upper case A with ring */
   0xC7, /* 82 -- upper case C with cedilla */
   0xC9, /* 83 -- upper case E with accute accent */
   0xD1, /* 84 -- upper case N with tilde */
   0xD6, /* 85 -- upper case O with diaeresis or umlaut mark */
   0xDC, /* 86 -- upper case U with diaeresis or umlaut mark */
   0xE1, /* 87 -- lower case a with accute accent */
   0xE0, /* 88 -- lower case a with grave accent */
   0xE2, /* 89 -- lower case a with circumflex accent */
   0xE4, /* 8A -- lower case a with diaeresis or umlaut mark */
   0xE3, /* 8B -- lower case a with tilde */
   0xE5, /* 8C -- lower case a with ring */
   0xE7, /* 8D -- lower case c with cedilla */
   0xE9, /* 8E -- lower case e with accute accent */
   0xE8, /* 8F -- lower case e with grave accent */
   0xEA, /* 90 -- lower case e with circumflex accent */
   0xEB, /* 91 -- lower case e with diaeresis or umlaut mark */
   0xED, /* 92 -- lower case i with accute accent */
   0xEC, /* 93 -- lower case i with grave accent */
   0xEE, /* 94 -- lower case i with circumflex accent */
   0xEF, /* 95 -- lower case i with diaeresis or umlaut mark */
   0xF1, /* 96 -- lower case n with tilde */
   0xF3, /* 97 -- lower case o with accute accent */
   0xF2, /* 98 -- lower case o with grave accent */
   0xF4, /* 99 -- lower case o with circumflex accent */
   0xF6, /* 9A -- lower case o with diaeresis or umlaut mark */
   0xF5, /* 9B -- lower case o with tilde */
   0xFA, /* 9C -- lower case u with accute accent */
   0xF9, /* 9D -- lower case u with grave accent */
   0xFB, /* 9E -- lower case u with circumflex accent */
   0xFC, /* 9F -- lower case u with diaeresis or umlaut mark */
   0x86, /* A0 -- UNS -  MAC A0 <new> */
   0xB0, /* A1 -- degrees */
   0xA2, /* A2 -- cent currency symbol */
   0xA3, /* A3 -- pound currency  */
   0xA7, /* A4 -- section separator */
   0x95, /* A5 -- bullet <changed from B7> */
   0xB6, /* A6 -- paragraph (cp > 0x80) */
   0xDF, /* A7 -- beta */
   0xAE, /* A8 -- registered */
   0xA9, /* A9 -- copyright */
   0x99, /* AA -- trade mark <new> */
   0xB4, /* AB -- apostrophe */
   0xA8, /* AC -- space with diaeresis or umlaut mark */
   0xB0, /* AD -- not equal <unused1> */
   0xC6, /* AE -- UPPER CASE AE */
   0xD8, /* AF -- UNS - ANSI D8 */
   0x81, /* B0 -- infinity <unused2> */
   0xB1, /* B1 -- plus minus */
   0x8A, /* B2 -- <= <unused3> */
   0x8D, /* B3 -- >= <unused4> */
   0xA5, /* B4 -- yen currency symbol */
   0xB5, /* B5 -- UNS - ANSI B5 */
   0x8E, /* B6 -- lower case Delta <unused5> */
   0x8F, /* B7 -- Sigma <unused6> */
   0x90, /* B8 -- upper case Pi <unused7> */
   0x9A, /* B9 -- lower case  pi <unused8> */
   0x9D, /* BA -- upper integral <unused9> */
   0xAA, /* BB -- super script a w/underscore */
   0xBA, /* BC -- UNS - ANSI BA */
   0x9E, /* BD -- Omega <unused10> */
   0xE6, /* BE -- lower case ae */
   0xF8, /* BF -- UNS - ANSI F8 */
   0xBF, /* C0 -- upside down ? */
   0xA1, /* C1 -- upside down < */
   0xAC, /* C2 -- UNS - ANSI AC */
   0xA6, /* C3 -- square root <unused11> */
   0x83, /* C4 -- function (f) <new> */
   0xAD, /* C5 -- UNS - 437 F7 <unused12> */
   0xB2, /* C6 -- upper case delta <unused13> */
   0xAB, /* C7 -- << */
   0xBB, /* C8 -- >> */
   0x85, /* C9 -- elipsis <new> */
   0xA0, /* CA -- non breaking space <new> */
   0xC0, /* CB -- upper case A with grave accent */
   0xC3, /* CC -- upper case A with tilde */
   0xD5, /* CD -- upper case O with tilde */
   0x8C, /* CE -- upper case CE <new> */
   0x9C, /* CF -- lower case CE <new> */
   0x96, /* D0 -- dash <changed from AD> */
   0x97, /* D1 -- m dash <changed from 96> */
   0x93, /* D2 -- double open quote */
   0x94, /* D3 -- double close quote */
   0x91, /* D4 -- single open quote */
   0x92, /* D5 -- single close quote */
   0xF7, /* D6 -- divide <new> */
   0xB3, /* D7 -- open diamond <unused14> */
   0xFF, /* D8 -- lower case y with diaeresis or umlaut mark */
   0x9F, /* D9 -- Undefined <new upper case y with diaeresis or umlaut mark> */
   0xB9, /* DA -- Undefined <new forward slash> */
   0xA4, /* DB -- UNS - ANSI A4. */
   0x8B, /* DC -- Undefined <new less than sign> */
   0x9B, /* DD -- Undefined <new greater than sign> */
   0xBC, /* DE -- Undefined <unused15 connected fi> */
   0xBD, /* DF -- Undefined <unused16 connected fl> */
   0x87, /* E0 -- Undefined <new double cross> */
   0xB7, /* E1 -- Undefined <new bullet character> */
   0x82, /* E2 -- Undefined <new single lower smart quote> */
   0x84, /* E3 -- Undefined <new double lower smart quote> */
   0x89, /* E4 -- Undefined <new weird percent sign> */
   0xC2, /* E5 -- upper case A with circumflex accent. */
   0xCA, /* E6 -- upper case E with circumflex accent. */
   0xC1, /* E7 -- upper case A with accute accent. */
   0xCB, /* E8 -- upper case E with diaeresis or umlaut mark. */
   0xC8, /* E9 -- upper case E with grave accent. */
   0xCD, /* EA -- upper case I with accute accent. */
   0xCE, /* EB -- upper case I with circumflex accent. */
   0xCF, /* EC -- upper case I with diaeresis or umlaut mark. */
   0xCC, /* ED -- upper case I with grave accent. */
   0xD3, /* EE -- upper case O with accute accent. */
   0xD4, /* EF -- upper case O with circumflex accent. */
   0xBE, /* F0 -- Undefined <unused17 apple character> */
   0xD2, /* F1 -- upper case O with grave accent. */
   0xDA, /* F2 -- upper case U with accute accent. */
   0xDB, /* F3 -- upper case U with circumflex accent. */
   0xD9, /* F4 -- upper case U with grave accent. */
   0xD0, /* F5 -- Undefined <unsused18 i with no dot> */
   0x88, /* F6 -- Undefined <new hat ligature> */
   0x98, /* F7 -- Undefined <new tilde ligature> */
   0xAF, /* F8 -- Undefined <new bar ligature> */
   0xD7, /* F9 -- Undefined <unused18 upside-down bow ligature> */
   0xDD, /* FA -- Undefined <unused19 dot ligature> */
   0xDE, /* FB -- Undefined <unused20 open dot ligature> */
   0xB8, /* FC -- space with cedilla. */
   0xF0, /* FD -- Undefined <unused21 double upper smart quote> */
   0xFD, /* FE -- Undefined <unused22 lower right bow ligature> */
   0xFE  /* FF -- Undefined <unused23 upside-down hat ligature> */
};

/*--- Default logical structures ---*/

typedef struct
{
   BITMAPINFOHEADER     bmiHeader;
   RGBQUAD              bmiColors[2];
   DWORD                pattern[8];

} PatBrush, far * PatBrushLPtr;

private  PatBrush patBrushSkel =
{
   {
      sizeof( BITMAPINFOHEADER ),      // size of header structure
      8,                               // width = 8
      8,                               // height = 8
      1,                               // planes = 1
      1,                               // number of bits/pixel = 1
      BI_RGB,                          // non-compressed bitmap
      8,                               // image size (in bytes)
      (DWORD)(72 * 39.37),             // XPelsPerMeter = 72 dpi * mm/inch
      (DWORD)(72 * 39.37),             // YPelsPerMeter = 72 dpi * mm/inch
      0,                               // all 2 colors used
      0                                // all colors important
   },
   {
      { 0, 0, 0, 0 },                  // background color
      { 0, 0, 0, 0 }                   // foreground (text) color
   },
   { 0, 0, 0, 0, 0, 0, 0, 0 }          // uninitialized pattern data
};


private  LOGFONT logFontSkel =
{
   0,                                  // height - will be set
   0,                                  // width = match aspect ratio
   0,                                  // escapement = no rotation
   0,                                  // orientation = no rotation
   FW_NORMAL,                          // weight = normal
   0,                                  // italics = no
   0,                                  // underline = no
   0,                                  // strikeout = no
   ANSI_CHARSET,                       // charset = ANSI
   OUT_DEFAULT_PRECIS,                 // default output precision
   CLIP_DEFAULT_PRECIS,                // default clipping precision
   DEFAULT_QUALITY,                    // default output quality
   DEFAULT_PITCH | FF_DONTCARE,        // default pitch and family
   cNULL                               // no face name - will be set
};


/*********************** Private Function Definitions ***********************/

private Boolean IsArithmeticMode( Integer mode );
/* return TRUE if this is an arithmetic transfer mode */


#define /* Boolean */ IsHiddenPenMode( /* Integer */ mode )             \
/* return TRUE if this is a hidden pen transfer mode */                 \
(mode == QDHidePen)


private void CalculatePenSize( Point startPt, Point endPt, Point penSize );
/* calcuate the pen width to produce equivalent QuickDraw stroke */


private Boolean SetAttributes( GrafVerb verb );
/* set up pen and brush elements according to GrafVerb */


private Boolean SetPenAttributes( GrafVerb verb );
/* make sure that pen attributes are OK according to preferences */


private Boolean SetBrushAttributes( GrafVerb verb );
/* set up the correct brush (fill) for the ensuing primitive */


private void MakePatternBrush( PixPatLPtr pixPatLPtr );
/* Make a new pattern brush using pixelPat passed in */


private Boolean IsSolidPattern( PixPatLPtr pixPatLPtr,
                                RGBColor far * rgbColor,
                                Boolean mixColors );
/* return true if pattern is solid, false if not.  If mixColors is TRUE, then
   mixtures of 25%, 50%, and 75% grey are mixed into a solid color */


private Boolean FrameMatchesFill( Word primType );
/* return TRUE if the fill pattern (current brush ) matches frame pattern */


private Boolean SetTextAttributes( void );
/* set up text attributes - set mapChars to TRUE if should map to ANSI */


private Integer FindGdiFont( void );
/* return an index to the current font selection */


private void MacToAnsi( StringLPtr string );
/* convert extended characters from Mac to ANSI equivalent */


private void MakeDIB( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                      Handle far * headerHandleLPtr,
                      Handle far * bitsHandleLPtr,
                      Boolean packDIB );
/* Create a Windows device-independant bitmap */


void GdiEPSData(PSBuf far* psbuf);
/* Output PostScript data as GDI POSTSCRIPT_DATA Escape */


private Boolean MakeMask( Handle mask, Boolean patBlt );
/* Create a mask that will be used in the ensuing StretchDIBits call
   Return TRUE if region was created, FALSE if rectangular region */


void InvertBits( Byte far * byteLPtr, Integer start, Integer count );
/* invert all bits in byteLPtr from bit offset start for count bits */


void hmemcpy( Byte huge * src, Byte huge * dst, Integer count );
/* copy count bytes from source to destination - assumes even count */


void hexpcpy( Byte huge * src, Byte huge * dst, Integer count, Integer bits );
/* copy count bytes to destination, expand each 2 bits to nibble of if
   16-bit image, expand to 24 bits */


void hmrgcpy( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr, Integer dibWidth );
/* if the is a 24-bit image, then the components are separated into scanlines
   of red, green and blue.  Merge into single scanline of 24-bit RGB pixels */


void hrlecpy256( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB );
/* 256 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */


void hrlecpy16( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB );
/* 16 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */


#define /* void */ GdiMarkAsCurrent( /* Integer */ attribCode )         \
/* indicate that the current attribute is current */                    \
gdiEnv.state[attribCode] = Current


#define /* void */ GdiAttribHasChanged( /* Integer */ attribCode )      \
/* return TRUE if the attribute has changed */                          \
(gdiEnv.state[attribCode] == Changed)


#define /* Boolean */ EmptyRect( /* Rect */ r )                         \
/* TRUE if a given rectangle has a zero delta in X or Y direction */    \
(((r.right) - (r.left) == 0) || ((r.bottom) - (r.top) == 0))


#define /* Boolean */ odd( /* Integer */ i )                            \
/* return TRUE if given integer is odd, FALSE if even */                \
((i) & 0x0001)


#define /* Integer */ RValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetRValue( color )))


#define /* Integer */ GValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetGValue( color )))


#define /* Integer */ BValue( /* RGBColor */ color )                    \
/* coerce the value of Byte color component to Integer */               \
((Integer)(GetBValue( color )))


/*********************** Function Implementation ****************************/

void GdiOffsetOrigin( Point delta )
/*=================*/
/* offset the current window origin and picture bounding box */
{
   /* flush the cache */
   CaFlushCache();

   /* make sure to make this permanent change that won't be affected by
      changes in clipping rectangles that are otherwise changed between
      SaveDC/RestoreDC pair. */
   CaRestoreDC();

   /* offset the picture bounding box and cached clipping rectangles */
   OffsetRect( &gdiPict.bbox,   delta.x, delta.y );
   OffsetRect( CaGetClipRect(), delta.x, delta.y );

   /* call GDI to reset the origin */
#ifdef WIN32
   SetWindowOrgEx( gdiEnv.metafile, gdiPict.bbox.left, gdiPict.bbox.top, NULL );
#else
   SetWindowOrg( gdiEnv.metafile, gdiPict.bbox.left, gdiPict.bbox.top );
#endif


   /* set up the next clipping frame */
   CaSaveDC();

   /* determine if we need to resend the clipping rectangle */
   if (!EqualRect( CaGetClipRect(), &gdiPict.bbox ))
   {
      /* retrieve the current clipping rectangle */
      Rect rect = *CaGetClipRect();

      /* newly offset clipping rectangle */
      IntersectClipRect( gdiEnv.metafile,
                         rect.left, rect.top, rect.right, rect.bottom );
   }
}



void GdiLineTo( Point newPt )
/*============*/
/* Emit line primitive with square endcaps */
{
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* check if the pen has been turned off */
   if (gdiEnv.drawingEnabled &&
      (port->pnSize.x != 0)  && (port->pnSize.y != 0))
   {
      RGBColor       solidRGB;

      /* determine if we are trying to draw with a patterned pen */
      if (!IsSolidPattern( &port->pnPixPat, &solidRGB, NOMIX ))
      {
         if (SetAttributes( GdiPaint))
         {
            Point       delta;

            /* determine if the dimensions in both directions */
            delta.x = newPt.x - port->pnLoc.x;
            delta.y = newPt.y - port->pnLoc.y;

            /* determine if we can simulate using a rectangle primitive */
            if (delta.x == 0 || delta.y == 0)
            {
               /* assign the structures into the cache type */
               prim.type = CaRectangle;
               prim.verb = GdiPaint;

               /* make a rectangle with upper-left, lower-right coords */
               prim.a.rect.bbox.left   = min( port->pnLoc.x, newPt.x );
               prim.a.rect.bbox.top    = min( port->pnLoc.y, newPt.y );
               prim.a.rect.bbox.right  = max( port->pnLoc.x, newPt.x ) + port->pnSize.x;
               prim.a.rect.bbox.bottom = max( port->pnLoc.y, newPt.y ) + port->pnSize.y;
            }
            else
            {
               Point    start;
               Point    end;
               Point    poly[7];
               Point    pnSize = port->pnSize;

               /* make sure that the points follow left->right x direction */
               if (delta.x > 0)
               {
                  start = port->pnLoc;
                  end   = newPt;
               }
               else
               {
                  start = newPt;
                  end   = port->pnLoc;
                  delta.y = - delta.y;
               }

               /* create the simulation of the outline */
               poly[0].x = start.x;
               poly[0].y = start.y;
               poly[1].x = (delta.y > 0) ? start.x + pnSize.x : end.x;
               poly[1].y = (delta.y > 0) ? start.y : end.y;
               poly[2].x = end.x + pnSize.x;
               poly[2].y = end.y;
               poly[3].x = end.x  + pnSize.x;
               poly[3].y = end.y + pnSize.y;
               poly[4].x = (delta.y > 0) ? end.x : start.x + pnSize.x;
               poly[4].y = (delta.y > 0) ? end.y + pnSize.y : start.y + pnSize.y;
               poly[5].x = start.x;
               poly[5].y = start.y + pnSize.y;
               poly[6] = poly[0];

               /* package the polygon for the cache module */
               prim.type = CaPolygon;
               prim.verb = GdiPaint;
               prim.a.poly.numPoints = 7;
               prim.a.poly.pointList = poly;
               prim.a.poly.pnSize.x = 0;
               prim.a.poly.pnSize.y = 0;
            }

            /* cache the primitive */
            CaCachePrimitive( &prim );
         }
      }
      /* eliminate OR'ing of white pen with display surface */
      else if (port->pnMode != QDPatOr || solidRGB != RGB( 255, 255, 255))
      {
         /* set the correct pen size before calling SetPenAttributes() */
         CalculatePenSize( port->pnLoc, newPt, port->pnSize );

         /* setup the correct line color and check whether to continue */
         if (SetPenAttributes( GdiFrame ))
         {
            /* package for the cache module */
            prim.verb = GdiFrame;
            prim.type = CaLine;
            prim.a.line.start = port->pnLoc;
            prim.a.line.end = newPt;
            prim.a.line.pnSize = port->pnSize;

            /* cache the primitive */
            CaCachePrimitive( &prim );
         }
      }
   }

}  /* GdiLineTo */



void GdiRectangle( GrafVerb verb, Rect rect )
/*===============*/
/* Emit rectangle primitive using action and dimensions parameters */
{
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for pen size */
   QDGetPort( &port );

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      RGBColor    solidRGB;

      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaRectangle ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* determine if we are trying to draw with a patterned pen */
      else if (verb == GdiFrame && !IsSolidPattern( &port->pnPixPat, &solidRGB, NOMIX ))
      {
         /* flush any pending graphics operations */
         CaFlushCache();

         /* set up the correct attributes for a simulated frameRect */
         if (SetAttributes( GdiPaint))
         {
            Point    poly[10];
            Integer  polyCount[2];
            Point    pnSize = port->pnSize;

            /* make sure that the rectangle outline will fill properly */
            if (Width( rect) < 2 * pnSize.x)
            {
               pnSize.x = Width( rect ) / 2;
            }
            if (Height( rect ) < 2 * pnSize.y)
            {
               pnSize.y = Height( rect ) / 2;
            }

            /* create the simulation of the outline */
            poly[0].x = poly[3].x = rect.left;
            poly[0].y = poly[1].y = rect.top;
            poly[1].x = poly[2].x = rect.right;
            poly[2].y = poly[3].y = rect.bottom;
            poly[4]   = poly[0];

            poly[5].x = poly[8].x = rect.left + pnSize.x;
            poly[5].y = poly[6].y = rect.top + pnSize.y;
            poly[6].x = poly[7].x = rect.right - pnSize.x;
            poly[7].y = poly[8].y = rect.bottom - pnSize.y;
            poly[9]   = poly[5];

            /* set the poly point count for the subpolygons */
            polyCount[0] = polyCount[1] = 5;

            /* flush the cache attributes to set the pen and brush style */
            CaFlushAttributes();

            /* call GDI to render the polypolygon */
            PolyPolygon( gdiEnv.metafile, poly, polyCount, 2);
         }
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaRectangle;
         prim.a.rect.bbox = rect;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiRectangle */



void GdiRoundRect( GrafVerb verb, Rect rect, Point oval )
/*===============*/
/* Emit rounded rectangle primitive */
{
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaRoundRect ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaRoundRect;
         prim.a.rect.bbox = rect;
         prim.a.rect.oval = oval;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiRRectProc */



void GdiOval( GrafVerb verb, Rect rect )
/*==========*/
/* Emit an oval primitive */
{
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ))
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaEllipse ))
      {
         /* just flush the cache and return */
         CaFlushCache();
      }
      /* setup the correct line and fill attribs, check to continue */
      else if (SetAttributes( verb ))
      {
         /* package for the cache module */
         prim.verb = verb;
         prim.type = CaEllipse;
         prim.a.rect.bbox = rect;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiOvalProc */



void GdiArc( GrafVerb verb, Rect rect, Integer startAngle, Integer arcAngle )
/*=========*/
/* Emit an arc primitive */
{
   Boolean        allOk;
   Point          center;
   Point          startPoint;
   Point          endPoint;
   Integer        hypotenuse;
   Integer        rectWidth;
   Integer        rectHeight;
   Real           startRadian;
   Real           arcRadian;
   Real           scaleFactor;
   Boolean        scaleVertically;
   CaPrimitive    prim;

   /* make sure that drawing is enabled and non-empty rectangle and sweep */
   if (gdiEnv.drawingEnabled && !EmptyRect( rect ) && (arcAngle != 0 ))
   {
      /* see what type of primitive will be created */
      prim.type = (verb == GdiFrame) ? CaArc : CaPie;

      /* if drawing an arc, only the pen attributes need be set */
      if (prim.type == CaArc)
      {
         /* set same object state to FALSE if framing - Gdi will render the
            entire outline of the pie, whereas in QuickDraw, only the outer
            edge of the pie is drawn. */
         gdiEnv.sameObject = FALSE;

         /* notify the cache module that this isn't the same object */
         CaSamePrimitive( FALSE );

         /* set up only the pen attributes */
         allOk = SetPenAttributes( verb );
      }
      else
      {
         /* otherwise, set pen and brush attributes */
         allOk = SetAttributes( verb );
      }

      /* check whether attributes were set up correctly and to proceed */
      if (allOk)
      {
         /* Calculate width and height of source rectangle. */
         rectWidth  = Width( rect );
         rectHeight = Height( rect );

         /* Determine size of smallest enclosing square and set hypotenuse
            to 1/2 width of resulting square */
         if (rectWidth > rectHeight)
         {
            hypotenuse = rectWidth / 2;
            scaleVertically = TRUE;
            scaleFactor = (Real)rectHeight / (Real)rectWidth;
         }
         else
         {
            hypotenuse = rectHeight / 2;
            scaleVertically = FALSE;
            scaleFactor = (Real)rectWidth / (Real)rectHeight;
         }

         /* adjust hypotenuse size if possible GDI divide by zero possible */
         if (hypotenuse < 100)
         {
            /* note that start and end points don't have to lie on arc */
            hypotenuse = 100;
         }

         /* find the center point of bounding rectangle */
         center.x = rect.left + rectWidth / 2;
         center.y = rect.top  + rectHeight /2;

         /* check if the arc is drawn in a counter-clockwise direction */
         if (arcAngle < 0)
         {
            Integer     tempArcAngle;

            /* if rendering counter-clockwise, then swap the start and end
               points so the rendering will occur in clockwise direction */
            tempArcAngle = arcAngle;
            arcAngle = startAngle;
            startAngle += tempArcAngle;
         }
         else
         {
            /* clockwise rendering - just add the arc angle to start angle */
            arcAngle += startAngle;
         }

         /* Determine the start and arc angles in radians */
         startRadian = ((Real)startAngle / 360.0) * TwoPi;
         arcRadian = ((Real)arcAngle / 360.0) * TwoPi;

         /* calculate the start and endpoints.  Note negation of y coordinate since
            the positive direction is downward.  Also note that the start and
            end points are being swapped, since QuickDraw renders in clock-
            wise direction and GDI renders in counter-clockwise direction */
         endPoint.x = (Integer)(sin( startRadian ) * hypotenuse);
         endPoint.y = (Integer)(-cos( startRadian ) * hypotenuse);

         startPoint.x = (Integer)(sin( arcRadian ) * hypotenuse);
         startPoint.y = (Integer)(-cos( arcRadian ) * hypotenuse);

         /* scale the resulting points in the vertical or horizontal direction
            depending on the setting of scaleVertically boolean */
         if (scaleVertically)
         {
            endPoint.y = (Integer)(endPoint.y * scaleFactor);
            startPoint.y = (Integer)(startPoint.y * scaleFactor);
         }
         else
         {
            endPoint.x = (Integer)(endPoint.x * scaleFactor);
            startPoint.x = (Integer)(startPoint.x * scaleFactor);
         }

         /* using the transformed points, use centerPoint to determine the correct
            starting and ending points */
         startPoint.x += center.x;
         startPoint.y += center.y;

         endPoint.x += center.x;
         endPoint.y += center.y;

         /* package for the cache module.  The type was set at beginning */
         prim.verb = verb;
         prim.a.arc.bbox = rect;
         prim.a.arc.start = startPoint;
         prim.a.arc.end = endPoint;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }
   }

}  /* GdiArc */



void GdiPolygon( GrafVerb verb, Handle poly )
/*=============*/
/* Emit polygon primitive */
{
   Integer           numPoints;
   Integer           lastPoint;
   Point far *       pointList;
   Integer far *     polyCountLPtr;
   Boolean           closed;
   Boolean           allOk;
   CGrafPort far *   port;
   CaPrimitive       prim;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* make sure that drawing is enabled */
   if (gdiEnv.drawingEnabled)
   {
      /* check if the same primitive is being outlined as was just filled.
         if this happens, then we don't need to set the frame (pen) */
      if (verb == GdiFrame && FrameMatchesFill( CaPolygon ) &&
         (port->pnSize.x == 1 && port->pnSize.y == 1))
      {
         /* just flush the cache and return */
         CaFlushCache();
         return;
      }

      /* lock the polygon handle to access individual fields */
      polyCountLPtr = (Integer far *)GlobalLock( poly );
      pointList = (Point far *)(polyCountLPtr +
                  (PolyHeaderSize / sizeofMacWord));

      /* determine number of points based on first word = length field */
      numPoints = (*polyCountLPtr - PolyHeaderSize) / sizeofMacPoint;

      /* determine if this is a closed polygon */
      lastPoint = numPoints - 1;
      closed = ((pointList->x == (pointList + lastPoint)->x) &&
                (pointList->y == (pointList + lastPoint)->y));

      /* determine what type of primitive to render */
      prim.type = (verb == GdiFrame && !closed) ? CaPolyLine : CaPolygon;

      /* if drawing a polyline, only the pen attributes need be set */
      if (prim.type == CaPolyLine)
      {
         /* set same object state to FALSE if drawing a polyline */
         gdiEnv.sameObject = FALSE;

         /* notify the cache module that this isn't the same object */
         CaSamePrimitive( FALSE );

         /* set up only the pen attributes */
         allOk = SetPenAttributes( verb );
      }
      else
      {
         /* otherwise, set pen and brush attributes */
         allOk = SetAttributes( verb );
      }

      /* check whether attribute setup succeeded - continue or not */
      if (allOk)
      {
         /* package for the cache module - type was set above */
         prim.verb = verb;
         prim.a.poly.numPoints = numPoints;
         prim.a.poly.pointList = pointList;
         prim.a.poly.pnSize    = port->pnSize;

         /* cache the primitive */
         CaCachePrimitive( &prim );
      }

      /* Unlock the data */
      GlobalUnlock( poly );
   }

}  /* GdiPoly */



void GdiRegion( GrafVerb verb, Handle rgn )
/*=============*/
/* Emit region primitive */
{
   Integer far *     rgnCountLPtr;
   Integer           numPoints;
   Rect              rgnBBox;
   CGrafPort far *   port;

   /* get port for updated pen location and pen size */
   QDGetPort( &port );

   /* lock the region handle to access individual fields */
   rgnCountLPtr = (Integer far *)GlobalLock( rgn );

   /* determine the bounding box of the region */
   rgnBBox = *((Rect far *)(rgnCountLPtr + 1));

   /* make sure that drawing is enabled and non-empty rectangle destination */
   if (gdiEnv.drawingEnabled && !EmptyRect( rgnBBox ))
   {
      /* determine number of points based on first word = length field */
      numPoints = (*rgnCountLPtr - RgnHeaderSize) / sizeofMacPoint;

      /* determine if we should just be drawing a rectangle */
      if (numPoints == 0 )
      {
         /* simulate region using rectangle primitive */
         GdiRectangle( verb, *((Rect far *)(rgnCountLPtr + 1)) );
      }
      else
      {
         /* determine if we are filling using a pre-set brush */
         switch (verb)
         {
            /* can simulate the region using a brush and mask */
            case GdiPaint:
            case GdiFill:
            case GdiErase:
            {
               /* set up the brush attributes for the ensuing StretchBlt */
               SetBrushAttributes( verb );

               /* call to MakeMask() will generate the bitblt operations */
               MakeMask( rgn, TRUE );
               break;
            }

            /* otherwise, just ignore the opcode */
            default:
               break;
         }
      }
   }

   /* Unlock the data */
   GlobalUnlock( rgn );

}  /* GdiRegion */



void GdiTextOut( StringLPtr string, Point location )
/*=============*/
/* draw the text at the location specified. */
{
   CGrafPort far *   port;

   /* get port for updated pen location */
   QDGetPort( &port );

   /* make sure that drawing is enabled */
   if (gdiEnv.drawingEnabled)
   {
      /* flush any cached primitive elements */
      CaFlushCache();

      /* set up the correct text attributes before continuing */
      if (SetTextAttributes())
      {
         Integer  strLen;

         /* determine the number of characters in the string */
         strLen = lstrlen( string );

         /* convert the individual characters from Mac to ANSI char set */
         MacToAnsi( string );

         /* call textout to display the characters */
         TextOut( gdiEnv.metafile, location.x, location.y,
                  string, strLen );
      }
   }

}  /* GdiTextOut */



void GdiStretchDIBits( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                       Rect src, Rect dst, Word mode, Handle mask )
/*===================*/
/* Draw a Windows device-independant bitmap */
{
   Handle            bitsInfoHandle;
   Handle            bitsHandle;
   LPBITMAPINFO      bitsInfoLPtr;
   Byte far *        bitsLPtr;
   Boolean           bitmapMask;
   Boolean           patternBlt;
   Boolean           clipRectSet;

   /* for now, assume no rectangular clip rectangle is set up */
   clipRectSet = FALSE;

   /* if a mask is present, call MakeDIB to create it */
   if (mask)
   {
      /* if a region mask is present, then call create the mask.  This will
         result in a recursive call to this routine.  If the routine returns
         FALSE, no region was created - this is a rectangular clip. */
      clipRectSet = !MakeMask( mask, FALSE );

      /* free the data block */
      GlobalFree( mask );

      if (clipRectSet)
      {
         /* if no mask was created, set mask to NULL to get SRCCOPY ROP */
         mask = NULL;
      }
   }

   /* make sure that drawing is enabled and non-empty source and/or
      destination rectangles in the bitmap record */
   if (gdiEnv.drawingEnabled && !EmptyRect( src ) && !EmptyRect( dst ))
   {
      /* determine if we are rendering the monochrome bitmap mask */
      bitmapMask = (mode == -1 || mode == -2);
      patternBlt = (mode == -2);

      /* if this is the mask, change the mode to the correct setting */
      if (bitmapMask)
      {
         /* yes, bitmap mask - change the mode to source copy */
         mode = QDSrcCopy;
      }

      /* flush the cache before proceeding */
      CaFlushCache();

      /* Create a DIB using the information passed in */
      MakeDIB( pixMapLPtr, pixDataHandle, &bitsInfoHandle, &bitsHandle, FALSE );

      /* make sure that everything went OK */
      if (ErGetGlobalError() == NOERR)
      {
         DWord       ropCode;
         RGBQUAD     secondFgColor;
         Byte        pass;
         Byte        numPasses;
         Boolean     twoColorDIB;

         /* determine if we are working with a 2 color DIB */
         twoColorDIB = pixMapLPtr->pixelSize == 1;

         if (mask)
         {
            /* if mask is already rendered, then AND in the remaining bits
               to cover the areas that have been turned to white */
            ropCode = SRCAND;
         }
         else if (patternBlt)
         {
            /* drawing a white on black bitmap - we want all the areas that
               are black to leave the destination untouched, and where white
               to draw with the currently selected brush.  Check Petzold
               "Programming Windows v3", pages 622-623. DSPDxax operation */
            ropCode = 0x00E20746;
         }
         else if (bitmapMask)
         {
            /* drawing the mask bitmap - OR in all bits to create white mask
               that will be overlaid in the ensuing operation with color */
            ropCode = SRCPAINT;
         }
         else if (!twoColorDIB &&
                 (mode == QDSrcOr || mode == QDAdMin || mode == QDTransparent))
         {
            /* check for the special case found in Illustrator EPS images,
               where a monochrome bitmap is used to clear an area, followed
               by a multi-color DIB drawn in QDSrcOr mode - we don't want to
               convert this to a SRCCOPY mode.  Instead, this simulated
               transparecy is done in a fashion similar to region masks. */
            ropCode = SRCAND;
         }
         else
         {
            /* otherwise, use a "normal" transfer mode.  This entails that
               there is no transparency present in the bitmap rendering */
            ropCode = SRCCOPY;
         }

         /* Lock the data to obtain pointers for call to StretchDIBits */
         bitsLPtr = (Byte far *)GlobalLock( bitsHandle );
         bitsInfoLPtr = (LPBITMAPINFO)GlobalLock( bitsInfoHandle );

         /* assume that only one pass is required */
         numPasses = 1;

         /* some special handling of two-color DIBs for transparency */
         if (twoColorDIB && (mode == QDSrcOr || mode == QDSrcBic))
         {
            RGBQUAD  bmiWhite = { 255, 255, 255, 0 };
            RGBQUAD  bmiBlack = {   0,   0,   0, 0 };

            /* determine if we should use the PowerPoint optimizations */
            if (gdiPrefsLPtr->optimizePP)
            {
               /* use the specialized SRCPAINT rop code - flag transparency */
               ropCode = SRCPAINT;

               /* if trying to clear all bits... */
               if (mode == QDSrcBic)
               {
                  /* ... swap foreground with background color -
                     the background is set to white in ensuing operation */
                  bitsInfoLPtr->bmiColors[0] = bitsInfoLPtr->bmiColors[1];
               }
            }
            else
            {
               /* save the foreground color for the second iteration ... */
               secondFgColor = (mode == QDSrcOr) ? bitsInfoLPtr->bmiColors[0] :
                                                   bitsInfoLPtr->bmiColors[1] ;

               /* assume two passes required - 1 for mask, 2 for color blt */
               numPasses = 2;

               /* check if all the RGB components are the same */
               if ((mode == QDSrcOr) && (secondFgColor.rgbRed == 0) &&
                   (secondFgColor.rgbRed == secondFgColor.rgbGreen) &&
                   (secondFgColor.rgbRed == secondFgColor.rgbBlue))
               {
                  /* if black or white, only one pass will be required */
                  numPasses = 1;
               }

               /* will draw a black transparent bitmap first, followed
                  on 2nd iteration is SRCPAINT - or'ing operation to color */
               ropCode = SRCAND;

               /* set the foreground to black */
               bitsInfoLPtr->bmiColors[0] = bmiBlack;
            }

            /* set the background color to white */
            bitsInfoLPtr->bmiColors[1] = bmiWhite;
         }

         /* call StretchDIBits once (PowerPoint) or twice (some others) */
         for (pass = 0; pass < numPasses; pass++)
         {
            /* set up the text and background color for the metafile */
            if (twoColorDIB)
            {
               RGBColor    fgColor;
               RGBColor    bkColor;
               RGBColor    black = RGB( 0, 0, 0 );

               /* determine fore- and background color in the DIB header */
               fgColor = RGB( bitsInfoLPtr->bmiColors[0].rgbRed,
                              bitsInfoLPtr->bmiColors[0].rgbGreen,
                              bitsInfoLPtr->bmiColors[0].rgbBlue );
               bkColor = RGB( bitsInfoLPtr->bmiColors[1].rgbRed,
                              bitsInfoLPtr->bmiColors[1].rgbGreen,
                              bitsInfoLPtr->bmiColors[1].rgbBlue );

               /* don't change text and background colors if performing a
                  pattern blt.  Otherwise, change to the DIB palette colors */
               if (!patternBlt)
               {
                  CaSetTextColor( fgColor );
                  CaSetBkColor( bkColor );
               }

               /* set the stretch mode to correct setting */
               CaSetStretchBltMode( (fgColor == black) ? BLACKONWHITE :
                                                         WHITEONBLACK );
            }
            else
            {
               /* if drawing a color bitmap, set the stretch mode accordingly */
               CaSetStretchBltMode( COLORONCOLOR );
            }

            /* call Gdi routine to draw bitmap */
            StretchDIBits( gdiEnv.metafile,
                           dst.left, dst.top, Width( dst ), Height( dst ),
                           src.left - pixMapLPtr->bounds.left,
                           src.top  - pixMapLPtr->bounds.top,
                           Width( src ), Height( src ),
                           bitsLPtr, bitsInfoLPtr, DIB_RGB_COLORS, ropCode );

            /* if this is the first pass, and a second is required ... */
            if (pass == 0 && numPasses == 2)
            {
               /*  set the new ROP code */
               ropCode = SRCPAINT;

               /* set the new background (black) and foreground colors */
               bitsInfoLPtr->bmiColors[1] = bitsInfoLPtr->bmiColors[0];
               bitsInfoLPtr->bmiColors[0] = secondFgColor;
            }
         }

         /* unlock the data and de-allocate it */
         GlobalUnlock( bitsHandle );
         GlobalUnlock( bitsInfoHandle );

         GlobalFree( bitsHandle );
         GlobalFree( bitsInfoHandle );
      }
   }

   /* De-allocate memory used for the pixel data */
   GlobalFree( pixDataHandle );

   /* if a rectangular clipping region was set up, restore original clip */
   if (clipRectSet)
   {
      /* Call Gdi module to change the clipping rectangle back to the
         previous settting before bitblt operation */
      gdiEnv.drawingEnabled = CaIntersectClipRect( gdiEnv.clipRect );
   }

}  /* GdiStretchDIBits */



void GdiSelectClipRegion( RgnHandle rgn )
/*======================*/
/* Create a clipping rectangle or region using handle passed */
{
   Integer far *  sizeLPtr;
   Boolean        arbitraryClipRgn;
   Comment        gdiComment;

   /* lock down the handle and emit rectangular clip region */
   sizeLPtr = (Integer far *)GlobalLock( rgn );

   /* Save the Gdi clip rectangle (used for EPS translation) */
   gdiEnv.clipRect = *((Rect far *)(sizeLPtr + 1));

   /* determine if this is a non-rectangular clipping region */
   arbitraryClipRgn = (*sizeLPtr > RgnHeaderSize);

   /* flag the clipping region if this is non-rectangular */
   if (arbitraryClipRgn)
   {
      /* check preference memory to see what action to take */
      if (gdiPrefsLPtr->nonRectRegionAction == GdiPrefAbort)
      {
         /* set global error if user request abort */
         ErSetGlobalError( ErNonRectRegion );
         return;
      }
      /* creating clipping region - emit comment to flag construct */
      else
      {
         /* put this in as a private comment */
         gdiComment.signature = POWERPOINT;
         gdiComment.function = PP_BEGINCLIPREGION;
         gdiComment.size = 0;

         /* write the comment to the metafile */
         GdiShortComment( &gdiComment );
      }
   }
   /* make sure that the clipping rectangle is confined to the bounding
      box of the image.  This is a workaround go MacDraft images that
      may contain clipping rectangles of (-32000, -32000),(32000, 32000) */
   IntersectRect( &gdiEnv.clipRect, &gdiEnv.clipRect, &gdiPict.bbox );

   /* Call Gdi module to change the clipping rectangle */
   gdiEnv.drawingEnabled = CaIntersectClipRect( gdiEnv.clipRect );

   /* determine if this is a non-rectangular clip region */
   if (arbitraryClipRgn)
   {
      Integer        excludeSeg[100];
      Integer        yStart[50];
      Integer        yBottom;
      Integer        numSegs;
      Integer far *  rgnLPtr;

      /* notify cache that a non-rectangular clipping region is being set */
      CaNonRectangularClip();

      /* save off the current y offset and first excluded segment */
      yStart[0]     = gdiEnv.clipRect.top;
      excludeSeg[0] = gdiEnv.clipRect.left;
      excludeSeg[1] = gdiEnv.clipRect.right;
      numSegs = 2;

      /* get the beginning of the region data */
      rgnLPtr = sizeLPtr + (RgnHeaderSize / sizeofMacWord);

      /* loop until the end-of-region record is encountered */
      while (*rgnLPtr != 0x7FFF)
      {
         /* copy the new y coordinate to merge */
         yBottom = *rgnLPtr++;

         /* continue looping until end of line marker encountered */
         while (*rgnLPtr != 0x7FFF)
         {
            Integer     start;
            Integer     end;
            Integer     s;
            Integer     e;
            Boolean     sEqual;
            Boolean     eEqual;
            Integer     yTop;
            Integer     left;

            /* determine the start and end point of segment to exclude */
            start = *rgnLPtr++;
            end   = *rgnLPtr++;

            /* find where the insertion point should be */
            for (s = 0; (s < numSegs) && (start > excludeSeg[s]); s++) ;
            for (e = s; (e < numSegs) && (end   > excludeSeg[e]); e++) ;

            /* determine if start and end points == segment ends */
            sEqual = ((s < numSegs) && (start == excludeSeg[s]));
            eEqual = ((e < numSegs) && (end   == excludeSeg[e]));

            /* make sure that this isn't the first scanline, and that
               a valid exclude segment will be referenced in the array.*/
            if ((yBottom != gdiEnv.clipRect.top) && (s != numSegs))
            {
               /* ensure the excluded excludeSeg starts on even offset */
               yTop = s / 2;
               left = yTop * 2;

               /* put the excluded rectangle record into the metafile */
               ExcludeClipRect( gdiEnv.metafile,
                                excludeSeg[left], yStart[yTop],
                                excludeSeg[left + 1], yBottom);

               /* reset the new y coordinate for the excludeSeg */
               yStart[yTop] = yBottom;

               /* determine if 2 segments are affected in merge */
               if (((e - left >= 2 && eEqual && sEqual) ||
                    (e - left >= 2 && eEqual) ||
                    (e - left == 3 && sEqual)))
               {
                  /* if so, put put eliminated cliprect in also */
                  ExcludeClipRect( gdiEnv.metafile,
                                   excludeSeg[left + 2], yStart[yTop + 1],
                                   excludeSeg[left + 3], yBottom);

                  /* reset the y coordinate for this new segment */
                  yStart[yTop + 1] = yBottom;
               }
            }

            /* if start and end fall on existing excludeSegs */
            if (sEqual && eEqual)
            {
               /* segment count reduced by 2 */
               numSegs -= 2;

               /* if two segments are involved in merge

                   0 *---------* 1         2 *--------* 3
                   s *+++++++++++++++++++++++* e
                             0 *======================* 1
               */
               if (e - s == 2)
               {
                  /* move down the end point of the first segment */
                  excludeSeg[s] = excludeSeg[s + 1];
                  yStart[s / 2 + 1] = yStart[s / 2];

                  /* increment the start point for the segment shift */
                  s++;
               }

               /* handle case where a single segment is affected

                   0 *---------* 1         2 *--------* 3
                             s *+++++++++++++* e
                   0 *================================* 1
               */
               /* move all the flats two points to the left */
               for ( ; s < numSegs; s += 2)
               {
                  excludeSeg[s] = excludeSeg[s + 2];
                  excludeSeg[s + 1] = excludeSeg[s + 3];
                  yStart[s / 2] = yStart[s / 2 + 1];
               }
            }
            /* if just the starting point is identical */
            else if (sEqual)
            {
               /* if segment boundary was crossed - 2 segs affected

                   0 *---------* 1    2 *-------------* 3
                             s *++++++++++++++++* e
                   0 *==================* 1   2 *=====* 3
               */
               if ((excludeSeg[s + 1] < end) && (s + 1 < numSegs))
               {
                  /* toggle the start/end points and insert end */
                  excludeSeg[s] = excludeSeg[s + 1];
                  excludeSeg[s + 1] = end;
               }
               /* otherwise, a simple extension of the segment is done

                   0 *---------* 1
                             s *++++++++++++++++++++++* e
                   0 *================================* 1
               */
               else
               {
                  /* assign a new ending point for the excludeSeg */
                  excludeSeg[s] = end;
               }
            }
            /* if just the ending point is identical */
            else if (eEqual)
            {
               /* if segment boundary was crossed - 2 segs affected

                   0 *------------* 1        2 *------* 3
                        s *++++++++++++++++++++* e
                   0 *====* 1   2 *===================* 3
               */
               if ((excludeSeg[e - 1] > start) && (e - 1 > 0))
               {
                  /* toggle the start/end points and insert start */
                  excludeSeg[s + 1] = excludeSeg[s];
                  excludeSeg[s] = start;
               }
               /* otherwise, a simple extension of the segment is done

                                          0 *---------* 1
                   s *++++++++++++++++++++++* e
                   0 *================================* 1
               */
               else
               {
                  /* assign a new starting point for the excludeSeg */
                  excludeSeg[e] = start;
               }
            }
            /* if an entirely new excludeSeg is being created */
            else
            {
               Integer  idx;

               /* create an new set of points */
               numSegs += 2;

               /* move all the flats two points to the right */
               for (idx = numSegs - 1; idx > s; idx -= 2)
               {
                  excludeSeg[idx] = excludeSeg[idx - 2];
                  excludeSeg[idx + 1] = excludeSeg[idx - 1];
                  yStart[idx / 2] = yStart[idx / 2 - 1];
               }

               /* start and endpoints are identical, insert new seg

                   0 *--------------------------------------* 1
                             s *++++++++++++++++* e
                   0 *=========* 1            2 *===========* 3
               */
               if (s == e)
               {
                  /* and insert the new excludeSeg */
                  excludeSeg[s] = start;
                  excludeSeg[s + 1] = end;
                  yStart[s / 2] = yBottom;
               }
               /* otherwise, need to shift in the new points

                   0 *---------------------* 1
                             s *++++++++++++++++++++++++++++* e
                   0 *=========* 1       2 *================* 3
               */
               else
               {
                  excludeSeg[s] = start;
                  excludeSeg[s + 1] = excludeSeg[s + 2];
                  excludeSeg[s + 2] = end;
                  yStart[s / 2] = yBottom;
                  yStart[s / 2 + 1] = yBottom;
               }
            }
         }

         /* increment past the end of line flag */
         rgnLPtr++;
      }

      /* place the end of clip region comment into metafile */
      gdiComment.function = PP_ENDCLIPREGION;
      GdiShortComment( &gdiComment );
   }

   /* unlock the memory handle */
   GlobalUnlock( rgn );

}  /* GdiSelectClipRegion */



void GdiHatchPattern( Integer hatchIndex )
/*==================*/
/* Use the hatch pattern index passed down to perform all ensuing fill
   operations - 0-6 for a hatch value, -1 turns off the substitution */
{
   gdiEnv.hatchIndex = hatchIndex;

}  /* GdiHatchPattern */



void GdiFontName( Byte fontFamily, Byte charSet, StringLPtr fontName )
/*==============*/
/* Set font characteristics based upno metafile comment from GDI2QD */
{
   /* copy the passed values into the font table */
   fontTable[FntFromGdi].family = fontFamily;
   fontTable[FntFromGdi].charset = charSet;
   lstrcpy( fontTable[FntFromGdi].gdiName, fontName );

   /* indicate that the font name should be used - no table lookup */
   gdiEnv.useGdiFont = TRUE;

}  /* GdiFontName */



void GdiShortComment( CommentLPtr cmtLPtr )
/*==================*/
/* Write public or private comment with no associated data */
{
   /* write the comment into the metafile */
   GdiEscape( MFCOMMENT, sizeof( Comment ), (StringLPtr)cmtLPtr );

}  /* GdiComment */



void GdiEscape( Integer function, Integer count, StringLPtr data)
/*============*/
/* Write out a GDI Escape structure with no returned data */
{
   /* Flush the cache before emitting the new metafile record */
   CaFlushCache();

   /* write the comment into the metafile */
   Escape( gdiEnv.metafile, function, count, data, NULL );

}  /* GdiEscape */



void GdiSetConversionPrefs( ConvPrefsLPtr convPrefs)
/*=====================*/
/* Provide conversion preferences via global data block */
{
   /* Save the metafile prefs Open() is issued */
   gdiPrefsLPtr = convPrefs;

}  /* GdiSetConversionPrefs */


void GdiOpenMetafile( void )
/*==================*/
/* Open metafile passed by GdiSetMetafileName() and perform any
   initialization of the graphics state */
{
   /* save metafile handle in global memory structure */
   gdiEnv.metafile = CreateMetaFile( gdiPrefsLPtr->metafileName );
   if (gdiEnv.metafile == NULL)
   {
      ErSetGlobalError( ErCreateMetafileFail );
   }
   else
   {
      /* get a handle to an information context for text metrics */
      gdiEnv.infoContext  = CreateIC( "DISPLAY", NULL, NULL, NULL );
#ifdef _OLECNV32_
      gdiEnv.fontFunction = EnumFontFunc;
#else
      gdiEnv.fontFunction = GetProcAddress( GetModuleHandle( "PICTIMP" ), "EnumFontFunc" );
#endif

      /* initialize the cache module */
      CaInit( gdiEnv.metafile );

      /* set up default logical font structures */
      gdiEnv.newLogFont = logFontSkel;

      /* enable drawing to metafile */
      gdiEnv.drawingEnabled = TRUE;

      /* don't override font table search until font comment is found */
      gdiEnv.useGdiFont = FALSE;

      /* don't use a hatch pattern substitution */
      gdiEnv.hatchIndex = -1;

      /* set the sameObject flag to FALSE and notify cache module */
      gdiEnv.sameObject = FALSE;
      CaSamePrimitive( FALSE );

      /* determine if running on Windows 3.1 or higher */
      if (LOBYTE( GetVersion() ) >= 3 && HIBYTE( GetVersion() ) >= 10 )
      {
         Byte  i;

         /* change the font substitution name to TrueType fonts */
         for (i = 0; i < NumTTSubs; i++)
         {
            lstrcpy( fontTable[TTSubStart + i].gdiName, trueTypeSub[i] );
         }

         /* change the font family for "Symbol" to FF_ROMAN */
         fontTable[FntSymbol].family = FF_ROMAN;

         /* loop through all entries, changing FF_DECORATIVE to FF_DONTCARE */
         for (i = 0; i < FntNoMatch; i++)
         {
            /* check for the family that needs to be changed */
            if (fontTable[i].family == FF_DECORATIVE)
            {
               /* change to FF_DONTCARE */
               fontTable[i].family = FF_DONTCARE;
            }
         }
      }
   }

}  /* GdiOpenMetafile */


void GdiSetBoundingBox( Rect bbox, Integer resolution )
/*====================*/
/* Set the overall picture size and picture resoulution in dpi */
{
   /* make sure this isn't an empty bounding rectangle */
   if (EmptyRect( bbox ))
   {
      /* if an error, then bail out */
      ErSetGlobalError( ErNullBoundingRect );
   }
   /* check if either dimension exceeds 32K - this would be flagged by a
      negative dimension signifying integer overflow condition */
   else if ((Width( bbox ) < 0) || (Height( bbox ) < 0))
   {
      /* indicate that the 32K limit was exceeded */
      ErSetGlobalError( Er32KBoundingRect );
   }
   else
   {
      /* Set up the Window origin in metafile and shadow DC */

#ifdef WIN32
      SetWindowOrgEx( gdiEnv.metafile, bbox.left, bbox.top, NULL );
#else
      SetWindowOrg( gdiEnv.metafile, bbox.left, bbox.top );
#endif

      /* Set window extent in metafile and shadow DC */

#ifdef WIN32
      SetWindowExtEx( gdiEnv.metafile, Width( bbox), Height( bbox ), NULL );
#else
      SetWindowExt( gdiEnv.metafile, Width( bbox), Height( bbox ) );
#endif

      /* Notify cache of the new clipping rectangle */
      CaSetClipRect( bbox );

      /* Notify cache that it should issue metafile defaults before SaveDC() */
      CaSetMetafileDefaults();

      /* Save display context, just in case clipping rect changes */
      CaSaveDC();

      /* Save overall dimensions and resolution in picture results structure */
      gdiPict.bbox = bbox;
      gdiPict.inch = (WORD) resolution;

      /* save the bounding box in the environment as the clipping rectangle */
      gdiEnv.clipRect = bbox;
   }

}  /* GdiSetBoundingBox */


void GdiCloseMetafile( void )
/*===================*/
/* Close the metafile handle and end picture generation */
{
   /* flush the cache before proceeding */
   CaFlushCache();

   /* Balance CaSaveDC() issued at beginning of the metafile */
   CaRestoreDC();

   /* and close the metafile */
   gdiPict.hmf = CloseMetaFile( gdiEnv.metafile );

   /* check the return value from the closemetafile - may be out of memory? */
   if (gdiPict.hmf == NULL)
   {
      ErSetGlobalError( ErCloseMetafileFail );
   }

   /* release the information context */
   DeleteDC( gdiEnv.infoContext );

   /* Close down the cache module */
   CaFini();

   /* if global error occurred, then remove metafile */
   if (ErGetGlobalError() != NOERR)
   {
      DeleteMetaFile( gdiPict.hmf );
      gdiPict.hmf = NULL;
   }

}  /* GdiCloseMetafile */



void GdiGetConversionResults( PictInfoLPtr  pictInfoLPtr )
/*==========================*/
/* return results of the conversion */
{
   /* just assign the saved values into the pointer passed in */
   *pictInfoLPtr = gdiPict;

}  /* GdiGetConversionResults */



void GdiMarkAsChanged( Integer attribCode )
/*===================*/
/* indicate that the attribute passed in has changed */
{
   gdiEnv.state[attribCode] = Changed;

}  /* GdiMarkAsChanged */


void GdiSamePrimitive( Boolean same )
/*===================*/
/* indicate whether next primitive is the same or new */
{
   /* save the state for merging of fill and frame operation */
   gdiEnv.sameObject = (same && (CaGetCachedPrimitive() != CaEmpty));

   CaSamePrimitive( same );

}  /* GdiSamePrimitive */


#ifdef WIN32
int WINAPI EnumFontFunc( CONST LOGFONT *logFontLPtr, CONST TEXTMETRIC *tmLPtr,
                         DWORD fontType, LPARAM dataLPtr )
/*====================*/
#else
int FAR PASCAL EnumFontFunc( LPLOGFONT logFontLPtr, LPTEXTMETRIC tmLPtr,
                             short fontType, LPSTR dataLPtr )
/*========================*/
#endif
/* Callback function used to determine if a given font is available */
{
   /* copy the passed values into the font table */
   fontTable[FntNoMatch].family  = logFontLPtr->lfPitchAndFamily;
   fontTable[FntNoMatch].charset = logFontLPtr->lfCharSet;

   /* this return value will be ignored */
   return TRUE;

   UnReferenced( tmLPtr );
   UnReferenced( fontType );
   UnReferenced( dataLPtr );

}  /* EnumFontFunc */



/******************************* Private Routines ***************************/


private Boolean IsArithmeticMode( Integer mode )
/*------------------------------*/
/* return TRUE if this is an arithmetic transfer mode */
{
   switch (mode)
   {
      case QDBlend:
      case QDAddPin:
      case QDAddOver:
      case QDSubPin:
      case QDAdMax:
      case QDSubOver:
      case QDAdMin:
      {
         return TRUE;
      }

      default:
      {
         return FALSE;
      }
   }

}  /* IsArithmeticMode */


private void CalculatePenSize( Point startPt, Point endPt, Point penSize )
/*---------------------------*/
/* calcuate the pen width to produce equivalent QuickDraw stroke */
{
   Point    delta;
   Real     lineLen;

   /* calcuate x and y delta of line segment */
   delta.x = abs( endPt.x - startPt.x );
   delta.y = abs( endPt.y - startPt.y );

   /* see if we have a vertical or horizontal line.  Otherwise, calculate
      the resulting line length on diagonal line. */
   if (delta.x == 0)
   {
      gdiEnv.newLogPen.lopnWidth.x = penSize.x;
   }
   else if (delta.y == 0)
   {
      gdiEnv.newLogPen.lopnWidth.x = penSize.y;
   }
   /* check if the pen size is 1 in each direction */
   else if ((penSize.x == 1) && (penSize.y == 1))
   {
      /* in this case, it should always be pen width of 1 */
      gdiEnv.newLogPen.lopnWidth.x = 1;
   }
   else
   {
      /* calculate the line length using Pythagorean theorem */
      lineLen = sqrt( ((Real)delta.x * (Real)delta.x) +
                      ((Real)delta.y * (Real)delta.y) );

      /* calculate the correct line diameter */
      gdiEnv.newLogPen.lopnWidth.x = (Integer)((penSize.y * delta.x +
                                                penSize.x * delta.y) / lineLen);
   }

   /* make sure that SetPenAttributes() doesn't change pen width */
   GdiMarkAsCurrent( GdiPnSize );

}  /* CalculatePenSize */



private Boolean SetAttributes( GrafVerb verb )
/*---------------------------*/
/* set up pen and brush elements according to GrafVerb */
{
   Boolean     allOK;

   /* if call to SetPenAttributes() fails, then return false */
   allOK = FALSE;

   /* set up pen attributes */
   if (SetPenAttributes( verb ))
   {
      /* set up brush attributes */
      allOK = SetBrushAttributes( verb );
   }

   /* return continue or stop status */
   return allOK;

}  /* SetAttributes */



private Boolean SetPenAttributes( GrafVerb verb )
/*-----------------------------*/
/* make sure that pen attributes are OK according to preferences */
{
   CGrafPortLPtr     port;

   /* Get the QuickDraw port in order to check pen settings */
   QDGetPort( &port );

   /* see if we are drawing with a NULL pen and can skip all the checks */
   if (verb == GdiFrame)
   {
      /* check for hidden pen mode - don't draw if invalid */
      if (IsHiddenPenMode( port->pnMode ))
      {
         return FALSE;
      }
      /* check for zero-size pen width = don't draw anything */
      else if (port->pnSize.x == 0 || port->pnSize.y == 0)
      {
         return FALSE;
      }

      /* use inside frame to best approximate the QD drawing model */
      gdiEnv.newLogPen.lopnStyle = PS_INSIDEFRAME;
   }
   else
   {
      /* if paint, erase, invert, or fill, then there is no perimeter */
      gdiEnv.newLogPen.lopnStyle = PS_NULL;
   }

   /* if NULL pen, then all the other fields don't change and don't matter */
   if (gdiEnv.newLogPen.lopnStyle != PS_NULL)
   {
      /* make sure that we are changing the pen size */
      if (GdiAttribHasChanged( GdiPnSize ))
      {
         /* check for non-square pen */
         if (port->pnSize.x == port->pnSize.y)
         {
            /* use x dimensions as the pen size if square pen */
            gdiEnv.newLogPen.lopnWidth.x = port->pnSize.x;
         }
         else
         {
            /* if non-square, do what the user requests */
            switch (gdiPrefsLPtr->nonSquarePenAction)
            {
               case GdiPrefOmit:          // omit line entirely
                  return FALSE;
                  break;

               case 1:                    // use width
                  gdiEnv.newLogPen.lopnWidth.x = port->pnSize.x;
                  break;

               case GdiPrefAbort:         // abort conversion completely
                  ErSetGlobalError( ErNonSquarePen );
                  return FALSE;
                  break;

               case 3:                    // use height
                  gdiEnv.newLogPen.lopnWidth.x = port->pnSize.y;
                  break;

               case 4:                    // use minimum dimension
                  gdiEnv.newLogPen.lopnWidth.x = min( port->pnSize.x, port->pnSize.y );
                  break;

               case 5:                    // use maximum dimension
                  gdiEnv.newLogPen.lopnWidth.x = max( port->pnSize.x, port->pnSize.y );
                  break;
            }
         }

         /* indicate that the pen size is current */
         GdiMarkAsCurrent( GdiPnSize );
      }

      /* get the correct pen color that we should draw with */
      if (!IsSolidPattern( &port->pnPixPat, &gdiEnv.newLogPen.lopnColor, MIXGREY ) )
      {
         /* check what to do with patterned pen */
         switch (gdiPrefsLPtr->penPatternAction)
         {
            case GdiPrefOmit:    // omit line entirely
               return FALSE;
               break;

            case 1:              // use foreground color
               gdiEnv.newLogPen.lopnColor = port->rgbFgColor;
               break;

            case GdiPrefAbort:   // abort conversion completely
               ErSetGlobalError( ErPatternedPen );
               return FALSE;
               break;
         }
      }

      /* make sure that we are changing the pen size */
      if (GdiAttribHasChanged( GdiPnMode ))
      {
         /* finally, check the transfer mode */
         if (IsArithmeticMode( port->pnMode ))
         {
            switch (gdiPrefsLPtr->penModeAction)
            {
               case GdiPrefOmit:    // omit line entirely
                  return FALSE;
                  break;

               case 1:              // use srcCopy
                  CaSetROP2( R2_COPYPEN );
                  break;

               case GdiPrefAbort:   // abort conversion completely
                  ErSetGlobalError( ErInvalidXferMode );
                  return FALSE;
                  break;
            }
         }

         /* indicate that the pen pattern is current */
         GdiMarkAsCurrent( GdiPnMode );
      }
   }

   /* notify cache that it should attempt to merge fill and frame */
   CaMergePen( verb );

   /* call cache module to create new pen */
   CaCreatePenIndirect( &gdiEnv.newLogPen );

   /* check if we are framing a previously filled object */
   if (gdiEnv.sameObject && verb == GdiFrame)
   {
      /* if so, flush the cache and indicate that nothing more to do */
      CaFlushCache();
      return FALSE;
   }
   else
   {
      /* return all systems go */
      return TRUE;
   }


}  /* SetPenAttributes */





private Boolean SetBrushAttributes( GrafVerb verb )
/*--------------------------------*/
/* set up the correct brush (fill) for the ensuing primitive */
{
   CGrafPortLPtr  port;
   PixPatLPtr     pixPatLPtr;

   /* get the Quickdraw port to access brush patterns */
   QDGetPort( &port );

   /* Determine the brush pattern that should be used */
   switch (verb)
   {
      /* fill with HOLLOW brush */
      case GdiFrame:
         gdiEnv.newLogBrush.lbStyle = BS_HOLLOW;
         break;

      /* fill using current pen pattern */
      case GdiPaint:
         pixPatLPtr = &port->pnPixPat;
         gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         break;

      /* fill using current fill pattern */
      case GdiFill:
         if (gdiEnv.hatchIndex == -1)
         {
            pixPatLPtr = &port->fillPixPat;
            gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         }
         else
         {
            /* override pattern with a hatch pattern index */
            gdiEnv.newLogBrush.lbStyle = BS_HATCHED;
            gdiEnv.newLogBrush.lbColor = port->rgbFgColor;
            gdiEnv.newLogBrush.lbHatch = gdiEnv.hatchIndex;

            /* set the background color and make the hatch opaque */
            CaSetBkColor( port->rgbBkColor );
            CaSetBkMode( OPAQUE );
         }
         break;

      /* erase to current background pattern */
      case GdiErase:
         pixPatLPtr = &port->bkPixPat;
         gdiEnv.newLogBrush.lbStyle = BS_DIBPATTERN;
         break;

      /* invert all bits using black brush */
      case GdiInvert:
         gdiEnv.newLogBrush.lbStyle = BS_SOLID;
         gdiEnv.newLogBrush.lbColor = RGB( 0, 0, 0 );
         break;
   }

   /* if this is a DIB pattern, check to see if we are using a solid brush */
   if (gdiEnv.newLogBrush.lbStyle == BS_DIBPATTERN)
   {
      /* first check if this is a dithered pixmap pattern */
      if (pixPatLPtr->patType == QDDitherPat)
      {
         /* read the color from the secret reserved field */
         gdiEnv.newLogBrush.lbColor = pixPatLPtr->patMap.pmReserved;
         gdiEnv.newLogBrush.lbStyle = BS_SOLID;

      }
      else
      {
         /* if this is a solid pattern, assign new solid pattern color. */
         if (IsSolidPattern( pixPatLPtr, &gdiEnv.newLogBrush.lbColor, NOMIX ))
         {
            /* if this is a solid brush, change the logBrush desired attribs */
            gdiEnv.newLogBrush.lbStyle = BS_SOLID;

            /* make sure that the pen color is correct for Erase grafVerb */
            if (verb == GdiErase)
            {
               /* check the new color setting */
               if (gdiEnv.newLogBrush.lbColor == port->rgbFgColor)
               {
                  gdiEnv.newLogBrush.lbColor = port->rgbBkColor;
               }
               else
               {
                  gdiEnv.newLogBrush.lbColor = port->rgbFgColor;
               }
            }
         }
         else
         {
            /* save the type of pattern DIB that is being created */
            gdiEnv.lastPatType = pixPatLPtr->patType;

            /* set the color field to indicate that we are using RGB palette */
            gdiEnv.newLogBrush.lbColor = DIB_RGB_COLORS;

            /* create DIB pattern based upon pattern type */
            switch (pixPatLPtr->patType)
            {
               /* create a simple 2-color pattern DIB brush */
               case QDOldPat:
               {
                  MakePatternBrush( pixPatLPtr );
                  break;
               }

               /* create full-scale pattern DIB brush */
               case QDNewPat:
               {
                  MakeDIB( &pixPatLPtr->patMap, pixPatLPtr->patData,
                           (Handle far *)&gdiEnv.newLogBrush.lbHatch,
                           (Handle far *)NULL,
                           TRUE );
                  break;
               }
            }
         }
      }
   }

   /* call cache module to create brush and select it into metafile */
   CaCreateBrushIndirect( &gdiEnv.newLogBrush );

   /* all OK */
   return TRUE;

}  /* SetBrushAttributes */


private void MakePatternBrush( PixPatLPtr pixPatLPtr )
/*---------------------------*/
/* Make a new pattern brush using pixelPat passed in */
{
   CGrafPort far *   port;
   PatBrush far *    patLPtr;
   Byte              i;
   DWORD far *       gdiPattern;
   Byte far *        qdPattern;
   Byte far *        savePattern;

   /* allocate the new structure */
   gdiEnv.newLogBrush.lbHatch = (ULONG_PTR) GlobalAlloc( GHND, sizeof( PatBrush ) );

   /* make sure that the memory could be allocated */
   if (gdiEnv.newLogBrush.lbHatch == (ULONG_PTR) NULL)
   {
      ErSetGlobalError( ErMemoryFull );
      return;
   }

   /* Get QuickDraw port address to access fore and background colors */
   QDGetPort( &port );

   /* set the corresponding text and background colors for metafile */
   CaSetBkColor( port->rgbBkColor );
   CaSetTextColor( port->rgbFgColor );

   /* lock down the data to access the individual elements */
   patLPtr = (PatBrushLPtr)GlobalLock( (HANDLE) gdiEnv.newLogBrush.lbHatch );

   /* copy over skelton brush structure */
   *patLPtr = patBrushSkel;

   /* save the fore- and background colors for later compares */
   gdiEnv.lastFgColor = port->rgbFgColor;
   gdiEnv.lastBkColor = port->rgbBkColor;

   /* convert the current background color to RGBQUAD structure */
   patLPtr->bmiColors[0].rgbRed = GetRValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbBlue = GetBValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbGreen = GetGValue( port->rgbFgColor );
   patLPtr->bmiColors[0].rgbReserved = 0;

   /* convert the current foreground color to RGBQUAD structure */
   patLPtr->bmiColors[1].rgbRed = GetRValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbBlue = GetBValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbGreen = GetGValue( port->rgbBkColor );
   patLPtr->bmiColors[1].rgbReserved = 0;

   /* set up pointers to patterns in preparation for copy */
   savePattern = (Byte far *)&gdiEnv.lastPattern[7];
   qdPattern   = (Byte far *)&pixPatLPtr->pat1Data[7];
   gdiPattern  = (DWORD far *)&patLPtr->pattern[0];

   /* Copy the bitmap bits into the individual scanlines.  Note that
      we need to XOR the bits, since they are opposite to Windows GDI */
   for (i = 0; i < sizeof( Pattern ); i++)
   {
      /* save off the pattern into the GDI environment for later compares */
      *savePattern-- = *qdPattern;

      /* note that scanlines are padded to a DWORD boundary */
      *gdiPattern++ = (DWord)(*qdPattern-- ^ 0xFF);
   }

   /* Unlock the data for call to CreateBrushIndirect() */
   GlobalUnlock( (HANDLE) gdiEnv.newLogBrush.lbHatch );

}  /* MakePatternBrush */




private Boolean IsSolidPattern( PixPatLPtr pixPatLPtr,
                                RGBColor far * rgbColor,
                                Boolean mixColors )
/*----------------------------*/
/* return true if pattern is solid, false if not.  If mixColors is TRUE, then
   mixtures of 25%, 50%, and 75% grey are mixed into a solid color */
{
   Boolean           solidPattern;
   DWord             repeatPattern;
   DWord far *       penBitsLPtr;
   CGrafPort far *   port;

   /* get access to foreground and background colors */
   QDGetPort( &port );

   /* assume that the pattern isn't solid for now */
   solidPattern = FALSE;

   /* check whether to use old monochrome bitmap or new pixmap patterns */
   if (pixPatLPtr->patType == QDOldPat)
   {
      /* check for patterned brush in 8x8 monochrome bitmap */
      penBitsLPtr = (DWord far *)&pixPatLPtr->pat1Data;

      /* save off the first DWord, and compare for matching scanlines */
      repeatPattern = *penBitsLPtr;

      /* check if either solid white (all 0's) or solid black (all 1's) */
      if ((repeatPattern != 0x00000000) && (repeatPattern != 0xFFFFFFFF))
      {
         ;  /* not solid black or white - just skip ensuing checks */
      }
      /* next, check if first block same as second block of bits */
      else if (repeatPattern != penBitsLPtr[1])
      {
         ;  /* first DWord doesn't match second - skip remaining checks */
      }
      /* so far, either a black or white pattern - check for black, first */
      else if (repeatPattern == 0xFFFFFFFF)
      {
         /* solid black - use the port's foreground color */
         *rgbColor = port->rgbFgColor;
         solidPattern = TRUE;
      }
      /* finally, this must be a solid white pattern */
      else /* if (repeatPattern == 0x00000000) */
      {
         /* solid white - use the background color in the QuickDraw port */
         *rgbColor = port->rgbBkColor;
         solidPattern = TRUE;
      }

      /* if this isn't a solid pattern, but we want to mix colors */
      if (!solidPattern && mixColors)
      {
         Byte        i;
         Byte        blackBits;
         Byte        whiteBits;

         /* set solid to TRUE, since we will be using a blend of the colors */
         solidPattern = TRUE;

         /* count the number of 1 bits in the pattern */
         for (i = 0, blackBits = 0; i < sizeof( DWord ) * 8; i++)
         {
            /* bitwise AND for the addition, then shift one bit to right */
            blackBits += (Byte)(repeatPattern & 1);
            repeatPattern /= 2;
         }

         /* perform the same calculation using the second DWord */
         for (i = 0, repeatPattern = penBitsLPtr[1]; i < sizeof( DWord ) * 8; i++)
         {
            /* bitwise AND for the addition, then shift one bit to right */
            blackBits += (Byte)(repeatPattern & 1);
            repeatPattern /= 2;
         }

         /* calculate white bit count, since black + white bits == 64 */
         whiteBits = (Byte)64 - blackBits;

         /* using the 1 bit count, calculate weighted average of fore- and
            background colors in the QuickDraw port */
         *rgbColor = RGB( (Byte)((blackBits * RValue( port->rgbFgColor ) + whiteBits * RValue( port->rgbBkColor )) / 64),
                          (Byte)((blackBits * GValue( port->rgbFgColor ) + whiteBits * GValue( port->rgbBkColor )) / 64),
                          (Byte)((blackBits * BValue( port->rgbFgColor ) + whiteBits * BValue( port->rgbBkColor )) / 64) );
      }
   }

   /* return results of compare */
   return solidPattern;

}  /* IsSolidPattern */



private Boolean FrameMatchesFill( Word primType )
/*------------------------------*/
/* return TRUE if the fill pattern (current brush ) matches frame pattern */
{
   CGrafPortLPtr     port;

   /* get the Quickdraw port to access brush patterns */
   QDGetPort( &port );

   /* make sure this is the parameters and same primitive type */
   if (!gdiEnv.sameObject || (CaGetCachedPrimitive() != primType))
   {
      return FALSE;
   }
   /* check whether we are using an old (8 byte) pattern brush */
   else if (port->pnPixPat.patType != QDOldPat || gdiEnv.lastPatType != QDOldPat)
   {
      return FALSE;
   }
   /* we are only interested in comparing DIB pattern brushes */
   else if (gdiEnv.newLogBrush.lbStyle != BS_DIBPATTERN)
   {
      return FALSE;
   }
   /* compare the fore- and background colors first */
   else if ((port->rgbFgColor != gdiEnv.lastFgColor) ||
            (port->rgbBkColor != gdiEnv.lastBkColor) )
   {
      return FALSE;
   }
   else
   {
      Byte     i;

      /* Compare each of the pattern bits to determine if same. */
      for (i = 0; i < sizeof( Pattern ); i++)
      {
         /* if patterns don't match, return FALSE and exit loop */
         if (port->pnPixPat.pat1Data[i] != gdiEnv.lastPattern[i])
         {
            return FALSE;
         }
      }
   }

   /* all the compares indicate that the fill matches the frame */
   return TRUE;

}  /* FrameMatchesFill */



private Boolean SetTextAttributes( void )
/*-------------------------------*/
/* set up text attributes - set mapChars to TRUE if should map to ANSI */
{
   CGrafPortLPtr     port;

   /* Get the QuickDraw port in order to check font settings */
   QDGetPort( &port );

   /* set the text alignment to be baseline */
   CaSetTextAlign( TA_LEFT | TA_BASELINE | TA_NOUPDATECP );

   /* set the correct foreground and background colors */
   switch (port->txMode)
   {
      case QDSrcCopy:
         CaSetTextColor( port->rgbFgColor );
         CaSetBkColor( port->rgbBkColor );
         break;

      case QDSrcBic:
         CaSetTextColor( port->rgbBkColor );
         break;

      case QDSrcXor:
         CaSetTextColor( RGB( 0, 0, 0 ) );
         break;

      case QDSrcOr:
      default:
         CaSetTextColor( port->rgbFgColor );
         break;
   }

   /* set the background cell transparency mode */
   CaSetBkMode( (port->txMode == QDSrcCopy) ? OPAQUE : TRANSPARENT );

   /* check the character extra field */
   if (GdiAttribHasChanged( GdiChExtra ))
   {
      /* call the cache to set charextra in metafile */
      CaSetTextCharacterExtra( port->chExtra );

      /* update the status */
      GdiMarkAsCurrent( GdiChExtra );
   }

   /* convert the QuickDraw clockwise rotation to GDI counter-clockwise */
   gdiEnv.newLogFont.lfEscapement = (port->txRotation == 0) ?
                                     0 :
                                     10 * (360 - port->txRotation);

   /* make sure text flipping is taken into consiseration */
   gdiEnv.newLogFont.lfOrientation = (port->txFlip == QDFlipNone) ?
                                     gdiEnv.newLogFont.lfEscapement :
                                     ((gdiEnv.newLogFont.lfEscapement > 1800) ?
                                       gdiEnv.newLogFont.lfEscapement - 1800 :
                                       1800 - gdiEnv.newLogFont.lfEscapement);

   /* make sure that we are changing the text font name */
   if (GdiAttribHasChanged( GdiTxFont ))
   {
      Integer  newFont;

      /* call the routine to find a matching GDI font face name */
      newFont = FindGdiFont();

      /* fill in information from the font lookup table */
      gdiEnv.newLogFont.lfPitchAndFamily = fontTable[newFont].family | (Byte)DEFAULT_PITCH;

      /* copy the correct font character set */
      gdiEnv.newLogFont.lfCharSet = fontTable[newFont].charset;

      /* copy over the new font face name */
      lstrcpy( gdiEnv.newLogFont.lfFaceName, fontTable[newFont].gdiName );

      /* indicate that the pen size is current */
      GdiMarkAsCurrent( GdiTxFont );
   }

   /* make sure that we are changing the text attributes */
   if (GdiAttribHasChanged( GdiTxFace ))
   {
      /* note that attributes QDTxShadow, QDTxCondense, and QDTxExtend
         are not handled by GDI and will be removed permanently - SBT.
         Set italic, underline and bold attributes as needed */
      gdiEnv.newLogFont.lfItalic    = (Byte)(port->txFace & QDTxItalic);
      gdiEnv.newLogFont.lfUnderline = (Byte)(port->txFace & QDTxUnderline);
      gdiEnv.newLogFont.lfWeight    = (port->txFace & QDTxBold ) ?
                                       FW_BOLD : FW_NORMAL;

      /* indicate that the font attributes are current */
      GdiMarkAsCurrent( GdiTxFace );
   }

   /* check the new font size */
   if (GdiAttribHasChanged( GdiTxSize) || GdiAttribHasChanged( GdiTxRatio))
   {
      /* check for any text rescaling factor in vertical direction */
      if (port->txNumerator.y == port->txDenominator.y)
      {
         /* note that we negate the font size in order to specify the
            character height = cell height - internal leading */
         gdiEnv.newLogFont.lfHeight = -port->txSize;
      }
      else
      {
         Integer  txHeight;

         /* scale the font size by numerator/denominator - use LongInts to
            avoid possibility of overflowing Integer multiplication */
         txHeight = (Integer)(((LongInt)port->txSize *
                               (LongInt)port->txNumerator.y +
                               (LongInt)(port->txDenominator.y / 2)) /
                               (LongInt)port->txDenominator.y);

         gdiEnv.newLogFont.lfHeight = -txHeight;
      }

      /* indicate that the font size and scaling is current */
      GdiMarkAsCurrent( GdiTxSize );
      GdiMarkAsCurrent( GdiTxRatio );
   }

   /* call cache module to create the font and select it */
   CaCreateFontIndirect( &gdiEnv.newLogFont );

   /* everything a-ok */
   return TRUE;

}  /* SetTextAttributes */



private Integer FindGdiFont( void )
/*-------------------------*/
/* return an index to the current font selection */
{
   CGrafPortLPtr     port;
   Boolean           findName;
   Byte              i;

   /* check if the search is overridden by a font name comment */
   if (gdiEnv.useGdiFont)
   {
      /* return the table index that the name was copied into */
      return FntFromGdi;
   }

   /* Get the QuickDraw port in order to check font settings */
   QDGetPort( &port );

   /* see if lookup should be done on face name */
   findName = (port->txFontName[0] != cNULL);

   /* search through all font table entries to find a match */
   for (i = 0; i < FntNoMatch; i++)
   {
      /* if looking up the font name, compare the macName field */
      if (findName)
      {
         /* look for an exact string compare - equivalent strings */
         if (lstrcmpi( fontTable[i].macName, port->txFontName ) == 0)
         {
            break;
         }
      }
      else
      {
         /* otherwise, compare the font numbers */
         if (fontTable[i].fontNum == port->txFont)
         {
            break;
         }
      }
   }

   /* see if there was no match found in the table */
   if (i == FntNoMatch)
   {
      /* see if if we are comparing font names, and no match was found */
      if (findName)
      {
         /* copy the Mac name over into the font table */
         lstrcpy( fontTable[FntNoMatch].gdiName, port->txFontName );

         /* assign default values for the charSet and family if not found */
         fontTable[FntNoMatch].family  = FF_ROMAN;
         fontTable[FntNoMatch].charset = ANSI_CHARSET;

         /* call Windows to enumerate any fonts that have the facename */
#ifdef WIN32
         EnumFonts( gdiEnv.infoContext, port->txFontName, gdiEnv.fontFunction, ( LPARAM ) NULL );
#else
         EnumFonts( gdiEnv.infoContext, port->txFontName, gdiEnv.fontFunction, NULL );
#endif
         /* return the font index of the new entry */
         return FntNoMatch;
      }
      else
      {
         /* otherwise, use the default Helvetica font */
         return FntDefault;
      }
   }
   else
   {
      /* a match was found - return the table index */
      return i;
   }

}  /* FindGdiFont */



private void MacToAnsi( StringLPtr string )
/*--------------------*/
/* convert extended characters from Mac to ANSI equivalent */
{
   /* determine if there should be character translations on the chars */
   if (gdiEnv.newLogFont.lfCharSet == ANSI_CHARSET)
   {
      /* continue until we hit the NULL end of string marker */
      while (*string)
      {
         /* if translating an extended character */
         if ((Byte)*string >= (Byte)128)
         {
            /* perform character table lookup */
            *string = MacToAnsiTable[(Byte)*string - (Byte)128];
         }

         /* if we encounter a non-printable character, convert to space */
         if ((Byte)*string < (Byte)0x20)
         {
            *string = ' ';
         }

         /* increment the string pointer */
         string++;
      }
   }
}

#if( REMAPCOLORS )

private void RemapColors( PixMapLPtr pixMapLPtr, Handle pixDataHandle )
/*------------------*/
/* Remap colors for black and white in 16- or 256-color DIB */
{
   Byte              remapTable[256];
   Integer           blackIndex = 0;
   Integer           whiteIndex = 0;
   Integer           index;

   ColorTableLPtr    colorTabLPtr;
   Integer           numColors;
   RGBColor far *    curColorLPtr;

   /* lock the color table before copying over the color table */
   colorTabLPtr = (ColorTableLPtr)GlobalLock( pixMapLPtr->pmTable );

   /* set up the color entry pointers */
   curColorLPtr = colorTabLPtr->ctColors;

   /* determine number of colors in DIB */
   numColors = colorTabLPtr->ctSize;

   /* copy over all the color entries */
   for (index = 0; index < numColors; index++ )
   {
      /* copy color to local variable */
      RGBColor color = *curColorLPtr;

      /* is this the black entry? */
      if( color == RGB( 0, 0, 0 ) )
         blackIndex = index;
      if( color == RGB( 255, 255, 255 ) )
         whiteIndex = index;

      /* just copy over the current assignment to the remap table */
      remapTable[index] = (Byte)index;

      /* increment the pointers */
      curColorLPtr++;
   }

   if( blackIndex != 0 || whiteIndex != numColors - 1 )
   {
      if( whiteIndex == 0 )
      {
         // Direct swap of black and white colors.
         remapTable[0] = (Byte)blackIndex;
         remapTable[blackIndex] = (Byte)whiteIndex;

         // Remap the colors in the palette, also
         colorTabLPtr->ctColors[0] = colorTabLPtr->ctColors[blackIndex];
         colorTabLPtr->ctColors[blackIndex] = colorTabLPtr->ctColors[whiteIndex];
      }
      else
      {
         Boolean  doBlack;

         for (index = 1, doBlack = TRUE; index < numColors; index++)
         {
            if( whiteIndex != index && blackIndex != index )
            {
               if( doBlack )
               {
                  remapTable[index]      = (Byte)blackIndex;
                  remapTable[blackIndex] = (Byte)index;
                  doBlack = FALSE;
               }
               else
               {
                  remapTable[index]      = (Byte)whiteIndex;
                  remapTable[whiteIndex] = (Byte)index;
                  break;
               }
            }
         }
      }
   }

   /* unlock color table and free associated memory */
   GlobalUnlock( pixMapLPtr->pmTable );
}

#endif

private void MakeDIB( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                      Handle far * headerHandleLPtr,
                      Handle far * bitsHandleLPtr,
                      Boolean packDIB )
/*------------------*/
/* Create a Windows device-independant bitmap */
{
   Integer           pixelSize;
   LongInt           bitsInfoSize;
   Boolean           expandBits;
   Boolean           mergeRGB;
   Boolean           rleCompress;
   DWord             dibCompression;
   Integer           totalColors;
   DWord             dibWidth;
   DWord             dibHeight;
   DWord             totalBytes;
   Integer           rowBytes;
   Integer           bytesPerLine;
   DWord             rleByteCount;

   /* determine the bitcount which will yield the size of the color table */
   pixelSize = pixMapLPtr->pixelSize;

#if( REMAPCOLORS )
   /* if this is an 16 or 256 color DIB, we need to remap color indicies */
   if( pixelSize == 4 || pixelSize == 8 )
   {
      RemapColors( pixMapLPtr, pixDataHandle );
   }
#endif

   /* determine if RLE compression should be used in resulting DIB */
   /* Use RLE for 4- & 8-bits/pixel, but not if calling app said no RLE */
   if ((pixelSize == 4 || pixelSize == 8) && gdiPrefsLPtr->noRLE == 0)
   {
      /* use compression and set the correct bmiHeader compression */
      rleCompress = TRUE;
      dibCompression = (pixelSize == 4) ? BI_RLE4 : BI_RLE8;
   }
   else
   {
      /* no compression - the bytes are rgb palette indicies */
      rleCompress = FALSE;
      dibCompression = BI_RGB;
   }

   /* assume that no expansion will be required */
   expandBits = FALSE;

   /* round to 16-entry color table if this is a 4-entry pixel map  or
      to a 24-bit image if this is a 16-bit image */
   if (pixelSize == 2 || pixelSize == 16)
   {
      expandBits = TRUE;
      pixelSize = (pixelSize == 2) ? 4 : 24;
   }
   else if (pixelSize == 32)
   {
      /* change pixel size to 24 bits if this is a 32-bit pixMap */
      pixelSize = 24;
   }

   /* if not creating a 24-bit DIB ... */
   if (pixelSize <= 8)
   {
      /* calculate total number of colors used in resulting Windows DIB */
      totalColors = 1 << pixelSize;
   }
   else
   {
      /* otherwise, we don't allocate for color table */
      totalColors = 0;
   }

   /* calculate width and height - these are used frequently */
   dibWidth  = Width( pixMapLPtr->bounds );
   dibHeight = Height( pixMapLPtr->bounds );

   /* determine if the RGB components need to be merged in 24-bit image */
   mergeRGB = (pixMapLPtr->packType == 4);

   /* calculate the amount of memory required for header structure */
   bitsInfoSize = sizeof( BITMAPINFOHEADER ) + totalColors * sizeof( RGBQUAD );

   /* calculate the number of bytes per line - round to DWORD boundary */
   bytesPerLine = (Word)((dibWidth * (LongInt)pixelSize + 31) / 32) * 4;

   /* save off rowBytes size for later calculations */
   rowBytes = pixMapLPtr->rowBytes & RowBytesMask;

   /* calculate total amount of memory needed for bits */
   totalBytes = dibHeight * bytesPerLine;

   /* perform a pre-flight of compression to see if larger */
   if (rleCompress)
   {
      DWord       tempDibHeight = dibHeight;
      Byte huge * srcLineHPtr;

      /* lock source pixel bits, set pointer to last line in source bitmap */
      srcLineHPtr = (Byte huge *)GlobalLock( pixDataHandle );
      srcLineHPtr = srcLineHPtr + ((LongInt)rowBytes * ((LongInt)dibHeight - 1));

      /* initialize rle byte count */
      rleByteCount = 0;

      /* continue looping while bytes remain */
      while (tempDibHeight--)
      {
         /* if this is a 16 or 256 color DIB, then use RLE compression.
            The rleByteCount is incremented inside the routine */
         if (dibCompression == BI_RLE4)
         {
            hrlecpy16( srcLineHPtr, NULL, (Integer)dibWidth,
                       &rleByteCount, FALSE );
         }
         else
         {
            hrlecpy256( srcLineHPtr, NULL, (Integer)dibWidth,
                        &rleByteCount, FALSE );
         }

         /* move the source pointer */
         srcLineHPtr -= rowBytes;
      }

      /* add in the end of bitmap record - increment total bytes */
      rleByteCount += 2;

      /* unlock the source pixel map */
      GlobalUnlock( pixDataHandle );

      /* check if the compression results in smaller DIB */
      if (rleByteCount < totalBytes)
      {
         /* if smaller, adjust the total size to allocate */
         totalBytes = rleByteCount;

         /* re-initialize the byte count */
         rleByteCount = 0;
      }
      else
      {
         /* larger - adjust compression technique */
         rleCompress = FALSE;
         dibCompression = BI_RGB;
      }
   }

   /* if we are creating a packed DIB, then allocate only one data block */
   if (packDIB)
   {
      *headerHandleLPtr = GlobalAlloc( GHND, (bitsInfoSize + totalBytes) );
   }
   else
   {
      /* allocate separate handles for header and bits */
      *headerHandleLPtr = GlobalAlloc( GHND, bitsInfoSize );
      *bitsHandleLPtr   = GlobalAlloc( GHND, totalBytes );
   }

   /* check the results of the allocation for out-of-memory conditions */
   if (*headerHandleLPtr == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else if (!packDIB)
   {
      if (*bitsHandleLPtr == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
   }

   if (ErGetGlobalError() == NOERR)
   {
      BITMAPINFO far *  bitsInfoLPtr;
      Byte huge *       srcLineHPtr;
      Byte huge *       dstLineHPtr;

      /* lock the info header */
      bitsInfoLPtr = (BITMAPINFO far *)GlobalLock( *headerHandleLPtr );

      /* copy over all the header fields from the QuickDraw pixmap */
      bitsInfoLPtr->bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
      bitsInfoLPtr->bmiHeader.biWidth = dibWidth;
      bitsInfoLPtr->bmiHeader.biHeight = dibHeight;
      bitsInfoLPtr->bmiHeader.biPlanes = 1;
      bitsInfoLPtr->bmiHeader.biBitCount = (WORD) pixelSize;
      bitsInfoLPtr->bmiHeader.biCompression = dibCompression;
      bitsInfoLPtr->bmiHeader.biSizeImage = (rleCompress ? totalBytes : 0);
      bitsInfoLPtr->bmiHeader.biXPelsPerMeter = (DWord)(72 * 39.37);
      bitsInfoLPtr->bmiHeader.biYPelsPerMeter = (DWord)(72 * 39.37);
      bitsInfoLPtr->bmiHeader.biClrUsed = 0;
      bitsInfoLPtr->bmiHeader.biClrImportant = 0;

      /* make sure that there are colors to copy over */
      if (totalColors)
      {
         ColorTableLPtr    colorTabLPtr;
         Integer           numColors;
         RGBQUAD far *     curQuadLPtr;
         RGBColor far *    curColorLPtr;

         /* lock the color table before copying over the color table */
         colorTabLPtr = (ColorTableLPtr)GlobalLock( pixMapLPtr->pmTable );


         /* set up the color entry pointers */
         curColorLPtr = colorTabLPtr->ctColors;
         curQuadLPtr  = bitsInfoLPtr->bmiColors;

         /* copy over all the color entries */
         for (numColors = colorTabLPtr->ctSize; numColors; numColors-- )
         {
            RGBColor    color;

            /* copy color to local variable */
            color = *curColorLPtr;

            /* convert the color from COLORREF to RGBQUAD structure */
            curQuadLPtr->rgbRed   = GetRValue( color );
            curQuadLPtr->rgbGreen = GetGValue( color );
            curQuadLPtr->rgbBlue  = GetBValue( color );
            curQuadLPtr->rgbReserved = 0;

            /* increment the pointers */
            curQuadLPtr++;
            curColorLPtr++;
         }

         /* fill in any empty color entries */
         for (numColors = totalColors - colorTabLPtr->ctSize; numColors; numColors--)
         {
            /* put in a black color entry (unused) */
            curQuadLPtr->rgbRed   =
            curQuadLPtr->rgbGreen =
            curQuadLPtr->rgbBlue  =
            curQuadLPtr->rgbReserved = 0;

            /* increment the pointers */
            curQuadLPtr++;
         }

         /* unlock color table and free associated memory */
         GlobalUnlock( pixMapLPtr->pmTable );

         /* free the color table only if this isn't a pixel pattern */
         if (!packDIB)
         {
            GlobalFree( pixMapLPtr->pmTable );
         }
      }

      /* adjust for 24-bit images that have dropped high-order byte.  Make
         sure not to adjust for 16-bit images that will expand to 24-bit */
      if (pixelSize == 24 && !expandBits)
      {
         rowBytes = rowBytes * 3 / 4;
      }

      /* determine where the data should be placed for the bitmap */
      if (packDIB)
      {
         /* set the destination pointer to the end of the color table */
         dstLineHPtr = (Byte huge *)((Byte far *)bitsInfoLPtr) + bitsInfoSize;
      }
      else
      {
         /* lock the data block handle if creating a normal DIB */
         dstLineHPtr = (Byte huge *)GlobalLock( *bitsHandleLPtr );
      }

      /* lock source pixel bits, set pointer to last line in source bitmap */
      srcLineHPtr = (Byte huge *)GlobalLock( pixDataHandle );
      srcLineHPtr = srcLineHPtr + ((LongInt)rowBytes * ((LongInt)dibHeight - 1));

      /* continue looping while bytes remain */
      while (dibHeight--)
      {
         if (expandBits)
         {
            /* if expanding, expand each 2 bits to full nibble or if this
               is a 16-bit image, expand to 24 bits */
            hexpcpy( srcLineHPtr, dstLineHPtr, rowBytes, pixelSize );
         }
         else if (mergeRGB)
         {
            /* if the is a 24-bit image, then the components are separated
               into scanlines of red, green and blue.  Merge these into
               a single RGB component for the entire line */
            hmrgcpy( srcLineHPtr, dstLineHPtr, rowBytes / 3 );
         }
         else if (rleCompress)
         {
            /* if this is a 16 or 256 color DIB, then use RLE compression.
               The rleByteCount is incremented inside the routine */
            if (dibCompression == BI_RLE4)
            {
                hrlecpy16( srcLineHPtr, dstLineHPtr + rleByteCount,
                           (Integer)dibWidth, &rleByteCount, TRUE );
            }
            else
            {
                hrlecpy256( srcLineHPtr, dstLineHPtr + rleByteCount,
                            (Integer)dibWidth, &rleByteCount, TRUE );
            }
         }
         else
         {
            /* if no expansion required, then this is a simple copy */
            hmemcpy( srcLineHPtr, dstLineHPtr, rowBytes );
         }

         /* move the source pointer and destination if not compressed */
         srcLineHPtr -= rowBytes;
         if (!rleCompress)
         {
            dstLineHPtr += bytesPerLine;
         }
      }

      /* if RLE compression was used, modify size field in the bmiHeader */
      if (rleCompress)
      {
         /* add in the end of bitmap record - increment total bytes */
         dstLineHPtr[rleByteCount++] = 0;
         dstLineHPtr[rleByteCount++] = 1;
      }

      /* unlock the source pixel map */
      GlobalUnlock( pixDataHandle );

      /* unlock the destination header info handle */
      GlobalUnlock( *headerHandleLPtr );

      /* if this isn't packed, unlock the data pointer, also */
      if (!packDIB)
      {
         GlobalUnlock( *bitsHandleLPtr );
      }
   }

}  /* MakeDIB */



private Boolean MakeMask( Handle mask, Boolean patBlt)
/*----------------------*/
/* Create a mask that will be used in the ensuing StretchDIBits call.
   Return TRUE if region was created, FALSE if rectangular region */
{
   PixMap            pixMap;
   Integer far *     sizeLPtr;
   LongInt           bytesNeeded;
   Boolean           solidPatBlt;
   Word              mode;

   /* determine if a solid pattern blt is being rendered - this can be
      altered to render a "simple" StretchBlt that DOESN'T involve a brush */
   solidPatBlt = patBlt && (gdiEnv.newLogBrush.lbStyle == BS_SOLID);

   if (patBlt)
      mode = (solidPatBlt) ? QDSrcOr : -2;
   else
      mode = (Word) -1;

   /* Lock the region handle and retrieve the bounding box */
   sizeLPtr = (Integer far *)GlobalLock( mask );

   /* determine if we are just requesting a rectangular bitmap mask */
   if (*sizeLPtr == RgnHeaderSize)
   {
      Rect  clipRect;

      /* determine the appropriate clipping rectangle */
      clipRect = *((Rect far *)(sizeLPtr + 1));

      /* Call Gdi module to change the clipping rectangle */
      gdiEnv.drawingEnabled = CaIntersectClipRect( clipRect );

      /* just unlock the mask and return to the calling routine */
      GlobalUnlock( mask );

      /* indicate that no region mask was created */
      return FALSE;
   }

   /* determine bounding rectangle and rowBytes (rounded to word bondary) */
   pixMap.bounds = *((Rect far *)(sizeLPtr + 1));

   pixMap.rowBytes = ((Width( pixMap.bounds ) + 15) / 16) * sizeofMacWord;

   /* if this is a bitmap, then we assign the various fields.  */
   pixMap.pmVersion = 0;
   pixMap.packType = 0;
   pixMap.packSize = 0;
   pixMap.hRes = 0x00480000;
   pixMap.vRes = 0x00480000;
   pixMap.pixelType = 0;
   pixMap.pixelSize = 1;
   pixMap.cmpCount = 1;
   pixMap.cmpSize = 1;
   pixMap.planeBytes = 0;
   pixMap.pmTable = 0;
   pixMap.pmReserved = 0;

   /* calculate the number of bytes needed for the color table */
   bytesNeeded = sizeof( ColorTable ) + sizeof( RGBColor );

   /* allocate the data block */
   pixMap.pmTable = GlobalAlloc( GHND, bytesNeeded );

   /* make sure that the allocation was successfull */
   if (pixMap.pmTable == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
      
      /* Unlock the mask region */
      GlobalUnlock( mask );
      return FALSE;
   }
   else
   {
      ColorTable far *  colorHeaderLPtr;
      Handle            maskBitmap;

      /* lock the memory handle and prepare to assign color table */
      colorHeaderLPtr = (ColorTable far *)GlobalLock( pixMap.pmTable );

      /* 2 colors are present - black and white */
      colorHeaderLPtr->ctSize = 2;
      if (solidPatBlt)
      {
         colorHeaderLPtr->ctColors[0] = gdiEnv.newLogBrush.lbColor;
         colorHeaderLPtr->ctColors[1] = RGB( 255, 255, 255 );
      }
      else
      {
         colorHeaderLPtr->ctColors[0] = RGB( 255, 255, 255 );
         colorHeaderLPtr->ctColors[1] = RGB( 0, 0, 0 );
      }

      /* unlock the memory */
      GlobalUnlock( pixMap.pmTable );

      /* Create the correct bitmap from the mask region */
      bytesNeeded  = (LongInt)pixMap.rowBytes * (LongInt)(Height( pixMap.bounds ));

      /* allocate the memory */
      maskBitmap = GlobalAlloc( GHND, bytesNeeded );

      /* make sure the allocation succeeded */
      if (maskBitmap == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
      else
      {
         Integer far *     maskLPtr;
         Byte far *        rowLPtr;
         Integer           curRow;

         /* lock the memory for creation of the bitmap mask */
         rowLPtr = GlobalLock( maskBitmap );

         /* set the mask pointer to beginning of region information */
         maskLPtr = sizeLPtr + 5;

         /* loop until all rows have been traversed */
         for (curRow = pixMap.bounds.top;
              curRow < pixMap.bounds.bottom;
              curRow++, rowLPtr += pixMap.rowBytes)
         {
            /* if this is the first row being created ... */
            if (curRow == pixMap.bounds.top)
            {
               Integer     i;

               /* make all the bits the background color */
               for (i = 0; i < pixMap.rowBytes; i++)
                  *(rowLPtr + i) = (Byte)0xFF;
            }
            else
            {
               /* copy over the information from the previous row */
               hmemcpy( rowLPtr - pixMap.rowBytes, rowLPtr, pixMap.rowBytes );
            }

            /* determine if the desired mask line was reached */
            if (*maskLPtr == curRow)
            {
               Integer     start;
               Integer     end;

               /* increment the mask pointer to get to the start/end values */
               maskLPtr++;

               /* continue looping until end of line marker encountered */
               while (*maskLPtr != 0x7FFF)
               {
                  /* determine the start and end point of bits to invert */
                  start = *maskLPtr++;
                  end   = *maskLPtr++;

                  /* if reached, invert the desired bits in the mask */
                  InvertBits( rowLPtr, start - pixMap.bounds.left, end - start);
               }

               /* increment past the end of line flag */
               maskLPtr++;
            }
         }

         /* unlock the bitmap memory block */
         GlobalUnlock( maskBitmap );

         /* call the GdiStretchDIB() entry point to create the bitmap */
         GdiStretchDIBits( &pixMap, maskBitmap,
                           pixMap.bounds, pixMap.bounds,
                           mode, NULL );

      }

      /* Unlock the mask region */
      GlobalUnlock( mask );

      /* indicate that a mask was created */
      return TRUE;
   }

}  /* MakeMask */



void InvertBits( Byte far * byteLPtr, Integer start, Integer count )
/*-------------*/
/* invert all bits in byteLPtr from bit offset start for count bits */
{
   Byte        byteMask;
   Integer     partialCount;

   /* set the beginning byte index */
   byteLPtr += start / 8;

   /* determine the beginning mask offset = start % 8 */
   partialCount = start & 0x0007;

   /* set up the byte mask and decrement by number of bits processed */
   byteMask = (Byte)(0xFF >> partialCount);
   count -= 8 - partialCount;

   /* continue looping while bits remain ... */
   while (count >= 0)
   {
      /* invert all the mask bits */
      *byteLPtr++ ^= byteMask;

      /* set up the new byte mask - assume all bits will be set */
      byteMask = 0xFF;

      /* decrement the count */
      count -= 8;
   }

   /* if a bitmask stilll remains */
   if (count > -8 && count < 0)
   {
      /* the negative count indicates number of bits to be inverted */
      count = -count;

      /* shift right, then left to clear remaining bits */
      byteMask = (Byte)((byteMask >> count) << count);

      /* and XOR with current bits */
      *byteLPtr ^= byteMask;
   }

}  /* InvertBits */



void hmemcpy( Byte huge * src, Byte huge * dst, Integer count )
/*----------*/
/* copy count bytes from source to destination - assumes even count */
{
   short huge * wSrc = (short far *)src;
   short huge * wDst = (short far *)dst;
   Integer     wCount = count / sizeof ( short );

   /* while words remain, copy to destination from source */
   while (wCount--)
   {
      *wDst++ = *wSrc++;
   }

}  /* hmemcpy */



void hexpcpy( Byte huge * src, Byte huge * dst, Integer count, Integer bits )
/*----------*/
/* copy count bytes to destination, expand each 2 bits to nibble of if
   16-bit image, expand to 24 bits */
{
   /* check if expanding from 2 to 4 bits */
   if (bits == 4)
   {
      Byte  tempByte;
      Byte  result;

      /* while bytes remain, copy to destination from source */
      while (count--)
      {
         /* expand high nibble to full byte */
         tempByte = *src;
         result  = (Byte)((tempByte >> 2) & (Byte)0x30);
         result |= (Byte)((tempByte >> 6));
         *dst++  = result;

         /* expand low nibble to full byte */
         tempByte = *src++;
         result  = (Byte)((tempByte & (Byte)0x0C) << 2);
         result |= (Byte)((tempByte & (Byte)0x03));
         *dst++  = result;
      }
   }
   else /* if (bits == 24) */
   {
      Word  tempWord;

      /* while words remain, copy to destination from source */
      while (count)
      {
         /* read the next two bytes into a full word, swapping bytes */
         tempWord  = (Word)(*src++ << 8);
         tempWord |= (Word)(*src++);

         /* 2 full bytes were read - decrement */
         count -= 2;

         /* expand each 5 bits to full byte */
         *dst++ = (Byte)((tempWord & 0x001F) << 3);
         *dst++ = (Byte)((tempWord & 0x03E0) >> 2);
         *dst++ = (Byte)((tempWord & 0x7C00) >> 7);
      }
   }

}  /* hexpcpy */



void hmrgcpy( Byte huge * srcLineHPtr, Byte huge * dstLineHPtr, Integer dibWidth )
/*----------*/
/* if the is a 24-bit image, then the components are separated into scanlines
   of red, green and blue.  Merge into single scanline of 24-bit RGB pixels */
{
   Integer        component;
   Byte huge *    insert;
   Integer        offset;

   /* for each red, green, and blue component ... */
   for (component = 2; component >= 0; component--)
   {
      /* adjust the insertion point */
      insert = dstLineHPtr + component;

      /* for each component byte in the scanline ... */
      for (offset = 0; offset < dibWidth; offset++)
      {
         /* copy the component to the correct destination insertion point */
         *insert = *srcLineHPtr++;

         /* increment to the next insertion point */
         insert += 3;
      }
   }


}  /* hmrgcpy */


void hrlecpy256( Byte huge * srcHPtr, Byte huge * dstHPtr,
                 Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB )
/*----------*/
/* 256 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */
{
   DWord       rleCount;
   Integer     bytesLeft;
   Byte        compareByte;
   Byte        runLength;
   Byte huge * startRun;

   /* initialize rleCount */
   rleCount = 0;

   /* all bytes remain to be processed */
   bytesLeft = dibWidth;

   /* continue compressing until all bytes are processed */
   while (bytesLeft)
   {
      /* save off the start of the run length */
      startRun = srcHPtr;

      /* read the first byte from the scanline */
      compareByte = *srcHPtr++;
      bytesLeft--;

      /* initialize the runLength */
      runLength = 1;

      /* continue comparing bytes until no match results */
      while (bytesLeft && (compareByte == *srcHPtr) && (runLength < 0xFF))
      {
         /* if a match was made, increment runLength and source pointer */
         runLength++;
         srcHPtr++;
         bytesLeft--;
      }

      /* check if only two more bytes remain in scanline */
      if ((runLength == 1) && (bytesLeft == 1))
      {
         if (writeDIB)
         {
            /* in this case, we have reached then end of the line with 2
               non-repeating bytes - have to write out to runlengths of 1 */
            *dstHPtr++ = 1;
            *dstHPtr++ = compareByte;
            *dstHPtr++ = 1;
            *dstHPtr++ = *srcHPtr;
         }

         /* decrement the byte counter so that the main loop ends */
         bytesLeft--;

         /* byte count incremented by 4 bytes */
         rleCount += 4;
      }
      /* check if we have a run length of 3 or more - also check bytesLeft
         to make sure that we don't attempt to read past memory block */
      else if ((runLength == 1) && (bytesLeft > 2) &&
              (*srcHPtr != *(srcHPtr + 1)))
      {
         Boolean     oddCount;

         /* set the correct run length, and reset the source pointer */
         srcHPtr += 2;
         runLength = 3;
         bytesLeft -= 2;

         /* continue comparing until some bytes match up */
         while (bytesLeft && (runLength < 0xFF))
         {
            /* make sure we don't try to read past end of scanline &&
               compare to see if the bytes are the same */
            if ((bytesLeft == 1) || (*srcHPtr != *(srcHPtr + 1)))
            {
               /* we will run past the end of scanline, add the byte */
               /* if byte pair doesn't match, increment pointer and count */
               srcHPtr++;
               runLength++;
               bytesLeft--;
            }
            else
            {
               /* if not at scanline end, or bytes match, bail */
               break;
            }
         }

         /* determine if there is an odd number of bytes to move */
         oddCount = runLength & (Byte)0x01;

         /* increment to total RLE byte count */
         rleCount += 2 + runLength + (Byte)oddCount;

         if (writeDIB)
         {
            /* write out the number of unique bytes */
            *dstHPtr++ = 0;
            *dstHPtr++ = runLength;

            /* write out the individual bytes until runLength is exhausted */
            while (runLength--)
            {
               /* copy to the destination from the starting point */
               *dstHPtr++ = *startRun++;
            }

            /* add a null pad byte to align to word boundary */
            if (oddCount)
            {
               *dstHPtr++ = 0;
            }
         }
      }
      else
      {
         if (writeDIB)
         {
            /* successful run length found - write to destination */
            *dstHPtr++ = runLength;
            *dstHPtr++ = compareByte;
         }

         /* increment the byte count */
         rleCount += 2;
      }
   }

   if (writeDIB)
   {
      /* write out an end of line marker */
      *dstHPtr++ = 0;
      *dstHPtr   = 0;
   }

   /* increment total number of bytes */
   rleCount += 2;

   /* assign the value into the address provided */
   *rleByteCount += rleCount;

}  /* hrlecpy256 */




void hrlecpy16( Byte huge * srcHPtr, Byte huge * dstHPtr,
                Integer dibWidth, DWord far * rleByteCount, Boolean writeDIB )
/*----------*/
/* 16 color DIB RLE compression.  Provide source, destination pointers,
   bytes in scanline.  rleByteCount updated and write if writeDIB is TRUE */
{
   DWord       rleCount;
   Integer     pixelsLeft;
   Boolean     oddStart;
   Boolean     look4Same;
   Byte        compareByte;
   Byte        runLength;
   Byte huge * startRun;

   /* initialize rleCount */
   rleCount = 0;

   /* all pixels left to process */
   pixelsLeft = dibWidth;

   /* continue compressing until all pixels are processed */
   while (pixelsLeft)
   {
      /* save off the start of the run length */
      startRun = srcHPtr;
      oddStart = odd( pixelsLeft + dibWidth );

      /* assume that we are comparing for equality, right now */
      look4Same = TRUE;

      /* read the next set of 2 pixels from the scanline */
      if (oddStart)
      {
         /* odd offset: swap high and low pixels for byte-aligned compares */
         compareByte  = *srcHPtr++ & (Byte)0x0F;

         /* make sure we can access the next byte - count > 1 */
         if (pixelsLeft > 1)
         {
            compareByte |= *srcHPtr << 4;
         }
      }
      else
      {
         /* otherwise, just save off the next full byte */
         compareByte = *srcHPtr++;
      }

      /* check if we have 2 or less pixels remaining in the scanline */
      if (pixelsLeft <= 2)
      {
         /* if only one pixel left ... */
         if (pixelsLeft == 1)
         {
            /* zero out low-order nibble and set runLength */
            compareByte &= (Byte)0xF0;
            runLength = 1;
         }
         else
         {
            /* otherwize, just set the runLength */
            runLength = 2;
         }

         /* no more pixels left */
         pixelsLeft = 0;
      }
      /* otherwise, proceed with the normal comparison loop */
      else
      {
         /* we have runLength of 2 pixels, so far */
         runLength = 2;
         pixelsLeft -= 2;

         /* continue comparing bytes until no match results */
         do
         {
            /* if comparing for equality ... */
            if (look4Same)
            {
               Byte     match;

               /* XOR compare byte and the source pointer byte */
               match = compareByte ^ *srcHPtr;

               /* was there a full 2 pixel compare? */
               if (match == 0)
               {
                  /* is this the last pixel in the scanline, runlength
                     maximum reached, or nibbles swapped and begin of
                     pattern matching */
                  if ((pixelsLeft == 1) || (runLength + 1) == 0xFF ||
                      (oddStart && runLength == 2))
                  {
                     /* if this is the begin of pattern matching following an
                        odd start, then increment the source pointer */
                     if (oddStart && runLength == 2)
                     {
                        srcHPtr++;
                     }

                     /* only one pixel handled in this case */
                     runLength++;
                     pixelsLeft--;
                  }
                  else
                  {
                     /* otherwise, a full byte compared correctly - 2 nibbles */
                     runLength  += 2;
                     pixelsLeft -= 2;
                     srcHPtr++;
                  }
               }
               /* if no full byte compare, determine if patial match */
               else if ((runLength != 2) && ((match & (Byte)0xF0) == 0))
               {
                  /* only high-order nibble matched - increment counts */
                  runLength++;
                  pixelsLeft--;

                  /* exit the loop */
                  break;
               }
               else if (runLength == 2)
               {
                  /* no match on first compare - look for non-matches */
                  look4Same = FALSE;

                  /* increment source pointer - sets up byte alignment */
                  srcHPtr++;

                  /* setup for the runLength of differing pixels */
                  if (oddStart || (pixelsLeft == 1))
                  {
                     /* increment runLength and decrement pixels left */
                     runLength++;
                     pixelsLeft--;
                  }
                  else
                  {
                     /* there are at least 4 non-exact pixels in a row */
                     runLength = 4;
                     pixelsLeft -= 2;
                  }
               }
               else
               {
                  /* really the end of the line - exit main loop */
                  break;
               }
            }
            else  /* if (look4Same == FALSE) */
            {
               /* make sure we don't try to read past end of scanline */
               if ((pixelsLeft == 1) || ((runLength + 1) == 0xFF))
               {
                  /* if running past end, then add this single nibble */
                  pixelsLeft--;
                  runLength++;
               }
               /* compare the next two bytes */
               else if (pixelsLeft == 2 || (*srcHPtr != *(srcHPtr + 1)))
               {
                  /* if byte pair doesn't match, increment pointer and count */
                  srcHPtr++;
                  runLength  += 2;
                  pixelsLeft -= 2;
               }
               else
               {
                  /* if not at scanline end, or bytes match, bail */
                  break;
               }
            }

         /* continue while pixels are left and max runLength not exceeded */
         } while (pixelsLeft && (runLength < 0xFF));
      }

      /* check what the runLength consists of - same or different pixels */
      if (look4Same)
      {
         /* increment the rle compression count */
         rleCount += 2;

         if (writeDIB)
         {
            /* successful run length found - write to destination */
            *dstHPtr++ = runLength;
            *dstHPtr++ = compareByte;
         }
      }
      else  /* if (look4Same == FALSE) */
      {
         Boolean     oddCount;

         /* determine if there is an odd number of bytes to move */
         oddCount = (((runLength & (Byte)0x03) == 1) ||
                     ((runLength & (Byte)0x03) == 2));

         /* RLE byte count = 2 (setup) + word aligned BYTE count */
         rleCount += 2 + ((runLength + 1) / 2) + (Byte)oddCount;

         if (writeDIB)
         {
            /* write out the number of unique bytes */
            *dstHPtr++ = 0;
            *dstHPtr++ = runLength;

            /* write out the individual bytes until runLength is exhausted */
            while (runLength)
            {
               /* check if reading nibble at a time or byte */
               if (oddStart)
               {
                  /* have to read nibbles and create byte alignment */
                  *dstHPtr = (Byte)(*startRun++ << 4);
                  *dstHPtr++ |= (Byte)(*startRun >> 4);
               }
               else
               {
                  /* byte alignment already set up */
                  *dstHPtr++ = *startRun++;
               }

               /* check if this is the last byte written */
               if (runLength == 1)
               {
                  /* if so, zero low-order nibble and prepare for loop exit */
                  *(dstHPtr - 1) &= (Byte)0xF0;
                  runLength--;
               }
               else
               {
                  /* otherwise, 2 or more bytes remain, decrement counter */
                  runLength -= 2;
               }
            }

            /* add a null pad byte to align to word boundary */
            if (oddCount)
            {
               *dstHPtr++ = 0;
            }
         }
      }
   }

   /* increment total number of bytes */
   rleCount += 2;

   if (writeDIB)
   {
      /* write out an end of line marker */
      *dstHPtr++ = 0;
      *dstHPtr   = 0;
   }

   /* assign the value into the address provided */
   *rleByteCount += rleCount;

}  /* hrlecpy16 */



/****
 *
 * GdiEPSPreamble(PSBuf far* psbuf, Rect far *ps_bbox)
 * Parse the EPS bounding box and output the GDI PostScript preamble.
 * Assuming BBOX_LEFT, BBOX_TOP, BBOX_RIGHT and BBOX_BOTTOM are
 * the corners of the EPS bounding box parsed from the input string,
 * the GDI EPS preamble looks like:
 *
 *   POSTSCRIPT_DATA
 *      /pp_save save def ...
 *      /pp_bx1 ps_bbox->left def /pp_by1 ps_bbox->top def
 *      /pp_bx2 ps_bbox->right def /pp_by2 ps_bbox->bottom def
 *      ...
 *   POSTSCRIPT_IGNORE FALSE
 *   SaveDC
 *   CreateBrush NULL_BRUSH
 *   SelectObject
 *   CreatePen PS_SOLID 0 (255,255,254)
 *   SelectObject
 *   SetROP1(R2_NOP)
 *   Rectangle( qd_bbox )
 *   DeleteObject
 *   RestoreDC
 *   POSTSCRIPT_IGNORE TRUE
 *
 *   POSTSCRIPT_DATA
 *      pp_cx pp_cy moveto ...
 *      pp_tx pp_ty translate
 *      pp_sx pp_sy scale end
 *
 * The input buffer contains the length in bytes of the PostScript
 * data in the first word followed by the data itself.
 * The GDI clip region has already been set to the frame of the
 * PostScript image in QuickDraw coordinates.
 *
 ****/
static char gdi_ps1[] =
       "%%MSEPS Preamble %d %d %d %d %d %d %d %d\r/pp_save save def\r\
        /showpage {} def\r\
        40 dict begin /pp_clip false def /pp_bbox false def\r\
        /F { pop } def /S {} def\r\
        /B { { /pp_dy1 exch def /pp_dx1 exch def\r\
                   /pp_dy2 exch def /pp_dx2 exch def }\r\
                stopped not { /pp_bbox true def } if } def\r\
        /CB { { /pp_cy exch def /pp_cx exch def\r\
                    /pp_cht exch def /pp_cwd exch def }\r\
                stopped not { /pp_clip true def } if } def\n\
        /pp_bx1 %d def /pp_by1 %d def /pp_bx2 %d def /pp_by2 %d def\n";

static char gdi_ps2[] =
      "pp_clip\r\
        { pp_cx pp_cy moveto pp_cwd 0 rlineto 0 pp_cht rlineto\r\
          pp_cwd neg 0 rlineto clip newpath } if\r\
        pp_bbox {\r\
        /pp_dy2 pp_dy2 pp_dy1 add def\r\
        /pp_dx2 pp_dx2 pp_dx1 add def\r\
        /pp_sx pp_dx2 pp_dx1 sub pp_bx2 pp_bx1 sub div def\r\
        /pp_sy pp_dy2 pp_dy1 sub pp_by1 pp_by2 sub div def\r\
        /pp_tx pp_dx1 pp_sx pp_bx1 mul sub def\r\
        /pp_ty pp_dy1 pp_sy pp_by2 mul sub def\r\
        pp_tx pp_ty translate pp_sx pp_sy scale } if\r\
        end\r";

/*
 * Note: these structures must be kept compatible with
 * what the POSTSCRIPT_DATA Escape needs as input.
 */
static struct { Word length; char data[31]; } gdi_ps3 =
        { 31, "%MSEPS Trailer\rpp_save restore\r" };

void GdiEPSPreamble(Rect far* ps_bbox)
{
Word    false = 0;
Word    true = 1;
HPEN    pen;
Handle  h;
Word    len;
PSBuf far *tmpbuf;
Rect far *qd_bbox = &gdiEnv.clipRect;

   len = sizeof(gdi_ps1) + 100;                 // allow for expansion of %d
   len = max(len, sizeof(gdi_ps2));             // find longest string
   if ((h = GlobalAlloc(GHND, (DWORD) len + sizeof(PSBuf))) == 0)
     {
      ErSetGlobalError(ErMemoryFull);           // allocation error
      return;
     }
   tmpbuf = (PSBuf far *) GlobalLock(h);
   wsprintf(tmpbuf->data, (LPSTR) gdi_ps1,
                ps_bbox->left, ps_bbox->top, ps_bbox->right, ps_bbox->bottom,
                qd_bbox->left, qd_bbox->top, qd_bbox->right, qd_bbox->bottom,
                ps_bbox->left, ps_bbox->top, ps_bbox->right, ps_bbox->bottom);
   tmpbuf->length = lstrlen(tmpbuf->data);      // length of first string
   GdiEPSData(tmpbuf);                          // output begin preamble
   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &false);
   SaveDC(gdiEnv.metafile);                     // output GDI transform code
   SelectObject(gdiEnv.metafile, GetStockObject(NULL_BRUSH));
   pen = CreatePen(PS_SOLID, 0, RGB(255, 255, 254));
   // Bug 45991
   if (pen) 
   {
      SelectObject(gdiEnv.metafile, pen);
      SetROP2(gdiEnv.metafile, R2_NOP);
      Rectangle(gdiEnv.metafile, qd_bbox->left, qd_bbox->top,
		qd_bbox->right, qd_bbox->bottom);
      DeleteObject(pen);
   }
   else
   {
      ErSetGlobalError(ErMemoryFull);           // allocation error
   }
   RestoreDC(gdiEnv.metafile, -1);
   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &true);
   tmpbuf->length = sizeof(gdi_ps2) - 1;
   lstrcpy(tmpbuf->data, gdi_ps2);
   GdiEPSData(tmpbuf);                          // output transform preamble
   GlobalUnlock(h);                             // clean up
   GlobalFree(h);
}

void GdiEPSTrailer()
{
   Word  false = 0;

   GdiEscape(POSTSCRIPT_IGNORE, sizeof(WORD), (StringLPtr) &false);
   GdiEPSData((PSBuf far *) &gdi_ps3);
}

/****
 *
 * GdiEPSData(PSBuf far* psbuf)
 * Output PostScript data to GDI as POSTSCRIPT_DATA Escape
 *
 * notes:
 * Currently, this routine does not do any buffering. It just outputs
 * a separate POSTSCRIPT_DATA Escape each time it is called.
 *
 ****/
void GdiEPSData(PSBuf far* psbuf)
{
   GdiEscape(POSTSCRIPT_DATA, psbuf->length + sizeof(WORD), (StringLPtr) psbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\getdata.h ===
/****************************************************************************
                       Unit GetData; Interface
*****************************************************************************

 GetData implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.  It will also perform some data validation and
 perform limited coordinate transformations on the input data.

   Module Prefix: Get

*****************************************************************************/

/*********************** Exported Function Definitions **********************/

#define /* void */ GetByte( /* Byte far * */ byteLPtr )           \
/* Retrieves an 8-bit unsigned byte from the input stream */      \
IOGetByte( byteLPtr )


void GetWord( Word far * wordLPtr );
/* Clears destination then retrieves an 16-bit unsigned integer from the input 
   stream */


void GetDWord( DWord far * dwordLPtr );
/* Retrieves a 32-bit unsigned long from the input stream */


void GetBoolean( Boolean far * bool );
/* Retrieves an 8-bit Mac boolean and coverts to 16-bit Windows Boolean */


#define /* void */ GetFixed( /* Fixed far * */ fixedLPtr )        \
/* Retrieved a fixed point number consisting of 16-bit whole      \
   and 16-bit fraction */                                         \
GetDWord( (DWord far *)fixedLPtr )

/* Retrieves POINT structure without coordinate transforms */  
#ifdef WIN32
void GetPoint( Point * pointLPtr );
#else
#define /* void */ GetPoint( /* Point far * */ pointLPtr )        \
/* Retrieves POINT structure without coordinate transforms */     \
GetDWord( (DWord far *)pointLPtr )
#endif

#ifdef WIN32
void GetCoordinate( Point * pointLPtr );
#else
#define /* void */ GetCoordinate( /* Point far * */ pointLPtr )   \
/* Retrieves POINT structure without coordinte transforms */      \
GetDWord( (DWord far *)pointLPtr )
#endif


void GetRect( Rect far * rect);
/* Returns a RECT structure consisting of upper left and lower right
   coordinate pair */


void GetString( StringLPtr stringLPtr );
/* Retrieves a Pascal-style string and formats it C-style.  If the input
   parameter is NIL, then the ensuing data is simply skipped */


void GetRGBColor( RGBColor far * rgbLPtr );
/* Returns an RGB color */


void GetOctochromeColor( RGBColor far * rgbLPtr );
/* Returns an RGB color - this will be converted from a PICT octochrome
   color if this is a version 1 picture */


Boolean GetPolygon( Handle far * polyHandleLPtr, Boolean check4Same );
/* Retrieves a polygon definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated.
   If check4Same is TRUE, then the routine will compare the point list
   against the previous polygon definition, checking for equality.  If
   pointlists match, then the routine returns TRUE, otherwise, it will
   always return FALSE.  Use this to merge fill and frame operations. */


void GetRegion( Handle far * rgnHandleLPtr );
/* Retrieves a region definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated. */

   
void GetPattern( Pattern far * patLPtr );
/* Returns a Pattern structure */


void GetColorTable( Handle far * colorHandleLPtr );


void GetPixPattern( PixPatLPtr pixPatLPtr );
/* Retrieves a Pixel Pattern structure. */


void GetPixMap( PixMapLPtr pixMapLPtr, Boolean forcePixMap );
/* Retrieves a Pixel Map from input stream */


void GetPixData( PixMapLPtr pixMapLPtr, Handle far * pixDataHandle );
/* Read a pixel map from the data stream */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\getdata.c ===
/****************************************************************************
                       Unit GetData; Implementation
*****************************************************************************

 GetData implements the structured reading of the imput stream.  As such, it
 will handle the necessary byte-swapping that must occur when reading a
 native Macintosh file.

   Module Prefix: Get

****************************************************************************/

#include "headers.c"
#pragma hdrstop

#include  <math.h>         /* for abs() function */

#include  "getdata.h"      /* own module interface */

/*********************** Exported Data **************************************/


/*********************** Private Data ***************************************/

/*--- octochrome color tables --- */

#define  blackColor     33
#define  whiteColor     30
#define  redColor       205
#define  greenColor     341
#define  blueColor      409
#define  cyanColor      273
#define  magentaColor   137
#define  yellowColor    69

typedef struct
{
   LongInt     octochromeColor;
   RGBColor    rgbColor;
} colorEntry, * colorEntryPtr;

private  colorEntry octochromeLookup[8] =
{
   { blackColor,   RGB( 0x00, 0x00, 0x00 ) },
   { whiteColor,   RGB( 0xFF, 0xFF, 0xFF ) },
   { redColor,     RGB( 0xDD, 0x08, 0x06 ) },
   { greenColor,   RGB( 0x00, 0x80, 0x11 ) },
   { blueColor,    RGB( 0x00, 0x00, 0xD4 ) },
   { cyanColor,    RGB( 0x02, 0xAB, 0xEA ) },
   { magentaColor, RGB( 0xF2, 0x08, 0x84 ) },
   { yellowColor,  RGB( 0xFC, 0xF3, 0x05 ) }
};

/*********************** Private Function Definitions ***********************/


/*********************** Function Implementation ****************************/


void GetWord( Word far * wordLPtr )
/*==========*/
/* Retrieves an 16-bit unsigned integer from the input stream */
{
   Byte far * byteLPtr = (Byte far *)wordLPtr;

   /* this initialization should be here for win32 */
   *wordLPtr = 0;

   /* Assign high-order byte first, followed by low-order byte. */
   GetByte( byteLPtr + 1);
   GetByte( byteLPtr );
}  /* GetWord */


void GetDWord( DWord far * dwordLPtr )
/*===========*/
/* Retrieves a 32-bit unsigned long from the input stream */
{
   Byte far * byteLPtr = (Byte far *)dwordLPtr;

   * dwordLPtr = 0;
   GetByte( byteLPtr + 3);
   GetByte( byteLPtr + 2);
   GetByte( byteLPtr + 1);
   GetByte( byteLPtr );
}  /* GetDWord */

#ifdef WIN32
void GetPoint( Point * pointLPtr )
/*===========*/
/* Retrieves 2 2-byte words from the input stream and assign them
   to a POINT structure */
{
   Word * wordLPtr = (Word *)pointLPtr;

   GetWord( wordLPtr + 1 );
   // This is done to extend the sign bit
   *( wordLPtr + 1 ) = (short)(*( wordLPtr + 1 ));

   GetWord( wordLPtr );
   *( wordLPtr     ) = (short)(*( wordLPtr     ));
}  /* GetPoint */
#endif

#ifdef WIN32
void GetCoordinate( Point * pointLPtr )
/*===========*/
/* Retrieves 2 2-byte words from the input stream and assign them
   to a POINT structure. Currently, there is no difference between
   this function and GetPoint. GetCoordinate is provided to provide for
   future modifications. */
{
   Word * wordLPtr = (Word *)pointLPtr;

   GetWord( wordLPtr + 1 );
   // This is done to extend the sign bit
   *( wordLPtr + 1 ) = (short)(*( wordLPtr + 1 ));

   GetWord( wordLPtr );
   *( wordLPtr     ) = (short)(*( wordLPtr     ));
}  /* GetCoordinate */
#endif

void GetBoolean( Boolean far * bool )
/*=============*/
/* Retrieves an 8-bit Mac boolean and coverts to 16-bit Windows Boolean */
{
   /* make sure that the high-order byte is zeroed out */
   *bool = 0;

   /* read low-order byte */
   GetByte( (Byte far *)bool );

}  /* GetBoolean */


void GetRect( Rect far * rect)
/*==========*/
/* Returns a RECT structure consisting of upper left and lower right
   coordinate pair */
{
   Integer     temp;
   Point far * pointLPtr = (Point far *)rect;

   /* Get the bounding coordinates */
   GetCoordinate( pointLPtr++ );
   GetCoordinate( pointLPtr );

   /* Make sure that the rectangle coords are upper-left and lower-right */
   if (rect->left > rect->right)
   {
      temp = rect->right;
      rect->right = rect->left;
      rect->left = temp;
   }

   if (rect->top > rect->bottom)
   {
      temp = rect->bottom;
      rect->bottom = rect->top;
      rect->top = temp;
   }

}  /* GetRect */


void GetString( StringLPtr stringLPtr )
/*============*/
/* Retrieves a Pascal-style string and formats it C-style.  If the input
   parameter is NIL, then the ensuing data is simply skipped */
{
   Byte           dataLen;
   Byte           unusedByte;
   Byte           increment;
   StringLPtr     destLPtr;

   /* Determine if we should be savin the text string or whether it simply
      ends up in the bit bucket. Set the correct destination pointer and
      increment value. */
   if (stringLPtr == NIL)
   {
      destLPtr = &unusedByte;
      increment = 0;
   }
   else
   {
      destLPtr = stringLPtr;
      increment = 1;
   }

   /* Determine exactly how many bytes should be read. */
   GetByte( &dataLen );

   /* continue reading bytes as determined by length. */
   while (dataLen--)
   {
      GetByte( destLPtr );
      destLPtr += increment;
   }

   /* terminate string with NUL byte */
   *destLPtr = 0;

}  /* GetString */


void GetRGBColor( RGBColor far * rgbLPtr )
/*==============*/
/* Returns an RGB color */
{
   Word     red;
   Word     green;
   Word     blue;

   /* read successive components from the stream */
   GetWord( &red );
   GetWord( &green );
   GetWord( &blue );

   /* use RGB macro to create an RGBColor */
   *rgbLPtr = RGB( red>>8, green>>8 , blue>>8 );

}  /* GetRGBColor */


void GetOctochromeColor( RGBColor far * rgbLPtr )
/*=====================*/
/* Returns an RGB color - this will be converted from a PICT octochrome
   color if this is a version 1 picture */
{
   LongInt        color;
   colorEntryPtr  entry;

   /* read in the LongInt octochrome color from the I/O stream */
   GetDWord( &color );

   /* search through the table, looking for the matching entry */
   entry = octochromeLookup;
   while (entry->octochromeColor != color)
   {
      entry++;
   }
   *rgbLPtr = entry->rgbColor;
}


Boolean GetPolygon( Handle far * polyHandleLPtr, Boolean check4Same )
/*================*/
/* Retrieves a polygon definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated.
   If check4Same is TRUE, then the routine will compare the point list
   against the previous polygon definition, checking for equality.  If
   pointlists match, then the routine returns TRUE, otherwise, it will
   always return FALSE.  Use this to merge fill and frame operations. */
{
   Handle      newPolyH;
   Word        polySize;
   Word  far * polySizeLPtr;
   Point far * polyPointsLPtr;
   Boolean     sameCoordinates;

   /* the polygon coordinates are assumed to be different */
   sameCoordinates = FALSE;

   /* determine how large the polygon buffer should be. */
   GetWord( &polySize );

   /* allocate the necessary size for the polygon. */
#ifdef WIN32
   {
      DWord dwSizeToAllocate;
      Word  uNumPoints;

      uNumPoints = (polySize - sizeofMacWord) / sizeofMacPoint;
      // a Word is needed to store polySize then POINT * uNumPoints
      dwSizeToAllocate = sizeof( Word ) +
          ( uNumPoints * sizeof ( Point ));

      newPolyH = GlobalAlloc( GHND, (DWord)dwSizeToAllocate );
   }
#else
   newPolyH = GlobalAlloc( GHND, (DWord)polySize );
#endif

   /* check to make sure that the allocation succeeded. */
   if (newPolyH == NIL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      Boolean     check4Closure;
      Point far * firstPtLPtr;

      /* Lock the memory handle and make sure it succeeds */
      polySizeLPtr = (Word far *)GlobalLock( newPolyH );

      /* save the size parameter and adjust the counter variables */
      *polySizeLPtr = polySize;
      polySize -= ( sizeofMacWord );
      polyPointsLPtr = (Point far *)(polySizeLPtr + 1);

      /* determine if we should check adjust first point to match last
         point if they are within 1 metafile unit of oneanother. */
      check4Closure = (polySize / sizeofMacPoint >= 6);
      firstPtLPtr = polyPointsLPtr + 2;

      /* continue reading points until the buffer is completely filled. */
      while (polySize)
      {
         GetCoordinate( polyPointsLPtr++ );
         polySize -= sizeofMacPoint;
      }

      /* should we check adjust for start, end points off by 1 unit? */
      if (check4Closure)
      {
         Point    first;
         Point    last;

         /* get the first and last points */
         first = *firstPtLPtr;
         last = *(--polyPointsLPtr);

         /* compare x and y components - see if delta in x or y < 1 */
         if ((abs( first.x - last.x ) <= 1) &&
             (abs( first.y - last.y ) <= 1))
         {
            /* if small delta, set last point equal to first point */
            *polyPointsLPtr = first;
         }
      }

      /* find out if the first and last point are within one metafile unit
         of oneanother - close the polygon in this case */


      /* determine if we should check against previous coordinates */
      if (*polyHandleLPtr != NIL && check4Same)
      {
         Word  far * checkSizeLPtr;
         DWord far * checkDWordLPtr;
         DWord far * polyDWordLPtr;

         /* go back and see if the same set of coordinates was specified -
            first check to see if the sizes are the same */
         checkSizeLPtr = (Word far *)GlobalLock( *polyHandleLPtr );
         if (*checkSizeLPtr == *polySizeLPtr)
         {
            /* reset the coordinate pointers to beginning of lists */
            polyDWordLPtr = (DWord far *)(polySizeLPtr + 1);
            checkDWordLPtr= (DWord far *)(checkSizeLPtr + 1);
            polySize = *checkSizeLPtr - sizeofMacWord;

            /* assume at this point that they are the same pointList */
            sameCoordinates = TRUE;

            /* continue check for equality until pointlist is exhausted */
            while (polySize)
            {
               /* compare the two coordinate pairs */
               if (*polyDWordLPtr++ != *checkDWordLPtr++)
               {
                  /* if one of the coordinates mis-compares, bail */
                  sameCoordinates = FALSE;
                  break;
               }
               else
               {
                  /* otherwise, decrement the count and continue */
                  polySize -= sizeofMacDWord;
               }
            }
         }

         /* unlock the previous polygon handle */
         GlobalUnlock( *polyHandleLPtr );
      }

      /* unlock the handle before returning */
      GlobalUnlock( newPolyH );
   }

   /* de-allocate the previous handle before continuing */
   if (*polyHandleLPtr != NIL)
   {
      GlobalFree( *polyHandleLPtr );
   }

   /* assign the new polygon handle */
   *polyHandleLPtr = newPolyH;

   /* return whether coordinates were same or not */
   return sameCoordinates;

}  /* GetPolygon */


void GetRegion( Handle far * rgnHandleLPtr )
/*=============*/
/* Retrieves a region definition from the I/O stream and places in the
   Handle passed down.  If the handle is previously != NIL, then the
   previous data is de-allocated. */
{
   Word        rgnSize;
   Word far *  rgnDataLPtr;
   Word far *  rgnSizeLPtr;

   /* de-allocate the previous handle before continuing */
   if (*rgnHandleLPtr != NIL)
   {
      GlobalFree( *rgnHandleLPtr );
   }

   // buffer should have enough room for a RECT and a series of Word's
   /* determine how large the region buffer should be. */
   GetWord( &rgnSize );

#ifdef WIN32
   /* allocate the necessary size for the region. */
   {
      Word uSizeToAllocate;

      uSizeToAllocate = (((rgnSize - sizeofMacRect) / sizeofMacWord)
          * sizeof ( Word ))
         + sizeof ( RECT );

      *rgnHandleLPtr = GlobalAlloc( GHND, (DWord)uSizeToAllocate );
   }
#else
   /* allocate the necessary size for the polygon. */
   *rgnHandleLPtr = GlobalAlloc( GHND, (DWord)rgnSize );
#endif

   /* check to make sure that the allocation succeeded. */
   if (*rgnHandleLPtr == NIL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* Lock the memory handle and make sure it succeeds */
      rgnSizeLPtr = (Word far *)GlobalLock( *rgnHandleLPtr );
      if (rgnSizeLPtr == NIL)
      {
         ErSetGlobalError( ErMemoryFail );
         GlobalFree( *rgnHandleLPtr );
      }
      else
      {
         /* save the size parameter and adjust the counter variables */
         *rgnSizeLPtr++ = rgnSize;
         rgnSize -= sizeofMacWord;
         rgnDataLPtr = (Word far *)rgnSizeLPtr;

         /* read out the bounding box */
         GetRect( (Rect far *)rgnDataLPtr );
         rgnDataLPtr += sizeofMacRect / sizeofMacWord;
         rgnSize -= sizeofMacRect;

         /* continue reading Data until the buffer is completely filled. */
         while (rgnSize)
         {
            /* read the next value from the source file */
            GetWord( rgnDataLPtr++ );
            rgnSize -= sizeofMacWord;
         }

         /* unlock the handle before returning */
         GlobalUnlock( *rgnHandleLPtr );
      }
   }

}  /* GetRegion */


void GetPattern( Pattern far * patLPtr )
/*=============*/
/* Returns a Pattern structure */
{
   Byte        i;
   Byte far *  byteLPtr = (Byte far *)patLPtr;

   for (i = 0; i < sizeof( Pattern); i++)
   {
      GetByte( byteLPtr++ );
   }

}  /* GetPattern */



void GetColorTable( Handle far * colorHandleLPtr )
/*================*/
{
   ColorTable        cTab;
   LongInt           bytesNeeded;
   ColorTable far *  colorHeaderLPtr;
   RGBColor far *    colorEntryLPtr;

   /* read in the header information */
   GetDWord( (DWord far *)&cTab.ctSeed );
   GetWord( (Word far *)&cTab.ctFlags );
   GetWord( (Word far *)&cTab.ctSize );

   /* calculate the number of bytes needed for the color table */
   bytesNeeded = sizeof( ColorTable ) + cTab.ctSize * sizeof( RGBColor );

   /* adjust the size of the color table size by 1 */
   cTab.ctSize++;

   /* allocate the data block */
   *colorHandleLPtr = GlobalAlloc( GHND, bytesNeeded );

   /* flag global error if memory is not available */
   if (*colorHandleLPtr == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      /* lock the memory */
      colorHeaderLPtr = (ColorTable far *)GlobalLock( *colorHandleLPtr );

      /* copy over the color handle header */
      *colorHeaderLPtr = cTab;

      /* convert the pointer to a RGBQUAD pointer */
      colorEntryLPtr = (RGBColor far *)colorHeaderLPtr->ctColors;

      /* read in the color table entries */
      while (cTab.ctSize--)
      {
         Word        unusedValue;

         /* read the value field */
         GetWord( &unusedValue );

         /* read the ensuing RGB color */
         GetRGBColor( colorEntryLPtr++ );
      }

      /* Unlock the data once finished */
      GlobalUnlock( *colorHandleLPtr );
   }

}  /* GetColorTable */



void GetPixPattern( PixPatLPtr pixPatLPtr )
/*================*/
/* Retrieves a Pixel Pattern structure. */
{
   /* release the memory from the patData field before continuing */
   if (pixPatLPtr->patData != NULL)
   {
      GlobalFree( pixPatLPtr->patMap.pmTable );
      GlobalFree( pixPatLPtr->patData );
      pixPatLPtr->patData = NULL;
   }

   /* read the pattern type to determine how the data is organized */
   GetWord( &pixPatLPtr->patType );
   GetPattern( &pixPatLPtr->pat1Data );

   /* read the additional data depending on the pattern type */
   if (pixPatLPtr->patType == QDDitherPat)
   {
      /* if this is a rare dither pattern, save off the desired color */
      GetRGBColor( &pixPatLPtr->patMap.pmReserved );
   }
   else /* (patType == newPat) */
   {
      /* read in the pixMap header and create a pixmap bitmap */
      GetPixMap( &pixPatLPtr->patMap, TRUE );
      GetColorTable( &pixPatLPtr->patMap.pmTable );
      GetPixData( &pixPatLPtr->patMap, &pixPatLPtr->patData );
   }

}  /* GetPixPattern */



void GetPixMap( PixMapLPtr pixMapLPtr, Boolean forcePixMap )
/*============*/
/* Retrieves a Pixel Map from input stream */
{
   Boolean     readPixelMap;

   /* Read the rowBytes number and check the high-order bit.  If set, it
      is a pixel map containing multiple bits per pixel; if not, it is
      a bitmap containing one bit per pixel */
   GetWord( (Word far *)&pixMapLPtr->rowBytes );
   readPixelMap = forcePixMap || ((pixMapLPtr->rowBytes & PixelMapBit) != 0);

   /* read the bitmap's bounding rectangle */
   GetRect( (Rect far *)&pixMapLPtr->bounds );

   if (readPixelMap)
   {
      /* read the different data fields into the record structure */
      GetWord(   (Word far *)&pixMapLPtr->pmVersion );
      GetWord(   (Word far *)&pixMapLPtr->packType );
      GetDWord( (DWord far *)&pixMapLPtr->packSize );
      GetFixed( (Fixed far *)&pixMapLPtr->hRes );
      GetFixed( (Fixed far *)&pixMapLPtr->vRes );
      GetWord(   (Word far *)&pixMapLPtr->pixelType );
      GetWord(   (Word far *)&pixMapLPtr->pixelSize );
      GetWord(   (Word far *)&pixMapLPtr->cmpCount );
      GetWord(   (Word far *)&pixMapLPtr->cmpSize );
      GetDWord( (DWord far *)&pixMapLPtr->planeBytes );
      GetDWord( (DWord far *)&pixMapLPtr->pmTable );
      GetDWord( (DWord far *)&pixMapLPtr->pmReserved );
   }
   else
   {
      LongInt           bytesNeeded;
      ColorTable far *  colorHeaderLPtr;

      /* if this is a bitmap, then we assign the various fields.  */
      pixMapLPtr->pmVersion = 0;
      pixMapLPtr->packType = 0;
      pixMapLPtr->packSize = 0;
      pixMapLPtr->hRes = 0x00480000;
      pixMapLPtr->vRes = 0x00480000;
      pixMapLPtr->pixelType = 0;
      pixMapLPtr->pixelSize = 1;
      pixMapLPtr->cmpCount = 1;
      pixMapLPtr->cmpSize = 1;
      pixMapLPtr->planeBytes = 0;
      pixMapLPtr->pmTable = 0;
      pixMapLPtr->pmReserved = 0;

      /* calculate the number of bytes needed for the color table */
      bytesNeeded = sizeof( ColorTable ) + sizeof( RGBColor );

      /* allocate the data block */
      pixMapLPtr->pmTable = GlobalAlloc( GHND, bytesNeeded );

      /* make sure that the allocation was successfull */
      if (pixMapLPtr->pmTable == NULL)
      {
         ErSetGlobalError( ErMemoryFull );
      }
      else
      {
         CGrafPortLPtr     port;

         /* Get the QuickDraw port for foreground and bkground colors */
         QDGetPort( &port );

         /* lock the memory handle and prepare to assign color table */
         colorHeaderLPtr = (ColorTable far *)GlobalLock( pixMapLPtr->pmTable );

         /* 2 colors are present - black and white */
         colorHeaderLPtr->ctSize = 2;
         colorHeaderLPtr->ctColors[0] = port->rgbFgColor;
         colorHeaderLPtr->ctColors[1] = port->rgbBkColor;

         /* unlock the memory */
         GlobalUnlock( pixMapLPtr->pmTable );
      }
   }

}  /* GetPixMap */



void GetPixData( PixMapLPtr pixMapLPtr, Handle far * pixDataHandle )
/*=============*/
/* Read a pixel map from the data stream */
{
   Integer        rowBytes;
   Integer        linesToRead;
   LongInt        bitmapBytes;
   Integer        bytesPerLine;

   /* determine the number of lines in the pixel map */
   linesToRead = Height( pixMapLPtr->bounds );

   /* make sure to turn off high-order bit - used to signify pixel map */
   rowBytes = pixMapLPtr->rowBytes & RowBytesMask;

   /* determine number of bytes to read for each line */
   if (pixMapLPtr->pixelSize <= 16)
   {
      /* use the masked rowBytes value (adjusted for pixel maps) */
      bytesPerLine = rowBytes;
   }
   else  /* if (pixMapLPtr->pixelSize == 24) */
   {
      /* adjust for 32-bit pixel images that don't contain high-order byte */
      bytesPerLine = rowBytes * 3 / 4;
   }

   /* calculate the size of the bitmap that will be created */
   bitmapBytes = (LongInt)linesToRead * (LongInt)bytesPerLine;

   /* allocate the necessary memory */
   *pixDataHandle = GlobalAlloc( GHND, bitmapBytes );

   /* flag global error if memory is not available */
   if (*pixDataHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull );
   }
   else
   {
      Boolean        compressed;
      Boolean        invertBits;
      Boolean        doubleByte;
      Byte huge *    rowHPtr;
      Byte huge *    insertHPtr;

      /* lock the memory handle and get a pointer to the first byte */
      rowHPtr = (Byte huge *)GlobalLock( *pixDataHandle );

      /* determine if the bitmap is compressed or not */
      compressed = !((rowBytes < 8)  ||
                     (pixMapLPtr->packType == 1) ||
                     (pixMapLPtr->packType == 2));

      /* determine if we should read 2 bytes at a time (16-bit pixelmap) */
      doubleByte = (pixMapLPtr->packType == 3);

      /* determine if bits should be inverted (monochrome bitmap) */
      /* must test for high bit of Mac word set, sign is not propagated
    when a Mac word is read into a 32-bit Windows int */
      invertBits = ((short)pixMapLPtr->rowBytes > 0 );

      /* decompress the bitmap into the global memory block */
      while (linesToRead-- && (ErGetGlobalError() == NOERR))
      {
         Integer        runLength;
         Integer        bytesRead;
         Integer        bytesToSkip;

         /* see if we need to read the scanline runlength */
         if (compressed)
         {
            /* get the run length - depends on the rowbytes field */
            if (rowBytes > 250)
            {
               GetWord( (Word far *)&runLength );
            }
            else
            {
               runLength = 0;
               GetByte( (Byte far *)&runLength );
            }
         }
         else
         {
            /* if not compressed, runLength is equal to rowBytes */
            runLength = bytesPerLine;
         }

         /* set the next insertion point to the beginning of the scan line */
         insertHPtr = rowHPtr;

         /* if this is a 24-bit image that contains 32-bits of information,
            then we must skip the high-order byte component.  This byte was
            originally spec'ed by Apple as a luminosity component, but is
            unused in Windows 24-bit DIBs. */
         bytesToSkip = (pixMapLPtr->cmpCount == 4) ? (rowBytes / 4) : 0;

         /* continue decompressing until run-length is exhausted */
         for (bytesRead = 0; bytesRead < runLength;  )
         {
            SignedByte     tempRepeatCount = 0;
            Integer        repeatCount;

            /* check on how the data should be read */
            if (compressed)
            {
               /* if compressed, get the repeat count byte */
              GetByte( (Byte far *)&tempRepeatCount );
              bytesRead++;
            }
            else
            {
               /* if no compression, fake the count of bytes to follow */
               tempRepeatCount = 0;
            }

            /* make sure that we didn't read a byte used to word-align */
            if (bytesRead == runLength)
            {
               /* this should force the read loop to be exited */
               continue;
            }

            /* if less than 0, indicates repeat count of following byte */
            if (tempRepeatCount < 0)
            {
               /* check for a flag-counter value of -128 (0x80) - QuickDraw
                  will never create this, but another application that packs
                  bits may.  As noted in the January 1992 release of TechNote
                  #171, we need to ignore this value and use the next byte
                  as the flag-counter byte. */
               if (tempRepeatCount != -128)
               {
                  Byte        repeatByte1;
                  Byte        repeatByte2;

                  /* calculate the repeat count and retrieve repeat byte */
                  repeatCount = 1 - (Integer)tempRepeatCount;
                  GetByte( &repeatByte1 );

                  /* increment the number of bytes read */
                  bytesRead++;

                  /* check for special handling cases */
                  if (invertBits)
                  {
                     /* if this is a monochrome bitmap, then invert bits */
                     repeatByte1 ^= (Byte)0xFF;
                  }
                  else if (doubleByte)
                  {
                     /* 16-bit images (pixel chunks) - read second byte */
                     GetByte( &repeatByte2 );

                     /* and increment byte count */
                     bytesRead++;
                  }

                  /* continue stuffing byte until repeat count exhausted */
                  while (repeatCount--)
                  {
                     /* check if we are skipping the luminosity byte for
                        32-bit images (this isn't used in Windows DIBs) */
                     if (bytesToSkip)
                     {
                        bytesToSkip--;
                     }
                     else
                     {
                        /* insert new Byte */
                        *insertHPtr++ = repeatByte1;
                     }

                     /* check if second repeat byte needs to be inserted */
                     if (doubleByte)
                     {
                        *insertHPtr++ = repeatByte2;
                     }
                  }
               }
            }
            else  /* if (tempRepeatCount >= 0) */
            {
               /* adjust the number of bytes that will be transferred */
               if (compressed)
               {
                  /* if greater than 0, is number of bytes that follow */
                  repeatCount = 1 + (Integer)tempRepeatCount;

                  /* double the number of bytes if 16-bit pixelmap */
                  if (doubleByte)
                  {
                     repeatCount *= 2;
                  }
               }
               else
               {
                  /* the number of bytes to read = bytesPerLine */
                  repeatCount = bytesPerLine;
               }

               /* increment the number of bytes read */
               bytesRead += repeatCount;

               /* check if iversion is required */
               if (invertBits)
               {
                  /* if this is a monochrome bitmap, then invert bits */
                  while (repeatCount--)
                  {
                     GetByte( insertHPtr );
                     *insertHPtr++ ^= (Byte)0xFF;
                  }
               }
               else
               {
                  /* continue reading bytes into the insert point */
                  while (repeatCount--)
                  {
                     /* check if we are skipping the luminosity byte for
                        32-bit images (this isn't used in Windows DIBs) */
                     if (bytesToSkip)
                     {
                        /* pass the current insertion pointer, but don't
                           increment (overwritten in ensuing read). */
                        bytesToSkip--;
                        GetByte( insertHPtr );
                     }
                     else
                     {
                        GetByte( insertHPtr++ );
                     }
                  }
               }
            }
         }

         /* increment the line pointer to the next scan line */
         rowHPtr += bytesPerLine;

         /* call IO module to update current read position */
         IOUpdateStatus();
      }

      /* Unlock the data block */
      GlobalUnlock( *pixDataHandle );

      /* if an error occured, make sure to remove the data block */
      if (ErGetGlobalError() != NOERR)
      {
         GlobalFree( *pixDataHandle );
	 *pixDataHandle = NULL;
      }
   }

}  /* GetPixData */


/******************************* Private Routines ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\headers.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       headers.c
//
//  Contents:   Precompiled header for olecnv32.dll
//
//  History:    28-Mar-94 AlexT     Created
//
//--------------------------------------------------------------------------

#undef UNICODE
#undef _UNICODE


//
//  Prevent lego errors under Chicago.
//
#if defined(_CHICAGO_)
#define _CTYPE_DISABLE_MACROS
#endif

#include "toolbox.h"    /* the underlying toolbox environment */
#include "error.h"      /* for error codes */
#include "quickdrw.h"   /* for some typedefs */
#include "bufio.h"
#include "gdiprim.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\gdiprim.h ===
/****************************************************************************
                       Unit GdiPrim; Interface
*****************************************************************************

 The Gdi module is called directly by the QuickDraw (QD) module in order
 to emit metafile primitives.  It is responsible for accessing the current
 CGrafPort structure in order to access the individual attribute settings.

 It also supports the caching and redundant elimination of duplicate
 elements when writing to the metafile.

   Module Prefix: Gdi

*****************************************************************************/

/*--- states ---*/

#define  Changed            0
#define  Current            1

/*--- state table offsets ---*/

#define  GdiPnPat             0x0001        /* fill patterns */
#define  GdiBkPat             0x0002
#define  GdiFillPat           0x0003
#define  GdiPnSize            0x0004        /* pen attribs */
#define  GdiPnMode            0x0005
#define  GdiFgColor           0x0006        /* foreground, background */
#define  GdiBkColor           0x0007
#define  GdiPnFgColor         0x000A
#define  GdiBkFgColor         0x000B
#define  GdiFillFgColor       0x000C
#define  GdiPnBkColor         0x000D
#define  GdiBkBkColor         0x000E
#define  GdiFillBkColor       0x000F
#define  GdiTxFont            0x0010        /* text attribs */
#define  GdiTxFace            0x0011
#define  GdiTxSize            0x0012
#define  GdiTxMode            0x0013
#define  GdiTxRatio           0x0014
#define  GdiChExtra           0x0015
#define  GdiSpExtra           0x0016
#define  GdiLineJustify       0x0017
#define  GdiNumAttrib         0x0018


/*--- Action verbs ---*/

typedef  Integer     GrafVerb;

#define  GdiFrame             0
#define  GdiPaint             1
#define  GdiErase             2
#define  GdiInvert            3
#define  GdiFill              4


/*--- metafile comment ---*/

#define  PUBLIC                  0xFFFFFFFF     /* '....' public */
#define  POWERPOINT_OLD          0x5050FE54     /* 'PP.T' PowerPoint 2.0 */
#define  POWERPOINT              0x50504E54     /* 'PPNT' PowerPoint 3.0 */
#define  PRIVATE                 0x512D3E47     /* 'Q->G' QD2GDI */
#define  SUPERPAINT              0x53504E54     /* 'SPNT' SuperPaint */

#define  PC_REGISTERED           0x8000         /* PowerPoint callback flag */

#define  QG_SIGNATURE            "QuickDraw -> GDI"

#define  BEGIN_GROUP             0              /* public comments */
#define  END_GROUP               1
#define  CREATOR                 4
#define  BEGIN_BANDING           6
#define  END_BANDING             7

#define  PP_VERSION              0x00           /* PowerPoint comments */
#define  PP_BFILEBLOCK           0x01
#define  PP_BEGINPICTURE         0x02
#define  PP_ENDPICTURE           0x03
#define  PP_DEVINFO              0x04
#define  PP_BEGINHYPEROBJ        0x05
#define  PP_ENDHYPEROBJ          0x06
#define  PP_BEGINFADE            0x07
#define  PP_ENDFADE              0x08

#define  PP_FONTNAME             0x11           /* GDI2QD round-trip */
#define  PP_HATCHPATTERN         0x12

#define  PP_BEGINCLIPREGION      0x40           /* clip regions from QD2GDI */
#define  PP_ENDCLIPREGION        0x41
#define  PP_BEGINTRANSPARENCY    0x42
#define  PP_ENDTRANSPARENCY      0x43
#define  PP_MASK                 0x44
#define  PP_TRANSPARENTOBJ       0x45

#define  PP_MACPP2COLOR          0x80
#define  PP_WINGRAPH             0xAB


typedef struct
{
   DWord       signature;
   Word        function;
   DWord       size;

}  Comment, far * CommentLPtr;


/*--- PostScript data buffer (POSTSCRIPT_DATA Escape) ---*/

typedef struct psbuf
{
   Word     length;
   char     data[1];
} PSBuf;


/*--- Conversion preferences ---*/

#define  GdiPrefOmit    0
#define  GdiPrefAbort   2

typedef struct
{
   StringLPtr  metafileName;
   Byte        penPatternAction;
   Byte        nonSquarePenAction;
   Byte        penModeAction;
   Byte        textModeAction;
   Byte        nonRectRegionAction;
   Boolean     optimizePP;
   Byte        noRLE;
} ConvPrefs, far * ConvPrefsLPtr;


/*--- Conversion results ---*/

typedef struct
{
   HANDLE   hmf;        /* Global memory handle to the metafile */
   RECT     bbox;       /* Tightly bounding rectangle in metafile units */
   short    inch;       /* Length of an inch in metafile units */
} PICTINFO, FAR * PictInfoLPtr;



/*********************** Exported Function Definitions **********************/

void GdiOffsetOrigin( Point delta );
/* offset the current window origin and picture bounding box */


void GdiLineTo( Point newPt );
/* Emit line primitive with square endcaps */


void GdiRectangle( GrafVerb verb, Rect rect );
/* Emit rectangle primitive using action and dimensions parameters */


void GdiRoundRect( GrafVerb verb, Rect rect, Point oval );
/* Emit rounded rectangle primitive */


void GdiOval( GrafVerb verb, Rect rect );
/* Emit an oval primitive */


void GdiArc( GrafVerb verb, Rect rect, Integer startAngle, Integer arcAngle );
/* Emit an arc primitive */


void GdiPolygon( GrafVerb verb, Handle poly );
/* Emit polygon primitive */


void GdiRegion( GrafVerb verb, Handle rgn );
/* Emit region primitive */


void GdiTextOut( StringLPtr string, Point location );
/* draw the text at the location specified by location parameter. */


void GdiStretchDIBits( PixMapLPtr pixMapLPtr, Handle pixDataHandle,
                       Rect src, Rect dst, Word mode, Handle mask );
/* Draw a Windows device-independant bitmap */


void GdiSelectClipRegion( RgnHandle rgn );
/* Create a clipping rectangle or region using handle passed */


void GdiHatchPattern( Integer hatchIndex );
/* Use the hatch pattern index passed down to perform all ensuing fill
   operations - 0-6 for a hatch value, -1 turns off the substitution */


void GdiFontName( Byte fontFamily, Byte charSet, StringLPtr fontName );
/* Set font characteristics based upno metafile comment from GDI2QD */


void GdiShortComment( CommentLPtr cmt );
/* Write public or private comment with no associated data */


void GdiEscape( Integer function, Integer count, StringLPtr data);
/* Write out a GDI Escape structure with no returned data */


void GdiSetConversionPrefs( ConvPrefsLPtr convPrefs);
/* Provide conversion preferences via global data block */


void GdiOpenMetafile( void );
/* Open metafile passed by GdiSetMetafileName() and perform any
   initialization of the graphics state */


void GdiSetBoundingBox( Rect bbox, Integer resolution );
/* Set the overall picture size and picture resoulution in dpi */


void GdiCloseMetafile( void );
/* Close the metafile handle and end picture generation */


void GdiGetConversionResults( PictInfoLPtr  pictInfoLPtr );
/* return results of the conversion */


void GdiMarkAsChanged( Integer attribCode );
/* indicate that the attribute passed in has changed */


#ifdef WIN32
int WINAPI EnumFontFunc( CONST LOGFONT *logFontLPtr, CONST TEXTMETRIC *tmLPtr,
                         DWORD fontType, LPARAM dataLPtr );
#else
int FAR PASCAL EnumFontFunc( LPLOGFONT logFontLPtr, LPTEXTMETRIC tmLPtr,
                             short fontType, LPSTR dataLPtr );
#endif
/* Callback function used to determine if a given font is available */

void GdiSamePrimitive( Boolean same );
/* indicate whether next primitive is the same or new */

void GdiEPSPreamble(Rect far *);
/* output GDI EPS filter PostScript preamble */

void GdiEPSTrailer( void );
/* output GDI EPS filter PostScript trailer */

void GdiEPSData(PSBuf far*);
/* output EPS PostScript data as GDI POSTSCRIPT_DATA Escape */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\quickdrw.h ===
/****************************************************************************
                            Module Quickdrw; Interface
*****************************************************************************

 This is the main module interface to the data stream interpreter.  As such,
 it will read individual opcode elements and the appropriate data 
 parameters associated with that opocode.  These are either placed into
 the CGrafPort structure or calls are made to the Gdi module to issue
 the correct metafile function.

   Module prefix:  QD

****************************************************************************/

/*--- Source transfer modes ---*/

#define  QDSrcCopy         0
#define  QDSrcOr           1
#define  QDSrcXor          2
#define  QDSrcBic          3
#define  QDNotSrcCopy      4
#define  QDNotSrcOr        5
#define  QDNotSrcXor       6
#define  QDNotSrcBic       7

/*--- Pattern transfer modes ---*/

#define  QDPatCopy         8
#define  QDPatOr           9
#define  QDPatXor          10
#define  QDPatBic          11
#define  QDNotPatCopy      12
#define  QDNotPatOr        13
#define  QDNotPatXor       14
#define  QDNotPatBic       15

/*--- Arithmetic transfer modes ---*/

#define  QDBlend           32
#define  QDAddPin          33
#define  QDAddOver         34
#define  QDSubPin          35
#define  QDTransparent     36
#define  QDAdMax           37
#define  QDSubOver         38
#define  QDAdMin           39

/*--- Undocumented hidden transfer mode ---*/

#define  QDHidePen         23


/*--- Font styles ---*/

#define  QDTxBold          0x01
#define  QDTxItalic        0x02
#define  QDTxUnderline     0x04
#define  QDTxOutline       0x08
#define  QDTxShadow        0x10
#define  QDTxCondense      0x20
#define  QDTxExtend        0x40


/*--- LaserWriter Text attributes ---*/

#define  QDAlignNone       0x00
#define  QDAlignLeft       0x01
#define  QDAlignCenter     0x02
#define  QDAlignRight      0x03
#define  QDAlignJustified  0x04

#define  QDFlipNone        0x00
#define  QDFlipHorizontal  0x01
#define  QDFlipVertical    0x02


/*--- Polygon and Region structure sizes ---*/

#define  PolyHeaderSize (sizeofMacWord + sizeofMacRect)
#define  RgnHeaderSize  (sizeofMacWord + sizeofMacRect)

/*--- PixelMap structure ---*/

#define  PixelMapBit       0x8000
#define  RowBytesMask      0x7FFF

typedef struct
{
   Integer        rowBytes;
   Rect           bounds;
   Integer        pmVersion;
   Word           packType;
   LongInt        packSize;
   Fixed          hRes;
   Fixed          vRes;
   Integer        pixelType;
   Integer        pixelSize;
   Integer        cmpCount;
   Integer        cmpSize;
   LongInt        planeBytes;
   Handle         pmTable;
   Word           pmTableSlop;
   LongInt        pmReserved;
} PixMap, far * PixMapLPtr;


/*--- Pixel Pattern structure ---*/

#define  QDOldPat      0
#define  QDNewPat      1
#define  QDDitherPat   2

typedef  Byte  Pattern[8];

typedef struct
{
   Integer        patType;
   PixMap         patMap;
   Handle         patData;
   Pattern        pat1Data;
} PixPat, far * PixPatLPtr;


/*--- Miscellaneous type declarations ---*/

#define  RgnHandle      Handle
#define  PixPatHandle   Handle
#define  RGBColor       COLORREF


/*--- Color Table structure ---*/

typedef struct
{
   LongInt        ctSeed;
   Word           ctFlags;
   Word           ctSize;
   RGBColor       ctColors[1];

} ColorTable, far * ColorTableLPtr;


/*--- QuickDraw grafPort simulation ---*/

typedef struct
{
   Integer        portVersion;
   Integer        chExtra;
   Integer        pnLocHFrac;
   Rect           portRect;
   RgnHandle      clipRgn;
   PixPat         bkPixPat;
   RGBColor       rgbFgColor;
   RGBColor       rgbBkColor;
   Point          pnLoc;
   Point          pnSize;
   Integer        pnMode;
   PixPat         pnPixPat;
   PixPat         fillPixPat;
   Integer        pnVis;
   Integer        txFont;
   Byte           txFace;
   Integer        txMode;
   Integer        txSize;
   Fixed          spExtra;
   Handle         rgnSave;
   Handle         polySave;
   Byte           txFontName[32];
   Point          txLoc;
   Point          txNumerator;
   Point          txDenominator;
   Integer        txRotation;
   Byte           txFlip;

} CGrafPort, far * CGrafPortLPtr;


/**************************** Exported Operations ***************************/

void QDConvertPicture( Handle dialogHandle );
/* create a Windows metafile using the previously set parameters, returning
   the converted picture information in the pictResult structure. */


void QDGetPort( CGrafPort far * far * port );
/* return handle to grafPort structure */


void QDCopyBytes( Byte far * src, Byte far * dest, Integer numBytes );
/* copy a data from source to destination */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\quickdrw.c ===
/****************************************************************************
                     Module Quickdrw: Implementation
*****************************************************************************

 This is the interpreter engine for the picture convertor.  It uses a
 modified CGrafPort structure to hold the intermediate results of a
 translation that can later be accessed from the Gdi module.  As such,
 it provides an input cache for all attributes, with calls made
 directly to the Gdi module for primitives.

 It is called by the API module and will call the Get module in order
 to read individual data or record elements from the data stream.

   Module prefix:  QD

****************************************************************************/

#include "headers.c"
#pragma hdrstop

/* C libraries */
#include "string.h"
#include <ctype.h>

/* quickdrw's own interface */
#include "qdopcode.i"
#include "qdcoment.i"

/* imported modules */
#include <math.h>
#include "filesys.h"
#include "getdata.h"

/*********************** Exported Data Initialization ***********************/


/******************************* Private Data *******************************/

/*--- QuickDraw grafPort simulation --- */

#define  Version1ID     0x1101
#define  Version2ID     0x02FF


/*--- QuickDraw opcode fields --- */

/* -1 is casted to Word to prevent warning in WIN32 compilation */
#define  Reserved       (Word) -1

#define  Variable       -1
#define  CommentSize    -2
#define  RgnOrPolyLen   -3
#define  WordDataLen    -4
#define  DWordDataLen   -5
#define  HiByteLen      -6

typedef struct
{
   Word     function;
   Integer  length;
} opcodeEntry, far * opcodeEntryLPtr;

/* The following opcode table was taken from "Inside Macintosh, Volume V" on
   pages V-97 to V-102 and supplemented by System 7 opcodes from "Inside
   Macintosh, Volume VI", page 17-20. */

#define  LookupTableSize      0xA2

private  opcodeEntry opcodeLookup[LookupTableSize] =
{
   /* 0x00 */ { NOP,                 0 },
   /* 0x01 */ { Clip,                RgnOrPolyLen },
   /* 0x02 */ { BkPat,               8 },
   /* 0x03 */ { TxFont,              2 },
   /* 0x04 */ { TxFace,              1 },
   /* 0x05 */ { TxMode,              2 },
   /* 0x06 */ { SpExtra,             4 },
   /* 0x07 */ { PnSize,              4 },
   /* 0x08 */ { PnMode,              2 },
   /* 0x09 */ { PnPat,               8 },
   /* 0x0A */ { FillPat,             8 },
   /* 0x0B */ { OvSize,              4 },
   /* 0x0C */ { Origin,              4 },
   /* 0x0D */ { TxSize,              2 },
   /* 0x0E */ { FgColor,             4 },
   /* 0x0F */ { BkColor,             4 },
   /* 0x10 */ { TxRatio,             8 },
   /* 0x11 */ { Version,             1 },
   /* 0x12 */ { BkPixPat,            Variable },
   /* 0x13 */ { PnPixPat,            Variable },
   /* 0x14 */ { FillPixPat,          Variable },
   /* 0x15 */ { PnLocHFrac,          2 },
   /* 0x16 */ { ChExtra,             2 },
   /* 0x17 */ { Reserved,            0 },
   /* 0x18 */ { Reserved,            0 },
   /* 0x19 */ { Reserved,            0 },
   /* 0x1A */ { RGBFgCol,            6 },
   /* 0x1B */ { RGBBkCol,            6 },
   /* 0x1C */ { HiliteMode,          0 },
   /* 0x1D */ { HiliteColor,         6 },
   /* 0x1E */ { DefHilite,           0 },
   /* 0x1F */ { OpColor,             6 },
   /* 0x20 */ { Line,                8 },
   /* 0x21 */ { LineFrom,            4 },
   /* 0x22 */ { ShortLine,           6 },
   /* 0x23 */ { ShortLineFrom,       2 },
   /* 0x24 */ { Reserved,            WordDataLen },
   /* 0x25 */ { Reserved,            WordDataLen },
   /* 0x26 */ { Reserved,            WordDataLen },
   /* 0x27 */ { Reserved,            WordDataLen },
   /* 0x28 */ { LongText,            Variable },
   /* 0x29 */ { DHText,              Variable },
   /* 0x2A */ { DVText,              Variable },
   /* 0x2B */ { DHDVText,            Variable },
   /* 0x2C */ { FontName,            WordDataLen },
   /* 0x2D */ { LineJustify,         WordDataLen },
   /* 0x2E */ { Reserved,            WordDataLen },
   /* 0x2F */ { Reserved,            WordDataLen },
   /* 0x30 */ { frameRect,           8 },
   /* 0x31 */ { paintRect,           8 },
   /* 0x32 */ { eraseRect,           8 },
   /* 0x33 */ { invertRect,          8 },
   /* 0x34 */ { fillRect,            8 },
   /* 0x35 */ { Reserved,            8 },
   /* 0x36 */ { Reserved,            8 },
   /* 0x37 */ { Reserved,            8 },
   /* 0x38 */ { frameSameRect,       0 },
   /* 0x39 */ { paintSameRect,       0 },
   /* 0x3A */ { eraseSameRect,       0 },
   /* 0x3B */ { invertSameRect,      0 },
   /* 0x3C */ { fillSameRect,        0 },
   /* 0x3D */ { Reserved,            0 },
   /* 0x3E */ { Reserved,            0 },
   /* 0x3F */ { Reserved,            0 },
   /* 0x40 */ { frameRRect,          8 },
   /* 0x41 */ { paintRRect,          8 },
   /* 0x42 */ { eraseRRect,          8 },
   /* 0x43 */ { invertRRect,         8 },
   /* 0x44 */ { fillRRect,           8 },
   /* 0x45 */ { Reserved,            8 },
   /* 0x46 */ { Reserved,            8 },
   /* 0x47 */ { Reserved,            8 },
   /* 0x48 */ { frameSameRRect,      0 },
   /* 0x49 */ { paintSameRRect,      0 },
   /* 0x4A */ { eraseSameRRect,      0 },
   /* 0x4B */ { invertSameRRect,     0 },
   /* 0x4C */ { fillSameRRect,       0 },
   /* 0x4D */ { Reserved,            0 },
   /* 0x4E */ { Reserved,            0 },
   /* 0x4F */ { Reserved,            0 },
   /* 0x50 */ { frameOval,           8 },
   /* 0x51 */ { paintOval,           8 },
   /* 0x52 */ { eraseOval,           8 },
   /* 0x53 */ { invertOval,          8 },
   /* 0x54 */ { fillOval,            8 },
   /* 0x55 */ { Reserved,            8 },
   /* 0x56 */ { Reserved,            8 },
   /* 0x57 */ { Reserved,            8 },
   /* 0x58 */ { frameSameOval,       0 },
   /* 0x59 */ { paintSameOval,       0 },
   /* 0x5A */ { eraseSameOval,       0 },
   /* 0x5B */ { invertSameOval,      0 },
   /* 0x5C */ { fillSameOval,        0 },
   /* 0x5D */ { Reserved,            0 },
   /* 0x5E */ { Reserved,            0 },
   /* 0x5F */ { Reserved,            0 },
   /* 0x60 */ { frameArc,            12 },
   /* 0x61 */ { paintArc,            12 },
   /* 0x62 */ { eraseArc,            12 },
   /* 0x63 */ { invertArc,           12 },
   /* 0x64 */ { fillArc,             12 },
   /* 0x65 */ { Reserved,            12 },
   /* 0x66 */ { Reserved,            12 },
   /* 0x67 */ { Reserved,            12 },
   /* 0x68 */ { frameSameArc,        4 },
   /* 0x69 */ { paintSameArc,        4 },
   /* 0x6A */ { eraseSameArc,        4 },
   /* 0x6B */ { invertSameArc,       4 },
   /* 0x6C */ { fillSameArc,         4 },
   /* 0x6D */ { Reserved,            4 },
   /* 0x6E */ { Reserved,            4 },
   /* 0x6F */ { Reserved,            4 },
   /* 0x70 */ { framePoly,           RgnOrPolyLen },
   /* 0x71 */ { paintPoly,           RgnOrPolyLen },
   /* 0x72 */ { erasePoly,           RgnOrPolyLen },
   /* 0x73 */ { invertPoly,          RgnOrPolyLen },
   /* 0x74 */ { fillPoly,            RgnOrPolyLen },
   /* 0x75 */ { Reserved,            RgnOrPolyLen },
   /* 0x76 */ { Reserved,            RgnOrPolyLen },
   /* 0x77 */ { Reserved,            RgnOrPolyLen },
   /* 0x78 */ { frameSamePoly,       0 },
   /* 0x79 */ { paintSamePoly,       0 },
   /* 0x7A */ { eraseSamePoly,       0 },
   /* 0x7B */ { invertSamePoly,      0 },
   /* 0x7C */ { fillSamePoly,        0 },
   /* 0x7D */ { Reserved,            0 },
   /* 0x7E */ { Reserved,            0 },
   /* 0x7F */ { Reserved,            0 },
   /* 0x80 */ { frameRgn,            RgnOrPolyLen },
   /* 0x81 */ { paintRgn,            RgnOrPolyLen },
   /* 0x82 */ { eraseRgn,            RgnOrPolyLen },
   /* 0x83 */ { invertRgn,           RgnOrPolyLen },
   /* 0x84 */ { fillRgn,             RgnOrPolyLen },
   /* 0x85 */ { Reserved,            RgnOrPolyLen },
   /* 0x86 */ { Reserved,            RgnOrPolyLen },
   /* 0x87 */ { Reserved,            RgnOrPolyLen },
   /* 0x88 */ { frameSameRgn,        0 },
   /* 0x89 */ { paintSameRgn,        0 },
   /* 0x8A */ { eraseSameRgn,        0 },
   /* 0x8B */ { invertSameRgn,       0 },
   /* 0x8C */ { fillSameRgn,         0 },
   /* 0x8D */ { Reserved,            0 },
   /* 0x8E */ { Reserved,            0 },
   /* 0x8F */ { Reserved,            0 },
   /* 0x90 */ { BitsRect,            Variable },
   /* 0x91 */ { BitsRgn,             Variable },
   /* 0x92 */ { Reserved,            WordDataLen },
   /* 0x93 */ { Reserved,            WordDataLen },
   /* 0x94 */ { Reserved,            WordDataLen },
   /* 0x95 */ { Reserved,            WordDataLen },
   /* 0x96 */ { Reserved,            WordDataLen },
   /* 0x97 */ { Reserved,            WordDataLen },
   /* 0x98 */ { PackBitsRect,        Variable },
   /* 0x99 */ { PackBitsRgn,         Variable },
   /* 0x9A */ { DirectBitsRect,      WordDataLen },
   /* 0x9B */ { DirectBitsRgn,       WordDataLen },
   /* 0x9C */ { Reserved,            WordDataLen },
   /* 0x9D */ { Reserved,            WordDataLen },
   /* 0x9E */ { Reserved,            WordDataLen },
   /* 0x9F */ { Reserved,            WordDataLen },
   /* 0xA0 */ { ShortComment,        2 },
   /* 0xA1 */ { LongComment,         CommentSize }
};

#define  RangeTableSize    7

private  opcodeEntry opcodeRange[RangeTableSize] =
{
   /* 0x00A2 - 0x00AF */ { 0x00AF,   WordDataLen },
   /* 0x00B0 - 0x00CF */ { 0x00CF,   0 },
   /* 0x00D0 - 0x00FE */ { 0x00FE,   DWordDataLen },
   /* 0x00FF - 0x00FF */ { opEndPic, 0 },
   /* 0x0100 - 0x07FF */ { 0x8000,   HiByteLen },
   /* 0x8000 - 0x80FF */ { 0x80FF,   0 },
   /* 0x8100 - 0xFFFF */ { 0xFFFF,   DWordDataLen }
};

/*--- EPS Filter PostScript Strings ---*/

#define   MAC_PS_TRAILER  "pse\rpsb\r"
#define   MAC_PS_PREAMBLE "pse\rcurrentpoint\r/picTop exch def\r/picLeft exch def\rpsb\r"

#define   SUPERPAINT_TEXTSTARTJUNK "P2_b ["
#define   SUPERPAINT_TEXTSTOPJUNK  "] sb end\r"

/*--- GrafPort allocation ---*/

#define  PARSEPOLY      1
#define  SKIPALTPOLY    2
#define  USEALTPOLY     3

#define  MASKPOLYBITS   0x07
#define  FRAMEPOLY      0x01
#define  FILLPOLY       0x02
#define  CLOSEPOLY      0x04
#define  FILLREQUIRED   0x08
#define  CHECK4SPLINE   0x10

#define  POLYLIST       ((sizeof( Integer ) + sizeof( Rect )) / sizeof( Integer ))
#define  BBOX           1

private  CGrafPort      grafPort;
private  Integer        resolution;
private  Boolean        skipFontID;
private  Integer        maxPoints;
private  Integer        numPoints;
private  Integer far *  numPointsLPtr;
private  Rect           polyBBox;
private  Point far *    polyListLPtr;
private  Handle         polyHandle;
private  Byte           polyMode;
private  Byte           polyParams;
private  RGBColor       polyFgColor;
private  RGBColor       polyBkColor;
private  Boolean        zeroDeltaExpected;

private  Boolean        textMode;
private  Boolean        newTextCenter;
private  Point          textCenter;
private  Boolean        textClipCheck;
private  Real           degCos;
private  Real           degSin;

private  Boolean        shadedObjectStarted;
private  Boolean        superPaintFile;
private  Boolean        badSuperPaintText;

/*--- last Primitive sent ---*/

private  Rect     saveRect;
private  Rect     saveRRect;
private  Rect     saveOval;
private  Point    saveOvalSize;
private  Rect     saveArc;
private  Integer  saveStartAngle;
private  Integer  saveArcAngle;

/*--- Global allocated contstants ---*/

private Pattern  SolidPattern = { 0xFF, 0xFF, 0xFF, 0xFF,
                                  0xFF, 0xFF, 0xFF, 0xFF };


/*********************** Private Routine Declarations ***********************/

private void ReadHeaderInfo( void );
/* read the fixed size PICT header from the file.  This provides information
   about the file size (however, it may be invalid and is ignored) and the
   picture bounding box, followed by the PICT version information. */

private void ReadPictVersion( void );
/* Read the PICT version number from the data file.  If this isn't a
   version 1 or 2 file, the routine returns IE_UNSUPP_VERSION error. */

private void ReadOpcode( opcodeEntry far * nextOpcode );
/* Reads the next opcode from the stream, depending on the PICT version */

private void TranslateOpcode( opcodeEntry far * currOpcodeLPtr );
/* read in the remaining data from the stream, based upon the opcode function
   and then call the appropriate routine in Gdi module */

private void SkipData( opcodeEntry far * currOpcodeLPtr );
/* skip the data - the opcode won't be translated and Gdi module won't be
   called to create anything in the metafile */

private void   OpenPort( void );
/* initialize the grafPort */

private void   ClosePort( void );
/* close grafPort and de-allocate any memory blocks */

private void NewPolygon( void );
/* initialize the state of the polygon buffer - flush any previous data */

private void AddPolySegment( Point start, Point end );
/* Add the line segment to the polygon buffer */

private void DrawPolyBuffer( void );
/* Draw the polygon definition if the points were read without errors */

private void AdjustTextRotation( Point far * newPt );
/* This will calculate the correct text position if text is rotated */

private Integer EPSComment(Word comment);
/* parse EPS Comment */

private Integer EPSData(Integer state);
/* process EPS Data */

private Boolean EPSBbox(PSBuf far *, Rect far *);
/* parse EPS bounding box description */

private char far* parse_number(char far* ptr, Integer far *iptr);
/* parse numeric string (local to EPSBbox) */

#define IsCharDigit(c) (IsCharAlphaNumeric(c) && !IsCharAlpha(c))

/**************************** Function Implementation ***********************/

void QDConvertPicture( Handle dialogHandle )
/*====================*/
/* create a Windows metafile using the previously set parameters, returning
   the converted picture information in the pictResult structure. */

{
   opcodeEntry    currOpcode;

   /* Open the file - if an error occured, return to main */
   IOOpenPicture( dialogHandle );

   /* Tell Gdi module to open the metafile */
   GdiOpenMetafile();

   /* initialize the grafPort */
   OpenPort();

   /* read and validate size, bounding box, and PICT version */
   ReadHeaderInfo();

   do
   {
      /* read the next opcode from the data stream */
      ReadOpcode( &currOpcode );

      /* read the ensuing data and call Gdi module entry points */
      TranslateOpcode( &currOpcode );

      /* align next memory read to Word boundary in the case of PICT 2 */
      if (grafPort.portVersion == 2)
      {
         IOAlignToWordOffset();
      }

      /* update the status dialog with current progress */
      IOUpdateStatus();

      /* break out of loop if end picture opcode is encountered */
   } while (currOpcode.function != opEndPic);

   /* close grafPort and de-allocate any used memory blocks */
   ClosePort();

   /* Tell Gdi module that picture is ending - perform wrapup */
   GdiCloseMetafile();

   /* Close the file */
   IOClosePicture();

} /* ReFileToPicture */


void QDGetPort( CGrafPort far * far * port )
/*============*/
/* return handle to grafPort structure */
{
   *port = &grafPort;
}


void QDCopyBytes( Byte far * src, Byte far * dest, Integer numBytes )
/*==============*/
/* copy a data from source to destination */
{
   /* loop through entire data length */
   while (numBytes--)
   {
      *dest++ = *src++;
   }

}  /* CopyBytes */


/******************************* Private Routines ***************************/


private void ReadHeaderInfo( void )
/*-------------------------*/
/* read the fixed size PICT header from the file.  This provides information
   about the file size (however, it may be invalid and is ignored) and the
   picture bounding box, followed by the PICT version information. */
{
   Word        unusedSize;

   /* read file size - this value is ignored since it may be totally bogus */
   GetWord( &unusedSize );

   /* the next rectangle contains the picture bounding box */
   GetRect( &grafPort.portRect );

   /* Read the next record that indicates a PICT1 or PICT2 version picture */
   ReadPictVersion();

   /* Call Gdi module and provide bounding box coordinates.  Note that these
      may have been altered from rectangle specified above if a spatial
      resolution other than 72 dpi is used in the picture. */
   GdiSetBoundingBox( grafPort.portRect, resolution );

}  /* ReadHeaderInfo */


private void ReadPictVersion( void )
/*--------------------------*/
/* Read the PICT version number from the data file.  If this isn't a
   version 1 or 2 file, the routine returns IE_UNSUPP_VERSION error. */
{
   opcodeEntry    versionOpcode;
   Word           versionCheck = 0;
   Word           opcodeCheck  = 0;

   /* The following loop was added in order to read PixelPaint files
      successfully.  Although technically an invalid PICT image, these files
      contain a series of NOP opcodes, followed by the version opcode.  In
      this case, we continue reading until the version opcode (non-zero
      value) is encountered, after which the checking continues. */
   do
   {
      /* read the first two bytes from the data stream - for PICT 1 this is
         both the opcode and version; for PICT 2 this is the opcode only. */
      GetWord( &versionCheck );

   } while ((versionCheck == NOP) && (ErGetGlobalError() == ErNoError));

   /* determine if a valid version opcode was encountered */
   if (versionCheck == Version1ID )
   {
      /* version 1 == 0x1101 */
      grafPort.portVersion = 1;
   }
   /* check for version 2 opcode which is a Word in length */
   else if (versionCheck == Version)
   {
      /* Since we have only read the opcode, read the next word which should
         contain the identifier for PICT 2 data. */
      GetWord( &versionCheck );
      if (versionCheck == Version2ID)
      {
         grafPort.portVersion = 2;

         /* make sure that the next record is a header opcode. */
         GetWord( &opcodeCheck );
         if (opcodeCheck == HeaderOp)
         {
            /* set up a record structure for call to TranslateOpcode(). */
            versionOpcode.function = HeaderOp;
            versionOpcode.length = 24;
            TranslateOpcode( &versionOpcode );
         }
         else
         {
            /* Header wasn't followed by correct Header opcode - error. */
            ErSetGlobalError( ErBadHeaderSequence );
         }
      }
      else
      {
         /* if version 2 identifier is invalid, return error state. */
         ErSetGlobalError( ErInvalidVersionID );
      }
   }
   else
   {
      /* if check for version 1 and 2 fails, return error state. */
      ErSetGlobalError( ErInvalidVersion );
   }

}  /* ReadPictVersion */




private void ReadOpcode( opcodeEntry far * nextOpcode )
/*---------------------*/
/* Reads the next opcode from the stream, depending on the PICT version */
{
   opcodeEntryLPtr   checkEntry;

   /* Initialize the function, since we may be reading a version 1 opcode
      that is only 1 byte in length. */
   nextOpcode->function = 0;

   /* Depending on the PICT version, we will read either a single byte
      or word for the opcode. */
   if (grafPort.portVersion == 1)
   {
      GetByte( (Byte far *)&nextOpcode->function );
   }
   else
   {
      GetWord( &nextOpcode->function );
   }

   /* check the current error code and force an exit from read loop if
      something went wrong. */
   if (ErGetGlobalError() != NOERR)
   {
      nextOpcode->function = opEndPic;
      nextOpcode->length = 0;
      return;
   }

   /* Check the opcode function number to determine if we can perform
      a direct lookup, or if the opcode is part of the range table. */
   if (nextOpcode->function < LookupTableSize )
   {
      nextOpcode->length = opcodeLookup[nextOpcode->function].length;
   }
   else
   {
      /* Walk through the range table to determine the data length of the
         ensuing information past the opcode. */
      for (checkEntry = opcodeRange;
           checkEntry->function < nextOpcode->function;
           checkEntry++) ;

      nextOpcode->length = checkEntry->length;
   }

}  /* ReadOpcode */


private void TranslateOpcode( opcodeEntry far * currOpcodeLPtr )
/*--------------------------*/
/* read in the remaining data from the stream, based upon the opcode function
   and then call the appropriate routine in Gdi module */
{
   Word  function = currOpcodeLPtr->function;

   /* perform appropriate action based on function code */
   switch (function)
   {
      case NOP:
         /* no data follows */
         break;

      case Clip:
      {
         Boolean  doClip = FALSE;

         /* read in clip region into grafPort */
         GetRegion( &grafPort.clipRgn );

         /* if in textmode, we need avoid clip regions, since they are used
            to draw Postscript encoded text *or* bitmap representations.
            We allow a clipping region to pass through only if it is being
            set to the bounds of the picture image (fix for MacDraw, Canvas,
            and SuperPaint images containing rotated text.) */
         if (textMode && textClipCheck)
         {
            Word far *  sizeLPtr;

            /* the most common case is a sequence of : null clip, text,
               non-null clip, bitmap.  If first clip == portRect, then
               we actually want to set the clip - doClip is set to TRUE. */
            sizeLPtr = (Word far *)GlobalLock( grafPort.clipRgn );
            doClip   = *sizeLPtr == RgnHeaderSize &&
                       EqualRect( (Rect far *)(sizeLPtr + 1), &grafPort.portRect );
            GlobalUnlock( grafPort.clipRgn );

            /* perform this check only once after initial picTextBegin */
            textClipCheck = FALSE;
         }

         /* issue the clip only if not in text mode, or a sanctioned clip */
         if (!textMode || doClip)
         {
            /* Call Gdi to set the new clip region */
            GdiSelectClipRegion( grafPort.clipRgn );
         }
         break;
      }

      case BkPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.bkPixPat.patType = QDOldPat;
         GetPattern( &grafPort.bkPixPat.pat1Data );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkPat );
         break;

      case TxFont:
         /* read text font index */
         GetWord( (Word far *)&grafPort.txFont );

         /* check if the font name was provided in previous opcode */
         if (!skipFontID)
         {
            /* Make sure that the font name is a null string */
            grafPort.txFontName[0] = cNULL;
         }

         /* Notify Gdi that text font index may have changed */
         GdiMarkAsChanged( GdiTxFont );
         break;

      case TxFace:
         /* read font attributes */
         GetByte( (Byte far *)&grafPort.txFace );

         /* Notify Gdi that text style elements may have changed */
         GdiMarkAsChanged( GdiTxFace );
         break;

      case TxMode:
         /* read text transfer mode */
         GetWord( (Word far *)&grafPort.txMode );

         /* Notify Gdi that text transfer mode may have changed */
         GdiMarkAsChanged( GdiTxMode );
         break;

      case SpExtra:
         /* read text space extra */
         GetFixed( (Fixed far *)&grafPort.spExtra );

         /* Notify Gdi that space extra may have changed */
         GdiMarkAsChanged( GdiSpExtra );
         break;

      case PnSize:
         /* read x and y components of pen size */
         GetPoint( (Point far *)&grafPort.pnSize );

         /* Notify Gdi that pen size may have changed */
         GdiMarkAsChanged( GdiPnSize );
         break;

      case PnMode:
         /* read pen transfer mode */
         GetWord( (Word far *)&grafPort.pnMode );

         /* Notify Gdi that transferm mode may have changed */
         GdiMarkAsChanged( GdiPnMode );
         break;

      case PnPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.pnPixPat.patType = QDOldPat;
         GetPattern( &grafPort.pnPixPat.pat1Data );

         /* Notify Gdi that pen pattern may have changed */
         GdiMarkAsChanged( GdiPnPat );
         break;

      case FillPat:
         /* flag the pixel map type a Foreground/Background pixel pattern */
         /* and read pattern into old data position */
         grafPort.fillPixPat.patType = QDOldPat;
         GetPattern( &grafPort.fillPixPat.pat1Data );

         /* Notify Gdi that fill pattern may have changed */
         GdiMarkAsChanged( GdiFillPat );
         break;

      case OvSize:
         /* save point in new grafPort field */
         GetPoint( &saveOvalSize );
         break;

      case Origin:
      {
         Point    offset;

         /* read the new origin in to the upper-left coordinate space */
         GetWord( (Word far *)&offset.x );
         GetWord( (Word far *)&offset.y );

         /* call gdi module to reset the origin */
         GdiOffsetOrigin( offset );
         break;
      }

      case TxSize:
         GetWord( (Word far *)&grafPort.txSize );

         /* Notify Gdi that text size may have changed */
         GdiMarkAsChanged( GdiTxSize );
         break;

      case FgColor:
         GetOctochromeColor( &grafPort.rgbFgColor );

         /* Notify Gdi that foreground color may have changed */
         GdiMarkAsChanged( GdiFgColor );
         break;

      case BkColor:
         GetOctochromeColor( &grafPort.rgbBkColor );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkColor );
         break;

      case TxRatio:
         /* save the numerator and denominator in the grafPort */
         GetPoint( &grafPort.txNumerator );
         GetPoint( &grafPort.txDenominator );

         /* Notify Gdi that text ratio may have changed */
         GdiMarkAsChanged( GdiTxRatio );
         break;

      case Version:
         /* just skip over the version information */
         IOSkipBytes( currOpcodeLPtr->length );
         break;

      case BkPixPat:
         GetPixPattern( &grafPort.bkPixPat );

         /* Notify Gdi that background pattern may have changed */
         GdiMarkAsChanged( GdiBkPat );
         break;

      case PnPixPat:
         GetPixPattern( &grafPort.pnPixPat );

         /* Notify Gdi that pen pattern may have changed */
         GdiMarkAsChanged( GdiPnPat );
         break;

      case FillPixPat:
         GetPixPattern( &grafPort.fillPixPat );

         /* Notify Gdi that fill pattern may have changed */
         GdiMarkAsChanged( GdiFillPat );
         break;

      case PnLocHFrac:
         GetWord( (Word far *)&grafPort.pnLocHFrac );
         break;

      case ChExtra:
         GetWord( (Word far *)&grafPort.chExtra );

         /* Notify Gdi that text character extra may have changed */
         GdiMarkAsChanged( GdiChExtra );
         break;

      case RGBFgCol:
         GetRGBColor( &grafPort.rgbFgColor );

         /* Notify Gdi that foregroudn color may have changed */
         GdiMarkAsChanged( GdiFgColor );
         break;

      case RGBBkCol:
         GetRGBColor( &grafPort.rgbBkColor );

         /* Notify Gdi that background color may have changed */
         GdiMarkAsChanged( GdiBkColor );
         break;

      case HiliteMode:
         /* don't do anything for hilite mode */
         break;

      case HiliteColor:
      {
         RGBColor    rgbUnused;

         GetRGBColor( &rgbUnused );
         break;

      }

      case DefHilite:
         /* don't do anything for hilite */
         break;

      case OpColor:
      {
         RGBColor    rgbUnused;

         GetRGBColor( &rgbUnused );
         break;
      }

      case Line:
      case LineFrom:
      case ShortLine:
      case ShortLineFrom:
      {
         Point          newPt;
         SignedByte     deltaX;
         SignedByte     deltaY;

         /* see if we need to read the updated pen location first */
         if (function == ShortLine || function == Line)
         {
            /* read in the new pen location */
            GetCoordinate( &grafPort.pnLoc );
         }

         /* determine what the next data record contains */
         if (function == Line || function == LineFrom)
         {
            /* get the new coordinate to draw to */
            GetCoordinate( &newPt );
         }
         else /* if (function == ShortLine || function == ShortLineFrom) */
         {
            /* the the new x and y deltas */
            GetByte( &deltaX );
            GetByte( &deltaY );

            /* calculate the endpoint for call to gdi */
            newPt.x = grafPort.pnLoc.x + (Integer)deltaX;
            newPt.y = grafPort.pnLoc.y + (Integer)deltaY;
         }

         /* check if buffering line segments (polygon mode != FALSE) */
         if (polyMode)
         {
            /* add the line segment to the polygon buffer */
            AddPolySegment( grafPort.pnLoc, newPt );
         }
         else
         {
            /* Call Gdi to draw line */
            GdiLineTo( newPt );
         }

         /* update the new pen location in the grafPort */
         grafPort.pnLoc = newPt;
         break;
      }

      case LongText:
      {
         Str255   txString;
         Point    location;

         /* read the new pen (baseline) location */
         GetCoordinate( &grafPort.txLoc );
         GetString( (StringLPtr)txString );

         /* adjust for any text rotation that may be set */
         location = grafPort.txLoc;
         AdjustTextRotation( &location );

         /* call Gdi to print the text at current pen location */
         GdiTextOut( txString, location );
         break;
      }

      case DHText:
      case DVText:
      case DHDVText:
      {
         Byte     deltaX = 0;
         Byte     deltaY = 0;
         Str255   txString;
         Point    location;

         /* if command is DHText or DHDVText, read horizontal offset */
         if (function != DVText)
         {
            GetByte( &deltaX );
         }

         /* if command is DVText or DHDVText, then read the vertical offset */
         if (function != DHText)
         {
            GetByte( &deltaY );
         }

         /* update the current pen postion */
         grafPort.txLoc.x += deltaX;
         grafPort.txLoc.y += deltaY;

         /* now read in the string */
         GetString( (StringLPtr)txString );

         /* adjust for any text rotation that may be set */
         location = grafPort.txLoc;
         AdjustTextRotation( &location );

         /* call Gdi to print the text at current pen location */
         GdiTextOut( txString, location );
         break;
      }

      case FontName:
      {
         Word           dataLen;

         GetWord( (Word far *)&dataLen );
         GetWord( (Word far *)&grafPort.txFont );
         GetString( grafPort.txFontName );

         /* Notify Gdi that font name may have changed */
         GdiMarkAsChanged( GdiTxFont );
         break;
      }

      case LineJustify:
      {
         Word           dataLen;
         Fixed          interCharSpacing;
         Fixed          textExtra;

         GetWord( (Word far *)&dataLen );
         GetFixed( &interCharSpacing );      // !!! where to put this ?
         GetFixed( &textExtra );

         /* Notify Gdi that line justification may have changed */
         GdiMarkAsChanged( GdiLineJustify );
         break;
      }


      case frameRect:
      case paintRect:
      case eraseRect:
      case invertRect:
      case fillRect:
      {
         /* read in the rectangle */
         GetRect( &saveRect );

         /* call the correct GDI routine */
         GdiRectangle( function - frameRect, saveRect );
         break;
      }

      case frameSameRect:
      case paintSameRect:
      case eraseSameRect:
      case invertSameRect:
      case fillSameRect:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last rectangle coords */
         GdiRectangle( function - frameSameRect, saveRect );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameRRect:
      case paintRRect:
      case eraseRRect:
      case invertRRect:
      case fillRRect:
      {
         /* save the rectangle */
         GetRect( &saveRRect );

         /* call the correct gdi routine using last rectangle coords */
         GdiRoundRect( function - frameRRect, saveRRect, saveOvalSize );
         break;
      }

      case frameSameRRect:
      case paintSameRRect:
      case eraseSameRRect:
      case invertSameRRect:
      case fillSameRRect:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last rectangle coords */
         GdiRoundRect( function - frameSameRRect, saveRRect, saveOvalSize );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameOval:
      case paintOval:
      case eraseOval:
      case invertOval:
      case fillOval:
      {
         /* save off bounding rectangle */
         GetRect( &saveOval );

         /* call the correct gdi routine using last oval coords */
         GdiOval( function - frameOval, saveOval );
         break;
      }

      case frameSameOval:
      case paintSameOval:
      case eraseSameOval:
      case invertSameOval:
      case fillSameOval:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call the correct gdi routine using last oval coords */
         GdiOval( function - frameSameOval, saveOval );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameArc:
      case paintArc:
      case eraseArc:
      case invertArc:
      case fillArc:
      {
         /* read rect into the save variables, new start and arc angles */
         GetRect( &saveArc );
         GetWord( (Word far *)&saveStartAngle );
         GetWord( (Word far *)&saveArcAngle );
#ifdef WIN32
         /* have to extend the sign because GetWord doesn't */
         saveStartAngle = (short)saveStartAngle;
         saveArcAngle = (short)saveArcAngle;
#endif
         /* call the correct gdi routine using last arc angles */
         GdiArc( function - frameArc, saveArc, saveStartAngle, saveArcAngle );
         break;
      }

      case frameSameArc:
      case paintSameArc:
      case eraseSameArc:
      case invertSameArc:
      case fillSameArc:
      {
         Integer     startAngle;
         Integer     arcAngle;

         /* read new start and arc angles */
         GetWord( (Word far *)&startAngle );
         GetWord( (Word far *)&arcAngle );
#ifdef WIN32
         /* have to extend the sign because GetWord doesn't */
         startAngle = (short)startAngle;
         arcAngle = (short)arcAngle;
#endif

         /* notify gdi that this is the may be the same primitive */
         GdiSamePrimitive( (startAngle == saveStartAngle) &&
                           (arcAngle   == saveArcAngle) );

         /* save off the start and arc angles */
         saveStartAngle = startAngle;
         saveArcAngle   = arcAngle;

         /* call the correct gdi routine using last rect and arc angles */
         GdiArc( function - frameSameArc, saveArc, startAngle, arcAngle );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case framePoly:
      case paintPoly:
      case erasePoly:
      case invertPoly:
      case fillPoly:
      {
         /* save the polygon in the grafPort */
         GdiSamePrimitive( GetPolygon( &grafPort.polySave, (function == framePoly) ) );

         /* call gdi routine to draw polygon */
         if (grafPort.polySave) 
	 {
	    GdiPolygon( function - framePoly, grafPort.polySave );
	    
	    /* turn off filling while in polygon mode */
	    polyParams &= ~FILLREQUIRED;
   
	    /* notify gdi that this is no longer the same primitive */
	    GdiSamePrimitive( FALSE );
	 }

         break;
      }

      case frameSamePoly:
      case paintSamePoly:
      case eraseSamePoly:
      case invertSamePoly:
      case fillSamePoly:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call gdi routine to draw polygon */
         GdiPolygon( function - frameSamePoly, grafPort.polySave );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case frameRgn:
      case paintRgn:
      case eraseRgn:
      case invertRgn:
      case fillRgn:
      {
         /* save the region in the grafPort */
         GetRegion( &grafPort.rgnSave );

         /* check for memory failure; GetRegion will set ErGetGlobalError */
         if (!grafPort.rgnSave)
             break;

         /* if in polygon mode and a fillRgn is encountered, this indicates
            that the polygon should be filled once parsing is completed */
         if (polyMode == PARSEPOLY)
         {
            /* make sure that a PaintPoly() hasn't been handled already */
            if (!(polyParams & (FILLPOLY | FILLREQUIRED)))
            {
               /* set flags to fill polygon once polygon buffer is filled */
               polyParams |= FILLPOLY | FILLREQUIRED;
            }
         }
         else if (polyMode == FALSE ||
                ((polyMode == USEALTPOLY) && !(polyParams & FRAMEPOLY)))
         {
            /* call gdi routine to draw polygon */
            GdiRegion( function - frameRgn, grafPort.rgnSave );

            /* make sure that the polygon isn't filled when the simulation
               buffer is drawn at the end of the polygon definition */
            polyParams &= ~FILLREQUIRED;
         }

         /* save off the current fore- and background colors for
            polygon simulation routine to ensure correct fill colors */
         if (polyMode && (grafPort.fillPixPat.patType == QDOldPat))
         {
            polyFgColor = grafPort.rgbFgColor;
            polyBkColor = grafPort.rgbBkColor;
         }

         break;
      }

      case frameSameRgn:
      case paintSameRgn:
      case eraseSameRgn:
      case invertSameRgn:
      case fillSameRgn:
      {
         /* notify gdi that this is the same primitive */
         GdiSamePrimitive( TRUE );

         /* call gdi routine to draw polygon */
         GdiRegion( function - frameSameRgn, grafPort.rgnSave );

         /* notify gdi that this is no longer the same primitive */
         GdiSamePrimitive( FALSE );
         break;
      }

      case BitsRect:
      case BitsRgn:
      case PackBitsRect:
      case PackBitsRgn:
      case DirectBitsRect:
      case DirectBitsRgn:
      {
         Boolean     has24bits;
         Boolean     hasRegion;
         Rect        srcRect;
         Rect        dstRect;
         Word        mode;
         PixMap      pixMap;
         Handle      pixData;
         DWord       unusedBaseAddr;
         RgnHandle   rgn;

         /* determine which type of bitmap we are reading */
         has24bits = (function == DirectBitsRect ||
                      function == DirectBitsRgn);
         hasRegion = (function == DirectBitsRgn ||
                      function == BitsRgn ||
                      function == PackBitsRgn);

         /* currently there is no region created */
         rgn = NULL;

         /* if 24-bit, read in the base address which should == 0x000000FF */
         if (has24bits)
         {
            GetDWord( &unusedBaseAddr );
         }

         /* read in the header structure */
         GetPixMap( &pixMap, FALSE );

         /* if this isn't an 24-bit RGB bitmap, read in the color table.
            Also check the rowBytes field to signify bitmap w/2 colors */
         if (!has24bits && (pixMap.rowBytes & PixelMapBit))
         {
            GetColorTable( &pixMap.pmTable );
         }

         /* call io module to update status indicator */
         IOUpdateStatus();

         /* read source and destination rects from stream */
         GetRect( &srcRect );
         GetRect( &dstRect );
         GetWord( &mode );

         /* if there is a region included, read this also */
         if (hasRegion)
         {
            /* read in the region */
            GetRegion( &rgn );
         }

         /* read the pixel bit data */
         GetPixData( &pixMap, &pixData );

         if (ErGetGlobalError() == NOERR && !textMode)
         {
            /* Call Gdi to render the bitmap and de-allocate the memory */
            GdiStretchDIBits( &pixMap, pixData, srcRect, dstRect, mode, rgn );
         }
         else
         {
            /* deallocate any memory that may be allocated */
            if (pixMap.pmTable != NULL)
            {
               GlobalFree( pixMap.pmTable );
            }
            if (hasRegion && (rgn != NULL))
            {
               GlobalFree( rgn );
            }
            if (pixData != NULL)
            {
               GlobalFree( pixData );
            }
         }
         break;
      }

      case ShortComment:
      {
         Word           comment;
         Boolean        doComment;
         Comment        gdiComment;

         /* get the comment word */
         GetWord( &comment );

         /* assume that we won't be generating an metafile comment */
         doComment = FALSE;

         /* determine the corresponding GDI comment for the comment */
         switch (comment)
         {
            case picPostScriptBegin:
            case picPostScriptEnd:
               EPSComment(comment);
               break;

            case picLParen:
            case picGrpBeg:
               doComment = TRUE;
               gdiComment.function = BEGIN_GROUP;
               break;

            case picRParen:
            case picGrpEnd:
               doComment = TRUE;
               gdiComment.function = END_GROUP;
               break;

            case picBitBeg:
               doComment = TRUE;
               gdiComment.function = BEGIN_BANDING;
               break;

            case picBitEnd:
               doComment = TRUE;
               gdiComment.function = END_BANDING;
               break;

            case picPolyBegin:
               /* indicate that we are in polygon mode, and reset buffer */
               polyMode = PARSEPOLY;
               polyParams = FRAMEPOLY;
               NewPolygon();
               break;

            case picPolyEnd:
               /* flush the polygon buffer and exit polygon mode */
               DrawPolyBuffer();
               polyMode = FALSE;
               break;

            case picPolyIgnore:
               /* see if we should reset the polygon buffer */
               if (polyMode == USEALTPOLY)
               {
                  /* use the alternate polygon definition to draw */
                  NewPolygon();
               }
               else
               {
                  /* otherwise, just use the current saved polygon buffer */
                  polyMode = SKIPALTPOLY;
               }
               break;

            case picTextEnd:
               /* set the global flag indicating we are exiting text mode */
               grafPort.txRotation = 0;
               grafPort.txFlip = QDFlipNone;
               textMode = FALSE;
               break;

            default:
               break;
         }

         /* if there is some comment to emit, then call GDI module */
         if (doComment)
         {
            /* make this a public comment */
            gdiComment.signature = PUBLIC;
            gdiComment.size = 0;

            /* call the gdi entry point */
            GdiShortComment( &gdiComment );
         }

         break;
      }

      case LongComment:
      {
         Word           comment;
         Integer        length;

         /* get the comment function */
         GetWord(&comment);

         /* determine what should be done with the comment */
         switch (comment)
         {
            case picPostScriptBegin:
            case picPostScriptEnd:
            case picPostScriptHandle:
            {
               if (EPSComment(comment) == 0)      /* not EPS? */
               {
                  GetWord( &length );             /* skip it */
               }
               else
               {
                  length = 0;                     /* EPS was already read */
               }
               break;
            }

            case picPolySmooth:
            {
               /* read the total length of comment */
               GetWord( &length );

               /* read polygon parameter mask and set flag bits */
               GetByte( &polyParams );
               polyParams &= MASKPOLYBITS;
               polyParams |= CHECK4SPLINE;
               length--;

               /* if we are to fill the polygon, indicate that fill required
                  just in case a PaintPoly() record appears before picPolyEnd */
               if (polyParams & FILLPOLY)
               {
                  /* or in the fill required bit */
                  polyParams |= FILLREQUIRED;
               }
               break;
            }

            case picTextBegin:
            {
               Byte  unusedAlignment;

               /* read the comment length */
               GetWord( &length );

               /* read in only relevant parameters - align, flip, rotation */
               GetByte( &unusedAlignment );
               GetByte( &grafPort.txFlip );
               GetWord( &grafPort.txRotation );
               length -= 4;

               /* set the global flag indicating we are in text mode.  The
                  only case this isn't true if for badly mangled SuperPaint
                  files that have invalid rotation and pt size information. */
               if( !(superPaintFile && badSuperPaintText) )
               {
                  textMode = TRUE;
                  textClipCheck = TRUE;
               }
               break;
            }

            case picTextCenter:
            {
               Fixed    textCenterX;
               Fixed    textCenterY;

               /* read the comment length */
               GetWord( &length );

               /* read y and x offsets to center of text rotation */
               GetFixed( &textCenterY );
               GetFixed( &textCenterX );
               length -= 8;

               /* copy only the highword of the fixed value to textCenter */
               textCenter.x = (short) (HIWORD( textCenterX ));
               textCenter.y = (short) (HIWORD( textCenterY ));

               /* make sure that the center is rounded, not truncated */
               if (LOWORD( textCenterX) & 0x8000)
                  textCenter.x++;

               if (LOWORD( textCenterY) & 0x8000)
                  textCenter.y++;

               /* indicate that text center needs to be re-computed */
               newTextCenter = TRUE;
               break;
            }

            case picAppComment:
            {
               DWord    signature;
               Word     function;
               Word     realFunc;

               /* read total comment length */
               GetWord( &length );

               /* make sure that there's enough space to read signature */
               if (length < sizeofMacDWord )
               {
                  /* if insufficient, just skip remaining data */
                  break;
               }

               /* read the signature of the application */
               GetDWord( &signature );
               length -= sizeofMacDWord ;

               /* is this PowerPoint 'PPNT' signature and function size enough? */
               if ((signature != POWERPOINT && signature != POWERPOINT_OLD) ||
                   (length < sizeofMacWord ))
               {
                  /* if SuperPaint signature matches, flag for text checks */
                  if (signature == SUPERPAINT)
                     superPaintFile = TRUE;

                  /* if wrong signature, or insufficient space, bail */
                  break;
               }

               /* read the application function ID */
               GetWord( &function );
               length -= sizeofMacWord ;

               /* mask out high-order bit to get "real" opcode */
               realFunc = function & ~PC_REGISTERED;

               /* determine what to do with the function specified */
               switch (realFunc)
               {
                  case PP_FONTNAME:
                  {
                     Byte     fontFamily;
                     Byte     charSet;
                     Byte     fontName[32];

                     /* font name from GDI2QD - read the LOGFONT info */
                     GetByte( &fontFamily );
                     GetByte( &charSet );
                     GetString( fontName );
                     length = 0;

                     /* call Gdi module to override font selection */
                     GdiFontName( fontFamily, charSet, fontName );
                     break;
                  }

                  case PP_HATCHPATTERN:
                  {
                     Integer  hatchIndex;

                     /* hatch pattern from GDI2QD - read hatch index value */
                     GetWord( (Word far *)&hatchIndex );
                     length = 0;

                     /* notify Gdi module of hatch to override fill pattern */
                     GdiHatchPattern( hatchIndex );
                     break;
                  }

                  case PP_BEGINFADE:
                  case PP_BEGINPICTURE:
                  case PP_DEVINFO:
                  {
                     DWord    cmntSize;
                     Boolean  doComment;

                     struct
                     {
                        Comment  gdiComment;
                        union
                        {
                           struct
                           {
                              Byte     version;
                              Boolean  isShape;
                              Integer  shapeIndex;
                              Integer  shapeParam1;
                              Boolean  olpNIL;
                              Rect     orectDR;
                              Rect     orect;
                              Word     shape;
                              Integer  shapeParam2;
                              Rect     location;
                              Integer  gradient;
                              Boolean  fromBackground;
                              Boolean  darker;
                              Integer  arcStart;
                              Integer  arcSweep;
                              Word     backR;
                              Word     backG;
                              Word     backB;
                              Rect     rSImage;
                           } fade;

                           Word        entity;

                           Point       unitsPerPixel;

                        } parm;

                     } cmnt;

#ifdef WIN32
                     memset( &cmnt, 0, sizeof( cmnt ));
#endif

                     /* so far, we won't be writting the Escape comment */
                     doComment = FALSE;

                     /* can we read the comment size? */
                     if (length < sizeofMacDWord )
                     {
                        /* couldn't read the size - just exit */
                        break;
                     }

                     /* read in a size field and validate */
                     GetDWord( &cmntSize );
                     length -= sizeofMacDWord ;

                     /* is this is an invalid PP3 size field (Word len) */
                     if (HIWORD( cmntSize ) != 0)
                     {
                        /* yes - just skip the remaining data */
                        break;
                     }

                     /* a valid comment was found - fill in header struct */
                     cmnt.gdiComment.signature = POWERPOINT;
                     cmnt.gdiComment.function = function;
                     cmnt.gdiComment.size = 0;

                     /* check if this is a zero-length comment */
                     if (cmntSize == 0)
                     {
                        /* make sure that the comment gets written */
                        doComment = TRUE;
                     }
                     /* process the begin fade comment */
                     else if (realFunc == PP_BEGINFADE)
                     {
                        /* can we read the version field? */
                        if (length < sizeof( Byte ))
                        {
                           /* can't read version - just bail */
                           break;
                        }

                        /* read the version field */
                        GetByte( &cmnt.parm.fade.version );
                        length -= sizeof( Byte );

                        /* if this is version 1 or 2, copy the bytes */
                        if (cmnt.parm.fade.version == 1 || cmnt.parm.fade.version == 2)
                        {
                           Handle         cmntHandle;
                           Comment far *  cmntLPtr;
                           Byte far *     cmntDataLPtr;
                           DWord          escapeSize;
                           Word           i;

                           /* determine size and allocate the required buffer */
                           escapeSize = cmntSize + sizeof( Comment );
                           cmntHandle = GlobalAlloc( GHND, escapeSize );

                           /* make sure allocation succeeded */
                           if (cmntHandle == NULL)
                           {
                              ErSetGlobalError( ErMemoryFull );
                              break;
                           }

                           /* lock the buffer and assign the comment header */
                           cmntLPtr = (Comment far *)GlobalLock( cmntHandle );

                           /* set the correct signature and parameters */
                           cmntLPtr->signature = POWERPOINT;
                           cmntLPtr->function = function;
                           cmntLPtr->size = cmntSize;

                           /* get pointer to the data and assign the version */
                           cmntDataLPtr = ((Byte far *)cmntLPtr) + sizeof( Comment );
                           *cmntDataLPtr++ = cmnt.parm.fade.version;

                           /* copy the byte over - start at 1 for version read */
                           for (i = 1; i < (Word)cmntSize; i++)
                           {
                              /* copy over byte and increment pointer */
                              GetByte( cmntDataLPtr++ );
                           }

                           /* put the comment into the metafile */
                           GdiEscape( MFCOMMENT, (Word)escapeSize, (StringLPtr)cmntLPtr );

                           /* release the memory allocated for the structure */
                           GlobalUnlock( cmntHandle );
                           GlobalFree( cmntHandle );
                        }
                        /* otherwise, perform swapping for PP3 fade */
                        else if (cmnt.parm.fade.version == 3)
                        {
                           Word     unusedWord;

                           if (length < ( 1 + (11 * sizeofMacWord) +
                                              ( 4 * sizeofMacRect) + 4
                                        ))
                           /* The above magic numbers come from:
                              GetByte
                              GetWord GetWord GetWord GetWord GetWord GetWord
                              GetWord GetWord GetWord GetWord GetWord
                              GetRect GetRect GetRect GetRect
                              GetBoolean GetBoolean GetBoolean GetBoolean
                              This is to make sure enough input left for
                              parameters - note that the Mac size is one less
                              than the GDI fade */
                           {
                              /* no - just bail */
                              break;
                           }

                           /* read in all remaining parameters */
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.isShape) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeIndex) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeParam1) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.olpNIL) );
                           GetByte( (Byte far *)(&unusedWord) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.orectDR) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.orect) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shape) );
                           GetWord( (Word far *)(&cmnt.parm.fade.shapeParam2) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.location) );
                           GetWord( (Word far *)(&cmnt.parm.fade.gradient) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.fromBackground) );
                           GetBoolean( (Boolean far *)(&cmnt.parm.fade.darker ) );
                           GetWord( (Word far *)(&cmnt.parm.fade.arcStart) );
                           GetWord( (Word far *)(&cmnt.parm.fade.arcSweep) );
                           GetWord( (Word far *)(&unusedWord) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backR) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backG) );
                           GetWord( (Word far *)(&cmnt.parm.fade.backB) );
                           GetRect( (Rect far *)(&cmnt.parm.fade.rSImage) );

                           /* determine the comment size */
                           cmnt.gdiComment.size = sizeof( cmnt.parm.fade );

                           /* make sure comment gets written */
                           doComment = TRUE;
                        }

                        /* no more bytes to read, flag that faded object started */
                        length = 0;
                        shadedObjectStarted = TRUE;
                     }
                     else if (realFunc == PP_BEGINPICTURE)
                     {
                        /* can we read the entity reference? */
                        if (length < sizeofMacWord )
                        {
                           /* no - just bail */
                           break;
                        }

                        /* read the entity reference */
                        GetWord( &cmnt.parm.entity );
                        length -= sizeofMacWord;

                        /* assign the correct comment size */
                        cmnt.gdiComment.size = sizeof( cmnt.parm.entity );

                        /* make sure comment gets written */
                        doComment = TRUE;
                     }
                     else if (realFunc == PP_DEVINFO)
                     {
                        /* can we read the units per pixel? */
                        if (length < sizeofMacPoint)
                        {
                           /* no - just bail */
                           break;
                        }

                        /* read the units per pixel */
                        GetPoint( (Point far *)&cmnt.parm.unitsPerPixel );
                        length -= sizeofMacPoint;

                        /* assign the size field */
                        cmnt.gdiComment.size = sizeof( cmnt.parm.unitsPerPixel );

                        /* make sure comment gets written */
                        doComment = TRUE;
                     }

                     /* write out the Gdi Escape comment */
                     if (doComment)
                     {
                        /* call the gdi entry point */
                        GdiEscape( MFCOMMENT, sizeof( Comment ) + (Word)cmnt.gdiComment.size, (StringLPtr)&cmnt );
                     }
                     break;
                  }

                  case PP_ENDFADE:
                  {
                     /* make sure that the BEGINFADE was put into metafile */
                     if (!shadedObjectStarted)
                     {
                        /* if not, then bail out */
                        break;
                     }
                     /* otherwise, just drop into the next case statement */
                  }

                  case PP_ENDPICTURE:
                  {
                     Comment     gdiComment;

                     /* make this a private PowerPoint comment */
                     gdiComment.signature = POWERPOINT;
                     gdiComment.function = function;
                     gdiComment.size = 0;

                     /* call the gdi entry point */
                     GdiShortComment( &gdiComment );

                     /* if this is the end of fade, mask out flag check */
                     if (realFunc == PP_ENDFADE)
                     {
                        /* end fade was processed successfully */
                        shadedObjectStarted = FALSE;
                     }
                     break;
                  }

                  default:
                     break;
               }
               break;
            }

            default:
            {
               /* any other comment is just skipped */
               GetWord( &length );
               break;
            }
         }

         /* skip any remaining bytes to be read */
         IOSkipBytes( length );
         break;
      }

      case opEndPic:
         /* do nothing - picture is closing */
         break;

      case HeaderOp:
      {
         Integer     version;
         Word        unusedReserved1;
         Fixed       hRes;
         Fixed       vRes;
         Rect        unusedRect;
         DWord       unusedReserved2;

         /* read in the the version to determine if OpenCPort() was used
            to open the picture, thus containing spatial resoultion info. */
         GetWord( (Word far *)&version );

         /* read any other parameters - will check later if they are valid.
            If version == -1, we are reading over the bounding rectangle. */
         GetWord( &unusedReserved1 );
         GetFixed( &hRes );
         GetFixed( &vRes );

         /* check if bounding rect and spatial resolution are changed */
         if (version == -2)
         {
            /* read in the optimal source rectangle */
            GetRect( &grafPort.portRect );

            /* use the integer portion of hRes for the resolution dpi */
            resolution = HIWORD( hRes );
         }
         else
         {
            /* otherwise, read an unused rectangle coordinate pair */
            GetRect( &unusedRect );
         }

         /* read the trailing unused reserved LongInt */
         GetDWord( &unusedReserved2 );

         break;
      }

      default:
         SkipData( currOpcodeLPtr );
         break;
   }

   /* set flag to skip ensuing font index if font name was provided */
   skipFontID = (currOpcodeLPtr->function == FontName);

   /* if global error, set opcode to opEndPic to exit main loop */
   if (ErGetGlobalError() != NOERR)
   {
      currOpcodeLPtr->function = opEndPic;
      currOpcodeLPtr->length = 0;
   }

}  /* TranslateOpcode */



private void SkipData( opcodeEntry far * currOpcodeLPtr )
/*-------------------*/
/* skip the data - the opcode won't be translated and Gdi module won't be
   called to create anything in the metafile */
{
   LongInt     readLength = 0;

   if (currOpcodeLPtr->length >= 0)
   {
      IOSkipBytes( currOpcodeLPtr->length );
   }
   else
   {
      readLength = 0;

      switch (currOpcodeLPtr->length)
      {
         case CommentSize:
         {
            Word  unusedFunction;

            GetWord( (Word far *)&unusedFunction );
            GetWord( (Word far *)&readLength );
            break;
         }

         case RgnOrPolyLen:
         {
            GetWord( (Word far *)&readLength );
            readLength -= 2;
            break;
         }

         case WordDataLen:
         {
            GetWord( (Word far *)&readLength );
            break;
         }

         case DWordDataLen:
         {
            GetDWord( (DWord far *)&readLength );
            break;
         }

         case HiByteLen:
         {
            readLength = (currOpcodeLPtr->function >> 8) * 2;
            break;
         }

      }  /* switch () */

      IOSkipBytes( readLength );

   }  /* else */

}  /* SkipData */



void OpenPort( void )
/*-----------*/
/* initialize the grafPort */
{
   /* set port version to unintialized state */
   grafPort.portVersion = 0;

   /* no polygons or regions saved yet */
   grafPort.clipRgn  = NIL;
   grafPort.rgnSave  = NIL;
   grafPort.polySave = NIL;

   /* initialize all patterns to old-style patterns */
   grafPort.bkPixPat.patType   = QDOldPat;
   grafPort.pnPixPat.patType   = QDOldPat;
   grafPort.fillPixPat.patType = QDOldPat;

   /* make patterns all solid */
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.bkPixPat.pat1Data, sizeof( Pattern ) );
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.pnPixPat.pat1Data, sizeof( Pattern ) );
   QDCopyBytes( (Byte far *)&SolidPattern,
                (Byte far *)&grafPort.fillPixPat.pat1Data, sizeof( Pattern ) );

   /* foreground/background set to black on white */
   grafPort.rgbFgColor  = RGB( 0x00, 0x00, 0x00 );    /* black */
   grafPort.rgbBkColor  = RGB( 0xFF, 0xFF, 0xFF );    /* white */

   /* various pen attributes */
   grafPort.pnLoc.x     = 0;                 /* pen location (0,0) */
   grafPort.pnLoc.y     = 0;
   grafPort.pnSize.x    = 1;                 /* pen size (1,1) */
   grafPort.pnSize.y    = 1;
   grafPort.pnVis       = 0;                 /* pen is visible */
   grafPort.pnMode      = QDPatCopy;         /* copy ROP */
   grafPort.pnLocHFrac  = 0x00008000;        /* 1/2 */

   /* font attributes */
   grafPort.txFont      = 0;                 /* system font */
   grafPort.txFace      = 0;                 /* plain style */
   grafPort.txMode      = QDSrcOr;
   grafPort.txSize      = 0;                 /* system font size */
   grafPort.spExtra     = 0;
   grafPort.chExtra     = 0;
   grafPort.txNumerator.x =                  /* text scaling ratio */
   grafPort.txNumerator.y =
   grafPort.txDenominator.x =
   grafPort.txDenominator.y = 1;
   grafPort.txRotation = 0;                  /* no rotation or flipping */
   grafPort.txFlip     = QDFlipNone;

   /* assume 72 dpi - this may be overridden in HeaderOp opcode */
   resolution = 72;

   /* private global initialization */
   polyMode = FALSE;
   textMode = FALSE;
   shadedObjectStarted = FALSE;
   superPaintFile = FALSE;

   /* text rotation variables */
   newTextCenter = FALSE;
   textCenter.x = textCenter.y = 0;

   /* allocate space for the polygon buffer */
   maxPoints = 16;
   polyHandle = GlobalAlloc( GHND, (maxPoints + 3) * sizeof( Point ) );
   if (polyHandle == NULL)
   {
      ErSetGlobalError( ErMemoryFull);
   }
   else
   {
      /* get pointer address and address for the polygon coordinate list */
      numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
      polyListLPtr = (Point far *)(numPointsLPtr + POLYLIST);
   }

}  /* OpenPort */


private void ClosePort( void )
/*--------------------*/
/* close grafPort and de-allocate any memory blocks */
{
   if (grafPort.clipRgn != NULL)
   {
      GlobalFree( grafPort.clipRgn );
      grafPort.clipRgn = NULL;
   }

   if (grafPort.rgnSave != NULL)
   {
      GlobalFree( grafPort.rgnSave );
      grafPort.rgnSave = NULL;
   }

   if (grafPort.polySave != NULL)
   {
      GlobalFree( grafPort.polySave );
      grafPort.polySave = NULL;
   }

   /* make sure that all the possible pixel pattern bitmaps are freed */
   if (grafPort.bkPixPat.patData != NULL)
   {
      GlobalFree( grafPort.bkPixPat.patMap.pmTable );
      GlobalFree( grafPort.bkPixPat.patData );
      grafPort.bkPixPat.patData = NULL;
   }

   if (grafPort.pnPixPat.patData != NULL)
   {
      GlobalFree( grafPort.pnPixPat.patMap.pmTable );
      GlobalFree( grafPort.pnPixPat.patData );
      grafPort.pnPixPat.patData = NULL;
   }

   if (grafPort.fillPixPat.patData != NULL)
   {
      GlobalFree( grafPort.fillPixPat.patMap.pmTable );
      GlobalFree( grafPort.fillPixPat.patData );
      grafPort.fillPixPat.patData = NULL;
   }

   /* deallocate the polygon buffer */
   GlobalUnlock( polyHandle );
   GlobalFree( polyHandle );

}  /* ClosePort */


private void NewPolygon( void )
/*---------------------*/
/* initialize the state of the polygon buffer - flush any previous data */
{
   /* initialize number of points and bounding box */
   numPoints = 0;
   polyBBox.left  = polyBBox.top    =  MAXINT;
   polyBBox.right = polyBBox.bottom = -MAXINT;

}  /* NewPolygon */


private void AddPolySegment( Point start, Point end )
/*-------------------------*/
/* Add the line segment to the polygon buffer */
{
   /* make sure that we are in polygon mode before adding vertex */
   if (polyMode == PARSEPOLY || polyMode == USEALTPOLY)
   {
      Point    pt;
      Byte     i;

      /* loop through both points ... */
      for (i = 0; i < 2; i++)
      {
         /* determine which point to process */
         pt = (i == 0) ? start : end;

         /* determine if we should expect a zero delta increment in both
            dimensions, implying that the quadratic B-spline definition will
            actually be rendered as a straight-edged polygon */
         if ((numPoints <= 1) || (polyMode == USEALTPOLY))
         {
            zeroDeltaExpected = FALSE;
         }

         /* check if we are expecting a zero delta from last point */
         if (zeroDeltaExpected && (polyParams & CHECK4SPLINE))
         {
            /* make sure we are adding a zero-length line segment */
            if ((start.x == end.x) && (start.y == end.y))
            {
               /* just skip including this in the polygon buffer */
               zeroDeltaExpected = FALSE;
               break;
            }
            else
            {
               /* MacDraw is rendering a smoothed (quadratic B-spline) - flag
                  the fact that we should use the polygon simulation */
               polyMode = USEALTPOLY;
            }
         }
         else
         {
            /* make sure the point is different from last point */
            if (numPoints == 0 ||
                polyListLPtr[numPoints - 1].x != pt.x ||
                polyListLPtr[numPoints - 1].y != pt.y)
            {
               /* make sure that we haven't reached maximum size */
               if ((numPoints + 1) >= maxPoints)
               {
                  /* expand the number of points that can be cached by 10 */
                  maxPoints += 16;

                  /* unlock to prepare for re-allocation */
                  GlobalUnlock( polyHandle);

                  /* re-allocate the memory handle by the given amount */
                  polyHandle = GlobalReAlloc(
                        polyHandle,
                        (maxPoints + 3) * sizeof( Point ),
                        GMEM_MOVEABLE);

                  /* make sure that the re-allocation succeeded */
                  if (polyHandle == NULL)
                  {
                     /* if not, flag global error and exit from here */
                     ErSetGlobalError( ErMemoryFull );
                     return;
                  }

                  /* get new pointer addresses the polygon coordinate list */
                  numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
                  polyListLPtr = (Point far *)(numPointsLPtr + POLYLIST);
               }

               /* insert the new point and increment number of points */
               polyListLPtr[numPoints++] = pt;

               /* union new point with polygon bounding box */
               polyBBox.left   = min( polyBBox.left,   pt.x );
               polyBBox.top    = min( polyBBox.top,    pt.y );
               polyBBox.right  = max( polyBBox.right,  pt.x );
               polyBBox.bottom = max( polyBBox.bottom, pt.y );

               /* toggle the state of zeroDeltaExpected - expect same point next time */
               zeroDeltaExpected = TRUE;
            }
         }
      }
   }

}  /* AddPolyPt */



private void DrawPolyBuffer( void )
/*-------------------------*/
/* Draw the polygon definition if the points were read without errors */
{
   /* copy the point count and bounding box into the memory block */
   *numPointsLPtr = sizeofMacWord + sizeofMacRect + (numPoints * sizeofMacPoint);
   *((Rect far *)(numPointsLPtr + BBOX)) = polyBBox;

   /* lock the polygon handle before rendering */
   GlobalUnlock( polyHandle );

   /* check if we should fill the polygon or if already done */
   if ((polyParams & FILLPOLY) && (polyParams & FILLREQUIRED))
   {
      Boolean  resetFg;
      Boolean  resetBk;
      RGBColor saveFg;
      RGBColor saveBk;

      /* set up fore- and background colors if they have changed */
      resetFg = (polyFgColor != grafPort.rgbFgColor);
      resetBk = (polyBkColor != grafPort.rgbBkColor);

      if (resetFg)
      {
         /* change the foreground color and notify Gdi of change */
         saveFg = grafPort.rgbFgColor;
         grafPort.rgbFgColor = polyFgColor;
         GdiMarkAsChanged( GdiFgColor );
      }
      if (resetBk)
      {
         /* change the background color and notify Gdi of change */
         saveBk = grafPort.rgbBkColor;
         grafPort.rgbBkColor = polyBkColor;
         GdiMarkAsChanged( GdiBkColor );
      }

      /* call gdi routine to draw polygon */
      GdiPolygon( GdiFill, polyHandle );

      if (resetFg)
      {
         /* change the foreground color and notify Gdi of change */
         grafPort.rgbFgColor = saveFg;
         GdiMarkAsChanged( GdiFgColor );
      }
      if (resetBk)
      {
         /* change the background color and notify Gdi of change */
         grafPort.rgbBkColor = saveBk;
         GdiMarkAsChanged( GdiBkColor );
      }

   }

   /* should the polygon be framed? */
   if ((polyParams & FRAMEPOLY) &&
       (grafPort.pnSize.x != 0) && (grafPort.pnSize.y != 0))
   {
      /* notify gdi that this is the same primitive */
      GdiSamePrimitive( polyParams & FILLPOLY );

      GdiPolygon( GdiFrame, polyHandle );

      /* notify gdi that this is no longer the same primitive */
      GdiSamePrimitive( FALSE );
   }

   /* get pointer address and address for the polygon coordinate list */
   numPointsLPtr = (Integer far *)GlobalLock( polyHandle );
   polyListLPtr  = (Point far *)(numPointsLPtr + POLYLIST);

}  /* DrawPolyBuffer */



private void AdjustTextRotation( Point far * newPt )
/*-----------------------------*/
/* This will calculate the correct text position if text is rotated */
{
   if (textMode && (grafPort.txRotation != 0) &&
      ((textCenter.x != 0) || (textCenter.y != 0)))
   {
      Point    location;
      Point    center;

      /* copy the new location to local variable */
      location = *newPt;

      /* ensure that a new text rotation was specified - recompute center */
      if (newTextCenter)
      {
         Real     degRadian;

         /* calculate the new center of rotation */
         center.x = textCenter.x + location.x;
         center.y = textCenter.y + location.y;

         /* calculate the sin() and cos() of the specified angle of rotation */
         degRadian = ((Real)grafPort.txRotation * TwoPi) / 360.0;
         degCos = cos( degRadian );
         degSin = sin( degRadian );

         /* use transformation matrix to compute offset to text center */
         textCenter.x = (Integer)((center.x * (1.0 - degCos)) +
                                  (center.y * degSin));

         textCenter.y = (Integer)((center.y * (1.0 - degCos)) -
                                  (center.x * degSin));

         /* indicate that the new text center was computed */
         newTextCenter = FALSE;
      }

      /* use transformation matrix to compute the new text basline location */
      newPt->x = (Integer)((location.x * degCos) -
                           (location.y * degSin) + textCenter.x);
      newPt->y = (Integer)((location.x * degSin) +
                           (location.y * degCos) + textCenter.y);
   }

}  /* AdjustTextRotation */



/****
 *
 * EPSComment(comment)
 * Encapsulated PostScript Handler which translates Mac EPS to GDI EPS.
 * This routine has intimate knowledge of the implementation of both
 * Mac and GDI EPS filters. It processes Mac PostScript comments.
 *
 * returns:
 *   >0      successfully parsed EPS data
 *    0      not EPS comment
 *   <0      error
 *
 * How the EPS filter works:
 * The Mac EPS filter uses special features in the LaserWriter driver
 * to send the PICT bounding box to the printer whre it is examined
 * by PostScript code. The filter outputs a preamble which is a
 * combination of QuickDraw and PostScript. This preamble is sent
 * before the PostScript date from the EPS file. It sets the pen
 * position for opposing corners of the PICT bounding box using
 * QuickDraw and reads the pen position back in PostScript. Any
 * transformations which have been set up in QuickDraw by the
 * application to position or scale the picture will be applied
 * to the coordinates of the bounding box sent by the preamble.
 * PostScript code determines the transformation necessary to map the
 * EPS bounding box onto the physical bounding box read from
 * QuickDraw. These transformations are then applied to the PostScript
 * picture when it is displayed.
 *
 * Operation of the GDI EPS filter is very similar except that it
 * outputs a combination of GDI and PostScript.
 *
 * Implementation:
 * The code can be in one of several states. Recognition of specific
 * PostScript strings causes transition between states.
 * PS_NONE     Initial state, indicates no PostScript has been seen yet
 *             In this state, QuickDraw to GDI translation proceeds
 *             normally but PostScript data is examined.
 *             When a PostScript record is found with the string
 *             "pse\rpsb\r", the start of the PostScript preamble
 *             has been found and the program goes into state PS_PREAMBLE.
 * PS_PREAMBLE All PostScript encountered in this state is ignored
 *             PostScript record starting with the string "[" is found.
 *             This is the PostScript bounding box specification.
 *             As soon as we see the bounding box, we have enough
 *             information to output the GDI EPS preamble and we go
 *             to state PS_BBOX.
 * PS_BBOX     PostScript is still ignored until a record beginning
 *             with "%!PS" is found, putting us into state PS_DATA.
 * PS_DATA     In this state, PostScript records are not ignored because
 *             PostScript seen now is from the EPS file. These records
 *             are translated to GDI POSTSCRIPT_DATA escapes.
 *             If the PostScript trailer "pse\rpsb\r" is encountered,
 *             it is ignored. If a PostScriptEnd comment is found
 *             it signals the end of the EPS data. We output the
 *             GDI PostScript trailer and we go back to state PS_NONE.
 *
 * Comment PostScriptHandle:
 *   if state == PS_NONE & data == "pse\rpsb\r"
 *      state = PS_PREAMBLE
 *   else if state == PS_PREAMBLE & data == "[ %d %d %d %d ]"
 *      state = PS_BBOX; output GDI EPS preamble
 *   else if state == PS_BBOX & data begins with "%!PS"
 *      state = PS_DATA
 *   else if state == PS_DATA
 *      if data == "pse\rpsb\r" ignore (is Mac PS trailer)
 *      else output PostScript data to GDI
 *
 * Comment PostScriptEnd:
 *      if state == PS_DATA
 *         state = PS_NONE; output GDI EPS trailer; exit
 *
 * QuickDraw primitives:
 *      translate QuickDraw to GDI normally
 *
 ****/
#define   PS_ERROR   (-1)
#define   PS_NONE      0
#define   PS_PREAMBLE  1
#define   PS_BBOX      2
#define   PS_DATA      3
#define   PS_ENDWAIT   4

private Integer EPSComment(Word comment)
{
static Integer state = PS_NONE;

   switch (comment)
     {
      case picPostScriptBegin:
      break;

      case picPostScriptEnd:
      if (state == PS_DATA)
        {
         GdiEPSTrailer();                  // output GDI trailer
         state = PS_NONE;                  // end, successful translation
        }
      break;

      case picPostScriptHandle:
      if ((state = EPSData(state)) < 0)    // process EPS data
         return (-1);                      // error during processing
       break;

       default:                           // not a PostScript comment
       return (0);
      }
   return (1);
}

/****
 *
 * Integer EPSData(Integer state)
 * Process EPS Data found in the PostScriptHandle comment.
 * What we do with the EPS data depends on the current state
 * we are in and what the PostScript data looks like.
 *
 * State        PS Data         Action
 * ----------------------------------------------------------------
 * PS_NONE      PS preamble string   state = PS_BEGIN
 * PS_PREAMBLE  [ ... ]              state = PS_BBOX, output GDI preamble
 * PS_BBOX      %!PS                 state = PS_DATA
 * PS_DATA      PS preamble string   ignore, is Mac PS trailer
 * PS_DATA      PS data              output as GDI PS data
 *
 * The Mac PostScript preamble string indicates that the PostScript
 * data was from the Mac EPS filter. It puts us into PS_PREAMBLE state
 * where we look for the bounding box specification (which begins
 * with "["). When this is found, we go to state PS_BBOX and output
 * the GDI EPS preamble using the bounding box.   From PS_BBOX we can
 * go into state PS_DATA when we find the record beginning with !PS
 * which designates the start of the read EPS data.
 *
 * Once in state PS_DATA, PostScript data is buffered up into GDI
 * printer escapes and output to the GDI stream. These are the only
 * PostScript records that are translated - all others are ignored.
 *
 ****/
private Integer EPSData(Integer state)
{
GLOBALHANDLE  h;
PSBuf far*    psbuf;
char far*     ptr;
Word          len = 0;
Rect          ps_bbox;

/*
 * Allocate a buffer for the PostScript data. The first WORD
 * of the buffer gives the number of bytes of PostScript data.
 * The actual data follows. This is the format needed for
 * the GDI Escape call.
 */
   GetWord(&len);                       // length of EPS comment
   if ((h = GlobalAlloc(GHND, (DWORD) len + sizeof(PSBuf))) == 0)
     {
      ErSetGlobalError(ErMemoryFull);   // memory allocation error
      return (-1);
     }
   psbuf = (PSBuf far *) GlobalLock(h);
   psbuf->length = len;                 // save byte length
   ptr = (char far *) &psbuf->data;     // -> PostScript data
   while (len-- != 0) GetByte(ptr++);   // read PS data into buffer
   *ptr = 0                ;            // null terminate it
   ptr = (char far *) &psbuf->data;     // -> PostScript data

   /* If this is a superPaint file, and postscript is being processed,
      check if this is a situation where text could be mangled beyond
      belief and requires adjustment in the parsing process. */
   if (superPaintFile && state == PS_NONE)
   {
      char save;
      Word start = lstrlen( SUPERPAINT_TEXTSTARTJUNK );
      Word stop  = lstrlen( SUPERPAINT_TEXTSTOPJUNK );

      /* Assume that this text is OK for now */
      badSuperPaintText = FALSE;

      /* If this buffer is long enough to hold the begin and end of the bogus
         test Postcript commands (dealing with rotation and shearin)... */
      if (psbuf->length > (start + stop))
      {
         /* Create a string and compare for the beginning sequence and ending
            sequences.  Restore the null "C" terminator after finished. */
         save = *(ptr + start);
         *(ptr + start) = 0;
         badSuperPaintText = (lstrcmp(ptr, SUPERPAINT_TEXTSTARTJUNK) == 0 &&
                              lstrcmp(ptr + psbuf->length - stop, SUPERPAINT_TEXTSTOPJUNK) == 0);
         *(ptr + start) = save;
      }
   }

/*
 * If PostScript preamble is found in state PS_NONE we can advance to
 * state PS_PREAMBLE. If it is found again before state PS_DATA,
 * we have an incorrect sequence and should not translate this EPS.
 * On the MAC, the preamble is the same as the trailer and, if found
 * during state PS_ENDWAIT, it signals the end of EPS processing.
 */
   if (lstrcmp(ptr, MAC_PS_PREAMBLE) == 0)
      switch (state)
     {
      case PS_NONE:                    // waiting for preamble
      state = PS_PREAMBLE;
      break;

      case PS_DATA:                    // ignore Mac trailer
      break;

      default:                        // error if found in other states
      state = PS_NONE;                // abort EPS processing
      break;
     }
/*
 * PostScript date was not MAC EPS preamble. Process other states
 */
   else switch (state)
     {
      case PS_PREAMBLE:               // waiting for bbox
      if (EPSBbox(psbuf, &ps_bbox))
        {
         GdiEPSPreamble(&ps_bbox);
         state = PS_BBOX;             // parsed bbox, wait for EPS data
        }
      break;

      case PS_BBOX:                   // waiting for !PS
      if ((ptr[0] == '%') &&
          (ptr[1] == '!') &&
          (ptr[2] == 'P') &&
          (ptr[3] == 'S'))
         state = PS_DATA;             // found start of EPS data
      else break;

      case PS_DATA:                   // output EPS data to GDI
      if (lstrcmp(ptr, MAC_PS_TRAILER) != 0)
        GdiEPSData(psbuf);            // but ignore PS trailer
      state = PS_DATA;
      break;
     }
   GlobalUnlock(h);
   GlobalFree(h);                     // free PostScript buffer
   return (state);
}

/****
 *
 * Boolean EPSBbox(PSBuf, Rect far *)
 * Parse EPS bounding box string [ %d %d %d %d ] and store corners
 * of bounding box in given rectangle.
 *
 * returns:
 *   0 = cannot parse bounding box descriptor
 *   1 = bounding box successfully parsed
 *
 ****/
private Boolean EPSBbox(PSBuf far *psbuf, Rect far *bbox)
{
char   far*   ptr = psbuf->data;

   while ((*ptr == ' ') || (*ptr == '\t') || (*ptr == '\n'))
      ++ptr;
   if (*ptr++ != '[') return (0);
   if (!(ptr = parse_number(ptr, &bbox->left))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->top))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->right))) return (0);
   if (!(ptr = parse_number(ptr, &bbox->bottom))) return (0);
   if (*ptr != ']') return(0);
   return(1);
}

private char far* parse_number(char far* ptr, Integer far *iptr)
{
Boolean   isneg = 0;         // assume positive
Integer   n = 0;

   while ((*ptr == ' ') || (*ptr == '\t'))
      ++ptr;                           // skip whitespace
   if (*ptr == '-')                    // number is negative?
     {
      isneg = 1;
      ++ptr;
     }
   if (!IsCharDigit(*ptr)) return(0);     // digit must follow
   do n = n * 10 + (*ptr++ - '0');
   while (IsCharDigit(*ptr));
   if (*ptr == '.')                   // skip any digits following decimal pt
   {
      do ++ptr;
      while (IsCharDigit(*ptr));
   }
   while ((*ptr == ' ') || (*ptr == '\t'))
      ++ptr;                          // skip whitespace
   if (isneg) n = -n;                 // remember the sign
   *iptr = n;
   return (ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\qd2gdi.h ===
/****************************************************************************

                   QuickDraw PICT Import Filter

*****************************************************************************

   This file contains the interface for the QuickDraw import filter 
   that reads Mac pictures from disk and/or memory.  In addition to the
   Aldus filter interface, it also supports a parameterized interface
   for Microsoft applications to control some conversion results.

****************************************************************************/

/*--- Possible Aldus-defined error code returns ---*/

#define NOERR              0     // Conversion succeeded

#define IE_NOT_MY_FILE     5301  // Invalid version (not version 1 or 2 PICT)
                                 // Invalid QD2GDI structure version (greater than 2)
                                 // Ill-formed PICT header record sequence

#define  IE_TOO_BIG        5302  // Image extents exceed 32K

#define IE_BAD_FILE_DATA   5309  // Image bounding box is empty
                                 // Attempt to read past end of picture
                                 // Corrupted input file
                                 // Zero-length record

#define  IE_IMPORT_ABORT   5310  // Opening of source image failed
                                 // Read failure (network failure, floppy popped)
                                 // Most I/O errors

#define IE_MEM_FULL        5311  // CreateMetaFile() failure
                                 // CloseMetaFile() failure
                                 // Unable to allocate memory (out of memory)

#define IE_MEM_FAIL        5315  // Handle lock failure

#define IE_NOPICTURES      5317  // Empty bounding rectangle or nothing drawn

#define IE_UNSUPP_VERSION  5342  // User-defined abort performed


/*--- Aldus-defined file access block ---*/

typedef DWORD FILETYPE;

typedef struct 
{
   unsigned slippery : 1;  /* TRUE if file may disappear. */
   unsigned write : 1;     /* TRUE if open for write. */
   unsigned unnamed : 1;   /* TRUE if unnamed. */
   unsigned linked : 1;    /* Linked to an FS FCB. */
   unsigned mark : 1;      /* Generic mark bit. */
   FILETYPE fType;         /* The file type. */
#define IBMFNSIZE 124
   short    handle;        /* MS-DOS open file handle. */
   char     fullName[IBMFNSIZE]; /* Device, path, file names. */
   DWORD    filePos;    /* Our current file posn. */
} FILESPEC, FAR *LPFILESPEC;


/*--- Aldus-defined picture info structure ---*/

typedef struct {
   HANDLE   hmf;           /* Global memory handle to the metafile */
   RECT     bbox;          /* Tightly bounding rectangle in metafile units */
   DC       inch;          /* Length of an inch in metafile units */
} PICTINFO;

/*--- Preferences memory block ---*/

typedef struct                   /* "old" version 1 USERPREFS */
{
   char     signature[6];
   WORD     version;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     charLock;
   BYTE     nonRectRegionAction;
   BOOL     PICTinComment;
   BOOL     optimizePP;
   WORD     lineClipWidthThreshold;
   WORD     reserved[6];   
} USERPREFS_V1, FAR *LPUSERPREFS_V1;


typedef struct                   /* current version 3 USERPREFS */
{
   char     signature[6];
   WORD     version;
   WORD     size;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     nonRectRegionAction;
   BOOL     optimizePP;
   BYTE     noRLE;         // new (split out from reserved[0] in version 3)
   BYTE     reservedByte;  // rest of first reserved word
   WORD     reserved[5];

} USERPREFS, FAR * LPUSERPREFS;


/*********************** Exported Function Definitions **********************/

#ifdef WIN32
int WINAPI GetFilterInfo( short PM_Version, LPSTR lpIni, 
                          HANDLE FAR * lphPrefMem, 
                          HANDLE FAR * lphFileTypes );
#else
int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni, 
                              HANDLE FAR * lphPrefMem, 
                              HANDLE FAR * lphFileTypes );
#endif
/* Returns information about this filter. 
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */


#ifdef WIN32
void WINAPI GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#else
void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
#endif
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */


#ifdef WIN32
short WINAPI ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                       PICTINFO FAR * lpPict, HANDLE hPrefMem );
#else
short FAR PASCAL ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                           PICTINFO FAR * lpPict, HANDLE hPrefMem );
#endif
/* Import the metafile in the file indicated by the lpFileSpec. The 
   metafile generated will be returned in lpPict. */


#ifdef WIN32
short WINAPI ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                               PICTINFO FAR * lpPict, HANDLE hPrefMem,
                               DWORD dwSize, LPSTR lpMetafileName );
#else
short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName );
#endif
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */

#ifdef WIN32
short WINAPI QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#else
short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
#endif
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\daytona\makefile.inc ===
obj\$(TARGET_DIRECTORY)\olecnv32.def: olecnv32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\chicago\makefile.inc ===
obj\*\olecnv32.def: olecnv32.src

olecnv32.sym:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oledbg\oledbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oledbg.cxx
//
//  Contents:   OLE debugger extention DLL
//
//  Classes:
//
//  Functions:
//
//  History:    8-05-94   kevinro   Created
//
//----------------------------------------------------------------------------
extern "C" {
#undef DBG
#define DBG 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <rpc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <oledbg.h>

#pragma hdrstop

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

//
char achTokenBuf[1024];
char *pszTokenNext = NULL;
char *pszToken = NULL;

void InitTokenStr(LPSTR lpszString)
{
    if (lpszString)
    {
	strcpy(achTokenBuf,lpszString);
    }
    else
    {
	achTokenBuf[0]=0;
    }

    pszTokenNext = achTokenBuf;
    pszToken = NULL;
}

char *NextToken()
{
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMemory
//
//  Synopsis:   Reads memory from the debuggee
//
//  Effects:
//
//  Arguments:  [pvAddress] --
//		[cbMemory] --
//		[pvLocalMemory] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    ULONG       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteMemory
//
//  Synopsis:   Writes memory to the debuggee
//
//  Effects:
//
//  Arguments:  [pvLocalMemory] --
//		[cbMemory] --
//		[pvAddress] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    ULONG       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());
}
#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define FreeHeap(x) 	RtlFreeHeap(RtlProcessHeap(), 0, x)


DWORD
GetTlsEntry(ULONG       TlsValue,
            PVOID *     ppvValue)
{
    NTSTATUS                    Status;
    THREAD_BASIC_INFORMATION    ThreadInfo;
    ULONG                       cbReturned;
    PVOID                       *Slot;
    PTEB                        Teb;

    Status = NtQueryInformationThread(  hDbgThread,
                                        ThreadBasicInformation,
                                        &ThreadInfo,
                                        sizeof(ThreadInfo),
                                        &cbReturned);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Teb = (PTEB) AllocHeap(sizeof(TEB));

    ReadMemory(ThreadInfo.TebBaseAddress, sizeof(TEB), Teb);

    Slot = &Teb->TlsSlots[TlsValue];
    *ppvValue = *Slot;

    FreeHeap(Teb);

    return(0);

}

void ShowBinaryData(PBYTE   pData,
                    DWORD   cbData)
{
    DWORD                   i;
    char                    line[20];
    PNTSD_EXTENSION_APIS    lpExt = pExtApis;

    line[16] = '\0';
    if (cbData > 65536)
    {
        ntsdPrintf("ShowBinaryData:  Data @%x is said to be %d bytes in length\n");
        ntsdPrintf("                 Rejecting request.  Corrupt data\n");
        return;
    }
    for (; cbData > 0 ; )
    {
        for (i = 0; i < 16 && cbData > 0 ; i++, cbData-- )
        {
            ntsdPrintf(" %02x", (unsigned) *pData);
            if (isprint(*pData))
                line[i] = *pData;
             else
                line[i] = '.';
            pData++;
        }
        if (i < 16)
        {
            for (;i < 16 ; i++ )
            {
                ntsdPrintf("   ");
                line[i] = ' ';
            }
        }
        ntsdPrintf("\t%s\n",line);
        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }

    }
}



BOOL
IsDebug_olethk32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("olethk32!oledbgCheck_olethk32");

    if (addr == 0)
    {
	ntsdPrintf("warning: olethk32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

     if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_olethk32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for olethk32\n");
	return(0);
    }
    return(1);
}


BOOL
IsDebug_ole32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("ole32!oledbgCheck_ole32");
    if (addr == 0)
    {
	ntsdPrintf("warning: ole32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

    if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_ole32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for ole32\n");
	return(0);
    }
    return(1);
}

//+---------------------------------------------------------------------------
//
//  Function:   DumpVtbl
//
//  Synopsis:   Dumps a vtbl to the debugger
//
//  Effects:	Given a pointer to a vtbl, output the name of the vtbl, and
//		its contents to the debugger.
//
//  Arguments:  [pvtbl] -- Address of vtbl
//		[pszCommand] -- Symbolic expression for pvtbl
//
//  History:    8-07-94   kevinro   Created
//
//----------------------------------------------------------------------------
extern "C"
void
DumpVtbl(PVOID pvtbl, LPSTR pszCommand)
{
   DWORD dwVtblOffset;
   char achNextSymbol[256];

   if (pvtbl == 0)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s has a vtbl pointer of NULL\n",pszCommand);
       return;
   }

   if ((DWORD)pvtbl == 0xdededede)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s may be deleted memory. pvtbl==0xdededede\n",pszCommand);
       return;
   }

   // This value points at the VTBL. Find a symbol for the VTBL
   ntsdGetSymbol((LPVOID)pvtbl,(UCHAR *)achNextSymbol,(LPDWORD)&dwVtblOffset);

   // If the dwVtblOffset is not zero, then we are pointing into the table.
   // This could mean multiple inheritance. We could be tricky, and try to
   // determine the vtbl by backing up here. Maybe later
   if (dwVtblOffset != 0)
   {
       ntsdPrintf("Closest Previous symbol is %s at 0x%x (offset -0x%x)\n",
		  achNextSymbol,
		  (DWORD)pvtbl - dwVtblOffset,
		  dwVtblOffset);
       return;
   }
   ntsdPrintf("0x%08x -->\t %s\n",pvtbl,achNextSymbol);
   // vtbl entries should always point at functions. Therefore, we should
   // always have a displacement of zero. To check for the end of the table
   // we will reevaluate the vtbl pointer. If the offset isn't what we
   // expected, then we are done.

   DWORD dwIndex;
   for (dwIndex = 0 ; dwIndex < 4096 ; dwIndex += 4)
   {
       DWORD dwVtblEntry;

       ntsdGetSymbol((LPVOID)((DWORD)pvtbl+dwIndex),
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       if (dwVtblOffset != dwIndex)
       {
	   //
	   // May have moved on to another vtable
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Moved to another table?\n");
#endif
	   return;
       }

       if (ReadMemory((LPVOID)((DWORD)pvtbl+dwIndex),
		      sizeof(dwVtblEntry),
		      (PVOID)&dwVtblEntry))
       {
	   //
	   // Must be off the end of a page or something.
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("End of page?\n");
#endif
	   return;
       }

       // If the function is at zero, then must be at end of table
       if (dwVtblEntry == 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("dwVtblEntry is zero. Must be end of table\n");
	   return;
#endif

       }

       // Now, determine the symbol for the entry in the vtbl
       ntsdGetSymbol((LPVOID)dwVtblEntry,
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       // If it doesn't point to the start of a routine, then it
       // probably isn't part of the vtbl
       if (dwVtblOffset != 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Doesn't point to function?\n");
#endif
	   return;
       }

       ntsdPrintf("   0x%08x\t %s\n",dwVtblEntry,achNextSymbol);
   }
   ntsdPrintf("Wow, there were at least 1024 entries in the table!\n");

}

extern "C"
void
punk(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID punk;
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the object
   punk = (PVOID) ntsdGetExpr(pszCommand);

   if (punk == NULL)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s is not a valid pointer\n",pszCommand);
       return;
   }
   // Now, read the first DWORD of this memory location
   // This is a pointer to the table
   if (ReadMemory(punk,sizeof(pvtbl),(PVOID)&pvtbl))
   {
       ntsdPrintf("Couldn't read memory at %x\n",punk);
       return;
   }

   DumpVtbl(pvtbl,pszCommand);

}
extern "C"
void
vtbl(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the table
   pvtbl = (PVOID) ntsdGetExpr(pszCommand);
   DumpVtbl(pvtbl,pszCommand);
}

extern "C"
void
expr(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    InitDebugHelp(hProcess, hThread, lpExt);

    UCHAR symbol[256];
    DWORD expr;
    DWORD disp;

    expr = ntsdGetExpr(pszCommand);

    ntsdGetSymbol((LPVOID)expr,(UCHAR *)symbol,(LPDWORD)&disp);

    ntsdPrintf("expr: %s = %x (%d) %s + %d\n",pszCommand,expr,expr,symbol,disp);

}

extern "C"
void
isdbg(  HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    if (IsDebug_ole32())
    {
	ntsdPrintf("ole32.dll is debug\n");
    }
    if (IsDebug_olethk32())
    {
	ntsdPrintf("olethk32.dll is debug\n");
    }
}

extern "C"
void
help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    ntsdPrintf(" help		\tThis Message\n");
    ntsdPrintf(" isdbg		\tDetermine if DLL's are debug\n");
    ntsdPrintf(" punk <expr>	\tDump IUnknown vtbl\n");
    ntsdPrintf(" vtbl <expr>	\tDump vtbl\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oledbg\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olecnv32\toolbox.h ===
/************** ToolBox.h ***************************************************

  The purpose of ToolBox is to isolate all the Windows vs Mac Toolbox
  DIFFERENCES THAT WE CARE TO ISOLATE AT ALL.  Always include this module
  instead of including Windows.h or "using" MemTypes.P, etc.

*****************************************************************************/

#ifdef WIN32
#define huge
#endif

/************** Includes ****************************************************/

#define   NOHELP        /* No help engine stuff */
#define   NOSOUND       /* No sound stuff */
#define   NODRAWFRAME   /* No DrawFrame stuff */
#define   NOCOMM        /* Disable Windows communications interface */
#define   NOKANJI       /* Disable Windows Kanji support */
#define   OEMRESOURCE   /* Enable access to OEM resources (checkmark, etc.) */

#include "windows.h"

#define sizeofMacDWord     4
#define sizeofMacPoint     4
#define sizeofMacRect      8
#define sizeofMacWord      2

/************** Public Data *************************************************/

#define Far far                 /* for use with function parameters only! */
#define Pascal                  /* default set with compiler options */

#define NA         0L           /* use for 'Not Applicable' parms */
#define NIL        NULL         /* alternate name for empty pointer */
#define cNULL      '\0'         /* alternate name for null char     */
#define sNULL      ""           /* alternate name for null string   */
#define NOERR      0            /* success flag */


typedef unsigned   Char;        /* MPW unsigned char */
typedef char       SignedByte;  /* MPW signed char */
typedef int        Integer;     /* MPW Pascal integer. Hide int type of compiler*/
typedef long       LongInt;     /* MPW Pascal name */
typedef double     Real;        /* MPW Pascal name */
typedef BYTE       Byte;        /* MPW Byte.  Hide Win/PM unsigned char type */
typedef unsigned   Word;        /* MPW Word.  Hide Win/PM unsigned int  type */
typedef DWORD      DWord;       /* Hide Win/PM unsigned long */
typedef LongInt    Fixed;       /* MPW fixed point number */
typedef LongInt    Fract;       /* MPW fraction point number [-2,2) */
typedef void *     Ptr;         /* MPW opaque pointer */
typedef void far * LPtr;        /* Opaque far pointer */
typedef HANDLE     Handle;      /* MPW opaque handle */
typedef char       Str255[256]; /* MPW string type.  255 characters + null */
typedef char       String[];    /* Indeterminate length string */
typedef char       StringRef;   /* AR: String reference type? */
typedef NPSTR      StringPtr;   /* MPW string type. Hide Win/PM string pointer*/
typedef LPSTR      StringLPtr;  /* Hide Win/PM string far pointer type */
typedef HANDLE     StringHandle;/* MPW string handle */
typedef BOOL       Boolean;     /* MPW Pascal name */
typedef unsigned   BitBoolean;  /* Boolean type that can be used as a bitfield */
typedef RECT       Rect;        /* MPW rectangle structure */
typedef POINT      Point;       /* MPW point structure */
typedef DWORD      Size;        /* MPW size.  AR: size_t if included stddef.h */
typedef WORD       Param1;      /* Hide Windows/PM message param differences */
typedef LONG       Param2;      /* Hide Windows/PM message param differences */
typedef unsigned   Style;       /* MPW text style */
typedef Integer    Interval;    /* Array/RunArray/Text intervals */
typedef Integer    OSErr;       /* OS Error */

typedef union
{  Handle handle;
   Ptr    ptr;
   LPtr   lptr;
   Word   word;
   DWord  dword;
}  LongOpaque;                  /* A 4-byte quantity whose type is unknown */

#define INDETERMINATE 1

#define  TwoPi          (2.0*3.141592)    /* math constant */

/* The following macro defeats the compiler warning for unreferenced vars.
   Use it only where a statement would be permitted in C. */
#define UnReferenced( v )  if(v)

#define private   static                /* alternate (understandable) name */

/* largest Integer value, expressed in an implementation-independent way */
#define MAXINT    ((Integer) (((Word) -1) >> 1))

/* MAXLONG is defined in winnt.h as 0x7FFFFFFF */
#ifndef WIN32
#define MAXLONG   ((LongInt) (((DWord) -1) >> 1))
#endif

Rect        NULLRECT;      /* empty rectangle */
Rect        UNIRECT;       /* rectangle encompassing the universe */
Point       ZEROPT;        /* zero (0,0) point */
Point       UNITPT;        /* unit (1,1) point */

void PASCAL BreakPoint( void );
/* Execute a software breakpoint to the debugger if it is loaded, otherwise
   continue execution. */

/* private */ void AssertionFailed( String file, Integer line, String expression );
/* Print the fact that 'expression' was not true at 'line' in 'file' to the
   'logFile', then execute a software breakpoint.  Treat this function as
   private to ToolBox; it is only exported because Assert() is a macro. */

#define /* void */ Assert( /* Boolean */ expression )                        \
/*=====================*/                                                    \
/* Provides an Assert function for use with Windows.  Note that the          \
   expression in the Assert should NOT be a function/procedure call which    \
   MUST be called, since Asserts may be disabled, disabling the function or  \
   procedure call.  Also note that Asserts expand inline, therefore to       \
   minimize code size in cases where several Asserts are done at once, you   \
   can code the Assert as                                                    \
                                \
   Assert( assertion1 && assertion2 ... );                              \
                                \
   This has the drawback of possibly not fitting on a source line or         \
   localizing an assertion failure accurately enough.   */                   \
{                                                                            \
   if( !( expression ) )                                                     \
      AssertionFailed( _FILE_, __LINE__, #expression );                    \
}  /* Assert */

#define /* Size */ Sizeof( expression )                                      \
/*======================*/                                                   \
/* Return the Size of the 'expression' */                                    \
((Size) sizeof( expression ))

#define /* Word */ ToWord( /*DWord*/ d )                                     \
/*=====================*/                                                    \
( LOWORD( d ))

#define /* Integer */ ToInteger( /* LongInt */ l )                           \
/*===========================*/                                              \
((Integer) (LOWORD( l )))


#define /* Boolean */ RectEqual( /* Rect */ a, /* Rect */ b )                \
/*===========================*/                                              \
/* Return TRUE iff Rect 'a' is identical to Rect 'b'. */                     \
(Boolean) EqualRect( &(a), &(b) )

/* HGET(pointer, field, structure name, type)
 * Accesses a field from a structure without using the "->"
 * construct. This is because "->" has a bug and does not work
 * correctly with huge pointers. Instead we use "+" and obtain
 * the offset of the structure field by casting 0 to be a
 * pointer to the structure. The last argument is the type of
 * the structure field.
 */
#define HGET( p, f, s, t ) ( *(( t huge * ) ((( char huge * )p ) + (( WORD ) &((( s * )0 )->f )))))

#define /* Integer */ Width( /* Rect */ r )                                  \
/*=======================*/                                                  \
/* Return width of the rectangle 'r'. */                                     \
((r).right - (r).left)

#define /* Integer */ Height( /* Rect */ r)                                  \
/*========================*/                                                 \
/* Return height of the rectangle 'r'. */                                    \
((r).bottom - (r).top)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oledbg\oledbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------

#include <ntsdexts.h>


extern "C" PNTSD_EXTENSION_APIS    pExtApis;
extern "C" HANDLE                  hDbgThread;
extern "C" HANDLE                  hDbgProcess;
extern "C" char			  *pszToken;
extern "C" char			  *pszTokenNext;


#define ntsdPrintf      (pExtApis->lpOutputRoutine)
#define ntsdGetSymbol       (pExtApis->lpGetSymbolRoutine)
#define ntsdGetExpr         (pExtApis->lpGetExpressionRoutine)
#define ntsdCheckC          (pExtApis->lpCheckControlCRoutine)

#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

extern void InitTokenStr(LPSTR lpzString);
extern DWORD ReadMemory( PVOID pvAddress, ULONG cbMemory, PVOID pvLocalMemory);
extern DWORD WriteMemory(PVOID pvLocalMemory, ULONG cbMemory, PVOID pvAddress);
extern void ShowBinaryData(PBYTE   pData,DWORD   cbData);
extern BOOL IsDebug_olethk32();
extern BOOL IsDebug_ole32();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\idl\chicago\makefile.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Greg Jensenworth


!ENDIF


SDKINC=$(_NTDRIVE)$(_NTROOT)\public\sdk\inc
DCOMIDL=$(_NTDRIVE)$(_NTROOT)\private\dcomidl

unknwn.idl : $(SDKINC)\unknwn.idl
    -erase proxy\unknwn_p.c
    copy $(SDKINC)\unknwn.idl .

objidl.idl : $(SDKINC)\objidl.idl
    -erase proxy\objidl_p.c
    copy $(SDKINC)\objidl.idl .

oleidl.idl : $(SDKINC)\oleidl.idl
    -erase proxy\oleidl_p.c
    copy $(SDKINC)\oleidl.idl .

oaidl.idl : $(SDKINC)\oaidl.idl
    -erase proxy\oaidl_p.c
    copy $(SDKINC)\oaidl.idl .


remunk.idl : $(DCOMIDL)\remunk.idl
    -erase proxy\remunk_p.c
    copy $(DCOMIDL)\remunk.idl .

contxt.idl : $(DCOMIDL)\contxt.idl
    -erase proxy\contxt_p.c
    copy $(DCOMIDL)\contxt.idl .

..\proxy\unknwn_p.c : unknwn.idl

..\proxy\objidl_p.c : objidl.idl

..\proxy\oleidl_p.c : oleidl.idl

..\proxy\oaidl_p.c : oaidl.idl

..\proxy\remunk_p.c : remunk.idl

..\proxy\contxt_p.c : contxt.idl

..\proxy\connct_p.c : connct.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\idl\cairo\makefile.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Greg Jensenworth


!ENDIF


SDKINC=$(_NTDRIVE)$(_NTROOT)\public\sdk\inc
DCOMIDL=$(_NTDRIVE)$(_NTROOT)\private\dcomidl

unknwn.idl : $(SDKINC)\unknwn.idl
    -erase proxy\unknwn_p.c
    copy $(SDKINC)\unknwn.idl .

objidl.idl : $(SDKINC)\objidl.idl
    -erase proxy\objidl_p.c
    copy $(SDKINC)\objidl.idl .

oleidl.idl : $(SDKINC)\oleidl.idl
    -erase proxy\oleidl_p.c
    copy $(SDKINC)\oleidl.idl .

oaidl.idl : $(SDKINC)\oaidl.idl
    -erase proxy\oaidl_p.c
    copy $(SDKINC)\oaidl.idl .

srvhdl.idl : $(SDKINC)\srvhdl.idl
    -erase proxy\srvhdl_p.c
    copy $(SDKINC)\srvhdl.idl .

storext.idl : $(SDKINC)\storext.idl
    -erase proxy\storext_p.c
    copy $(SDKINC)\storext.idl .

remunk.idl : $(DCOMIDL)\remunk.idl
    -erase proxy\remunk_p.c
    copy $(DCOMIDL)\remunk.idl .

..\proxy\unknwn_p.c : unknwn.idl

..\proxy\objidl_p.c : objidl.idl

..\proxy\oleidl_p.c : oleidl.idl

..\proxy\oaidl_p.c : oaidl.idl

..\proxy\remunk_p.c : remunk.idl

..\proxy\storext_p.c : storext.idl

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\idl\daytona\makefile.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Greg Jensenworth


!ENDIF


SDKINC=$(_NTDRIVE)$(_NTROOT)\public\sdk\inc
DCOMIDL=$(_NTDRIVE)$(_NTROOT)\private\dcomidl

unknwn.idl : $(SDKINC)\unknwn.idl
    -erase proxy\unknwn_p.c
    copy $(SDKINC)\unknwn.idl .

objidl.idl : $(SDKINC)\objidl.idl
    -erase proxy\objidl_p.c
    copy $(SDKINC)\objidl.idl .

oleidl.idl : $(SDKINC)\oleidl.idl
    -erase proxy\oleidl_p.c
    copy $(SDKINC)\oleidl.idl .

oaidl.idl : $(SDKINC)\oaidl.idl
    -erase proxy\oaidl_p.c
    copy $(SDKINC)\oaidl.idl .


remunk.idl : $(DCOMIDL)\remunk.idl
    -erase proxy\remunk_p.c
    copy $(DCOMIDL)\remunk.idl .

contxt.idl : $(DCOMIDL)\contxt.idl
    -erase proxy\contxt_p.c
    copy $(DCOMIDL)\contxt.idl .

..\proxy\unknwn_p.c : unknwn.idl

..\proxy\objidl_p.c : objidl.idl

..\proxy\oleidl_p.c : oleidl.idl

..\proxy\oaidl_p.c : oaidl.idl

..\proxy\remunk_p.c : remunk.idl

..\proxy\contxt_p.c : contxt.idl

..\proxy\connct_p.c : connct.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\clipformat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       clipformat.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for CLIPFORMAT.
//
//  Functions:  
//              CLIPFORMAT_UserSize
//              CLIPFORMAT_UserMarshal
//              CLIPFORMAT_UserUnmarshal
//              CLIPFORMAT_UserFree
//              CLIPFORMAT_UserSize64
//              CLIPFORMAT_UserMarshal64
//              CLIPFORMAT_UserUnmarshal64
//              CLIPFORMAT_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>
#include <winsta.h>
#include <allproc.h>

typedef HANDLE __stdcall FN_WinStationOpenServerW(LPWSTR);
typedef BOOLEAN __stdcall FN_WinStationGetTermSrvCountersValue(HANDLE, ULONG, PVOID);
typedef BOOLEAN __stdcall FN_WinStationCloseServer(HANDLE);

static DWORD g_cTSSessions = -1;

#include "carefulreader.hxx"
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
void CountTSSessions()
{
   DWORD cTSSessions = 0;
   HINSTANCE hTSLib = LoadLibraryW(L"winsta.dll");
   if (hTSLib) 
   {
      FN_WinStationOpenServerW *pFNOpen = (FN_WinStationOpenServerW *)GetProcAddress(hTSLib, "WinStationOpenServerW");
      FN_WinStationGetTermSrvCountersValue *pFNCount = (FN_WinStationGetTermSrvCountersValue *)GetProcAddress(hTSLib, "WinStationGetTermSrvCountersValue");
      FN_WinStationCloseServer *pFNClose = (FN_WinStationCloseServer *)GetProcAddress(hTSLib, "WinStationCloseServer");
      if (pFNOpen && pFNCount && pFNClose) 
      {
	 HANDLE hServer = pFNOpen(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
	 if (hServer != NULL)
	 {
	    TS_COUNTER tsCounters[2] = {0};

	    tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
	    tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

	    if (pFNCount(hServer, ARRAYSIZE(tsCounters), tsCounters))
	    {
	       int i;
               for (i = 0; i < ARRAYSIZE(tsCounters); i++)
	       {
		  if (tsCounters[i].counterHead.bResult)
		  {
                    cTSSessions += tsCounters[i].dwValue;
		  }
	       }
	    }
	    pFNClose(hServer);
	 }
      }
      FreeLibrary(hTSLib);
   }
   g_cTSSessions = cTSSessions;
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserSize
//
//  Synopsis:   Sizes a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
CLIPFORMAT_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return( Offset );

    if (g_cTSSessions == -1) 
    {
       CountTSSessions();
    }
    // userCLIPFORMAT is an encapsulated union with a string.

    LENGTH_ALIGN( Offset, 3);
    Offset += sizeof(long) + sizeof(void *);

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
	 || (g_cTSSessions > 1 ))) // ignore console session
        {
        wchar_t temp[CLIPFORMAT_BUFFER_MAX];

        int ret = GetClipboardFormatName( *pObject,
                                          temp,
                                          CLIPFORMAT_BUFFER_MAX - 1 );

        if ( ret )
            {
            Offset += 3 * sizeof(long)  +  (ret+1) * sizeof(wchar_t);
            }
        else
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );
        }

    return( Offset );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserMarshal
//
//  Synopsis:   Marshals a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return pBuffer;

    // userCLIPFORMAT is an encapsulated union with a string.

    ALIGN( pBuffer, 3);

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
	 || (g_cTSSessions > 1 ))) // ignore console session
        {
        // sending a wide string

        unsigned long    ret;

        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;

        // On Chicago this is GetClipboardFormatNameX.
        // When the buffer is too short, this call would still
        // return a decent, null terminated, truncated string.
        //

        ret = (ulong) GetClipboardFormatName( *pObject,
                                               (wchar_t *)(pBuffer + 12),
                                               CLIPFORMAT_BUFFER_MAX - 1
                                             );


        if ( ret )
	{
	   ret++;
	   // conformat size etc. for string.
   
	   *(PULONG_LV_CAST pBuffer)++ = ret;
	   *(PULONG_LV_CAST pBuffer)++ = 0;
	   *(PULONG_LV_CAST pBuffer)++ = ret;
            // skip the string in the bbuffer, including the terminator

            pBuffer += ret * sizeof(wchar_t);
	}
	else
            RpcRaiseException( DV_E_CLIPFORMAT );
        }
    else
        {
        // sending the number itself

        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;
        }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserUnmarshal
//
//  Synopsis:   Unmarshals a CLIPFORMAT; registers if needed.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//              Aug-99   JohnStra      Added consistency checks
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    ulong UnionDisc;
    UINT  cf;

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing buffer.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    UnionDisc =        *(PULONG_LV_CAST pBuffer)++;
    cf        = (WORD) *(PULONG_LV_CAST pBuffer)++;

    if ( WDT_DATA_MARKER == UnionDisc )
        {
        // CLIPFORMAT value must be in valid range.
        if ( cf < 0xc000 || cf > 0xffff )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Check for EOB before accessing string header.
        CHECK_BUFFER_SIZE( BufferSize, cbFixup + (5 * sizeof( ULONG )) );

        // Get the string header from the buffer and subtract the string
        // header from the BufferSize.
        ULONG ConfSize = *(PULONG_LV_CAST pBuffer)++;
        ULONG Offset = *(PULONG_LV_CAST pBuffer)++;
        ULONG ActualSize = *(PULONG_LV_CAST pBuffer)++;

        // Verify the header: Offset must always be zero, length must match
        // size, and size can't be zero since that would mean no NULL
        // terminator.
        if ( 0 != Offset || ActualSize != ConfSize || 0 == ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Check for EOB before accessing string.
        CHECK_BUFFER_SIZE(
            BufferSize,
            cbFixup + (5 * sizeof(ULONG)) + (ActualSize * sizeof(WCHAR)) );

        // Last two bytes of the buffer must be unicode terminator
        if ( *(WCHAR*)(pBuffer + ((ActualSize-1) * sizeof(WCHAR))) != 0x0000 )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Must be only 1 unicode terminator.
        if ( (ULONG)(lstrlenW( (WCHAR*)pBuffer ) + 1) != ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Register the clipboard format.
        cf = RegisterClipboardFormat( (wchar_t *)pBuffer );
        if ( cf == 0 )
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );

        // Advance buffer pointer past string.
        pBuffer += ActualSize * sizeof(wchar_t);
        }
    else if ( WDT_HANDLE_MARKER != UnionDisc )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

    *pObject = (CLIPFORMAT) cf;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserFree
//
//  Synopsis:   Frees remnants of CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Feb-96   Ryszardk      Created
//
//--------------------------------------------------------------------------

void  __RPC_USER
CLIPFORMAT_UserFree(
    unsigned long * pFlags,
    CLIPFORMAT * pObject )
{
    // Nothing to free, as nothing gets allocated when we unmarshal.
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserSize64
//
//  Synopsis:   Sizes a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
CLIPFORMAT_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return( Offset );

    // userCLIPFORMAT is an encapsulated union with a string.
    // max align of the union is size of 64b pointer.
    LENGTH_ALIGN( Offset, 7 );
    Offset += 8;               // 4 byte discriminant, 4 byte alignment
    
    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
	 || (g_cTSSessions > 1 ))) // ignore console session
    {
        // Writing another pointer...
        Offset += 8;           // 64b pointer

        wchar_t temp[CLIPFORMAT_BUFFER_MAX + 1];

        int ret = GetClipboardFormatName( *pObject,
                                          temp,
                                          CLIPFORMAT_BUFFER_MAX );

        if ( ret )
        {
            // This string has 3 conformance fields (64b) followed by an
            // array of 16b chars.
            Offset += (3 * 8)  +  ((ret + 1) * 2);
        }
        else
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );
    }
    else
    {
        // Writing a DWORD
        Offset += 4;
    }

    return( Offset );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserMarshal64
//
//  Synopsis:   Marshals a CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    if ( !pObject )
        return pBuffer;

    // userCLIPFORMAT is an encapsulated union with a string.

    ALIGN( pBuffer, 7 );

    if ( (NON_STANDARD_CLIPFORMAT(pObject)) && ((REMOTE_CLIPFORMAT( pFlags) ) 
	 || (g_cTSSessions > 1 ))) // ignore console session
    {
        // sending a wide string
        unsigned long    ret;

        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper) *pObject;

        // On Chicago this is GetClipboardFormatNameX.
        // When the buffer is too short, this call would still
        // return a decent, null terminated, truncated string.
        //
        ret = (ulong) GetClipboardFormatName( *pObject,
                                               (wchar_t *)(pBuffer + (3 * 8)),
                                               CLIPFORMAT_BUFFER_MAX
                                            );

        if ( ret )
        {
            // Account for the trailing NULL.
            ret ++;

            // conformat size etc. for string.
            *(PHYPER_LV_CAST pBuffer)++ = ret;   // Conformance
            *(PHYPER_LV_CAST pBuffer)++ = 0;     // Offset
            *(PHYPER_LV_CAST pBuffer)++ = ret;   // Actual Size

            // skip the string in the buffer, including the terminator
            pBuffer += (ret * 2);
        }
        else
            RpcRaiseException( DV_E_CLIPFORMAT );
    }
    else
    {
        // sending the number itself

        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        ALIGN( pBuffer, 7 );
        *(PULONG_LV_CAST pBuffer)++ = (ulong) *pObject;
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserUnmarshal64
//
//  Synopsis:   Unmarshals a CLIPFORMAT; registers if needed.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR *  __RPC_USER
CLIPFORMAT_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    CLIPFORMAT    * pObject )
{
    ulong  UnionDisc;
    hyper  cf;

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    stream.Align( 8 );                 // Must align on 8, union rules.
    UnionDisc = stream.ReadULONGNA();  // ...so no need to align on 4 here...
    stream.Align( 8 );                 // ...but must explicitly align to 8 here again.

    if ( WDT_DATA_MARKER == UnionDisc )
    {
        cf = stream.ReadHYPERNA();     // Just aligned 8, so don't align again.

        // CLIPFORMAT value must be in valid range.
        if ( cf < 0xc000 || cf > 0xffff )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Get the string header from the buffer and subtract the string
        // header from the BufferSize.
        hyper ConfSize   = stream.ReadHYPERNA();
        hyper Offset     = stream.ReadHYPERNA();
        hyper ActualSize = stream.ReadHYPERNA();

        // Verify the header: Offset must always be zero, length must match
        // size, and size can't be zero since that would mean no NULL
        // terminator.
        if ( 0 != Offset || ActualSize != ConfSize || 0 == ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Check for EOB before accessing string.
        stream.CheckSize((unsigned long)(ActualSize * sizeof(WCHAR)));

        // Last two bytes of the buffer must be unicode terminator
        WCHAR *pCheck = (WCHAR *)stream.GetBuffer();
        if ( pCheck[ActualSize-1] != 0x0000 )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );
        
        // Must be only 1 unicode terminator.
        if ( (ULONG)(lstrlenW( pCheck ) + 1) != ActualSize )
            RAISE_RPC_EXCEPTION( RPC_X_INVALID_BOUND );

        // Register the clipboard format.
        cf = RegisterClipboardFormat( pCheck );
        if ( cf == 0 )
            RAISE_RPC_EXCEPTION( DV_E_CLIPFORMAT );

        // Advance buffer pointer past string.
        stream.Advance((unsigned long)(ActualSize * sizeof(WCHAR)));
    }
    else if ( WDT_HANDLE_MARKER == UnionDisc )
    {        
        cf = (hyper)stream.ReadULONGNA();  // Just aligned on 8...
    }
    else
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }

    *pObject = (CLIPFORMAT) cf;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   CLIPFORMAT_UserFree64
//
//  Synopsis:   Frees remnants of CLIPFORMAT.
//
//  Derivation: A union of a long and a string.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void  __RPC_USER
CLIPFORMAT_UserFree64 (
    unsigned long * pFlags,
    CLIPFORMAT * pObject )
{
    // Nothing to free, as nothing gets allocated when we unmarshal.
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\bitmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       bitmap.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HBITMAP.
//
//  Functions:  
//              HBITMAP_UserSize
//              HBITMAP_UserMarshal
//              HBITMAP_UserUnmarshal
//              HBITMAP_UserFree
//              HBITMAP_UserSize64
//              HBITMAP_UserMarshal64
//              HBITMAP_UserUnmarshal64
//              HBITMAP_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserSize
//
//  Synopsis:   Get the wire size the HBITMAP handle and data.
//
//  Derivation: Union of a long and the bitmap handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBITMAP_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return Offset;

    BITMAP      bm;
    HBITMAP     hBitmap = *pHBitmap;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHBitmap )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Pointee of the union arm for the remote case.
        // Conformat size, 6 fields, size, conf array.

        Offset += 4 + 4 * sizeof(LONG) + 2 * sizeof(WORD) + 4;

        // Get information about the bitmap

        #if defined(_CHICAGO_)
            if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
        #else
            if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
        #endif
                {
                RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
                }

        ULONG ulDataSize = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        Offset += ulDataSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserMarshall
//
//  Synopsis:   Marshalls an HBITMAP object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHBITMAP

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHBitmap);

        if ( ! *pHBitmap )
            return pBuffer;

        // Get information about the bitmap

        BITMAP bm;
        HBITMAP hBitmap = *pHBitmap;

        #if defined(_CHICAGO_)
            if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
        #else
            if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
        #endif
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }

        DWORD dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        *( PULONG_LV_CAST pBuffer)++ = dwCount;

        // Get the bm structure fields.

        ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );

        memcpy( pBuffer, (void *) &bm, ulBmSize );
        pBuffer += ulBmSize;

        // Get the raw bits.

        if (0 == GetBitmapBits( hBitmap, dwCount, pBuffer ) )
            {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }
        pBuffer += dwCount;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHBitmap);
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap,
    ULONG_PTR       BufferSize )
{
    HBITMAP         hBitmap;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get Discriminant and handle.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hBitmap = (HBITMAP)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hBitmap )
            {
            ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );

            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof( ULONG )) + ulBmSize );

            DWORD    dwCount = *( PULONG_LV_CAST  pBuffer)++;
            BITMAP * pBm     = (BITMAP *) pBuffer;

            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pBm->bmPlanes * pBm->bmHeight * pBm->bmWidthBytes )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            pBuffer += ulBmSize;

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof(ULONG)) + ulBmSize + dwCount);

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            hBitmap = CreateBitmap( pBm->bmWidth,
                                    pBm->bmHeight,
                                    pBm->bmPlanes,
                                    pBm->bmBitsPixel,
                                    pBuffer );

            pBuffer += dwCount;
            }
        }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work into a worker
//                                     routine in order to add consistency
//                                     checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserUnmarshal\n"));

    // Get the buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HBITMAP_UserUnmarshalWorker( pFlags,
                                           pBufferStart,
                                           pHBitmap,
                                           BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserFree
//
//  Synopsis:   Free an HBITMAP.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBITMAP_UserFree(
    unsigned long * pFlags,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserFree\n"));

    if( pHBitmap  &&  *pHBitmap )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteObject( *pHBitmap );
            }
        }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserSize64
//
//  Synopsis:   Get the wire size the HBITMAP handle and data.
//
//  Derivation: Union of a long and the bitmap handle and then struct.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBITMAP_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return Offset;

    BITMAP      bm;
    HBITMAP     hBitmap = *pHBitmap;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant   4
    //   (align on 8)   4
    //   handle or ptr  8
    Offset += 16;

    if ( ! *pHBitmap )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Pointee of the union arm for the remote case.
        //   (aligned on 8)
        //   conformance 8
        //   4xlong      16
        //   2xword      4
        //   size        4
        //   data        ulDataSize;
        if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
            RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));

        ULONG ulDataSize = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;
        Offset += 32 + ulDataSize;
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserMarshal64
//
//  Synopsis:   Marshalls an HBITMAP object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return pBuffer;
    
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserMarshal64\n"));
    
    ALIGN( pBuffer, 7 );
    
    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHBITMAP
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHBitmap);

        if ( ! *pHBitmap )
            return pBuffer;

        // Get information about the bitmap        
        BITMAP bm;
        HBITMAP hBitmap = *pHBitmap;

        if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        ULONG ulCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        // Conformance...
        *(PHYPER_LV_CAST pBuffer)++ = ulCount;

        // Get the bm structure fields.
        ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );
        memcpy( pBuffer, &bm, ulBmSize );
        pBuffer += ulBmSize;

        // Get the raw bits.
        *(PULONG_LV_CAST pBuffer)++ = ulCount;

        if (0 == GetBitmapBits( hBitmap, ulCount, pBuffer ) )
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulCount;
    }
    else
    {
        // Sending a handle.        
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHBitmap);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshallWorker64
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);    

    stream.Align(8);

    // Get Discriminant and handle.
    unsigned long UnionDisc = stream.ReadULONGNA();
    HBITMAP hBitmap = (HBITMAP)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hBitmap )
        {
            DWORD    dwCount = (DWORD)stream.ReadHYPERNA();
            
            // Check for EOB before accessing metadata.
            ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof(WORD);
            stream.CheckSize(ulBmSize);

            BITMAP * pBm = (BITMAP *)stream.GetBuffer();
            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pBm->bmPlanes * pBm->bmHeight * pBm->bmWidthBytes )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            stream.Advance(ulBmSize);
            
            if (stream.ReadULONGNA() != dwCount)
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            stream.CheckSize(dwCount);

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer
            hBitmap = CreateBitmap( pBm->bmWidth,
                                    pBm->bmHeight,
                                    pBm->bmPlanes,
                                    pBm->bmBitsPixel,
                                    stream.GetBuffer() );
            if (hBitmap == NULL)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

            stream.Advance(dwCount);
        }
    }
    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }
    
    // A new bitmap handle is ready, destroy the old one, if needed.
    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserUnmarshal\n"));
    
    // Get the buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();
    
    pBuffer = HBITMAP_UserUnmarshalWorker64( pFlags,
                                             pBufferStart,
                                             pHBitmap,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserFree64
//
//  Synopsis:   Free an HBITMAP.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBITMAP_UserFree64 (
    unsigned long * pFlags,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserFree\n"));

    if( pHBitmap  &&  *pHBitmap )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteObject( *pHBitmap );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\bstr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    bstr.cxx

Abstract:

    Windows Data Type Support by means of [user_marshal] attribute.

    Covers:
        BSTR
    

Author:

    Bill Morel (billmo)  Oct 14, 1995

    These routines provide [wire_marshal] support for BSTRs.

Revision History:

    14-Jun-96   MikeHill    Converted to use the new PrivSysAllocString,
                            PrivSysReAllocString, & PrivSysFreeString routines
                            (defined elsewhere in OLE32).

-------------------------------------------------------------------*/


//#include "stdrpc.hxx"
#pragma hdrstop

#include <wtypes.h>
#include "transmit.h"
#include <privoa.h>     // PrivSys* routines

// round up string alloc requests to nearest N-byte boundary, since allocator
// will round up anyway. Improves cache hits.
//
// UNDONE: optimal for Chicago is 4
// UNDONE: optimal for Daytona is 32
// UNDONE: 4 didn't help the a$ = a$ + "x" case at all.
// UNDONE: 8 did (gave 50% cache hit)
//
#define WIN32_ALLOC_ALIGN (4 - 1)	
#define DEFAULT_ALLOC_ALIGN (2 - 1)


/***
*unsigned int PrivSysStringByteLen(BSTR)
*Purpose:
*  return the length in bytes of the given BSTR.
*
*Entry:
*  bstr = the BSTR to return the length of
*
*Exit:
*  return value = unsigned int, length in bytes.
*
***********************************************************************/

// #########################################################################
//
//  BSTR
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserSize
//
//  Synopsis:   Get the wire size for the BSTR handle and data.
//
//  Derivation: Conformant struct with a flag field:
//                  align + 12 + data size.
//
//--------------------------------------------------------------------------

unsigned long __RPC_USER
BSTR_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    BSTR          * pBstr)
{
    // Null bstr doesn't get marshalled.

    if ( pBstr == NULL  ||  *pBstr == NULL )
        return Offset;

    unsigned long   ulDataSize;

    LENGTH_ALIGN( Offset, 3 );

    // Takes the byte length of a unicode string

    ulDataSize = PrivSysStringByteLen( *pBstr );

    return( Offset + 12 + ulDataSize) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserMarshall
//
//  Synopsis:   Marshalls an BSTR object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
BSTR_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    BSTR          * pBstr)
{
    // A null Bstr is not marshalled, the engine will take care of it.

    if ( pBstr == NULL  ||  *pBstr == NULL )
        return pBuffer;

    unsigned long   ulDataSize;

    // Data size (in bytes): a null bstr gets a data size of zero.

    ulDataSize = PrivSysStringByteLen( *pBstr );

    // Conformant size.

    ALIGN( pBuffer, 3 );
    *( PULONG_LV_CAST pBuffer)++ = (ulDataSize >> 1);

    // FLAGGED_WORD_BLOB: Handle is the null/non-null flag

    *( PULONG_LV_CAST pBuffer)++ = (unsigned long)*pBstr;

    // Length on wire is in words.

    *( PULONG_LV_CAST pBuffer)++ = (ulDataSize >> 1);

    if( ulDataSize )
        {
        // we don't put the terminating string on wire

        WdtpMemoryCopy( pBuffer, *pBstr, ulDataSize );
        }

    return( pBuffer + ulDataSize );
}


//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserUnmarshall
//
//  Synopsis:   Unmarshalls an BSTR object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
BSTR_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    BSTR          * pBstr)
{
    unsigned long   ulDataSize, fHandle;
    BSTR            Bstr = NULL;    // Default to NULL BSTR

    ALIGN( pBuffer, 3 );

    ulDataSize = *( PULONG_LV_CAST pBuffer)++;
    fHandle = *(ulong *)pBuffer;
    pBuffer += 8;

    if ( fHandle  )
        {
        // Length on wire is in words, and the string is unicode.

        if ( *pBstr  &&
             *(((ulong *)*pBstr) -1) == (ulDataSize << 1) )
            WdtpMemoryCopy( *pBstr, pBuffer, (ulDataSize << 1) );
        else
            {
            if (!PrivSysReAllocStringLen( pBstr, 
                                          (OLECHAR *)pBuffer,
                                          ulDataSize ))
                RpcRaiseException( E_OUTOFMEMORY );
            }
        }
    else
        {
        // free the old one, make it NULL.

        PrivSysFreeString( *pBstr );
        *pBstr = NULL;
        }

    return( pBuffer + (ulDataSize << 1) );
}

//+-------------------------------------------------------------------------
//
//  Function:   BSTR_UserFree
//
//  Synopsis:   Free an BSTR.
//
//--------------------------------------------------------------------------
void __RPC_USER
BSTR_UserFree(
    unsigned long * pFlags,
    BSTR * pBstr)
{
    if( pBstr && *pBstr )
            {
            PrivSysFreeString(* pBstr);
            *pBstr = NULL;
            }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\call_as.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       call_as.c
//
//  Contents:   [call_as] wrapper functions for COMMON\types.
//
//  Functions:  IAdviseSink2_OnLinkSrcChange_Proxy
//              IAdviseSink2_OnLinkSrcChange_Stub
//              IAdviseSink_OnDataChange_Proxy
//              IAdviseSink_OnDataChange_Stub
//              IAdviseSink_OnViewChange_Proxy
//              IAdviseSink_OnViewChange_Stub
//              IAdviseSink_OnRename_Proxy
//              IAdviseSink_OnRename_Stub
//              IAdviseSink_OnSave_Proxy
//              IAdviseSink_OnSave_Stub
//              IAdviseSink_OnClose_Proxy
//              IAdviseSink_OnClose_Stub
//              IBindCtx_GetBindOptions_Proxy
//              IBindCtx_GetBindOptions_Stub
//              IBindCtx_SetBindOptions_Proxy
//              IBindCtx_SetBindOptions_Stub
//              IClassFactory_CreateInstance_Proxy
//              IClassFactory_CreateInstance_Stub
//              IDataObject_GetData_Proxy
//              IDataObject_GetData_Stub
//              IDataObject_GetDataHere_Proxy
//              IDataObject_GetDataHere_Stub
//              IDataObject_SetData_Proxy
//              IDataObject_SetData_Stub
//              IEnumConnectionPoints_Next_Proxy
//              IEnumConnectionPoints_Next_Stub
//              IEnumConnections_Next_Proxy
//              IEnumConnections_Next_Stub
//              IEnumFORMATETC_Next_Proxy
//              IEnumFORMATETC_Next_Stub
//              IEnumMoniker_Next_Proxy
//              IEnumMoniker_Next_Stub
//              IEnumSTATDATA_Next_Proxy
//              IEnumSTATDATA_Next_Stub
//              IEnumSTATSTG_Next_Proxy
//              IEnumSTATSTG_Next_Stub
//              IEnumString_Next_Proxy
//              IEnumString_Next_Stub
//              IEnumUnknown_Next_Proxy
//              IEnumUnknown_Next_Stub
//              IEnumOLEVERB_Next_Proxy
//              IEnumOLEVERB_Next_Stub
//              ILockBytes_ReadAt_Proxy
//              ILockBytes_ReadAt_Stub
//              ILockBytes_WriteAt_Proxy
//              ILockBytes_WriteAt_Stub
//              IMoniker_BindToObject_Proxy
//              IMoniker_BindToObject_Stub
//              IMoniker_BindToStorage_Proxy
//              IMoniker_BindToStorage_Stub
//              IClientSiteHandler_PrivQueryInterface_Proxy
//              IClientSiteHandler_PrivQueryInterface_Stub
//              IOleInPlaceActiveObject_TranslateAccelerator_Proxy
//              IOleInPlaceActiveObject_TranslateAccelerator_Stub
//              IOleInPlaceActiveObject_ResizeBorder_Proxy
//              IOleInPlaceActiveObject_ResizeBorder_Stub
//              IRunnableObject_IsRunning_Proxy
//              IRunnableObject_IsRunning_Stub
//              IStorage_OpenStream_Proxy
//              IStorage_OpenStream_Stub
//              IStorage_EnumElements_Proxy
//              IStorage_EnumElements_Stub
//              ISequentialStream_Read_Proxy
//              ISequentialStream_Read_Stub
//              IStream_Seek_Proxy
//              IStream_Seek_Stub
//              ISequentialStream_Write_Proxy
//              ISequentialStream_Write_Stub
//              IStream_CopyTo_Proxy
//              IStream_CopyTo_Stub
//              IOverlappedStream_ReadOverlapped_Proxy
//              IOverlappedStream_ReadOverlapped_Stub
//              IOverlappedStream_WriteOverlapped_Proxy
//              IOverlappedStream_WriteOverlapped_Stub
//              IEnumSTATPROPSTG_Next_Proxy
//              IEnumSTATPROPSTG_Next_Stub
//              IEnumSTATPROPSETSTG_Next_Proxy
//              IEnumSTATPROPSETSTG_Next_Stub
//
//
//  History:    May-01-94   ShannonC    Created
//              Jul-10-94   ShannonC    Fix memory leak (bug #20124)
//              Aug-09-94   AlexT       Add ResizeBorder proxy, stub
//              Apr-25-95   RyszardK    Rewrote STGMEDIUM support
//              Nov-03-95   JohannP     Added IClientSite proxy, stub
//
//--------------------------------------------------------------------------

#include <rpcproxy.h>
#include <debnot.h>
#include "mega.h"
#include "transmit.h"
#include "stdidx.h"

#pragma code_seg(".orpc")

#define ASSERT(expr) Win4Assert(expr)

HRESULT CreateCallback(
    BOOL (STDMETHODCALLTYPE *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue,
    IContinue **ppContinue);

BOOL    CoIsSurrogateProcess();
HRESULT CoRegisterSurrogatedObject(IUnknown *pObject);

// The following is needed to avoid the async path when calling IAdviseSink 
// notifications cross-context. The async approach causes problems in the 
// cross-context case since the wrapper calls the real object and if it 
// implements IID_ICallFactory, creates a proxy for it. The proxy is basically
// useless since ICallFactory is a [local] interface. So the notification
// does not make it through to the other side.

DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);

BOOL IsStdIdentity(IAdviseSink* This)
{
    void *pStdId;

    if (SUCCEEDED( This->lpVtbl->QueryInterface(This, &IID_IStdIdentity, &pStdId) ))
    {
        ((IUnknown *)pStdId)->lpVtbl->Release(pStdId);
        return TRUE;   
    }
    return FALSE;   //not an StdIdentity
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink2_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink2::OnLinkSrcChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Proxy(
    IAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink2_RemoteOnLinkSrcChange_Proxy(This, pmk);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink2 *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink2, NULL, 
                                                    &IID_AsyncIAdviseSink2, (LPUNKNOWN *) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnLinkSrcChange(pAAS, pmk);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink2_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink2::OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Stub(
    IAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->OnLinkSrcChange(This, pmk);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Begin_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(This, pmk);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Finish_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2 __RPC_FAR * This)
{
    AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Begin_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2 __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->Begin_OnLinkSrcChange(This, pmk);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink2::Finish_OnLinkSrcChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2 __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnLinkSrcChange(This);
    return S_OK;

}



////////////////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnDataChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnDataChange_Proxy(
    IAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)

{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnDataChange_Proxy(This, pFormatetc, pStgmed);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnDataChange(pAAS, pFormatetc, pStgmed);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);  
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnDataChange_Stub(
    IAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    This->lpVtbl->OnDataChange(This, pFormatetc, pStgmed);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(This, pFormatetc, pStgmed);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnDataChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    FORMATETC __RPC_FAR *pFormatetc,
    STGMEDIUM __RPC_FAR *pStgmed)
{
    This->lpVtbl->Begin_OnDataChange(This, pFormatetc, pStgmed);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnDataChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnDataChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnDataChange(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnViewChange.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnViewChange_Proxy(
    IAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnViewChange_Proxy(This, dwAspect, lindex);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnViewChange(pAAS, dwAspect, lindex);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);            
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnViewChange_Stub(
    IAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    This->lpVtbl->OnViewChange(This, dwAspect, lindex);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(This, dwAspect, lindex);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnViewChange_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    DWORD dwAspect,
    LONG lindex)
{
    This->lpVtbl->Begin_OnViewChange(This, dwAspect, lindex);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnViewChange_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnViewChange.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnViewChange(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnRename.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnRename_Proxy(
    IAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnRename_Proxy(This, pmk);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnRename(pAAS, pmk);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnRename_Stub(
    IAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->OnRename(This, pmk);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Proxy(
    AsyncIAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)

{
    AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(This, pmk);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnRename_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Stub(
    AsyncIAdviseSink __RPC_FAR * This,
    IMoniker __RPC_FAR *pmk)
{
    This->lpVtbl->Begin_OnRename(This, pmk);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnRename_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnRename.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnRename(This);
    return S_OK;

}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnSave.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnSave_Proxy(
    IAdviseSink __RPC_FAR * This)
{
    __try
    {
        if (!IsStdIdentity((void *)This))
        {
            IAdviseSink_RemoteOnSave_Proxy(This);
        }
        else
        {
            ICallFactory *pCF;
            if (SUCCEEDED(This->lpVtbl->QueryInterface(This, &IID_ICallFactory, (void **) &pCF)))
            {
                AsyncIAdviseSink *pAAS;
                if (SUCCEEDED(pCF->lpVtbl->CreateCall(pCF, &IID_AsyncIAdviseSink, NULL, 
                                                    &IID_AsyncIAdviseSink, (LPUNKNOWN*) &pAAS)))
                {
                    pAAS->lpVtbl->Begin_OnSave(pAAS);
                    pAAS->lpVtbl->Release(pAAS);
                }
                pCF->lpVtbl->Release(pCF);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnSave_Stub(
    IAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->OnSave(This);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(This);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnSave_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Begin_OnSave(This);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnSave_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnSave.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnSave(This);
    return S_OK;

}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IAdviseSink::OnClose.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE IAdviseSink_OnClose_Proxy(
    IAdviseSink __RPC_FAR * This)
{
    __try
    {
        // ignore the HRESULT return
        IAdviseSink_RemoteOnClose_Proxy(This);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IAdviseSink_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IAdviseSink::OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IAdviseSink_OnClose_Stub(
    IAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->OnClose(This);
    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(This);
}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnClose_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Proxy(
    AsyncIAdviseSink __RPC_FAR * This)
{
    AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(This);
}

//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Begin_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Begin_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT  STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Begin_OnClose(This);
    return S_OK;
                                                       

}


//+-------------------------------------------------------------------------
//
//  Function:   AsyncIAdviseSink_Finish_OnClose_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              AsyncIAdviseSink::Finish_OnClose.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Stub(
    AsyncIAdviseSink __RPC_FAR * This)
{
    This->lpVtbl->Finish_OnClose(This);
    return S_OK;

}

////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_GetBindOptions_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IBindCtx::GetBindOptions.
//
//  Returns:    S_OK
//
//  Notes:      If the caller's BIND_OPTS is smaller than the current
//              BIND_OPTS definition, then we must truncate the results
//              so that we don't go off the end of the structure.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Proxy(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS __RPC_FAR *pbindopts)
{
    HRESULT hr;

    if(pbindopts->cbStruct >= sizeof(BIND_OPTS2))
    {
        hr = IBindCtx_RemoteGetBindOptions_Proxy(This, (BIND_OPTS2 *) pbindopts);
    }
    else
    {
        BIND_OPTS2 bindOptions;

        //The pbindopts supplied by the caller is too small.
        //We need a BIND_OPTS2 for the marshalling code.
        memset(&bindOptions, 0, sizeof(BIND_OPTS2));
        memcpy(&bindOptions, pbindopts, pbindopts->cbStruct);

        hr = IBindCtx_RemoteGetBindOptions_Proxy(This, &bindOptions);

        if(SUCCEEDED(hr))
        {
            memcpy(pbindopts, &bindOptions, bindOptions.cbStruct);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_GetBindOptions_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IBindCtx::GetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Stub(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS2 __RPC_FAR *pbindopts)
{
    HRESULT hr;

    //make sure we don't request more data than we can handle.
    if(pbindopts->cbStruct > sizeof(BIND_OPTS2))
    {
        pbindopts->cbStruct = sizeof(BIND_OPTS2);
    }

    hr = This->lpVtbl->GetBindOptions(This, (BIND_OPTS *)pbindopts);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_SetBindOptions_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IBindCtx::SetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Proxy(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS __RPC_FAR *pbindopts)
{
    HRESULT hr;

    if(sizeof(BIND_OPTS2) == pbindopts->cbStruct)
    {
        hr = IBindCtx_RemoteSetBindOptions_Proxy(This, (BIND_OPTS2 *) pbindopts);
    }
    else if(sizeof(BIND_OPTS2) > pbindopts->cbStruct)
    {
        BIND_OPTS2 bindOptions;

        memset(&bindOptions, 0, sizeof(bindOptions));
        memcpy(&bindOptions, pbindopts, pbindopts->cbStruct);
        hr = IBindCtx_RemoteSetBindOptions_Proxy(This, &bindOptions);
    }
    else
    {
        //The caller's BIND_OPTS is too large.
        //We don't want to truncate, so we return an error.
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IBindCtx_SetBindOptions_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IBindCtx::SetBindOptions.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Stub(
    IBindCtx __RPC_FAR * This,
    BIND_OPTS2 __RPC_FAR *pbindopts)
{
    HRESULT hr;

    hr = This->lpVtbl->SetBindOptions(This, (BIND_OPTS *)pbindopts);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_CreateInstance_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IClassFactory::CreateInstance.
//
//  Returns:    CLASS_E_NO_AGGREGREGRATION - if punkOuter != 0.
//              Any errors returned by Remote_CreateInstance_Proxy.
//              Any errors from QI() on Proxy IUnknown for local interfaces.
//
//  Notes:      We don't support remote aggregation. punkOuter must be zero.
//
//              If the interface being created is implemented on the proxy,
//              we create the object and then QI() the proxy returned to us
//              for the interface.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy(
    IClassFactory __RPC_FAR * This,
    IUnknown __RPC_FAR *pUnkOuter,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    HRESULT hr;

    *ppvObject = 0;

    if(pUnkOuter != 0)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else 
    {
        BOOL fIsOnProxy = IsInterfaceImplementedByProxy(riid);
        IUnknown* pUnk = NULL;

        hr = IClassFactory_RemoteCreateInstance_Proxy(This, 
                                                      fIsOnProxy ? &IID_IUnknown : riid,
                                                      &pUnk);
        if ( fIsOnProxy && SUCCEEDED(hr) && pUnk != NULL)
        {
            hr = pUnk->lpVtbl->QueryInterface(pUnk, riid, ppvObject);
            pUnk->lpVtbl->Release(pUnk);
        }
        else
        {
            *ppvObject = (void*) pUnk;
        }
    }

    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_CreateInstance_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IClassFactory::CreateInstance.
//
//  Returns:    Any errors returned by CreateInstance.
//
//  Notes:      We don't support remote aggregation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub(
    IClassFactory __RPC_FAR * This,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObject)
{
    HRESULT hr;

    hr = This->lpVtbl->CreateInstance(This, 0, riid, ppvObject);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObject to zero.
        ASSERT(*ppvObject == 0);

        //Set it to zero, in case we have a badly behaved server.
        *ppvObject = 0;
    }
    else if (S_OK == hr && CoIsSurrogateProcess())
    {
        // Don't worry about any errors.  The worst that will happen is that
        // keyboard accelerators won't work.
        CoRegisterSurrogatedObject(*ppvObject);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_LockServer_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IClassFactory::LockServer.
//
//  Returns:    S_OK
//
//  Notes:      The server activation code does an implicit LockServer(TRUE)
//              when it marshals the class object, and an implicit
//              LockServer(FALSE) when the client releases it, so calls
//              made by the client are ignored.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy(
    IClassFactory __RPC_FAR * This,
    BOOL fLock)
{
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   IClassFactory_LockServer_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IClassFactory::LockServer.
//
//  Returns:    S_OK
//
//  Notes:      The server activation code does an implicit LockServer(TRUE)
//              when it marshals the class object, and an implicit
//              LockServer(FALSE) when the client releases it, so calls
//              made by the client are ignored.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Stub(
    IClassFactory __RPC_FAR * This,
    BOOL fLock)
{
    return This->lpVtbl->LockServer(This, fLock);
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetData_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [out] only.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetData_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetcIn,
    STGMEDIUM __RPC_FAR *pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetData_Proxy\n"));

    WdtpZeroMemory( pMedium, sizeof(STGMEDIUM) );
    hr = IDataObject_RemoteGetData_Proxy(This, pformatetcIn, pMedium);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetData_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [out] only.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetData_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetcIn,
    STGMEDIUM __RPC_FAR * pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetData_Stub\n"));

    hr = This->lpVtbl->GetData(This, pformatetcIn, pMedium);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetDataHere_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetDataHere.
//              pMedium is [in,out].
//
//  History:    05-19-94  AlexT     Handle all cases correctly
//
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR *pmedium)
{
    HRESULT   hr;
    IUnknown * punkSaved;
    IStorage * pStgSaved = NULL;

    UserNdrDebugOut((UNDR_FORCE, "==GetDataHere_Proxy: %s\n", WdtpGetStgmedName(pmedium)));

    if ((pmedium->tymed &
         (TYMED_FILE | TYMED_ISTORAGE | TYMED_ISTREAM | TYMED_HGLOBAL)) == 0)
    {
        //  We only support GetDataHere for files, storages, streams,
        //  and HGLOBALs

        return(DV_E_TYMED);
    }

    if (pmedium->tymed != pformatetc->tymed)
    {
        //  tymeds must match!
        return(DV_E_TYMED);
    }

    // NULL the pUnkForRelease. It makes no sense to pass this parameter
    // since the callee will never call it.  NULLing saves all the marshalling
    // and associated Rpc calls, and reduces complexity in this code.

    punkSaved = pmedium->pUnkForRelease;
    pmedium->pUnkForRelease = NULL;

    // This is a hack to make Exchange 8.0.829.1 work HenryLee 04/18/96
    // So probably can't remove it now JohnDoty 04/24/00
    if (pmedium->tymed == TYMED_ISTORAGE || pmedium->tymed == TYMED_ISTREAM)
    {
        pStgSaved = pmedium->pstg;
        if (pStgSaved)
            pStgSaved->lpVtbl->AddRef(pStgSaved);     // save the old pointer
    }

    hr = IDataObject_RemoteGetDataHere_Proxy(This, pformatetc, pmedium );

    pmedium->pUnkForRelease = punkSaved;

    if (pStgSaved != NULL)
    {
        if (pmedium->pstg != NULL)                       // discard the new one
           (pmedium->pstg)->lpVtbl->Release(pmedium->pstg);
        pmedium->pstg = pStgSaved;                       // restore old one
    }

    if(SUCCEEDED(hr) )
        {
        UserNdrDebugOut((UNDR_FORCE, "  (GetDataHere_ProxyO: new if ptr)\n"));
        }
    else
        UserNdrDebugOut((UNDR_FORCE, "  (GetDataHere_ProxyO: didn't succeed : %lx)\n", hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_GetDataHere_Stub
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::GetData.
//              pMedium is [in,out].
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR * pMedium)
{
    HRESULT hr;

    UserNdrDebugOut((UNDR_FORCE, "==GetDataHere_Stub: %s\n", WdtpGetStgmedName(pMedium)));

    hr = This->lpVtbl->GetDataHere(This, pformatetc, pMedium);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_SetData_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDataObject::SetData.
//              This wrapper function uses FLAG_STGMEDIUM type.
//              pMedium is [in].
//
//  Notes:      If fRelease is TRUE, then the callee is responsible for
//              freeing the STGMEDIUM.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_SetData_Proxy(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    STGMEDIUM __RPC_FAR *pmedium,
    BOOL fRelease)
{
    HRESULT hr;
    FLAG_STGMEDIUM   RemoteStgmed;

#ifdef FUTURE
    STGMEDIUM StgMedium;

    //  Potential performance improvement

    if (!fRelease && pmedium->pUnkForRelease != NULL)
    {
        //  Caller is retaining ownership of pmedium, but is providing
        //  a pUnkForRelease.  We make sure the stub doesn't call the
        //  pUnkForRelease by sending a STGMEDIUM that has it as NULL.

        StgMedium.tymed = pmedium->tymed;
        StgMedium.hGlobal = pmedium->hGlobal;
        StgMedium.pUnkForRelease = NULL;
        pmedium = &StgMedium;
    }
#endif

    UserNdrDebugOut((UNDR_FORCE, "  SetData_Proxy %s\n", WdtpGetStgmedName(pmedium)));
    UserNdrDebugOut((UNDR_FORCE, "      fRelease=%d, punk=%p\n", fRelease, pmedium->pUnkForRelease));

    __try
    {
        RemoteStgmed.ContextFlags = 0;
        RemoteStgmed.fPassOwnership = fRelease;
        RemoteStgmed.Stgmed = *pmedium;

        hr = IDataObject_RemoteSetData_Proxy( This,
                                              pformatetc,
                                              & RemoteStgmed,
                                              fRelease);

        if (fRelease && SUCCEEDED(hr))
        {
            // Caller has given ownership to callee.
            // Free the resources left on this side.
            // Context flags have been set by the unmarshalling routine.

            if ( pmedium->tymed != TYMED_FILE )
                STGMEDIUM_UserFree( &RemoteStgmed.ContextFlags, pmedium );
            else
                {
                // For files, STGMEDIUM_UserFree dereferences pStubMsg via pFlags
                // to get to the right freeing routine. As the StubMsg is gone,
                // we need to free the file here.

                NdrOleFree( pmedium->lpszFileName );
                NukeHandleAndReleasePunk( pmedium );
                }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DWORD dwExceptionCode = GetExceptionCode();

        if(FAILED((HRESULT) dwExceptionCode))
            hr = (HRESULT) dwExceptionCode;
        else
            hr = HRESULT_FROM_WIN32(dwExceptionCode);
    }

    UserNdrDebugOut((UNDR_FORCE, "  SetData_Proxy hr=%lx\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IDataObject_SetData_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IDataObject::SetData.
//              pMedium is [in].
//
//  Notes:      If fRelease is TRUE, then the callee is responsible for
//              freeing the STGMEDIUM.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDataObject_SetData_Stub(
    IDataObject __RPC_FAR * This,
    FORMATETC __RPC_FAR *pformatetc,
    FLAG_STGMEDIUM __RPC_FAR *pFlagStgmed,
    BOOL fRelease)
{
    HRESULT     hr;
    STGMEDIUM   Stgmed;

    __try
    {
        Stgmed = pFlagStgmed->Stgmed;

        UserNdrDebugOut((UNDR_FORCE, "  SetData_Stub %s\n", WdtpGetStgmedName(& Stgmed)));
        UserNdrDebugOut((UNDR_FORCE, "      fRelease=%d, punk=%p\n", fRelease, Stgmed.pUnkForRelease));


        hr = This->lpVtbl->SetData( This,
                                    pformatetc,
                                    & Stgmed,
                                    fRelease);

        if ( fRelease && SUCCEEDED(hr) )
            {
            // The ownership was passed successfully.
            // The user should free the object.
            // Make it so that our userfree routine for user medium
            // doesn't do anything to the user's object.

            pFlagStgmed->Stgmed.tymed = TYMED_NULL;
            }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DWORD dwExceptionCode = GetExceptionCode();

        if(FAILED((HRESULT) dwExceptionCode))
            hr = (HRESULT) dwExceptionCode;
        else
            hr = HRESULT_FROM_WIN32(dwExceptionCode);
    }


    UserNdrDebugOut((UNDR_FORCE, "  SetData_Stub hr=%lx\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnectionPoints_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumConnectionPoints::Next.  This wrapper function handles the
//              case where lpcFetched is NULL.
//
//  Notes:      If lpcFetched != 0, then the number of elements
//              fetched will be returned in *lpcFetched.  If an error
//              occurs, then *lpcFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Proxy(
    IEnumConnectionPoints __RPC_FAR * This,
    ULONG cConnections,
    IConnectionPoint __RPC_FAR *__RPC_FAR *rgpcn,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    if((cConnections > 1) && (lpcFetched == 0))
        return E_INVALIDARG;

    hr = IEnumConnectionPoints_RemoteNext_Proxy(This, cConnections, rgpcn, &cFetched);

    if(lpcFetched != 0)
        *lpcFetched = cFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnectionPoints_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumConnectionPoints::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Stub(
    IEnumConnectionPoints __RPC_FAR * This,
    ULONG cConnections,
    IConnectionPoint __RPC_FAR *__RPC_FAR *rgpcn,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, cConnections, rgpcn, lpcFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *lpcFetched to zero.
        ASSERT(*lpcFetched == 0);

        //Set *lpcFetched to zero in case we have a badly behaved server.
        *lpcFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnections_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumConnections::Next.  This wrapper function handles the
//              case where lpcFetched is NULL.
//
//  Notes:      If lpcFetched != 0, then the number of elements
//              fetched will be returned in *lpcFetched.  If an error
//              occurs, then *lpcFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Proxy(
    IEnumConnections __RPC_FAR * This,
    ULONG cConnections,
    CONNECTDATA __RPC_FAR *rgpunk,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    if((cConnections > 1) && (lpcFetched == 0))
        return E_INVALIDARG;

    hr = IEnumConnections_RemoteNext_Proxy(This, cConnections, rgpunk, &cFetched);

    if(lpcFetched != 0)
        *lpcFetched = cFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumConnections_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumConnections::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Stub(
    IEnumConnections __RPC_FAR * This,
    ULONG cConnections,
    CONNECTDATA __RPC_FAR *rgpunk,
    ULONG __RPC_FAR *lpcFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, cConnections, rgpunk, lpcFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *lpcFetched to zero.
        ASSERT(*lpcFetched == 0);

        //Set *lpcFetched to zero in case we have a badly behaved server.
        *lpcFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumFORMATETC_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumFORMATETC::Next.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Proxy(
    IEnumFORMATETC __RPC_FAR * This,
    ULONG celt,
    FORMATETC __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumFORMATETC_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumFORMATETC_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumFORMATETC::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Stub(
    IEnumFORMATETC __RPC_FAR * This,
    ULONG celt,
    FORMATETC __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumMoniker_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumMoniker::Next.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Proxy(
    IEnumMoniker __RPC_FAR * This,
    ULONG celt,
    IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumMoniker_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumMoniker_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumMoniker::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Stub(
    IEnumMoniker __RPC_FAR * This,
    ULONG celt,
    IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATDATA_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumSTATDATA::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Proxy(
    IEnumSTATDATA __RPC_FAR * This,
    ULONG celt,
    STATDATA __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATDATA_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATDATA_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumSTATDATA::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Stub(
    IEnumSTATDATA __RPC_FAR * This,
    ULONG celt,
    STATDATA __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATSTG_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumSTATSTG::Next.  This wrapper function handles the case
//              where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Proxy(
    IEnumSTATSTG __RPC_FAR * This,
    ULONG celt,
    STATSTG __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATSTG_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumSTATSTG::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Stub(
    IEnumSTATSTG __RPC_FAR * This,
    ULONG celt,
    STATSTG __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumString_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumString::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumString_Next_Proxy(
    IEnumString __RPC_FAR * This,
    ULONG celt,
    LPOLESTR __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumString_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumString_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumString::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumString_Next_Stub(
    IEnumString __RPC_FAR * This,
    ULONG celt,
    LPOLESTR __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumUnknown_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumUnknown::Next.  This wrapper function handles the
//              case where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Proxy(
    IEnumUnknown __RPC_FAR * This,
    ULONG celt,
    IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumUnknown_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumUnknown_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumUnknown::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Stub(
    IEnumUnknown __RPC_FAR * This,
    ULONG celt,
    IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumOLEVERB_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IEnumOLEVERB::Next.  This wrapper function handles the case
//              where pceltFetched is NULL.
//
//  Notes:      If pceltFetched != 0, then the number of elements
//              fetched will be returned in *pceltFetched.  If an error
//              occurs, then *pceltFetched is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Proxy(
    IEnumOLEVERB __RPC_FAR * This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumOLEVERB_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if(pceltFetched != 0)
        *pceltFetched = celtFetched;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumOLEVERB_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IEnumOLEVERB::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Stub(
    IEnumOLEVERB __RPC_FAR * This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;

    hr = This->lpVtbl->Next(This, celt, rgelt, pceltFetched);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *pceltFetched to zero.
        ASSERT(*pceltFetched == 0);

        //Set *pceltFetched to zero in case we have a badly behaved server.
        *pceltFetched = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_ReadAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ILockBytes::ReadAt.  This wrapper function
//              handles the case where pcbRead is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_ReadAt_Proxy(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;
    ULONG cbRead = 0;

    hr = ILockBytes_RemoteReadAt_Proxy(This, ulOffset, (byte __RPC_FAR *) pv, cb, &cbRead);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_ReadAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ILockBytes::ReadAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_ReadAt_Stub(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;

    *pcbRead = 0;
    hr = This->lpVtbl->ReadAt(This, ulOffset, (void __RPC_FAR *) pv, cb, pcbRead);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_WriteAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ILockBytes::WriteAt.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Proxy(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = ILockBytes_RemoteWriteAt_Proxy(This, ulOffset, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ILockBytes_WriteAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ILockBytes::WriteAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Stub(
    ILockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->WriteAt(This, ulOffset, pv, cb, pcbWritten);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToObject_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IMoniker::BindToObject.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Proxy(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    *ppvObj = 0;

    hr = IMoniker_RemoteBindToObject_Proxy(
        This, pbc, pmkToLeft, riid, (IUnknown **) ppvObj);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToObject_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IMoniker::BindToObject.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Stub(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    hr = This->lpVtbl->BindToObject(
        This, pbc, pmkToLeft, riid, (void **) ppvObj);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObj to zero.
        ASSERT(*ppvObj == 0);

        //Set it to zero in case we have a badly behaved server.
        *ppvObj = 0;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToStorage_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IMoniker::BindToStorage.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Proxy(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    *ppvObj = 0;

    hr = IMoniker_RemoteBindToStorage_Proxy(
        This, pbc, pmkToLeft, riid, (IUnknown **)ppvObj);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IMoniker_BindToStorage_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IMoniker::BindToStorage.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Stub(
    IMoniker __RPC_FAR * This,
    IBindCtx __RPC_FAR *pbc,
    IMoniker __RPC_FAR *pmkToLeft,
    REFIID riid,
    IUnknown __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;

    hr = This->lpVtbl->BindToStorage(
        This, pbc, pmkToLeft, riid, (void **) ppvObj);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppvObj to zero.
        ASSERT(*ppvObj == 0);

        //Set it to zero in case we have a badly behaved server.
        *ppvObj = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleCache2_UpdateCache_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleCache2:UpdateCache
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Proxy(
    IOleCache2 __RPC_FAR * This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LPVOID pReserved)
{
    HRESULT hr;
    hr = IOleCache2_RemoteUpdateCache_Proxy(This,
                                            pDataObject,
                                            grfUpdf,
                                            (LONG_PTR) pReserved);
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IOleCache2_UpdateCache_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleCache2::UpdateCache.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Stub(
    IOleCache2 __RPC_FAR * This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LONG_PTR pReserved)
{
    HRESULT hr;
    hr = This->lpVtbl->UpdateCache(This,
                                   pDataObject,
                                   grfUpdf,
                                   (void *)pReserved);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_TranslateAccelerator_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::TranslateAccelerator.
//
//  Returns:    This function always returns S_FALSE.
//
//  Notes:      A container needs to process accelerators differently
//              depending on whether an inplace server is running
//              in process or as a local server.  When the container
//              calls IOleInPlaceActiveObject::TranslateAccelerator on
//              an inprocess server, the server can return S_OK if it
//              successfully translated the message.  When the container
//              calls IOleInPlaceActiveObject::TranslateAccelerator on
//              a local server, the proxy will always return S_FALSE.
//              In other words, a local server never gets the opportunity
//              to translate messages from the container.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Proxy(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPMSG lpmsg)
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_TranslateAccelerator_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::TranslateAccelerator
//
//  Notes:      This function should never be called.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Stub(
    IOleInPlaceActiveObject __RPC_FAR * This)
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_ResizeBorder_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::ResizeBorder
//
//  Notes:      The pUIWindow interface is either an IOleInPlaceUIWindow or
//              an IOleInPlaceFrame, based on fFrameWindow.  We use
//              fFrameWindow to tell the proxy exactly which interace it
//              is so that it gets marshalled and unmarshalled correctly.
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Proxy(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPCRECT prcBorder,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    HRESULT hr;
    REFIID riid;

    if (fFrameWindow)
    {
        riid = &IID_IOleInPlaceFrame;
    }
    else
    {
        riid = &IID_IOleInPlaceUIWindow;
    }

    hr = IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
             This, prcBorder, riid, pUIWindow, fFrameWindow);

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   IOleInPlaceActiveObject_ResizeBorder_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IOleInPlaceActiveObject::ResizeBorder
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Stub(
    IOleInPlaceActiveObject __RPC_FAR * This,
    LPCRECT prcBorder,
    REFIID riid,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    HRESULT hr;

    hr = This->lpVtbl->ResizeBorder(This, prcBorder, pUIWindow, fFrameWindow);

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_OpenStream_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStorage::OpenStream.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Proxy(
    IStorage __RPC_FAR * This,
    const OLECHAR __RPC_FAR *pwcsName,
    void __RPC_FAR *pReserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;

#if DBG == 1
    if(pReserved1 != 0)
        return STG_E_INVALIDPARAMETER;
#endif

    *ppstm = 0;

    hr = IStorage_RemoteOpenStream_Proxy(
        This, pwcsName, 0, 0, grfMode, reserved2, ppstm);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStorage_OpenStream_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStorage::OpenStream.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Stub(
    IStorage __RPC_FAR * This,
    const OLECHAR __RPC_FAR *pwcsName,
    unsigned long cbReserved1,
    byte __RPC_FAR *reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;


    hr = This->lpVtbl->OpenStream(This, pwcsName, 0, grfMode, reserved2, ppstm);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppstm to zero.
        ASSERT(*ppstm == 0);

        //Set *ppstm to zero in case we have a badly behaved server.
        *ppstm = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_EnumElements_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStorage_EnumElements_Proxy
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Proxy(
    IStorage __RPC_FAR * This,
    DWORD reserved1,
    void __RPC_FAR *reserved2,
    DWORD reserved3,
    IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr;

    *ppenum = 0;

    hr = IStorage_RemoteEnumElements_Proxy(
        This, reserved1, 0, 0, reserved3, ppenum);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStorage_EnumElements_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStorage::EnumElements.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Stub(
    IStorage __RPC_FAR * This,
    DWORD reserved1,
    unsigned long cbReserved2,
    byte __RPC_FAR *reserved2,
    DWORD reserved3,
    IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr;

    hr = This->lpVtbl->EnumElements(This, reserved1, 0, reserved3, ppenum);

    if(FAILED(hr))
    {
        //If the server returns an error code, it must set *ppenum to zero.
        ASSERT(*ppenum == 0);

        //Set *ppenum to zero in case we have a badly behaved server.
        *ppenum = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IRunnableObject_IsRunning_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IRunnableObject::IsRunning.
//
//--------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE IRunnableObject_IsRunning_Proxy(
    IRunnableObject __RPC_FAR * This)
{
    BOOL bIsRunning = TRUE;
    HRESULT hr;

    hr = IRunnableObject_RemoteIsRunning_Proxy(This);

    if(S_FALSE == hr)
        bIsRunning = FALSE;

    return bIsRunning;
}

//+-------------------------------------------------------------------------
//
//  Function:   IRunnableObject_IsRunning_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IRunnableObject::IsRunning.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IRunnableObject_IsRunning_Stub(
    IRunnableObject __RPC_FAR * This)
{
    HRESULT hr;
    BOOL bIsRunning;

    bIsRunning = This->lpVtbl->IsRunning(This);

    if(TRUE == bIsRunning)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Read_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Read.  This wrapper function handles the case
//              where pcbRead is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Proxy(
    ISequentialStream __RPC_FAR * This,
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;
    ULONG cbRead = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif //DBG == 1

    hr = ISequentialStream_RemoteRead_Proxy(This, (byte *) pv, cb, &cbRead);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Read_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::Read.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Stub(
    ISequentialStream __RPC_FAR * This,
    byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
    HRESULT hr;

    *pcbRead = 0;
    hr = This->lpVtbl->Read(This, (void *) pv, cb, pcbRead);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IStream_Seek_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Seek.  This wrapper function handles the case
//              where plibNewPosition is NULL.
//
//  Notes:      If plibNewPosition != 0, then the new position
//              will be returned in *plibNewPosition.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_Seek_Proxy(
    IStream __RPC_FAR * This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    HRESULT hr;
    ULARGE_INTEGER libNewPosition;

    hr = IStream_RemoteSeek_Proxy(This, dlibMove, dwOrigin, &libNewPosition);

    if(plibNewPosition != 0)
    {
        *plibNewPosition = libNewPosition;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStream_Seek_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::Seek.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_Seek_Stub(
    IStream __RPC_FAR * This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    HRESULT hr;

    hr = This->lpVtbl->Seek(This, dlibMove, dwOrigin, plibNewPosition);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Write_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::Write.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Proxy(
    ISequentialStream __RPC_FAR * This,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = ISequentialStream_RemoteWrite_Proxy(This, (byte *) pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ISequentialStream_Write_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ISequentialStream::Write.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Stub(
    ISequentialStream __RPC_FAR * This,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->Write(This, (const void __RPC_FAR *) pv, cb, pcbWritten);

    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   IStream_CopyTo_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IStream::CopyTo.  This wrapper function handles the
//              cases where pcbRead is NULL or pcbWritten is NULL.
//
//  Notes:      If pcbRead != 0, then the number of bytes read
//              will be returned in *pcbRead.  If an error
//              occurs, then *pcbRead is set to zero.
//
//              If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_CopyTo_Proxy(
    IStream __RPC_FAR * This,
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULARGE_INTEGER cbRead;
    ULARGE_INTEGER cbWritten;

    cbRead.LowPart = 0;
    cbRead.HighPart = 0;
    cbWritten.LowPart = 0;
    cbWritten.HighPart = 0;

    hr = IStream_RemoteCopyTo_Proxy(This, pstm, cb, &cbRead, &cbWritten);

    if(pcbRead != 0)
        *pcbRead = cbRead;

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IStream_CopyTo_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IStream::CopyTo.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IStream_CopyTo_Stub(
    IStream __RPC_FAR * This,
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    pcbRead->LowPart = 0;
    pcbRead->HighPart = 0;
    pcbWritten->LowPart = 0;
    pcbWritten->HighPart = 0;

    hr = This->lpVtbl->CopyTo(This, pstm, cb, pcbRead, pcbWritten);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Draw_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::Draw.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Draw_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL (STDMETHODCALLTYPE __RPC_FAR *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    HRESULT hr;
    IContinue *pContinue = 0;

    if(pvAspect != 0)
        return E_INVALIDARG;

    if(pfnContinue != 0)
    {
        hr = CreateCallback(pfnContinue, dwContinue, &pContinue);
        if(FAILED(hr))
        {
             return hr;
        }
    }

    hr = IViewObject_RemoteDraw_Proxy(This,
                                      dwDrawAspect,
                                      lindex,
                                      (LONG_PTR) pvAspect,
                                      ptd,
                                      (LONG_PTR) hdcTargetDev,
                                      (LONG_PTR) hdcDraw,
                                      lprcBounds,
                                      lprcWBounds,
                                      pContinue);

    if(pContinue != 0)
    {
        pContinue->lpVtbl->Release(pContinue);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_RemoteContinue
//
//  Synopsis:   Wrapper function for IContinue::FContinue.  This function
//              is used for marshalling the pfnContinue parameter in
//              IViewObject::Draw.
//
//  Algorithm:  Cast the dwContinue to an IContinue * and then
//              call IContinue::FContinue.
//
//--------------------------------------------------------------------------
BOOL STDAPICALLTYPE IViewObject_RemoteContinue(ULONG_PTR dwContinue)
{
    BOOL bContinue = TRUE;
    HRESULT hr;
    IContinue *pContinue = (IContinue *) dwContinue;

    if(pContinue != 0)
    {
        hr = pContinue->lpVtbl->FContinue(pContinue);

        if(S_FALSE == hr)
            bContinue = FALSE;
    }

    return bContinue;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Draw_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::Draw.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Draw_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    ULONG_PTR hdcTargetDev,
    ULONG_PTR hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    IContinue *pContinue)
{
    HRESULT hr;
    BOOL (STDMETHODCALLTYPE __RPC_FAR *pfnContinue )(ULONG_PTR dwContinue) = 0;
    ULONG_PTR dwContinue = 0;

    if(pContinue != 0)
    {
        pfnContinue = IViewObject_RemoteContinue;
        dwContinue = (ULONG_PTR) pContinue;
    }

    hr = This->lpVtbl->Draw(This,
                            dwDrawAspect,
                            lindex,
                            (void *) pvAspect,
                            ptd,
                            (HDC) hdcTargetDev,
                            (HDC) hdcDraw,
                            lprcBounds,
                            lprcWBounds,
                            pfnContinue,
                            dwContinue);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Freeze_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::Freeze.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DWORD __RPC_FAR *pdwFreeze)
{
    HRESULT hr;

    if(pvAspect != 0)
        return E_INVALIDARG;

    hr = IViewObject_RemoteFreeze_Proxy(This,
                                        dwDrawAspect,
                                        lindex,
                                        (LONG_PTR) pvAspect,
                                        pdwFreeze);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_Freeze_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::Freeze.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DWORD __RPC_FAR *pdwFreeze)
{
    HRESULT hr;

    hr = This->lpVtbl->Freeze(This,
                              dwDrawAspect,
                              lindex,
                              (void *) pvAspect,
                              pdwFreeze);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetAdvise_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::GetAdvise.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [unique][out] */ DWORD __RPC_FAR *pAspects,
    /* [unique][out] */ DWORD __RPC_FAR *pAdvf,
    /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink)
{
    HRESULT hr;
    DWORD dwAspects = 0;
    DWORD dwAdvf = 0;

    hr = IViewObject_RemoteGetAdvise_Proxy(This,
                                           &dwAspects,
                                           &dwAdvf,
                                           ppAdvSink);

    if(pAspects != NULL)
    {
        *pAspects = dwAspects;
    }

    if(pAdvf != NULL)
    {
        *pAdvf = dwAdvf;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetAdvise_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::GetAdvise.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Stub( 
    IViewObject __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pAspects,
    /* [out] */ DWORD __RPC_FAR *pAdvf,
    /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink)
{
    HRESULT hr;

    hr = This->lpVtbl->GetAdvise(This,
                                 pAspects,
                                 pAdvf,
                                 ppAdvSink);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetColorSet_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IViewObject::GetColorSet.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Proxy(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    void __RPC_FAR *pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    HDC hicTargetDev,
    LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet)
{
    HRESULT hr;

    if(pvAspect != 0)
        return E_INVALIDARG;

    hr = IViewObject_RemoteGetColorSet_Proxy(This,
                                             dwDrawAspect,
                                             lindex,
                                             (LONG_PTR) pvAspect,
                                             ptd,
                                             (LONG_PTR) hicTargetDev,
                                             ppColorSet);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IViewObject_GetColorSet_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IViewObject::GetColorSet.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Stub(
    IViewObject __RPC_FAR * This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE __RPC_FAR *ptd,
    ULONG_PTR hicTargetDev,
    LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet)
{
    HRESULT hr;

    hr = This->lpVtbl->GetColorSet(This,
                                   dwDrawAspect,
                                   lindex,
                                   (void *)pvAspect,
                                   ptd,
                                   (HDC) hicTargetDev,
                                   ppColorSet);

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:    IEnumSTATPROPSTG_Next_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy(
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [unique][out][in] */ ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATPROPSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if (pceltFetched != 0)
    {
        *pceltFetched = celtFetched;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSTG_Next_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub(
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    return This->lpVtbl->Next(This, celt, rgelt, pceltFetched);
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSETSTG_Next_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy(
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [unique][out][in] */ ULONG __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    ULONG celtFetched = 0;

    if((celt > 1) && (pceltFetched == 0))
        return E_INVALIDARG;

    hr = IEnumSTATPROPSETSTG_RemoteNext_Proxy(This, celt, rgelt, &celtFetched);

    if (pceltFetched != 0)
    {
        *pceltFetched = celtFetched;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IEnumSTATPROPSETSTG_Next_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub(
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    return This->lpVtbl->Next(This, celt, rgelt, pceltFetched);
}

#ifdef _CAIRO_
//+-------------------------------------------------------------------------
//
//  Function:   IOverlappedStream_ReadOverlapped_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOverlappedStream_ReadOverlapped_Proxy(
                IOverlappedStream __RPC_FAR *This,
                /* [in, size_is(cb)] */ void * pv,
                /* [in] */ ULONG cb,
                /* [out] */ ULONG * pcbRead,
                /* [in,out] */ STGOVERLAPPED *lpOverlapped)
{
    HRESULT hr = IOverlappedStream_RemoteReadOverlapped_Proxy (
                /* IOverlappedStream * */ This,
                /* [in, size_is(cb)] */ (byte *) pv,
                /* [in] */ cb,
                /* [out] */ pcbRead,
                /* [in,out] */ lpOverlapped);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOverlappedStream_ReadOverlapped_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOverlappedStream_ReadOverlapped_Stub (
                IOverlappedStream __RPC_FAR *This,
                /* [in, size_is(cb)] */ byte * pv,
                /* [in] */ ULONG cb,
                /* [out] */ ULONG * pcbRead,
                /* [in,out] */ STGOVERLAPPED *lpOverlapped)
{
    return This->lpVtbl->ReadOverlapped(
                /* IOverlappedStream * */ This,
                /* [in, size_is(cb)] */ pv,
                /* [in] */ cb,
                /* [out] */ pcbRead,
                /* [in,out] */lpOverlapped);
}

//+-------------------------------------------------------------------------
//
//  Function:   IOverlappedStream_WriteOverlapped_Proxy
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOverlappedStream_WriteOverlapped_Proxy(
                IOverlappedStream __RPC_FAR *This,
                /* [in, size_is(cb)] */ void *pv,
                /* [in] */ ULONG cb,
                /* [out] */ ULONG * pcbWritten,
                /* [in,out] */ STGOVERLAPPED *lpOverlapped)
{
    HRESULT hr = IOverlappedStream_RemoteWriteOverlapped_Proxy (
                /* IOverlappedStream * */ This,
                /* [in, size_is(cb)] */ (byte *)pv,
                /* [in] */ cb,
                /* [out] */ pcbWritten,
                /* [in,out] */ lpOverlapped);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IOverlappedStream_WriteOverlapped_Stub
//
//  Synopsis:
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IOverlappedStream_WriteOverlapped_Stub (
                IOverlappedStream __RPC_FAR *This,
                /* [in, size_is(cb)] */ byte *pv,
                /* [in] */ ULONG cb,
                /* [out] */ ULONG * pcbWritten,
                /* [in,out] */ STGOVERLAPPED *lpOverlapped)
{
    return This->lpVtbl->WriteOverlapped(
                /* IOverlappedStream * */ This,
                /* [in, size_is(cb)] */ pv,
                /* [in] */ cb,
                /* [out] */ pcbWritten,
                /* [in,out] */ lpOverlapped);
}



#endif // _CAIRO_

//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAt_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IFillLockBytes::FillAt.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAt_Proxy(
    IFillLockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = IFillLockBytes_RemoteFillAt_Proxy(This, ulOffset, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAt_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IFillLockBytes::FillAt.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAt_Stub(
    IFillLockBytes __RPC_FAR * This,
    ULARGE_INTEGER ulOffset,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->FillAt(This, ulOffset, pv, cb, pcbWritten);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAppend_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IFillLockBytes::FillAppend.  This wrapper function handles the
//              case where pcbWritten is NULL.
//
//  Notes:      If pcbWritten != 0, then the number of bytes written
//              will be returned in *pcbWritten.  If an error
//              occurs, then *pcbWritten is set to zero.
//
//  History:    ?        ?          Created
//              05-27-94 AlexT      Actually return count of bytes written
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAppend_Proxy(
    IFillLockBytes __RPC_FAR * This,
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;
    ULONG cbWritten = 0;

#if DBG == 1
    //validate parameters.
    if(pv == 0)
        return STG_E_INVALIDPOINTER;
#endif

    hr = IFillLockBytes_RemoteFillAppend_Proxy(This, (byte __RPC_FAR *)pv, cb, &cbWritten);

    if(pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IFillLockBytes_FillAppend_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IFillLockBytes::FillAppend.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAppend_Stub(
    IFillLockBytes __RPC_FAR * This,
    const byte __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
    HRESULT hr;

    *pcbWritten = 0;
    hr = This->lpVtbl->FillAppend(This, pv, cb, pcbWritten);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\mega.h ===
// a giant mega idl file to put the whole proxy together

#include "unknwn.h"

#include "objidl.h"

#include "oleidl.h"

#include "oaidl.h"

#include "ocidl.h"

#include "contxt.h"

#ifdef DCOM

// internal interfaces used by DCOM
// this is private! (for now)
#include "oleprv.h"

// This is for the remote activation forwarding interface
#ifdef _CHICAGO_
#include "forward.h"
#endif // _CHICAGO_

#endif // DCOM

#ifdef ASYNC
#include "iconn.h"
#endif

#ifdef _CAIRO_
#include "storext.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\hpalette.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hpalette.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HPALETTE.
//
//  Functions:  
//              HPALETTE_UserSize
//              HPALETTE_UserMarshal
//              HPALETTE_UserUnmarshal
//              HPALETTE_UserFree
//              HPALETTE_UserSize64
//              HPALETTE_UserMarshal64
//              HPALETTE_UserUnmarshal64
//              HPALETTE_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserSize
//
//  Synopsis:   Get the wire size the HPALETTE handle and data.
//
//  Derivation: Union of a long and the hpalette handle.
//              Then the struct represents hpalette.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HPALETTE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return Offset;
    
    LENGTH_ALIGN( Offset, 3 );
    
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);
    
    if ( ! *pHPalette )
        return Offset;
    
    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Conformat struct with version and size and conf array of entries.
        
        Offset += sizeof(long) + 2 * sizeof(short);
        
        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        Offset += cEntries * sizeof(PALETTEENTRY);
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserMarshall
//
//  Synopsis:   Marshalls an HPALETTE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHPALETTE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHPalette);

        if ( ! *pHPalette )
            return pBuffer;

        // rpcLOGPALETTE
        // Logpalette is a conformant struct with a version field,
        // size filed and conformant array of palentries.

        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        // Conformant size

        *( PULONG_LV_CAST pBuffer)++ = cEntries;

        // Fields: both are short!
        // The old code was just setting the version number.
        // They say it has to be that way.

        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) 0x300;
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) cEntries;

        // Entries: each entry is a struct with 4 bytes.
        // Calculate the resultant data size

        DWORD cbData = cEntries * sizeof(PALETTEENTRY);

        if (cbData)
            {
            if (0 == GetPaletteEntries( *pHPalette,
                                        0,
                                        cEntries,
                                        (PALETTEENTRY *)pBuffer ) )
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }
            pBuffer += cbData;
            }
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHPalette);        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette,
    ULONG_PTR       BufferSize )
{
    HPALETTE        hPalette;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get disc and handle.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hPalette = (HPALETTE)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hPalette )
            {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE(
                BufferSize,
                cbFixup + (3 * sizeof(ULONG)) + (2 * sizeof(USHORT))) ;

            // Get the conformant size.

            DWORD           cEntries = *( PULONG_LV_CAST pBuffer)++;
            LOGPALETTE *    pLogPal;

            // If there are 0 color entries, we need to allocate the LOGPALETTE
            // structure with the one dummy entry (it's a variably sized struct).
            // Otherwise, we need to allocate enough space for the extra n-1
            // entries at the tail of the structure

            if (0 == cEntries)
                {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE));
                }
            else
                {
                pLogPal = (LOGPALETTE *)
                          WdtpAllocate( pFlags,
                                        sizeof(LOGPALETTE) +
                                        (cEntries - 1) * sizeof(PALETTEENTRY));
                }

            pLogPal->palVersion    = *( PUSHORT_LV_CAST pBuffer)++;
            pLogPal->palNumEntries = *( PUSHORT_LV_CAST pBuffer)++;
            if ( pLogPal->palVersion != 0x300 || pLogPal->palNumEntries != cEntries )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // If there are entries, move them into out LOGPALETTE structure

            if (cEntries)
                {
                // Check for EOB before accessing data.
                CHECK_BUFFER_SIZE(
                    BufferSize,
                    cbFixup + (3 * sizeof(ULONG)) +
                              (2 * sizeof(USHORT)) +
                              (cEntries * sizeof(PALETTEENTRY)) );

                memcpy( &(pLogPal->palPalEntry[0]),
                        pBuffer,
                        cEntries * sizeof(PALETTEENTRY) );
                pBuffer += cEntries * sizeof(PALETTEENTRY);
                }

            // Attempt to create the palette

            hPalette = CreatePalette(pLogPal);

            // Success or failure, we're done with the LOGPALETTE structure

            WdtpFree( pFlags, pLogPal );

            // If the creation failed, raise an exception

            if (NULL == hPalette)
                {
                RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
                }
            }
        }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

    // A new palette is ready, destroy the old one, if needed.

    if ( *pHPalette )
        DeleteObject( *pHPalette );

    *pHPalette = hPalette;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out inta a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HPALETTE_UserUnmarshalWorker( pFlags,
                                             pBufferStart,
                                             pHPalette,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserFree
//
//  Synopsis:   Free an HPALETTE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HPALETTE_UserFree(
    unsigned long * pFlags,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserFree\n"));

    if( pHPalette  &&  *pHPalette )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteObject( *pHPalette );
            }
        }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserSize64
//
//  Synopsis:   Get the wire size the HPALETTE handle and data.
//
//  Derivation: Union of a long and the hpalette handle.
//              Then the struct represents hpalette.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HPALETTE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned to 8)
    //   discriminant    4
    //   (align to 8)    4
    //   ptr or handle   8
    Offset += 16;

    if ( ! *pHPalette )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Conformat struct with version and size and conf array of entries.
        //   (aligned to 8)
        //   conformance    8
        //   palVersion     2
        //   palNumEntries  2
        //   entries        sizeof(PALETTEENTRY) * cEntries

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);
        Offset += 12 + (cEntries * sizeof(PALETTEENTRY));
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserMarshal64
//
//  Synopsis:   Marshalls an HPALETTE object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserMarshal\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.    
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHPALETTE
        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHPalette);

        if ( ! *pHPalette )
            return pBuffer;
        
        // rpcLOGPALETTE
        // Logpalette is a conformant struct with a version field,
        // size filed and conformant array of palentries.
        
        // Determine the number of color entries in the palette
        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        // Conformant size
        *( PHYPER_LV_CAST pBuffer)++ = cEntries;

        // Fields: both are short!
        // The old code was just setting the version number.
        // They say it has to be that way.
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) 0x300;
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) cEntries;

        // Entries: each entry is a struct with 4 bytes.
        // Calculate the resultant data size
        DWORD cbData = cEntries * sizeof(PALETTEENTRY);

        if (cbData)
        {
            if (0 == GetPaletteEntries( *pHPalette,
                                        0,
                                        cEntries,
                                        (PALETTEENTRY *)pBuffer ) )
            {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }

            pBuffer += cbData;
        }
    }
    else
    {
        // Sending a handle.
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHPalette);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    HPALETTE        hPalette;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // Get disc and handle.
    unsigned long UnionDisc = stream.ReadULONGNA();
    hPalette = (HPALETTE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hPalette )
        {
            // Get the conformant size.
            DWORD           cEntries = (DWORD)stream.ReadHYPER();
            LOGPALETTE *    pLogPal;

            // If there are 0 color entries, we need to allocate the LOGPALETTE
            // structure with the one dummy entry (it's a variably sized struct).
            // Otherwise, we need to allocate enough space for the extra n-1
            // entries at the tail of the structure
            
            if (0 == cEntries)
            {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE));
            }
            else
            {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE) +
                                                       (cEntries - 1) * sizeof(PALETTEENTRY));
            }

            pLogPal->palVersion    = stream.ReadUSHORTNA();
            pLogPal->palNumEntries = stream.ReadUSHORTNA();
            if ( pLogPal->palVersion != 0x300 || pLogPal->palNumEntries != cEntries )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // If there are entries, move them into out LOGPALETTE structure
            if (cEntries)
            {
                // Check for EOB before accessing data.
                stream.CheckSize(cEntries * sizeof(PALETTEENTRY));

                memcpy( &(pLogPal->palPalEntry[0]),
                        stream.GetBuffer(),
                        cEntries * sizeof(PALETTEENTRY) );
                
                stream.Advance(cEntries * sizeof(PALETTEENTRY));
            }

            // Attempt to create the palette
            hPalette = CreatePalette(pLogPal);

            // Success or failure, we're done with the LOGPALETTE structure
            WdtpFree( pFlags, pLogPal );

            // If the creation failed, raise an exception
            if (NULL == hPalette)
            {
                RAISE_RPC_EXCEPTION(HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    }
    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }
    
    // A new palette is ready, destroy the old one, if needed.
    if ( *pHPalette )
        DeleteObject( *pHPalette );

    *pHPalette = hPalette;
    
    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HPALETTE_UserUnmarshalWorker64( pFlags,
                                               pBufferStart,
                                               pHPalette,
                                               BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserFree64
//
//  Synopsis:   Free an HPALETTE.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HPALETTE_UserFree64 (
    unsigned long * pFlags,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserFree\n"));

    if( pHPalette  &&  *pHPalette )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteObject( *pHPalette );
        }
    }
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\hglobal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hglobal.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HGLOBAL.
//
//  Functions:  
//              HGLOBAL_UserSize
//              HGLOBAL_UserMarshal
//              HGLOBAL_UserUnmarshal
//              HGLOBAL_UserFree
//              HGLOBAL_UserSize64
//              HGLOBAL_UserMarshal64
//              HGLOBAL_UserUnmarshal64
//              HGLOBAL_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserSize
//
//  Synopsis:   Get the wire size the HGLOBAL handle and data.
//
//  Derivation: Conformant struct with a flag field:
//                  align + 12 + data size.
//
//  history:    May-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HGLOBAL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return Offset;

    // userHGLOBAL: the encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    LENGTH_ALIGN( Offset, 3 );

    // Union discriminent is 4 bytes
    Offset += sizeof( long );

    // Handle represented by a polymorphic type - for inproc case only!
    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        LENGTH_ALIGN( Offset, sizeof( HGLOBAL )-1 );
        Offset += sizeof( HGLOBAL );
    }
    else
        Offset += ( sizeof(long) + sizeof(HGLOBAL) );
    
    if ( ! *pGlobal )
        return Offset;
    
    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize = (ULONG) GlobalSize( *pGlobal );
        
        Offset += 3 * sizeof(long) + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserMarshall
//
//  Synopsis:   Marshalls an HGLOBAL object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return pBuffer;

    // We marshal a null handle, too.

    UserNdrDebugOut((UNDR_OUT4, "HGLOBAL_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize;
        
        // userHGLOBAL
        
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
        
        
        if ( ! *pGlobal )
            return pBuffer;
        
        // FLAGGED_BYTE_BLOB

        ulDataSize = (ULONG) GlobalSize( *pGlobal );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        // Handle is the non-null flag

        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if( ulDataSize )
        {
            void * pData = GlobalLock( *pGlobal);
            memcpy( pBuffer, pData, ulDataSize );
            GlobalUnlock( *pGlobal);
        }

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        // For WIN64 HGLOBALs, 64 bits may by significant (e.i. GPTR).
#if defined(_WIN64)
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)pGlobal;
#else
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pGlobal );
#endif
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpGlobalUnmarshal
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  Note:       Reallocation is forbidden when the hglobal is part of
//              an [in,out] STGMEDIUM in IDataObject::GetDataHere.
//              This affects only data passing with old handles being
//              non null.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpGlobalUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal,
    BOOL            fCanReallocate,
    ULONG_PTR       BufferSize )
{
    unsigned long   ulDataSize, fHandle, UnionDisc;
    HGLOBAL         hGlobal;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag from buffer.
    UnionDisc = *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        // Get the marker from the buffer.
        hGlobal = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        
        // If handle is NULL, we are done.
        if ( ! hGlobal )
        {
            if ( *pGlobal )
                GlobalFree( *pGlobal );
            *pGlobal = NULL;
            return pBuffer;
        }

        // Check for EOB before accessing header.
        CHECK_BUFFER_SIZE( BufferSize, cbFixup + (5 * sizeof( ULONG )) );

        // Get the rest of the header from the buffer.
                ulDataSize    = *( PULONG_LV_CAST pBuffer)++;
        HGLOBAL hGlobalDup    = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        ULONG   ulDataSizeDup = *( PULONG_LV_CAST pBuffer)++;

        // Validate the header: handle and size are put on wire twice, make
        // sure both instances of each are the same.
        if ( (hGlobalDup != hGlobal) ||
             (ulDataSizeDup != ulDataSize) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        if ( *pGlobal )
        {
            // Check for reallocation

            if ( GlobalSize( *pGlobal ) == ulDataSize )
                hGlobal = *pGlobal;
            else
            {
                if ( fCanReallocate )
                {
                    GlobalFree( *pGlobal );
                    hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
                }
                else
                {
                    if ( GlobalSize(*pGlobal) < ulDataSize )
                    {
                        RAISE_RPC_EXCEPTION( STG_E_MEDIUMFULL );
                    }
                    else
                        hGlobal = *pGlobal;
                }
            }
        }
        else
        {
            // allocate a new block
            
            hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
        }
        
        if ( hGlobal == NULL )
        {
            RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
        }
        else
        {
            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize,
                               cbFixup + (5 * sizeof( ULONG )) + ulDataSize );
            
            // Get the data from the buffer.
            void * pData = GlobalLock( hGlobal);
            memcpy( pData, pBuffer, ulDataSize );
            pBuffer += ulDataSize;
            GlobalUnlock( hGlobal);
        }
    }
    else
    {
        // Sending a handle only.
        // Reallocation problem doesn't apply to handle passing.
        
        if ( IS_HANDLE_MARKER( UnionDisc ) )
        {
            hGlobal = (HGLOBAL) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
        }
        else if (IS_HANDLE64_MARKER( UnionDisc ) )
        {
            ALIGN( pBuffer, 7 );
            
            // Must be enough buffer to do alignment fixup.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup +
                               (ULONG_PTR) (pBuffer - pBufferStart) + sizeof( __int64 ));
            
            hGlobal = (HGLOBAL) ( *( PHYPER_LV_CAST pBuffer)++ );
        }
        else
        {
            RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }
        
        if ( *pGlobal != hGlobal  && *pGlobal )
            GlobalFree( *pGlobal );
    }
    
    *pGlobal = hGlobal;
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = WdtpGlobalUnmarshal( pFlags,
                                   pBufferStart,
                                   pGlobal,
                                   TRUE,              // reallocation possible
                                   BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserFree
//
//  Synopsis:   Free an HGLOBAL.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HGLOBAL_UserFree(
    unsigned long * pFlags,
    HGLOBAL *       pGlobal)
{
    if( pGlobal  &&  *pGlobal )
    {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            GlobalFree( *pGlobal);
    }
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserSize64
//
//  Synopsis:   Get the wire size the HGLOBAL handle and data.
//
//  Derivation: Union around a pointer to a conformant struct with a 
//              flag field.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HGLOBAL_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return Offset;

    // userHGLOBAL: the encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    // Union discriminent is 4 bytes, but it contains a pointer, so 
    // align on union is 8 bytes.
    LENGTH_ALIGN( Offset, 7 );   
    Offset += sizeof( long );
    LENGTH_ALIGN( Offset, 7 );

    // Handle represented by a polymorphic type - for inproc case only!
    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        // Doesn't matter which arm we take inproc, it's size of native
        // HGLOBAL.
        Offset += sizeof( HGLOBAL );
    }
    else
    {
        // Pointer representation...
        Offset += 8;
    }

    if ( ! *pGlobal )
        return Offset;

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        // Struct must be aligned on 8, but already aligned on 
        // 8...

        unsigned long   ulDataSize = (ULONG) GlobalSize( *pGlobal );
        
        Offset += 8 + 2 * sizeof(long) + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserMarshal64
//
//  Synopsis:   Marshalls an HGLOBAL object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return pBuffer;

    // We marshal a null handle, too.

    UserNdrDebugOut((UNDR_OUT4, "HGLOBAL_UserMarshal\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.
    if ( HGLOBAL_DATA_PASSING(*pFlags) )
    {
        unsigned long   ulDataSize;

        // userHGLOBAL
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)*pGlobal;

        if ( ! *pGlobal )
            return pBuffer;
        
        // FLAGGED_BYTE_BLOB
        ulDataSize = (ULONG) GlobalSize( *pGlobal );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;

        // Handle is the non-null flag
        *( PLONG_LV_CAST pBuffer)++  = HandleToLong( *pGlobal );
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if( ulDataSize )
        {
            void * pData = GlobalLock( *pGlobal);
            memcpy( pBuffer, pData, ulDataSize );
            GlobalUnlock( *pGlobal);
        }

        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        // For WIN64 HGLOBALs, 64 bits may by significant (e.i. GPTR).
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)pGlobal;
    }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpGlobalUnmarshal64
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  Note:       Reallocation is forbidden when the hglobal is part of
//              an [in,out] STGMEDIUM in IDataObject::GetDataHere.
//              This affects only data passing with old handles being
//              non null.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpGlobalUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal,
    BOOL            fCanReallocate,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    unsigned long   ulDataSize, fHandle, UnionDisc;
    HGLOBAL         hGlobal;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // Get the tag from buffer.
    UnionDisc = stream.ReadULONGNA();

    // Get the marker from the buffer.
    hGlobal = (HGLOBAL)stream.ReadHYPER();

    if ( IS_DATA_MARKER(UnionDisc) )
    {
        // If the handle was NULL, return out now.
        if (!hGlobal)
        {
            if (*pGlobal)
                GlobalFree(*pGlobal);
            *pGlobal = NULL;
            return stream.GetBuffer();
        }

        // Get the rest of the header from the buffer.
              ulDataSize    = (ULONG)stream.ReadHYPERNA();
         LONG hGlobalDup    = stream.ReadLONGNA();
        ULONG ulDataSizeDup = stream.ReadULONGNA();
            
        // Validate the header: handle and size are put on wire twice, make
        // sure both instances of each are the same.
        if ( (hGlobalDup != HandleToLong(hGlobal)) ||
             (ulDataSizeDup != ulDataSize) )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        
        if ( *pGlobal )
        {
            // Check for reallocation            
            if ( GlobalSize( *pGlobal ) == ulDataSize )
                hGlobal = *pGlobal;
            else
            {
                if ( fCanReallocate )
                {
                    GlobalFree( *pGlobal );
                    hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
                }
                else
                {
                    if ( GlobalSize(*pGlobal) < ulDataSize )
                    {
                        RAISE_RPC_EXCEPTION( STG_E_MEDIUMFULL );
                    }
                    else
                        hGlobal = *pGlobal;
                }
            }
        }
        else
        {
            // allocate a new block            
            hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
        }
        
        if ( hGlobal == NULL )
        {
            RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
        }
        else
        {
            // Check for EOB before accessing data.
            stream.CheckSize(ulDataSize);
            
            // Get the data from the buffer.
            void * pData = GlobalLock( hGlobal);
            memcpy( pData, stream.GetBuffer(), ulDataSize );
            GlobalUnlock( hGlobal);
            
            stream.Advance(ulDataSize);
        }
    }
    else if (IS_HANDLE64_MARKER( UnionDisc ))
    {
        // Make sure the old stuff is cleaned up...
        if ( *pGlobal != hGlobal  && *pGlobal )
            GlobalFree( *pGlobal );    
    }
    else
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }
    
    *pGlobal = hGlobal;
    
    return( stream.GetBuffer() );
}
    
//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = WdtpGlobalUnmarshal64( pFlags,
                                     pBufferStart,
                                     pGlobal,
                                     TRUE,              // reallocation possible
                                     BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserFree64
//
//  Synopsis:   Free an HGLOBAL.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void __RPC_USER
HGLOBAL_UserFree64 (
    unsigned long * pFlags,
    HGLOBAL *       pGlobal)
{
    if( pGlobal  &&  *pGlobal )
    {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            GlobalFree( *pGlobal);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\prop.h ===
#include "propidl.h"  // Public property interfaces
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\remunkps.cxx ===
//+-------------------------------------------------------------------
//
//  File:       remunkps.cxx
//
//  Contents:   IRemoteUnnknown custom proxy/stub implementation
//
//  Classes:    CRemUnknownFactory
//              CRemUnknownSyncP
//              CRemUnknownAsyncP
//
//  History:    15-Dec-97       MattSmit  Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include "remunkps.hxx"
#include "..\..\com\dcomrem\sync.hxx"
// out internal psclass factory implementation
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);



//+--------------------------------------------------------------------
//
// Function:  RemUnkGetClassObject
//
// Synopsis:  Creates a factory object for our custom IRemUnknown proxy.
//
//---------------------------------------------------------------------

HRESULT RemUnkPSGetClassObject(REFIID riid, LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL, "RemUnkPSGetClassObject IN riid:%I, ppv:0x%x\n", &riid, ppv));


    HRESULT hr = E_OUTOFMEMORY;
    CRemUnknownFactory *pObj = new CRemUnknownFactory();
    if (pObj)
    {
        hr = pObj->QueryInterface(riid, ppv);
    }
    ComDebOut((DEB_CHANNEL, "RemUnkPSGetClassObject OUT hr:0x%x\n", hr));
    return hr;



}
//+-------------------------------------------------------------------
//
// Class:      CRemUnknownFactory
//
// Synopsis:   Custom factory for the proxy/stub for IRemUnknown.
//
//--------------------------------------------------------------------

//+-------------------------------------------------------------------
//
// Interface:  IUnKnown
//
// Synopsis:   Simple IUnknown implementation.  QI will support
//             IPSFactoryBuffer
//
//--------------------------------------------------------------------

STDMETHODIMP CRemUnknownFactory::QueryInterface(REFIID riid, PVOID *pv)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownFactory::QueryInterface IN riid:%I, pv:0x%x\n", &riid, pv));

    if ((riid == IID_IUnknown) || (riid == IID_IPSFactoryBuffer))
    {
        *pv = this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }


}

STDMETHODIMP_(ULONG) CRemUnknownFactory::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}


STDMETHODIMP_(ULONG) CRemUnknownFactory::Release()
{
    ULONG ret = InterlockedDecrement((PLONG) &_cRefs);
    if (ret == 0)
    {
        delete this;
    }
    return ret;
}




//+-------------------------------------------------------------------
//
// Interface:  IPSFactoryBuffer
//
//--------------------------------------------------------------------


//+-------------------------------------------------------------------
//
// Method:     CreateProxy
//
// Synopsis:   Creates a custom synchronous proxy object so we can
//             implement ICallFactory on the proxy.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownFactory::CreateProxy(IUnknown *pUnkOuter,
                                             REFIID riid,
                                             IRpcProxyBuffer **ppProxy,
                                             void **ppv)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownFactory::CreateProxy IN pUnkOuter:0x%x, riid:%I,"
                " ppProxy:0x%x, ppv:0x%x\n", pUnkOuter, &riid, ppProxy, ppv));

    HRESULT hr;
    Win4Assert((riid == IID_IRemUnknown) ||
               (riid == IID_IRemUnknown2) ||
               (riid == IID_IRemUnknownN) ||
               (riid == IID_IRundown)) ;

    hr = E_OUTOFMEMORY;
    CRemUnknownSyncP *pObj = new CRemUnknownSyncP();
    if (pObj)
    {
        hr = pObj->Init(pUnkOuter, riid, ppProxy, ppv);
        pObj->_IntUnk.Release();
    }

    // Clean up out parameters on error.
    if (FAILED(hr))
    {
        *ppProxy = NULL;
        *ppv     = NULL;
    }

    ComDebOut((DEB_CHANNEL, "CRemUnknownFactory::CreateProxy OUT hr:0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
// Method:     CreateStub
//
// Synopsis:   Create the MIDL generated stub and give it back
//             because we do not need to get involved on the server
//             side.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownFactory::CreateStub(REFIID riid,
                                            IUnknown *pUnkServer,
                                            IRpcStubBuffer **ppStub)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownFactory::CreateStub IN riid:%I, pUnkServer:0x%x, ppStub:0x%x\n",
               &riid, pUnkServer, ppStub));
    HRESULT hr;
    IPSFactoryBuffer *pFac;
    if (SUCCEEDED(hr = ProxyDllGetClassObject(CLSID_PSOlePrx32, IID_IPSFactoryBuffer, (void **) &pFac)))
    {
        hr = pFac->CreateStub(riid, pUnkServer, ppStub);
        pFac->Release();
    }
    ComDebOut((DEB_CHANNEL, "CRemUnknownFactory::CreateStub OUT hr:0x%x\n", hr));

    return hr;
}







//+-------------------------------------------------------------------
//
// Class:      CRemUnknownSyncP::CRpcProxyBuffer
//
// Synopsis:   Internal Unknown and IRpcProxyBuffer implementation
//             for CRemUnknownSyncP
//
//--------------------------------------------------------------------
//+-------------------------------------------------------------------
//
// Interface:  IUnKnown
//
// Synopsis:   Simple IUnknown implementation.  QI will support
//             IRpcProxyBuffer, ICallFactory and delegate the
//             rest to the MIDL implementation
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownSyncP::CRpcProxyBuffer::QueryInterface(REFIID riid, PVOID *pv)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::CRpcProxyBuffer::QueryInterface"
               " riid:%I, pv:0x%x\n", &riid, pv));

    CRemUnknownSyncP *This = (CRemUnknownSyncP *) (((BYTE *) this) - offsetof(CRemUnknownSyncP, _IntUnk));

    if ((riid == IID_IUnknown) || (riid == IID_IRpcProxyBuffer))
    {
        *pv = this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_ICallFactory)
    {
        *pv = (ICallFactory * ) This;
        This->AddRef();
        return S_OK;
    }
    else
    {
        return This->_pPrx->QueryInterface(riid, pv);
    }
}

STDMETHODIMP_(ULONG) CRemUnknownSyncP::CRpcProxyBuffer::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}


STDMETHODIMP_(ULONG) CRemUnknownSyncP::CRpcProxyBuffer::Release()
{
    ULONG ret = InterlockedDecrement((PLONG) &_cRefs);
    if (ret == 0)
    {
        CRemUnknownSyncP *This = (CRemUnknownSyncP *) (((BYTE *) this) - offsetof(CRemUnknownSyncP, _IntUnk));
        delete This;
    }
    return ret;
}



//+-------------------------------------------------------------------
//
// Interface:  IRpcProxyBuffer
//
// Synopsis:   Delegates IrpcProxyBuffer calls to the MIDL generated
//
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownSyncP::CRpcProxyBuffer::Connect(IRpcChannelBuffer *pRpcChannelBuffer)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::CRpcProxyBuffer::Connect pRpcChannelBuffer:0x%x\n", pRpcChannelBuffer));

    CRemUnknownSyncP *This = (CRemUnknownSyncP *) (((BYTE *) this) - offsetof(CRemUnknownSyncP, _IntUnk));
    return This->_pPrx->Connect(pRpcChannelBuffer);
}


STDMETHODIMP_(void) CRemUnknownSyncP::CRpcProxyBuffer::Disconnect()
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::CRpcProxyBuffer::Disconnect\n" ));

    CRemUnknownSyncP *This = (CRemUnknownSyncP *) (((BYTE *) this) - offsetof(CRemUnknownSyncP, _IntUnk));
    This->_pPrx->Disconnect();
}





//+-------------------------------------------------------------------
//
// Class:      CRemUnknownSyncP
//
// Synopsis:   Synchronous proxy for IRemUknown
//
//--------------------------------------------------------------------
//+-------------------------------------------------------------------
//
// Method:     Init
//
// Synopsis:   Initializes the proxy wrapper by creating the MIDL
//             generated proxy and saving the outer unknown.
//
//--------------------------------------------------------------------
HRESULT CRemUnknownSyncP::Init(IUnknown *pUnkOuter,
                               REFIID riid,
                               IRpcProxyBuffer **ppProxy,
                               void **ppv)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::Init IN pUnkOuter:0x%x,"
               " riid:%I, ppProxy:0x%x, ppv:0x%x\n", pUnkOuter, &riid, ppProxy, ppv));

    HRESULT hr;

    _pCtrlUnk = pUnkOuter;
    IPSFactoryBuffer *pFac;
    if (SUCCEEDED(hr = ProxyDllGetClassObject(CLSID_PSOlePrx32, IID_IPSFactoryBuffer, (void **) &pFac)))
    {
        IRpcProxyBuffer *pPrx = 0;
        if (SUCCEEDED(hr = pFac->CreateProxy(pUnkOuter, riid, &pPrx, ppv)))
        {
            _pPrx = pPrx;
            *ppProxy = &_IntUnk;
            (*ppProxy)->AddRef();

        }
        pFac->Release();
    }

    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::Init OUT hr:0x%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
// Method:     Destructor
//
// Synopsis:   Release the MIDL generated proxy if we aquired it.
//
//--------------------------------------------------------------------

CRemUnknownSyncP::~CRemUnknownSyncP()
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP~CRemUnknownSyncP \n" ));

    if (_pPrx)
    {
        _pPrx->Release();
        _pPrx = NULL;
    }
}



//+-------------------------------------------------------------------
//
// Interface:  IUnKnown
//
// Synopsis:   Simple IUnknown implementation.  Delegates to outer.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownSyncP::QueryInterface(REFIID riid, PVOID *pv)
{
    return _pCtrlUnk->QueryInterface(riid, pv);
}
STDMETHODIMP_(ULONG) CRemUnknownSyncP::AddRef()
{
    return _pCtrlUnk->AddRef();
}
STDMETHODIMP_(ULONG) CRemUnknownSyncP::Release()
{
    return _pCtrlUnk->Release();
}


//+-------------------------------------------------------------------
//
// Interface:  ICallFactory
//
// Synopsis:   Interface for creating asynchronous call objects
//
//--------------------------------------------------------------------
//+-------------------------------------------------------------------
//
// Method:     CreateCall
//
// Synopsis:   create and initialize an async call object
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownSyncP::CreateCall(REFIID                riid,
                                          IUnknown             *pCtrlUnk,
                                          REFIID                riid2,
                                          IUnknown **ppUnk)
{

    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::CreateCall IN "
               "riid:%I, pCtrlUnk:0x%x, riid2:%I, ppUnk:0x%x\n",
                &riid, pCtrlUnk, &riid2, ppUnk));

    HRESULT hr = E_OUTOFMEMORY;
    Win4Assert((riid == IID_AsyncIRemUnknown) || (riid == IID_AsyncIRemUnknown2));
    CRemUnknownAsyncCallP *pObj = new CRemUnknownAsyncCallP(pCtrlUnk);
    if (pObj)
    {
        hr = pObj->_IntUnk.QueryInterface(riid2, (void **) ppUnk);
        pObj->_IntUnk.Release();
    }

    ComDebOut((DEB_CHANNEL, "CRemUnknownSyncP::CreateCall OUT hr:0x%x\n", hr));
    return hr;
}













//+-------------------------------------------------------------------
//
// Class:      CRemUnknownAsyncCallP::CRpcProxyBuffer
//
// Synopsis:   Inner unknown and proxy buffer interface
//
//--------------------------------------------------------------------
//+-------------------------------------------------------------------
//
// Interface:  IUnKnown
//
// Synopsis:   Simple IUnknown implementation.  QI will support
//             IRpcProxyBuffer and AsyncIRemUnknown
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::CRpcProxyBuffer::QueryInterface(REFIID riid, PVOID *pv)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::CRpcProxyBuffer::QueryInterface "
               " riid:%I, pv:0x%x\n", &riid, pv));

    CRemUnknownAsyncCallP *This = (CRemUnknownAsyncCallP *) (((BYTE *) this) - offsetof(CRemUnknownAsyncCallP, _IntUnk));

    if ((riid == IID_IUnknown) || (riid == IID_IRpcProxyBuffer))
    {
        *pv = this;
        AddRef();
        return S_OK;
    }
    else if ((riid == IID_AsyncIRemUnknown) || (riid == IID_AsyncIRemUnknown2) )
    {
        *pv = (AsyncIRemUnknown2 * ) This;
        This->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CRemUnknownAsyncCallP::CRpcProxyBuffer::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}


STDMETHODIMP_(ULONG) CRemUnknownAsyncCallP::CRpcProxyBuffer::Release()
{
    ULONG ret = InterlockedDecrement((PLONG) &_cRefs);
    if (ret == 0)
    {
        CRemUnknownAsyncCallP *This = (CRemUnknownAsyncCallP *) (((BYTE *) this) - offsetof(CRemUnknownAsyncCallP, _IntUnk));
        delete This;
    }
    return ret;
}



//+-------------------------------------------------------------------
//
// Interface:  IRpcProxyBuffer
//
// Synopsis:   handles logistics of connecting and disconnecting
//             the proxy call object
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::CRpcProxyBuffer::Connect(IRpcChannelBuffer *pRpcChannelBuffer)
{
    CRemUnknownAsyncCallP *This = (CRemUnknownAsyncCallP *) (((BYTE *) this) - offsetof(CRemUnknownAsyncCallP, _IntUnk));
    Win4Assert(!This->_pChnl);
    return pRpcChannelBuffer->QueryInterface(IID_IAsyncRpcChannelBuffer, (void **) &(This->_pChnl));
}


STDMETHODIMP_(void) CRemUnknownAsyncCallP::CRpcProxyBuffer::Disconnect(void)
{
    CRemUnknownAsyncCallP *This = (CRemUnknownAsyncCallP *) (((BYTE *) this) - offsetof(CRemUnknownAsyncCallP, _IntUnk));
    if (This->_pChnl)
    {
        This->_pChnl->Release();
        This->_pChnl = NULL;
    }
}








//+-------------------------------------------------------------------
//
// Class:      CRemUnknownAsyncCallP
//
// Synopsis:   Asynchronous proxy call object for IRemUknown
//
//--------------------------------------------------------------------
//+-------------------------------------------------------------------
//
// Interface:  IUnKnown
//
// Synopsis:   Simple IUnknown implementation.  Delegates to outer.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::QueryInterface(REFIID riid, PVOID *pv)
{
    return _pCtrlUnk->QueryInterface(riid, pv);
}

STDMETHODIMP_(ULONG) CRemUnknownAsyncCallP::AddRef()
{
    return _pCtrlUnk->AddRef();
}
STDMETHODIMP_(ULONG) CRemUnknownAsyncCallP::Release()
{
    return _pCtrlUnk->Release();
}





//+-------------------------------------------------------------------
//
// Interface:  AsyncIRemUnknown
//
// Synopsis:   This is the actual async interface which will marshal
//             the parameters.
//
//--------------------------------------------------------------------
//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Begin_RemQueryInterface
//
//  Synopsis:      Marshal paramenters and save cIids
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Begin_RemQueryInterface(
        REFIPID                ripid,
        unsigned long          cRefs,
        unsigned short         cIids,
        IID                   *iids
    )
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface IN"
               " ripid:%I, crefs:0x%d, cIids:0x%d, iids:%I\n",
               &ripid, cRefs, cIids, iids));


    _hr = S_OK;
    HRESULT hr;

    // Get the synchronize interface
    ISynchronize *pSync;
    if (FAILED(hr = _pCtrlUnk->QueryInterface(IID_ISynchronize, (void **) &pSync) ))
    {
        ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface"
                    " FAILED QI for ISyncronize\n"));
        return hr;
    }

    // set up message
    memset(&_msg, 0, sizeof(RPCOLEMESSAGE));

    _msg.cbBuffer = sizeof(IPID) +                       // ripid
        sizeof(unsigned long) +                          // cRefs
        sizeof(unsigned short) + 2 +                     // cIids + padding
        sizeof(unsigned long)  + (cIids * sizeof(IID));  // iids

    _msg.rpcFlags = RPC_BUFFER_ASYNC;
    _msg.iMethod = 3;

    // get buffer
    if (SUCCEEDED(hr = _pChnl->GetBuffer(&_msg, IID_IRemUnknown)))
    {
        ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface  "
                   "buffer obtained _msg.cbBuffer:%d, _msg.Buffer:0x%x \n",
                   _msg.cbBuffer, _msg.Buffer));

        BYTE * p = (BYTE *)_msg.Buffer;
        memset(p, 0, _msg.cbBuffer);

        // marshal the parameters
        memcpy(p, &ripid, sizeof(IPID));
        p += sizeof(IPID);
        memcpy(p, &cRefs, sizeof(cRefs));
        p += sizeof (cRefs);
        memcpy(p, &cIids, sizeof(unsigned short));
        p += sizeof (unsigned short) + 2;
        memcpy(p, &cIids, sizeof(unsigned short));
        p += sizeof (unsigned long);
        unsigned short i;
        for (i=0; i<cIids; i++)
        {
            memcpy(p, iids+i, sizeof(IID));
            p += sizeof (IID);
        }

        // save this for later
        _cIids = cIids;



        // send
        ULONG status;
        hr = _pChnl->Send(&_msg, pSync, &status);

    }
    if (FAILED(hr))
    {
        pSync->Signal();
        _hr = hr;
    }
    pSync->Release();

    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface OUT hr:0x%x\n", hr));

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Finish_RemQueryInterface
//
//  Synopsis:      Unmarshal QI parameters
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Finish_RemQueryInterface(REMQIRESULT **ppQIResults)
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface IN ppQIResults:0x%x\n", ppQIResults));

    HRESULT hr;

    // check state
    if (FAILED(_hr) )
    {
        return _hr;
    }

    // ensure call has completed
    ISynchronize *pSync;
    if (SUCCEEDED(_pCtrlUnk->QueryInterface(IID_ISynchronize, (void **) &pSync) ))
    {
        hr = pSync->Wait(0, INFINITE);
        pSync->Release();

        if (FAILED(hr))
        {
            return hr;
        }
    }

    // receive
    ULONG status;
    if (SUCCEEDED(hr = _pChnl->Receive(&_msg, &status)))
    {

        hr = E_OUTOFMEMORY;
        // unmarshal parameters
        REMQIRESULT *p = (REMQIRESULT *)CoTaskMemAlloc(_cIids * sizeof(REMQIRESULT));

        if (p)
        {
            ComDebOut((DEB_CHANNEL, "_cIids = 0x%x, _msg.cbBuffer = 0x%x, _msg.Buffer=0x%x\n",
                       _cIids, _msg.cbBuffer, _msg.Buffer));
            ComDebOut((DEB_CHANNEL, "sizeof(REMQIRESULT)=0x%x, offsetof(REMQIRESULT, std)=0x%x\n",
                       sizeof(REMQIRESULT),offsetof(REMQIRESULT, std)));


//            Win4Assert(_cIids == ((unsigned long *) _msg.Buffer)[1]);
            BYTE * pBuffer = (BYTE *)_msg.Buffer;
            pBuffer += sizeof(DWORD)*2;
            memcpy(p, pBuffer, sizeof(REMQIRESULT) *_cIids);

            *ppQIResults = p;
            hr = S_OK;
        }

        // free the buffer
        _pChnl->FreeBuffer(&_msg);
    }
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface OUT hr:0x%x\n", hr));
    return hr;

}

//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Begin_RemAddRef
//
//  Synopsis:      Not implemented. Never used
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Begin_RemAddRef(unsigned short cInterfaceRefs,
                                                    REMINTERFACEREF InterfaceRefs[])
{
    return E_NOTIMPL;
}
//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Finish_RemAddRef
//
//  Synopsis:      Not implemented. Never used
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Finish_RemAddRef(HRESULT *pResults)
{
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Begin_RemRelease
//
//  Synopsis:      Marshal parameters.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Begin_RemRelease(unsigned short cInterfaceRefs,
                                                     REMINTERFACEREF InterfaceRefs[])
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemRelease IN cInterfaceRefs:0x%d, ",
               "InterfaceRefs:0x%x\n", cInterfaceRefs, InterfaceRefs));


    _hr = S_OK;
    HRESULT hr;

    // Get the synchronize interface
    ISynchronize *pSync;
    if (FAILED(hr = _pCtrlUnk->QueryInterface(IID_ISynchronize, (void **) &pSync) ))
    {
        ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemRelease FAILED QI for ISyncronize\n"));
        return hr;
    }

    // set up message
    memset(&_msg, 0, sizeof(RPCOLEMESSAGE));

    _msg.cbBuffer = sizeof(unsigned short) + 2 + // cInterfaceRefs
        sizeof(unsigned long) + (sizeof(REMINTERFACEREF) * cInterfaceRefs); // InterfaceRefs[]

    _msg.rpcFlags = RPC_BUFFER_ASYNC;
    _msg.iMethod = 5;

    // get buffer
    if (SUCCEEDED(hr = _pChnl->GetBuffer(&_msg, IID_IRemUnknown)))
    {
        BYTE * p = (BYTE *)_msg.Buffer;
        memset(p, 0, _msg.cbBuffer);

        // marshal the parameters

        memcpy(p, &cInterfaceRefs, sizeof(unsigned short));
        p += sizeof (unsigned short) + 2;
        memcpy(p, &cInterfaceRefs, sizeof(unsigned short));
        p += sizeof (unsigned long);
        unsigned short i;
        for (i=0; i<cInterfaceRefs; i++)
        {
            memcpy(p, InterfaceRefs+i, sizeof(REMINTERFACEREF));
            p += sizeof (REMINTERFACEREF);
        }

        // send
        ULONG status;
        hr = _pChnl->Send(&_msg, pSync, &status);

    }
    else
    {
        pSync->Signal();
    }

    if (FAILED(hr))
    {
        _hr = hr;
    }

    pSync->Release();


    return hr;
}
//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Finish_RemRelease
//
//  Synopsis:      Check state and return.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Finish_RemRelease()
{

    HRESULT hr;

    // check state
    if (FAILED(_hr) )
    {
        return _hr;
    }

    // ensure call has completed
    ISynchronize *pSync;
    if (SUCCEEDED(_pCtrlUnk->QueryInterface(IID_ISynchronize, (void **) &pSync) ))
    {
        hr = pSync->Wait(0, INFINITE);
        pSync->Release();

        if (FAILED(hr))
        {
            return hr;
        }
    }

    // receive
    ULONG status;
    if (SUCCEEDED(hr = _pChnl->Receive(&_msg, &status)))
    {

        // free the buffer
        _pChnl->FreeBuffer(&_msg);
    }

    return hr;


}


//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Begin_RemQueryInterface2
//
//  Synopsis:      Marshal parameters, save count for Finish.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Begin_RemQueryInterface2 (
        REFIPID                            ripid,
        unsigned short                     cIids,
        IID                               *iids
    )

{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface2 IN "
               "ripid:%I, cIids:0x%d, iids:0x%x\n", &ripid, cIids, iids));

    _hr = S_OK;
    HRESULT hr;

    // Get the synchronize interface
    ISynchronize *pSync;
    if (FAILED(hr = _pCtrlUnk->QueryInterface(IID_ISynchronize, (void **) &pSync) ))
    {
        ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface2 FAILED QI for ISynchronize\n"));
        return hr;
    }

    // set up message
    memset(&_msg, 0, sizeof(RPCOLEMESSAGE));

    _msg.cbBuffer = sizeof(IPID) +                       // ripid
        sizeof(unsigned short) + 2 +                     // cIids + padding
        sizeof(unsigned long)  + (cIids * sizeof(IID));  // iids

    _msg.rpcFlags = RPC_BUFFER_ASYNC;
    _msg.iMethod = 6;

    // get buffer
    if (SUCCEEDED(hr = _pChnl->GetBuffer(&_msg, IID_IRemUnknown)))
    {
        BYTE * p = (BYTE *)_msg.Buffer;
        memset(p, 0, _msg.cbBuffer);

        // marshal the parameters
        memcpy(p, &ripid, sizeof(IPID));
        p += sizeof(IPID);
        memcpy(p, &cIids, sizeof(unsigned short));
        p += sizeof (unsigned short) + 2;
        memcpy(p, &cIids, sizeof(unsigned short));
        p += sizeof (unsigned long);
        memcpy(p, iids, sizeof(IID) * cIids);


        ComDebOut((DEB_CHANNEL, "RemQueryInterface2: _msg.Buffer:%x\n", _msg.Buffer));

        // save this for later
        _cIids = cIids;



        // send
        ULONG status;
        hr = _pChnl->Send(&_msg, pSync, &status);

    }
    if (FAILED(hr))
    {
        pSync->Signal();
        _hr = hr;
    }
    pSync->Release();

    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Begin_RemQueryInterface2 OUT hr:0x%x\n", hr));

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CRemUnknownAsyncCallP::Finish_RemQueryInterface2
//
//  Synopsis:      Unmarshal out parameters.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRemUnknownAsyncCallP::Finish_RemQueryInterface2(
        HRESULT           *phr,
        MInterfacePointer **ppMIF
    )
{
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface2 IN "
                "phr:0x%x, ppMIF:0x%x\n", phr, ppMIF));

    HRESULT hr;

    // check state
    if (FAILED(_hr) )
    {
        return _hr;
    }

    // ensure call has completed
    hr = WaitObject(_pCtrlUnk, 0, INFINITE);
    if (FAILED(hr))
    {
        return hr;
    }

    // receive
    ULONG status;
    if (SUCCEEDED(hr = _pChnl->Receive(&_msg, &status)))
    {
        ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface2 \n",
                   "_cIids = 0x%x, _msg.cbBuffer = 0x%x, _msg.Buffer=0x%x\n",
                   _cIids, _msg.cbBuffer, _msg.Buffer));

        BYTE * pBuffer = (BYTE *)_msg.Buffer;
        pBuffer += sizeof(ULONG); // skip the count
        memcpy(phr, pBuffer, sizeof(HRESULT) *_cIids); // copy the hresults
        pBuffer += sizeof(HRESULT) *_cIids; // advance past hresults
        pBuffer += sizeof(ULONG); // skip count
        pBuffer += sizeof(ULONG) * _cIids; // not sure what this is, but its there.
        for(int i = 0; i < _cIids; i++)
        {

            // allocate memory and transfer to out parameters.
            ULONG *pulCntData = (PULONG) pBuffer;
            ULONG cb = sizeof(MInterfacePointer) + *pulCntData;
            MInterfacePointer *pMIF = (MInterfacePointer *) CoTaskMemAlloc(cb);
            if (pMIF)
            {
                pMIF->ulCntData = *pulCntData;
                pBuffer += sizeof(ULONG);
                pBuffer += sizeof(ULONG); // skip count
                memcpy(pMIF->abData, pBuffer, pMIF->ulCntData);
                ppMIF[i] = pMIF;
                pBuffer += pMIF->ulCntData;

            }
            else
            {
                // no memory, so free up what we have left
                // an return an error
                hr = E_OUTOFMEMORY;
                for (int j = 0; j<i; j++)
                {
                    CoTaskMemFree(ppMIF[j]);
                    ppMIF[j] = NULL;
                }
                break;

            }

        }


        // free the buffer
        _pChnl->FreeBuffer(&_msg);
    }
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface2 "
                   "phr:%x, ppMIF:%x\n", phr, ppMIF));
    ComDebOut((DEB_CHANNEL, "CRemUnknownAsyncCallP::Finish_RemQueryInterface2 OUT hr:0x%x\n", hr));
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\metafile.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       metafile.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for HMETAFILEPICT, HENHMETAFILE, and
//              HMETAFILE.
//
//  Functions:  
//              HMETAFILEPICT_UserSize
//              HMETAFILEPICT_UserMarshal
//              HMETAFILEPICT_UserUnmarshal
//              HMETAFILEPICT_UserFree
//              HMETAFILEPICT_UserSize64
//              HMETAFILEPICT_UserMarshal64
//              HMETAFILEPICT_UserUnmarshal64
//              HMETAFILEPICT_UserFree64
//              HENHMETAFILE_UserSize
//              HENHMETAFILE_UserMarshal
//              HENHMETAFILE_UserUnmarshal
//              HENHMETAFILE_UserFree
//              HENHMETAFILE_UserSize64
//              HENHMETAFILE_UserMarshal64
//              HENHMETAFILE_UserUnmarshal64
//              HENHMETAFILE_UserFree64
//              HMETAFILE_UserSize
//              HMETAFILE_UserMarshal
//              HMETAFILE_UserUnmarshal
//              HMETAFILE_UserFree
//              HMETAFILE_UserSize64
//              HMETAFILE_UserMarshal64
//              HMETAFILE_UserUnmarshal64
//              HMETAFILE_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

// #########################################################################
//
//  HMETAFILEPICT
//  See transmit.h for explanation of hglobal vs. gdi data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserSize
//
//  Synopsis:   Get the wire size the HMETAFILEPICT handle and data.
//
//  Derivation: Union of a long and the meta file pict handle.
//              Then struct with top layer (and a hmetafile handle).
//              The the representation of the metafile.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // Discriminant of the encapsulated union and the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += 8;


    if ( ! *pHMetaFilePict )
        return Offset;

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
#if defined(_WIN64)
        //Win64, inproc, we need a bit more space for the handle.
        Offset -= 4;  //Get rid of that bogus long...
        LENGTH_ALIGN( Offset, 7 ); //Make sure alignment is right...
        Offset += 8; //And add in the real size of the handle...
#endif
        return Offset;
    }

    // Now, this is a two layer object with HGLOBAL on top.
    // Upper layer - hglobal part - needs to be sent as data.

    METAFILEPICT *
    pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

    if ( pMFP == NULL )
        RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

    // Upper layer: 3 long fields + ptr marker + enc. union

    Offset += 4 * sizeof(long) + sizeof(userHMETAFILE);

    // The lower part is a metafile handle.

    if ( GDI_DATA_PASSING( *pFlags) )
        {
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );

        Offset += 12 + ulDataSize;
        }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( Offset ) ;
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserMarshal
//
//  Synopsis:   Marshalls an HMETAFILEPICT object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
        {
        // Sending only the top level global handle.
#if defined(_WIN64)
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );
#else
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHMetaFilePict );
#endif

        return pBuffer;
        }

    // userHMETAFILEPICT
    // We need to send the data from the top (hglobal) layer.

    *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
    *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHMetaFilePict );

    if ( ! *pHMetaFilePict )
        return pBuffer;

    // remoteHMETAFILEPICT

    METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock(
                                             *(HANDLE *)pHMetaFilePict );
    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    *( PULONG_LV_CAST pBuffer)++ = pMFP->mm;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->xExt;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->yExt;
    *( PULONG_LV_CAST pBuffer)++ = USER_MARSHAL_MARKER;

    // See if the HMETAFILE needs to be sent as data, too.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pMFP->hMF );

        if ( pMFP->hMF )
            {
            ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );

            // conformant size then the size field

            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

            GetMetaFileBitsEx( pMFP->hMF, ulDataSize , pBuffer );

            pBuffer += ulDataSize;
            };
        }
    else
        {
        // Sending only an HMETAFILE handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pMFP->hMF );
        }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshalWorker
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict,
    ULONG_PTR       BufferSize )
{
    unsigned long   ulDataSize, fHandle;
    HMETAFILEPICT   hMetaFilePict;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag and handle from the buffer.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    if (IS_HANDLE64_MARKER(UnionDisc))
    {
        ALIGN( pBuffer, 7 );
        hMetaFilePict = (HMETAFILEPICT)(*( PHYPER_LV_CAST pBuffer)++ );
    }
    else
    {
        hMetaFilePict = (HMETAFILEPICT)LongToHandle( *( PLONG_LV_CAST pBuffer)++ );
    }

    if ( IS_DATA_MARKER( UnionDisc ) )
        {
        if ( hMetaFilePict )
            {
            HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
            hMetaFilePict = (HMETAFILEPICT) hGlobal;

            if ( hMetaFilePict == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock((HANDLE) hMetaFilePict );
            if ( pMFP == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (8 * sizeof( ULONG )) );

            pMFP->mm   = *( PULONG_LV_CAST pBuffer)++;
            pMFP->xExt = *( PULONG_LV_CAST pBuffer)++;
            pMFP->yExt = *( PULONG_LV_CAST pBuffer)++;

            // validate marker.

            if ( *( PULONG_LV_CAST pBuffer)++ != USER_MARSHAL_MARKER )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            UnionDisc  = *( PULONG_LV_CAST pBuffer)++;
            pMFP->hMF  = (HMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

            ULONG ulExcept = 0;
            if ( pMFP->hMF )
                {
                if (IS_DATA_MARKER( UnionDisc ) )
                    {
                    // Check for EOB.
                    if ( BufferSize < cbFixup + (10 * sizeof( ULONG )) )
                        ulExcept = RPC_X_BAD_STUB_DATA;
                    else
                        {
                        // Conformant size then the size field.  These must be the same.
                        ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
                        if ( ulDataSize == *( PULONG_LV_CAST pBuffer)++ )
                            {
                            // Check for EOB before accessing data.
                            if ( BufferSize < cbFixup + (10 * sizeof(ULONG)) + ulDataSize )
                                ulExcept = RPC_X_BAD_STUB_DATA;
                            else
                                {
                                pMFP->hMF = SetMetaFileBitsEx( ulDataSize, (uchar*)pBuffer );
                                pBuffer += ulDataSize;
                                }
                            }
                        else
                            ulExcept = RPC_X_BAD_STUB_DATA;
                        }

                    }
                else if ( !IS_HANDLE_MARKER( UnionDisc ) )
                    {
                    ulExcept = RPC_S_INVALID_TAG;
                    }
                }

            GlobalUnlock( (HANDLE) hMetaFilePict );

            // wait until we've called GlobalUnlock before raising any exceptions.

            if ( ulExcept != 0 )
                {
                RAISE_RPC_EXCEPTION( ulExcept );
                }
            }
        }
    else if ( !(IS_HANDLE_MARKER( UnionDisc ) || IS_HANDLE64_MARKER( UnionDisc )) )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }


    // no reusage, just release the previous one.

    if ( *pHMetaFilePict )
        {
        // This may happen on the client only and doesn't depend on
        // how the other one was passed.

        METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

        if ( pMFP->hMF )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
        }

    *pHMetaFilePict = hMetaFilePict;

    return( pBuffer );
}
//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshal
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored out bulk of work into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserUnmarshal\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HMETAFILEPICT_UserUnmarshalWorker( pFlags,
                                                  pBufferStart,
                                                  pHMetaFilePict,
                                                  BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserFree
//
//  Synopsis:   Free an HMETAFILEPICT.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILEPICT_UserFree(
    unsigned long * pFlags,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILEPICT_UserFree\n"));

    if( pHMetaFilePict  &&  *pHMetaFilePict )
        {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            return;

        // Need to free the upper hglobal part.

        METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

        // See if we need to free the hglobal, too.

        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
        }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserSize
//
//  Synopsis:   Get the wire size the HENHMETAFILE handle and data.
//
//  Derivation: Union of a long and the meta file handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HENHMETAFILE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHEnhMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Pointee of the union arm for the remote case.
        // Byte blob : conformant size, size field, data

        Offset += 2 * sizeof(long);

        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );
        Offset += ulDataSize;
        }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserMarshall
//
//  Synopsis:   Marshalls an HENHMETAFILE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHENHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( *pHEnhMetafile );

        if ( !*pHEnhMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data

        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetEnhMetaFileBits( *pHEnhMetafile,
                                      ulDataSize,
                                      (uchar*)pBuffer ) )
           RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulDataSize;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PLONG_LV_CAST pBuffer)++ = HandleToLong(*(HANDLE *)pHEnhMetafile);
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshallWorker
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshalWorker (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile,
    ULONG_PTR       BufferSize )
{
    HENHMETAFILE    hEnhMetafile;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Get the tag and handle.  Caller checked for EOB.
    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hEnhMetafile = (HENHMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hEnhMetafile )
            {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof( ULONG )) );

            // Byte blob : conformant size, size field, data

            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
            if ( *( PULONG_LV_CAST pBuffer)++ != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof(ULONG)) + ulDataSize );

            hEnhMetafile = SetEnhMetaFileBits( ulDataSize, (uchar*) pBuffer );            
            pBuffer += ulDataSize;
            }
        }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

    // No reusage of the old object.

    if (*pHEnhMetafile)
        DeleteEnhMetaFile( *pHEnhMetafile );

    *pHEnhMetafile = hEnhMetafile;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserUnmarshal\n"));

    // Get the buffer size and start of buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HENHMETAFILE_UserUnmarshalWorker( pFlags,
                                                pBufferStart,
                                                pHEnhMetafile,
                                                BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserFree
//
//  Synopsis:   Free an HENHMETAFILE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HENHMETAFILE_UserFree(
    unsigned long * pFlags,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HENHMETAFILE_UserFree\n"));

    if( pHEnhMetafile  &&  *pHEnhMetafile )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteEnhMetaFile( *pHEnhMetafile );
            }
        }
}


// #########################################################################
//
//  HMETAFILE
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserSize
//
//  Synopsis:   Get the wire size the HMETAFILE handle and data.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    Offset += sizeof(long) + sizeof(long);

    if ( ! *pHMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Pointee of the union arm for the remote case.
        // Byte blob : conformant size, size field, data

        Offset += 2 * sizeof(long);

        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );
        Offset += ulDataSize;
        }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserMarshal
//
//  Synopsis:   Marshals an HMETAFILE object into the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*pHMetafile);

        if ( !*pHMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data

        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetMetaFileBitsEx( *pHMetafile,
                                     ulDataSize,
                                     (uchar*)pBuffer ) )
           RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulDataSize;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = PtrToUlong(*(HANDLE *)pHMetafile);
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserUnmarshal
//
//  Synopsis:   Unmarshalls an HMETAFILE object from the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    HMETAFILE    hMetafile;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserUnmarshal\n"));

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing discriminant and handle.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof(ULONG)) );

    unsigned long UnionDisc =  *( PULONG_LV_CAST pBuffer)++;
    hMetafile = (HMETAFILE) LongToHandle( *( PLONG_LV_CAST pBuffer)++ );

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hMetafile )
            {
            // Check for EOB before accessing metadata.
            CHECK_BUFFER_SIZE( BufferSize, cbFixup + (4 * sizeof( ULONG )) );

            // Byte blob : conformant size, size field, data

            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
            if ( *( PULONG_LV_CAST pBuffer)++ != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            // Check for EOB before accessing data.
            CHECK_BUFFER_SIZE( BufferSize,
                               cbFixup + (4 * sizeof( ULONG )) + ulDataSize );

            hMetafile = SetMetaFileBitsEx( ulDataSize, (uchar*) pBuffer );            
            pBuffer += ulDataSize;
            }
        }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
        {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
        }

    // No reusage of the old object.

    if (*pHMetafile)
        DeleteMetaFile( *pHMetafile );

    *pHMetafile = hMetafile;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserFree
//
//  Synopsis:   Free an HMETAFILE.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILE_UserFree(
    unsigned long * pFlags,
    HMETAFILE     * pHMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILE_UserFree\n"));

    if( pHMetafile  &&  *pHMetafile )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteMetaFile( *pHMetafile );
            }
        }
}


#if defined(_WIN64)


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserSize64
//
//  Synopsis:   Get the wire size the HMETAFILEPICT handle and data.
//
//  Derivation: Union of a long and the meta file pict handle.
//              Then struct with top layer (and a hmetafile handle).
//              The the representation of the metafile.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return Offset;
    
    // Discriminant of the encapsulated union and the union arm.
    // Union discriminant is 4 bytes
    LENGTH_ALIGN( Offset, 7 );
    Offset += 4;
    LENGTH_ALIGN( Offset, 7 );

    // Rest of the upper layer:
    //   (already aligned on 8)
    //   pointer marker (or handle)    8
    Offset += 8;    

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        return Offset;
    }

    if ( ! *pHMetaFilePict )
    {
        return Offset;
    }

    // METAFILEPICT is a structure containing an HMETAFILE.
    // The structure is GlobalAlloc'd.    
    METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

    if ( pMFP == NULL )
        RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

    //   3xlong            12
    //   (align on 8)      4
    //   lower lev ptr.    8
    // Lower level:
    //   (already aligned on 8)
    //   discriminant      4
    //   (align on 8)      4
    Offset += 32;

    // Lower layer: userHMETAFILE union...
    if ( GDI_DATA_PASSING( *pFlags) )
    {
        // pointer         8
        // BYTE_BLOB:
        // conformance     8
        // size            4
        // bytes           ulDataSize
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 20 + ulDataSize;
    }
    else
    {
        // handle          8        
        Offset += 8;
    }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( Offset ) ;
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserMarshal64
//
//  Synopsis:   Marshalls an HMETAFILEPICT object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
    {
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );

        return pBuffer;
    }

    // userHMETAFILEPICT
    // We need to send the data from the top (hglobal) layer.

    *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = *(__int64 *)( pHMetaFilePict );

    if ( ! *pHMetaFilePict )
        return pBuffer;

    // remoteHMETAFILEPICT

    METAFILEPICT * pMFP = (METAFILEPICT*)GlobalLock( *(HANDLE *)pHMetaFilePict );
    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    *( PULONG_LV_CAST pBuffer)++ = pMFP->mm;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->xExt;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->yExt;
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = USER_MARSHAL_MARKER;

    // See if the HMETAFILE needs to be sent as data, too.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)( pMFP->hMF );

        if ( pMFP->hMF )
        {
            ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );
            if (0 == ulDataSize)
            {
                GlobalUnlock (*(HANDLE *)pHMetaFilePict);
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }
            
            // conformant size then the size field
            *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
            *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
            
            GetMetaFileBitsEx( pMFP->hMF, ulDataSize , pBuffer );
            
            pBuffer += ulDataSize;
        }
    }
    else
    {
        // Sending only an HMETAFILE handle.            
        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)( pMFP->hMF );
    }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    unsigned long   ulDataSize, fHandle;
    HMETAFILEPICT   hMetaFilePict;
    
    stream.Align(8);

    unsigned long UnionDisc = stream.ReadULONGNA();
    hMetaFilePict = (HMETAFILEPICT)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc ) )
    {
        if ( hMetaFilePict )
        {
            HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
            hMetaFilePict = (HMETAFILEPICT) hGlobal;

            if ( hMetaFilePict == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );

            METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock((HANDLE) hMetaFilePict );
            if ( pMFP == NULL )
                RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
            
            RpcTryFinally
            {
                pMFP->mm   = stream.ReadULONGNA();
                pMFP->xExt = stream.ReadULONGNA();
                pMFP->yExt = stream.ReadULONGNA();

                // validate marker.
                if ( stream.ReadHYPER() != USER_MARSHAL_MARKER )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                UnionDisc = stream.ReadULONGNA();
                pMFP->hMF = (HMETAFILE)stream.ReadHYPER();

                if ( pMFP->hMF )
                {
                    if ( IS_DATA_MARKER( UnionDisc ) )
                    {
                        // Conformant size then the size field.  These must be the same.
                        ULONG ulDataSize = (ULONG)stream.ReadHYPERNA();
                        if ( ulDataSize == stream.ReadULONGNA() )
                        {
                            stream.CheckSize(ulDataSize);
                            pMFP->hMF = SetMetaFileBitsEx( ulDataSize, 
                                                           (uchar*)stream.GetBuffer() );
                            if (NULL == pMFP->hMF)
                                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                            stream.Advance(ulDataSize);
                        }
                        else
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
                    {
                        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
                    }
                }
            }
            RpcFinally
            {
                GlobalUnlock( (HANDLE) hMetaFilePict );
            }
            RpcEndFinally;
        }
    }
    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }


    // no reusage, just release the previous one.    
    if ( *pHMetaFilePict )
    {
        // This may happen on the client only and doesn't depend on
        // how the other one was passed.
        METAFILEPICT *
            pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        
        if ( pMFP->hMF )
            DeleteMetaFile( pMFP->hMF );
        
        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }

    *pHMetaFilePict = hMetaFilePict;

    return( stream.GetBuffer() );
}
//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserUnmarshal64\n"));

    // Get the buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer =  HMETAFILEPICT_UserUnmarshalWorker64( pFlags,
                                                    pBufferStart,
                                                    pHMetaFilePict,
                                                    BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserFree64
//
//  Synopsis:   Free an HMETAFILEPICT.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILEPICT_UserFree64 (
    unsigned long * pFlags,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILEPICT_UserFree64\n"));
    
    if( pHMetaFilePict  &&  *pHMetaFilePict )
    {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            return;
        
        // Need to free the upper hglobal part.
        
        METAFILEPICT *
            pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );
        
        if ( pMFP == NULL )
            RAISE_RPC_EXCEPTION( E_OUTOFMEMORY );
        
        // See if we need to free the hglobal, too.
        
        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserSize64
//
//  Synopsis:   Get the wire size the HENHMETAFILE handle and data.
//
//  Derivation: Union of a long and the meta file handle and then struct.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------
unsigned long  __RPC_USER
HENHMETAFILE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );
    
    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant      4
    //   (align on 8)      4
    //   pointer or handle 8
    Offset += 16;

    if ( ! *pHEnhMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // BYTE_BLOB
        //   (aligned on 8)
        //   conformance   8
        //   size          4
        //   data          ulDataSize
        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 12 + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserMarshal64
//
//  Synopsis:   Marshalls an HENHMETAFILE object into the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );
    
    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHENHMETAFILE
        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *( PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHEnhMetafile);

        if ( !*pHEnhMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data
        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetEnhMetaFileBits( *pHEnhMetafile,
                                      ulDataSize,
                                      (uchar*)pBuffer ) )
            RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));
        
        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.
        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHEnhMetafile);
    }
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshallWorker64
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    HENHMETAFILE    hEnhMetafile;

    stream.Align(8);

    // Get the tag and handle.  Caller checked for EOB.
    unsigned long UnionDisc = stream.ReadULONGNA();
    hEnhMetafile = (HENHMETAFILE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hEnhMetafile )
        {
            // Byte blob : conformant size, size field, data            
            ulong ulDataSize = (ulong)stream.ReadHYPERNA();
            if ( stream.ReadULONGNA() != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            
            stream.CheckSize(ulDataSize);
            hEnhMetafile = SetEnhMetaFileBits( ulDataSize, (uchar*)stream.GetBuffer() );
            if (NULL == hEnhMetafile)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            stream.Advance(ulDataSize);
        }
    }
    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }

    // No reusage of the old object.

    if (*pHEnhMetafile)
        DeleteEnhMetaFile( *pHEnhMetafile );
    
    *pHEnhMetafile = hEnhMetafile;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserUnmarshal64\n"));

    // Get the buffer size and start of buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = HENHMETAFILE_UserUnmarshalWorker64( pFlags,
                                                  pBufferStart,
                                                  pHEnhMetafile,
                                                  BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserFree64
//
//  Synopsis:   Free an HENHMETAFILE.
//
//  history:    Dec-00   JohnDoty      Created from 32bit functions.
//
//--------------------------------------------------------------------------

void __RPC_USER
HENHMETAFILE_UserFree64 (
    unsigned long * pFlags,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HENHMETAFILE_UserFree64\n"));

    if( pHEnhMetafile  &&  *pHEnhMetafile )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteEnhMetaFile( *pHEnhMetafile );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserSize64
//
//  Synopsis:   Get the wire size the HMETAFILE handle and data.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILE_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // The encapsulated union.
    //   (aligned on 8)
    //   discriminant     4
    //   (align on 8)     4
    //   ptr or handle    8
    Offset += 16;

    if ( ! *pHMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // Byte blob
        //  (aligned on 8)
        //  conformance   8
        //  size          4
        //  data          ulDataSize
        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );
        if (0 == ulDataSize)
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));

        Offset += 12 + ulDataSize;
    }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserMarshal64
//
//  Synopsis:   Marshals an HMETAFILE object into the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{
    if ( !pHMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserMarshal64\n"));

    ALIGN( pBuffer, 7 );

    // Discriminant of the encapsulated union and union arm.
    if ( GDI_DATA_PASSING(*pFlags) )
    {
        // userHMETAFILE
        *(PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*pHMetafile);

        if ( !*pHMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data
        ulong ulDataSize = GetMetaFileBitsEx( *pHMetafile, 0, NULL );

        *( PHYPER_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetMetaFileBitsEx( *pHMetafile,
                                     ulDataSize,
                                     (uchar*)pBuffer ) )
            RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));
        
        pBuffer += ulDataSize;
    }
    else
    {
        // Sending a handle.        
        *(PULONG_LV_CAST pBuffer)++ = WDT_HANDLE64_MARKER;
        ALIGN( pBuffer, 7 );
        *(PHYPER_LV_CAST pBuffer)++ = (hyper)(*(HANDLE *)pHMetafile);
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an HMETAFILE object from the RPC buffer.
//
//  Derivation: Same wire layout as HENHMETAFILE
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILE_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILE     * pHMetafile )
{    
    HMETAFILE    hMetafile;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILE_UserUnmarshal64\n"));

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    // Align the buffer and save the fixup size.
    stream.Align(8);
    unsigned long UnionDisc = stream.ReadULONGNA();
    hMetafile = (HMETAFILE)stream.ReadHYPER();

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hMetafile )
        {
            // Byte blob : conformant size, size field, data
            ulong ulDataSize = (ulong)stream.ReadHYPERNA();
            if ( stream.ReadULONGNA() != ulDataSize )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            stream.CheckSize(ulDataSize);
            hMetafile = SetMetaFileBitsEx( ulDataSize, (uchar*) stream.GetBuffer() );
            if (NULL == hMetafile)
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            stream.Advance(ulDataSize);
        }
    }
    else if ( !IS_HANDLE64_MARKER( UnionDisc ) )
    {
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );
    }
    
    // No reusage of the old object.
    
    if (*pHMetafile)
        DeleteMetaFile( *pHMetafile );
    
    *pHMetafile = hMetafile;

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILE_UserFree64
//
//  Synopsis:   Free an HMETAFILE.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILE_UserFree64(
    unsigned long * pFlags,
    HMETAFILE     * pHMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILE_UserFree64\n"));
    
    if( pHMetafile  &&  *pHMetafile )
    {
        if ( GDI_DATA_PASSING(*pFlags) )
        {
            DeleteMetaFile( *pHMetafile );
        }
    }
}

#endif // win64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\pipes.cxx ===
//+--------------------------------------------------------------------------
//
//   Microsoft Windows
//   Copyright (C) Microsoft Corporation, 1992 - 1997
//
//   File: pipes.cxx
//
//   History:
//           RichN  10/30/97  Created.
//
//---------------------------------------------------------------------------
#include <ole2int.h>
#include "pipes.hxx"

/////////////////////////////////////////////////////////////////////////////
// Externals
EXTERN_C HRESULT PrxDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
extern HRESULT RemUnkPSGetClassObject(REFIID riid, PVOID* ppv);
//////////////////////////////////////////////////////////////////////////////
// Constants
const DWORD WAIT_INFINITE = DWORD(-1);
const ULONG FRAGMENT_SIZE = 1300;

typedef struct
{
  const char *key;
  const char *value;
} RegistryKeyValue;

const RegistryKeyValue REG_CONST_KEY[] =
{
  "CLSID\\{0000032E-0000-0000-C000-000000000046}", "PipePSFactory",
  "CLSID\\{0000032E-0000-0000-C000-000000000046}\\InprocServer32", "ole32.dll",

  "Interface\\{DB2F3ACA-2F86-11d1-8E04-00C04FB9989A}", "IPipeByte",
  "Interface\\{DB2F3ACA-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  "Interface\\{DB2F3ACC-2F86-11d1-8E04-00C04FB9989A}", "IPipeLong",
  "Interface\\{DB2F3ACC-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  "Interface\\{DB2F3ACE-2F86-11d1-8E04-00C04FB9989A}", "IPipeDouble",
  "Interface\\{DB2F3ACE-2F86-11d1-8E04-00C04FB9989A}\\ProxyStubClsid32", "{0000032E-0000-0000-C000-000000000046}",

  // Indicates end of list.
  "", ""
};

/////////////////////////////////////////////////////////////////////////////
// Macros
inline ULONG MIN( ULONG a, ULONG b )
{
    return a < b ? a : b;
}
inline ULONG MAX( ULONG a, ULONG b )
{
    return a < b ? b : a;
}

inline HRESULT MAKE_WIN32( HRESULT status )
{
    return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );
}

inline HRESULT FIX_WIN32( HRESULT result )
{
    if ((ULONG) result > 0xfffffff7 || (ULONG) result < 0x2000)
        return MAKE_WIN32( result );
    else
        return result;
}

/////////////////////////////////////////////////////////////////////////////
// Globals
#define DISABLEASYNC    0

/////////////////////////////////////////////////////////////////////////////
// Prototypes

//+**************************************************************************
// FixUpPipeRegistry(void)
//
// Description: Modifies the registry to have the pipe interface point
//              to a different class ID for the PSFactory.  Adds to the
//              registry the new ID for the PipePSFactory.
//
// History:
// Date:   Time:          Developer:    Action:
// 12/3/97 10:14:48 AM    RichN         Created.
//
// Notes: We do not change the async interfaces.  They should still 
//        be handled by ole32 directly.  Only modify the synchronous varity.
//
//-**************************************************************************
HRESULT FixUpPipeRegistry(void)
{
    HRESULT result = ERROR_SUCCESS;

    // Create the Pipe interfaces and add the clsid for the PipePSFactory.
    for (int i = 0; (REG_CONST_KEY[i].key[0] != '\0') && result == ERROR_SUCCESS; i++)
    {
        // Use Ascii so it works on Win95.
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_CONST_KEY[i].key,
                 REG_SZ,
                 REG_CONST_KEY[i].value,
                 strlen(REG_CONST_KEY[i].value) );
    }

    if( result != ERROR_SUCCESS )
        return FIX_WIN32( result );

    return S_OK;
}


//+**************************************************************************
// ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
//
// Description: Creates a proxy.  Trys PrxDllGetClassObject first since that
//              is the most likely.  If not, then sees if it is the pipe
//              proxy being created.
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:43:55 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv)
{
    ComDebOut(( DEB_MARSHAL, "ProxyDllGetClassObject, clsid: %l, riid: %l \n", 
                                                            clsid, riid));

    HRESULT hr = PrxDllGetClassObject(clsid, riid, ppv);

    if( FAILED(hr) )
    {
        // Not a well known one, maybe it is the pipe factory.
        if( clsid == CLSID_PipePSFactory )
        {
            // Create the pipe proxy/stub class factory
            CPipePSFactory *pPipePSFactory = new CPipePSFactory();

            if( NULL != pPipePSFactory )
            {
                // Get the interface Requested.
                hr = pPipePSFactory->QueryInterface(riid, ppv);
                pPipePSFactory->Release();
            }
            else
            {
                *ppv = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else if (clsid == CLSID_RemoteUnknownPSFactory) 
        {
            hr = RemUnkPSGetClassObject(riid, ppv);
        } 
    }

    return hr;
}

//+**************************************************************************
// CPipePSFactory()
//
// Description: CTOR
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 12:55:55 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipePSFactory::CPipePSFactory() :
    m_cRef(1)
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory - ctor, this:%x \n", this));    
}

//+**************************************************************************
// CPipePSFactory()
//
// Description: DTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 12:56:19 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipePSFactory::~CPipePSFactory()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory - dtor, this:%x \n"));
}

//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: Standard QI
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:10:58 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::QueryInterface, this:%x, riid:%i \n", 
                                                              this, riid));
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPSFactoryBuffer) )
    {
        *ppvObj = (IPSFactoryBuffer *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+**************************************************************************
// CPipePSFactory::AddRef()
//
// Description: Standard AddRef
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:11:16 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipePSFactory::AddRef()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::AddRef, this:%x, m_cRef:%d \n", 
                                                      this, m_cRef + 1));
    return InterlockedIncrement( &m_cRef );
}

//+**************************************************************************
// CPipePSFactory::Release()
//
// Description: Standard Release
//
// History:
// Date:   Time:         Developer:    Action:
// 10/30/97 11:11:31 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipePSFactory::Release()
{
    ComDebOut(( DEB_MARSHAL, "CPipePSFactory::Release, this:%x, m_cRef:%d \n", 
                                                       this, m_cRef - 1));
    ULONG lRef;

    if( (lRef = InterlockedDecrement( &m_cRef )) == 0)
    {
        delete this;
        return 0;
    }

    return lRef;
}


//+**************************************************************************
// CreateProxy
//
// Description: Creates a pipe proxy.
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:11:45 AM    RichN         Created.
//
// Notes: We will pass back to the call a ptr to our object and we will
//        hold a pointer to the real proxy.  When the client calls us, we
//        can do whatever we want/need to do and then call the real proxy.
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::CreateProxy( IUnknown *pUnkOuter,
                                          REFIID riid,
                                          IRpcProxyBuffer **ppProxy,
                                          void **ppv )
{
    ComDebOut(( DEB_MARSHAL, "CreateProxy, pUnkOuter:%x riid:%I \n", 
                                                    pUnkOuter, riid));

    if( NULL == ppv || NULL == ppProxy )
        return E_INVALIDARG;

    *ppProxy = NULL;
    *ppv     = NULL;

    IPSFactoryBuffer *pPSFactory;

    // Create the real PSFactory for the pipe interface.
    HRESULT hr = PrxDllGetClassObject(  riid, 
                                        IID_IPSFactoryBuffer, 
                                        (void **) &pPSFactory);

    IUnknown *pNDRPipeProxy = NULL;
    IRpcProxyBuffer *pInternalProxyBuffer = NULL;
    
    if( SUCCEEDED(hr) )
    {
        // Create the real proxy.
        hr = pPSFactory->CreateProxy(  pUnkOuter, 
                                       riid, 
                                       &pInternalProxyBuffer, 
                                       (void **)&pNDRPipeProxy);
        pPSFactory->Release();
    }

    if( FAILED(hr) )
        return hr;

    if( IID_IPipeByte == riid )
    {
        *ppv = new CPipeProxy<BYTE, 
                              &IID_IPipeByte,
                              &IID_AsyncIPipeByte,
                              IPipeByte,
                              AsyncIPipeByte>
                             (pUnkOuter, pNDRPipeProxy);
    }
    else if( IID_IPipeLong == riid )
    {
        *ppv = new CPipeProxy<LONG, 
                              &IID_IPipeLong,
                              &IID_AsyncIPipeLong, 
                              IPipeLong,
                              AsyncIPipeLong>
                             (pUnkOuter,  pNDRPipeProxy);
    }
    else if( IID_IPipeDouble == riid )
    {
        *ppv = new CPipeProxy<DOUBLE, 
                              &IID_IPipeDouble,
                              &IID_AsyncIPipeDouble, 
                              IPipeDouble,
                              AsyncIPipeDouble>
                             (pUnkOuter, pNDRPipeProxy);
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    
    if( SUCCEEDED(hr) && NULL == *ppv)
        hr = E_OUTOFMEMORY;

    // Create the object that contains the IRpcProxyBuffer 
    // and the pipe interface.  Created with refcount of 1.
    if( SUCCEEDED(hr) )
    {
        CPipeProxyImp *pProxyImp = new CPipeProxyImp(pUnkOuter,
                                                     pInternalProxyBuffer,
                                                     pNDRPipeProxy,
                                                     (IUnknown*) *ppv,
                                                     riid);
        if( NULL == pProxyImp )
        {
            hr = E_OUTOFMEMORY;
        }
        else
            *ppProxy = (IRpcProxyBuffer *) pProxyImp;
    }

    // Clean up failure.
    if( FAILED(hr) )
    {
        if( NULL != *ppv )
        {
            delete *ppv;
            *ppv = NULL;
        }

        pNDRPipeProxy->Release();
        pInternalProxyBuffer->Release();

    }

    return hr;
}

//+**************************************************************************
// CreateStub
//
// Description: Creates a pipe stub.
//
// History:
// Date:    Time:          Developer:    Action:
// 10/30/97 11:12:46 AM    RichN         Created.
//
// Notes: 
//
//-**************************************************************************
STDMETHODIMP CPipePSFactory::CreateStub( REFIID riid,
                                         IUnknown *pUnkServer,
                                         IRpcStubBuffer **ppStub )
{
    ComDebOut(( DEB_MARSHAL, "CreateStub, riid:%x pUnkServer:%x \n", 
                                               riid, pUnkServer ));
    HRESULT hr = S_OK;
    IPSFactoryBuffer *pPSFactory;

    // Create the real PSFactory for the pipe interface.
    hr = PrxDllGetClassObject( riid, 
                               IID_IPSFactoryBuffer, 
                               (void **) &pPSFactory);

    // Call real factory to get stub.
    if( SUCCEEDED(hr) )
    {
        hr = pPSFactory->CreateStub(riid, pUnkServer, ppStub);
    
        pPSFactory->Release();
    }

    return hr;
}

//+**************************************************************************
// CPipePoxyImp(IRpcProxyBuffer *pInternalPB, IUnknown *pPipe)
//
// Description: CTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:31:43 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipeProxyImp::CPipeProxyImp(IUnknown *pUnkOuter,
                             IRpcProxyBuffer *pInternalPB, 
                             IUnknown *pRealPipeProxy,
                             IUnknown *pInternalPipeProxy,
                             IID iid) :
    m_cRef              (1),
    m_pInternalPipeProxy(pInternalPipeProxy),
    m_pInternalPB       (pInternalPB),
    m_pRealPipeProxy    (pRealPipeProxy),
    m_pUnkOuter         (pUnkOuter),
    m_IidOfPipe         (iid)
{
    ComDebOut(( DEB_MARSHAL, "CPipeProxyImp ctor, this:%x \n"));

    Win4Assert(NULL != m_pInternalPB);
    Win4Assert(NULL != m_pRealPipeProxy);
    Win4Assert(NULL != m_pInternalPipeProxy);

}

//+**************************************************************************
// CPipeProxyImp()
//
// Description: DTOR
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:32:02 AM    RichN         Created.
//
// Notes: 
//
//-**************************************************************************
CPipeProxyImp::~CPipeProxyImp()
{
    ComDebOut(( DEB_MARSHAL, "~CPipeProxyImp, this:%x \n", this));

    // AddRef the outer because we are aggregated.
    m_pUnkOuter->AddRef();

    // Delete the internal proxy.
    if( NULL != m_pInternalPipeProxy )
    {
        delete m_pInternalPipeProxy;
        m_pInternalPipeProxy = NULL;
    }

    // Release the real proxy.
    if( NULL != m_pRealPipeProxy )
    {
        m_pRealPipeProxy->Release();
        m_pRealPipeProxy = NULL;
    }

    // Release the pointer to the IRpcProxyBuffer
    if( NULL != m_pInternalPB )
        m_pInternalPB->Release();

}

//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: QI
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:15 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxyImp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    ComDebOut(( DEB_MARSHAL, "QueryInterface, this:%x \n", this));

    HRESULT hr = S_OK;

    if( NULL == ppvObj )
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRpcProxyBuffer) )
    {
        *ppvObj = (IUnknown *) this;
    }
    else if( IsEqualIID(riid, m_IidOfPipe) )
    {
        *ppvObj = m_pInternalPipeProxy;
    }
    else
    {
        return m_pInternalPB->QueryInterface(riid, ppvObj);
    }
   
    ((IUnknown *)(*ppvObj))->AddRef();
    return hr;
}

//+**************************************************************************
// CPipeProxyImp::AddRef()
//
// Description: AddRef
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:34 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipeProxyImp::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

//+**************************************************************************
// CPipeProxyImp::Release()
//
// Description: 
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:48 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(ULONG) CPipeProxyImp::Release()
{
  ULONG lRef;

  if( (lRef = InterlockedDecrement( &m_cRef )) == 0)
  {
    delete this;
    return 0;
  }

  return lRef;
}


//+**************************************************************************
// Connect(IRpcChannelBuffer *pRpcChannelBuffer)
//
// Description: Simple pass through.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:36:59 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxyImp::Connect(IRpcChannelBuffer *pRpcChannelBuffer)
{
    return m_pInternalPB->Connect(pRpcChannelBuffer);
}

//+**************************************************************************
// Disconnect( void )
//
// Description: Simple pass through.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:37:25 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP_(void) CPipeProxyImp::Disconnect( void )
{
    m_pInternalPB->Disconnect();
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CPipeProxy( void * pProxy ): 
//
// Description:CTOR 
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:43:00 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CPipeProxy(IUnknown *pUnkOuter, void * pProxy ): 
    m_cFreeSpace      (0),           m_cKeepBufferSize (0),
    m_cKeepDataSize   (0),           m_cLastRead       (0),
    m_cPushBufferSize (0),           m_cReadAhead      (0),         
    m_cRef            (0),           m_pAsyncPullPipe  (NULL),      
    m_pAsyncPushPipe  (NULL),        m_pFreeSpace      (NULL),      
    m_pISyncPull      (NULL),        m_pISyncPush      (NULL),      
    m_pKeepBuffer     (NULL),        m_pKeepData       (NULL),      
    m_pRealProxy      ((I *)pProxy), m_pUnkOuter       (pUnkOuter), 
    m_pPushBuffer     (NULL),        m_PullState       (PULLSTATE0_ENTRY),
    m_PushState       (PUSHSTATE0_ENTRY)
{
    ComDebOut(( DEB_MARSHAL, "CPipeProxy, pUnkOuter:%x pProxy:%x p \n",
                                                pUnkOuter, pProxy));
    Win4Assert(NULL != m_pUnkOuter);
    Win4Assert(NULL != m_pRealProxy);

    // Fill in the array of functions for the pull states.
    PullStateFunc[0] = NULL;       // Should never execute in state zero.
    PullStateFunc[1] = NbNaRgtRA1; // No Buffer, No async outstanding, Request > Read ahead
    PullStateFunc[2] = NbaRltRA2;  // No Buffer, async call outstanding, Request < Read Ahead
    PullStateFunc[3] = NbaRgtRA3;  // No Buffer, async, Req >= Read ahead
    PullStateFunc[4] = baRltB4;    // Buffer, async, Request < Buffer size
    PullStateFunc[5] = baRgtB5;    // Buffer, async, Request >= Buffer size
    PullStateFunc[6] = PullDone6;  // done.

    // Fill in the array of functions for the push states.
    PushStateFunc[0] = NULL;      // Should never execute in state zero.
    PushStateFunc[1] = NbNf1;     // No Buffer, No free buffer space
    PushStateFunc[2] = bfPgtF2;   // Buffer, free space in buffer, push size >= free size
    PushStateFunc[3] = bfPltF3;   // Buffer, free, push < free
    PushStateFunc[4] = bPSz4;     // Buffer, push size zero
    PushStateFunc[5] = PushDone5; // Done

#if DBG==1
    for(int i = 1; i < MAX_PULL_STATES; i++)
        Win4Assert(PullStateFunc[i] != NULL);

    for(i = 1; i < MAX_PUSH_STATES; i++)
        Win4Assert(PushStateFunc[i] != NULL);
#endif

    return;

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CPipeProxy( void )
//
// Description: DTOR
//
// History:
// Date:   Time:         Developer:    Action:
// 11/11/97 11:43:20 AM    RichN         Created.
//
// Notes: Addref the outer unknown and then release the pointer to the 
//        real proxy.
//
//-**************************************************************************
CPipeProxy<T, ID, AsyncID, I, AsyncI>
::~CPipeProxy( void )
{
    Win4Assert(NULL != m_pUnkOuter);
    Win4Assert(NULL != m_pRealProxy);

}    
//+**************************************************************************
// QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Description: IUnknown implementation.  All delegate to outer unknown.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/11/97 11:48:42 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return m_pUnkOuter->QueryInterface(riid, ppvObj);
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP_(ULONG) CPipeProxy<T, ID, AsyncID, I, AsyncI>
::AddRef()
{
    m_cRef++;
    return m_pUnkOuter->AddRef();
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
STDMETHODIMP_(ULONG) CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Release()
{
    m_cRef--;
    return m_pUnkOuter->Release();
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// Pull( T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull the data from the server.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:49:18 AM    RichN         Created.
//
// Notes: We read data ahead by using async calls.  The size of the
//        read ahead can be controled by the user by implementing
//        the IPipeHueristic and setting it on the interface.
//
//-**************************************************************************
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Pull( T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "Pull, this:%x, Buf:%x, Request:%d, Received:%x \n", 
                                    this, Buf, Request, Received));

    if( 0 == Request )
        return E_UNEXPECTED;

    HRESULT hr;

    // For debugging it is sometimes useful to disable
    // the async read ahead.
#if DISABLEASYNC==1
    hr = m_pRealProxy->Pull(Buf, Request, Received);
    return hr;
#endif

    *Received = 0;

    // Transition to the next state.
    hr = PullStateTransition( Request );

    // Should never see state 0.
    Win4Assert(0 != m_PullState);

    // Call the function for the new state.
    if( SUCCEEDED(hr) )
    {
        hr = (this->*(PullStateFunc[m_PullState]))( Buf, Request, Received );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// Push( T *Buf, ULONG count)
//
// Description: Pushes data to the server.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/11/97 11:49:39 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
STDMETHODIMP CPipeProxy<T, ID, AsyncID, I, AsyncI>
::Push( T *Buf, ULONG Count)
{
    ComDebOut(( DEB_MARSHAL, "Push, this:%x, Buf:%x, Count:%u \n",
                                    this, Buf, Count));
    HRESULT hr; 
    
    // For debugging it is sometimes useful to disable 
    // write behind.
#if DISABLEASYNC==1
    hr = m_pRealProxy->Push(Buf, Count);
    return hr;
#endif

    // Transition to the next state.
    hr = PushStateTransition( Count );

    // Should never see state 0.
    Win4Assert(0 != m_PushState);

    // Call the function for the new state.
    if( SUCCEEDED(hr) )
    {
        hr = (this->*(PushStateFunc[m_PushState]))( Buf, Count );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// InitAsync(void)
//
// Description: Initializes, gets, the pointers to the async parts.
//
// History:
// Date:   Time:         Developer:    Action:
// 12/8/97 4:45:22 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::InitAsync(IUnknown**     ppCallObj, 
            AsyncI**       ppAsyncPipe,
            ISynchronize** ppISync)
{
    ComDebOut(( DEB_MARSHAL, "InitAsync, this:%x \n", this));

    Win4Assert(NULL != m_pRealProxy);
    Win4Assert(NULL == (*ppAsyncPipe));
    Win4Assert(NULL == (*ppISync));

    HRESULT hr;
    ICallFactory *pCF = NULL;

    hr = m_pRealProxy->QueryInterface(IID_ICallFactory, (void **) &pCF);

    if( FAILED(hr) )
        return hr;

    hr = pCF->CreateCall(*AsyncID, NULL, IID_IUnknown, ppCallObj);
    pCF->Release();

    if( FAILED(hr) )
        return hr;

    hr = (*ppCallObj)->QueryInterface(*AsyncID, (void **) ppAsyncPipe);
    if( FAILED(hr) )
        goto ErrorCallObj;

    hr = (*ppCallObj)->QueryInterface(IID_ISynchronize, (void **) ppISync);
    if( FAILED(hr) )
        goto ErrorAsyncPipe;

    return S_OK;

ErrorAsyncPipe:
    (*ppAsyncPipe)->Release();
    (*ppAsyncPipe) = NULL;

ErrorCallObj:
    (*ppCallObj)->Release();
    (*ppCallObj) = NULL;

    return hr;

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CleanupProxy(IUnknown* pCallObj, IUnknown* pAsyncPipe, ISynchronize* pISync)
//
// Description: Cleans up all the async interfaces acquired.
//
// History:
// Date:    Time:          Developer:    Action:
// 12/16/97 11:42:42 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CleanupProxy(T **           ppBuffer, 
               IUnknown**     ppCallObj, 
               AsyncI**       ppAsyncPipe, 
               ISynchronize** ppISync)
{

    if( *ppBuffer )
    {
        delete (*ppBuffer);
        (*ppBuffer) = NULL;
    }

    if( NULL != (*ppISync) )
    {
        (*ppISync)->Release();
        *ppISync = NULL;
    }

    if( NULL != (*ppAsyncPipe) )
    {
        (*ppAsyncPipe)->Release();
        *ppAsyncPipe = NULL;
    }

    if( NULL != (*ppCallObj) )
    {
        (*ppCallObj)->Release();
        *ppCallObj = NULL;
    }

}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CancelTheCall(DWORD delay)
//
// Description: Cancel the currently outstanding call.
//
// History:
// Date:   Time:          Developer:    Action:
// 12/9/97 10:59:54 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CancelTheCall(IUnknown *pCallObj, DWORD delay)
{
    ComDebOut(( DEB_MARSHAL, "CancelTheCall, this:%x \n", this));

    ICancelMethodCalls *pICancel;
    HRESULT hr = pCallObj->QueryInterface(IID_ICancelMethodCalls, 
                                          (void **) &pICancel);
    if( FAILED(hr) )
        return;

    pICancel->Cancel(delay);
    
    pICancel->Release();
    
    return;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// SetReadAhead(ULONG Request)
//
// Description: Determine the size of the read ahead.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/20/97 10:01:10 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
void CPipeProxy<T, ID, AsyncID, I, AsyncI>
::SetReadAhead(ULONG Request)
{
    ComDebOut(( DEB_MARSHAL, "SetReadAhead, this:%x Request:%u \n", this, Request));
    Win4Assert(Request != 0);

    switch(m_PullState)
    {
    case PULLSTATE1_FIRST_CALL :
        // On the first call just set the read ahead to the request.
        // This assumes that the request will be constant and 
        // we will be one call ahead all the time.
        m_cReadAhead = Request;
        break;
    case PULLSTATE2_NS_RQlsRA :
        // We haven't had a zero read or we wouldn't be here
        Win4Assert(m_cLastRead != 0);

        // Set the read ahead to the lesser of the request and the 
        // amount last read.  We are trying to match the read ahead with
        // the request by assuming a constant request, but the server
        // may only return a given amount regardless of what we 
        // request.
        m_cReadAhead = MIN(Request, m_cLastRead);
        break;
    case PULLSTATE3_NS_RQgeRA :
    case PULLSTATE5_S_RQgeBS :
        // No zero read
        Win4Assert(m_cLastRead != 0);

        // The request is greater than what was asked for last time.  So
        // we increase the read ahead to the max of the request or what
        // was actually read last time.
        m_cReadAhead = MAX(Request, m_cLastRead);
        break;
    default :
        // For all other states we should not be making read ahead calls.
        // Mostly because we read zero elements last time which indicates
        // the end of the data.  The PULLSTATE4_S_RQlsBS doesn't do a read
        // ahead so we shouldn't be here while in that state.
        Win4Assert(FALSE && "Request read ahead in wrong state.");
    }

    Win4Assert( 0 != m_cReadAhead );
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// CheckAndSetKeepBuffer()
//
// Description: Check to see if the Buffer is the correct size and if not
//              make it the correct size.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 3:27:25 PM    RichN         Created.
//
// Notes: The buffer will never get smaller.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::CheckAndSetKeepBuffer(void)
{
    Win4Assert(0 != m_cReadAhead);

    // Create a keep buffer the size of the read ahead.
    // We assume here that the user will not change the
    // request size and that the amount of data on hand
    // will never be larger.  When it is we will re-allocate.
    // The buffer will never get smaller.  Something to look at.
    if( m_cKeepBufferSize >= m_cReadAhead )
        return S_OK;
    
    T *temp = new T[m_cReadAhead];

    if( NULL == temp )
    {
        delete[] m_pKeepBuffer;
        m_pKeepBuffer = NULL;
        return E_OUTOFMEMORY;
    }

    if( m_pKeepBuffer != NULL )
    {
        // Copy the data into the new buffer
        memcpy(temp, m_pKeepBuffer, m_cKeepDataSize * sizeof(T));

        // Delete the old buffer and reset the bookkeeping.
        delete[] m_pKeepBuffer;
    }
    m_pKeepBuffer     = temp;
    m_cKeepBufferSize = m_cReadAhead;
    m_pKeepData       = m_pKeepBuffer + m_cKeepDataSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PullStateTransition(ULONG Request)
//
// Description: Transition from one state to the next.  See pipes document
//              for a description of the state machine.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/11/97 4:20:19 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PullStateTransition(ULONG Request)
{
    ComDebOut(( DEB_MARSHAL, "PullStateTransition \n"));

    Win4Assert(Request > 0);

    switch( m_PullState )
    {
    case PULLSTATE0_ENTRY:
        // Transition to the first call state.
        m_PullState = PULLSTATE1_FIRST_CALL;
        break;

    case PULLSTATE1_FIRST_CALL:
        // If the last read was zero we are done.  We have no stored 
        // data so go to the state that handles request
        // that are either less than or greater than or
        // equal to the last read ahead.  Realize the amount of
        // data returned from the last read ahead may
        // not equal the requeat and could be greater than or less than.
        if( 0 == m_cLastRead )
            m_PullState = PULLSTATE6_DONE;
        else 
            m_PullState = (Request < m_cReadAhead) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        break;

    case PULLSTATE2_NS_RQlsRA:
        // In this state, either the last read is not zero or
        // the amount of data remaining is zero.  Whatever state
        // we get to this one from does not go here on a last read
        // of zero nor if there is any data in the buffer (kept data).  
        // Possible we where in this state and got a last
        // read of zero, in which case the amount of held data will
        // be = zero.  We are in a state with no held data and got
        // a zero read of data, there can't be any kept data.
        Win4Assert(!( m_cLastRead == 0 && m_cKeepDataSize > 0));

        // If we had a zero read, we cleaned up in
        // this state and go to the state that just returns zero.
        if( 0 == m_cLastRead)
        {
            Win4Assert( 0 == m_cKeepDataSize );
            m_PullState = PULLSTATE6_DONE;
        }
        else
        {
            // If the kept data is zero, then we need to go to a state
            // that understands an empty buffer.  Determine which one
            // by the request and the read ahead.
            // If there is kept data then go to a state that understands
            // a non empty buffer.  This time the correct one depends on
            // the amount of data in the buffer.
            if( 0 == m_cKeepDataSize )
                m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
            else
                m_PullState = ( Request < m_cKeepDataSize) ? 
                            PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;                   
        }
        break;

    case PULLSTATE3_NS_RQgeRA:
        // We can never leave this state with data in the buffer.  The
        // request is greater than the read ahead and the returned amount
        // of data can never be greater than the requested data, but it
        // could be less.
        Win4Assert(m_cKeepDataSize == 0);

        // If the last read was zero go to the done state.
        // else go to the state that understands empty buffers depending
        // on the request and the read ahead.
        if( 0 == m_cLastRead )
            m_PullState = PULLSTATE6_DONE;
        else
            m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        break;

    case PULLSTATE4_S_RQlsBS:
        // When this state was entered there was data in the buffer.  The 
        // request was for less than the buffer size so when we returned
        // there should have still been data in the buffer.  No read is done.
        Win4Assert(m_cKeepDataSize > 0);
        Win4Assert(m_cLastRead > 0);

        // Go to the state that handles data in the buffer
        // depending on the request and the amount of data in the buffer.
        m_PullState = ( Request < m_cKeepDataSize ) ? 
                        PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;
        break;

    case PULLSTATE5_S_RQgeBS:
        // Because we can fulfill at aleast part of the request from
        // the buffer, we don't wait on the async call to finish.  If it 
        // did finish (wait 0 tells us that) then there is data in the
        // buffer (assuming it returned data) otherwise it is empty.  
        // So when the call finished last time the buffer 
        // could be empty or not.  If the read was zero the buffer is empty.
        Win4Assert( (m_cLastRead == 0 && m_cKeepDataSize == 0) ||
                     m_cLastRead != 0 );

        // If the buffer is empty then on a zero last read go to done. 
        // Otherwise go to a state that understands empty buffers depending
        // on the request size and the read ahead.
        if( 0 == m_cKeepDataSize )
            if( 0 == m_cLastRead )
                m_PullState = PULLSTATE6_DONE;
            else
                m_PullState = ( Request < m_cReadAhead ) ? 
                            PULLSTATE2_NS_RQlsRA : PULLSTATE3_NS_RQgeRA;
        else
            // Otherwise go to one that understands having data in the 
            // buffer depending on the request and the amount of data in
            // the buffer.
            m_PullState = ( Request < m_cKeepDataSize ) ? 
                            PULLSTATE4_S_RQlsBS : PULLSTATE5_S_RQgeBS;
        break;

    case PULLSTATE6_DONE:
        // When in this state there better not be any data left and
        // the last read must be zero.
        Win4Assert(m_cKeepDataSize == 0);
        Win4Assert(m_cLastRead == 0);
        
        m_PullState = PULLSTATE1_FIRST_CALL;

        break;

    default:
        return E_UNEXPECTED; 
    }
    
    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbNaRgtRA1 
//
// Description: Pull, No data in buffer, no async call outstanding and 
//              request is >= read ahead.  State 1.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 2:30:11 PM    RichN         Created.
//
// Notes: Make a sync call to get some data and then make an async call to
//        read ahead.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbNaRgtRA1(T *Buf, 
           ULONG Request, 
           ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbNaRgtRA1 Request:%d\n", Request));
    Win4Assert(1 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions
    Win4Assert(0 == m_cLastRead );
    Win4Assert(0 == m_cKeepDataSize);

    HRESULT hr = S_OK;

    // We are only in this state one time.  There will always be
    // an out standing async call, so we init async here.
    hr = InitAsync(&m_pPullCallObj, &m_pAsyncPullPipe, &m_pISyncPull);

    if( FAILED(hr) )
        return hr;

    // make a sync call to get started.
    hr = m_pRealProxy->Pull(Buf, Request, Received);
    m_cLastRead = *Received;

    if( m_cLastRead > 0 && SUCCEEDED(hr))
    {
        SetReadAhead(Request);

        // Make the async call.
        hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
    }
    else
    {
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);

    }

    // Post condition
    // Wouldn't expect the last read to be zero here, but no reason 
    // it couldn't be.
    Win4Assert( 0 == m_cKeepDataSize );

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbaRltRA2 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, No Buffer, read ahead call outstanding.  
//              State 2.  We have to be prepared
//              for the amount returned to be greater than, less than or equal
//              to the amount requested.  This works for both states 2 and 3.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/19/97 2:32:13 PM    RichN         Created.
//
// Notes: wait on the sync object,
//        Finish the async call,
//        Copy the data into the user Buffer
//        make another async call
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbaRltRA2 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbaRltRA2 Request:%d\n", Request));
    Win4Assert(2 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions.
    Win4Assert(0 == m_cKeepDataSize); // No data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request < m_cReadAhead);

    HRESULT hr = S_OK;
    bool bDoCleanup = false;

    // There might be a Bug here. Bug!
    // We should just be able to call the finish method, but the 
    // bug requires us to wait first.
    hr = m_pISyncPull->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
    {
        hr = CheckAndSetKeepBuffer();
        if( SUCCEEDED(hr) )
        {
            // Get the data requested last time.  Remember the amount returned
            // could be less than we requested.
            hr = m_pAsyncPullPipe->Finish_Pull(m_pKeepBuffer, &m_cLastRead);

            // We can't return more than requested, the buffer may not be 
            // large enough.
            *Received = MIN(Request, m_cLastRead);
            
            if( SUCCEEDED(hr) && m_cLastRead > 0 )
            {
                // Copy the data to the users Buffer and updata bookkeeping.
                memcpy(Buf, m_pKeepBuffer, (*Received) * sizeof(T));

                m_pKeepData = m_pKeepBuffer + *Received;
                m_cKeepDataSize = m_cLastRead - *Received;

                SetReadAhead(Request);

                // Make another read ahead
                hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
            }
            else
            {
                // If the call failed or we received no data, we
                // need to clean up since we won't be called again.
                bDoCleanup = true;
            }
        }
        else
        {
            //Cancel the call here.
            CancelTheCall(m_pPullCallObj, 0);
        }
    }

    if( FAILED(hr) || bDoCleanup )
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);


    // Post condition
    Win4Assert(!(m_cLastRead == 0 && m_cKeepDataSize > 0));

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbaRgtRA3 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, No Buffered data, async call outstanding and request
//              is greater than read ahead.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 10:50:22 AM    RichN         Created.
//
// Notes: Difference between this and the previous state: we know
//        we don't need a keep Buffer here.
//        wait on the sync object,
//        Finish the async call,
//        Copy the data into the user Buffer
//        make another async call
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbaRgtRA3 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "NbaRgtRA3, Request:%d  \n", Request));
    Win4Assert(3 == m_PullState);
    Win4Assert(NULL != Buf);

    // State conditions.
    Win4Assert(0 == m_cKeepDataSize); // No data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request >= m_cReadAhead);

    bool bDoCleanup = false;
    HRESULT hr = m_pISyncPull->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr))
    {
        // Get the data requested last time.
        hr = m_pAsyncPullPipe->Finish_Pull(Buf, &m_cLastRead);
        
        *Received = m_cLastRead;

        if( SUCCEEDED(hr) && m_cLastRead > 0 )
        {
            // Reset the amount of data remaining.
            m_cKeepDataSize = 0;
            m_pKeepData    = NULL;

            SetReadAhead(Request);

            // Make another read ahead
            hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
        }
        else
        {
            // If the call failed or we received no data, we
            // need to clean up since we won't be called again.
            bDoCleanup = TRUE;
        }
    }

    if( FAILED(hr) || bDoCleanup )
        CleanupProxy(&m_pKeepBuffer,
             &m_pPullCallObj, 
             &m_pAsyncPullPipe, 
             &m_pISyncPull);

    // Post condition
    Win4Assert( 0 < m_cReadAhead);
    Win4Assert(0 == m_cKeepDataSize);

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// baRltB4   (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, Data in Buffer, async call outstanding and Request is
//              less than the data in the keep Buffer.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 1:22:41 PM    RichN         Created.
//
// Notes: Copy data from the keep Buffer to the users Buffer.
//        Update state variables.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::baRltB4   (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "baRltB4    \n"));

    Win4Assert(NULL != Buf);
    Win4Assert(4 == m_PullState);

    // State conditions.
    Win4Assert(0 < m_cKeepDataSize); // Data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request < m_cKeepDataSize);

    memcpy(Buf, m_pKeepData, Request * (sizeof(T)));

    m_cKeepDataSize -= Request;
    m_pKeepData     += Request;

    // Post condition
    Win4Assert(m_cKeepDataSize > 0);
    Win4Assert(m_cLastRead > 0);

    // Post condition
    Win4Assert(0 < m_cKeepDataSize); // Data in keep Buffer.
    Win4Assert(0 < m_cLastRead);
    

    return S_OK;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// baRgtB5   (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull, Data in Buffer, async call outstanding and Request is
//              greater than or equal the data in the keep Buffer.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/20/97 1:24:25 PM    RichN         Created.
//
// Notes:  Copy the keep Buffer data to the users Buffer.
//         Wait 0
//         if the call has completed.
//             Finish the async call (keep Buffer, RA)
//             Copy data into users Buffer to fill request
//             Update keep data size.
//             if we didn't read zero
//                 set read ahead
//                 Begin async call(RA)
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::baRgtB5   (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "baRgtB5    \n"));

    Win4Assert(NULL != Buf);
    Win4Assert(5 == m_PullState);

    // State conditions.
    Win4Assert(0 < m_cKeepDataSize); // Data in keep buffer.
    Win4Assert(0 < m_cLastRead);
    Win4Assert(Request >= m_cKeepDataSize);

    HRESULT hr = S_OK;

    // Give whatever data we already have.
    T *tempBuf = Buf;
    memcpy(tempBuf, m_pKeepData, m_cKeepDataSize * (sizeof(T)) );

    // Remainder of the request.
    ULONG Remainder = Request - m_cKeepDataSize;

    tempBuf        += m_cKeepDataSize;
    m_cKeepDataSize = 0;
    m_pKeepData     = NULL;

    hr = m_pISyncPull->Wait(0, 0);

    // If the call is finished get the data and 
    // copy up to the total request or as much as
    // we have into the buffer.
    if( SUCCEEDED(hr) && RPC_S_CALLPENDING != hr)
    {
        hr = CheckAndSetKeepBuffer();
        if( SUCCEEDED(hr) )
        {
            hr = m_pAsyncPullPipe->Finish_Pull(m_pKeepBuffer, &m_cLastRead);

            if( SUCCEEDED(hr) )
            {
                // Copy the smaller of the remainder of the
                // request or what was actually received.
                ULONG CopySize = MIN(Remainder, m_cLastRead);

                memcpy(tempBuf, m_pKeepBuffer, CopySize * sizeof(T));

                m_cKeepDataSize = m_cLastRead - CopySize;
                m_pKeepData     = m_pKeepBuffer + CopySize;

                if( m_cLastRead > 0 )
                {
                    SetReadAhead(Request);

                    hr = m_pAsyncPullPipe->Begin_Pull(m_cReadAhead);
                }
            }
        }
        else
            CancelTheCall(m_pPullCallObj, 0);
    }
    else
    {
        if( RPC_S_CALLPENDING == hr )
            hr = S_OK;
        else
            CancelTheCall(m_pPullCallObj, 0);
    }

    *Received = (ULONG) (tempBuf - Buf);

    if( FAILED(hr) )
        CleanupProxy(&m_pKeepBuffer,
                     &m_pPullCallObj, 
                     &m_pAsyncPullPipe, 
                     &m_pISyncPull);

    // Post condition
    Win4Assert( (m_cLastRead == 0 && m_cKeepDataSize == 0) ||
                 m_cLastRead != 0 );

    return hr;
}


template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PullDone6 (T *Buf, ULONG Request, ULONG *Received)
//
// Description: Pull Done, no data in the Buffer and no outstanding calls.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/20/97 3:30:14 PM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PullDone6 (T *Buf, ULONG Request, ULONG *Received)
{
    ComDebOut(( DEB_MARSHAL, "PullDone6  \n"));

    Win4Assert(6 == m_PullState);

    CleanupProxy(&m_pKeepBuffer,
                 &m_pPullCallObj, 
                 &m_pAsyncPullPipe, 
                 &m_pISyncPull);

    HRESULT hr = S_OK;
    if (Request > 0)
    {
        m_PullState = PULLSTATE1_FIRST_CALL;
        hr = (this->*(PullStateFunc[m_PullState]))( Buf, Request, Received );
    }
    else
    {
        *Received = 0;

        // Post condition
        Win4Assert( 0 == m_cKeepDataSize );
        Win4Assert( 0 == m_cLastRead );
    }

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// SetPushBuffer(ULONG PushSize)
//
// Description: Allocates a buffer for push, or reallocates if it 
//              needs to grow.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/21/97 10:10:50 AM    RichN         Created.
//
// Notes: The buffer will never get smaller.  We might want
//        to reduce it by some algorithm, but not this time.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::SetPushBuffer(ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "SetPushBuffer, PushSize:%l \n"));
    // If it is already big enough just return.
    if( m_cPushBufferSize >= PushSize )
        return S_OK;


    ULONG NewSize = MAX(PushSize, (FRAGMENT_SIZE / sizeof(T)) + 1);
    T *pTtemp = new T[NewSize];

    if( NULL == pTtemp )
    {
        delete[] m_pPushBuffer;
        m_pPushBuffer = NULL;
        return E_OUTOFMEMORY;
    }

    ULONG BufferedDataSize = m_cPushBufferSize - m_cFreeSpace;

    if( m_pPushBuffer != NULL )
    {
        // Copy data over and reset bookkeeping.
        memcpy(pTtemp, m_pPushBuffer, BufferedDataSize * sizeof(T));

        delete[] m_pPushBuffer;
    }

    m_pPushBuffer     = pTtemp;
    m_cPushBufferSize = NewSize;
    m_pFreeSpace      = m_pPushBuffer + BufferedDataSize;
    m_cFreeSpace      = m_cPushBufferSize - BufferedDataSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PushStateTransition(ULONG Request)
//
// Description: Implements the transition table for push.  See the pipes 
//              document for a description of the state machine.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/13/97 4:36:43 PM    RichN         Created.
//
// 02/05/99               JohnStra      Modified Push state machine to
//                                      allow multiple Push operations
//                                      on a pipe.
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PushStateTransition(ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "PushStateTransition, PushSize:%l \n"));

    switch( m_PushState )
    {
        case PUSHSTATE0_ENTRY:
            // From the entry state we always go to the first call state.
            m_PushState = PUSHSTATE1_FIRSTCALL;
            break;

        case PUSHSTATE1_FIRSTCALL:
        case PUSHSTATE2_FS_PSgeFS:
        case PUSHSTATE3_FS_PSltFS:
            // If the push size is zero transition to state that
            // does a zero send.
            if( 0 == PushSize )
                m_PushState = PUSHSTATE4_FS_PSZERO;
            else
                // Go to state that either puts the data in free space
                // or one that handles a push greater than the free space.
                m_PushState = (PushSize < m_cFreeSpace) ? 
                             PUSHSTATE3_FS_PSltFS : PUSHSTATE2_FS_PSgeFS;
            break;

        case PUSHSTATE4_FS_PSZERO:
            // If we are in the state that handles a zero push we may
            // be called again with a positive buffer size to execute
            // another push.  If we are called with any other 
            // buffer size, go to the state that returns an error.
            if( 0 < PushSize )
                m_PushState = PUSHSTATE1_FIRSTCALL;
            else
                m_PushState = PUSHSTATE5_DONE_ERROR;
            break;

        case PUSHSTATE5_DONE_ERROR:
            // Stay in state PUSHSTATE_DONE_ERROR.
            break;

        default:
            return E_UNEXPECTED; 

    }

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// NbNf1(T *Buf, ULONG PushSize)
//
// Description: Push, No buffer, no free, state 1.
//
// History:
// Date:    Time:         Developer:    Action:
// 11/21/97 9:42:57 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::NbNf1(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "NbNf1, PushSize:%l \n", PushSize));

    Win4Assert(1 == m_PushState);

    // This is the first call to push so PushSize shouldn't be zero.
    if( PushSize == 0 || NULL == Buf)
        return E_INVALIDARG;

    HRESULT hr;

    // We are only in this state one time so init the async stuff.
    hr = InitAsync(&m_pPushCallObj, &m_pAsyncPushPipe, &m_pISyncPush);

    if( FAILED(hr) )
        return hr;

    hr = m_pAsyncPushPipe->Begin_Push(Buf, PushSize);

    if( FAILED(hr) )
        CleanupProxy(&m_pPushBuffer,
                     &m_pPushCallObj, 
                     &m_pAsyncPushPipe, 
                     &m_pISyncPush);

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bfPgtF2(T *Buf, ULONG PushSize)
//
// Description: Push, Have a buffer with free space and the push size
//              is greater than or equal to the free space. State 2.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 10:52:41 AM    RichN         Created.
//
// Notes: This may grow the buffer, look at reducing it in the next method.
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bfPgtF2(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bfPgtF2, PushSize:%l \n", PushSize));

    Win4Assert(2 == m_PushState);
    Win4Assert( PushSize >= m_cFreeSpace );
    Win4Assert( PushSize > 0 );
    Win4Assert( (LONG) m_cFreeSpace >= 0 );

    if( PushSize == 0 || NULL == Buf)
        return E_INVALIDARG;

    // There might be a BUG here. BUG! Shouldn't have to wait.
    HRESULT hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
        hr = m_pAsyncPushPipe->Finish_Push();

    if( SUCCEEDED(hr) )
    {
        ULONG TotalData = PushSize + (m_cPushBufferSize - m_cFreeSpace);
        hr = SetPushBuffer( TotalData );

        if( SUCCEEDED(hr) )
        {
            // Append the data to the buffer.
            memcpy(m_pFreeSpace, Buf, PushSize * sizeof(T));

            hr = m_pAsyncPushPipe->Begin_Push(m_pPushBuffer, TotalData);

            m_pFreeSpace       = m_pPushBuffer;
            m_cFreeSpace       = m_cPushBufferSize;
        }
    }

    if( FAILED(hr) )
        CleanupProxy(&m_pPushBuffer,
                     &m_pPushCallObj, 
                     &m_pAsyncPushPipe, 
                     &m_pISyncPush);


    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bfPltF3(T *Buf, ULONG PushSize)
//
// Description: Push, Have buffer and pushed data is less than free space.
//
// History:
// Date:    Time:          Developer:    Action:
// 11/21/97 11:03:19 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bfPltF3(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bfPltF3, PushSize:%l \n", PushSize));

    Win4Assert(3 == m_PushState);
    Win4Assert( m_cFreeSpace > PushSize );
    Win4Assert( PushSize     > 0 );
    Win4Assert( m_cFreeSpace > 0 );

    if( NULL == Buf)
        return E_INVALIDARG;

    // Copy the data into the buffer.
    memcpy(m_pFreeSpace, Buf, PushSize * sizeof(T));

    m_cFreeSpace -= PushSize;
    m_pFreeSpace += PushSize;

    return S_OK;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// bPSz4(T *Buf, ULONG PushSize)
//
// Description: Push, Have buffer and push size is zero.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 11:33:32 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::bPSz4(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "bPSz4, PushSize:$l \n", PushSize));

    Win4Assert(4 == m_PushState);
    Win4Assert( PushSize == 0 );
    Win4Assert( (LONG) m_cFreeSpace >= 0 );

    // There might be a BUG here.  BUG! Shouldn't have to wait.
    HRESULT hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

    if( SUCCEEDED(hr) )
        hr = m_pAsyncPushPipe->Finish_Push();

    if( SUCCEEDED(hr) )
    {
        if( (m_cPushBufferSize - m_cFreeSpace) > 0 )
        {
            // Data in buffer so send it.
            hr = m_pAsyncPushPipe->Begin_Push(m_pPushBuffer, 
                                              m_cPushBufferSize - m_cFreeSpace);
            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pAsyncPushPipe->Finish_Push();
        }
        
        if( SUCCEEDED(hr) )
        {
            // Push a zero size buffer to signal end of data.
            hr = m_pAsyncPushPipe->Begin_Push(Buf, PushSize);
            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pISyncPush->Wait(0, WAIT_INFINITE);

            if( FAILED(hr) )
                goto asyncFailed;

            hr = m_pAsyncPushPipe->Finish_Push();
        }

    }

asyncFailed:
    // Last call regardless of success or failure so clean async up.
    CleanupProxy(&m_pPushBuffer,
                 &m_pPushCallObj, 
                 &m_pAsyncPushPipe, 
                 &m_pISyncPush);

    return hr;
}

template<class T, const IID* ID, const IID *AsyncID, class I, class AsyncI>
//+**************************************************************************
// PushDone5(T *Buf, ULONG PushSize)
//
// Description: Push Done, so this should never be called.
//
// History:
// Date:   Time:         Developer:    Action:
// 11/21/97 11:42:08 AM    RichN         Created.
//
// Notes:
//
//-**************************************************************************
HRESULT CPipeProxy<T, ID, AsyncID, I, AsyncI>
::PushDone5(T *Buf, ULONG PushSize)
{
    ComDebOut(( DEB_MARSHAL, "PushDone5, PushSize:%u \n"));
    Win4Assert(FALSE && "Push call after completion.");
    Win4Assert(5 == m_PushState);

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\snb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       clipformat.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for SNB.
//
//  Functions:  
//              SNB_UserSize
//              SNB_UserMarshal
//              SNB_UserUnmarshal
//              SNB_UserFree
//              SNB_UserSize64
//              SNB_UserMarshal64
//              SNB_UserUnmarshal64
//              SNB_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserSize
//
//  Synopsis:   Sizes an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
SNB_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    SNB           * pSnb )
{
    if ( ! pSnb )
        return Offset;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;

        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // The wire size is: conf size, 2 fields and the wchars.

    LENGTH_ALIGN( Offset, 3 );

    return ( Offset + 3 * sizeof(long) + ulCntChar * sizeof( WCHAR ) );
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserMarshall
//
//  Synopsis:   Marshalls an SNB into the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserMarshal\n"));

    if ( ! pSnb )
        return pBuffer;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;

        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // conformant size

    ALIGN( pBuffer, 3 );
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // fields

    *( PULONG_LV_CAST pBuffer)++ = ulCntStr;
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // actual strings only

    if ( pSnb  &&  *pSnb )
        {
        // There is a NULL string pointer to mark the end of the pointer array.
        // However, the strings don't have to follow tightly.
        // Hence, we have to copy one string at a time.

        SNB   snb = *pSnb;
        WCHAR *pszSrc;

        while (pszSrc = *snb++)
            {
            ULONG ulCopyLen = (lstrlenW(pszSrc) + 1) * sizeof(WCHAR);

            WdtpMemoryCopy( pBuffer, pszSrc, ulCopyLen );
            pBuffer += ulCopyLen;
            }
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserUnmarshall
//
//  Synopsis:   Unmarshalls an SNB from the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//              Aug-99    JohnStra      Add consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserUnmarshal\n"));

    // Initialize CUserMarshalInfo object and get the buffer
    // size and pointer to the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save the size of the fixup.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before trying to get header.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (3 * sizeof( ULONG )) );

    // Get the header from the buffer.
    ULONG ulCntChar = *( PULONG_LV_CAST pBuffer)++;
    ULONG ulCntStr = *( PULONG_LV_CAST pBuffer)++;
    ULONG ulCntCharDup = *(PULONG_LV_CAST pBuffer)++;

    // Verify that 2nd instance of count matches first.
    if ( ulCntCharDup != ulCntChar )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // No reusage of pSNB.
    if ( *pSnb )
        WdtpFree( pFlags, *pSnb );

    if ( ulCntStr == 0 )
        {
        // There are no strings.

        // NULL pSnb and return.
        *pSnb = NULL;
        return pBuffer;
        }

    // Validate the header:
    // Repeated char count must match first instance and char count must
    // not be less than the number of strings since that would mean at
    // least one of them doesn't isn't terminated.
    if ( (ulCntChar != ulCntCharDup) || (ulCntChar < ulCntStr) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before trying to get the strings.
    CHECK_BUFFER_SIZE(
        BufferSize,
        cbFixup + (3 * sizeof(ULONG)) + (ulCntChar * sizeof(WCHAR)) );

    // Last WCHAR in the buffer must be the UNICODE terminator.
    WCHAR* pszChars = (WCHAR*) pBuffer;
    if ( pszChars[ulCntChar - 1] != 0x0000 )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // construct the SNB.
    SNB Snb = (SNB) WdtpAllocate( pFlags,
                                  ( (ulCntStr + 1) * sizeof(WCHAR *) +
                                     ulCntChar * sizeof(WCHAR)) );
    *pSnb = Snb;

    if (Snb)
        {
        // create the pointer array within the SNB.  to do this, we go through
        // the buffer, and use strlen to find the end of the each string for
        // us.
        WCHAR *pszSrc = (WCHAR *) pBuffer;
        WCHAR *pszTgt = (WCHAR *) (Snb + ulCntStr + 1); // right behind array

        void* SnbStart = Snb;
        ULONG ulTotLen = 0;
        ULONG i;
        for (i = ulCntStr; (i > 0) && (ulTotLen < ulCntChar); i--)
            {
            *Snb++ = pszTgt;

            ULONG ulLen = lstrlenW(pszSrc) + 1;
            pszSrc += ulLen;
            pszTgt += ulLen;
            ulTotLen += ulLen;
            }

        *Snb++ = NULL;

        // Verify that the number of strings and the number of chars
        // in the buffer matches what is supposed to be there.
        if ( (i > 0) || (ulTotLen < ulCntChar) )
            {
            WdtpFree( pFlags, SnbStart );
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            }

        // Copy the actual strings.
        // We can do a block copy here as we packed them tight in the buffer.
        // Snb points right behind the lastarray of pointers within the SNB.
        WdtpMemoryCopy( Snb, pBuffer, ulCntChar * sizeof(WCHAR) );
        pBuffer += ulCntChar * sizeof(WCHAR);
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserFree
//
//  Synopsis:   Frees an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

void __RPC_USER
SNB_UserFree(
    unsigned long * pFlags,
    SNB           * pSnb )
{
    if ( pSnb && *pSnb )
        WdtpFree( pFlags, *pSnb );
}

#if defined(_WIN64)

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserSize64
//
//  Synopsis:   Sizes an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
SNB_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    SNB           * pSnb )
{
    if ( ! pSnb )
        return Offset;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
    {
        SNB snb = *pSnb;
        
        WCHAR *psz = *snb;
        while (psz)
        {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
        }
    }
    
    // The wire size is: conf size, 2 fields and the wchars.
    LENGTH_ALIGN( Offset, 7 );    
    return ( Offset + 8 + (2 * sizeof(long)) + (ulCntChar * sizeof(WCHAR)) );
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserMarshal64
//
//  Synopsis:   Marshalls an SNB into the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
SNB_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserMarshal\n"));

    if ( ! pSnb )
        return pBuffer;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
    {
        SNB snb = *pSnb;
        
        WCHAR *psz = *snb;
        while (psz)
        {
            ulCntChar += lstrlenW(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
        }
    }

    // conformant size
    ALIGN( pBuffer, 7 );
    *( PHYPER_LV_CAST pBuffer)++ = ulCntChar;

    // fields
    *( PULONG_LV_CAST pBuffer)++ = ulCntStr;
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // actual strings only

    if ( pSnb  &&  *pSnb )
    {
        // There is a NULL string pointer to mark the end of the pointer array.
        // However, the strings don't have to follow tightly.
        // Hence, we have to copy one string at a time.
        
        SNB   snb = *pSnb;
        WCHAR *pszSrc;
        
        while (pszSrc = *snb++)
        {
            ULONG ulCopyLen = (lstrlenW(pszSrc) + 1) * sizeof(WCHAR);
            
            WdtpMemoryCopy( pBuffer, pszSrc, ulCopyLen );
            pBuffer += ulCopyLen;
        }
    }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an SNB from the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00   JohnDoty       Created from 32bit function
//
//--------------------------------------------------------------------------
unsigned char __RPC_FAR * __RPC_USER
SNB_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserUnmarshal\n"));

    // Initialize CUserMarshalInfo object and get the buffer
    // size and pointer to the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream( pBuffer, MarshalInfo.GetBufferSize() );

    // Get the header from the buffer....  (ReadHYPER aligns on 8).
    ULONG ulCntChar    = (ULONG)stream.ReadHYPER();
    ULONG ulCntStr     = stream.ReadULONGNA();
    ULONG ulCntCharDup = stream.ReadULONGNA();

    // Verify that 2nd instance of count matches first.
    if ( ulCntCharDup != ulCntChar )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // No reusage of pSNB.
    if ( *pSnb )
    {
        WdtpFree( pFlags, *pSnb );
        *pSnb = NULL;
    }

    if ( ulCntStr == 0 )
    {
        // There are no strings.
        return stream.GetBuffer();
    }

    // Validate the header:
    // Repeated char count must match first instance and char count must
    // not be less than the number of strings since that would mean at
    // least one of them doesn't isn't terminated.
    if ( ulCntChar < ulCntStr )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before trying to get the strings.
    stream.CheckSize(ulCntChar * sizeof(WCHAR));

    // Last WCHAR in the buffer must be the UNICODE terminator.
    WCHAR* pszChars = (WCHAR*)stream.GetBuffer();
    if ( pszChars[ulCntChar - 1] != L'\0' )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // construct the SNB.
    SNB Snb = (SNB) WdtpAllocate( pFlags,
                                  ( (ulCntStr + 1) * sizeof(WCHAR *) +
                                     ulCntChar * sizeof(WCHAR)) );
    *pSnb = Snb;

    if (Snb)
    {
        // create the pointer array within the SNB.  to do this, we go through
        // the buffer, and use strlen to find the end of the each string for
        // us.
        WCHAR *pszSrc = (WCHAR *) stream.GetBuffer();
        WCHAR *pszTgt = (WCHAR *) (Snb + ulCntStr + 1); // right behind array
        
        void* SnbStart = Snb;
        ULONG ulTotLen = 0;
        ULONG i;
        for (i = ulCntStr; (i > 0) && (ulTotLen < ulCntChar); i--)
        {
            *Snb++ = pszTgt;
            
            ULONG ulLen = lstrlenW(pszSrc) + 1;
            pszSrc += ulLen;
            pszTgt += ulLen;
            ulTotLen += ulLen;
        }
        
        *Snb++ = NULL;
        
        // Verify that the number of strings and the number of chars
        // in the buffer matches what is supposed to be there.
        if ( (i > 0) || (ulTotLen < ulCntChar) )
        {
            WdtpFree( pFlags, SnbStart );
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
        }
        
        // Copy the actual strings.
        // We can do a block copy here as we packed them tight in the buffer.
        // Snb points right behind the lastarray of pointers within the SNB.
        WdtpMemoryCopy( Snb, stream.GetBuffer(), ulCntChar * sizeof(WCHAR) );
        stream.Advance(ulCntChar * sizeof(WCHAR));
    }

    return stream.GetBuffer();
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserFree64
//
//  Synopsis:   Frees an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    Dec-00    JohnDoty      Created from 32bit function
//
//--------------------------------------------------------------------------

void __RPC_USER
SNB_UserFree64 (
    unsigned long * pFlags,
    SNB           * pSnb )
{
    if ( pSnb && *pSnb )
        WdtpFree( pFlags, *pSnb );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\sources.inc ===
NO_CAIRO_LIBS=1

TARGETNAME=oleprx32
TARGETPATH=obj
TARGETTYPE=LIBRARY

ASYNC_DOCFILE_INC=..\..\..\stg\async\docfile\$(DEST_TREE)\$(O)

INCLUDES=..\.;..\..\..\ih
INCLUDES=$(INCLUDES);..\..\..\com\inc
INCLUDES=$(INCLUDES);..\..\..\com\dcomrem
INCLUDES=$(INCLUDES);..\..\..\idl\internal
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\stg\h
INCLUDES=$(INCLUDES);$(ASYNC_DOCFILE_INC)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)
INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH)

CONDITIONAL_INCLUDES=

SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DENTRY_PREFIX=Prx -DPROXY_CLSID=CLSID_PSOlePrx32 -DREGISTER_PROXY_DLL

# All the files listed below ending in _p.c are generated by MIDL

SOURCES= \
         dlldata.c         \
         mega_p.c          \
         mega_i.c          \
         prop_x.c          \
         prop_i.c          \
         ..\call_as.c      \
         ..\pipes.cxx      \
         ..\remunkps.cxx   \
         ..\transmit.cxx   \
         ..\clipformat.cxx \
         ..\snb.cxx        \
         ..\hglobal.cxx    \
         ..\metafile.cxx   \
         ..\bitmap.cxx     \
         ..\hpalette.cxx   \
         ..\stgmedium.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\transmit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       transmit.h
//
//  Contents:   Function prototypes for STGMEDIUM marshalling.
//
//  Functions:  STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//
//  History:    May-10-94   ShannonC    Created
//  History:    May-10-95   Ryszardk    wire_marshal changes
//
//--------------------------------------------------------------------------
#pragma once
#ifndef __TRANSMIT_H__
#define __TRANSMIT_H__

#include <debnot.h>

#if (DBG==1)

DECLARE_DEBUG(UserNdr)
//
#define UserNdrDebugOut(x) UserNdrInlineDebugOut x
#define UserNdrAssert(x)   Win4Assert(x)
#define UserNdrVerify(x)   Win4Assert(x)

//#define UNDR_FORCE   DEB_FORCE
#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

EXTERN_C char *
WdtpGetStgmedName( STGMEDIUM * );

#else

#define UserNdrDebugOut(x)
#define UserNdrAssert(x)
#define UserNdrVerify(x)

#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

#endif

// Shortcut typedefs.
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

#ifndef TRUE
#define TRUE    (1)
#define FALSE   (0)
typedef unsigned short BOOL;
#endif

//
// Alignment and access macros.
//
#define ALIGN( pStuff, cAlign ) \
        pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))

#define PCHAR_LV_CAST   *(char __RPC_FAR * __RPC_FAR *)&
#define PSHORT_LV_CAST  *(short __RPC_FAR * __RPC_FAR *)&
#define PLONG_LV_CAST   *(long __RPC_FAR * __RPC_FAR *)&
#define PHYPER_LV_CAST  *(hyper __RPC_FAR * __RPC_FAR *)&

#define PUSHORT_LV_CAST  *(unsigned short __RPC_FAR * __RPC_FAR *)&
#define PULONG_LV_CAST   *(unsigned long __RPC_FAR * __RPC_FAR *)&

// Just a pointer sized random thing we can identify in the stream.
// For error checking purposes only.
#define USER_MARSHAL_MARKER     0x72657355

//
// These are based on flags defined in wtypes.idl comming from the channel.
// They indicate where we are marshalling.
//
#define INPROC_CALL( Flags) (USER_CALL_CTXT_MASK(Flags) == MSHCTX_INPROC)
#define REMOTE_CALL( Flags) ((USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE) \
                          || (USER_CALL_CTXT_MASK(Flags) == MSHCTX_NOSHAREDMEM))
#define DIFFERENT_MACHINE_CALL( Flags)  \
                        (USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE)

// There is a difference in the scope of handles, Daytona vs. Chicago.
// The following is an illustration of the notions of
//    HGLOBAL handle vs. data passing and  GDI handle vs. data passing.
// The type of an rpc call is defined by the flags above.
//
// This is included only for historical interest, as this code no longer
// has anything to do with chicago, win9x, or any of that goo.
//
// Daytona rules: GDI same as HGLOBAL
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|------------|----------------------------------------------------|
//|  GDI h.p.  |             GDI data passing                       |
//|------------|----------------------------------------------------|
//
// Chicago rules: HGLOBAL stricter than GDI.
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|-----------------------------------------------------------------|
//|  GDI handle passing         |          GDI data passing         |
//|-----------------------------|-----------------------------------|

#define HGLOBAL_HANDLE_PASSING( Flags )     INPROC_CALL( Flags)
#define HGLOBAL_DATA_PASSING( Flags )     (!INPROC_CALL( Flags))

// On Chicago, some handles are valid between processes.
// #if defined(_CHICAGO_)
// #define GDI_HANDLE_PASSING( Flags )      (! REMOTE_CALL( Flags ))
// #define GDI_DATA_PASSING( Flags )           REMOTE_CALL( Flags )
// #else
// #endif
#define GDI_HANDLE_PASSING( Flags )         HGLOBAL_HANDLE_PASSING( Flags )
#define GDI_DATA_PASSING( Flags )           HGLOBAL_DATA_PASSING( Flags )


#define WDT_DATA_MARKER        WDT_REMOTE_CALL
#define WDT_HANDLE_MARKER      WDT_INPROC_CALL
#define WDT_HANDLE64_MARKER    WDT_INPROC64_CALL
#define IS_DATA_MARKER( dw )   (WDT_REMOTE_CALL == dw)
#define IS_HANDLE_MARKER( dw ) (WDT_INPROC_CALL == dw)
#define IS_HANDLE64_MARKER( dw ) (WDT_INPROC64_CALL == dw)

//
// CLIPFORMAT remoting
//
#define CLIPFORMAT_BUFFER_MAX  248

#define NON_STANDARD_CLIPFORMAT(pcf)((0xC000<= *pcf) && (*pcf <=0xFFFF))

#define REMOTE_CLIPFORMAT(pFlags) ((USER_CALL_CTXT_MASK(*pFlags) == MSHCTX_DIFFERENTMACHINE) )

//
// Useful memory macros, for consistency.
//
#define WdtpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)
#define WdtpZeroMemory(Destination, Length) \
    RtlZeroMemory(Destination, Length)

#define WdtpAllocate(p,size)    \
    ((USER_MARSHAL_CB *)p)->pStubMsg->pfnAllocate( size )
#define WdtpFree(pf,ptr)    \
    ((USER_MARSHAL_CB *)pf)->pStubMsg->pfnFree( ptr )

//
// Used in call_as.c
//
EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed );

//
// Useful checking/exception routines.
//
#if DBG==1
#define RAISE_RPC_EXCEPTION( e )                                 \
    {                                                            \
    Win4Assert( !"Wire marshaling problem!" );                   \
    RpcRaiseException( (e) );                                    \
    }
#else
#define RAISE_RPC_EXCEPTION( e )                                 \
    {                                                            \
    RpcRaiseException( (e) );                                    \
    }
#endif

#define CHECK_BUFFER_SIZE( b, s )                                \
    if ( (b) < (s) )                                             \
        {                                                        \
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );              \
        }

#endif  // __TRANSMIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\stgmedium.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       hpalette.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//              This file contains support for STGMEDIUM, FLAG_STGMEDIUM, and 
//               ASYNC_STGMEDIUM.
//
//  Functions:  
//              STGMEDIUM_UserSize
//              STGMEDIUM_UserMarshal
//              STGMEDIUM_UserUnmarshal
//              STGMEDIUM_UserFree
//              STGMEDIUM_UserSize64
//              STGMEDIUM_UserMarshal64
//              STGMEDIUM_UserUnmarshal64
//              STGMEDIUM_UserFree64
//              FLAG_STGMEDIUM_UserSize
//              FLAG_STGMEDIUM_UserMarshal
//              FLAG_STGMEDIUM_UserUnmarshal
//              FLAG_STGMEDIUM_UserFree
//              FLAG_STGMEDIUM_UserSize64
//              FLAG_STGMEDIUM_UserMarshal64
//              FLAG_STGMEDIUM_UserUnmarshal64
//              FLAG_STGMEDIUM_UserFree64
//              ASYNC_STGMEDIUM_UserSize
//              ASYNC_STGMEDIUM_UserMarshal
//              ASYNC_STGMEDIUM_UserUnmarshal
//              ASYNC_STGMEDIUM_UserFree
//              ASYNC_STGMEDIUM_UserSize64
//              ASYNC_STGMEDIUM_UserMarshal64
//              ASYNC_STGMEDIUM_UserUnmarshal64
//              ASYNC_STGMEDIUM_UserFree64
//
//  History:    13-Dec-00   JohnDoty    Migrated from transmit.cxx,
//                                      created NDR64 functions
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>

#include "carefulreader.hxx"

// PROTOTYPES FOR OTHER USERMARSHAL ROUTINES, TO HELP US!
EXTERN_C unsigned long __stdcall __RPC_USER WdtpInterfacePointer_UserSize (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned long Offset, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall WdtpInterfacePointer_UserMarshal (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned char *pBuffer, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned long __stdcall __RPC_USER WdtpInterfacePointer_UserSize64 (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned long Offset, IUnknown *pIf, const IID &IId );
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall WdtpInterfacePointer_UserMarshal64 (USER_MARSHAL_CB * pContext, unsigned long Flags, unsigned char *pBuffer, IUnknown *pIf, const IID &IId );
unsigned char __RPC_FAR * __RPC_USER WdtpInterfacePointer_UserUnmarshalWorker (USER_MARSHAL_CB * pContext,  unsigned char * pBuffer, IUnknown ** ppIf, const IID &IId, ULONG_PTR BufferSize, BOOL fNDR64 );


unsigned char __RPC_FAR * __RPC_USER HMETAFILEPICT_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HMETAFILEPICT * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HMETAFILEPICT_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HMETAFILEPICT * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HENHMETAFILE_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HENHMETAFILE * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HENHMETAFILE_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HENHMETAFILE * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HBITMAP_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HBITMAP * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HBITMAP_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HBITMAP * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER HPALETTE_UserUnmarshalWorker (unsigned long * pFlags, unsigned char * pBuffer, HPALETTE * pHMetaFilePict, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER HPALETTE_UserUnmarshalWorker64 (unsigned long * pFlags, unsigned char * pBuffer, HPALETTE * pHMetaFilePict, ULONG_PTR BufferSize);

unsigned char __RPC_FAR * __RPC_USER WdtpGlobalUnmarshal (unsigned long * pFlags, unsigned char * pBuffer, HGLOBAL * pGlobal, BOOL fCanReallocate, ULONG_PTR BufferSize);
unsigned char __RPC_FAR * __RPC_USER WdtpGlobalUnmarshal64 (unsigned long * pFlags, unsigned char * pBuffer, HGLOBAL * pGlobal, BOOL fCanReallocate, ULONG_PTR BufferSize);


//+-------------------------------------------------------------------------
//
//  class:  CPunkForRelease
//
//  purpose:    special IUnknown for remoted STGMEDIUMs
//
//  history:    02-Mar-94   Rickhi      Created
//
//  notes:  This class is used to do the cleanup correctly when certain
//      types of storages are passed between processes or machines
//      in Nt and Chicago.
//
//      On NT, GLOBAL, GDI, and BITMAP handles cannot be passed between
//      processes, so we actually copy the whole data and create a
//      new handle in the receiving process. However, STGMEDIUMs have
//      this weird behaviour where if PunkForRelease is non-NULL then
//      the sender is responsible for cleanup, not the receiver. Since
//      we create a new handle in the receiver, we would leak handles
//      if we didnt do some special processing.  So, we do the
//      following...
//
//          During STGMEDIUM_UserUnmarshal, if there is a pUnkForRelease
//          replace it with a CPunkForRelease.  When Release is called
//          on the CPunkForRelease, do the necessary cleanup work,
//          then call the real PunkForRelease.
//
//+-------------------------------------------------------------------------

class   CPunkForRelease : public IUnknown
{
public:
    CPunkForRelease( STGMEDIUM *pStgMed, ulong fTopLayerOnly);

    //  IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppunk);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    ~CPunkForRelease(void);

    ULONG       _cRefs;                 //  reference count
    ULONG       _fTopLayerMFP:1;        //  optimisation flag for Chicago
    STGMEDIUM   _stgmed;                //  storage medium
    IUnknown  * _pUnkForRelease;        //  real pUnkForRelease
};


inline CPunkForRelease::CPunkForRelease(
    STGMEDIUM * pStgMed,
    ulong       fTopLayerMFPict
    ) :
    _cRefs(1),
    _fTopLayerMFP( fTopLayerMFPict),
    _stgmed(*pStgMed)
{
    //  NOTE: we assume the caller has verified pStgMed is not NULL,
    //  and the pUnkForRelease is non-null, otherwise there is no
    //  point in constructing this object.  The tymed must also be
    //  one of the special ones.

    UserNdrAssert(pStgMed);
    UserNdrAssert(pStgMed->tymed == TYMED_HGLOBAL ||
       pStgMed->tymed == TYMED_GDI  ||
       pStgMed->tymed == TYMED_MFPICT  ||
       pStgMed->tymed == TYMED_ENHMF);

    _pUnkForRelease = pStgMed->pUnkForRelease;
}


inline CPunkForRelease::~CPunkForRelease()
{
    //  since we really have our own copies of these handles' data, just
    //  pretend like the callee is responsible for the release, and
    //  recurse into ReleaseStgMedium to do the cleanup.

    _stgmed.pUnkForRelease = NULL;

    // There is this weird optimized case of Chicago MFPICT when we have two
    // layers with a HENHMETAFILE handle inside. Top layer is an HGLOBAL.

    if ( _fTopLayerMFP )
        GlobalFree( _stgmed.hGlobal );
    else
        ReleaseStgMedium( &_stgmed );

    //  release the callers punk
    _pUnkForRelease->Release();
}

STDMETHODIMP_(ULONG) CPunkForRelease::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CPunkForRelease::Release(void)
{
    long Ref = _cRefs - 1;

    UserNdrAssert( _cRefs );

    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
        {
        // null out the vtable.
        long * p = (long *)this;
        *p = 0;

        delete this;
        return 0;
        }
    else
        return Ref;
}

STDMETHODIMP CPunkForRelease::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
    *ppv = (void *)(IUnknown *) this;
    AddRef();
    return S_OK;
    }
    else
    {
    *ppv = NULL;
    return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SetContextFlagsForAsyncCall
//
//  Synopsis:   Forces correct flags for an async stgmed call.
//
//  history:    May-97   Ryszardk      Created.
//
//  We used to force MSHCTX_DIFFERENTMACHINE context on every
//  async stgmedium call because of problems with handles - for a truly
//  async call passing a handle, the client may free the handle before
//  the server can use it.
//  That is still needed. However, we cannot force the different machine
//  flags on IStream and IStorage as that prevents custom marshaler from
//  running.
//
//--------------------------------------------------------------------------

void inline
SetContextFlagsForAsyncCall(
    unsigned long * pFlags,
    STGMEDIUM     * pStgmed )
{
    if ( *pFlags & USER_CALL_IS_ASYNC )
        {
        // Additional considerations for async calls.

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
            case TYMED_MFPICT:
            case TYMED_ENHMF:
            case TYMED_GDI:
            case TYMED_HGLOBAL:
            case TYMED_FILE:
            default:
                if (!REMOTE_CALL(*pFlags))
                    {
                    *pFlags &= ~0xff;
                    *pFlags |= MSHCTX_DIFFERENTMACHINE;
                    }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Dont force remote.
                break;

            }
        }
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a stgmedium pbject for RPC marshalling.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    STGMEDIUM     * pStgmed )
{
    if ( ! pStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // Both handle and pUnk are represented by a long.
    if ( pStgmed->tymed == TYMED_NULL )
        Offset += sizeof(long) + sizeof(long);  // switch, (empty arm), pUnk
    else
        Offset += sizeof(long) + 2 * sizeof(long); // switch, handle, pUnk

    // Pointee of the union arm.
    // Only if the handle/pointer field is non-null.

    if ( pStgmed->hGlobal )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                Offset = HMETAFILEPICT_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                Offset = HENHMETAFILE_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:

                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                // switch for object type.

                Offset += sizeof(long);

                switch( GetObjectType( (HGDIOBJ)pStgmed->hBitmap ) )
                    {
                    case OBJ_BITMAP:
                        Offset = HBITMAP_UserSize( pFlags,
                                                   Offset,
                                                   &pStgmed->hBitmap );
                        break;

                    case OBJ_PAL:
                        Offset = HPALETTE_UserSize( pFlags,
                                                    Offset,
                                       (HPALETTE *) & pStgmed->hBitmap );
                        break;

                    default:
                        RAISE_RPC_EXCEPTION(DV_E_TYMED);
                        break;
                    }
                break;

            case TYMED_HGLOBAL:
                Offset = HGLOBAL_UserSize( pFlags,
                                            Offset,
                                            &pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                ulong ulDataSize = lstrlenW(pStgmed->lpszFileName) + 1;
                Offset += 3 * sizeof(long); // [string]
                Offset += ulDataSize * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                Offset = WdtpInterfacePointer_UserSize(
                            (USER_MARSHAL_CB *)pFlags,
                            *pFlags,
                            Offset,
                            pStgmed->pstg,
                            ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                : IID_IStorage));
                break;

            default:
                break;

            }
        }

    // pUnkForRelease, if not null.

    if ( pStgmed->pUnkForRelease )
        Offset = WdtpInterfacePointer_UserSize( (USER_MARSHAL_CB *)pFlags,
                                                 *pFlags,
                                                 Offset,
                                                 pStgmed->pUnkForRelease,
                                                 IID_IUnknown );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a stgmedium pbject for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    STGMEDIUM     * pStgmed )
{
    unsigned char * pBuffer;
    unsigned char * pUnionArmMark;

    if ( ! pStgmed )
        return pBufferStart;

    UserNdrDebugOut((
        UNDR_FORCE,
        "--STGMEDIUM_UserMarshal: %s\n",
        WdtpGetStgmedName(pStgmed)));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 3 );

    // userSTGMEDIUM: switch, union arm, pUnk ptr.

    *( PULONG_LV_CAST pBuffer)++ = pStgmed->tymed;
    pUnionArmMark = pBuffer;
    if ( pStgmed->tymed != TYMED_NULL )
        {
        // hGlobal stands for any of these handles.

        *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pStgmed->hGlobal );
        }

    *( PLONG_LV_CAST pBuffer)++ = HandleToLong( pStgmed->pUnkForRelease );

    // Now the pointee of the union arm.
    // We need to marshal only if the handle/pointer field is non null.
    // Otherwise it is already in the buffer.

    if ( pStgmed->hGlobal )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                pBuffer = HMETAFILEPICT_UserMarshal( pFlags,
                                                     pBuffer,
                                                     &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                pBuffer = HENHMETAFILE_UserMarshal( pFlags,
                                                    pBuffer,
                                                    &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:

                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                ulong GdiObjectType = GetObjectType( (HGDIOBJ)pStgmed->hBitmap );

                // GDI_OBJECT

                *( PULONG_LV_CAST pBuffer)++ = GdiObjectType;

                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        pBuffer = HBITMAP_UserMarshal( pFlags,
                                                       pBuffer,
                                                       &pStgmed->hBitmap );
                        break;

                    case OBJ_PAL:
                        pBuffer = HPALETTE_UserMarshal( pFlags,
                                                        pBuffer,
                                           (HPALETTE *) & pStgmed->hBitmap );
                        break;

                    default:
                        RpcRaiseException(DV_E_TYMED);
                    }
                }
                break;

            case TYMED_HGLOBAL:
                pBuffer = HGLOBAL_UserMarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                // We marshal it as a [string].

                ulong Count = (pStgmed->lpszFileName)
                                    ?  lstrlenW(pStgmed->lpszFileName) + 1
                                    :  0;

                *( PULONG_LV_CAST pBuffer)++ = Count;
                *( PULONG_LV_CAST pBuffer)++ = 0;
                *( PULONG_LV_CAST pBuffer)++ = Count;
                memcpy( pBuffer, pStgmed->lpszFileName, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                pBuffer = WdtpInterfacePointer_UserMarshal(
                               ((USER_MARSHAL_CB *)pFlags),
                               *pFlags,
                               pBuffer,
                               pStgmed->pstg,
                               ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                   : IID_IStorage));
                break;

            default:
                break;
            }
        }

    // Marker for this pointer is already in the buffer.

    if ( pStgmed->pUnkForRelease )
        pBuffer = WdtpInterfacePointer_UserMarshal( ((USER_MARSHAL_CB *)pFlags
),
                                                    *pFlags,
                                                    pBuffer,
                                                    pStgmed->pUnkForRelease,
                                                    IID_IUnknown );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshalWorker
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Aug-99   JohnStra      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshalWorker(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed,
    ULONG_PTR       BufferSize )
{
    unsigned long   fUnkForRelease;
    LONG_PTR        Handle = 0;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR) (pBuffer - pBufferStart);

    // Check for EOB.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + sizeof( ULONG ) );

    // switch, union arm, pUnk.
    pStgmed->tymed = *( PULONG_LV_CAST pBuffer)++;

    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal: %s\n",
                     WdtpGetStgmedName(pStgmed) ));

    ULONG_PTR cbData = cbFixup + (2 * sizeof( ULONG ));
    if ( pStgmed->tymed != TYMED_NULL )
        {
        cbData += sizeof( ULONG );

        CHECK_BUFFER_SIZE( BufferSize, cbData );

        // This value is just a marker for the handle - a long.
        Handle =  *( PLONG_LV_CAST pBuffer)++;
        }
    else
        {
        CHECK_BUFFER_SIZE( BufferSize, cbData );
        }

    // pUnkForRelease pointer marker.
    fUnkForRelease = *( PULONG_LV_CAST pBuffer)++;

    // First pointee

    // Union arm pointee.
    // We need to unmarshal only if the handle/pointer field was not NULL.

    if ( Handle )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        LONG* pBuf = (LONG*)pBuffer;

        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:

#if defined(_WIN64)
                if ( IS_DATA_MARKER( pBuf[0] ) )
                {
                    CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                    if ( Handle != pBuf[1] )
                    {
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }
                else
                {
                    //Inproc should always have marked this as handle64....
                    //Out-of-proc should always have marked this with a data marker....
                    if (!IS_HANDLE64_MARKER(pBuf[0]))
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    // Align to 64b.
                    PBYTE pbBuf = (PBYTE)( pBuf + 1 );
                    PBYTE pbBufStart = pbBuf;
                    ALIGN( pbBuf, 7 );

                    // Make sure we don't step off the end of the buffer.
                    CHECK_BUFFER_SIZE( BufferSize, cbData +
                                        (ULONG_PTR)(pbBuf - pbBufStart) +
                                                   (sizeof(__int64)) );

                    // Verify that the handle put on the wire matches the
                    // first instance of the handle on the wire.
                    if ( Handle != (LONG_PTR) (*(LONG *)pbBuf ) )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
#else
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof(ULONG)) );

                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
#endif

                pBuffer = HMETAFILEPICT_UserUnmarshalWorker(
                                      pFlags,
                                      pBuffer,
                                     &pStgmed->hMetaFilePict,
                                      BufferSize - cbData );
                break;
            case TYMED_ENHMF:
                // Must be room in buffer to do lookahead check.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                // validate the handle.
                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                pBuffer = HENHMETAFILE_UserUnmarshalWorker( pFlags,
                                                            pBuffer,
                                                        &pStgmed->hEnhMetaFile,
                                                            BufferSize - cbData );
                break;
            case TYMED_GDI:
                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we
                // handle those types we know about based on the object type,
                // and reject those which we do not support.

                // Make sure we don't walk off the end of the buffer.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (3 * sizeof( ULONG )) );

                cbData += sizeof( ULONG );

                DWORD GdiObjectType = *( PULONG_LV_CAST pBuffer)++;

                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        // Lookahead validaton of the handle.  We look at
                        // the 3rd DWORD: GDI type, DISC, Handle.
                        if ( Handle != pBuf[2] )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        pBuffer = HBITMAP_UserUnmarshalWorker( pFlags,
                                                               pBuffer,
                                                              &pStgmed->hBitmap,
                                                               BufferSize - cbData );
                        break;

                    case OBJ_PAL:
                        // Lookahead validaton of the handle.
                        if ( Handle != pBuf[2] )
                            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                        pBuffer = HPALETTE_UserUnmarshalWorker( pFlags,
                                                                pBuffer,
                                               (HPALETTE *) & pStgmed->hBitmap,
                                                                BufferSize - cbData );
                        break;

                    default:
                        RAISE_RPC_EXCEPTION(DV_E_TYMED);
                    }
                }
                break;

            case TYMED_HGLOBAL:
                {
                // reallocation is forbidden for [in-out] hglobal in STGMEDIUM.

#if defined(_WIN64)
                if ( IS_DATA_MARKER( pBuf[0] ) )
                {
                    CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof( ULONG )) );

                    if ( Handle != pBuf[1] )
                    {
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                    }
                }
                else
                {
                    // Align to 64b.
                    PBYTE pbBuf = (PBYTE)( pBuf + 1 );
                    PBYTE pbBufStart = pbBuf;
                    ALIGN( pbBuf, 7 );

                    // Make sure we don't step off the end of the buffer.
                    CHECK_BUFFER_SIZE( BufferSize, cbData +
                                        (ULONG_PTR)(pbBuf - pbBufStart) +
                                                   (sizeof(__int64)) );

                    // Verify that the handle put on the wire matches the
                    // first instance of the handle on the wire.
                    if ( Handle != (LONG_PTR) (*(LONG *)pbBuf ) )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
#else
                CHECK_BUFFER_SIZE( BufferSize, cbData + (2 * sizeof(ULONG)) );

                if ( Handle != pBuf[1] )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
#endif

                pBuffer = WdtpGlobalUnmarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal,
                                               FALSE,
                                               BufferSize - cbData);
                break;
                }
            case TYMED_FILE:
                {
                // Must be room in buffer for header.
                CHECK_BUFFER_SIZE( BufferSize, cbData + (3 * sizeof(ULONG)) );

                // We marshal it as a [string].

                ulong Count = *( PULONG_LV_CAST pBuffer)++;
                if ( *( PULONG_LV_CAST pBuffer)++ != 0 ||
                     *( PULONG_LV_CAST pBuffer)++ != Count )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                if ( ! pStgmed->lpszFileName )
                    pStgmed->lpszFileName = (LPOLESTR)
                                        WdtpAllocate( pFlags,
                                                      Count * sizeof(wchar_t) );

                // Must be room in the buffer for the string.
                CHECK_BUFFER_SIZE(
                    BufferSize,
                    cbData + (3 * sizeof( ULONG )) + (Count * sizeof( wchar_t )) );

                memcpy(pStgmed->lpszFileName, pBuffer, Count * sizeof(wchar_t));
                pBuffer += Count * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Non null pointer, retrieve the interface pointer

                pBuffer = WdtpInterfacePointer_UserUnmarshalWorker(
                              (USER_MARSHAL_CB *)pFlags,
                              pBuffer,
                              (IUnknown **) &pStgmed->pstm,
                              ((pStgmed->tymed == TYMED_ISTREAM)
                                    ? IID_IStream
                                    : IID_IStorage),
                               BufferSize - cbData,
                              FALSE );
                break;

            default:
                break;
            }
        }
    else
        {
        // New handle/pointer field is null, so release the previous one
        // if it wasn't null.

        if ( pStgmed->hGlobal )
            {
            // This should never happen for GetDataHere.

            // Note, that we release the handle field, not the stgmedium itself.
            // Accordingly, we don't follow punkForRelease.

            UserNdrDebugOut((
                  UNDR_FORCE,
                  "--STGMEDIUM_UserUnmarshal: %s: NULL in, freeing old one\n",
                  WdtpGetStgmedName(pStgmed)));

            STGMEDIUM  TmpStg = *pStgmed;
            TmpStg.pUnkForRelease = NULL;

            if ( pStgmed->tymed == TYMED_HGLOBAL )
                {
                // Cannot reallocate.
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
                }
            else
                {
                ReleaseStgMedium( &TmpStg );
                }
            }

        pStgmed->hGlobal = 0;
        }

    // Fixup the buffer size so if fUnkForRelease is set, we
    // pass the correct BufferSize to the unmarshal routine.
    BufferSize -= (ULONG_PTR)(pBuffer - pBufferStart);

    if ( fUnkForRelease )
        {
        // There is an interface pointer on the wire.

        pBuffer = WdtpInterfacePointer_UserUnmarshalWorker(
                        (USER_MARSHAL_CB *)pFlags,
                        pBuffer,
                        &pStgmed->pUnkForRelease,
                        IID_IUnknown,
                        BufferSize,
                        FALSE );
        }

    if ( pStgmed->pUnkForRelease )
        {
        // Replace the app's punkForRelease with our custom release
        // handler for special situations.

        // The special situation is when a handle is remoted with data
        // and so we have to clean up a side effect of having a data copy
        // around. UserFree does it properly but we need that for the callee.
        // When the callee releases a stgmed, it would invoke
        // ReleaseStgMedium and this API doesn't do anything for handles
        // when the punkForRelease is not NULL.

        ULONG fHandleWithData = 0;
        ULONG fTopLevelOnly = 0;

        switch ( pStgmed->tymed )
            {
            case TYMED_HGLOBAL:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                break;

            case TYMED_ENHMF:
            case TYMED_GDI:
                fHandleWithData = GDI_DATA_PASSING( *pFlags );
                break;

            case TYMED_MFPICT:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                fTopLevelOnly   = fHandleWithData  &&
                                        ! GDI_DATA_PASSING( *pFlags );
                break;

            default:
                break;
            }

        if ( fHandleWithData )
            {
            IUnknown *
            punkTmp = (IUnknown *) new CPunkForRelease( pStgmed,
                                                        fTopLevelOnly );
            if (!punkTmp)
                {
                RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
                }

            pStgmed->pUnkForRelease = punkTmp;
            }
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of code out into a
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed )
{
    // Init buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = STGMEDIUM_UserUnmarshalWorker( pFlags,
                                             pBufferStart,
                                             pStgmed,
                                             BufferSize );
    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserFree
//
//  Synopsis:   Frees a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//  Note:       This routine is called from the freeing walk at server
//              or from the SetData *proxy*, when ownership has been passed.
//
//--------------------------------------------------------------------------

EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed )
{
    pStgmed->hGlobal = NULL;
    pStgmed->tymed = TYMED_NULL;

    if (pStgmed->pUnkForRelease)
        {
        pStgmed->pUnkForRelease->Release();
        pStgmed->pUnkForRelease = 0;
        }
}

void __RPC_USER
STGMEDIUM_UserFree(
    unsigned long * pFlags,
    STGMEDIUM * pStgmed )
{
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserFree: %s\n", WdtpGetStgmedName(pStgmed)));

    if( pStgmed )
        {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        switch ( pStgmed->tymed )
            {
            case TYMED_FILE:
                WdtpFree( pFlags, pStgmed->lpszFileName);
                NukeHandleAndReleasePunk( pStgmed );
                break;

            case TYMED_NULL:
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                ReleaseStgMedium( pStgmed );
                break;

            case TYMED_GDI:
            case TYMED_ENHMF:

                if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_HGLOBAL:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk ==0, this will just release the data.
                    // For punk !=0, this will go to our CPunk object,
                    // release the data, and then call the original punk.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_MFPICT:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    if ( pStgmed->pUnkForRelease )
                        {
                        pStgmed->pUnkForRelease->Release();
                        }
                    else
                        {
                        if ( pStgmed->hGlobal )
                            GlobalFree( pStgmed->hGlobal );
                        pStgmed->hGlobal = NULL;
                        pStgmed->tymed = TYMED_NULL;
                        }
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            default:
                RAISE_RPC_EXCEPTION( E_INVALIDARG );
                break;
            }
        }
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
FLAG_STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    Offset += 2 * sizeof(long);
    Offset  = STGMEDIUM_UserSize( pFlags, Offset, & pFlagStgmed->Stgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return pBuffer;

    ALIGN( pBuffer, 3 );

    // Flags: we need them when freeing in the client call_as routine

    pFlagStgmed->ContextFlags = *pFlags;

    *( PULONG_LV_CAST pBuffer)++ = *pFlags;
    *( PULONG_LV_CAST pBuffer)++ = pFlagStgmed->fPassOwnership;

    pBuffer = STGMEDIUM_UserMarshal( pFlags,
                                     pBuffer,
                                     & pFlagStgmed->Stgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();
    UCHAR*    pBufferPtr   = pBufferStart;

    // Align the buffer.
    ALIGN( pBufferPtr, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBufferPtr - pBufferStart);

    // BufferSize must not be less than the
    // alignment fixup + ContextFlags + fPassOwnership + tymed.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    // Flags and buffer marker

    pFlagStgmed->ContextFlags = *( PULONG_LV_CAST pBufferPtr)++;

    // Flags: we need them when freeing in the client call_as routine
    // We need that in the Proxy, when we call the user free routine.

    pFlagStgmed->fPassOwnership = *( PULONG_LV_CAST pBufferPtr)++;
    pFlagStgmed->ContextFlags   = *pFlags;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // Subtract alignment fixup + 2 DWORDs from BufferSize.
    BufferSize -= cbFixup + (2 * sizeof( ULONG ));

    pBuffer = STGMEDIUM_UserUnmarshalWorker( pFlags,
                                             pBufferPtr,
                                           & pFlagStgmed->Stgmed,
                                             BufferSize );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserFree
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
FLAG_STGMEDIUM_UserFree(
    unsigned long * pFlags,
    FLAG_STGMEDIUM* pFlagsStgmed )
{
    if ( ! pFlagsStgmed->fPassOwnership )
        STGMEDIUM_UserFree( pFlags, & pFlagsStgmed->Stgmed );

    // else the callee is supposed to release the stg medium.
}


//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//              May-97   Ryszardk      introduced the async flag to optimize
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
ASYNC_STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return Offset;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // BTW: This is needed only as a workaround because the [async] attr
    // has been temporarily removed from objidl.idl. (May 1997).
    // After we have the new [async] in place, this code is unnecessary
    // as the NDR engine is setting the same flag for every async call.

    *pFlags |= USER_CALL_IS_ASYNC;

    Offset  = STGMEDIUM_UserSize( pFlags, Offset, pAsyncStgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return pBuffer;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer = STGMEDIUM_UserMarshal( pFlags,
                                     pBuffer,
                                     pAsyncStgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer =  STGMEDIUM_UserUnmarshalWorker( pFlags,
                                              pBufferStart,
                                              pAsyncStgmed,
                                              BufferSize );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserFree
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
ASYNC_STGMEDIUM_UserFree(
    unsigned long * pFlags,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    STGMEDIUM_UserFree( pFlags, pAsyncStgmed );
}


#if defined(_WIN64)
//
// NDR64 Support routines.
//

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a stgmedium pbject for RPC marshalling.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    STGMEDIUM     * pStgmed )
{
    if ( ! pStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    // tymed is 4 bytes, plus 4 bytes padding, plus potentially the handle (8 bytes),
    // plus the pUnk.
    if ( pStgmed->tymed == TYMED_NULL )
        Offset += 4 + 4 + 8;                       // switch, pad, (empty arm), pUnk
    else
    {
        Offset += 4 + 4 + 8 + 8;                   // switch, pad, handle, pUnk

        // Pointee of the union arm.
        // Only if the handle/pointer field is non-null.
    
        if ( pStgmed->hGlobal )
        {
            SetContextFlagsForAsyncCall( pFlags, pStgmed );
            
            switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                Offset = HMETAFILEPICT_UserSize64( pFlags,
                                                   Offset,
                                                   &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                Offset = HENHMETAFILE_UserSize64( pFlags,
                                                  Offset,
                                                  &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:                
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                // 4 bytes for disc, plus 4 bytes pad, plus 8 bytes pointer?
                Offset += 4 + 4 + 8; 

                switch( GetObjectType( (HGDIOBJ)pStgmed->hBitmap ) )
                {
                case OBJ_BITMAP:
                    Offset = HBITMAP_UserSize64( pFlags,
                                                 Offset,
                                                 &pStgmed->hBitmap );
                    break;

                case OBJ_PAL:
                    Offset = HPALETTE_UserSize64( pFlags,
                                                  Offset,
                                                  (HPALETTE *) & pStgmed->hBitmap );
                    break;

                default:
                    RAISE_RPC_EXCEPTION(DV_E_TYMED);
                    break;
                }
                break;

            case TYMED_HGLOBAL:
                Offset = HGLOBAL_UserSize64( pFlags,
                                             Offset,
                                             &pStgmed->hGlobal );
                break;

            case TYMED_FILE:
                {           
                    ulong ulDataSize = 0;
                    if (pStgmed->lpszFileName)
                        ulDataSize = lstrlenW(pStgmed->lpszFileName) + 1;
                    Offset += 3 * 8; // max size, offset, conformance
                    Offset += ulDataSize * sizeof(wchar_t);
                }
                break;

            case TYMED_ISTREAM:
                Offset = WdtpInterfacePointer_UserSize64((USER_MARSHAL_CB *)pFlags,
                                                         *pFlags,
                                                         Offset,
                                                         pStgmed->pstm,
                                                         IID_IStream);
                break;

            case TYMED_ISTORAGE:
                Offset = WdtpInterfacePointer_UserSize64((USER_MARSHAL_CB *)pFlags,
                                                         *pFlags,
                                                         Offset,
                                                         pStgmed->pstg,
                                                         IID_IStorage);
                break;

            default:
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
                break;
            }
        }
    }

    // pUnkForRelease, if not null.

    if ( pStgmed->pUnkForRelease )
        Offset = WdtpInterfacePointer_UserSize64( (USER_MARSHAL_CB *)pFlags,
                                                  *pFlags,
                                                  Offset,
                                                  pStgmed->pUnkForRelease,
                                                  IID_IUnknown );
    
    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a stgmedium pbject for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    STGMEDIUM     * pStgmed )
{
    unsigned char * pBuffer;
    unsigned char * pUnionArmMark;
    DWORD tymed;

    if ( ! pStgmed )
        return pBufferStart;
    
    UserNdrDebugOut((
        UNDR_FORCE,
        "--STGMEDIUM_UserMarshal64: %s\n",
        WdtpGetStgmedName(pStgmed)));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 7 );

    // userSTGMEDIUM: switch, union arm, pUnk ptr.
    tymed = pStgmed->tymed;
    *( PULONG_LV_CAST pBuffer)++ = tymed;
    ALIGN( pBuffer, 7 );
    
    pUnionArmMark = pBuffer;
    if ( tymed != TYMED_NULL )
    {
        // hGlobal stands for any of these handles.        
      *(PHYPER_LV_CAST pBuffer)++ = (hyper)( pStgmed->hGlobal );
    }
    
    *(PHYPER_LV_CAST pBuffer)++ = (hyper)( pStgmed->pUnkForRelease );

    // Now the pointee of the union arm.
    // We need to marshal only if the handle/pointer field is non null.
    // Otherwise it is already in the buffer.
    if ( pStgmed->hGlobal )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );
        
        switch( pStgmed->tymed )
        {
        case TYMED_NULL:
            break;
            
        case TYMED_MFPICT:
            pBuffer = HMETAFILEPICT_UserMarshal64( pFlags,
                                                   pBuffer,
                                                   &pStgmed->hMetaFilePict );
            break;

        case TYMED_ENHMF:
            pBuffer = HENHMETAFILE_UserMarshal64( pFlags,
                                                  pBuffer,
                                                  &pStgmed->hEnhMetaFile );
            break;
            
        case TYMED_GDI:
            {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.

                ulong GdiObjectType = GetObjectType( (HGDIOBJ)pStgmed->hBitmap );

                // GDI_OBJECT
                *(PULONG_LV_CAST pBuffer)++ = GdiObjectType;
                ALIGN( pBuffer, 7 );
                *(PHYPER_LV_CAST pBuffer)++ = (hyper)(pStgmed->hBitmap);

                switch( GdiObjectType )
                {
                case OBJ_BITMAP:
                    pBuffer = HBITMAP_UserMarshal64( pFlags,
                                                     pBuffer,
                                                     &pStgmed->hBitmap );
                    break;

                case OBJ_PAL:
                    pBuffer = HPALETTE_UserMarshal64( pFlags,
                                                      pBuffer,
                                                      (HPALETTE *) & pStgmed->hBitmap );
                    break;
                    
                default:
                    RpcRaiseException(DV_E_TYMED);
                }
            }
            break;

        case TYMED_HGLOBAL:
            pBuffer = HGLOBAL_UserMarshal64( pFlags,
                                             pBuffer,
                                             &pStgmed->hGlobal );
            break;
        case TYMED_FILE:
            {
                // We marshal it as a [string].
                ulong Count = 0;
                if (pStgmed->lpszFileName)
                    Count = lstrlenW(pStgmed->lpszFileName) + 1;

                *( PHYPER_LV_CAST pBuffer)++ = Count;
                *( PHYPER_LV_CAST pBuffer)++ = 0;
                *( PHYPER_LV_CAST pBuffer)++ = Count;
                memcpy( pBuffer, pStgmed->lpszFileName, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
            }
            break;

        case TYMED_ISTREAM:
            pBuffer = WdtpInterfacePointer_UserMarshal64(((USER_MARSHAL_CB *)pFlags),
                                                         *pFlags,
                                                         pBuffer,
                                                         pStgmed->pstm,
                                                         IID_IStream);
            break;
            
        case TYMED_ISTORAGE:
            pBuffer = WdtpInterfacePointer_UserMarshal64(((USER_MARSHAL_CB *)pFlags),
                                                         *pFlags,
                                                         pBuffer,
                                                         pStgmed->pstg,
                                                         IID_IStorage);
            break;

        default:
            RpcRaiseException(DV_E_TYMED);
            break;
        }
    }

    // Marker for this pointer is already in the buffer.
    if ( pStgmed->pUnkForRelease )
        pBuffer = WdtpInterfacePointer_UserMarshal64( ((USER_MARSHAL_CB *)pFlags),
                                                      *pFlags,
                                                      pBuffer,
                                                      pStgmed->pUnkForRelease,
                                                      IID_IUnknown );
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshalWorker64
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshalWorker64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed,
    ULONG_PTR       BufferSize )
{
    CarefulBufferReader stream(pBuffer, BufferSize);
    LONG_PTR        fUnkForRelease;
    LONG_PTR        Handle = 0;
    unsigned char  *mark = NULL;

    // Align the buffer and save the fixup size.
    stream.Align(8);

    // switch, union arm, pUnk.
    pStgmed->tymed = stream.ReadULONGNA();
    
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal64: %s\n",
                     WdtpGetStgmedName(pStgmed) ));

    // (Force the align here so we only align once)
    stream.Align(8);
    if ( pStgmed->tymed != TYMED_NULL )
    {
        // This value is just a marker for the handle - a long.
        Handle = stream.ReadHYPERNA();
    }
    
    // pUnkForRelease pointer marker.
    fUnkForRelease = stream.ReadHYPERNA();

    // First pointee

    // Union arm pointee.
    // We need to unmarshal only if the handle/pointer field was not NULL.
    if ( Handle )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );

        hyper* pBuf = (hyper*)stream.GetBuffer();

        switch( pStgmed->tymed )
        {
        case TYMED_NULL:
            break;

        case TYMED_MFPICT:            
            // validate the handle...
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

            mark = HMETAFILEPICT_UserUnmarshalWorker64 (pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->hMetaFilePict,
                                                        stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;

        case TYMED_ENHMF:
            // validate the handle...
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );            

            mark = HENHMETAFILE_UserUnmarshalWorker64 ( pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->hEnhMetaFile,
                                                        stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;

        case TYMED_GDI:
            {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we
                // handle those types we know about based on the object type,
                // and reject those which we do not support.
                
                DWORD GdiObjectType = stream.ReadULONGNA();
                Handle = stream.ReadHYPER();

                switch( GdiObjectType )
                {
                case OBJ_BITMAP:
                    // Lookahead validation of the handle. 
                    stream.CheckSize( 4 + 4 + 8 );
                    pBuf = (hyper*)stream.GetBuffer();
                    if ( Handle != pBuf[1] )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    mark = HBITMAP_UserUnmarshalWorker64( pFlags,
                                                          stream.GetBuffer(),
                                                          &pStgmed->hBitmap,
                                                          stream.BytesRemaining() );
                    stream.AdvanceTo(mark);
                    break;

                case OBJ_PAL:
                    // Lookahead validaton of the handle.
                    stream.CheckSize( 4 + 4 + 8 );
                    pBuf = (hyper*)stream.GetBuffer();
                    if ( Handle != pBuf[1] )
                        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                    mark = HPALETTE_UserUnmarshalWorker64( pFlags,
                                                           stream.GetBuffer(),
                                                           (HPALETTE *) & pStgmed->hBitmap,
                                                           stream.BytesRemaining() );
                    stream.AdvanceTo(mark);
                    break;
                    
                default:
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                }
            }
            break;

        case TYMED_HGLOBAL:
            // reallocation is forbidden for [in-out] hglobal in STGMEDIUM.
            // validate the handle.
            stream.CheckSize( 4 + 4 + 8 ); // enc. union: 4b switch + 4b pad + 8b handle            
            
            if ( Handle != pBuf[1] )
                RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            
            mark = WdtpGlobalUnmarshal64( pFlags,
                                          stream.GetBuffer(),
                                          & pStgmed->hGlobal,
                                          FALSE,
                                          stream.BytesRemaining() );
            stream.AdvanceTo(mark);
            break;
        
        case TYMED_FILE:
            {
                // Must be room in buffer for header.
                ulong Count = (ulong)stream.ReadHYPERNA();

                // We marshal it as a [string].
                if ( stream.ReadHYPERNA() != 0 )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
                if ( stream.ReadHYPERNA() != Count )
                    RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

                if ( ! pStgmed->lpszFileName )
                    pStgmed->lpszFileName = (LPOLESTR) WdtpAllocate( pFlags, Count * sizeof(wchar_t) );

                // Must be room in the buffer for the string.
                stream.CheckSize( Count * sizeof(WCHAR) );
                memcpy(pStgmed->lpszFileName, 
                       stream.GetBuffer(), 
                       Count * sizeof(wchar_t));
                stream.Advance( Count * sizeof(WCHAR) );
            }
            break;

        case TYMED_ISTREAM:
            mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                            stream.GetBuffer(),
                                                            (IUnknown **) &pStgmed->pstm,
                                                            IID_IStream,
                                                            stream.BytesRemaining(),
                                                            TRUE);
            stream.AdvanceTo(mark);
            break;

        case TYMED_ISTORAGE:
            mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                            stream.GetBuffer(),
                                                            (IUnknown **) &pStgmed->pstg,
                                                            IID_IStorage,
                                                            stream.BytesRemaining(),
                                                            TRUE);
            stream.AdvanceTo(mark);
            break;

        default:
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );
            break;
        }
    }
    else
    {
        // New handle/pointer field is null, so release the previous one
        // if it wasn't null.

        if ( pStgmed->hGlobal )
        {
            // This should never happen for GetDataHere.
            
            // Note, that we release the handle field, not the stgmedium itself.
            // Accordingly, we don't follow punkForRelease.            
            UserNdrDebugOut((
                  UNDR_FORCE,
                  "--STGMEDIUM_UserUnmarshal64: %s: NULL in, freeing old one\n",
                  WdtpGetStgmedName(pStgmed)));

            STGMEDIUM  TmpStg = *pStgmed;
            TmpStg.pUnkForRelease = NULL;
            
            if ( pStgmed->tymed == TYMED_HGLOBAL )
            {
                // Cannot reallocate.
                RAISE_RPC_EXCEPTION(DV_E_TYMED);
            }
            else
            {
                ReleaseStgMedium( &TmpStg );
            }
        }
        
        pStgmed->hGlobal = 0;
    }

    if ( fUnkForRelease )
    {
        // There is an interface pointer on the wire.
        mark = WdtpInterfacePointer_UserUnmarshalWorker((USER_MARSHAL_CB *)pFlags,
                                                        stream.GetBuffer(),
                                                        &pStgmed->pUnkForRelease,
                                                        IID_IUnknown,
                                                        stream.BytesRemaining(),
                                                        TRUE);
        stream.AdvanceTo(mark);
    }

    if ( pStgmed->pUnkForRelease )
    {
        // Replace the app's punkForRelease with our custom release
        // handler for special situations.

        // The special situation is when a handle is remoted with data
        // and so we have to clean up a side effect of having a data copy
        // around. UserFree does it properly but we need that for the callee.
        // When the callee releases a stgmed, it would invoke
        // ReleaseStgMedium and this API doesn't do anything for handles
        // when the punkForRelease is not NULL.
        ULONG fHandleWithData = 0;
        ULONG fTopLevelOnly = 0;

        switch ( pStgmed->tymed )
        {
        case TYMED_HGLOBAL:
            fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
            break;
            
        case TYMED_ENHMF:
        case TYMED_GDI:
            fHandleWithData = GDI_DATA_PASSING( *pFlags );
            break;
            
        case TYMED_MFPICT:
            fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
            fTopLevelOnly   = fHandleWithData  && !GDI_DATA_PASSING( *pFlags );
            break;
            
        default:
            break;
        }

        if ( fHandleWithData )
        {
            IUnknown *
                punkTmp = (IUnknown *) new CPunkForRelease( pStgmed,
                                                            fTopLevelOnly );
            if (!punkTmp)
            {
                RAISE_RPC_EXCEPTION(E_OUTOFMEMORY);
            }

            pStgmed->pUnkForRelease = punkTmp;
        }
    }

    return( stream.GetBuffer() );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed )
{
    // Init buffer size and ptr to buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    pBuffer = STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                               pBufferStart,
                                               pStgmed,
                                               BufferSize );
    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserFree64
//
//  Synopsis:   Frees a stgmedium object for RPC.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//  Note:       This routine is called from the freeing walk at server
//              or from the SetData *proxy*, when ownership has been passed.
//
//--------------------------------------------------------------------------

void __RPC_USER
STGMEDIUM_UserFree64 (
    unsigned long * pFlags,
    STGMEDIUM * pStgmed )
{
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserFree64: %s\n", WdtpGetStgmedName(pStgmed)));

    if( pStgmed )
    {
        SetContextFlagsForAsyncCall( pFlags, pStgmed );
        
        switch ( pStgmed->tymed )
        {
        case TYMED_FILE:
            WdtpFree( pFlags, pStgmed->lpszFileName);
            NukeHandleAndReleasePunk( pStgmed );
            break;
            
        case TYMED_NULL:
        case TYMED_ISTREAM:
        case TYMED_ISTORAGE:
            ReleaseStgMedium( pStgmed );
            break;
            
        case TYMED_GDI:
        case TYMED_ENHMF:
            
            if ( GDI_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk !=0, this will go to our CPunk object.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        case TYMED_HGLOBAL:
            
            if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk ==0, this will just release the data.
                // For punk !=0, this will go to our CPunk object,
                // release the data, and then call the original punk.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        case TYMED_MFPICT:
            
            if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            {
                NukeHandleAndReleasePunk( pStgmed );
            }
            else if ( GDI_HANDLE_PASSING(*pFlags) )
            {
                if ( pStgmed->pUnkForRelease )
                {
                    pStgmed->pUnkForRelease->Release();
                }
                else
                {
                    if ( pStgmed->hGlobal )
                        GlobalFree( pStgmed->hGlobal );
                    pStgmed->hGlobal = NULL;
                    pStgmed->tymed = TYMED_NULL;
                }
            }
            else
            {
                // Handle w/data: there is a side effect to clean up.
                // For punk !=0, this will go to our CPunk object.
                
                ReleaseStgMedium( pStgmed );
            }
            break;
            
        default:
            RAISE_RPC_EXCEPTION( E_INVALIDARG );
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
FLAG_STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 7 );

    Offset += 2 * sizeof(long);
    Offset  = STGMEDIUM_UserSize64 ( pFlags, Offset, & pFlagStgmed->Stgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return pBuffer;

    ALIGN( pBuffer, 7 );

    // Flags: we need them when freeing in the client call_as routine

    pFlagStgmed->ContextFlags = *pFlags;

    *( PULONG_LV_CAST pBuffer)++ = *pFlags;
    *( PULONG_LV_CAST pBuffer)++ = pFlagStgmed->fPassOwnership;

    pBuffer = STGMEDIUM_UserMarshal64( pFlags,
                                       pBuffer,
                                       & pFlagStgmed->Stgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    CarefulBufferReader stream(pBuffer, MarshalInfo.GetBufferSize());


    // Align the buffer.
    stream.Align(8);
    
    // Flags and buffer marker
    pFlagStgmed->ContextFlags = stream.ReadULONGNA();

    // Flags: we need them when freeing in the client call_as routine
    // We need that in the Proxy, when we call the user free routine.
    pFlagStgmed->fPassOwnership = stream.ReadULONGNA();
    pFlagStgmed->ContextFlags   = *pFlags;

    pBuffer = STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                               stream.GetBuffer(),
                                               & pFlagStgmed->Stgmed,
                                               stream.BytesRemaining() );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserFree64
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

void __RPC_USER
FLAG_STGMEDIUM_UserFree64 (
    unsigned long * pFlags,
    FLAG_STGMEDIUM* pFlagsStgmed )
{
    if ( ! pFlagsStgmed->fPassOwnership )
        STGMEDIUM_UserFree64 ( pFlags, & pFlagsStgmed->Stgmed );

    // else the callee is supposed to release the stg medium.
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserSize64
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
ASYNC_STGMEDIUM_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return Offset;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    // BTW: This is needed only as a workaround because the [async] attr
    // has been temporarily removed from objidl.idl. (May 1997).
    // After we have the new [async] in place, this code is unnecessary
    // as the NDR engine is setting the same flag for every async call.

    *pFlags |= USER_CALL_IS_ASYNC;

    Offset  = STGMEDIUM_UserSize64 ( pFlags, Offset, pAsyncStgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserMarshal64
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    if ( ! pAsyncStgmed )
        return pBuffer;

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer = STGMEDIUM_UserMarshal64( pFlags,
                                       pBuffer,
                                       pAsyncStgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserUnmarshal64
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
ASYNC_STGMEDIUM_UserUnmarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Init buffer size.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    pBuffer =  STGMEDIUM_UserUnmarshalWorker64( pFlags,
                                                pBufferStart,
                                                pAsyncStgmed,
                                                BufferSize );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   ASYNC_STGMEDIUM_UserFree64
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    Dec-00   JohnDoty      Created based on 32b function.
//
//--------------------------------------------------------------------------

void __RPC_USER
ASYNC_STGMEDIUM_UserFree64(
    unsigned long * pFlags,
    ASYNC_STGMEDIUM* pAsyncStgmed )
{
    // Needed to handle both GDI handles and Istream/IStorage correctly.

    *pFlags |= USER_CALL_IS_ASYNC;

    STGMEDIUM_UserFree64( pFlags, pAsyncStgmed );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\chicago\prop_x.c ===
//+===================================================================
//
//   This file is a wrapper for prop_p.c (which is generated by MIDL
//   from ..\..\idl\prop.idl).
//
//   Prop_p.c makes references to wire-marshal routines that are
//   provided by oleaut32.dll.  But we can't (for performance
//   reasons) link ole32.dll directly to oleaut32, we do it
//   lazily.  So in this file, we use #defines to map
//   the wire-marshal routines called by prop_p.c so that
//   they are actually calls to "Load*" wrappers.  These
//   wrappers load oleaut32.dll, do a GetProcAddr, and
//   then make the actual call.
//
//+===================================================================

#include "prop.h"
#include <privoa.h>

#define BSTR_UserSize        LoadBSTR_UserSize
#define BSTR_UserMarshal     LoadBSTR_UserMarshal
#define BSTR_UserUnmarshal   LoadBSTR_UserUnmarshal
#define BSTR_UserFree        LoadBSTR_UserFree

#define LPSAFEARRAY_UserSize        LoadLPSAFEARRAY_UserSize
#define LPSAFEARRAY_UserMarshal     LoadLPSAFEARRAY_UserMarshal
#define LPSAFEARRAY_UserUnmarshal   LoadLPSAFEARRAY_UserUnmarshal
#define LPSAFEARRAY_UserFree        LoadLPSAFEARRAY_UserFree

#include "prop_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\transmit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transmit.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//  Functions:  
//              HBRUSH_UserSize
//              HBRUSH_UserMarshal
//              HBRUSH_UserUnmarshal
//              HBRUSH_UserFree
//              HACCEL_UserSize
//              HACCEL_UserMarshal
//              HACCEL_UserUnmarshal
//              HACCEL_UserFree
//              HWND_UserSize
//              HWND_UserMarshal
//              HWND_UserUnmarshal
//              HWND_UserFree
//              HMENU_UserSize
//              HMENU_UserMarshal
//              HMENU_UserUnmarshal
//              HMENU_UserFree
//              HICON_User*
//              HDC_UserSize
//              HDC_UserMarshal
//              HDC_UserUnmarshal
//              HDC_UserFree
//
//  History:    24-Aug-93   ShannonC    Created
//              24-Nov-93   ShannonC    Added HGLOBAL
//              14-May-94   DavePl      Added HENHMETAFILE
//              18-May-94   ShannonC    Added HACCEL, UINT, WPARAM
//              19-May-94   DavePl      Added HENHMETAFILE to STGMEDIUM code
//                 May-95   Ryszardk    Wrote all the _User* routines
//                 Feb-96   Ryszardk    Added CLIPFORMAT support
//              25-Jun-99   a-olegi     Added HDC code
//              14-Dec-00   JohnDoty    Because the size of the code nearly
//                                      doubled for NDR64, factored out the
//                                      involved routines to seperate files.
//                                      see:
//                                         clipformat.cxx
//                                         bitmap.cxx
//                                         hpalette.cxx
//                                         metafile.cxx
//                                         snb.cxx
//                                         hglobal.cxx
//                                         stgmedium.cxx
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.hxx"
#include <rpcwdt.h>
#include <storext.h>
#include "widewrap.h"
#include <valid.h>
#include <obase.h>
#include <stream.hxx>


WINOLEAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pStgMed);

#pragma code_seg(".orpc")

EXTERN_C const CLSID CLSID_MyPSFactoryBuffer = {0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}};

// Used to detect if the channel is a CRpcChannelBuffer object
extern const IID IID_CPPRpcChannelBuffer;

class CRpcChannelBuffer;

extern HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid);


// These methods are needed as the object is used for interface marshaling.

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::AddRef( THIS )
{
  return ref_count += 1;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Clone(THIS_ IStream * *ppstm)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Commit(THIS_ DWORD grfCommitFlags)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::CopyTo(THIS_ IStream *pstm,
                  ULARGE_INTEGER cb,
                  ULARGE_INTEGER *pcbRead,
                  ULARGE_INTEGER *pcbWritten)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
CStreamOnMessage::CStreamOnMessage(unsigned char **ppMessageBuffer)
    : ref_count(1), ppBuffer(ppMessageBuffer), cbMaxStreamLength(0xFFFFFFFF)
{
    pStartOfStream = *ppMessageBuffer;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::LockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown))
  {
    *ppvObj = (IUnknown *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else if (IsEqualIID(riid, IID_IStream))
  {
    *ppvObj = (IStream *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else
    return ResultFromScode(E_NOINTERFACE);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Read(THIS_ VOID HUGEP *pv,
                  ULONG cb, ULONG *pcbRead)
{
  memcpy( pv, *ppBuffer, cb );
  *ppBuffer += cb;
  if (pcbRead != NULL)
    *pcbRead = cb;
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::Release( THIS )
{
  ref_count -= 1;
  if (ref_count == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;

}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Revert(THIS)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Seek(THIS_ LARGE_INTEGER dlibMove,
                  DWORD dwOrigin,
                  ULARGE_INTEGER *plibNewPosition)
{
  ULONG   pos;

  // Verify that the offset isn't out of range.
  if (dlibMove.HighPart != 0)
    return ResultFromScode( E_FAIL );

  // Determine the new seek pointer.
  switch (dwOrigin)
  {
    case STREAM_SEEK_SET:
      pos = dlibMove.LowPart;
      break;

    case STREAM_SEEK_CUR:
      /* Must use signed math here. */
      pos = (ULONG) (*ppBuffer - pStartOfStream);
      if ((long) dlibMove.LowPart < 0 &&
      pos < (unsigned long) - (long) dlibMove.LowPart)
    return ResultFromScode( E_FAIL );
      pos += (long) dlibMove.LowPart;
      break;

    case STREAM_SEEK_END:
        return ResultFromScode(E_NOTIMPL);
    break;

    default:
      return ResultFromScode( E_FAIL );
  }

  // Set the seek pointer.
  *ppBuffer = pStartOfStream + pos;
  if (plibNewPosition != NULL)
  {
    plibNewPosition->LowPart = pos;
    plibNewPosition->HighPart = 0;
  }
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Stat(THIS_ STATSTG *pstatstg, DWORD grfStatFlag)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Write(THIS_ VOID const HUGEP *pv,
                  ULONG cb,
                  ULONG *pcbWritten)
{
  // Write the data.
  memcpy( *ppBuffer, pv, cb );
  if (pcbWritten != NULL)
    *pcbWritten = cb;
  *ppBuffer += cb;
  return ResultFromScode(S_OK);
}



// #########################################################################
//
//  WdtpRemotableHandle helper
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserSize
//
//  Synopsis:   Sizes a void star handle as a union with a long.
//              Handle size may be 8 bytes but on wire it is still a long.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
WdtpRemotableHandle_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    LONG_PTR      * pHandle )
{
    if ( !pHandle )
        return Offset;

    if ( *pHandle && DIFFERENT_MACHINE_CALL(*pFlags) )
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

    LENGTH_ALIGN( Offset, 3 );

    // 4 bytes for discriminator, 4 bytes for the long.
    return( Offset + 8 ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserMarshall
//
//  Synopsis:   Marshalls a handle as a union with a long.
//              We represent a GDI or USER handle, which may be 4 or 8 bytes,
//              as a long on wire.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpRemotableHandle_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    LONG_PTR      * pHandle )
{
    if ( !pHandle )
        return pBuffer;

    if ( *pHandle && DIFFERENT_MACHINE_CALL(*pFlags) )
        RpcRaiseException( RPC_S_INVALID_TAG );

    ALIGN( pBuffer, 3 );

    *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
    *( PLONG_LV_CAST pBuffer)++ = (long)*pHandle;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserUnmarshall
//
//  Synopsis:   Unmarshalls a remotable void star as union with ulong.
//              Handle is represented as a long on wire.
//              On 64b platforms, we sign extended it to 8 bytes to get
//              the proper USER or GDI handle representation.
//
//  history:    Dec-95   Ryszardk      Created.
//              Dec-98   Ryszardk      Ported to 64b.
//              Aug-99   JohnStra      Added consistency checks.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpRemotableHandle_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    LONG_PTR      * pHandle )
{
    unsigned long HandleMarker;

    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( pFlags, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Align the buffer and save fixup size.
    ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing data.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + (2 * sizeof( ULONG )) );

    HandleMarker = *( PULONG_LV_CAST pBuffer)++;

    if ( HandleMarker == WDT_HANDLE_MARKER )
        *pHandle = *( PLONG_LV_CAST pBuffer)++;
    else
        RAISE_RPC_EXCEPTION( RPC_S_INVALID_TAG );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpRemotableHandle_UserFree
//
//--------------------------------------------------------------------------

void __RPC_USER
WdtpRemotableHandle_UserFree(
    unsigned long * pFlags,
    LONG_PTR * pHandle )
{
}

//+-------------------------------------------------------------------------

//
//  Function:   HWND_UserSize
//
//  Synopsis:   Sizes an HWND handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HWND_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserMarshall
//
//  Synopsis:   Marshalls an HWND handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HWND handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserFree
//
//  Synopsis:   Shouldn't be called.
//
//--------------------------------------------------------------------------

void __RPC_USER
HWND_UserFree(
    unsigned long * pFlags,
    HWND          * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserSize
//
//  Synopsis:   Sizes an HMENU handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMENU_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserMarshall
//
//  Synopsis:   Marshalls an HMENU handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HMENU handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserFree
//
//  Synopsis:   Free an HMENU.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMENU_UserFree(
    unsigned long * pFlags,
    HMENU         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserSize
//
//  Synopsis:   Sizes an HACCEL handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HACCEL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserMarshall
//
//  Synopsis:   Marshalls an HACCEL handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HACCEL handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserFree
//
//  Synopsis:   Free an HACCEL.
//
//--------------------------------------------------------------------------

void __RPC_USER
HACCEL_UserFree(
    unsigned long * pFlags,
    HACCEL        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserSize
//
//  Synopsis:   Sizes an HBRUSH handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBRUSH_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserMarshall
//
//  Synopsis:   Marshalls an HBRUSH handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBRUSH handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserFree
//
//  Synopsis:   Free an HBRUSH.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBRUSH_UserFree(
    unsigned long * pFlags,
    HBRUSH        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserSize
//
//  Synopsis:   Sizes an HICON handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HICON_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserFree
//
//  Synopsis:   Free an HICON.
//
//--------------------------------------------------------------------------

void __RPC_USER
HICON_UserFree(
    unsigned long * pFlags,
    HICON         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserSize
//
//  Synopsis:   Sizes an HDC handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HDC_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserFree
//
//  Synopsis:   Free an HDC.
//
//--------------------------------------------------------------------------

void __RPC_USER
HDC_UserFree(
    unsigned long * pFlags,
    HDC           * pH )
{
}


// #########################################################################
//
//  Interface pointers.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserSize
//
//  Synopsis:   Get the wire size for an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned long  __RPC_USER __stdcall
WdtpInterfacePointer_UserSize (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned long       Offset,
    IUnknown          * pIf,
    const IID &         IId )
{
    if ( pIf )
        {
        LENGTH_ALIGN( Offset, 3 );

        //Leave space for array bounds and length

        Offset += 2 * sizeof(long);

        HRESULT         hr;
        unsigned long   cbSize = 0;

        hr = CoGetMarshalSizeMax( &cbSize,
                                  IId,
                                  pIf,
                                  USER_CALL_CTXT_MASK( Flags ),
                                  pContext->pStubMsg->pvDestContext,
                                  MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        Offset += cbSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserMarshal
//
//  Synopsis:   Marshalls an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserMarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned char     * pBuffer,
    IUnknown          * pIf,
    const IID &         IId )
{
    unsigned long * pMaxCount, *pSize;
    unsigned long   cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterface_PointerMarshal\n"));

    if ( pIf )
        {
        // Always marshaled because of the apartment model.

        CStreamOnMessage MemStream( (unsigned char **) &pBuffer );

        ALIGN( pBuffer, 3 );

        pMaxCount = (unsigned long *) pBuffer;
        pBuffer += 4;

        // Leave space for length

        pSize = (unsigned long *) pBuffer;
        pBuffer += 4;

        HRESULT  hr;
        unsigned char * pBufferMark = pBuffer;

        hr = CoMarshalInterface( &MemStream,
                                 IId,
                                 pIf,
                                 USER_CALL_CTXT_MASK( Flags ),
                                 pContext->pStubMsg->pvDestContext,
                                 MSHLFLAGS_NORMAL );
        if( FAILED(hr) )
            {
            RpcRaiseException(hr);
            }

        // Calculate the size of the data written

        DWORD cbData = (ULONG) (pBuffer - pBufferMark);

        // Update the array bounds.

        *pMaxCount = cbData;
        *pSize = cbData;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshalWorker
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    Aug-99   JohnStra      Created.
//              Oct-00   ScottRob/
//                       YongQu        NDR64 Support.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpInterfacePointer_UserUnmarshalWorker (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId,
    ULONG_PTR           BufferSize,
    BOOL fNDR64 )
{
    unsigned long      *pMaxCount, *pSize;
    unsigned long       cbData = 0;

    // Align the buffer and save the fixup size.
    UCHAR* pBufferStart = pBuffer;
    if (fNDR64) ALIGN(pBuffer, 7); else ALIGN( pBuffer, 3 );
    ULONG_PTR cbFixup = (ULONG_PTR)(pBuffer - pBufferStart);

    // Check for EOB before accessing data.
    int cbHeader = (int)((fNDR64) ? 3*sizeof( ULONG ) : 2*sizeof( ULONG ));

    CHECK_BUFFER_SIZE( BufferSize, cbFixup + cbHeader + 2*sizeof( ULONG ) + sizeof( GUID ) );
    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointerUnmarshal\n"));

    pMaxCount = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    if (fNDR64) pBuffer += sizeof(long);  //NDR64 Padding

    //Unmarshal count
    pSize = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    // max count and unmarshal count must be the same.
    if ( *pSize != *pMaxCount )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Get IID from the OBJREF and verify that it matches the supplied IID.
    IID* piid;
    if( FAILED( GetIIDFromObjRef( *(OBJREF *)pBuffer, &piid ) ) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    if( 0 != memcmp( &IId, piid, sizeof(IID) ) )
        RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

    // Check for EOB before unmarshaling.
    CHECK_BUFFER_SIZE( BufferSize, cbFixup + cbHeader + *pSize );

    // Release the old pointer after unmarshalling the new one
    // to prevent object from getting released too early.
    // Then release the old one only when successful.

    IUnknown * punkTemp = 0;

//CodeReview: The original code
// CNdrStream MemStream( pBuffer,
//               (ULONG) BufferSize + (2 * sizeof(ULONG)) + *pSize );
// Doesn't look right... We just verified that BufferSize was large enough to
// hold the data. Then we tell the CNdrStream that the size of buffer is double
// that size when we should be only unmarshaling pSize bytes.
// Is this to prevent CoUnmarshalInterface from running up against the end of a corrupted stream?

    // Use a CNdrStream for unmarshaling because it checks for buffer overruns.
    CNdrStream MemStream( pBuffer,
                  (ULONG) *pSize );

    HRESULT hr = CoUnmarshalInterface( &MemStream,
                                       IId,
                                       (void **) &punkTemp );
    if(FAILED(hr))
        {
        RAISE_RPC_EXCEPTION(hr);
        }
    else
        {
        // Get the number of bytes read from the stream.
        LARGE_INTEGER lOffset = { 0, 0 };
        ULARGE_INTEGER ulCurPos;
        hr = MemStream.Seek( lOffset, STREAM_SEEK_CUR, &ulCurPos );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        // Make sure the number of bytes read is what we expected.
        if ( ulCurPos.LowPart != *pSize )
            RAISE_RPC_EXCEPTION( RPC_X_BAD_STUB_DATA );

        // Increment pBuffer pointer by the amount we unmarshaled from it.
        pBuffer += ulCurPos.LowPart;

        // On the client side, release the [in,out] interface pointer.
        // The pointer may be different from NULL only on the client side.

        // release the old one, keep the new one.

        if ( *ppIf )
            (*ppIf)->Release();
        *ppIf = punkTemp;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshal
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//              Aug-99   JohnStra      Factored bulk of work out into
//                                     worker routine in order to add
//                                     consistency checks.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserUnmarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId )
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( (ULONG*)pContext, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Delegate to worker routine.
    pBuffer = WdtpInterfacePointer_UserUnmarshalWorker( pContext,
                                                        pBufferStart,
                                                        ppIf,
                                                        IId,
                                                        BufferSize,
                                                        FALSE );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserFree
//
//  Synopsis:   Releases an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

EXTERN_C void __RPC_USER __stdcall
WdtpInterfacePointer_UserFree(
    IUnknown      * pIf )
{
    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointer_UserFree\n"));

    if( pIf )
        {
        pIf->Release();
        }
}




#if (DBG==1)
//+-------------------------------------------------------------------------
//
//  Function:   WdtpGetStgmedName
//
//  Synopsis:   Debug support
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

char *
WdtpGetStgmedName( STGMEDIUM * pStgmed)

{
    char * Name;
    if ( pStgmed )
        {
        switch (pStgmed->tymed)
            {
            case TYMED_NULL:
                Name = "TYMED_NULL";
                break;
            case TYMED_MFPICT:
                Name = "TYMED_MFPICT";
                break;
            case TYMED_ENHMF:
                Name = "TYMED_ENHMF";
                break;
            case TYMED_GDI:
                Name = "TYMED_GDI";
                break;
            case TYMED_HGLOBAL:
                Name = "TYMED_HGLOBAL";
                break;
            case TYMED_FILE:
                Name = "TYMED_FILE";
                break;
            case TYMED_ISTREAM:
                Name = "TYMED_ISTREAM";
                break;
            case TYMED_ISTORAGE:
                Name = "TYMED_ISTORAGE";
                break;
            default:
                Name = "TYMED invalid";
                break;
            }
        return Name;
        }
    else
        return "STGMED * is null";
}
#endif

//+-------------------------------------------------------------------------
//
//  Class:      CContinue
//
//  Synopsis:   Notification object
//
//--------------------------------------------------------------------------
class CContinue : public IContinue
{
private:
    long _cRef;
    BOOL (__stdcall *_pfnContinue)(LONG_PTR);
    LONG_PTR _dwContinue;
    ~CContinue(void);

public:
    CContinue(BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue), LONG_PTR dwContinue);

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE FContinue();
};




//+-------------------------------------------------------------------------
//
//  Method:     CContinue::CContinue, public
//
//  Synopsis:   Constructor for CContinue
//
//--------------------------------------------------------------------------
CContinue::CContinue(BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue), LONG_PTR dwContinue)
: _cRef(1), _pfnContinue(pfnContinue), _dwContinue(dwContinue)
{
}

CContinue::~CContinue()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::QueryInterface, public
//
//  Synopsis:   Query for an interface on the notification object.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CContinue::QueryInterface (
    REFIID iid,
    void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if ((IID_IUnknown == iid) || (IID_IContinue == iid))
    {
        this->AddRef();
        *ppv = (IContinue *) this;
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::AddRef, public
//
//  Synopsis:   Increment the reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CContinue::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return (unsigned long) _cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CContinue::Release, public
//
//  Synopsis:   Decrement the reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CContinue::Release()
{
    unsigned long count = _cRef - 1;

    if(0 == InterlockedDecrement((long *)&_cRef))
    {
        count = 0;
        delete this;
    }

    return count;
}


//+-------------------------------------------------------------------------
//
//  Method:     CContinue::FContinue, public
//
//  Synopsis:   Calls the callback function.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CContinue::FContinue()
{
    HRESULT hr;
    BOOL bResult;

    bResult = (*_pfnContinue) (_dwContinue);

    if(bResult == FALSE)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateCallback
//
//  Synopsis:   Create a callback notification object .
//
//--------------------------------------------------------------------------
extern "C" HRESULT CreateCallback(
    BOOL (__stdcall *pfnContinue)(LONG_PTR dwContinue),
    LONG_PTR dwContinue,
    IContinue **ppContinue)
{
    HRESULT hr;

    if(pfnContinue != 0)
    {
        CContinue *pContinue = new CContinue(pfnContinue, dwContinue);

        *ppContinue = (IContinue *) pContinue;

        if(pContinue != 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        *ppContinue = 0;
    }

    return hr;
}

////// NDR64 funcs
#ifdef _WIN64

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserSize
//
//  Synopsis:   Sizes an HWND handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HWND_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserMarshall
//
//  Synopsis:   Marshalls an HWND handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return HWND_UserMarshal( pFlags, pBuffer, pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HWND handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserFree
//
//  Synopsis:   Shouldn't be called.
//
//--------------------------------------------------------------------------

void __RPC_USER
HWND_UserFree64(
    unsigned long * pFlags,
    HWND          * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserSize
//
//  Synopsis:   Sizes an HMENU handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMENU_UserSize64(
    unsigned long * pFlags,
    unsigned long   Offset,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserMarshall
//
//  Synopsis:   Marshalls an HMENU handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserMarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HMENU handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserUnmarshal64(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserFree
//
//  Synopsis:   Free an HMENU.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMENU_UserFree64(
    unsigned long * pFlags,
    HMENU         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserSize
//
//  Synopsis:   Sizes an HACCEL handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HACCEL_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserMarshall
//
//  Synopsis:   Marshalls an HACCEL handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HACCEL handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserFree
//
//  Synopsis:   Free an HACCEL.
//
//--------------------------------------------------------------------------

void __RPC_USER
HACCEL_UserFree64(
    unsigned long * pFlags,
    HACCEL        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserSize
//
//  Synopsis:   Sizes an HBRUSH handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBRUSH_UserSize64(
    unsigned long * pFlags,
    unsigned long   Offset,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserMarshall
//
//  Synopsis:   Marshalls an HBRUSH handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBRUSH handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserFree
//
//  Synopsis:   Free an HBRUSH.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBRUSH_UserFree64(
    unsigned long * pFlags,
    HBRUSH        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserSize
//
//  Synopsis:   Sizes an HICON handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HICON_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HICON_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HICON         * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HICON_UserFree
//
//  Synopsis:   Free an HICON.
//
//--------------------------------------------------------------------------

void __RPC_USER
HICON_UserFree64(
    unsigned long * pFlags,
    HICON         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserSize
//
//  Synopsis:   Sizes an HDC handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HDC_UserSize64 (
    unsigned long * pFlags,
    unsigned long   Offset,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserSize( pFlags, Offset, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserMarshall
//
//  Synopsis:   Marshalls an HICON handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserMarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserMarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HICON handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HDC_UserUnmarshal64 (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HDC           * pH )
{
    return WdtpRemotableHandle_UserUnmarshal( pFlags, pBuffer, (LONG_PTR*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HDC_UserFree
//
//  Synopsis:   Free an HDC.
//
//--------------------------------------------------------------------------

void __RPC_USER
HDC_UserFree64(
    unsigned long * pFlags,
    HDC           * pH )
{
}


// #########################################################################
//
//  Interface pointers.
//
// #########################################################################


//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserSize64
//
//  Synopsis:   Get the wire size for an interface pointer.
//
//  history:    Oct-00  ScottRob/
//                      YongQu         Created for NDR64 Support
//
//--------------------------------------------------------------------------
EXTERN_C unsigned long  __RPC_USER __stdcall
WdtpInterfacePointer_UserSize64 (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned long       Offset,
    IUnknown          * pIf,
    const IID &         IId )
{
    if ( pIf )
        {
        LENGTH_ALIGN( Offset, 7 );

        //Leave space for array bounds, padding, and length

        Offset += 3 * sizeof(long);

        HRESULT         hr;
        unsigned long   cbSize = 0;

        hr = CoGetMarshalSizeMax( &cbSize,
                                  IId,
                                  pIf,
                                  USER_CALL_CTXT_MASK( Flags ),
                                  pContext->pStubMsg->pvDestContext,
                                  MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
            RAISE_RPC_EXCEPTION( hr );

        Offset += cbSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserMarshal64
//
//  Synopsis:   Marshalls an interface pointer.
//
//  history:    Oct-2000   ScottRob/YongQu      Created for NDR64.
//
//--------------------------------------------------------------------------
EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserMarshal64 (
                                   USER_MARSHAL_CB   * pContext,
                                   unsigned long       Flags,
                                   unsigned char     * pBuffer,
                                   IUnknown          * pIf,
                                   const IID &         IId )
{
    unsigned long * pMaxCount, *pSize;
    unsigned long   cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterface_PointerMarshal64\n"));

    if ( pIf )
    {
        // Always marshaled because of the apartment model.

        CStreamOnMessage MemStream( (unsigned char **) &pBuffer );

        ALIGN( pBuffer, 7 );        // need to align to 8

        pMaxCount = (unsigned long *) pBuffer;
        pBuffer +=  2 * sizeof( long );        // conformant size is 8

        // Leave space for length

        pSize = (unsigned long *) pBuffer;
        pBuffer += sizeof( long );

        HRESULT  hr;
        unsigned char * pBufferMark = pBuffer;

        hr = CoMarshalInterface( &MemStream,
                                 IId,
                                 pIf,
                                 USER_CALL_CTXT_MASK( Flags ),
                                 pContext->pStubMsg->pvDestContext,
                                 MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
        {
            RpcRaiseException(hr);
        }

        // Calculate the size of the data written

        DWORD cbData = (ULONG) (pBuffer - pBufferMark);

        // Update the array bounds.

        *pMaxCount = cbData;
        *pSize = cbData;
    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshal64
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    Oct-00   ScottRob/
//                       YongQu        Created for NDR64.
//
//--------------------------------------------------------------------------

EXTERN_C unsigned char __RPC_FAR * __RPC_USER __stdcall
WdtpInterfacePointer_UserUnmarshal64 (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId )
{
    // Get the buffer size and the start of the buffer.
    CUserMarshalInfo MarshalInfo( (ULONG*)pContext, pBuffer );
    ULONG_PTR BufferSize   = MarshalInfo.GetBufferSize();
    UCHAR*    pBufferStart = MarshalInfo.GetBuffer();

    // Delegate to worker routine.
    pBuffer = WdtpInterfacePointer_UserUnmarshalWorker( pContext,
                                                        pBufferStart,
                                                        ppIf,
                                                        IId,
                                                        BufferSize,
                                                        TRUE );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserFree64
//
//  Synopsis:   Frees the unmarshaled interface
//
//  history:    Oct-2000   ScottRob/YongQu      Created for NDR64.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER __stdcall
WdtpInterfacePointer_UserFree64(
    IUnknown      * pIf )
{
    WdtpInterfacePointer_UserFree(pIf);
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleprx32\proxy\daytona\prop_x.c ===
//+===================================================================
//
//   This file is a wrapper for prop_p.c (which is generated by MIDL
//   from ..\..\idl\prop.idl).
//
//   Prop_p.c makes references to wire-marshal routines that are
//   provided by oleaut32.dll.  But we can't (for performance
//   reasons) link ole32.dll directly to oleaut32, we do it
//   lazily.  So in this file, we use #defines to map
//   the wire-marshal routines called by prop_p.c so that
//   they are actually calls to "Load*" wrappers.  These
//   wrappers load oleaut32.dll, do a GetProcAddr, and
//   then make the actual call.
//
//+===================================================================

#include "prop.h"
#include <privoa.h>

#define BSTR_UserSize        LoadBSTR_UserSize
#define BSTR_UserMarshal     LoadBSTR_UserMarshal
#define BSTR_UserUnmarshal   LoadBSTR_UserUnmarshal
#define BSTR_UserFree        LoadBSTR_UserFree

#define LPSAFEARRAY_UserSize        LoadLPSAFEARRAY_UserSize
#define LPSAFEARRAY_UserMarshal     LoadLPSAFEARRAY_UserMarshal
#define LPSAFEARRAY_UserUnmarshal   LoadLPSAFEARRAY_UserUnmarshal
#define LPSAFEARRAY_UserFree        LoadLPSAFEARRAY_UserFree

#if defined(_WIN64)
#define BSTR_UserSize64        LoadBSTR_UserSize
#define BSTR_UserMarshal64     LoadBSTR_UserMarshal
#define BSTR_UserUnmarshal64   LoadBSTR_UserUnmarshal
#define BSTR_UserFree64        LoadBSTR_UserFree

#define LPSAFEARRAY_UserSize64        LoadLPSAFEARRAY_UserSize
#define LPSAFEARRAY_UserMarshal64     LoadLPSAFEARRAY_UserMarshal
#define LPSAFEARRAY_UserUnmarshal64   LoadLPSAFEARRAY_UserUnmarshal
#define LPSAFEARRAY_UserFree64        LoadLPSAFEARRAY_UserFree
#endif // defined(_WIN64)

#include "prop_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  _Assert
//              _PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92  BryanT    Switched to w4crt.h instead of wchar.h
//
//----------------------------------------------------------------------------

//
// This one file **always** uses debugging options
//

#if DBG == 1

#include <stdarg.h>

# include <debnot.h>
# include "dprintf.h"            // w4printf, w4dprintf prototypes

extern "C"
{
#include <windows.h>

#ifndef WIN32
#define MessageBoxA MessageBox
#define wsprintfA wsprintf
#endif
}

int APINOT _PopUpError(char const FAR *szMsg,
                       int iLine,
                       char const FAR *szFile);

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void _asdprintf(char const FAR *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------

void APINOT _Win4Assert(char const FAR * szFile,
                        int iLine,
                        char const FAR * szMessage)
{
    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = _PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifndef FLAT
            _asm int 3;
#else
            DebugBreak();
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifndef FLAT
        _asm int 3;
#else
        DebugBreak();
#endif
    }
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoMask(unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4AssertLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    _PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT _PopUpError(char const FAR *szMsg,int iLine, char const FAR *szFile)
{

    int id;
    static char szAssertCaption[100];
    wsprintfA(szAssertCaption, "File: %s line %u", szFile,iLine);

    id = MessageBoxA(NULL,
                     (char FAR *) szMsg,
                     (LPSTR) szAssertCaption,
		     MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);
    return id;
}


//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT vdprintf(unsigned long ulCompMask,
              char const FAR *pszComp,
              char const FAR *ppszfmt,
              va_list     pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        if (! (ulCompMask & DEB_NOCOMPNAME))
        {
#ifdef WIN32
#if defined(_CHICAGO_)
            //
            //  Hex Process/Thread ID's are better for Chicago since both
            //  are memory addresses.
            //
            w4dprintf("%08x.%08x> %s: ",
#else
            w4dprintf("%03d.%03d> %s: ",
#endif
                      GetCurrentProcessId(),
                      GetCurrentThreadId(),
                      pszComp);
#else
            w4dprintf("%07x> %s: ",
                      GetCurrentTask(),
                      pszComp);
#endif
        }
        w4vdprintf(ppszfmt, pargs);

        // Chicago and Win32s debugging is usually through wdeb386
        // which needs carriage returns
#if WIN32 == 50 || WIN32 == 200
        w4dprintf("\r");
#endif
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"

LPVOID lpThkCallOutputFunctionsProc = NULL;

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//		w4vprintf
//  		w4dprintf
//		w4vdprintf
//		
//  History:    18-Oct-91   vich	Created
//	
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN32
int _cdecl w4dprintf(const char __far *format, ...);
int _cdecl w4vdprintf(const char __far *format, va_list arglist);
#else
int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#define _W4SPRINTF_
#include "printf.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\h\io16.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	io16.h
//
//  Contents:	16-bit generic include
//
//  History:	18-Feb-94	DrewB	Created
//              07-Mar-94       BobDay  Pre-adjusted STACK_PTR, prepared for
//                                      removal of other macros
//
//----------------------------------------------------------------------------

#ifndef __IO16_H__
#define __IO16_H__

// Get a pointer to a _pascal stack via an argument
#define PASCAL_STACK_PTR(v) ((LPVOID)((DWORD)&(v)+sizeof(v)))

// Get a pointer to a _cdecl stack via an argument
#define CDECL_STACK_PTR(v) ((LPVOID)(&(v)))

#endif // #ifndef __IO16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(FLAT)
#ifndef FAR
#define FAR
#endif
#  ifndef FLAT
#    define FLAT
#  endif
#else
#ifndef FAR
#define FAR __far
#endif
#endif

#ifndef NULL
#  define NULL 0
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

struct w4io
{
    union
    {
	struct
	{
	    wchar_t FAR *_pwcbuf;	// wchar_t output buffer
	    wchar_t FAR *_pwcstart;
	} wc;
	struct
	{
	    char FAR *_pchbuf;	// char output buffer
	    char FAR *_pchstart;
	} ch;
    } buf ;
    unsigned int cchleft;	// output buffer character count
    void (_cdecl *writechar)(int ch,
			     int num,
			     struct w4io FAR *f,
			     int FAR *pcchwritten);
};

#define pwcbuf		buf.wc._pwcbuf
#define pwcstart	buf.wc._pwcstart
#define pchbuf		buf.ch._pchbuf
#define pchstart	buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io FAR *stream, const char FAR *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <stdarg.h>
#include <limits.h>
#include <windows.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char FAR *s, long cch, long FAR * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifndef FLAT
#     define OutputDebugStringA OutputDebugString
#   endif
    int _cdecl _pflushbuf(struct w4io FAR *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io FAR *f, int FAR *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ FAR *string) const char FAR *format, va_list arglist);

#ifdef __cplusplus
extern "C"
{
#endif
DWORD  FAR PASCAL CallProc32W(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount);
#ifdef __cplusplus
}
#endif
LPVOID lpThkCallOutputFunctionsProc;


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ FAR *string) const char FAR *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ FAR *string) const char FAR *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugStringA("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io FAR *f, int FAR *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io FAR *f)
{
    int cch;

    if (cch = (int) (f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        if (lpThkCallOutputFunctionsProc == NULL)
        {
            OutputDebugStringA(f->pchstart);
        }
        else
        {
            // note casting and dummy arguments to match other uses of it (see interop.hxx)
            CallProc32W((DWORD) f->pchstart, 0, 0, lpThkCallOutputFunctionsProc, 0x00000004, 3); // thunk it to olethk32.dll
        }
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\h\wow32fn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	wow32fn.h
//
//  Contents:	WOW 32-bit private function declarations
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#ifndef __WOW32FN_H__
#define __WOW32FN_H__

//
// WOW types
//

// 'V'DM pointers
typedef DWORD VPVOID;
typedef DWORD VPSTR;

typedef HANDLE HAND32;
typedef WORD HAND16;

typedef HAND16 HMEM16;
typedef HAND16 HWND16;
typedef HAND16 HDC16;
typedef HAND16 HRGN16;
typedef HAND16 HMENU16;
typedef HAND16 HICON16;
typedef HAND16 HBITMAP16;
typedef HAND16 HACCEL16;
typedef HAND16 HTASK16;
typedef HAND16 HMETAFILE16;

#ifdef __cplusplus
extern "C"
{
#endif

// Macros to handle conversion of 16:16 pointers to 0:32 pointers
// On NT this mapping is guaranteed to stay stable in a WOW process
// as long as a 32->16 transition doesn't occur
//
// On Chicago 32-bit code can be preempted at any time so selectors
// must be fixed to protect them from being remapped

#if defined(_CHICAGO_)

#define WOWFIXVDMPTR(vp, cb) WOWGetVDMPointerFix(vp, cb, TRUE)
#define WOWRELVDMPTR(vp)     WOWGetVDMPointerUnfix(vp)

#else

#define WOWFIXVDMPTR(vp, cb) WOWGetVDMPointer(vp, cb, TRUE)
#define WOWRELVDMPTR(vp)     (vp)

#endif

#define FIXVDMPTR(vp, type) \
    (type UNALIGNED *)WOWFIXVDMPTR(vp, sizeof(type))
#define RELVDMPTR(vp) \
    WOWRELVDMPTR(vp)

#if !defined(_CHICAGO_)

HAND16 CopyDropFilesFrom32(HANDLE h32);
HANDLE CopyDropFilesFrom16(HAND16 h16);

#endif

#ifdef __cplusplus
}
#endif

// 16-bit HGLOBAL tracking functions
#if DBG == 1
VPVOID WgtAllocLock(WORD wFlags, DWORD cb, HMEM16 *ph);
void WgtUnlockFree(VPVOID vpv);
void WgtDump(void);
#else
#define WgtAllocLock(wFlags, cb, ph) \
    WOWGlobalAllocLock16(wFlags, cb, ph)
#define WgtUnlockFree(vpv) \
    WOWGlobalUnlockFree16(vpv)
#define WgtDump()
#endif

#endif // #ifndef __WOW32FN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\debnot\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#if DBG == 1

#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS			// Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT	     1	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     0	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     1	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     0	     /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT	     0	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     1	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     0	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     1	     /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0	     /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void FAR *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void FAR *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE	    /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001	  /* put plus or minus in front */
#define FL_SIGNSP     0x0002	  /* put space or minus in front */
#define FL_LEFT       0x0004	  /* left justify */
#define FL_LEADZERO   0x0008	  /* pad with leading zeros */
#define FL_LONG       0x0010	  /* long value given */
#define FL_SHORT      0x0020	  /* short value given */
#define FL_SIGNED     0x0040	  /* signed data given */
#define FL_ALTERNATE  0x0080	  /* alternate form requested */
#define FL_NEGATIVE   0x0100	  /* value is negative */
#define FL_FORCEOCTAL 0x0200	  /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400	  /* long double value given */
#define FL_WIDE	      0x0800	  /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,		    /* normal state; outputting literal chars */
    ST_PERCENT, 	    /* just read '%' */
    ST_FLAG,		    /* just read flag character */
    ST_WIDTH,		    /* just read width specifier */
    ST_DOT,		    /* just read '.' */
    ST_PRECIS,		    /* just read precision specifier */
    ST_SIZE,		    /* just read size specifier */
    ST_TYPE		    /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,		    /* character with no special meaning */
    CH_PERCENT, 	    /* '%' */
    CH_DOT,		    /* '.' */
    CH_STAR,		    /* '*' */
    CH_ZERO,		    /* '0' */
    CH_DIGIT,		    /* '1'..'9' */
    CH_FLAG,		    /* ' ', '+', '-', '#' */
    CH_SIZE,		    /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE		    /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";	/* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any	  */
/* character; while the uper nybble of the byte gives the next state	  */
/* to enter.  See the macros below the table for details.		  */
/*									  */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.								  */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)		\
	((c) < ' ' || (c) > 'x' ?	\
	    CH_OTHER			\
	:				\
	    lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)	\
	(lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list FAR *pargptr);
#endif
LOCAL(int) get_int_arg(va_list FAR *pargptr);
LOCAL(void) writestring(char FAR *string,
			int len,
			struct w4io FAR *f,
			int FAR *pcchwritten,
			int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (FAR * PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)	    (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)	    (*_cfltcvt_tab[3])(a)
#define _positive(a)	    (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.	It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*	The format string is parsed by using a finite state automaton
*	based on the current state and the current character read from
*	the format string.  Thus, looping is on a per-character basis,
*	not a per conversion specifier basis.  Once the format specififying
*	character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io FAR *f, const char FAR *format, va_list argptr)
{
    int hexadd; 	/* offset to add to number to get 'a'..'f' */
    char ch;		/* character just read */
    wchar_t wc;		/* wide character temp */
    wchar_t FAR *pwc;	/* wide character temp pointer */
    int flags;		/* flag word -- see #defines above for flag values */
    enum STATE state;	/* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;		/* current conversion radix */
    int charsout;	/* characters currently written so far, -1 = IO error */
    int fldwidth;	/* selected field with -- 0 means default */
    int fwide;
    int precision;	/* selected precision -- -1 means default */
    char prefix[2];	/* numeric prefix -- up to two characters */
    int prefixlen;	/* length of prefix -- 0 means no prefix */
    int capexp; 	/* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;	/* non-zero = prodcue no output for this specifier */
    char FAR *text; 	/* pointer text to be printed, not zero terminated */
    char FAR *text2; 	/* pointer text to be printed, not zero terminated */
    int textlen;	/* length of the text to be printed */
    char buffer[BUFFERSIZE];	/* buffer for conversions */

    charsout = 0;		/* no characters written yet */
    state = ST_NORMAL;		/* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
	chclass = find_char_class(ch);	/* find character class */
	state = find_next_state(chclass, state); /* find next state */

	/* execute code for each state */
	switch (state) {

	case ST_NORMAL:
	    /* normal state -- just write character */
	    f->writechar(ch, 1, f, &charsout);
	    break;

	case ST_PERCENT:
	    /* set default value of conversion parameters */
	    prefixlen = fldwidth = no_output = capexp = 0;
	    flags = 0;
	    precision = -1;
	    fwide = 0;
	    break;

	case ST_FLAG:
	    /* set flag based on which flag character */
	    switch (ch) {
	    case '-':
		flags |= FL_LEFT;	/* '-' => left justify */
		break;
	    case '+':
		flags |= FL_SIGN;	/* '+' => force sign indicator */
		break;
	    case ' ':
		flags |= FL_SIGNSP;	/* ' ' => force sign or space */
		break;
	    case '#':
		flags |= FL_ALTERNATE;	/* '#' => alternate form */
		break;
	    case '0':
		flags |= FL_LEADZERO;	/* '0' => pad with leading zeros */
		break;
	    }
	    break;

	case ST_WIDTH:
	    /* update width value */
	    if (ch == '*') {
		/* get width from arg list */
		fldwidth = get_int_arg(&argptr);
		if (fldwidth < 0) {
		    /* ANSI says neg fld width means '-' flag and pos width */
		    flags |= FL_LEFT;
		    fldwidth = -fldwidth;
		}
	    }
	    else {
		/* add digit to current field width */
		fldwidth = fldwidth * 10 + (ch - '0');
	    }
	    break;

	case ST_DOT:
	    /* zero the precision, since dot with no number means 0
	       not default, according to ANSI */
	    precision = 0;
	    break;

	case ST_PRECIS:
	    /* update precison value */
	    if (ch == '*') {
		/* get precision from arg list */
		precision = get_int_arg(&argptr);
		if (precision < 0)
		    precision = -1;	/* neg precision means default */
	    }
	    else {
		/* add digit to current precision */
		precision = precision * 10 + (ch - '0');
	    }
	    break;

	case ST_SIZE:
	    /* just read a size specifier, set the flags based on it */
	    switch (ch) {
#if !LONG_IS_INT
	    case 'l':
		flags |= FL_LONG;   /* 'l' => long int */
		break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
	    case 'L':
		flags |= FL_LONGDOUBLE; /* 'L' => long double */
		break;
#endif

#if !SHORT_IS_INT
	    case 'h':
		flags |= FL_SHORT;  /* 'h' => short int */
		break;
#endif
	    case 'w':
		flags |= FL_WIDE;   /* 'w' => wide character */
		break;
	    }
	    break;

	case ST_TYPE:
	    /* we have finally read the actual type character, so we	   */
	    /* now format and "print" the output.  We use a big switch	   */
	    /* statement that sets 'text' to point to the text that should */
	    /* be printed, and 'textlen' to the length of this text.	   */
	    /* Common code later on takes care of justifying it and	   */
	    /* other miscellaneous chores.  Note that cases share code,    */
	    /* in particular, all integer formatting is doen in one place. */
	    /* Look at those funky goto statements!			   */

	    switch (ch) {

	    case 'c': {
		/* print a single character specified by int argument */
		wc = (wchar_t) get_int_arg(&argptr);	/* get char to print */
		* (wchar_t FAR *) buffer = wc;
		text = buffer;
		textlen = 1;	    /* print just a single character */
	    }
	    break;

	    case 'S': {
		/* print a Counted String

		int i;
		char FAR *p;       /* temps */
                struct string {
                    short Length;
                    short MaximumLength;
                    char FAR *Buffer;
                } *pstr;

		pstr = get_ptr_arg(&argptr);
		if (pstr == NULL || pstr->Buffer == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
#ifdef FLAT
                    textlen = strlen(text);
#else
                    textlen = _fstrlen(text);
#endif
		    flags &= ~FL_WIDE;
		} else {
                    text = pstr->Buffer;
                    textlen = pstr->Length;
                }

	    }
	    break;

	    case 's': {
		/* print a string --				*/
		/* ANSI rules on how much of string to print:	*/
		/*   all if precision is default,		*/
		/*   min(precision, length) if precision given. */
		/* prints '(null)' if a null string is passed	*/

		int i;
		char FAR *p;       /* temps */

		text = get_ptr_arg(&argptr);
		if (text == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
		    flags &= ~FL_WIDE;
		}

		/* At this point it is tempting to use strlen(), but */
		/* if a precision is specified, we're not allowed to */
		/* scan past there, because there might be no null   */
		/* at all.  Thus, we must do our own scan.	     */

		i = (precision == -1) ? INT_MAX : precision;

		/* scan for null upto i characters */
		if (flags & FL_WIDE) {
		    pwc = (wchar_t FAR *) text;
		    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
			++pwc;
			if (wc & 0xff00) {	// if high byte set,
			    break;		// error will be indicated
			}
		    }
		    textlen = (int) (pwc - (wchar_t FAR *) text) ;  /* length of string */
		} else {
		    p = text;
		    while (i-- && *p) {
			++p;
		    }
		    textlen = (int) (p - text);    /* length of the string */
		}
	    }
	    break;

	    case 'n': {
		/* write count of characters seen so far into */
		/* short/int/long thru ptr read from args */

		void FAR *p;	    /* temp */

		p = get_ptr_arg(&argptr);

		/* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    *(long FAR *)p = charsout;
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT)
		    *(short FAR *)p = (short) charsout;
		else
#endif
		    *(int FAR *)p = charsout;

		no_output = 1;		    /* force no output */
	    }
	    break;


#ifndef NOFLOATS
	    case 'E':
	    case 'G':
		capexp = 1;		    /* capitalize exponent */
		ch += 'a' - 'A';	    /* convert format char to lower */
		/* DROP THROUGH */
	    case 'e':
	    case 'f':
	    case 'g':	{
		/* floating point conversion -- we call cfltcvt routines */
		/* to do the work for us.				 */
		flags |= FL_SIGNED;	    /* floating point is signed conversion */
		text = buffer;		    /* put result in buffer */
		flags &= ~FL_WIDE;	    /* 8 bit string */

		/* compute the precision value */
		if (precision < 0)
		    precision = 6;	/* default precision: 6 */
		else if (precision == 0 && ch == 'g')
		    precision = 1;	/* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
		/* do the conversion */
		if (flags & FL_LONGDOUBLE) {
		    _cldcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, LONGDOUBLE);
		}
		else
#endif
		{
		    _cfltcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, DOUBLE);
		}

		/* '#' and precision == 0 means force a decimal point */
		if ((flags & FL_ALTERNATE) && precision == 0)
		    _forcdecpt(text);

		/* 'g' format means crop zero unless '#' given */
		if (ch == 'g' && !(flags & FL_ALTERNATE))
		    _cropzeros(text);

		/* check if result was negative, save '-' for later */
		/* and point to positive part (this is for '0' padding) */
		if (*text == '-') {
		    flags |= FL_NEGATIVE;
		    ++text;
		}

		textlen = strlen(text);     /* compute length of text */
	    }
	    break;
#endif // NOFLOATS

	    case 'd':
	    case 'i':
		/* signed decimal output */
		flags |= FL_SIGNED;
		radix = 10;
		goto COMMON_INT;

	    case 'u':
		radix = 10;
		goto COMMON_INT;

	    case 'p':
		/* write a pointer -- this is like an integer or long */
		/* except we force precision to pad with zeros and */
		/* output in big hex. */

		precision = 2 * sizeof(void FAR *);     /* number of hex digits needed */
#if !PTR_IS_INT
		flags |= FL_LONG;	/* assume we're converting a long */
#endif
		/* DROP THROUGH to hex formatting */

	    case 'C':
	    case 'X':
		/* unsigned upper hex output */
		hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
		goto COMMON_HEX;

	    case 'x':
		/* unsigned lower hex output */
		hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
		/* DROP THROUGH TO COMMON_HEX */

	    COMMON_HEX:
		radix = 16;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means '0x' prefix */
		    prefix[0] = '0';
		    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);	/* 'x' or 'X' */
		    prefixlen = 2;
		}
		goto COMMON_INT;

	    case 'o':
		/* unsigned octal output */
		radix = 8;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means force a leading 0 */
		    flags |= FL_FORCEOCTAL;
		}
		/* DROP THROUGH to COMMON_INT */

	    COMMON_INT: {
		/* This is the general integer formatting routine. */
		/* Basically, we get an argument, make it positive */
		/* if necessary, and convert it according to the */
		/* correct radix, setting text and textlen */
		/* appropriately. */

		unsigned long number;	/* number to convert */
		int digit;		/* ascii value of digit */
		long l; 		/* temp long value */

		/* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    l = get_long_arg(&argptr);
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT) {
		    if (flags & FL_SIGNED)
			l = (short) get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
		}
		else
#endif
		{
		    if (flags & FL_SIGNED)
			l = get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
		}

		/* 2. check for negative; copy into number */
		if ( (flags & FL_SIGNED) && l < 0) {
		    number = -l;
		    flags |= FL_NEGATIVE;   /* remember negative sign */
		}
		else {
		    number = l;
		}

		/* 3. check precision value for default; non-default */
		/*    turns off 0 flag, according to ANSI. */
		if (precision < 0)
		    precision = 1;		/* default precision */
		else
		    flags &= ~FL_LEADZERO;

		/* 4. Check if data is 0; if so, turn off hex prefix */
		if (number == 0)
		    prefixlen = 0;

		/* 5. Convert data to ASCII -- note if precision is zero */
		/*    and number is zero, we get no digits at all.	 */

		text2 = text = &buffer[BUFFERSIZE-1];	// last digit at end of buffer
		flags &= ~FL_WIDE;		// 8 bit characters

		while (precision-- > 0 || number != 0) {
		    digit = (int)(number % radix) + '0';
		    number /= radix;		/* reduce number */
		    if (digit > '9') {
			/* a hex digit, make it a letter */
			digit += hexadd;
		    }
		    *text-- = (char)digit;	/* store the digit */
		}

		textlen = text2 - text; /* compute length of number */
		++text; 	/* text points to first digit now */


		/* 6. Force a leading zero if FORCEOCTAL flag set */
		if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
		    *--text = '0';
		    ++textlen;		/* add a zero */
		}
	    }
	    break;
	    }

	    /* At this point, we have done the specific conversion, and */
	    /* 'text' points to text to print; 'textlen' is length.  Now we */
	    /* justify it, put on prefixes, leading zeros, and then */
	    /* print it. */

	    if (!no_output) {
		int padding;	/* amount of padding, negative means zero */

		if (flags & FL_SIGNED) {
		    if (flags & FL_NEGATIVE) {
			/* prefix is a '-' */
			prefix[0] = '-';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGN) {
			/* prefix is '+' */
			prefix[0] = '+';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGNSP) {
			/* prefix is ' ' */
			prefix[0] = ' ';
			prefixlen = 1;
		    }
		}

		/* calculate amount of padding -- might be negative, */
		/* but this will just mean zero */
		padding = fldwidth - textlen - prefixlen;

		/* put out the padding, prefix, and text, in the correct order */

		if (!(flags & (FL_LEFT | FL_LEADZERO))) {
		    /* pad on left with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* write prefix */
		writestring(prefix, prefixlen, f, &charsout, 0);

		if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
		    /* write leading zeros */
		    f->writechar('0', padding, f, &charsout);
		}

		/* write text */
		writestring(text, textlen, f, &charsout, flags & FL_WIDE);

		if (flags & FL_LEFT) {
		    /* pad on right with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* we're done! */
	    }
	    break;
	}
    }

    return charsout;	    /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list FAR *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list FAR *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len	     - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide	     - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
	char FAR *string,
	int len,
	struct w4io FAR *f,
	int FAR *pcchwritten,
	int fwide)
{
    wchar_t FAR *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
	pwc = (wchar_t FAR *) string;
	while (len-- > 0) {
	    if (*pwc & 0xff00) {
		f->writechar('^', 1, f, pcchwritten);
	    }
	    f->writechar((char) *pwc++, 1, f, pcchwritten);
	}
    } else {
	while (len-- > 0) {
	    f->writechar(*string++, 1, f, pcchwritten);
	}
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\h\wow16fn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	wow16fn.h
//
//  Contents:	WOW 16-bit private function declarations
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#ifndef __WOW16FN_H__
#define __WOW16FN_H__

#ifdef __cplusplus
extern "C"
{
#endif

DWORD  FAR PASCAL LoadLibraryEx32W(LPCSTR pszDll, DWORD reserved,
                                   DWORD dwFlags);
BOOL   FAR PASCAL FreeLibrary32W(DWORD hLibrary);
LPVOID FAR PASCAL GetProcAddress32W(DWORD hMod, LPCSTR pszProc);
DWORD  FAR PASCAL GetVDMPointer32W(LPVOID pv, UINT cb);

/* This API actually takes a variable number of user arguments before
   the three required arguments.  We only need three user arguments at
   most so that's the way we declare it.
   When using this call, dwArgCount must always be three.
   Use CP32_NARGS to track changes*/

#define CP32_NARGS 3
DWORD  FAR PASCAL CallProc32W(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount);

#ifdef _CHICAGO_

DWORD  FAR PASCAL SSCallProc32(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount);

#ifdef _STACKSWITCHON16_
#define CallProcIn32(a,b,c,d,e,f) 	SSCallProc32(a,b,c,d,e,f)
#else
#define CallProcIn32(a,b,c,d,e,f) 	CallProc32W(a,b,c,d,e,f)
#endif // _STACKSWITCHON16_

#else

#define CallProcIn32(a,b,c,d,e,f) 	CallProc32W(a,b,c,d,e,f)

#endif


#ifdef __cplusplus
}
#endif

#endif // #ifndef __WOW16FN_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\coll\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <windows.h>
#include <ole2.h>
#include <ole2sp.h>
#include <olecoll.h>
#include <memctx.hxx>


#include "plex.h"
ASSERTDATA



CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, DWORD mp, UINT nMax, UINT cbElement)
{
	AssertSz(nMax > 0 && cbElement > 0,0);
	CPlex FAR* p = (CPlex FAR*)CoMemAlloc(sizeof(CPlex) + nMax * cbElement, mp, NULL);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain(DWORD mp)     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		CoMemFree(pThis, mp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\assrtdlg.h ===
#define AssertFail                  5100
#define Expr                        5101
#define Location                    5102
#define ASSRT_ID_BREAK                     5103
#define ASSRT_ID_EXIT                      5104
#define ASSRT_ID_IGNORE                    5105
#define ASSRT_ID_LOC                       5106
#define ASSRT_ID_EXPR                      5107
#define ASSRT_ID_MSG                5108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\coll\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <ole2.h>
#include <ole2sp.h>
#include <olecoll.h>
#include <memctx.hxx>


#include "map_kv.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
	if (memctx == MEMCTX_SAME)
		memctx = CoMemctxOf(this);
	m_memctx = memctx;
	Assert(m_memctx != MEMCTX_UNKNOWN);
}

CMapKeyToValue::~CMapKeyToValue()
{
	ASSERT_VALID(this);
	RemoveAll();
	Assert(m_nCount == 0);
}


// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


BOOL CMapKeyToValue::InitHashTable()
{
	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)CoMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*), m_memctx, NULL)) == NULL)
		return FALSE;

	_fmemset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


void CMapKeyToValue::RemoveAll()
{
	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		CoMemFree(m_pHashTable, m_memctx);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain(m_memctx);
	m_pBlocks = NULL;

	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_memctx, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	if (m_lpfnHashKey)
		nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else {
		Assert(m_lpfnHashKey);
		return NULL;
	}

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && _fmemcmp(pKey1, pKey2, cbKey1) == 0;
}


BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = CoMemAlloc(cbKey, m_memctx, NULL)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	_fmemcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	if (m_cbKey == 0)
		CoMemFree(pAssoc->key.pKey, m_memctx);
}


void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	_fmemcpy(pValue, pValueFrom, m_cbValue);
}


void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		_fmemset(pValueTo, 0, m_cbValue);
	else
		_fmemcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	UINT nHash;
	return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		_fmemset(pValue, 0, m_cbValue);
		return FALSE;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
	return TRUE;
}


// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	if (Lookup(pKey, cbKey, pValue))
		return TRUE;

	// value set to zeros since lookup failed

	return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	UINT nHash;
	register CAssoc  FAR* pAssoc;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			return FALSE;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			return FALSE;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
	{
		SetAssocValue(pAssoc, pValue);
	}

	return TRUE;
}


// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		return FALSE;       // not in map

	ASSERT_VALID(this);

	SetAssocValue(pAssoc, pValue);
	return TRUE;
}


// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[(*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;   // not found
}


// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	// REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
		// null hkey or bad hash value
		return FALSE;

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

	return FALSE;   // not found (must have a messed up list or passed 
					// a key from another list)
}


HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	UINT nHash;

	ASSERT_VALID(this);

	return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		_fmemcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(!IsBadReadPtr(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	Assert(!IsBadCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(!IsBadReadPtr(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(!IsBadReadPtr(m_pBlocks, SizeAssoc() * m_nBlockSize));

	// some collections live as global variables in the libraries, but 
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
	Assert(m_memctx == MEMCTX_SHARED || CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\call32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       call32.cxx      (16 bit target)
//
//  Contents:   Functions to call 32 bit dll in WOW
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "map_htsk.h"
#include "etask.hxx"

#include <call32.hxx>
#include <obj16.hxx>
#include <go1632pr.hxx>
#include <comlocal.hxx>

static LPVOID lpInvokeOn32Proc;     // Address of InvokeOn32() in 32-bits
static LPVOID lpSSInvokeOn32Proc;   // Address of InvokeOn32() in 32-bits
LPVOID lpIUnknownObj32;             // Address of IUnknown methods handler
static LPVOID lpCallbackProcessing; // Address of CallbackProcessing_3216
static LPVOID pfnCSm16ReleaseHandler_Release32;

static LPVOID pfnConvertHr1632;     // TranslateHRESULT_1632
static LPVOID pfnConvertHr3216;     // TranslateHRESULT_3216
static LPVOID pfnThkAddAppCompatFlag; // Add an AppCompatibility flag

static DWORD hmodOLEThunkDLL;       // Module handle of 32-bit OLE interop DLL
EXTERN_C LPVOID lpThkCallOutputFunctionsProc; // Address of ThkCallOutputFunctions in olethk32.dll

//
// Not used on Win95
//

#ifndef _CHICAGO_
static LPVOID pfnIntOpUninitialize; // Uninitialize function
#else
BOOL gfReleaseDLL = TRUE;
#endif


DWORD __loadds FAR PASCAL CallStub16(LPCALLDATA pcd);

// Address of ThkInitialize() in 32-bits
static LPVOID lpThkInitializeProc;
// Address of ThkUninitialize() in 32-bits
static LPVOID lpThkUninitializeProc;

BOOL  __loadds FAR PASCAL CallbackHandler( DWORD dwContinue );
DWORD __loadds FAR PASCAL LoadProcDll( LPLOADPROCDLLSTRUCT lplpds );
DWORD __loadds FAR PASCAL UnloadProcDll( DWORD vhmodule );
DWORD __loadds FAR PASCAL CallGetClassObject( LPCALLGETCLASSOBJECTSTRUCT
                                              lpcgcos );
DWORD __loadds FAR PASCAL CallCanUnloadNow( DWORD vpfnCanUnloadNow );
DWORD __loadds FAR PASCAL QueryInterface16(IUnknown FAR *punk,
                                           REFIID riid,
                                           void FAR * FAR *ppv);
DWORD __loadds FAR PASCAL AddRef16(IUnknown FAR *punk);
DWORD __loadds FAR PASCAL Release16(IUnknown FAR *punk);
DWORD __loadds FAR PASCAL ReleaseStgMedium16(STGMEDIUM FAR *psm);
DWORD __loadds FAR PASCAL TouchPointer16(BYTE FAR *pb);
DWORD __loadds FAR PASCAL StgMediumStreamHandler16(IStream FAR *pstmFrom,
                                         IStream FAR *pstmTo);
DWORD __loadds FAR PASCAL SetOwnerPublic16( DWORD hMem16 );
ULONG __loadds FAR PASCAL WinExec16( LPWINEXEC16STRUCT lpwes );


extern DWORD Sm16RhVtbl[SMI_COUNT];

// This DBG block allows assertion that the list is the same size
// as a DATA16
#if DBG == 1
DWORD gdata16[] =
#else
DATA16 gdata16 =
#endif
{
    (DWORD)atfnProxy1632Vtbl,
    (DWORD)CallbackHandler,
    (DWORD)TaskAlloc,
    (DWORD)TaskFree,
    (DWORD)LoadProcDll,
    (DWORD)UnloadProcDll,
    (DWORD)CallGetClassObject,
    (DWORD)CallCanUnloadNow,
    (DWORD)QueryInterface16,
    (DWORD)AddRef16,
    (DWORD)Release16,
    (DWORD)ReleaseStgMedium16,
    (DWORD)Sm16RhVtbl,
    (DWORD)TouchPointer16,
    (DWORD)StgMediumStreamHandler16,
    (DWORD)CallStub16,
    (DWORD)SetOwnerPublic16,
    (DWORD)WinExec16
};

//+---------------------------------------------------------------------------
//
//  Function:   CallbackHandler
//
//  Synopsis:   Provides 16-bit address that will allow calling back into
//              the 32-bit world's callback handler.  See IViewObject::Draw
//              lpfnContinue function parameter for the reasons for this
//              function.
//
//  Returns:    BOOL
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
BOOL __loadds FAR PASCAL CallbackHandler( DWORD dwContinue )
{
    BOOL    fResult;

    thkDebugOut((DEB_ITRACE, "CallbackHandler\n"));

    fResult = (BOOL)CallProcIn32( dwContinue, 0, 0,
                                 lpCallbackProcessing, 0, CP32_NARGS);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call32Initialize, public
//
//  Synopsis:   Called once when compobj.dll gets loaded.
//              Connects to the interop DLL on the 32-bit side and
//              finds entry points
//
//  Returns:    BOOL
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      Called at library initialization time
//
//----------------------------------------------------------------------------
#ifdef _CHICAGO_
extern "C" BOOL FAR PASCAL SSInit( void );
extern "C" DWORD _cdecl SSCall(DWORD cbParamBytes,
                         DWORD flags,
                         LPVOID lpfnProcAddress,
                         DWORD param1,...);

#define SSF_BigStack 1
#endif // _CHICAGO_

STDAPI_(BOOL) Call32Initialize(void)
{
    LPVOID lpAddr;
    BOOL fRet;
    DWORD hr;

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "In  Call32Initialize\n"));

    thkAssert(sizeof(gdata16) == sizeof(DATA16));

    fRet = FALSE;
    do
    {
        // initialize the 32 bit stack

#ifdef _CHICAGO_
        if (SSInit() == FALSE)
        {
            thkDebugOut((DEB_ERROR, "In  Call32Initialize; SSInit failed.\n"));
            break;
        }
#endif // _CHICAGO_

        //
        // Load the OLETHK32.DLL in WOW
        //
        hmodOLEThunkDLL = LoadLibraryEx32W("OLETHK32.DLL", 0, 0);
        if (hmodOLEThunkDLL == 0)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; LoadLibary failed.\n"));
            break;
        }

        //
        // Get the 32-bit initalization routine
        //
        lpAddr = GetProcAddress32W(hmodOLEThunkDLL, "IntOpInitialize");
        if (lpAddr == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress IntOpInitialize failed.\n"));
            break;
        }

        // Call the initialization routine and pass the 16-bit
        // invocation and proxy setup routine pointers
        // We want to keep these pointers in VDM form for Callback16
        // so we do not have them mapped flat

        if ((hr = CallProcIn32((DWORD)(LPDATA16)(&gdata16), 0, 0, lpAddr, 1 << 2, CP32_NARGS)) != NOERROR)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; Call IntOpInitialize failed. hr = %x\n", hr));
            break;
        }

        //
        // Get the address of the start of the 32-bit thunk interpreter
        //
        lpInvokeOn32Proc = GetProcAddress32W(hmodOLEThunkDLL, "InvokeOn32");
        if (lpInvokeOn32Proc == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress InvokeOn32 failed.\n"));
            break;
        }
#ifdef _CHICAGO_
        lpSSInvokeOn32Proc = GetProcAddress32W(hmodOLEThunkDLL, "SSInvokeOn32");
        if (lpSSInvokeOn32Proc == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress SSInvokeOn32 failed.\n"));
            break;
        }
#endif

        lpIUnknownObj32 = GetProcAddress32W(hmodOLEThunkDLL, "IUnknownObj32");
        if (lpIUnknownObj32 == NULL)
        {
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress IUnknowObj32 failed.\n"));
            break;
        }

        // proc address to initialize the thunk manager for
        // needs to be called for each apartment
        lpThkInitializeProc = GetProcAddress32W(hmodOLEThunkDLL,
                                                "ThkMgrInitialize");
        if (lpThkInitializeProc == NULL)
        {
            break;
        }

        lpThkUninitializeProc = GetProcAddress32W(hmodOLEThunkDLL,
                                                  "ThkMgrUninitialize");
        if (lpThkUninitializeProc == NULL)
        {
            break;
        }

        pfnCSm16ReleaseHandler_Release32 =
            GetProcAddress32W(hmodOLEThunkDLL,
                              "CSm16ReleaseHandler_Release32");
        if (pfnCSm16ReleaseHandler_Release32 == NULL)
        {
            break;
        }

        //
        // Get the address of the callback procedure for 32-bit callbacks
        //
        lpCallbackProcessing = GetProcAddress32W(hmodOLEThunkDLL,
                                                 "CallbackProcessing_3216");
        if ( lpCallbackProcessing == NULL )
        {
            break;
        }

        pfnConvertHr1632 = GetProcAddress32W(hmodOLEThunkDLL,
                                             "ConvertHr1632Thunk");
        if (pfnConvertHr1632 == NULL)
        {
            break;
        }

        pfnConvertHr3216 = GetProcAddress32W(hmodOLEThunkDLL,
                                             "ConvertHr3216Thunk");
        if (pfnConvertHr3216 == NULL)
        {
            break;
        }

        //
        // pfnIntOpUninitialize is not used on Win95
        //
#ifndef _CHICAGO_
        pfnIntOpUninitialize = GetProcAddress32W(hmodOLEThunkDLL,
                                                "IntOpUninitialize");
        if (pfnIntOpUninitialize == NULL)
        {
            break;
        }
#endif
        pfnThkAddAppCompatFlag = GetProcAddress32W(hmodOLEThunkDLL,
                                        "ThkAddAppCompatFlag");

        if (pfnThkAddAppCompatFlag == NULL )
        {
                break;
        }

#if DBG == 1
#ifndef _CHICAGO_
        // BUGBUG: doesn't work on Chicago
        lpThkCallOutputFunctionsProc = GetProcAddress32W(hmodOLEThunkDLL, "ThkCallOutputFunctions");
        if (lpThkCallOutputFunctionsProc == NULL)
        {
            // Ignore error as stuff will go to debugger screen by default
            thkDebugOut((DEB_ERROR, "Call32Initialize; GetProcAddress ThkCallOutputFunctions failed.\n"));
        }
#endif // _CHICAGO_
#endif

        fRet = TRUE;
    }
    while (FALSE);

    if (!fRet && hmodOLEThunkDLL != 0)
    {
        FreeLibrary32W(hmodOLEThunkDLL);
    }

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "Out Call32Initialize exit, %d\n", fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call32Uninitialize, public
//
//  Synopsis:   Called once when compobj.dll gets unloaded.
//              Disconnects to the interop DLL on the 32-bit side
//
//  History:    13-Jul-94       BobDay      Created
//
//  Notes:      Called at library WEP time
//
//----------------------------------------------------------------------------
STDAPI_(void) Call32Uninitialize(void)
{
    //
    // The notification is only sent on Windows/NT. On Win95, the 32-bit
    // side has already been cleaned up at this point, so calling over to
    // 32-bits is a really bad idea. We could fault.
    //
#ifndef _CHICAGO_
    // Notify olethk32 that the 16-bit half of interop is going away
    if (pfnIntOpUninitialize != NULL)
    {
        CallProc32W(0, 0, 0, pfnIntOpUninitialize, 0, CP32_NARGS);
    }
#endif
    //
    // Free OLETHK32.DLL
    //
    if ( CanReleaseDLL() && hmodOLEThunkDLL != 0 )
    {
        FreeLibrary32W(hmodOLEThunkDLL);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CallThkUninitialize
//
//  Synopsis:   Uninitialize the thunk manager and the tls data
//
//  History:    5-24-94   JohannP (Johann Posch)   Created
//
//  Notes:      Is called after CoUnintialize returned.
//
//----------------------------------------------------------------------------
STDAPI_(void) CallThkMgrUninitialize(void)
{
    thkAssert(lpThkUninitializeProc != NULL);

    CallProc32W(0, 0, 0,
                lpThkUninitializeProc, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallThkInitialize
//
//  Synopsis:   Initializes the thunk manager and the tls data
//
//  Returns:    Appropriate status code
//
//  History:    5-24-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called during CoInitialize.
//
//----------------------------------------------------------------------------

STDAPI CallThkMgrInitialize(void)
{
    thkAssert(lpThkInitializeProc != NULL);

    return (HRESULT)CallProc32W(0, 0, 0,
                                lpThkInitializeProc, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOW, public
//
//  Synopsis:   Wrapper for CallProcIn32 which handles our particular
//              form of call for thunked APIs and methods
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    18-Feb-94       JohannP Created
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOW(DWORD dwMethod, LPVOID pvStack)
{

    thkDebugOut((DEB_ITRACE, "CallObjectInWOW\n"));
    thkAssert(lpInvokeOn32Proc != NULL);


#ifdef _CHICAGO_
    // Note: only call if this process is still initialized
    HTASK htask;
    Etask etask;

    if (! (   LookupEtask(htask, etask)
           && (etask.m_htask == GetCurrentProcess()) ) )
    {
        thkDebugOut((DEB_ITRACE, "CallObjectInWOW failed not ETask (%08lX)(0x%08lX, %p)\n",
                     lpInvokeOn32Proc, dwMethod, pvStack));
        return (DWORD)E_UNEXPECTED;
    }
#endif


    // If the stack pointer is NULL then pass along our own stack
    // It won't be used but we need a valid pointer for CallProcIn32
    // to work on
    if (pvStack == NULL)
    {
        pvStack = PASCAL_STACK_PTR(dwMethod);
    }

    thkDebugOut((DEB_ITRACE, "CallProcIn32(%08lX)(0x%08lX, %p)\n",
                 lpInvokeOn32Proc, dwMethod, pvStack));

    // Translate the stack pointer from 16:16 to flat 32
    // The other user parameters aren't pointers
    return CallProcIn32(0, dwMethod, (DWORD)pvStack,
                       lpInvokeOn32Proc, (1 << 0), CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSCallObjectInWOW
//
//  Synopsis:
//
//  Arguments:  [dwMetho] --
//              [pvStack] --
//
//  Returns:
//
//  History:    1-24-95   JohannP (Johann Posch)   Created
//
//  Notes:      Same functionality as CallObjectInWOW except
//              not switching to 32 bit stack first.
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) SSCallObjectInWOW(DWORD dwMethod, LPVOID pvStack)
{
    thkDebugOut((DEB_ITRACE, "CallObjectInWOW\n"));
    thkAssert(lpInvokeOn32Proc != NULL);

    // If the stack pointer is NULL then pass along our own stack
    // It won't be used but we need a valid pointer for CallProcIn32
    // to work on
    if (pvStack == NULL)
    {
        pvStack = PASCAL_STACK_PTR(dwMethod);
    }

    thkDebugOut((DEB_ITRACE, "CallProcIn32(%08lX)(0x%08lX, %p)\n",
                 lpInvokeOn32Proc, dwMethod, pvStack));

    // Translate the stack pointer from 16:16 to flat 32
    // The other user parameters aren't pointers
    return CallProcIn32(0, dwMethod, (DWORD)pvStack,
                       lpSSInvokeOn32Proc, (1 << 0), CP32_NARGS);
}


//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOWCheckInit, public
//
//  Synopsis:   Performs CallObjectInWOW with guaranteed initialization
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      Since this function can return an error code from
//              CoInitialize, it should only be used directly for
//              functions which return HRESULTs
//              Other functions should check the HRESULT and map
//              it into an appropriate return value
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOWCheckInit(DWORD dwMethod, LPVOID pvStack)
{
    Etask etask;
    HTASK htask;
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CallObjectInWOWCheckInit\n"));

    if (!IsEtaskInit(htask, etask))
    {
        hr = CoInitialize( NULL );
        if (FAILED(hr))
        {
            return (DWORD)hr;
        }

        thkVerify(LookupEtask( htask, etask ));
        etask.m_inits = ETASK_FAKE_INIT;
        thkVerify(SetEtask(htask, etask));
    }

    return( CallObjectInWOW( dwMethod, pvStack) );
}
//+---------------------------------------------------------------------------
//
//  Function:   CallObjectInWOWCheckThkMgr, public
//
//  Synopsis:   Performs CallObjectInWOW with guaranteed initialization
//              of ThkMgr.
//
//  Arguments:  [oid] - Object ID
//              [dwMethod] - Method index
//              [pvStack] - Beginning of stack in 16-bits
//
//  Returns:    32-bit call result
//
//  History:    25-Aug-94       JohannP Created
//
//  Notes:      Since this function can return an error code from
//              ThkMgrInitialize, it should only be used directly for
//              functions which return HRESULTs
//              Other functions should check the HRESULT and map
//              it into an appropriate return value
//              This function is used by Storage api's since
//              they do not need compobj.
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CallObjectInWOWCheckThkMgr(DWORD dwMethod, LPVOID pvStack)
{
    Etask etask;
    HTASK htask;
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CallObjectInWOWCheckThkMgr\n"));

    // Note: IsEtaskInit will fail until CoInitialize
    // gets called.
    // ThkMgrInitialize can be called mutliple time
    // on the same apartment. This is inefficient but
    // the simplest solution; there are only a few
    // apps out there which use Storage api's without
    // compobj and ole2.
    if (!IsEtaskInit(htask, etask))
    {
        //  Note:
        //  Under Chicago 32-bit DLL's are loaded into a 16-bit apps private
        //  memory address space.  (Under Daytona, 32-bit DLL's are loaded in
        //  common memory).  This causes an abort as the logic assumes that
        //  OLETHK32.DLL is loaded at this point.
        //
        //  So if not initialize, initialize the thunk layer now.
        //
        hr = CallThkMgrInitialize();
        if (FAILED(hr))
        {
            return (DWORD)hr;
        }
    }

    return( CallObjectInWOW( dwMethod, pvStack) );
}



//+---------------------------------------------------------------------------
//
//  Function:   LoadProcDll, public
//
//  Synopsis:   Routine to load a 16-bit DLL and get the OLE entry points
//
//  Arguments:  [lplpds] - LoadProcDll struct full of needed goodies
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL LoadProcDll( LPLOADPROCDLLSTRUCT lplpds )
{
    DWORD   dwResult;
    HMODULE hmod16;
    LPDWORD lpdw;

    thkDebugOut((DEB_ITRACE, "LoadProcDll\n"));

    hmod16 = LoadLibrary( (LPSTR)lplpds->vpDllName );

    if ( hmod16 < HINSTANCE_ERROR )
    {
        return OLETHUNK_DLL16NOTFOUND;
    }

    lplpds->vpfnGetClassObject =
                (DWORD)GetProcAddress( hmod16, "DllGetClassObject" );
    lplpds->vpfnCanUnloadNow   =
                (DWORD)GetProcAddress( hmod16, "DllCanUnloadNow" );

    lplpds->vhmodule = (DWORD) hmod16;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnloadProcDll, public
//
//  Synopsis:   Routine to unload a 16-bit DLL
//
//  Arguments:  [vhmodule] - hmodule to unload
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL UnloadProcDll( DWORD vhmodule )
{
    DWORD   dwResult;
    HMODULE hmod16;

    thkDebugOut((DEB_ITRACE, "UnloadProcDll\n"));

    hmod16 = (HMODULE)vhmodule;

    FreeLibrary( hmod16 );

    return (DWORD)0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallGetClassObject, public
//
//  Synopsis:   Routine to call 16-bit DLL's DllGetClassObject entrypoint
//
//  Arguments:  [lpcgcos] - CallGetClassObject struct full of needed goodies
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallGetClassObject(
    LPCALLGETCLASSOBJECTSTRUCT lpcgcos )
{
    HRESULT hresult;
    HRESULT (FAR PASCAL *lpfn)(CLSID &,IID &,LPVOID FAR *);

    thkDebugOut((DEB_ITRACE, "CallGetClassObject\n"));

    lpfn = (HRESULT (FAR PASCAL *)(CLSID &,IID &,LPVOID FAR*))
                     lpcgcos->vpfnGetClassObject;

    hresult = (*lpfn)( lpcgcos->clsid,
                       lpcgcos->iid,
                       (LPVOID FAR *)&lpcgcos->iface );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallCanUnloadNow, public
//
//  Synopsis:   Routine to call 16-bit DLL's DllCanUnloadNow entrypoint
//
//  Arguments:  [vpfnCanUnloadNow] - 16:16 address of DllCanUnloadNow in DLL
//
//  Returns:
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallCanUnloadNow( DWORD vpfnCanUnloadNow )
{
    HRESULT hresult;
    HRESULT (FAR PASCAL *lpfn)(void);

    thkDebugOut((DEB_ITRACE, "CallGetClassObject\n"));

    lpfn = (HRESULT (FAR PASCAL *)(void))vpfnCanUnloadNow;

    hresult = (*lpfn)();

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterface16, public
//
//  Synopsis:   Calls QueryInterface on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//              [riid] - IID
//              [ppv] - Interface return
//
//  Returns:    HRESULT
//
//  History:    24-Mar-94       JohannP   Created
//
//----------------------------------------------------------------------------
DWORD __loadds FAR PASCAL QueryInterface16(IUnknown *punk,
                                           REFIID riid,
                                           void **ppv)
{
    DWORD dwRet;

    thkAssert(punk != NULL);

    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "QueryInterface16(%p) - Object invalid\n",
                     punk));
        return (DWORD)E_UNEXPECTED;
    }

    thkDebugOut((DEB_THUNKMGR, "In QueryInterface16(%p, %p, %p)\n",
                 punk, &riid, ppv));

    dwRet = (DWORD)punk->QueryInterface(riid, ppv);

    // There are some apps (Works is one) that return an IOleItemContainer
    // as an IOleContainer but neglect to respond to IOleContainer
    // in their QueryInterface implementations
    // In that event, retry with IOleItemContainer.  This is legal
    // to return as an IOleContainer since IOleItemContainer is
    // derived from IOleContainer

    // There are other derivation cases in the same vein

    if (dwRet == (DWORD)E_NOINTERFACE)
    {
        if (IsEqualIID(riid, IID_IOleContainer))
        {
            // Works has this problem

            dwRet = (DWORD)punk->QueryInterface(IID_IOleItemContainer, ppv);
        }
        else if (IsEqualIID(riid, IID_IPersist))
        {
            // According to the OLE 2.01 16-bit sources, Corel PhotoPaint
            // supports IPersistStorage but not IPersist.  Try all persist
            // combinations.

            dwRet = (DWORD)punk->QueryInterface(IID_IPersistStorage, ppv);
            if (dwRet == (DWORD)E_NOINTERFACE)
            {
                dwRet = (DWORD)punk->QueryInterface(IID_IPersistFile, ppv);
                if (dwRet == (DWORD)E_NOINTERFACE)
                {
                    dwRet = (DWORD)punk->QueryInterface(IID_IPersistStream,
                                                        ppv);
                }
            }
        }
    }

    thkDebugOut((DEB_THUNKMGR,
                 "  >>IUnknowObj16:QueryInterface (%p):0x%08lx\n",
                 *ppv, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRef16, public
//
//  Synopsis:   Calls AddRef on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//
//  Returns:    16-bit call return
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL AddRef16(IUnknown *punk)
{
    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "AddRef16(%p) - Object invalid\n", punk));
        return 0;
    }

    return punk->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   Release16, public
//
//  Synopsis:   Calls Release on behalf of the 32-bit code
//
//  Arguments:  [punk] - Object
//
//  Returns:    16-bit call return
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL Release16(IUnknown *punk)
{
    // There are shutdown cases where we will attempt to release objects
    // which no longer exist in the 16-bit world
    // According to CraigWi, in 16-bit OLE objects which had an
    // external reference were not cleaned up in CoUninitialize,
    // while in 32-bit OLE things are always cleaned up.  This
    // means that apps which are leaking objects with external locks
    // (Word can in some situations) get Releases that they do not
    // expect, so protect against calling invalid objects
    if (!IsValidInterface(punk))
    {
        thkDebugOut((DEB_ERROR, "Release16(%p) - Object invalid\n", punk));
        return 0;
    }

    return punk->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseStgMedium16, public
//
//  Synopsis:   Calls ReleaseStgMedium
//
//  Arguments:  [psm] - STGMEDIUM
//
//  Returns:    Appropriate status code
//
//  History:    25-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL ReleaseStgMedium16(STGMEDIUM FAR *psm)
{
    ReleaseStgMedium(psm);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSm16ReleaseHandler routines, public
//
//  Synopsis:   Method implementations for CSm16ReleaseHandler
//
//  History:    24-Apr-94       DrewB   Created
//              26-Mar-97       Gopalk  Removed call on the proxy to 32-bit
//                                      punkForRelease as the proxy is not
//                                      created in the first place
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) Sm16RhAddRef(CSm16ReleaseHandler FAR *psrh)
{
    return ++psrh->_cReferences;
}

STDMETHODIMP Sm16RhQI(CSm16ReleaseHandler FAR *psrh,
                      REFIID riid,
                      void FAR * FAR *ppv)
{
    if ( IsEqualIID(riid,IID_IUnknown) )
    {
        *ppv = psrh;
        Sm16RhAddRef(psrh);
        return NOERROR;
    }
    else
    {
        thkDebugOut((DEB_WARN, "Not a QI for IUnknown\n"));
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) Sm16RhRelease(CSm16ReleaseHandler FAR *psrh)
{
    STGMEDIUM *psm;
    METAFILEPICT *pmfp;
    HGLOBAL hg;

    if (--psrh->_cReferences != 0)
    {
        return psrh->_cReferences;
    }

    psm = &psrh->_sm16;
    switch(psm->tymed)
    {
    case TYMED_HGLOBAL:
        // Don't free this because copyback needs to occur in the
        // 32-bit world
        break;

    case TYMED_MFPICT:
#ifndef _CHICAGO_
        // Win95 thunking shares HMETAFILEs between 16/32 so we don't
        // need to clean up our copy
        pmfp = (METAFILEPICT *)GlobalLock(psm->hGlobal);
        DeleteMetaFile(pmfp->hMF);
        GlobalUnlock(psm->hGlobal);
#endif
        GlobalFree(psm->hGlobal);
        break;

    case TYMED_FILE:
    case TYMED_ISTREAM:
    case TYMED_ISTORAGE:
        // Handled by ReleaseStgMedium
        // 32-bit name handled by 32-bit part of processing
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in CSm16ReleaseHandler::Release");
        break;
    }

    // Continue call in 32-bits where 32-bit task allocations
    // and other 32-bit objects are cleaned up
    CallProcIn32( (DWORD)psrh, 0, 0,
                 pfnCSm16ReleaseHandler_Release32, (1 << 2), CP32_NARGS);

    // Clean up this
    hg = LOWORD(GlobalHandle(HIWORD((unsigned long)psrh)));
    GlobalUnlock(hg);
    GlobalFree(hg);

    return 0;
}

DWORD Sm16RhVtbl[SMI_COUNT] =
{
    (DWORD)Sm16RhQI,
    (DWORD)Sm16RhAddRef,
    (DWORD)Sm16RhRelease
};


//+---------------------------------------------------------------------------
//
//  Function:   StgMediumStreamHandler16
//
//  Synopsis:   Copies one stream to another
//
//  Effects:    Turns out that Excel does the wrong thing with STGMEDIUM's
//      when its GetDataHere() method is called. Instead of using
//      the provided stream, like it was supposed to, it creates its
//      own stream, and smashes the passed in streams pointer. This
//      appears to be happening on the Clipboard object for Excel.
//      To fix this, the thop function for STGMEDIUM input is going to
//      watch for changes to the stream pointer. If it changes, then
//      the 'app' (excel) has done something wrong.
//
//      To recover from this, the thop will call this routine passing
//      the bogus stream and the stream that was supposed to be used.
//      This routine will do a pstmFrom->CopyTo(pstmTo), and then
//      release the 'bogus' stream pointer.
//
//  Arguments:  [pstmFrom] -- Stream to copy then release
//      [pstmTo] -- Destination stream
//
//  History:    7-07-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD __loadds FAR PASCAL StgMediumStreamHandler16(IStream FAR *pstmFrom,
                                         IStream FAR *pstmTo)
{
    HRESULT hresult;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    ULONG ul;

    thkDebugOut((DEB_ITRACE,
                 "*** StgMediumStreamHandler16(pstmFrom=%p,pstmTo=%p)\n",
         pstmFrom,pstmTo));

    //
    // Assume that the entire stream is the data set to be copied.
    // Seek to the start of the stream
    //
    ULISet32(li,0);
    hresult = pstmFrom->Seek(li,STREAM_SEEK_SET,NULL);
    if (hresult != NOERROR)
    {
       thkDebugOut((DEB_ITRACE,
                     "StgMediumStreamHandler16 failed on seek %lx\n",hresult));
        goto exitRtn;
    }

    //
    // To copy the entire stream, specify the maximum size possible.
    //
    uli.LowPart = -1;
    uli.HighPart = -1;
    hresult = pstmFrom->CopyTo(pstmTo,uli,NULL,NULL);
    if (hresult != NOERROR)
    {
       thkDebugOut((DEB_ITRACE,
                     "StgMediumStreamHandler16 failed CopyTo %lx\n",hresult));
        goto exitRtn;
    }

exitRtn:
    //
    // In all cases, it is proper to release the pstmFrom, since we didn't
    // want it on the 32-bit side at all.
    //

    ul = pstmFrom->Release();


    if (ul != 0)
    {
       //
       // Whoops, we expected this stream pointer to go to zero. We can
       // only print a message, then let it leak.
       //
       thkDebugOut((DEB_ITRACE,
            "StgMediumStreamHandler16() Stream not released. ref=%lx\n",ul));
    }

    thkDebugOut((DEB_ITRACE,
    "*** StgMediumStreamHandler16(pstmFrom=%p,pstmTo=%p) returns %lx\n",
         pstmFrom,pstmTo,hresult));

    return((DWORD)hresult);

}

//+---------------------------------------------------------------------------
//
//  Function:   TouchPointer16, public
//
//  Synopsis:   Touches a byte at the given pointer's address to
//              bring in not-present segments
//
//  Arguments:  [pb] - Pointer
//
//  History:    25-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL TouchPointer16(BYTE FAR *pb)
{
    BYTE b = 0;

    if (pb)
    {
        b = *pb;
    }

#ifdef _CHICAGO_
    // On Win95, fix the memory block before returning to 32-bit code
    // to lock the segment in place.  If we tried to do this in 32-bit
    // code we could be preempted before we successfully lock the memory
    GlobalFix(LOWORD(HIWORD((DWORD)pb)));
#endif

    return b;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOwnerPublic16, public
//
//  Synopsis:   Sets a given 16-bit memory handle to be owned by nobody
//              (everybody)
//
//  Arguments:  [hmem] - 16-bit memory handle
//
//  History:    13-Jul-94       BobDay      Created
//
//----------------------------------------------------------------------------
extern "C" void FAR PASCAL KERNEL_SetOwner( WORD hMem16, WORD wOwner );

DWORD __loadds FAR PASCAL SetOwnerPublic16(DWORD hmem)
{
    KERNEL_SetOwner( (WORD)hmem, (WORD)-1 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   WinExec16, public
//
//  Synopsis:   Routine to run an application on behalf of ole32.dll
//
//  Arguments:  [lpwes] - WinExec16 struct full of needed goodies
//
//  Returns:
//
//  History:    27-Jul-94   AlexT   Created
//
//----------------------------------------------------------------------------

ULONG __loadds FAR PASCAL WinExec16( LPWINEXEC16STRUCT lpwes )
{
    ULONG ulResult;

    thkDebugOut((DEB_ITRACE, "WinExec16(%s, %d)\n",
                 lpwes->vpCommandLine, lpwes->vusShow));

    ulResult = (ULONG) WinExec((LPSTR)lpwes->vpCommandLine,
                               (UINT)lpwes->vusShow);
    thkDebugOut((DEB_ITRACE, "WinExec returned %ld\n", ulResult));

    return ulResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHr1632, public
//
//  Synopsis:   Converts a 16-bit HRESULT into a 32-bit HRESULT
//
//  Arguments:  [hr] - 16-bit HRESULT
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-94       DrewB   Created
//
//  Notes:      Delegates to 32-bit functions
//
//----------------------------------------------------------------------------

STDAPI ConvertHr1632(HRESULT hr)
{
    return (HRESULT)CallProcIn32( (DWORD)hr, 0, 0,
                                 pfnConvertHr1632, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHr3216, public
//
//  Synopsis:   Converts a 32-bit HRESULT into a 16-bit HRESULT
//
//  Arguments:  [hr] - 32-bit HRESULT
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-94       DrewB   Created
//
//  Notes:      Delegates to 32-bit functions
//
//----------------------------------------------------------------------------

STDAPI ConvertHr3216(HRESULT hr)
{
    return (HRESULT)CallProcIn32( (DWORD)hr, 0, 0,
                                 pfnConvertHr3216, 0, CP32_NARGS);
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCallProc32, public
//
//  Synopsis:   Wrapper for CallProc32W which switches to a bigger stack
//
//  Arguments:  [dw1] - argumensts similar to CallProc32W
//              [dw2]
//              [dw3]
//              [pfn32]
//              [dwPtrTranslate]
//              [dwArgCount]
//
//  Returns:    32-bit call result
//
//  History:    5-Dec-94       JohannP Created
//
//  Note:       this will be enabled as soon as I get the CallProc32WFix from
//              Win95
//----------------------------------------------------------------------------
#ifdef _STACKSWITCHON16_
DWORD  FAR PASCAL SSCallProc32(DWORD dw1, DWORD dw2, DWORD dw3,
                              LPVOID pfn32, DWORD dwPtrTranslate,
                              DWORD dwArgCount)
{
    DWORD dwRet = 0;
    // switch to the 32 bit stack
    //
    // return  SSCall(24,SSF_BigStack, (LPVOID)CallProc32W, dw1, dw2, dw3, pfn32, dwPtrTranslate, dwArgCount);
    thkDebugOut((DEB_ERROR, "SSCallProc32(dwArgCount:%x, dwPtrTranslate:%x, pfn32:%x, dw3:%x, dw2:%x, dw1:%x)\n",
                                dwArgCount, dwPtrTranslate, pfn32, dw3, dw2, dw1));
#if DBG == 1
    if (fSSOn)
    {
        dwRet = SSCall(24,SSF_BigStack, (LPVOID)CallProc32WFix, dwArgCount, dwPtrTranslate, pfn32, dw3, dw2, dw1);
    }
    else
#endif // DBG==1
    {
        dwRet = CallProc32W(dw1, dw2, dw3, pfn32, dwPtrTranslate, dwArgCount);
    }

    return dwRet;
}
#endif // _STACKSWITCHON16_

//+-------------------------------------------------------------------------
//
//  Function:   AddAppCompatFlag
//
//  Synopsis:   calls into olethk32 to add an app compability flag.
//
//  Effects:
//
//  Arguments:  [dwFlag]        -- the flag to add
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Mar-95 alexgo    author
//
//  Notes:      this function is exported so that ole2.dll can also call it
//
//--------------------------------------------------------------------------

STDAPI_(void) AddAppCompatFlag( DWORD dwFlag )
{
    CallProcIn32( (DWORD)dwFlag, 0, 0,
                                 pfnThkAddAppCompatFlag, 0, CP32_NARGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\coll\array_fv.cxx ===
/////////////////////////////////////////////////////////////////////////////
//
// Implementation of Array of values
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly initialized elements

#include <windows.h>
#include <ole2.h>
#include <ole2sp.h>
#include <olecoll.h>
#include <memctx.hxx>

ASSERTDATA

#include "array_fv.h"

#include <limits.h>
#define SIZE_T_MAX  UINT_MAX            /* max size for a size_t */


/////////////////////////////////////////////////////////////////////////////

CArrayFValue::CArrayFValue(DWORD memctx, UINT cbValue)
{
	m_pData = NULL;
	m_cbValue = cbValue;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
	if (memctx == MEMCTX_SAME)
		memctx = CoMemctxOf(this);
	m_memctx = memctx;
	Assert(m_memctx != MEMCTX_UNKNOWN);
}

CArrayFValue::~CArrayFValue()
{
	ASSERT_VALID(this);

	CoMemFree(m_pData, m_memctx);
}

// set new size; return FALSE if OOM

BOOL CArrayFValue::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
	ASSERT_VALID(this);
	Assert(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;    // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		CoMemFree(m_pData, m_memctx);
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		Assert((long)nNewSize * m_cbValue <= SIZE_T_MAX);    // no overflow

		m_pData = (BYTE FAR*)CoMemAlloc(nNewSize * m_cbValue, m_memctx, NULL);
		if (m_pData == NULL)
			return FALSE;

		_fmemset(m_pData, 0, nNewSize * m_cbValue);        // zero fill
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			_fmemset(&m_pData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// Otherwise grow array
		int nNewMax;
		if (nNewSize < m_nMaxSize + m_nGrowBy)
			nNewMax = m_nMaxSize + m_nGrowBy;   // granularity
		else
			nNewMax = nNewSize; // no slush

		Assert((long)nNewMax * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)CoMemAlloc(nNewMax * m_cbValue, m_memctx, NULL);
		if (pNewData == NULL)
			return FALSE;

		// copy new data from old
		_fmemcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// construct remaining elements
		Assert(nNewSize > m_nSize);
		_fmemset(&pNewData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		CoMemFree(m_pData, m_memctx);
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
	ASSERT_VALID(this);

	return TRUE;
}

void CArrayFValue::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		Assert((long)m_nSize * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)CoMemAlloc(m_nSize * m_cbValue, m_memctx, NULL);
		if (pNewData == NULL)
			return;					// can't shrink; don't to anything

		// copy new data from old
		_fmemcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		CoMemFree(m_pData, m_memctx);
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////

LPVOID CArrayFValue::_GetAt(int nIndex) const
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);
	return &m_pData[nIndex * m_cbValue];
}

void CArrayFValue::SetAt(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);

	_fmemcpy(&m_pData[nIndex * m_cbValue], pValue, m_cbValue);
}

BOOL CArrayFValue::SetAtGrow(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	if (nIndex >= m_nSize && !SetSize(nIndex+1))
		return FALSE;

	SetAt(nIndex, pValue);

	return TRUE;
}

BOOL CArrayFValue::InsertAt(int nIndex, LPVOID pValue, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);        // will expand to meet need
	Assert(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		if (!SetSize(nIndex + nCount))       // grow so nIndex is valid
			return FALSE;
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		if (!SetSize(m_nSize + nCount)) // grow it to new size
			return FALSE;

		// shift old data up to fill gap
		_fmemmove(&m_pData[(nIndex+nCount) * m_cbValue], 
			&m_pData[nIndex * m_cbValue],
			(nOldSize-nIndex) * m_cbValue);

		// re-init slots we copied from
		_fmemset(&m_pData[nIndex * m_cbValue], 0, nCount * m_cbValue);
	}

	// insert new value in the gap
	Assert(nIndex + nCount <= m_nSize);
	while (nCount--)
		_fmemcpy(&m_pData[nIndex++ * m_cbValue], pValue, m_cbValue);

	ASSERT_VALID(this);

	return TRUE;
}

void CArrayFValue::RemoveAt(int nIndex, int nCount /* = 1 */)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	Assert(nIndex < m_nSize);
	Assert(nCount >= 0);
	Assert(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	if (nMoveCount)
		_fmemcpy(&m_pData[nIndex * m_cbValue], 
			&m_pData[(nIndex + nCount) * m_cbValue],
			nMoveCount * m_cbValue);
	m_nSize -= nCount;
}


/////////////////////////////////////////////////////////////////////////////


// find element given part of one; offset is offset into value; returns
// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
// will be optimized for appropriate value size and param combinations
int CArrayFValue::IndexOf(LPVOID pData, UINT cbData, UINT offset)
{
	Assert(offset <= m_cbValue);
	Assert(cbData <= m_cbValue);
	Assert((long)offset + cbData <= m_cbValue);
	Assert(!IsBadReadPtr(pData, cbData));

#ifdef LATER
	if (cbData == sizeof(WORD) && m_cbValue == sizeof(WORD))
	{
		int iwRet;
		_asm 
		{
			push di
			les di,pData			;* get value
			mov ax,es:[di]			;*    from *(WORD FAR*)pData
			les di,this
			mov cx,[di].m_nSize		;* get size (in WORDs) of array
			les di,[di].m_pData		;* get ptr to WORD array
			repne scasw				;* look for *(WORD FAR*)pData
			jeq retcx				;* brif found
			xor cx,cx				;* return -1
		retcx:
			dec cx
			mov iwRet,cx
			pop di
		}

		return iwRet;
	}
#endif 
	BYTE FAR* pCompare = m_pData + offset;	// points to the value to compare
	int nIndex = 0;

	if (cbData == sizeof(WORD)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(WORD FAR*)pCompare == *(WORD FAR*)pData)
				return nIndex;
		}
	} else if (cbData == sizeof(LONG)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(LONG FAR*)pCompare == *(LONG FAR*)pData)
				return nIndex;
		}
	} else {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (_fmemcmp(pCompare, pData, cbData) == 0)
				return nIndex;
		}
	}

	return -1;
}


/////////////////////////////////////////////////////////////////////////////


void CArrayFValue::AssertValid() const
{
#ifdef _DEBUG
	if (m_pData == NULL)
	{
		Assert(m_nSize == 0);
		Assert(m_nMaxSize == 0);
	}
	else
	{
		Assert(m_nSize <= m_nMaxSize);
		Assert((long)m_nMaxSize * m_cbValue <= SIZE_T_MAX);    // no overflow
		Assert(!IsBadReadPtr(m_pData, m_nMaxSize * m_cbValue));
	}

	// some collections live as global variables in the libraries, but 
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
	Assert(m_memctx == MEMCTX_SHARED || CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\clstub16.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       clstub16.cxx
//
//  Contents:   32->16 bit call forwarding stub
//
//  History:    25-Feb-93       DrewB   Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CallStub16, public
//
//  Synopsis:   Invokes a 16-bit routine on behalf of the 32-bit code
//
//  Arguments:  [pcd] - Data describing the call to be made
//
//  Returns:    Appropriate status code
//
//  History:    18-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD __loadds FAR PASCAL CallStub16(LPCALLDATA pcd)
{
    DWORD dwRes;
    DWORD pfn;
    WORD cbStack;
    DWORD pvStack;
    
    thkAssert(pcd != NULL);

    pfn = pcd->vpfn;
    cbStack = (WORD)pcd->cbStack;
    pvStack = pcd->vpvStack16;

    thkDebugOut((DEB_ITRACE, "In CallStub16(%08lX, %u, %08lX)\n",
                 pfn, cbStack, pvStack));
    
    // Check for wildly out-of-range stack sizes
    thkAssert(cbStack < 0x100);

    // Make sure that the stack size is even to
    // maintain alignment and allow free use of movsw
    thkAssert((cbStack & 1) == 0);
    
    __asm
    {
        // Make space on the real stack for the stack given to us from 32-bits
        sub sp, cbStack

        // Simple sanity checks on new stack pointer
        jc StackOverflow
        cmp sp, 512
        jb StackOverflow

        // Copy pvStack to the real stack
        push ds
        push si
        push es
        push di

        mov ds, WORD PTR pvStack+2
        mov si, WORD PTR pvStack
        
        mov ax, ss
        mov es, ax
        mov di, sp
        // Skip over saved registers
        add di, 8

        mov cx, cbStack
        shr cx, 1
        cld        
        rep movsw

        pop di
        pop es
        pop si
        pop ds

        // Call the routine
        call DWORD PTR pfn
        
        jmp End

    StackOverflow:
        // E_OUTOFMEMORY
        mov dx, 8000h
        mov ax, 0002h
        
    End:
        mov WORD PTR dwRes, ax
        mov WORD PTR dwRes+2, dx
        
        add sp, cbStack
    }

    thkDebugOut((DEB_ITRACE, "Out CallStub16: return %ld\n",dwRes));

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\makefile.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!include $(NTMAKEENV)\makefile.plt

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif


!if "$(OPST)" == ""
!error OPSTR must be defined [chic|dayt]
!endif

OUTNUL= 1>nul 2>nul

# !if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
# OBJDIR = objd$(OPST)
# !else
# OBJDIR = objr$(OPST)
# !endif
OBJDIR=$(_OBJ_DIR)\$(TARGET_DIRECTORY)

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR
#
# JohnDoty:
# The build will break with $(O) has a new range of supported types.
# This sucks.  However, I don't think I can do this correctly.
#
!if "$(OBJDIR)" == "obj\i386"
OBJFILES = $(OBJFILES:.\=obj\i386\)
RESFILES = $(RESFILES:.\=obj\i386\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif
BLDKEEP=        KEEP

!ifndef OLEDIR
OLEDIR=..\..\..
!endif
OLETHUNK= $(OLEDIR)\olethunk
OLE16= $(OLETHUNK)\ole16

!if "$(OPST)" == "chic"
RCINC = $(RCINC) -i..\inc\chicago -i..\inc
!else
RCINC = $(RCINC) -i$(OLE16)\inc
!endif
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(SDK_INC_PATH)

PATH    = $(OLE16)\tools;$(PATH)
LINK    = link16
#
#  We need to mark our Windows 95 components as version 4.0.
#
!if "$(OPST)" == "chic"
RCT     = rc_chic -40
!else
RCT     = rc16
!endif
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = $(DEFINES) -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -Alfw $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if ("$(NTDEBUGTYPE)" == "windbg") || ("$(NTDEBUGTYPE)" == "both")
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip -DDBG=1 -DDEVL=1
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs -DDBG=0 -DDEVL=1
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RCT)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RCT) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\comlocal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       COMLOCAL.CXX    (16 bit target)
//
//  Contents:   CompObj APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"

#include "call32.hxx"
#include "apilist.hxx"

UINT v_pidHighWord = 1;                         // incremented each time used
IMalloc FAR* v_pMallocShared = NULL; // is not addrefed

// Note: bug 3698
// MsPub is not calling CoInitialize befor calling OpenStorage to
// preview templates. This pointer has an addref!
// When this pointer is not NULL CoGetMalloc was called prior to CoInitialize
// The pointer is transfered as soon as CoInitialize is called by any task.
IMalloc FAR* v_pMallocPreShared = NULL;
BOOL SetupSharedAllocator(Etask FAR& etask);


//+---------------------------------------------------------------------------
//
//  Function:   TaskAlloc, private
//
//  Synopsis:   Allocates task memory
//
//  Arguments:  [cb] - Number of bytes to allocate
//
//  Returns:    Pointer to memory or NULL
//
//  History:    03-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

LPVOID __loadds FAR PASCAL TaskAlloc(ULONG cb)
{
    HRESULT     hr;
    LPMALLOC    lpMalloc = NULL;
    LPVOID      lpv;

    hr = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (FAILED(GetScode(hr)) )
    {
        lpv = NULL;
    }
    else
    {
        thkAssert(lpMalloc != NULL && "CoGetMalloc pMalloce is NULL\n");
        lpv = lpMalloc->Alloc(cb);
        lpMalloc->Release();
    }

    return lpv;
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree, private
//
//  Synopsis:   Free task memory
//
//  Arguments:  [pv] - Memory
//
//  History:    03-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

void __loadds FAR PASCAL TaskFree(LPVOID pv)
{
    HRESULT     hr;
    LPMALLOC    lpMalloc;

    hr = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (SUCCEEDED(GetScode(hr)))
    {
        lpMalloc->Free(pv);
        lpMalloc->Release();
    }
}


#if defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   IsProcessIn32Context, private
//
//  Synopsis:   Returns true if current process is 32-bits.
//
//  Arguments:  None.
//
//  History:    03-Jan-95       KentCe  Created
//
//  Remarks:    This function takes advantage of internal Chicago data
//              structures.  No other method available.
//
//----------------------------------------------------------------------------

BOOL IsProcessIn32Context(void)
{
    LPBYTE pTaskFlag;


    //
    //  Create a pointer to the 0x16 byte of the task structure.
    //
    pTaskFlag = (LPBYTE)MAKELONG(0x16, GetCurrentTask());

    //
    //  Bit 4 (0x10) is only true when we are a 32-bit process.
    //
    if (*pTaskFlag & 0x10)
        return TRUE;

    return FALSE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     SetupSharedAllocator
//
//  Synopsis:   Allocats the shared allocator and
//              initializes the etask shared allocator
//
//  Arguments:  [etask] --
//
//  Returns:
//
//  History:    2-03-95   JohannP (Johann Posch)   Created
//
//  Notes:      call by CoInitialize and DllEntryPoint
//
//----------------------------------------------------------------------------
BOOL SetupSharedAllocator(Etask FAR& etask)
{
    // we must ensure we have a shared allocator now since that is where the
    // etask map wiil be stored; if another process already created it, use it;
    // this is so we always use the same shared pool of memory for all
    // processes (so the DidAlloc method returns 1 for the same call from
    // different process); the pointer refers to shared memory within
    // the blocks managed by the IMalloc implementation and the
    // vtable is always valid on Windows; the global pointer carries
    // no ref count on its own; changes might be requires on
    // other platforms.
    if (v_pMallocPreShared != NULL)
    {
        // Note: fix for bug 3698;l MsPub not calling CoInitialize
        // transfer addref from preshared to task entry
        etask.m_pMallocShared = v_pMallocPreShared;
        v_pMallocShared = v_pMallocPreShared;
        v_pMallocPreShared = NULL;
    }
    else if (v_pMallocShared != NULL)
    {
        (etask.m_pMallocShared = v_pMallocShared)->AddRef();
    }
    else
    {
        // sets pMalloc to NULL on error
        CoCreateStandardMalloc(MEMCTX_SHARED, &etask.m_pMallocShared);
        v_pMallocShared = etask.m_pMallocShared;
        thkAssert(v_pMallocShared != NULL && "SetupSharedAllocator failed!");
    }
    return (v_pMallocShared != NULL) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              3-08-94   BobDay    Added code from \\ole\slm\...\compobj.cpp
//
//  Notes:
//
//----------------------------------------------------------------------------
// initialize compobj; errors: S_FALSE, E_OUTOFMEMORY
STDAPI  CoInitialize(IMalloc FAR* pMalloc)
{
    LPMALLOC pmlNull = NULL;
    HRESULT hresult;
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, "CoInitialize\n"));
    thkDebugOut((DEB_APIS16, "CoInitilaize called on Process (%X) \n", GetCurrentProcess()));

#if defined(_CHICAGO_)
    //
    //  Prevent 32-bit MPLAYER from loading a 16-bit DLL's which in turns
    //  uses 16-bit OLE2.  We can't handle the condition of a 32-bit process
    //  thunking up thru the 16:32 OLE2 interop layer.  So return an error
    //  and not fault out.
    //
    if (IsProcessIn32Context())
        return ResultFromScode(E_OUTOFMEMORY);

    etask.m_Dllinits = 0;
#endif


    // if already init, bump count and return S_FALSE
    if (   IsEtaskInit(htask, etask)
        && IsValidInterface((etask.m_pMalloc)) )
    {
        if ( etask.m_inits != ETASK_FAKE_INIT )
        {
            etask.m_inits++;
            thkVerify(SetEtask(htask, etask));
            return ResultFromScode(S_FALSE);
        }

        //
        // CoInitialize has been called after we've done a fake call for them
        // we can just take over their allocator and get rid of our fake one.
        //

        if ( pMalloc != NULL )
        {
            etask.m_pMalloc->Release();   // Get rid of the old task allocator
            etask.m_pMalloc = pMalloc;
            etask.m_pMalloc->AddRef();
        }
        else
        {
            //
            // It would be nice if we could assert that the fake task
            // allocator was a default task allocator.  i.e. no operation
            // were really needed!
            //
        }

        //
        // "We need to have a way to clean up any fake calls to
        // CoInitialize.  Should the application go away after using one of
        // the apis that caused us to do a fake CoInitialize in the first
        // place, and should the application exit without really making a
        // call to CoInitialize eventually, then we wouldn't know enough to
        // clean up...  I think this is ok for now.  Most apps do call
        // CoInitialize eventually."
        //
        etask.m_inits = 1;

        thkAssert(etask.m_pMalloc != NULL); // now have task allocator in all cases
        thkVerify(SetEtask(htask, etask));
        return ResultFromScode(S_OK);
    }
#ifdef _CHICAGO_
    else if (etask.m_Dllinits == 0)
    {
        // Note: we might end up here since some app call
        // CoInitialize in LibMain. The call to our DllEntryPoint
        // will follow.
        if (!Call32Initialize())
        {
            return ResultFromScode(E_OUTOFMEMORY);
        }
        etask.m_htask = GetCurrentProcess();
    }
#endif
    // set/create task malloc
    if (pMalloc != NULL)
    {
        VDATEIFACE( pMalloc );
        (etask.m_pMalloc = pMalloc)->AddRef();
    }
    else
    {
        if ((hresult = CoCreateStandardMalloc(MEMCTX_TASK,
                                              &etask.m_pMalloc)) != NOERROR)
            return hresult;
    }
    thkAssert(etask.m_pMalloc != NULL); // now have task allocator in all cases


    // set up the shared allocator
    if (   etask.m_pMallocShared == NULL
        && SetupSharedAllocator(etask) == FALSE)
    {
        etask.m_pMalloc->Release();        // was created or AddRef'd above
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // now have shared allocator in all cases
    thkAssert(etask.m_pMallocShared != NULL);

    // init remaining entries and add entry to table for this app/task pair;
    // leave maps null for now (they are allocated on demand)
    etask.m_pMallocSBlock = NULL;
    etask.m_pMallocPrivate = NULL;
    etask.m_pid = MAKELONG(GetCurrentProcess(),v_pidHighWord++);
    etask.m_inits = 1;
    etask.m_oleinits = 0;
    etask.m_reserved = 0;
    etask.m_pDlls = NULL;
    etask.m_pMapToServerCO = NULL;
    etask.m_pMapToHandlerCO = NULL;
    etask.m_pArraySH = NULL;
    etask.m_pCThrd = NULL;
    etask.m_hwndClip = NULL;
    etask.m_hwndDde = NULL;
    etask.m_punkState = NULL;

    if (!SetEtask(htask, etask))
    {
        ReleaseEtask(NULL, etask);
        thkAssert(0 && "CompObj: CoInitialize SetEtask failed.");
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Initialize the thunk manager for this apartment.
    if (SUCCEEDED(hresult = CallThkMgrInitialize()))
    {
        //
        // Now transition into 32-bit world to give it a chance for
        // initialization at this time.
        //
        // Never pass the 16-bit allocator on to 32-bits
        pMalloc = NULL;
        hresult = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoInitialize),
                                           PASCAL_STACK_PTR(pMalloc) );
    }

    if (FAILED(GetScode(hresult)))
    {
        ReleaseEtask(htask, etask);
    }

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUninitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              10-Mar-94   BobDay  Copied & Merged with compobj.cpp 16-bit
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(void) CoUninitialize(void)
{
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, "CoUninitialize\n"));
    thkDebugOut((DEB_APIS16, "CoUninitilaize called on Process (%X) \n", GetCurrentProcess()));

    if (!IsEtaskInit(htask, etask))
        return;

    // if not last uninit, just decrement count and return.
    if (etask.m_inits != 1)
    {
        //
        // If a fake init, then just ignore as if we haven't ever init'd
        //
        if ( etask.m_inits == ETASK_FAKE_INIT )
        {
            //
            // Some slimy app doesn't call CoInitialize but does eventually
            // call CoUninitialize. Lets find them if they do!
            //
            thkAssert(FALSE &&
                      "CoUninitialize called after fake CoInitialize\n");
        }
        else
        {
            etask.m_inits--;
            thkVerify(SetEtask(htask, etask));
        }
        return ;
    }

    // Some applications pass on module handle of loaded dlls.
    // As a result LibMain and WEP is not called in the same process.
    // To prevent premature unloading of OleThk32.dll call
    // SetReleaseDLL(FALSE)

    SetReleaseDLL(FALSE);

    //
    // Now transition into 32-bit world to give it a chance for
    // initialization at this time.
    //
    CallObjectInWOW(THK_API_METHOD(THK_API_CoUninitialize), NULL );

    // Reset dll unloading - see above
    SetReleaseDLL(TRUE);

    CoFreeAllLibraries();

    //
    // We do not uninitialize the thunk manager at this point. The app may attempt
    // to call additional API's after CoUninitialize. For example, Lotus 1-2-3
    // is known to do this, as is Publisher. The thunk manager will clean up
    // as part of its thread detach.
    //

    // the last thing is to remove the allocator and delete the etask for us;
    // must lookup again in case contents changed.

    if (LookupEtask(htask, etask))
        ReleaseEtask(htask, etask);

    thkDebugOut((DEB_APIS16, "CoUninitilaize on Process (%X) done.\n", GetCurrentProcess()));
    thkDebugOut((DEB_ITRACE, "CoUninitialize exit\n"));

    // Note: some apps check the return value if the void function CoUninitialize
    //       and they fail if it is not NULL like WinOffice Setup 4.3
    //       Please don't take it out.
    _asm mov ax,0;
    _asm mov dx,0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetMalloc, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [dwMemContext] --
//      [ppMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              10-Mar-94   BobDay  Copied & Merged with compobj.cpp 16-bit
//
//  Notes:
//
//----------------------------------------------------------------------------
// return pMalloc for the current task; errors: E_INVALIDARG,
// CO_E_NOTINITIALIZED, E_OUTOFMEMORY (not for task or shared allocators)
STDAPI  CoGetMalloc(DWORD dwContext, IMalloc FAR* FAR* ppMalloc)
{
    Etask etask;
    HTASK htask;

    thkDebugOut((DEB_ITRACE, " CoGetMalloc\n"));

    VDATEPTROUT( ppMalloc, IMalloc FAR* );
    // NOTE: we set *ppMalloc to NULL only in the error cases below

    // MOre work here!
    // need this for the bootstrap case
    if (dwContext == MEMCTX_SHARED)
    {
        if (v_pMallocShared != NULL)
        {
            *ppMalloc = v_pMallocShared;
            goto Exit;
        }
        // pMallocShared is NULL -- CoInitialize was not called yet.
        if (v_pMallocPreShared == NULL)
        {
            CoCreateStandardMalloc(MEMCTX_SHARED, &v_pMallocPreShared);
            if (v_pMallocPreShared != NULL)
            {
                *ppMalloc = v_pMallocPreShared;
                goto Exit;
            }
            else
            {
                *ppMalloc = NULL;
                return ResultFromScode(CO_E_NOTINITIALIZED);
            }
        }
        else
        {
            *ppMalloc = v_pMallocPreShared;
            goto Exit;
        }
    }

    //
    //  Clip Art Gallery will call pStream->Stat before calling CoInitialize.
    //  This causes the thunk logic to allocation 16bit memory which will
    //  fail at this point.  The below code to auto-initialize should this
    //  happen.  (Really just a hack for Clip Art Gallery).
    //
    if (   !IsEtaskInit(htask, etask)
        || !IsValidInterface((etask.m_pMalloc)) )
    {
        if (FAILED(CoInitialize(NULL)))
        {
            *ppMalloc = NULL;
            return ResultFromScode(CO_E_NOTINITIALIZED);
        }

        thkVerify(LookupEtask( htask, etask ));
        etask.m_inits = ETASK_FAKE_INIT;
        thkVerify(SetEtask(htask, etask));
    }

    // shared always available if initialized; no need to handle here
    thkAssert(dwContext != MEMCTX_SHARED);

    if (dwContext == MEMCTX_TASK)
    {
        thkAssert(etask.m_pMalloc != NULL);
        *ppMalloc = etask.m_pMalloc;
    }
    else
    {
#ifdef NOTYET
        // contexts which are delay-created
        IMalloc FAR* FAR* ppMallocStore;

        if (dwContext == MEMCTX_SHAREDBLOCK)
            ppMallocStore = &etask.m_pMallocSBlock;
        else if (dwContext == MEMCTX_COPRIVATE)
            ppMallocStore = &etask.m_pMallocPrivate;
        else
        {
            // invalid context
            *ppMalloc = NULL;
            return ResultFromScode(E_INVALIDARG);
        }

        if (*ppMallocStore == NULL)
        {
            // sets pMalloc to NULL on error
            if (CoCreateStandardMalloc(dwContext, ppMallocStore) != NOERROR)
            {
                *ppMalloc = NULL;
                return ResultFromScode(E_OUTOFMEMORY);
            }

            thkVerify(SetEtask(htask, etask));
        }

        *ppMalloc = *ppMallocStore;
#else
        // invalid context
        thkAssert(!"Unknown memctx in CoGetMalloc");
        *ppMalloc = NULL;
        return ResultFromScode(E_INVALIDARG);
#endif // NOTYET
    }

 Exit:  // have non-null *ppMalloc
    thkAssert(*ppMalloc != NULL);
    (*ppMalloc)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetState, Local
//
//  Synopsis:   Retrieves task-specific state
//
//  Arguments:  [ppunk] - IUnknown pointer to fill in
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DrewB   Created
//
//  Notes:      Private API for OLE automation
//
//----------------------------------------------------------------------------

STDAPI CoGetState(IUnknown FAR * FAR *ppunk)
{
    Etask etask;
    HTASK htask;

    thkDebugOut((DEB_APIS16, "CoGetState called\n"));
    if (IsBadWritePtr(ppunk, sizeof(IUnknown *)))
    {
        thkDebugOut((DEB_APIS16, "CoGetState failed\n"));
        return ResultFromScode(E_INVALIDARG);
    }

    if (!LookupEtask(htask, etask) || etask.m_punkState == NULL )
    {
        *ppunk = NULL;
        thkDebugOut((DEB_APIS16, "CoGetState failed\n"));
        return ResultFromScode(S_FALSE);
    }

    if ( !IsValidInterface((etask.m_punkState)) )
    {
        *ppunk = NULL;
        etask.m_punkState = NULL;
        thkDebugOut((DEB_APIS16, "CoGetState failed (invalid interface)\n"));
        return ResultFromScode(S_FALSE);
    }


    *ppunk = etask.m_punkState;
    etask.m_punkState->AddRef();

    thkDebugOut((DEB_APIS16, "CoGetState done %p\n", *ppunk));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoSetState, Local
//
//  Synopsis:   Sets task-specific state
//
//  Arguments:  [punk] - State to set
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DrewB   Created
//
//  Notes:      Private API for OLE automation
//
//----------------------------------------------------------------------------

STDAPI CoSetState(IUnknown FAR *punk)
{
    Etask etask;
    HTASK htask;
    IUnknown FAR *punkStateOld;

    thkDebugOut((DEB_APIS16, "CoSetState called %p\n", punk));

    if (punk != NULL && !IsValidInterface(punk))
    {
        thkDebugOut((DEB_APIS16, "CoSetState called %p failed\n", punk));
        return ResultFromScode(E_INVALIDARG);
    }

    if (!IsEtaskInit(htask, etask))
    {
        thkDebugOut((DEB_APIS16, "CoSetState called %p failed\n", punk));
        return ResultFromScode(S_FALSE);
    }

    if (punk != NULL)
    {
        punk->AddRef();
    }

    punkStateOld = etask.m_punkState;
    etask.m_punkState = punk;

    thkVerify(SetEtask(htask, etask));

    if (punkStateOld != NULL && IsValidInterface(punkStateOld))
    {
        punkStateOld->Release();
    }

    thkDebugOut((DEB_APIS16, "CoSetState called %p done\n", punk));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetCurrentProcess, Local
//
//----------------------------------------------------------------------------
// returns a unique value for the current task; this routine is
// necessary because htask values from Window get reused periodically.
STDAPI_(DWORD)  CoGetCurrentProcess(void)
{
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_ITRACE, " CoGetCurrentProcess\n"));

    if (!IsEtaskInit(htask, etask))
        return 0;

    return etask.m_pid;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoBuildVersion, Local
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) CoBuildVersion(VOID)
{
    thkDebugOut((DEB_ITRACE, " CoBuildVersion\n"));

    // We must return 23 as our major version number to remain
    // compatible with shipped OLE 2.01
    // OLE 2.01 shipped with minor version 640
    // We return a number slightly higher to differentiate
    // our product while indicating compatibility
    return MAKELONG(700, 23);
}

//+---------------------------------------------------------------------------
//
//  Function:   CoMarshalHresult, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CoMarshalHresult\n"));

    if (!IsValidInterface(pstm))
    {
        hr = ResultFromScode(E_INVALIDARG);
    }
    else
    {
        SCODE sc;
        ULONG cb;

        sc = GetScode(hresult);
        hr = pstm->Write(&sc, sizeof(sc), &cb);
        if (SUCCEEDED(GetScode(hr)) && cb != sizeof(sc))
        {
            hr = ResultFromScode(STG_E_WRITEFAULT);
        }
    }
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnmarshalHresult, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CoUnmarshalHresult\n"));

    if (!IsValidPtrOut(phresult, sizeof(HRESULT)))
    {
        hr = ResultFromScode(E_INVALIDARG);
    }
    else
    {
        *phresult = 0;

        if (!IsValidInterface(pstm))
        {
            hr = ResultFromScode(E_INVALIDARG);
        }
        else
        {
            SCODE sc;
            ULONG cb;

            hr = pstm->Read(&sc, sizeof(sc), &cb);
            if (SUCCEEDED(GetScode(hr)))
            {
                if (cb != sizeof(sc))
                {
                    hr = ResultFromScode(STG_E_READFAULT);
                }
                else
                {
                    *phresult = ResultFromScode(sc);
                }
            }
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEqualGUID, Local
//
//  History:    Taken straight from OLE2 sources
//
//----------------------------------------------------------------------------
#pragma intrinsic(_fmemcmp)
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    //thkDebugOut((DEB_ITRACE, "IsEqualGUID\n"));

    return !_fmemcmp(&rguid1, &rguid2, sizeof(GUID));
}
#pragma function(_fmemcmp)

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

//+---------------------------------------------------------------------------
//
//  Function:   HexStringToDword, private
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

static BOOL HexStringToDword(LPCSTR FAR& lpsz, DWORD FAR& Value, int cDigits,
                             char chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
        {
            Value = (Value << 4) + *lpsz - '0';
        }
        else if (*lpsz >= 'A' && *lpsz <= 'F')
        {
            Value = (Value << 4) + *lpsz - 'A' + 10;
        }
        else if (*lpsz >= 'a' && *lpsz <= 'f')
        {
            Value = (Value << 4) + *lpsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }
    if (chDelim != 0)
    {
        return *lpsz++ == chDelim;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GUIDFromString, private
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{')
        return FALSE;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '}'))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromCLSID, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

#define CLSIDSTR_MAX (GUIDSTR_MAX)

STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz)
{
    SCODE sc;
    char *psz;

    thkDebugOut((DEB_ITRACE, "StringFromCLSID\n"));

    psz = NULL;
    do
    {
        if (!IsValidPtrOut(lplpsz, sizeof(LPSTR)))
        {
            sc = E_INVALIDARG;
            break;
        }
        *lplpsz = NULL;

        if (!IsValidPtrIn(&rclsid, sizeof(CLSID)))
        {
            sc = E_INVALIDARG;
            break;
        }

        psz = (char *)TaskAlloc(CLSIDSTR_MAX);
        if (psz == NULL)
        {
            sc = E_OUTOFMEMORY;
            break;
        }

        if (StringFromGUID2(rclsid, psz, CLSIDSTR_MAX) == 0)
        {
            sc = E_INVALIDARG;
            TaskFree(psz);
            break;
        }

   *lplpsz = psz;
        sc = S_OK;
    } while (FALSE);

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromIID, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz)
{
    SCODE sc;
    char *psz;

    thkDebugOut((DEB_ITRACE, "StringFromIID\n"));

    do
    {
        if (!IsValidPtrOut(lplpsz, sizeof(LPSTR)))
        {
            sc = E_INVALIDARG;
            break;
        }
        *lplpsz = NULL;

        if (!IsValidPtrIn(&rclsid, sizeof(IID)))
        {
            sc = E_INVALIDARG;
            break;
        }

        psz = (char *)TaskAlloc(GUIDSTR_MAX);
        if (psz == NULL)
        {
            sc = E_OUTOFMEMORY;
            break;
        }

        if (StringFromGUID2(rclsid, psz, GUIDSTR_MAX) == 0)
        {
            sc = E_INVALIDARG;
            TaskFree(psz);
            break;
        }

   *lplpsz = psz;
        sc = S_OK;
    } while (FALSE);

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   IIDFromString, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid)
{
    SCODE sc;

    thkDebugOut((DEB_ITRACE, "IIDFromString\n"));

    sc = S_OK;
    if (!IsValidPtrOut(lpiid, sizeof(IID)))
    {
        sc = E_INVALIDARG;
    }
    else if (lpsz == NULL)
    {
        *lpiid = IID_NULL;
    }
    else if (!IsValidPtrIn(lpsz, sizeof(LPSTR)))
    {
        sc = E_INVALIDARG;
    }
    else if (!GUIDFromString(lpsz, lpiid))
    {
        sc = CO_E_IIDSTRING;
    }

    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromGUID2, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax)
{
    thkDebugOut((DEB_ITRACE, "StringFromGUID2\n"));

    if (cbMax < GUIDSTR_MAX)
    {
        return 0;
    }

    wsprintf(lpsz, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
             rguid.Data1, rguid.Data2, rguid.Data3,
             rguid.Data4[0], rguid.Data4[1],
             rguid.Data4[2], rguid.Data4[3],
             rguid.Data4[4], rguid.Data4[5],
             rguid.Data4[6], rguid.Data4[7]);

    return GUIDSTR_MAX;
}

// The following two APIs are now macros but must still be exported
// so use PASCAL-form names to avoid problems with the macros

//+---------------------------------------------------------------------------
//
//  Function:   GETSCODE, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI_(SCODE) GETSCODE(HRESULT hr)
{
    return GetScode(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   RESULTFROMSCODE, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI RESULTFROMSCODE(SCODE sc)
{
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:   PropagateResult, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew)
{
    thkDebugOut((DEB_ITRACE, "PropagateResult\n"));

    return (HRESULT)((scNew & 0x800FFFFF) | ((DWORD)hrPrev & 0x7FF00000)
                     + 0x100000);
}

//+---------------------------------------------------------------------------
//
//  Function:   FnAssert, Local
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------

#if DBG == 1
static char lpBuffer[512];
static char lpLocBuffer[256];
#endif

STDAPI FnAssert( LPSTR lpstrExpr,
                 LPSTR lpstrMsg,
                 LPSTR lpstrFileName,
                 UINT iLine )
{
#if DBG == 1
    int iResult;

    wsprintf(lpBuffer, "Assertion \"%s\" failed! %s", lpstrExpr, lpstrMsg);
    wsprintf(lpLocBuffer, "File %s, line %d; (A=exit; R=break; I=continue)",
             lpstrFileName, iLine);
    iResult = MessageBox(NULL, lpLocBuffer, lpBuffer,
                         MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);

    if (iResult == IDRETRY)
    {
        DebugBreak();
    }
    else if (iResult == IDABORT)
    {
        CoFreeAllLibraries();
        FatalAppExit(0, "Assertion failure");
    }
#endif
    return NOERROR;
}

//
// NOTE- These APIs are exported by the .DEF file, but are not documented,
// nor is there any code in the 16-bit world to deal with them.  Each of these
// needs to be investigated to determine what we need to do to implement them.
//
// LRPCDISPATCH
// REMCONNECTTOOBJECT
// REMCREATEREMOTEHANDLER
// REMALLOCOID
// LRPCFREEMONITORDATA
// TIMERCALLBACKPROC
// COSETACKSTATE
// COGETCLASSEXT
// LRPCCALL
// LRPCREGISTERMONITOR
// CLSIDFROMOLE1CLASS
// COOPENCLASSKEY
// LRPCGETTHREADWINDOW
// LRPCREVOKEMONITOR
// COHANDLEINCOMINGCALL
// REMGETINFOFORCID
//
// The below stubs probably don't clean up the stack properly either!!!

#define UNDEFINED_DEF_ENTRY(x)  STDAPI x ( void ) \
                                   { return ResultFromScode(E_NOTIMPL); }


UNDEFINED_DEF_ENTRY( LRPCDISPATCH            )
UNDEFINED_DEF_ENTRY( REMCONNECTTOOBJECT      )
UNDEFINED_DEF_ENTRY( REMCREATEREMOTEHANDLER  )
UNDEFINED_DEF_ENTRY( REMALLOCOID             )
UNDEFINED_DEF_ENTRY( LRPCFREEMONITORDATA     )
UNDEFINED_DEF_ENTRY( TIMERCALLBACKPROC       )
UNDEFINED_DEF_ENTRY( COSETACKSTATE           )
UNDEFINED_DEF_ENTRY( COGETCLASSEXT           )
UNDEFINED_DEF_ENTRY( LRPCCALL                )
UNDEFINED_DEF_ENTRY( LRPCREGISTERMONITOR     )
UNDEFINED_DEF_ENTRY( CLSIDFROMOLE1CLASS      )
UNDEFINED_DEF_ENTRY( COOPENCLASSKEY          )
UNDEFINED_DEF_ENTRY( LRPCGETTHREADWINDOW     )
UNDEFINED_DEF_ENTRY( LRPCREVOKEMONITOR       )
UNDEFINED_DEF_ENTRY( COHANDLEINCOMINGCALL    )
UNDEFINED_DEF_ENTRY( REMGETINFOFORCID        )
UNDEFINED_DEF_ENTRY( OLE1CLASSFROMCLSID2     )
UNDEFINED_DEF_ENTRY( REMLOOKUPSHUNK          )
UNDEFINED_DEF_ENTRY( REMFREEOID              )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\comguid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ComGUID.cxx	(16 bit target)
//
//  Contents:	GUIDs for CompObj 
//
//  Functions:	
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "initguid.h"
#include "coguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\comdthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Comdthk.c   (16 bit target)
//
//  Contents:   CompObj Directly Thunked APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//              07-Mar-94 BobDay     Moved into COMTHUNK.C from COMAPI.CXX
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid);

//+---------------------------------------------------------------------------
//
//  Function:   Straight thunk routines
//
//  Synopsis:   The following routines do not need to do any special
//              processing on the 16-bit side so they thunk straight
//              through
//
//  History:    18-Feb-94       JohannP Created
//
//  Notes:      "Review to ensure these don't have to do any work"
//              15-Feb-2000  I'm pretty sure they don't.  JohnDoty
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromString, Remote
//
//  History:    Straight from OLE2 sources
//
//----------------------------------------------------------------------------
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid)
{
    HRESULT hr;

    thkDebugOut((DEB_ITRACE, "CLSIDFromString\n"));

    //
    //	The 16-bit OLE2 application "Family Tree Maker" always passes a bad
    //	string to CLSIDFromString.  We need to make sure we fail in the exact
    //	same way with the interop layer.  This will also provide a speed
    //	improvement since we only need to remote to the 32bit version of
    //	CLSIDFromString when the string provided does not start with '{'.
    //
    if (lpsz[0] == '{')
	return GUIDFromString(lpsz, pclsid)
		? NOERROR : ResultFromScode(CO_E_CLASSSTRING);

    // Note: Corel calls this function prior to calling
    //       CoInitialize so use CheckInit

    return (HRESULT)CallObjectInWOWCheckInit(THK_API_METHOD(THK_API_CLSIDFromString),
                                             PASCAL_STACK_PTR(lpsz));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [dwClsContext] --
//      [pvReserved] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                        REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, " CoGetClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetClassObject),
                                    PASCAL_STACK_PTR(rclsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [pUnk] --
//      [dwClsContext] --
//      [flags] --
//      [lpdwRegister] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                             DWORD dwClsContext, DWORD flags,
                             LPDWORD lpdwRegister)
{
    thkDebugOut((DEB_ITRACE, " CoRegisterClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRegisterClassObject),
                                    PASCAL_STACK_PTR(rclsid));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [dwRegister] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRevokeClassObject(DWORD dwRegister)
{
    thkDebugOut((DEB_ITRACE, " CoRevokeClassObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRevokeClassObject),
                                    PASCAL_STACK_PTR(dwRegister) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoMarshalInterface, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [riid] --
//      [pUnk] --
//      [dwDestContext] --
//      [pvDestContext] --
//      [mshlflags] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                          DWORD dwDestContext, LPVOID pvDestContext,
                          DWORD mshlflags)
{
    thkDebugOut((DEB_ITRACE, " CoMarshalInterface\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoMarshalInterface),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnmarshalInterface, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, "CoUnmarshalInterface\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoUnmarshalInterface),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoReleaseMarshalData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoReleaseMarshalData(LPSTREAM pStm)
{
    thkDebugOut((DEB_ITRACE, "CoReleaseMarshalData\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoReleaseMarshalData),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoDisconnectObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//      [dwReserved] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved)
{
    thkDebugOut((DEB_ITRACE, "CoDisconnectObject\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoDisconnectObject),
                                    PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoLockObjectExternal, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//      [fLock] --
//      [fLastUnlockReleases] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock,
                            BOOL fLastUnlockReleases)
{
    thkDebugOut((DEB_ITRACE, "CoLockObjectExternal\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoLockObjectExternal),
                                    PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetStandardMarshal, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [riid] --
//      [pUnk] --
//      [dwDestContext] --
//      [pvDestContext] --
//      [mshlflags] --
//      [ppMarshal] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                            DWORD dwDestContext, LPVOID pvDestContext,
                            DWORD mshlflags,
                            LPMARSHAL FAR* ppMarshal)
{
    thkDebugOut((DEB_ITRACE, "CoGetStandardMarshal\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetStandardMarshal),
                                    PASCAL_STACK_PTR(riid));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoIsHandlerConnected, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk)
{
    thkDebugOut((DEB_ITRACE, "CoIsHandlerConnected\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoIsHandlerConnected),
                                 PASCAL_STACK_PTR(pUnk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoCreateInstance, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [pUnkOuter] --
//      [dwClsContext] --
//      [riid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv)
{
    thkDebugOut((DEB_ITRACE, "CoCreateInstance\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoCreateInstance),
                                    PASCAL_STACK_PTR(rclsid) );
}



//+---------------------------------------------------------------------------
//
//  Function:   CoIsOle1Class, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid)
{
    thkDebugOut((DEB_ITRACE, "CoIsOle1Class\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoIsOle1Class),
                                 PASCAL_STACK_PTR(rclsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ProgIDFromCLSID, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [lplpszProgID] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ProgIDFromCLSID(REFCLSID clsid, LPSTR FAR* lplpszProgID)
{
    thkDebugOut((DEB_ITRACE, "ProgIDFromCLSID\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ProgIDFromCLSID),
                                    PASCAL_STACK_PTR(clsid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgID, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszProgID] --
//      [lpclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CLSIDFromProgID(LPCSTR lpszProgID, LPCLSID lpclsid)
{
    thkDebugOut((DEB_ITRACE, "CLSIDFromProgID\n"));

    // Note: Word 6 calls this function prior to calling
    //       CoInitialize so use CheckInit

    return (HRESULT)CallObjectInWOWCheckInit(THK_API_METHOD(THK_API_CLSIDFromProgID),
                                             PASCAL_STACK_PTR(lpszProgID) );
}


//+---------------------------------------------------------------------------
//
//  Function:   CoCreateGuid, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pguid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateGuid(GUID FAR *pguid)
{
    thkDebugOut((DEB_ITRACE, "CoCreateGuid\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoCreateGuid),
                                    PASCAL_STACK_PTR(pguid));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoFileTimeToDosDateTime, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpFileTime] --
//      [lpDosDate] --
//      [lpDosTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoFileTimeToDosDateTime(FILETIME FAR* lpFileTime,
                                      LPWORD lpDosDate, LPWORD lpDosTime)
{
    thkDebugOut((DEB_ITRACE, "CoFileTimeToDosDateTime\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoFileTimeToDosDateTime),
                                 PASCAL_STACK_PTR(lpFileTime));
}


//+---------------------------------------------------------------------------
//
//  Function:   CoDosDateTimeToFileTime, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [nDosDate] --
//      [nDosTime] --
//      [lpFileTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) CoDosDateTimeToFileTime(WORD nDosDate, WORD nDosTime,
                                      FILETIME FAR* lpFileTime)
{
    thkDebugOut((DEB_ITRACE, "CoDosDateTimeToFileTime\n"));
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_CoDosDateTimeToFileTime),
                                 PASCAL_STACK_PTR(nDosDate));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoFileTimeNow, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpFileTime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoFileTimeNow(FILETIME FAR* lpFileTime)
{
    thkDebugOut((DEB_ITRACE, "CoFileTimeNow\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoFileTimeNow),
                                    PASCAL_STACK_PTR(lpFileTime));
}

//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterMessageFilter, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpMessageFilter] --
//      [lplpMessageFilter] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoRegisterMessageFilter(LPMESSAGEFILTER lpMessageFilter,
                               LPMESSAGEFILTER FAR* lplpMessageFilter)
{
    thkDebugOut((DEB_ITRACE, "CoRegisterMessageFilter\n"));

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoRegisterMessageFilter),
                                    PASCAL_STACK_PTR(lpMessageFilter) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoGetTreatAsClass, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [pClsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew)
{
    thkDebugOut((DEB_ITRACE, "CoGetTreatAsClass\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoGetTreatAsClass),
                                    PASCAL_STACK_PTR(clsidOld) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoTreatAsClass, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [clsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
    thkDebugOut((DEB_ITRACE, "CoTreatAsClass\n"));
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CoTreatAsClass),
                                    PASCAL_STACK_PTR(clsidOld) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\cpkt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       CPKT.CXX
//
//  Contents:   CPkt implementation for RPC/LRPC
//
//  Functions:
//
//  History:    30-Mar-94   BobDay  Adapted from 16-bit OLE2.0, CPKT.CPP
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>
#include "rpc16.hxx"
#include "comlocal.hxx"

//
// Standard IUnknown method.  Not used but need to be supported to comply
// with the IUnknown.
//

STDMETHODIMP CPkt::QueryInterface(
    REFIID         iidInterface,
    void FAR* FAR* ppvObj )
{
    HRESULT hresult;

    // Three interfaces supported (each, and extension of the previous):
    //    IUnknown, IStream, ICPkt

    if ( (iidInterface == IID_CPkt ||
          iidInterface == IID_IStream ||
          iidInterface == IID_IUnknown   )) {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
        hresult = NOERROR;
    }
    else {                 // Not accessible or unsupported interface
        *ppvObj = NULL;
        hresult = ResultFromScode(E_NOINTERFACE);
    }

    return hresult;
}

//
// Called when CPkt is referenced by an additional pointer.
//

STDMETHODIMP_(ULONG) CPkt::AddRef(void)
{
    return ++m_refs;
}

//
// Called when a pointer to this CPkt is discarded
//

STDMETHODIMP_(ULONG) CPkt::Release(void)
{
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_rom16.Buffer != NULL)
    {
	TaskFree(m_rom16.Buffer);
    }

    delete this; // Free storage

    return 0;
}


STDMETHODIMP CPkt::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
    HRESULT hresult = NOERROR;
    ULONG cbRead = cb;


    if (pcbRead != NULL)
    {
        *pcbRead = 0;
    }

    if (cbRead + m_pos > m_rom16.cbBuffer) {
	if (m_pos < m_rom16.cbBuffer)
        {
	    cbRead = m_rom16.cbBuffer - m_pos;
        }
	else
        {
	    cbRead = 0;
        }
        hresult = ResultFromScode(E_UNSPEC); // PKT (tried to read passed EOS)
    }

    if ( cbRead != 0 )
    {
        hmemcpy(pb,(LPSTR)m_rom16.Buffer + m_pos, cbRead);
        m_pos += cbRead;
    }

    if (pcbRead != NULL)
    {
        *pcbRead = cbRead;
    }

    return hresult;
}


STDMETHODIMP CPkt::Write(void const HUGEP* pb, ULONG cb, ULONG FAR* pcbWritten)
{
    HRESULT hresult = NOERROR;
    ULONG cbWritten = cb;


    if (pcbWritten != NULL)
    {
        *pcbWritten = 0;
    }

    if (cbWritten + m_pos > m_rom16.cbBuffer)
    {
        ULARGE_INTEGER ularge_integer;

        ULISet32(ularge_integer,m_pos+cbWritten);

        hresult = SetSize(ularge_integer);
        if (hresult != NOERROR)
        {
            return hresult;
        }
    }

    if ( cbWritten != 0 )
    {
        hmemcpy((LPSTR)m_rom16.Buffer + m_pos,pb, cbWritten);
        m_pos += cbWritten;
    }

    if (pcbWritten != NULL)
    {
        *pcbWritten = cbWritten;
    }

    return hresult;
}

STDMETHODIMP CPkt::Seek(LARGE_INTEGER dlibMoveIn, DWORD dwOrigin, ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = NOERROR;
    LONG dlibMove   = dlibMoveIn.LowPart;
    ULONG cbNewPos  = dlibMove;


    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, m_pos);
    }

    switch(dwOrigin)
    {
        case STREAM_SEEK_SET:
            if (dlibMove >= 0)
            {
                m_pos = dlibMove;
            }
            else
            {
                hresult = ResultFromScode(E_UNSPEC); // PKT (Invalid seek)
            }
        break;

        case STREAM_SEEK_CUR:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
            {
                m_pos += dlibMove;
            }
            else
            {
                hresult = ResultFromScode(E_UNSPEC); // PKT (Invalid seek)
            }
        break;

        case STREAM_SEEK_END:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_rom16.cbBuffer))
            {
                m_pos = m_rom16.cbBuffer + dlibMove;
            }
            else
            {
                hresult = ResultFromScode(E_UNSPEC); // PKT (Invalid seek)
            }
        break;

        default:
            hresult = ResultFromScode(E_UNSPEC); // PKT (Invalid seek mode)
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition,m_pos);
    }

    return hresult;
}

//
// Note: if the cpkt data needs to be reallocate extra space
//       
#define CBEXTRABYTES 128

STDMETHODIMP CPkt::SetSize(ULARGE_INTEGER cb)
{
    HRESULT hresult = NOERROR;
    ULONG   ulNewSize;

    if (m_opd.cbSize && m_opd.cbSize > cb.LowPart) {
    	m_rom16.cbBuffer = cb.LowPart;
        goto Exit;
	}

    if (m_rom16.cbBuffer == cb.LowPart)
        goto Exit;

    ulNewSize = cb.LowPart + CBEXTRABYTES;
    TaskFree(m_rom16.Buffer);
    m_rom16.Buffer = TaskAlloc(ulNewSize);
    if ( m_rom16.Buffer == NULL )
    {
        m_rom16.cbBuffer = 0;
        m_opd.cbSize = 0;
        hresult = ResultFromScode(S_OOM);
        goto Exit;
    }

    m_rom16.cbBuffer = cb.LowPart;

    m_opd.cbSize = ulNewSize;

Exit:
    return hresult;
}


STDMETHODIMP CPkt::CopyTo(IStream FAR *pstm, ULARGE_INTEGER cb,
                                   ULARGE_INTEGER FAR * pcbRead, ULARGE_INTEGER FAR * pcbWritten)
{
   return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPkt::Commit(DWORD grfCommitFlags)
{
    return ResultFromScode(E_NOTIMPL);
}



STDMETHODIMP CPkt::Revert(void)
{
    return ResultFromScode(E_NOTIMPL);
}



STDMETHODIMP CPkt::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER, DWORD dwLockType)
{
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CPkt::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return ResultFromScode(E_NOTIMPL);
}



STDMETHODIMP CPkt::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
    return ResultFromScode(E_NOTIMPL);
}



STDMETHODIMP CPkt::Clone(THIS_ IStream FAR * FAR *ppstm)
{
    return ResultFromScode(E_NOTIMPL);
}

//
// Create untyped CPkt. Used by other create functions (is private)
//


CPkt FAR* CPkt::Create(IUnknown FAR *pUnk, DWORD cbExt)
{
    CPkt FAR* pCPkt;

    pCPkt = new CPkt;

    if (pCPkt == NULL) 
    	return NULL;

    pCPkt->m_rom16.Buffer = TaskAlloc( cbExt );
    if ( pCPkt->m_rom16.Buffer == NULL )
    {
        delete pCPkt;
        return NULL;
    }

    pCPkt->m_rom16.cbBuffer = cbExt;
    pCPkt->m_opd.cbSize     = cbExt;

    return pCPkt;
}

//
// CPkt used to make a call
//

CPkt FAR* CPkt::CreateForCall(
    IUnknown FAR *pUnk,
    REFIID       iid,
    int          iMethod,
    BOOL         fSend,
    BOOL         fAsync,
    DWORD        size     )
{
    CPkt FAR *   pCPkt;

    if (fAsync && fSend) {
        fSend = FALSE;
        //Assert(0,"Async CPkt with fSend == TRUE not implemented");
        //return NULL;
    }

    pCPkt = CPkt::Create(pUnk, size);
    if (pCPkt == NULL)
    {
        return NULL;
    }

    pCPkt->m_opd.iid = iid;

    pCPkt->m_rom16.iMethod = iMethod;
    pCPkt->m_rom16.rpcFlags = 0;

    if ( fSend )
    {
        pCPkt->m_rom16.rpcFlags |= RPCFLG_INPUT_SYNCHRONOUS;
    }

    if ( fAsync )
    {
        pCPkt->m_rom16.rpcFlags |= RPCFLG_ASYNCHRONOUS;
    }
    return pCPkt;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetRpcChannelBuffer, public
//
//  Synopsis:   Sets the RpcChannelBuffer to call when CallRpcChannelBuffer
//              is called.
//
//  Arguments:  [prcb] - IRpcChannelBuffer interface
//
//  Returns:    NOERROR always
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPkt::SetRpcChannelBuffer(
    CRpcChannelBuffer FAR * prcb )
{
    m_prcb = prcb;

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallRpcChannelBuffer, public
//
//  Synopsis:   Calls the RpcChannelBuffer with the parameters accumulated in
//              the CPkt buffer.
//
//  Arguments:  none
//
//  Returns:    HRESULT for success/failure of call or procedure
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPkt::CallRpcChannelBuffer( void )
{
    HRESULT         hresult;
    RPCOLEMESSAGE16 rom16;
    ULONG           ulStatus;

    //
    // Allocate a buffer from the Channel
    //
    memset(&rom16, 0, sizeof(rom16));       // Zero out everything

    rom16.cbBuffer = m_rom16.cbBuffer;      // Tell it how big we want it!
    rom16.rpcFlags = m_rom16.rpcFlags;
    rom16.iMethod  = m_rom16.iMethod;

    hresult = m_prcb->GetBuffer( &rom16, m_opd.iid );
    if ( FAILED(hresult) )
    {
        return hresult;
    }

    //
    // For speed, we could get away without doing the copy here
    // by passing the buffer to the 32-bit world in the GetBuffer
    // call above.
    //
    hmemcpy( rom16.Buffer, m_rom16.Buffer, m_rom16.cbBuffer );

    //
    // Call the channel
    //
    ulStatus = 0;
    hresult = m_prcb->SendReceive( &rom16, &ulStatus );
    if ( SUCCEEDED(hresult) )
    {
        ULARGE_INTEGER ularge_integer;

        hresult = (HRESULT)ulStatus;

        //
        // Copy the buffer back!
        //
        ULISet32(ularge_integer,rom16.cbBuffer);
        SetSize( ularge_integer );      // Make it big enough!

        hmemcpy( m_rom16.Buffer, rom16.Buffer, rom16.cbBuffer );
    }

    //
    // Free up the buffer
    //
    m_prcb->FreeBuffer( &rom16 );

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\compobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ComAPIs.cxx     (16 bit target)
//
//  Contents:   CompObj APIs
//
//  Functions:
//
//  History:    16-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop
#include <ole2sp.h>
#include <olecoll.h>
#include <map_kv.h>
#include <stdlib.h>

#include "map_htsk.h"
#include "etask.hxx"
#include "call32.hxx"
#include "apilist.hxx"

// Opmodes should be removed
// They don't seem to be necessary any more

DECLARE_INFOLEVEL(thk1);
DECLARE_INFOLEVEL(Stack1);

CMapHandleEtask NEAR v_mapToEtask(MEMCTX_SHARED);

#if defined(_CHICAGO_)
Etask getask = {0,0,0,0,0,0,0,0};
extern IMalloc FAR* v_pMallocShared; // is not addrefed
BOOL SetupSharedAllocator(Etask FAR& etask);
STDAPI_(BOOL) RemoveEtask(HTASK FAR& hTask, Etask FAR& etask);
#endif // _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   LibMain, public
//
//  Synopsis:   DLL initialization function
//
//  Arguments:  [hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:    One for success, zero for failure
//
//  History:    21-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];

#ifdef _CHICAGO_
BOOL fSSOn = TRUE;
#endif // _CHICAGO_

#endif

extern "C" int CALLBACK LibMain(HINSTANCE hinst,
                                WORD wDataSeg,
                                WORD cbHeapSize,
                                LPSTR lpszCmdLine)
{

#if DBG == 1
    if (GetProfileString("olethk32", "InfoLevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }

#ifdef _CHICAGO_
    if (GetProfileString("CairOLE InfoLevels",
			"Stack", "3", achInfoLevel,
                        sizeof(achInfoLevel)) > 0)
    {
        Stack1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }

#endif // _CHICAGO_

#endif

    thkDebugOut((DEB_DLLS16, "CompObj16: LibMain called on Process (%X) \n", GetCurrentProcess() ));

#if defined(_CHICAGO_)
    //
    //  The Chicago debugger doesn't like hinst not being wired.
    //
    GlobalWire(hinst);
#else
    // NOTE: on WIN95 Call32Initialize is called by DLLEntryPoint
    if (!Call32Initialize())
    {
	return 0;
    }
#endif

#ifdef _DEBUG
        v_mapToEtask.AssertValid();
#endif

        UNREFERENCED(cbHeapSize);

    // Leave our DS unlocked when we're not running
    UnlockData( 0 );

#if defined(_CHIC_INIT_IN_LIBMAIN_)
    if (SetupSharedAllocator(getask) == FALSE)
    {
	return FALSE;
    }
#endif // _CHIC_INIT_IN_LIBMAIN_

    thkDebugOut((DEB_DLLS16, "CompObj16: LibMain called on Process (%X) Exitype (%ld)\n", GetCurrentProcess() ));
	
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   WEP, public
//
//  Synopsis:   Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:  [nExitType] - Type of exit occurring
//
//  Returns:    One for success, zero for failure
//
//  History:    21-Feb-94       DrewB   Created
//
//  Note:       Does nothing on WIN95. Call32Unitialize is called in
//		DllEntryPoint when load count goes to zero.
//
//----------------------------------------------------------------------------

extern "C" int CALLBACK WEP(int nExitType)
{
    thkDebugOut((DEB_DLLS16, "CompObj16: WEP called on Process (%X) Exitype (%ld)\n", GetCurrentProcess(),nExitType));

#if defined(_CHICAGO_)
#if defined(_CHIC_INIT_IN_LIBMAIN_)

    if (v_pMallocShared != NULL)
    {
	getask.m_pMallocShared->Release();
	getask.m_pMallocShared = NULL;
	v_pMallocShared = NULL;
	thkDebugOut((DEB_DLLS16, "CompObj16: WEP v_pMallocShared to NULL  (%X) \n",GetCurrentProcess()));
    }
#endif // _CHIC_INIT_IN_LIBMAIN_
#else
    HTASK htask;
    Etask etask;
    if (LookupEtask(htask, etask))
    {
	//
	// There is an etask. Check to see if the etask for this task has
	// its init count set to ETASK_FAKE_INIT. If it does, we cheated
	// and called CoInitialize on the processes behalf, but it never
	// called CoUninitialize(). Some apps that only make storage calls
	// demonstrate this behaviour. If it is ETASK_FAKE_INIT, then we
	// are going to call CoUninitialize on the apps behalf.
	//
	if (etask.m_inits == ETASK_FAKE_INIT)
	{
	    //
	    // We are going to set the m_inits == 1, since we called it
	    // once. Then we are going to call our very own CoUninitialize()
	    // to let it handle the rest of the cleanup.
	    //
	    etask.m_inits = 1;
	    thkVerify(SetEtask(htask, etask));
	    CoUninitialize();
	}
    }

    //
    // Now uninit the thunk layer
    //
    Call32Uninitialize();
#endif

    thkDebugOut((DEB_DLLS16, "CompObj16: WEP called on Process (%X) done\n", GetCurrentProcess()));
    return 1;
}

#if defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   DllEntryPoint, public
//
//  Synopsis:	Chicago's 16-bit DLL Load/Unload Entry Point.
//
//  Arguments:	[dwReason]    - 1 DLL load, 0 DLL unload
//		[hInst]       - hInstance
//		[wDS]	      - Data Segment
//		[wHeapSize]   - Heap Size
//		[dwReserved1] - Reserved
//		[wReserved2]  - Reserved
//
//  Returns:	True for success, False for failure
//
//  Remarks:	This DLL must be marked as 4.0 for Chicago to call this entry
//		point. DllEntryPoint is called between LibMain and WEP.  See
//		etask.hxx for information of it's elements.
//
//  History:	18-Jan-95	JohannP	 Created
//
//  Note: 	The shared allocator gets initialized first time this function
//		gets called with DLL_LOAD. The gets removed when the dll gets
//		unloaded.
//
//----------------------------------------------------------------------------
#define DLL_LOAD 1
#define DLL_UNLOAD 0

extern "C" BOOL FAR PASCAL
__export DllEntryPoint(DWORD dwReason,WORD  hInst,WORD  wDS,
                       WORD  wHeapSize,DWORD dwReserved1,WORD  wReserved2)
{
    HTASK htask;
    Etask etask;

    thkDebugOut((DEB_DLLS16, "CompObj16: DllEntryPoint called on Process (%X) Reason: (%ld)\n", GetCurrentProcess(),dwReason));
    if (dwReason == DLL_LOAD) 	// DLL refcount increment
    {
	etask.m_htask = 0;
	etask.m_Dllinits = 0;
	// if not init call and init 32 bit
	if (   !LookupEtask(htask, etask)
	    || etask.m_htask != GetCurrentProcess() )
	{
	    // Set up the shared allocator.
	    if (SetupSharedAllocator(etask) == FALSE)
	    {
		thkAssert(v_pMallocShared != NULL && "CompObj: DllEntryPoint: pMallocShared not initialized");
		return FALSE;
	    }
	    // Initialize the interop call mechanism
	    if (!Call32Initialize())
	    {
		thkDebugOut((DEB_DLLS16, "CompObj16: DllEntryPoint Call32Initialize failed\n"));
		return FALSE;
	    }

	    etask.m_Dllinits = 1;
	    etask.m_htask = GetCurrentProcess();
	    etask.m_pMallocSBlock = NULL;
	    etask.m_pMallocPrivate = NULL;
	    etask.m_pid = 0;
	    etask.m_inits = ETASK_NO_INIT;
	    etask.m_oleinits = 0;
	    etask.m_reserved = 0;
	    etask.m_pDlls = NULL;
	    etask.m_pMapToServerCO = NULL;
	    etask.m_pMapToHandlerCO = NULL;
	    etask.m_pArraySH = NULL;
	    etask.m_pCThrd = NULL;
	    etask.m_hwndClip = NULL;
	    etask.m_hwndDde = NULL;
	    etask.m_punkState = NULL;
	    SetEtask(htask, etask);

	    // this should be simplified

	    // verify the initialzation
	    etask.m_Dllinits = 0;
	    etask.m_htask = 0;
	    if (   !LookupEtask(htask, etask)
		 || etask.m_Dllinits == 0
		 || etask.m_htask != GetCurrentProcess() )
	    {
		thkDebugOut((DEB_DLLS16, "CompObj16: DllEntryPoint Etask not initialized; Process (%X) done (%ld)\n", GetCurrentProcess(),dwReason));
		thkAssert(0 && "CompObj: DllEntryPoint Etask not initialized.");
		return FALSE;
	    }
	    thkDebugOut((DEB_DLLS16, "CompObj16: Added Etask\n"));
	}
	else
	{
	    etask.m_Dllinits++;
	    if (!SetEtask(htask, etask))
	    {
		thkAssert(0 && "CompObj16: Etask could not be updated.");
	    }
	    else
	    {
		thkDebugOut((DEB_DLLS16, "CompObj16: Updated Etask\n"));
	    }
	}
    }
    else if (dwReason == DLL_UNLOAD)	// dll refcount decrement
    {
	if (LookupEtask(htask, etask))
	{
	    if (etask.m_Dllinits > 0)
	    {
		etask.m_Dllinits--;

		if ( etask.m_Dllinits == 0 )
		{
		    Call32Uninitialize();
		    thkDebugOut((DEB_DLLS16, "CompObj16: Removing Etask\n"));
		    thkVerify(RemoveEtask(htask,etask));
		}
		else
		{
		    if (!SetEtask(htask, etask))
		    {
			thkAssert(0 && "CompObj16: Etask could not be updated.");
		    }
		    else
		    {
			thkDebugOut((DEB_DLLS16, "CompObj16: Updated Etask\n"));
		    }
		}
	    }
	    else
	    {
		thkAssert(0 && "Dllinit count invalid");
	    }
        }
	else
        {
	    thkAssert(0 && "DllEntryPoint on CompObj - no etask");
	}
    }
    else
    {
	thkAssert(0 && "Chicago BUG - Someone changed DllEntryPoint protocol");
    }
    thkDebugOut((DEB_DLLS16, "CompObj16: DllEntryPoint on Process (%X) done (%ld)\n", GetCurrentProcess(),dwReason));
    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\dlltable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dlltable.cxx
//
//  Contents:   DLL table management
//
//  History:    16-Mar-94       DrewB   Taken from OLE2 16-bit sources
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2int.h>
#include <taskmap.h>
#include <call32.hxx>
#include <apilist.hxx>

#include "dlltable.h"

// FUTURE: move to some private header file
INTERNAL_(void) ReleaseDemandLoadCO(Etask FAR& etask);

//  Keep only hInst.  Always do LoadLibrary; if hInst already exist
//  do FreeLibrary.  This is because GetModuleHandle(pLibName) doesn't
//  neccessarily return same value as LoadLibrary(pLibName).
//
HINSTANCE  CDlls::GetLibrary(LPSTR pLibName, BOOL fAutoFree)
{
    UINT i, nFree, nOldErrorMode;
    HINSTANCE hInst;

#ifndef _MAC
// REVIEW:  The SetErrorMode calls turn of the Windows "File not found"
// message box, assuming that the app will respond to the error code.
// The name of the file that was not found will be lost by the time we
// return to the app, however.  We may want to reconsider this.

   nOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hInst = LoadLibrary(pLibName);
   SetErrorMode(nOldErrorMode);
#ifdef WIN32
    if (hInst == NULL)
#else
    if (hInst < HINSTANCE_ERROR)
#endif
        return hInst;
#else
    hInst = WinLoadLibrary(pLibName);

    if (hInst == HINSTANCE_ERROR)
        return hInst;
#endif

    for (nFree = m_size, i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0) {
            if (nFree > i)
                nFree = i;
            continue;
        }

        if (hInst == m_pDlls[i].hInst) {
            m_pDlls[i].refsTotal++;
                if (fAutoFree)
                        m_pDlls[i].refsAuto++;
            FreeLibrary(hInst);
            return hInst;
        }
    }

    if (nFree == m_size) {
        UINT newsize = m_size + 10;
        void FAR* pMem = NULL;
        IMalloc FAR* pMalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pMalloc) == 0) {
                pMem = pMalloc->Realloc(m_pDlls, newsize * sizeof(m_pDlls[0]));
                pMalloc->Release();
        }

        if (pMem == NULL) {
            FreeLibrary(hInst);
            return NULL; // Out of memory
        }

        _fmemset(((char FAR*) pMem) + m_size * sizeof(m_pDlls[0]),0,
                                   (newsize - m_size) * sizeof(m_pDlls[0]));
        *((void FAR* FAR*) &m_pDlls) = pMem;
        m_size = newsize;
    }

    m_pDlls[nFree].hInst = hInst;
    m_pDlls[nFree].refsTotal = 1;
    m_pDlls[nFree].refsAuto = fAutoFree != 0;
   m_pDlls[nFree].lpfnDllCanUnloadNow =
        (LPFNCANUNLOADNOW)IGetProcAddress(hInst, "DllCanUnloadNow");

#ifdef _DEBUG
   // call it now to prevent dlls from using it to indicate they will be
   // unloaded.
   if (m_pDlls[nFree].lpfnDllCanUnloadNow != NULL)
        (void)(*m_pDlls[nFree].lpfnDllCanUnloadNow)();
#endif // _DEBUG

    return hInst;
}



// unload library.
void  CDlls::ReleaseLibrary(HINSTANCE hInst)
{
    UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        if (hInst == m_pDlls[i].hInst) {

            if (--m_pDlls[i].refsTotal == 0) {
                        Assert(m_pDlls[i].refsAuto == 0);
                FreeLibrary(m_pDlls[i].hInst);
                m_pDlls[i].hInst = NULL;
                m_pDlls[i].lpfnDllCanUnloadNow = NULL;
            }

            return;
        }
    }
}

void  CDlls::FreeAllLibraries(void)
{
   UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        // A dll loaded on behalf of this app hasn't been freed by it
        //
#ifdef _DEBUG
        if (m_pDlls[i].refsTotal != m_pDlls[i].refsAuto) {
                // not all references to this dll are auto load; print message
                char pln[_MAX_PATH];

                if (GetModuleFileName(m_pDlls[i].hInst,pln,_MAX_PATH) == 0)
                        lstrcpy(pln,"<unknown>");
                Puts("WARNING in Uninitialize: Did not free ");
                Puts(pln);
                Puts("\r\n");
        }
#endif
        FreeLibrary(m_pDlls[i].hInst);
    }

    CoMemFree(m_pDlls, MEMCTX_TASK);
    m_size = 0;
    m_pDlls = NULL;
}


// for all dlls, find lpfnDllCanUnloadNow; call it; do it
void  CDlls::FreeUnusedLibraries(void)
{
   static BOOL v_fReadUnloadOption = FALSE;
   static BOOL v_fAllowUnloading = TRUE;
   UINT i;

    for (i = 0; i < m_size; i++) {

        if (m_pDlls[i].refsTotal == 0)
            continue;

        if (m_pDlls[i].refsTotal != m_pDlls[i].refsAuto)
                continue;

        // have an auto-free dll (total refs == auto refs)

        if (m_pDlls[i].lpfnDllCanUnloadNow == NULL)
                continue;

        if (!v_fReadUnloadOption) {
                v_fAllowUnloading = GetProfileInt("windows",
                        "AllowOptimalDllUnload", TRUE);

                v_fReadUnloadOption = TRUE;
        }

        // we want to actually make the call and then check the flag; that
        // way, we ensure that the dlls are exercising their code, but we
        // don't take action on it.
        if ((*m_pDlls[i].lpfnDllCanUnloadNow)() == NOERROR &&
                v_fAllowUnloading) {
                FreeLibrary(m_pDlls[i].hInst);
                m_pDlls[i].refsTotal = NULL;
                m_pDlls[i].refsAuto = NULL;
                m_pDlls[i].hInst = NULL;
                m_pDlls[i].lpfnDllCanUnloadNow = NULL;
        }
    }
}


static INTERNAL_(BOOL)  EnsureDllMap(CDlls FAR* FAR* ppDlls)
{
   HTASK hTask;
   Etask etask;

   if (!LookupEtask(hTask, etask))
        return FALSE;

   // NOTE - The original code used TASK-allocating operator new
   if (etask.m_pDlls == NULL) {
        if ((etask.m_pDlls = new FAR CDlls) == NULL)
                return FALSE;

        SetEtask(hTask, etask);
   }

   *ppDlls = etask.m_pDlls;
   return TRUE;
}


STDAPI_(HINSTANCE)  CoLoadLibrary(LPSTR pLibName, BOOL fAutoFree)
{
   CDlls FAR* pCDlls;

   if (!EnsureDllMap(&pCDlls))
        return NULL;

    return pCDlls->GetLibrary(pLibName, fAutoFree);
}

STDAPI_(void)  CoFreeLibrary(HINSTANCE hInst)
{
    CDlls FAR* pCDlls;

   if (!EnsureDllMap(&pCDlls))
        return;

    pCDlls->ReleaseLibrary(hInst);
}

STDAPI_(void)  CoFreeAllLibraries(void)
{
    thkDebugOut((DEB_ITRACE, "CoFreeAllLibraries\n"));
    CDlls FAR* pCDlls;

    if (!EnsureDllMap(&pCDlls))
        return;

    pCDlls->FreeAllLibraries();

    // Also thunk the call to 32-bits
    CallObjectInWOW(THK_API_METHOD(THK_API_CoFreeAllLibraries), NULL);
    thkDebugOut((DEB_ITRACE, "CoFreeAllLibraries exit\n"));
}

STDAPI_(void)  CoFreeUnusedLibraries(void)
{
    HTASK hTask;
    Etask etask;

    if (!LookupEtask(hTask, etask) || etask.m_pDlls == NULL)
        return;

#if 0
    // Do we need this?  We won't be loading any class objects?
    ReleaseDemandLoadCO(etask);
#endif

    etask.m_pDlls->FreeUnusedLibraries();

    // Also thunk the call to 32-bits
    CallObjectInWOW(THK_API_METHOD(THK_API_CoFreeUnusedLibraries), NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\dlltable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dlltable.h
//
//  Contents:	DLL tracking class
//
//  Classes:	CDll
//
//  History:	16-Mar-94	DrewB	Taken from OLE2 16-bit sources
//
//----------------------------------------------------------------------------

#ifndef __DLLTABLE_H__
#define __DLLTABLE_H__

class FAR CDlls
{
public:
    HINSTANCE GetLibrary(LPSTR pLibName, BOOL fAutoFree);
    void ReleaseLibrary(HINSTANCE hInst);
    void FreeAllLibraries(void);
    void FreeUnusedLibraries(void);

    CDlls() { m_size = 0; m_pDlls = NULL; }
    ~CDlls() {}

private:
    UINT m_size;                 // Number of entries
    struct {
        HINSTANCE hInst;
        ULONG refsTotal;		// total number of refs
        ULONG refsAuto;			// number of autounload refs
        LPFNCANUNLOADNOW lpfnDllCanUnloadNow;	// set on first load
    } FAR* m_pDlls;
};

#endif // #ifndef __DLLTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <ole2.h>
#include <valid.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\etask.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ETASK.CXX   (16 bit target)
//
//  Contents:   ETask management code, taken from 16-bit COMPOBJ.CPP
//
//  Functions:
//
//  History:    08-Mar-94   BobDay  Copied parts from \\ole\slm\...\compobj.cpp
//		01-Feb-95   JohannP modified/simplified
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"

#include "call32.hxx"
#include "apilist.hxx"

// NOTE: NEAR forces this variable to be in the default data segment; without
// NEAR, the ambient model of the class CMapHandleEtask, which is FAR,
// causes the variable to be in a far_data segment.
//
// For WIN32/NT this table is in instance data, the table contains exactly one 
// entry
//
HTASK	v_hTaskCache = NULL;
Etask	NEAR v_etaskCache;


// quick check that the etask is valid (e.g., pointers are valid)
INTERNAL_(BOOL) IsValidEtask(HTASK hTask, Etask FAR& etask)
{
    Win(Assert(GetCurrentProcess() == hTask));
    thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) pMalloc(%p)\n", hTask, etask.m_pMalloc));

#ifdef _CHICAGO_
    if (    etask.m_pMalloc != NULL
	&& !IsValidInterface(etask.m_pMalloc))
#else
    if (!IsValidInterface(etask.m_pMalloc))
#endif
    {
	thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) FALSE\n", hTask));
	return FALSE;
    }

    // FUTURE: verify that stack segment is the same
    // FUTURE: verify that hInst/hMod are the same
    thkDebugOut((DEB_DLLS16, "IsValidEtask (%X) TRUE\n", hTask));

    return TRUE;
}


// if task map empty, clear globals in case lib doesn't get unloaded
INTERNAL_(void) CheckIfMapEmpty(void)
{
	// if no more entries, clear v_pMallocShared; this ensures we clear the
	// variable if the app holds onto this pointer erroneously.
	if (v_mapToEtask.IsEmpty()) {
		v_pMallocShared = NULL;
	}
}

//+---------------------------------------------------------------------------
//
//  Method:     LookupEtask
//
//  Synopsis: 	get etask for current task (and also return hTask);
//		does not create if none
//
//  Arguments:  [hTask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16	  created for CompObj 16 bit for Ole2
//		2-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) LookupEtask(HTASK FAR& hTask, Etask FAR& etask)
{
    hTask = GetCurrentProcess();
    thkDebugOut((DEB_DLLS16, "LookupEtask on Process (%X) \n", hTask));

    if (hTask == v_hTaskCache)
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask found in cache (%X) \n", hTask));
	etask = v_etaskCache;
	goto CheckEtask;
    }

    if (!v_mapToEtask.Lookup(hTask, etask))
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask faild on lookup (%X) \n", hTask));
	return FALSE;
    }
    else
    {
	thkDebugOut((DEB_DLLS16, "LookupEtask found in lookup (%X) \n", hTask));
    }

    // found etask; make this the current cache
    v_hTaskCache = hTask;
    v_etaskCache = etask;

CheckEtask:
    if (IsValidEtask(hTask, etask))
    {
	return TRUE;
    }
    else
    {
	// task got reused; kill cache and entry in map
	v_hTaskCache = NULL;
	v_mapToEtask.RemoveKey(hTask);
	CheckIfMapEmpty();
	thkAssert(0 && "LookupEtask - failed (invalid Etask)");
	return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     SetEtask
//
//  Synopsis: set etask for task given (must be current task); return FALSE
//	      if OOM (only first time; all other times should return TRUE).
//
//  Arguments:  [hTask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16      created for CompObj 16 bit for Ole2
//		02-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) SetEtask(HTASK hTask, Etask FAR& etask)
{
    Win(Assert(GetCurrentProcess() == hTask));

    if (!v_mapToEtask.SetAt(hTask, etask))
		return FALSE;

	Assert(IsValidEtask(hTask, etask));

	// map set; make this the current cache
	v_hTaskCache = hTask;
	v_etaskCache = etask;
	return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     ReleaseEtask
//
//  Synopsis:	release all fields in the etask; do all the task memory
//		(except the task allocator) first; then all the shared
//		memory (except the shared allocator); then the shared
//		allocator and finally the task allocator.
// 		Also removes key if htask is given.
//
//  Arguments:  [htask] --
//		[etask] --
//
//  Returns:
//
//  History:	Ole16	  created for CompObj 16 bit for Ole2
//		2-03-95   JohannP (Johann Posch)   modified/simplified
//
//  Notes:	Called by daytona and chicago.
//
//----------------------------------------------------------------------------
void  ReleaseEtask(HTASK htask, Etask FAR& etask)
{
	thkDebugOut((DEB_DLLS16, "ReleaseEtask on Process (%X) \n", htask));
	Assert(etask.m_inits == 1);
	Assert(etask.m_oleinits == 0);
	Assert(etask.m_reserved == 0);

        // Release any state that may have been set
        if (etask.m_punkState != NULL && IsValidInterface(etask.m_punkState))
        {
            etask.m_punkState->Release();
#ifdef _CHICAGO_
	    if (!LookupEtask(htask, etask))
		return;
#endif
        }
	// first delete all task memory items
	delete etask.m_pDlls;					// task memory
	delete etask.m_pMapToServerCO;			// task memory
	delete etask.m_pMapToHandlerCO;			// task memory
	delete etask.m_pArraySH;				// task memory
	Assert(etask.m_pCThrd == NULL);			// task memory; must be gone by now


	// remove key now that all task memory that will be freed is freed
#ifdef _CHICAGO_
	// Note: just null this out
	// Key is removed later in RemoveEtask called
	etask.m_pDlls = 0;					
	etask.m_pMapToServerCO = 0;				
	etask.m_pMapToHandlerCO = 0;			
	etask.m_pArraySH = 0;				
	etask.m_pCThrd = 0;

#else

	if (htask != NULL) {
		v_mapToEtask.RemoveKey(htask);
	}
	// if no more entries, remove last remaining memory; this prevents
	// problems if the dll is not unloaded for some reason before being
	// used again.
	if (v_mapToEtask.IsEmpty())
		v_mapToEtask.RemoveAll();
#endif


	// now remove all shared memory (doesn't need access to task pMalloc)
#ifdef NOTYET
	if (etask.m_pMallocSBlock != NULL)
		etask.m_pMallocSBlock->Release();		// in shared memory
	if (etask.m_pMallocPrivate != NULL)
		etask.m_pMallocPrivate->Release();		// in shared memory
#endif

#ifndef _CHICAGO_

	Assert(etask.m_pMallocShared != NULL);
	if (etask.m_pMallocShared->Release() == 0) { // in shared memory
		// last use of the shared allocator; set global to null
		v_pMallocShared = NULL;
		Assert(v_mapToEtask.IsEmpty());
	}

	CheckIfMapEmpty();
#endif


	// finally, release the task memory
	Assert(etask.m_pMalloc != NULL);
	etask.m_pMalloc->Release();				// in task memory
	etask.m_pMalloc = NULL;
	thkDebugOut((DEB_DLLS16, "ReleaseEtask (%X) pMalloc(%p)\n", htask, etask.m_pMalloc));

#if defined(_CHICAGO_)
	// Note: update the etask now. Will be deleted on
	// DllEntryPoint when refcount is zero by Remove Etask.
	SetEtask(htask,etask);
#endif


	// invalidate cache
	v_hTaskCache = NULL;
	thkDebugOut((DEB_DLLS16, "ReleaseEtask done on (%X) \n", htask));
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveEtask
//
//  Synopsis:   Releases the shares allocator and removes
//		the etask from the global list
//
//  Arguments:  [hTask] -- htask
//		[etask] -- etask
//
//  Returns:
//
//  History:    2-03-95   JohannP (Johann Posch)   Created
//
//  Notes:	Called only by Chicago.
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) RemoveEtask(HTASK FAR& hTask, Etask FAR& etask)
{
    hTask = GetCurrentProcess();
    thkDebugOut((DEB_DLLS16, "RemoveEtask on Process (%X) \n", hTask));

    if (hTask == v_hTaskCache)
    {
	v_hTaskCache = NULL;
    }
    v_mapToEtask.RemoveKey(hTask);

    if (v_mapToEtask.IsEmpty())
	v_mapToEtask.RemoveAll();

    thkAssert(etask.m_pMallocShared != NULL);
    if(etask.m_pMallocShared->Release() == 0)
    {
	// in shared memory
	// last use of the shared allocator; set global to null
	v_pMallocShared = NULL;
	thkDebugOut((DEB_DLLS16, "RemoveEtask Set v_pMallocShared to NULL  (%X) \n", hTask));
	Assert(v_mapToEtask.IsEmpty());
    }

    CheckIfMapEmpty();

    thkDebugOut((DEB_DLLS16, "RemoveEtask done (%X) \n", hTask));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\memctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       memctx.cxx
//
//  Contents:   all memory management for compobj dll (exported as well)
//
//  Classes:
//
//  Functions:
//
//  History:    10-Mar-94   bobday  Ported from ole2.01 (16-bit)
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

#include <olecoll.h>
#include <map_kv.h>
#include <memctx.hxx>

#include "comlocal.hxx"
#include "map_htsk.h"
#include "etask.hxx"


ASSERTDATA

STDAPI_(DWORD) CoMemctxOf(void const FAR* lpv)
{
	Etask etask;
	HTASK htask;
	int iDidTaskAlloc;

	if (lpv == NULL)
		return MEMCTX_UNKNOWN;

	// try shared memory first because of a bootstrapping problem when setting
	// the Etask the first time.
	if (v_pMallocShared != NULL && v_pMallocShared->DidAlloc((LPVOID)lpv) == 1)
		return MEMCTX_SHARED;

	// now try the other contexts by getting the pointers to their mallocs
	if (!LookupEtask(htask, etask))
		return MEMCTX_UNKNOWN;

	Assert(etask.m_pMalloc != NULL);			// should always have one
	if ((iDidTaskAlloc = etask.m_pMalloc->DidAlloc((LPVOID)lpv)) == 1)
		return MEMCTX_TASK;

	Assert(etask.m_pMallocShared == NULL || etask.m_pMallocShared == v_pMallocShared);

#ifdef NOTYET
	if (etask.m_pMallocSBlock != NULL && etask.m_pMallocSBlock->DidAlloc((LPVOID)lpv) == 1)
		return MEMCTX_SHAREDBLOCK;

	if (etask.m_pMallocPrivate != NULL && etask.m_pMallocPrivate->DidAlloc((LPVOID)lpv) == 1)
		return MEMCTX_COPRIVATE;
#endif

	// last ditch effort: if the task allocator returned -1 (may have alloc'd),
	// then we assume it is task memory.  We do this after the above tests
	// since we would prefer to be exact.
	if (iDidTaskAlloc == -1)
		return MEMCTX_TASK;

	return MEMCTX_UNKNOWN;
}


STDAPI_(void FAR*) CoMemAlloc(ULONG size, DWORD memctx, void FAR* lpvNear)
{
	if (memctx == MEMCTX_SAME)
		{
		AssertSz(lpvNear != NULL,0);
		memctx = CoMemctxOf(lpvNear);
		}
	else
		AssertSz(lpvNear == NULL,0);

	IMalloc FAR* pMalloc;
	void FAR* lpv = NULL;	// stays null if bad context or out of memory
	if (CoGetMalloc(memctx, &pMalloc) == 0) {
		lpv = pMalloc->Alloc(size);
		pMalloc->Release();
	}
	return lpv;
}


STDAPI_(void) CoMemFree(void FAR* lpv, DWORD memctx)
{
	if (lpv == NULL)
		return;

	if (memctx == MEMCTX_UNKNOWN)
		memctx = CoMemctxOf(lpv);

	IMalloc FAR* pMalloc;
	if (CoGetMalloc(memctx, &pMalloc) == 0) {
		pMalloc->Free(lpv);
		pMalloc->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\go1632pr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       GO1632Pr.cxx    (16 bit target)
//
//  Contents:   Functions to thunk interface pointer from 16 to 32 bit.
//
//  Functions:
//
//  History:    13-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <obj16.hxx>
#include <go1632pr.hxx>

//+---------------------------------------------------------------------------
//
//  Macro:      DEFINE_METHOD
//
//  Synopsis:   Defines a generic 16->32 proxy method
//
//  History:    23-Feb-94       DrewB     Created
//
//
//  Notes:      A proxy method's primary reason for existence is to
//              get into the 32-bit world with a pointer to the 16-bit
//              stack.  This is accomplished by taking the address of
//              the this pointer.  Since methods are cdecl, this works
//              for methods with any number of parameters because the
//              first parameter is always the one closest to the return
//              address.
//              The method also passed on the object ID and the method
//              index so that the method's arguments can be properly
//              thunked on the 32-bit side
//
//----------------------------------------------------------------------------

#define DEFINE_METHOD(n) \
STDMETHODIMP_(DWORD) Proxy1632Method##n(THUNK1632OBJ FAR *ptoThis16) \
{ \
    thkDebugOut((DEB_THUNKMGR, "Proxy1632Method: %p(%d)\n", ptoThis16, n)); \
    return CallObjectInWOW( n, CDECL_STACK_PTR(ptoThis16)); \
}


#if DBG == 1

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidString(GUID const *pguid)
{
    static char ach[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    wsprintf(ach, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return ach;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632QueryInterface, public
//
//  Synopsis:   QueryInterface for the proxy object.
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632QueryInterface(THUNK1632OBJ FAR *ptoThis16,
                                             REFIID refiid,
                                             LPVOID *ppv)
{
    DWORD dwRet;
    LPVOID lpvoid = (LPVOID)&refiid;
    IID iid = refiid;

    thkDebugOut((DEB_THUNKMGR, " Proxy1632QueryInterface: %p %s\n",
                 ptoThis16, GuidString((IID const *)&iid) ));

    // Why do we make a copy of the iid only so that we can over-write
    // it so that we can return the pointer to it in it?  This should be
    // re-written.
    //
    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_QUERYINTERFACE, (DWORD)&iid,
                        lpIUnknownObj32, 0, CP32_NARGS);
    *ppv = (LPVOID) iid.Data1;

    thkDebugOut(( DEB_THUNKMGR,
                  "Out Proxy1632QueryInterface: (%p)->%p scRet:0x%08lx\n",
                  ptoThis16, *ppv, dwRet));

    return dwRet;

}

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632AddRef, public
//
//  Synopsis:   AddRef for the generic proxy object
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632AddRef(THUNK1632OBJ FAR *ptoThis16)
{
    DWORD dwRet;

    thkDebugOut(( DEB_THUNKMGR, "In Proxy1632AddRef: %p \n",ptoThis16));

    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_ADDREF, 0,
                        lpIUnknownObj32, 0, CP32_NARGS);

    thkDebugOut(( DEB_THUNKMGR, "Out Proxy1632AddRef: %p dwRet:%ld\n",
                  ptoThis16, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Proxy1632Release, public
//
//  Synopsis:   Release for the proxy object.
//
//  History:    01-Apr-94       JohannP   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) Proxy1632Release(THUNK1632OBJ FAR *ptoThis16)
{
    DWORD dwRet;

    thkDebugOut(( DEB_THUNKMGR, "In Proxy1632Release: %p\n", ptoThis16));

    dwRet = CallProcIn32((DWORD)ptoThis16, SMI_RELEASE, 0,
                        lpIUnknownObj32, 0, CP32_NARGS);

    thkDebugOut(( DEB_THUNKMGR, "Out Proxy1632Release: %p dwRet:%ld\n",
                               ptoThis16,dwRet));

    return dwRet;
}

// Additional methods so that any possible interface can be represented
// using the vtable made up out of all the methods

DEFINE_METHOD(3)
DEFINE_METHOD(4)
DEFINE_METHOD(5)
DEFINE_METHOD(6)
DEFINE_METHOD(7)
DEFINE_METHOD(8)
DEFINE_METHOD(9)
DEFINE_METHOD(10)
DEFINE_METHOD(11)
DEFINE_METHOD(12)
DEFINE_METHOD(13)
DEFINE_METHOD(14)
DEFINE_METHOD(15)
DEFINE_METHOD(16)
DEFINE_METHOD(17)
DEFINE_METHOD(18)
DEFINE_METHOD(19)
DEFINE_METHOD(20)
DEFINE_METHOD(21)
DEFINE_METHOD(22)
DEFINE_METHOD(23)
DEFINE_METHOD(24)
DEFINE_METHOD(25)
DEFINE_METHOD(26)
DEFINE_METHOD(27)
DEFINE_METHOD(28)
DEFINE_METHOD(29)
DEFINE_METHOD(30)
DEFINE_METHOD(31)

// A vtable which will end up calling back to our proxy methods
DWORD atfnProxy1632Vtbl[] =
{
    (DWORD)Proxy1632QueryInterface,
    (DWORD)Proxy1632AddRef,
    (DWORD)Proxy1632Release,
    (DWORD)Proxy1632Method3,
    (DWORD)Proxy1632Method4,
    (DWORD)Proxy1632Method5,
    (DWORD)Proxy1632Method6,
    (DWORD)Proxy1632Method7,
    (DWORD)Proxy1632Method8,
    (DWORD)Proxy1632Method9,
    (DWORD)Proxy1632Method10,
    (DWORD)Proxy1632Method11,
    (DWORD)Proxy1632Method12,
    (DWORD)Proxy1632Method13,
    (DWORD)Proxy1632Method14,
    (DWORD)Proxy1632Method15,
    (DWORD)Proxy1632Method16,
    (DWORD)Proxy1632Method17,
    (DWORD)Proxy1632Method18,
    (DWORD)Proxy1632Method19,
    (DWORD)Proxy1632Method20,
    (DWORD)Proxy1632Method21,
    (DWORD)Proxy1632Method22,
    (DWORD)Proxy1632Method23,
    (DWORD)Proxy1632Method24,
    (DWORD)Proxy1632Method25,
    (DWORD)Proxy1632Method26,
    (DWORD)Proxy1632Method27,
    (DWORD)Proxy1632Method28,
    (DWORD)Proxy1632Method29,
    (DWORD)Proxy1632Method30,
    (DWORD)Proxy1632Method31
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\stdalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       stdalloc.cxx
//
//  Contents:   16-bit OLE allocator
//
//  Classes:
//
//  Functions:
//
//  History:    3-07-94   kevinro   Ported from ole2.01 (16-bit)
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>

/****** Standard Task/Shared Allocator **********************************/

#define NULLSAB ((__segment)0)

typedef __segment SAB;

// amount of space windows reserves at start of segment
#define cbWinRes	16

// amount of space LocalInit takes (somewhat empirical)
#define cbWinOH		(6+10+46)

// total overhead per global block
#define cbTotalOH	(cbWinRes + sizeof(StdAllocHdr) + cbWinOH + 32)

// maximum sized object in a SAB (fudged to include space for per-block
// overhead and most anything else we missed).
#define cbMaxSAB (0xfffe - cbTotalOH)

//+---------------------------------------------------------------------------
//
//  Class:      CStdMalloc ()
//
//  Purpose:    Standard task allocator
//
//  History:    3-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
class FAR CStdMalloc : public IMalloc
{
public:
	CStdMalloc(DWORD memctx)
	{
		m_refs = 1;
		m_pStdAllocHead = NULL;
		m_flags = (memctx == MEMCTX_TASK)? GMEM_MOVEABLE :
						   GMEM_MOVEABLE|GMEM_SHARE;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void FAR* FAR* ppvObj)
	{
                VDATEPTROUT( ppvObj, LPVOID );
                *ppvObj = NULL;
                VDATEIID( iid );

		if (iid == IID_IUnknown || iid == IID_IMalloc) {
			*ppvObj = this;
			++m_refs;
			return NOERROR;
		} else {
			*ppvObj = NULL;
			return ReportResult(0, E_NOINTERFACE, 0, 0);
		}
	}
	
	STDMETHOD_(ULONG,AddRef)(void) { return ++m_refs; }
		
	STDMETHOD_(ULONG,Release)(void)
	{
		if (--m_refs == 0) {
			// free all memory (includes the memory for this class)
			FreeAllMem();
			return 0;
		} else
			return m_refs;
	}
		
    STDMETHOD_(void FAR*, Alloc) (ULONG cb);
    STDMETHOD_(void FAR*, Realloc) (void FAR* pv, ULONG cb);
    STDMETHOD_(void, Free) (void FAR* pv);
    STDMETHOD_(ULONG, GetSize) (void FAR* pv);
    STDMETHOD_(int, DidAlloc) (void FAR* pv);
    STDMETHOD_(void, HeapMinimize) ();

private:
	ULONG m_refs;
	UINT m_flags;

	#define STDALLOC_SIG 0x4D445453		// 'STDM'

	struct StdAllocHdr
	{
		ULONG m_Signature;
		HTASK m_hTask;					// task which owns this block
		StdAllocHdr FAR* m_pStdAllocNext;
	};

	StdAllocHdr FAR* m_pStdAllocHead;

	INTERNAL_(StdAllocHdr FAR*) MapBlockToSA(SAB sab) { return (StdAllocHdr FAR*)MAKELONG(cbWinRes, sab); }
	INTERNAL_(SAB) MapSAToBlock(StdAllocHdr FAR* pSA) { return (__segment)pSA; }
	INTERNAL_(void FAR*) AllocInBlock(SAB seg, UINT cb);
	INTERNAL_(SAB) AllocNewBlock(UINT cb);
	INTERNAL_(SAB) MapPtrToBlock(void FAR* pv);

	INTERNAL_(CStdMalloc FAR*) MoveSelf(LPVOID lpv);
	friend HRESULT STDAPICALLTYPE CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


	INTERNAL_(void) FreeAllMem(void);
};


INTERNAL_(void FAR*) CStdMalloc::AllocInBlock(SAB sab, UINT cb)
{
#ifdef _DEBUG
	WINDEBUGINFO Olddebuginfo, debuginfo;
	
	//get initial debug state
	
	GetWinDebugInfo(&debuginfo, WDI_OPTIONS);
	Olddebuginfo = debuginfo;
	
	//turn off alerts (see bug 3502)
	debuginfo.dwOptions |= DBO_SILENT;
	SetWinDebugInfo(&debuginfo);
	
#endif	// _DEBUG

	// must make alloc of 0 mean alloc something; LocalAlloc fails on cb == 0
	if (0==cb)
		cb = 2;

	_asm push DS;
	_asm mov DS, sab;
	void NEAR *npv = (void NEAR*)LocalAlloc(LMEM_FIXED, cb);
	_asm pop DS;

#ifdef _DEBUG
	//restore Debug state
		SetWinDebugInfo(&Olddebuginfo);
#endif	// _DEBUG

    if (npv == NULL) // npv is near pointer
        return NULL; // returned value is far pointer

	return (void FAR*)MAKELONG(npv, sab);
}


INTERNAL_(SAB) CStdMalloc::AllocNewBlock(UINT cb)
{
	if (cb > cbMaxSAB)
		// overflow
		return NULLSAB;

	if (cb < 4096 - cbTotalOH)
		// minimum is 4k global block
		cb = 4096;
	else
		// size will be larger than 4K; must include total overhead
		cb += cbTotalOH;

	// allocate block and get segment value
	HGLOBAL h;
	if ((h = GlobalAlloc(m_flags, cb)) == NULL)
		return NULLSAB;

	UINT segment;
	segment = HIWORD(GlobalHandle(h));

	// init windows local heap
	if (!LocalInit(segment, cbWinRes + sizeof(StdAllocHdr), cb)) {
		GlobalFree(h);
		return NULLSAB;
	}

	// init block and put it on front of list
	StdAllocHdr FAR* pSA;
	pSA = MapBlockToSA((SAB)segment);
	pSA->m_Signature = STDALLOC_SIG;
	pSA->m_hTask = (m_flags & GMEM_SHARE) != 0 ? NULL : GetCurrentTask();
	pSA->m_pStdAllocNext = m_pStdAllocHead;
	m_pStdAllocHead = pSA;

	return (SAB)segment;
}


INTERNAL_(SAB) CStdMalloc::MapPtrToBlock(void FAR* pv)
{
	if (pv == NULL)
		return NULLSAB;

	StdAllocHdr FAR* pSA;
	pSA = MapBlockToSA((SAB)pv);
	if (pSA->m_Signature != STDALLOC_SIG)
		return NULLSAB;
	
#ifdef DOESNTWORK
	UINT flags = GlobalFlags((HGLOBAL)GlobalHandle((SAB)pv));
#endif
	if (m_flags & GMEM_SHARE) {
		if (pSA->m_hTask != NULL)
			// owned by task; not shared memory
			return NULLSAB;

#ifdef DOESNTWORK
		if ((flags & GMEM_SHARE) == 0)	
			// flags not shared, not shared memory
			return NULLSAB;
#endif
	} else {
		if (pSA->m_hTask != GetCurrentTask()) {
			// if not same task, not this allocator; if different task,
			// something is wrong.
			AssertSz(pSA->m_hTask == NULL, "pointer used in wrong task");
			return NULLSAB;
		}

#ifdef DOESNTWORK
		if ((flags & GMEM_SHARE) != 0)	
			// flags shared, not task memory
			return NULLSAB;
#endif
	}

	return MapSAToBlock(pSA);
}


STDMETHODIMP_(void FAR*) CStdMalloc::Alloc(ULONG cb)
{
	if (cb > cbMaxSAB)
		// can't deal with objects larger than 64k
		return NULL;

	// try all sab in order (newest allocated sab on front)
	StdAllocHdr FAR* pSA = m_pStdAllocHead;
	while (pSA != NULL) {
		// try allocating the memory; if successful, return

		void FAR* pv;
		if ((pv = AllocInBlock(MapSAToBlock(pSA), (UINT)cb)) != NULL)
			return pv;

		pSA = pSA->m_pStdAllocNext;
	}

	SAB sab;
	if ((sab = AllocNewBlock((UINT)cb)) == NULLSAB)
		return NULL;

	// this should really succeed (i.e., an assert would be better)
	return AllocInBlock(sab, (UINT)cb);
}


STDMETHODIMP_(void FAR*) CStdMalloc::Realloc(void FAR* pv, ULONG cb)
{


	if (cb > cbMaxSAB)
		// can't deal with objects larger than 64k
		return NULL;

	SAB sab;
	if (pv == NULL)
		// same as allocating a new pointer
		return Alloc(cb);
	
	//VDATEPTRIN rejects NULL (changed by alexgo 8/3/93)	
	GEN_VDATEPTRIN( pv, int, (LPVOID)NULL );	
	if ((sab = MapPtrToBlock(pv)) == NULLSAB)
		// attempt to realloc a pointer from some other allocator
		return NULL;
	else if (cb == 0) {
		// Realloc(pv, 0) -> frees and returns NULL; this is C library behavior
		Free(pv);
		return NULL;
	}

	void NEAR* npv;
	npv = (void NEAR*)(ULONG)pv;

	// first try realloc within same sab
	Assert(sab != NULLSAB);
	{
		void NEAR* npvT;

		_asm push DS;
		_asm mov DS, sab;
		npvT = (void NEAR*)LocalReAlloc((HLOCAL)npv, (UINT)cb, LMEM_MOVEABLE);
		_asm pop DS;

		if (npvT != NULL)
			return (void FAR*)MAKELONG(npvT, sab);
	}

	// now try allocating new sab and copying
	void FAR* pvT;
	if ((pvT = Alloc(cb)) == NULL)
		return NULL;

	// only copy the smaller of the old and new size
	_asm push ds;
	_asm mov ds,sab;
	UINT cbCopy = LocalSize((HLOCAL)npv);
	_asm pop ds;

	if ((UINT)cb < cbCopy)
		// new size smaller
		cbCopy = (UINT)cb;

	_fmemcpy(pvT, pv, cbCopy);
	

	Free(pv);

	return pvT;
}


STDMETHODIMP_(void) CStdMalloc::Free(void FAR* pv)
{
	SAB sab;

	if (pv == NULL)
		return;

	//VDATEPTRIN rejects NULL (changed by alexgo 8/3/93)
 	VOID_VDATEPTRIN( pv, int );
 	
	if ((sab = MapPtrToBlock(pv)) == NULLSAB) {
#ifdef _DEBUG
		AssertSz(FALSE, "Pointer freed by wrong allocator; filling with 0xcc");

		// we don't own block; this is an error; fill it with 0xcccc anyway
		UINT cb = (UINT)GlobalSize((HGLOBAL)GlobalHandle((__segment)pv));
		cb -= (UINT)(ULONG)pv;

		_fmemset(pv, 0xcc, (size_t)cb);
#endif
	} else {
#ifdef _DEBUG
		// we own block; fill it with 0xcccc
		_fmemset(pv, 0xcc, (size_t)GetSize(pv));
#endif
		_asm push ds;
		_asm mov ds,sab;
		LocalFree((HLOCAL)(void NEAR*)(ULONG)pv);
		_asm pop ds;
	}
}


STDMETHODIMP_(ULONG) CStdMalloc::GetSize(void FAR* pv)
{
	ULONG size = 0;
	SAB sab;

	//VDATEPTRIN rejects NULL (added by alexgo 8/3/93)	
	if( pv == NULL )
		return -1;
		
	GEN_VDATEPTRIN( pv , int, 0 );

	if ((sab = MapPtrToBlock(pv)) != NULLSAB) {
		_asm push ds;
		_asm mov ds,sab;
		size = LocalSize((HLOCAL)(void NEAR*)(ULONG)pv);
		_asm pop ds;
	}

	return size;
}


STDMETHODIMP_(int) CStdMalloc::DidAlloc(void FAR* pv)
{


	if (pv == NULL)
		return -1;

 	//VDATEPTRIN rejects NULL (added by alexgo 8/3/93)
	GEN_VDATEPTRIN( pv , int, 0 );
	
	// returns 1 if we allocated, 0 if not; this impl never returns -1.
	return MapPtrToBlock(pv) != NULLSAB;
}


STDMETHODIMP_(void) CStdMalloc::HeapMinimize()
{
	// LATER : could do local compact here
}


// move this instance of stdmalloc to lpv (which must be large enough)
INTERNAL_(CStdMalloc FAR*) CStdMalloc::MoveSelf(LPVOID lpv)
{
	_fmemcpy(lpv, this, sizeof(*this));
	m_pStdAllocHead = NULL;
	return (CStdMalloc FAR*)lpv;
}


INTERNAL_(void) CStdMalloc::FreeAllMem(void)
{
	// get/null out head of list; null now in case we are freeing self.
	StdAllocHdr FAR* pSA = m_pStdAllocHead;
	m_pStdAllocHead = NULL;

	// free all blocks
	while (pSA != NULL) {
		StdAllocHdr FAR* pSANext = pSA->m_pStdAllocNext;
		pSA->m_pStdAllocNext = NULL;		// to prevent incorrect compiler opt

		GlobalFree(LOWORD(GlobalHandle((UINT)MapSAToBlock(pSA))));

		pSA = pSANext;
	}
}


/****** Global API for creating *****************************************/


// create and return an impl of IMalloc of given memctx
//+---------------------------------------------------------------------------
//
//  Function:   CoCreateStandardMalloc, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [memctx] --
//		[ppMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc)
{
	thkDebugOut((DEB_ITRACE, " CoCreateStandardMalloc\n"));
	*ppMalloc = NULL;

	switch (memctx) {

	case MEMCTX_TASK:
	case MEMCTX_SHARED:
		{
		CStdMalloc sm(memctx);			// local one

		void FAR* lpv;
		if ((lpv = sm.Alloc(sizeof(CStdMalloc))) == NULL)
			return ResultFromScode(E_OUTOFMEMORY);

		*ppMalloc = sm.MoveSelf(lpv);		// move to newly allocated memory
		return NOERROR;
		}
	default:
		return ResultFromScode(E_INVALIDARG);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\rpc16.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       rpc16.cxx
//
//  Contents:   Maps the 16-bit IRpcChannel implementation to a 16-bit
//              implementation of IRpcChannelBuffer.
//
//              This is required to support custom interface marshalling.
//
//  History:    30-Mar-94   BobDay  Adapted from OLELRPC.CPP
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <ole2sp.h>

#include "rpc16.hxx"

interface IRpcChannel : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetStream
    (
	REFIID riid,
        int iMethod,
        BOOL fSend,
        BOOL fNoWait,
        DWORD size,
        IStream FAR * FAR *ppIStream
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Call
    (
	IStream FAR * pIStream
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetDestCtx
    (
	DWORD *pdwDestContext,
	void **ppvDestContext
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsConnected
    (
        void
    ) = 0;
    
};

//
// 16-bit IRpcChannel interface, stream-based
//
// This is the interface seen by the 16-bit proxy implementations
//
class CRpcChannel : public IRpcChannel
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream);
    STDMETHOD(Call)(IStream FAR* pIStream);
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx);
    STDMETHOD(IsConnected)(void);

    CRpcChannel FAR *CRpcChannel::Create( CRpcChannelBuffer FAR *prcb );

private:
    CRpcChannel::CRpcChannel( CRpcChannelBuffer FAR *prcb );
    CRpcChannel::~CRpcChannel( void );

    ULONG                   m_refs;     // Reference count
    CRpcChannelBuffer FAR * m_prcb;     // ChannelBuffer to talk through
};


//+-------------------------------------------------------------------------
//
//  Implementation of CRpcChannel
//
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   Create, public
//
//  Synopsis:   Creates a 16-bit CRpcChannel and gives it the
//              IRpcChannelBuffer that in needs to call.
//
//  Arguments:  [prcb] - IRpcChannelBuffer to call when called
//
//  Returns:    IRpcChannel *, Null on failure
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
CRpcChannel FAR *CRpcChannel::Create( CRpcChannelBuffer FAR *prcb )
{
    CRpcChannel FAR *pRC;

    pRC = new CRpcChannel( prcb );

    return( pRC );
}

//+---------------------------------------------------------------------------
//
//  Function:   Constructor, private
//
//  Synopsis:   Creates a 16-bit CRpcChannel and gives it the
//              IRpcChannelBuffer that in needs to call.
//
//  Arguments:  [prcb] - IRpcChannelBuffer to call when called
//
//  Returns:    IRpcChannel *, Null on failure
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
CRpcChannel::CRpcChannel( CRpcChannelBuffer FAR *prcb )
{
    m_refs = 1;
    m_prcb = prcb;      // Save it and addref it
    if ( m_prcb != NULL )
    {
        m_prcb->AddRef();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Destructor, private
//
//  Synopsis:   Destroys the CRpcChannel object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
CRpcChannel::~CRpcChannel( void )
{
    if ( m_prcb != NULL )
    {
        m_prcb->Release();  // Release it and zero it
        m_prcb = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterface, public
//
//  Synopsis:   Allows querying for other interfaces supported by this
//              object
//
//  Arguments:  [iidInterface] - iid to query for
//              [ppv] - interface pointer returned
//
//  Returns:    nothing
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CRpcChannel::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj )
{
    HRESULT hresult;

    // Two interfaces supported: IUnknown, IRpcChannel

    if (iidInterface == IID_IUnknown || iidInterface == IID_IRpcChannel)
    {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
        hresult = NOERROR;
    }
    else
    {
        *ppvObj = NULL;
        hresult = ResultFromScode(E_NOINTERFACE);
    }

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRef, public
//
//  Synopsis:   Increments object reference count, called when object is
//              referenced by another pointer/client.
//
//  Arguments:  none
//
//  Returns:    new reference count
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcChannel::AddRef(void)
{
    return ++m_refs;
}

//+---------------------------------------------------------------------------
//
//  Function:   Release, public
//
//  Synopsis:   Decrements object reference count and handles necessary
//              self-destruction and sub-releasing, called when object is
//              no longer referenced by another pointer/client.
//
//  Arguments:  none
//
//  Returns:    new reference count
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcChannel::Release(void)
{
    if (--m_refs != 0)      // Object still alive?
    {
        return m_refs;
    }

    delete this;            // Suicide
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStream, public
//
//  Synopsis:   Create an IStream onto which the client can write in
//              preparation for making an RPC call with the stream contents
//              as parameters.
//
//  Arguments:  [iid] - IID of interface being RPC'd
//              [iMethod] - Method # within interface
//              [fSend] - Should we use SendMessage?
//              [fNoWait] - Should we be asynchronous?
//              [size] - Initial size of stream
//              [ppIStream] - Output IStream
//
//  Returns:    HRESULT for success/failure
//              [ppIStream] - IStream for writing parameters
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CRpcChannel::GetStream(
    REFIID            iid,
    int               iMethod,
    BOOL              fSend,
    BOOL              fNoWait,
    DWORD             size,
    IStream FAR* FAR* ppIStream )
{
    CPkt FAR*         pCPkt;

    // no point in allowing this to succeed if we are not connected
    if ( IsConnected() != NOERROR )
    {
        // Connection terminated (server died or disconnectd)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);
    }

    pCPkt = CPkt::CreateForCall(this,iid,iMethod,fSend,fNoWait,size);
    if (pCPkt == NULL)
    {
        *ppIStream = NULL;
        return ResultFromScode(E_OUTOFMEMORY);
    }

    if (pCPkt->QueryInterface(IID_IStream,(void FAR* FAR*) ppIStream)
                                                              != NOERROR)
    {
	pCPkt->Release();
        return ResultFromScode(E_OUTOFMEMORY);
    }

    pCPkt->SetRpcChannelBuffer( m_prcb );

    pCPkt->Release();

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call, public
//
//  Synopsis:   Sends a call to a remote procedure.  Previously, all of the
//              parameters for the procedure were serialized into the IStream
//              which was passed in.
//
//  Arguments:  [pIStream] - IStream for parameters to procedure
//
//  Returns:    HRESULT for success/failure of call or procedure
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CRpcChannel::Call(
    IStream FAR *   pIStream )
{
    HRESULT         hresult;
    CPkt FAR *      pCPkt;

    hresult = pIStream->QueryInterface(IID_CPkt,(void FAR* FAR*) &pCPkt);
    if (hresult != NOERROR)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    return pCPkt->CallRpcChannelBuffer();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDestCtx, public
//
//  Synopsis:   According to the code in OLELRPC.CPP, this is all this code
//              does, presumably, it might be expanded in the future.
//
//  Arguments:
//
//  Returns:
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CRpcChannel::GetDestCtx(
    DWORD FAR *     lpdwDestCtx,
    LPVOID FAR *    lplpvDestCtx )
{
    *lpdwDestCtx = NULL;
    if (lplpvDestCtx)
    {
        *lplpvDestCtx = NULL;
    }
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsConnected, public
//
//  Synopsis:   According to the code in OLELRPC.CPP, this is all this code
//              does, presumably, it might be expanded in the future.
//
//  Arguments:  none
//
//  Returns:    HRESULT indicating connection status
//
//  History:    30-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CRpcChannel::IsConnected( void )
{
    if ( m_prcb == NULL )
    {
        return ResultFromScode(E_UNEXPECTED);
    }
    return m_prcb->IsConnected();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\array_fv.h ===
#ifndef __ARRAY_FV_H__
#define __ARRAY_FV_H__

////////////////////////////////////////////////////////////////////////////
// class CArrayFValue - an array containing fixed size elements,
//
////////////////////////////////////////////////////////////////////////////


// class FAR __export CArrayFValue
class __export CArrayFValue
{
public:

// Construction
	CArrayFValue(DWORD memctx, UINT cbValue);
	~CArrayFValue();

// Attributes
	int     GetSize() const
				{ return m_nSize; }
	int     GetUpperBound() const
				{ return m_nSize-1; }
	BOOL    SetSize(int nNewSize, int nGrowBy = -1);
	int		GetSizeValue() const
				{ return m_cbValue; }

// Operations
	// Clean up
	void    FreeExtra();
	void    RemoveAll()
				{ SetSize(0); }

	// return pointer to element; index must be in range
#ifdef _DEBUG
	// with debug checks
	LPVOID   GetAt(int nIndex) const
				{ return _GetAt(nIndex); }
#else
	// no debug checks
	LPVOID   GetAt(int nIndex) const
				{ return &m_pData[nIndex * m_cbValue]; }
#endif
	LPVOID   _GetAt(int nIndex) const;

	// set element; index must be in range
	void    SetAt(int nIndex, LPVOID pValue);

	// find element given part of one; offset is offset into value; returns
	// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
	// will be optimized for appropriate value size and param combinations
	int		IndexOf(LPVOID pData, UINT cbData, UINT offset);

	// set/add element; Potentially growing the array; return FALSE/-1 if
	// not possible (due to OOM)
	BOOL    SetAtGrow(int nIndex, LPVOID pValue);

	// Operations that move elements around
	BOOL    InsertAt(int nIndex, LPVOID pValue, int nCount = 1);
	void    RemoveAt(int nIndex, int nCount = 1);

	void    AssertValid() const;

// Implementation
private:
	BYTE FAR*   m_pData;    // the actual array of data
	UINT	m_cbValue;		// size of each value (in bytes)
	int     m_nSize;        // current # of elements (m_cbValue bytes in length)
	int     m_nMaxSize;     // max # of elements (m_cbValue bytes in length)
	int     m_nGrowBy;      // grow amount (in # elements)
	DWORD	m_memctx;		// the memctx where the array data should be allocd
};


#endif // !__ARRAY_FV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
****/

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#undef  assert

#ifdef NDEBUG

#define assert(exp) ((void)0)

#else 
#ifdef __cplusplus
extern "C" {
#endif 
void __cdecl _assert(void *, void *, unsigned);
#ifdef __cplusplus
}
#endif 

#define assert(exp) \
    ( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\cosegs.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\compobj\valid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		Valid.cxx	(16 bit target)
//
//  Contents:	Validation APIs exported by CompObj
//
//  Functions:	
//
//  History:	93 OLE 2.0 Dev team  Cretead
//				17-Dec-93 JohannP
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

/*
 * IsValidPtrIn -- Check if the pointer points to a readable segment
 * and if the pointer + #of bytes stays within the segment.
 *
 * NULL will fail
 *
 * cb == 0 will FAIL
 *
 * This function exists only for compatibility with already-compiled apps.
 * We now use macros for IsValidPtrIn and IsValidPtrOut
 * Check out the comments in inc\valid.h
 */


//+---------------------------------------------------------------------------
//
//  Function:   ISVALIDPTRIN, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//		[cb] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
ISVALIDPTRIN( const void FAR* pv, UINT cb )
{
	return !IsBadReadPtr (pv, cb);
	// We cannot use inline assembly here because the VERR instruction does
	// not work if the segment has been discarded (but is still valid).
}


// This function exists only for compatibility with already-compiled apps.
// We now use macros for IsValidPtrIn and IsValidPtrOut
//
// Check out the comments in inc\valid.h


//+---------------------------------------------------------------------------
//
//  Function:   ISVALIDPTROUT, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//		[cb] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
ISVALIDPTROUT( void FAR* pv, UINT cb )
										//	NULL is not acceptable
{
	return !IsBadWritePtr (pv, cb);
}


//	valid code begins 0xb8, ??, ??, followed by:

// BYTE validcode[6] = { 0x55, 0x8b, 0xec, 0x1e, 0x8e, 0xd8};


//+---------------------------------------------------------------------------
//
//  Function:   IsValidInterface, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
	BYTE FAR* pb;
	
	//	NULL is not acceptable as input.

	if (!IsValidPtrIn(pv,4)) goto false;
#ifdef _STRICT_VALIDATION
	//	if the interface was compiled with C++, the virtual function table
	//	will be in a code segment
	if (IsBadCodePtr(*(FARPROC FAR*)pv)) goto false;
#endif
	pb = *(BYTE FAR* FAR*)pv;		//	pb points to beginning of vftable
    if (!IsValidPtrIn(pb, 4)) goto false;
	if (IsBadCodePtr(*(FARPROC FAR*)pb)) goto false;
	pb = *(BYTE FAR* FAR*)pb;
	if (!IsValidPtrIn(pb, 9)) goto false;
//	if (*pb != 0xb8) goto false;
//	pb += 3;
//	if (_fmemcmp(pb, validcode, 6)) goto false;
	return TRUE;
false:
//	AssertSz(FALSE, "Invalid interface pointer");
	return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidIid, Local
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [iid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL)
IsValidIid( REFIID iid )
{
	IID iidTemp = iid;
	DWORD FAR* pdw = (DWORD FAR*)&iidTemp;
	*pdw = 0;
	if (IID_IUnknown == iidTemp) return TRUE;
        thkDebugOut((DEB_IERROR, "WARNING: Nonstandard IID parameter"));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ddesegs.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\cobjps.h ===
/*****************************************************************************\
*                                                                             *
* cobjps.h -    Definitions for writing standard proxies and stubs			  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _COBJPS_H_ )
#define _COBJPS_H_


/****** IRpcChannel Interface ***********************************************/

interface IRpcChannel : IUnknown 
{
    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream) = 0;
    STDMETHOD(Call)(IStream FAR* pIStream) = 0;
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx) = 0;
    STDMETHOD(IsConnected)(void) = 0;
};


/****** IRpcProxy Interface *************************************************/

// IRpcProxy is an interface implemented by proxy objects.  A proxy object has
// exactly the same interfaces as the real object in addition to IRpcProxy.
//

interface IRpcProxy : IUnknown 
{
    STDMETHOD(Connect)(IRpcChannel FAR* pRpcChannel) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
};


/****** IRpcStub Interface **************************************************/

// IRpcStub is an interface implemented by stub objects.  
//

interface IRpcStub : IUnknown
{
    STDMETHOD(Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(Invoke)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx) = 0;
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid) = 0;
    STDMETHOD_(ULONG, CountRefs)(void) = 0;
};


/****** IPSFactory Interface ************************************************/

// IPSFactory - creates proxies and stubs
//

interface IPSFactory : IUnknown
{
    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID riid, 
        IRpcProxy FAR* FAR* ppProxy, void FAR* FAR* ppv) = 0;
    STDMETHOD(CreateStub)(REFIID riid, IUnknown FAR* pUnkServer,
        IRpcStub FAR* FAR* ppStub) = 0;
};

#endif // _COBJPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\cmacs.h ===
/*
 *	**************************** Module Header ******************************\
 *	Module Name: CMACS.H
 *	
 *	This module contains common macros used by C routines.
 *	
 *	Created: 9-Feb-1989
 *	
 *	Copyright (c) 1985 - 1989  Microsoft Corporation
 *	
 *	History:
 *	  Created by Raor
 *	
 *	This will eventually be removed completely.  Right now, we
 *	define ASSERT in terms of AssertSz.
 *	
 *	\**************************************************************************
 */

#if !defined( _CMACS_H_ )
#define _CMACS_H_

#ifndef _MAC

#define  DLL_USE


#ifdef FIREWALLS
extern short ole_flags;

#ifndef _DEBUG
#define _DEBUG
#endif

#include <debug.h>

#define DEBUG_PUTS          0x01
#define DEBUG_DEBUG_OUT     0x02
#define DEBUG_MESSAGEBOX    0x04

extern char    szDebugBuffer[];

#define DEBUG_OUT(parm1,parm2){\
    if(ole_flags & DEBUG_DEBUG_OUT){\
            wsprintf(szDebugBuffer,parm1,parm2);\
        OutputDebugString(szDebugBuffer);\
            OutputDebugString ("^^^  ");\
        }\
    }

#define ASSERT(x,y) AssertSz(x,y)

#define Puts(msg) {\
                    if(ole_flags & DEBUG_PUTS){\
                        OutputDebugString ((LPSTR)(msg));\
                        OutputDebugString ("**  ");\
                    }\
                  }

#else // FIREWALLS

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
// #define Puts(msg)
// FIREWALLS is never defined so let the Puts from debug.h remain defined

#endif // FIREWALLS

#endif // !_MAC

#endif // _CMACS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)

#define CLASS_E_CLASSNOTAVAILABLE   (CLASSFACTORY_E_FIRST + 0x1)
// dll doesn't support that class (returned from DllGetClassObject)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// DDE conversation - no second outgoing call on same channel
#define RPC_E_CANTCALLOUT_AGAIN			(RPC_E_FIRST + 0x11)         

// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in compobj.dll.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO 
{               
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;


// bit flags for IExternalConnection
typedef enum tagEXTCONN 
{
	EXTCONN_STRONG		= 0x0001	// strong connection
} EXTCONN;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn, DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif


/* the character classification macro definitions */

#define isalpha(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( (_ctype+1)[_c] & _UPPER )
#define islower(_c)	( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c)	( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)	( (_ctype+1)[_c] & _HEX )
#define isspace(_c)	( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c)	( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c)	( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c)	( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif
#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )
#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

/* extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif
#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_CTYPE
#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\debnot.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       DEBNOT.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#ifndef __DEBNOT_H__
#define __DEBNOT_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message BUGBUG: Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
#ifndef DEBFAR
#define DEBFAR
#endif
 #include <windef.h>
 #if WIN32 > 200
  #include <winnot.h>
 #endif
#else
#ifndef DEBFAR
#define DEBFAR __far
#endif
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const DEBFAR *pszComp,
       char const DEBFAR *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const DEBFAR *pszFile,
       int iLine,
       char const DEBFAR *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const DEBFAR *pszMsg,
       int iLine,
       char const DEBFAR *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x) if ( !(x) ) \
        Win4AssertEx ( __FILE__, __LINE__, #x );


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


# if (WIN32 > 200) && defined(WIN32) && defined(__cplusplus) && !defined(KERNEL)
#  include <dbgpoint.hxx>
# endif

//+----------------------------------------------------------------------
//
// This next section makes for some really dense reading! Most of it is
// used for the debugging window. It defines some macros that make it
// easier to define debug groups and debug break points, since the macros
// expand to nothing if DEVL != 1. Check out dbgpoint.hxx for more info.
//
//
// The following macros allow you to do things like this
//
// DECLARE_GROUP(FooDebugingGroup)
//
// DECLARE_BREAKPOINT(FooBreakPoint,FooDebuggingGroup,FALSE)
//
// foo()
// {
//      TEST_BREAKPOINT(FooBreakPoint);
// }
//
//
//-----------------------------------------------------------------------

# if (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)

//
// The following class is used to register debug groups as static
// members. Its only needed when DBG is set.
//
//
// The easy way to declare a group, and have it registered for you
//
#  define DECLARE_GROUP(grpName) \
    CDebugGroupClass grpName ((L#grpName));

//
// The easy way to define a group in a header file for use cross module
//
#  define DEFINE_GROUP(grpName) extern CDebugGroupClass grpName;

//
// The easy way to declare a breakpoint is with the following macro.
//
#  define DECLARE_BREAKPOINT(Name,hGroup,fEnabled) \
    CDebugBreakPoint Name((L#Name),hGroup,fEnabled)

//
// If you need to have global access to a break point, use this in
// an include file
//

#  define DEFINE_BREAKPOINT(Name) \
    extern CDebugBreakPoint Name;


//
// A debug value is a class that allows you to wrap the contents of any
// integer value, and publish it in the debug window. The actual debug
// value keeps a reference to the actual value. Therefore, you can attach
// it to any long in the program.
//
// If you use the CDebugValue::SetValue() to change it, the change will
// be reflected in the window immediately.
//
// DECLARE_DEBUGVALUE( Name of Debug Value, Group, Reference to data object)
//
#  define DECLARE_DEBUGVALUE(Name,hGroup,Value) \
    CDebugValue Name((L#Name),hGroup,Value)

#  define DEFINE_DEBUGVALUE(Name) \
    extern CDebugValue Name;


//
// This is the same as above, only you can specify your own title for the
// debug value.
//
// DECLARE_DEBUGVALUEEX( Name of Debug Value, Title, Group, Reference to data object)
//
#  define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value) \
    CDebugValue Name(Title,hGroup,Value)

//
// If you need to have global access to a break point, use this in
// an include file
//

#  define DEFINE_BREAKPOINT(Name) \
    extern CDebugBreakPoint Name;


//
// This test uses a default value for the HRESULT in the window. Use it
// when you don't have one. If you have an HRESULT you could display,
// please use TEST_BREAKPOINTHR
//

#  define TEST_BREAKPOINT(x) if( (x).BreakPointTest() && \
                         (x).BreakPointMessage(__FILE__,__LINE__) )\
                         { DebugBreak(); }

//
// This test includes an HRESULT as a parameter. You should use this one
//
#  define TEST_BREAKPOINTHR(x,hr) if( (x).BreakPointTest() && \
                         (x).BreakPointMessage(__FILE__,__LINE__,hr) )\
                         { DebugBreak(); }


#  define MAKE_CINFOLEVEL(comp) \
   CInfoLevel comp##CInfoLevel((L#comp),comp##InfoLevel);

# else   // (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)


//
// In the non debug version or C version, don't define these
//

#  define MAKE_CINFOLEVEL(comp)
#  define DECLARE_GROUP(Name)
#  define DEFINE_GROUP(Name)
#  define DEFINE_BREAKPOINT(Name)
#  define DECLARE_BREAKPOINT(Name,hGroup,fEnabled)
#  define TEST_BREAKPOINT(x)
#  define TEST_BREAKPOINTHR(x,hr)
#  define DECLARE_DEBUGVALUE(Name,hGroup,Value)
#  define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value)
#  define DEFINE_DEBUGVALUE(Name)

# endif  // #if (WIN32 > 200) && defined(__cplusplus) && defined(WIN32) && !defined(KERNEL)


//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;\
        MAKE_CINFOLEVEL(comp)

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const DEBFAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const DEBFAR * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const DEBFAR * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const DEBFAR * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const DEBFAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)
# define Assert(x)                             // OBSOLETE!
# define Verify(x)     (x)                     // OBSOLETE!

# define MAKE_CINFOLEVEL(comp)
# define DECLARE_GROUP(Name)
# define DEFINE_GROUP(Name)
# define DEFINE_BREAKPOINT(Name)
# define DECLARE_BREAKPOINT(Name,hGroup,fEnabled)
# define TEST_BREAKPOINT(x)
# define TEST_BREAKPOINTHR(x,hr)
# define DECLARE_DEBUGVALUE(Name,hGroup,Value)
# define DECLARE_DEBUGVALUEEX(Name,Title,hGroup,Value)
# define DEFINE_DEBUGVALUE(Name)
# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0


//
// The following section adds the API's used for the performance snapshots
//


#if PERFSNAP == 1

#ifdef __cplusplus
extern "C" {
#endif

void _stdcall InitPerformanceMetering(char const DEBFAR * const);
void _stdcall Perfon(char const DEBFAR * const);
void _stdcall Perfsnap(char const DEBFAR * const, int const);
void _stdcall Perfcomment(char const DEBFAR * const s);
void _stdcall Perfdelta(char const DEBFAR * const, int const);
void _stdcall Perfoff(char const DEBFAR * const);
void _stdcall EndPerformanceMetering(char const DEBFAR * const);

#ifdef __cplusplus
}
#endif

#define PSNAPINIT(pszFileKey) InitPerformanceMetering(pszFileKey)
#define PSNAPEND() EndPerformanceMetering(NULL)
#define PSNAP(s) Perfsnap(s,0)
#define PSNAPL(s,l) Perfsnap(s,l)
#define PSNAPC(s) Perfcomment(s)
#define PSNAPDELTA(s) Perfdelta(s,0)
#define PSNAPDELTAL(s,l) Perfdelta(s,l)
#define PSNAPON(s) Perfon(s)
#define PSNAPOFF(s) Perfoff(s)

#else   // PERFSNAP == 1

#define InitPerformanceMetering(x)
#define Perfon(x)
#define Perfsnap(x,y)
#define Perfcomment(x)
#define Perfdelta(x,y)
#define Perfoff(x)
#define EndPerformanceMetering(x)

#define PSNAPINIT(pszFileKey)
#define PSNAPEND()
#define PSNAP(s)
#define PSNAPL(s,l)
#define PSNAPC(s)
#define PSNAPDELTA(s)
#define PSNAPDELTAL(s,l)
#define PSNAPON(s)
#define PSNAPOFF(s)

#endif


//
// If the sampling profiler is to be used, then here are its includes
//
//

#ifdef WIN32
#if (DBG == 1) || (RTLPROFILE == 1)

#ifdef __cplusplus
extern "C" {
#endif
void _stdcall InitSamplingProfiler(void);
void _stdcall EndSamplingProfiler(void);
#ifdef __cplusplus
}
#endif


#define INITSAMPLINGPROFILER    InitSamplingProfiler()
#define ENDSAMPLINGPROFILER     EndSamplingProfiler()

#else   // RTLPROFILE == 1

#define INITSAMPLINGPROFILER
#define ENDSAMPLINGPROFILER

#endif  // RTLPROFILE == 1
#endif  // WIN32

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -		Data/View object definitions								  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else 
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when 
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium 
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one 
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;
    
typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,
                            LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf, 
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};                 
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IViewObject2

DECLARE_INTERFACE_(IViewObject2, IViewObject)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
					
    // *** IViewObject2 methods ***
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    DVTARGETDEVICE FAR * ptd, LPSIZEL lpsizel) PURE;
					
};
typedef      IViewObject2 FAR* LPVIEWOBJECT2;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc, 
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;



// Cache update Flags

#define	UPDFCACHE_NODATACACHE			0x00000001
#define UPDFCACHE_ONSAVECACHE			0x00000002
#define	UPDFCACHE_ONSTOPCACHE			0x00000004
#define	UPDFCACHE_NORMALCACHE			0x00000008
#define	UPDFCACHE_IFBLANK				0x00000010
#define UPDFCACHE_ONLYIFBLANK			0x80000000

#define UPDFCACHE_IFBLANKORONSAVECACHE	(UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )
#define UPDFCACHE_ALL					(~UPDFCACHE_ONLYIFBLANK)
#define UPDFCACHE_ALLBUTNODATACACHE		(UPDFCACHE_ALL & ~UPDFCACHE_NODATACACHE)


// IOleCache2::DiscardCache options
typedef enum tagDISCARDCACHE
{
	DISCARDCACHE_SAVEIFDIRTY =	0,	// Save all dirty cache before discarding
	DISCARDCACHE_NOSAVE		 =	1	// Don't save dirty caches before 
									// discarding
} DISCARDCACHE;


#undef  INTERFACE
#define INTERFACE   IOleCache2

DECLARE_INTERFACE_(IOleCache2, IOleCache)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;

    // *** IOleCache2 methods ***							
    STDMETHOD(UpdateCache) (THIS_ LPDATAOBJECT pDataObject, DWORD grfUpdf, 
							LPVOID pReserved) PURE;
    STDMETHOD(DiscardCache) (THIS_ DWORD dwDiscardOptions) PURE;
						
};
typedef      IOleCache2 FAR* LPOLECACHE2;


#undef  INTERFACE
#define INTERFACE   IOleCacheControl

DECLARE_INTERFACE_(IOleCacheControl, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(OnRun) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(OnStop) (THIS) PURE;
};                 
typedef      IOleCacheControl FAR* LPOLECACHECONTROL;



/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
					REFIID iid, LPVOID FAR* ppv);
					
#endif // _DVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\dlgs.h ===
#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1993                            */
/*---------------------------------------------------------------------------*/

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041d
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 * 27 March 1991        clarkc
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\debug.h ===
/*
 *  DEBUG code - Contains declarations and macros for include debug support;
 *       Contains null definitions when !_DEBUG
 */

#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#include <ole2dbg.h>

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#ifdef _MAC
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugString(const char *);
#ifdef __cplusplus
}
#endif
#endif

#define ASSERTDATA  static char  _szAssertFile[]= __FILE__;

#undef Assert
// MAC compiler barfs on '(void)0'.
#ifdef _MAC
#define Assert(a) { if (!(a)) FnAssert(#a, NULL, _szAssertFile, __LINE__); }
#undef AssertSz
#define AssertSz(a, b) { if (!(a)) FnAssert(#a, b, _szAssertFile, __LINE__); }
#else
#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, _szAssertFile, __LINE__))
#endif
#undef Verify
#define Verify(a)   Assert(a)
#undef Puts
#define Puts(s) OutputDebugString(s)

#define ASSERT(cond, msg)

#else   //  !_DEBUG

#define ASSERTDATA
#define Assert(a)
#define AssertSz(a, b)
#define Verify(a) (a)
#define ASSERT(cond, msg)
#define Puts(s)

#endif  //  _DEBUG

#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
 *    LPSTR sz;
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    char ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( char ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#if _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif
#endif
};


#ifdef _MAC
typedef short HFILE;
#endif


/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPSTR lpszFile, LPSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

    #ifdef _MAC

        //#define STDDEBDECL(cclassname,classname)

        //#if 0
        #define STDDEBDECL(cclassname,classname) NESTED_CLASS(cclassname, CDebug):IDebug { public: \
            NC1(cclassname,CDebug)( cclassname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~##NC1(cclassname,CDebug)(void){} \
            STDMETHOD_(void, Dump)(THIS_ IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(THIS_ BOOL fSuspicious ); \
            private: cclassname FAR* m_p##classname; }; \
            DECLARE_NC2(cclassname, CDebug) \
            NC(cclassname, CDebug) m_Debug;
        //#endif

        #else  // _MAC

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;
    #endif

    //#ifdef _MAC
    //#define CONSTRUCT_DEBUG
    //#else
    #define CONSTRUCT_DEBUG m_Debug(this),
    //#endif

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif __cplusplus

#endif !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __interrupt _interrupt
#define __near      _near
#endif 

#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED
#pragma pack(2)

struct _DOSERROR {
    int exterror;
    char errclass;
    char action;
    char locus;
    };

#if ((!defined (__STDC__)) && (!defined (__cplusplus)))
/* Non-ANSI name for compatibility */
struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };
#endif 

#pragma pack()
#define _DOSERROR_DEFINED
#endif 


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED
#pragma pack(2)

struct _find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define find_t _find_t
#endif 

#pragma pack()
#define _FIND_T_DEFINED
#endif 


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED
#pragma pack(2)

struct _dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;      /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct _dostime_t {
    unsigned char hour; /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define dosdate_t _dosdate_t
#define dostime_t _dostime_t
#endif 

#pragma pack()
#define _DATETIME_T_DEFINED
#endif 


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t _diskfree_t
#endif 

#define _DISKFREE_T_DEFINED
#endif 


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                    /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL   0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY   0x01    /* Read only file */
#define _A_HIDDEN   0x02    /* Hidden file */
#define _A_SYSTEM   0x04    /* System file */
#define _A_VOLID    0x08    /* Volume ID file */
#define _A_SUBDIR   0x10    /* Subdirectory */
#define _A_ARCH     0x20    /* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

/* macro to construct a far pointer from segment and offset values
 */

#define _MK_FP(seg, offset) (void __far *)(((unsigned long)seg << 16) \
    + (unsigned long)(unsigned)offset)

/* external variable declarations */

extern unsigned int __near __cdecl _osversion;


/* function prototypes */

#ifndef _MT
int __cdecl _bdos(int, unsigned int, unsigned int);
#ifndef _WINDOWS
void __cdecl _chain_intr(void (__cdecl __interrupt __far *)());
#endif 
void __cdecl _disable(void);
#ifndef _WINDOWS
unsigned __cdecl _dos_allocmem(unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_close(int);
unsigned __cdecl _dos_commit(int);
unsigned __cdecl _dos_creat(const char *, unsigned, int *);
unsigned __cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned __cdecl _dos_findfirst(const char *, unsigned, struct _find_t *);
unsigned __cdecl _dos_findnext(struct _find_t *);
#ifndef _WINDOWS
unsigned __cdecl _dos_freemem(unsigned);
#endif 
void __cdecl _dos_getdate(struct _dosdate_t *);
void __cdecl _dos_getdrive(unsigned *);
unsigned __cdecl _dos_getdiskfree(unsigned, struct _diskfree_t *);
unsigned __cdecl _dos_getfileattr(const char *, unsigned *);
unsigned __cdecl _dos_getftime(int, unsigned *, unsigned *);
void __cdecl _dos_gettime(struct _dostime_t *);
void (__cdecl __interrupt __far * __cdecl _dos_getvect(unsigned))();
#ifndef _WINDOWS
void __cdecl _dos_keep(unsigned, unsigned);
#endif 
unsigned __cdecl _dos_lock(int, int, unsigned long, unsigned long);
unsigned __cdecl _dos_open(const char *, unsigned, int *);
unsigned __cdecl _dos_read(int, void __far *, unsigned, unsigned *);
unsigned long __cdecl _dos_seek(int, unsigned long, int);
#ifndef _WINDOWS
unsigned __cdecl _dos_setblock(unsigned, unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_setdate(struct _dosdate_t *);
void __cdecl _dos_setdrive(unsigned, unsigned *);
unsigned __cdecl _dos_setfileattr(const char *, unsigned);
unsigned __cdecl _dos_setftime(int, unsigned, unsigned);
unsigned __cdecl _dos_settime(struct _dostime_t *);
#ifndef _WINDOWS
void __cdecl _dos_setvect(unsigned, void (__cdecl __interrupt __far *)());
#endif 
unsigned __cdecl _dos_write(int, const void __far *, unsigned, unsigned *);
int __cdecl _dosexterr(struct _DOSERROR *);
void __cdecl _enable(void);
#ifndef _WINDOWS
void __cdecl _harderr(void (__far __cdecl *)(unsigned, unsigned,
    unsigned __far *));
void __cdecl _hardresume(int);
void __cdecl _hardretn(int);
#endif 
int __cdecl _intdos(union _REGS *, union _REGS *);
int __cdecl _intdosx(union _REGS *, union _REGS *, struct _SREGS *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);
#endif 

void __cdecl _segread(struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define FP_SEG     _FP_SEG
#define FP_OFF     _FP_OFF
#define MK_FP      _MK_FP

#ifndef _MT
int __cdecl bdos(int, unsigned int, unsigned int);
int __cdecl intdos(union REGS *, union REGS *);
int __cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#ifndef __cplusplus
int __cdecl dosexterr(struct DOSERROR *);
#endif 
#endif 
void __cdecl segread(struct SREGS *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\enumfetc.h ===
// This file is now OBSOLETE (include olestd.h instead)

/*************************************************************************
** 
**    OLE 2 Utility Code
**    
**    enumfetc.c
**    
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

// Function prototypes moved to olestd.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains defines for a number of implementation dependent values
*	which are commonly used in C programs.
*	[ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT	  8		/* number of bits in a char */
#define SCHAR_MIN	(-127)		/* minimum signed char value */
#define SCHAR_MAX	  127		/* maximum signed char value */
#define UCHAR_MAX	  0xff		/* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	/* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	/* maximum char value */
#else
#define CHAR_MIN	  0
#define CHAR_MAX	UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;			/* unsigned CHAR_MAX value */
#else
extern "C" unsigned int _charmax;	/* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif
#endif
#define	MB_LEN_MAX	  2		/* max. # bytes in multibyte char */
#define SHRT_MIN	(-32767)	/* minimum (signed) short value */
#define SHRT_MAX	  32767 	/* maximum (signed) short value */
#define USHRT_MAX	  0xffff	/* maximum unsigned short value */
#define INT_MIN 	(-32767)	/* minimum (signed) int value */
#define INT_MAX 	  32767 	/* maximum (signed) int value */
#define UINT_MAX	  0xffff	/* maximum unsigned int value */
#define LONG_MIN	(-2147483647)	/* minimum (signed) long value */
#define LONG_MAX	  2147483647	/* maximum (signed) long value */
#define ULONG_MAX	  0xffffffff	/* maximum unsigned long value */

#define _INC_LIMITS
#endif	/* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\lrpcmon.h ===
#ifndef _LRPCMON_H
#define _LRPCMON_H

// Creates a window and registers it with LRPC.  Also saves the address, size
// of the given static buffer; address of Notification routine.
//
// For every LRPC message processed LRPC posts an identical message to this
// window.  The message is processed: it content is formatted into the buffer.
// It then calls the notification routine.
//
STDAPI_(BOOL) StartMonitor(HINSTANCE hInst, FARPROC pNotify,
                                            LPSTR pBuf, DWORD dwBufSize);

STDAPI_(void) StopMonitor(void);

#define MINBUFSIZE 32 /* Minimum buffer size passed to StartMonitor */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\monsegs.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains the function declarations for memory allocation functions;
*	also defines manifest constants and types used by the heap routines.
*	[System V]
*
****/

#ifndef _INC_MALLOC

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __based     _based
#define __cdecl     _cdecl
#define __far       _far
#define __huge	    _huge
#define __near      _near
#define __segment   _segment
#endif

/* constants for based heap routines */

#define _NULLSEG	((__segment)0)
#define _NULLOFF	((void __based(void) *)0xffff)

/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY	(-1)
#define _HEAPOK 	(-2)
#define _HEAPBADBEGIN	(-3)
#define _HEAPBADNODE	(-4)
#define _HEAPEND	(-5)
#define _HEAPBADPTR	(-6)
#define _FREEENTRY	0
#define _USEDENTRY	1

/* maximum heap request that can ever be honored */

#ifdef _WINDOWS
#define _HEAP_MAXREQ	0xFFE6
#else
#define _HEAP_MAXREQ	0xFFE8
#endif

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
	int __far * _pentry;
	size_t _size;
	int _useflag;
	} _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif


/* external variable declarations */

extern unsigned int __near __cdecl _amblksiz;


/* based heap function prototypes */

void __based(void) * __cdecl _bcalloc(__segment, size_t, size_t);
void __based(void) * __cdecl _bexpand(__segment,
	void __based(void) *, size_t);
void __cdecl _bfree(__segment, void __based(void) *);
int __cdecl _bfreeseg(__segment);
int __cdecl _bheapadd(__segment, void __based(void) *, size_t);
int __cdecl _bheapchk(__segment);
int __cdecl _bheapmin(__segment);
__segment __cdecl _bheapseg(size_t);
int __cdecl _bheapset(__segment, unsigned int);
int __cdecl _bheapwalk(__segment, _HEAPINFO *);
void __based(void) * __cdecl _bmalloc(__segment, size_t);
size_t __cdecl _bmsize(__segment, void __based(void) *);
void __based(void) * __cdecl _brealloc(__segment,
	void __based(void) *, size_t);


/* function prototypes */

#ifndef _WINDOWS
void * __cdecl _alloca(size_t);
#endif
void * __cdecl calloc(size_t, size_t);
void * __cdecl _expand(void *, size_t);
void __far * __cdecl _fcalloc(size_t, size_t);
void __far * __cdecl _fexpand(void __far *, size_t);
void __cdecl _ffree(void __far *);
int __cdecl _fheapchk(void);
int __cdecl _fheapmin(void);
int __cdecl _fheapset(unsigned int);
int __cdecl _fheapwalk(_HEAPINFO *);
void __far * __cdecl _fmalloc(size_t);
size_t __cdecl _fmsize(void __far *);
void __far * __cdecl _frealloc(void __far *, size_t);
unsigned int __cdecl _freect(size_t);
void __cdecl free(void *);
void __huge * __cdecl _halloc(long, size_t);
void __cdecl _hfree(void __huge *);
#ifndef _WINDOWS
int __cdecl _heapadd(void __far *, size_t);
int __cdecl _heapchk(void);
#endif
int __cdecl _heapmin(void);
#ifndef _WINDOWS
int __cdecl _heapset(unsigned int);
int __cdecl _heapwalk(_HEAPINFO *);
#endif
void * __cdecl malloc(size_t);
size_t __cdecl _memavl(void);
size_t __cdecl _memmax(void);
size_t __cdecl _msize(void *);
void __near * __cdecl _ncalloc(size_t, size_t);
void __near * __cdecl _nexpand(void __near *, size_t);
void __cdecl _nfree(void __near *);
#ifndef _WINDOWS
int __cdecl _nheapchk(void);
#endif
int __cdecl _nheapmin(void);
#ifndef _WINDOWS
int __cdecl _nheapset(unsigned int);
int __cdecl _nheapwalk(_HEAPINFO *);
#endif
void __near * __cdecl _nmalloc(size_t);
size_t __cdecl _nmsize(void __near *);
void __near * __cdecl _nrealloc(void __near *, size_t);
void * __cdecl realloc(void *, size_t);
size_t __cdecl _stackavail(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _WINDOWS
void * __cdecl alloca(size_t);
#endif
void __huge * __cdecl halloc(long, size_t);
void __cdecl hfree(void __huge *);
size_t __cdecl stackavail(void);
#endif	/* __STDC__*/

#ifdef __cplusplus
}
#endif

#define _INC_MALLOC
#endif	/* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\map_htsk.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapHandleEtask
{
public:
	// Construction
	CMapHandleEtask(DWORD memctx, UINT nBlockSize=10) 
		: m_mkv(memctx, sizeof(Etask), sizeof(HTASK), nBlockSize) { }
	CMapHandleEtask(DWORD memctx, UINT nBlockSize, UINT nHashTableSize) 
		: m_mkv(memctx, sizeof(Etask), sizeof(HTASK), nBlockSize,
			&MKVDefaultHashKey, nHashTableSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(HTASK key, Etask FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, Etask FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(HTASK key, Etask FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(HTASK key, Etask& value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(HTASK), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, Etask& value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(HTASK key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(HTASK)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, HTASK FAR& rKey, Etask FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(HTASK key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(HTASK)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
****/

#ifndef _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* definition of _exception struct - this struct is passed to the _matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
#pragma pack(2)

struct _exception {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif 

#pragma pack()
#define _EXCEPTION_DEFINED
#endif 


/* definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED

struct _complex {
    double x,y; /* real and imaginary parts */
    } ;

#ifndef __cplusplus
#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct complex {
    double x,y; /* real and imaginary parts */
    } ;
#endif 
#endif 

#define _COMPLEX_DEFINED
#endif 


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of _HUGE (XENIX) and HUGE_VAL (ANSI) error return values used
 * by several floating point math routines
 */

extern double __near __cdecl _HUGE;
#define HUGE_VAL _HUGE


/* function prototypes */

#ifdef _MT
int __cdecl  abs(int);
double  __pascal acos(double);
double  __pascal asin(double);
double  __pascal atan(double);
double  __pascal atan2(double, double);
double  __pascal atof(const char *);
double  __pascal _cabs(struct _complex);
double  __pascal ceil(double);
double  __pascal cos(double);
double  __pascal cosh(double);
int __cdecl  _dieeetomsbin(double *, double *);
int __cdecl  _dmsbintoieee(double *, double *);
double  __pascal exp(double);
double  __pascal fabs(double);
int __cdecl  _fieeetomsbin(float *, float *);
double  __pascal floor(double);
double  __pascal fmod(double, double);
int __cdecl  _fmsbintoieee(float *, float *);
double  __pascal frexp(double, int *);
double  __pascal _hypot(double, double);
double  __pascal _j0(double);
double  __pascal _j1(double);
double  __pascal _jn(int, double);
long    __cdecl  labs(long);
double  __pascal ldexp(double, int);
double  __pascal log(double);
double  __pascal log10(double);
int __cdecl  _matherr(struct _exception *);
double  __pascal modf(double, double *);
double  __pascal pow(double, double);
double  __pascal sin(double);
double  __pascal sinh(double);
double  __pascal sqrt(double);
double  __pascal tan(double);
double  __pascal tanh(double);
double  __pascal _y0(double);
double  __pascal _y1(double);
double  __pascal _yn(int, double);

#else 
int __cdecl abs(int);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double, double);
double  __cdecl atof(const char *);
double  __cdecl _cabs(struct _complex);
double  __cdecl ceil(double);
double  __cdecl cos(double);
double  __cdecl cosh(double);
int __cdecl _dieeetomsbin(double *, double *);
int __cdecl _dmsbintoieee(double *, double *);
double  __cdecl exp(double);
double  __cdecl fabs(double);
int __cdecl _fieeetomsbin(float *, float *);
double  __cdecl floor(double);
double  __cdecl fmod(double, double);
int __cdecl _fmsbintoieee(float *, float *);
double  __cdecl frexp(double, int *);
double  __cdecl _hypot(double, double);
double  __cdecl _j0(double);
double  __cdecl _j1(double);
double  __cdecl _jn(int, double);
long    __cdecl labs(long);
double  __cdecl ldexp(double, int);
double  __cdecl log(double);
double  __cdecl log10(double);
int __cdecl _matherr(struct _exception *);
double  __cdecl modf(double, double *);
double  __cdecl pow(double, double);
double  __cdecl sin(double);
double  __cdecl sinh(double);
double  __cdecl sqrt(double);
double  __cdecl tan(double);
double  __cdecl tanh(double);
double  __cdecl _y0(double);
double  __cdecl _y1(double);
double  __cdecl _yn(int, double);
#endif 


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
#pragma pack(2)
struct _exceptionl {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    long double arg1;   /* first argument to function */
    long double arg2;   /* second argument (if any) to function */
    long double retval; /* value to be returned by function */
    } ;
#pragma pack()
#define _LD_EXCEPTION_DEFINED
#endif 


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
#pragma pack(2)
struct _complexl {
    long double x,y;    /* real and imaginary parts */
    } ;
#pragma pack()
#define _LD_COMPLEX_DEFINED
#endif 

extern long double __near __cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int      __cdecl _matherrl(struct _exceptionl *);
long double  __cdecl modfl(long double, long double *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr _matherr

extern double __near __cdecl HUGE;

#ifdef _MT
#ifndef __cplusplus
double  __pascal cabs(struct complex);
#endif 
double  __pascal hypot(double, double);
double  __pascal j0(double);
double  __pascal j1(double);
double  __pascal jn(int, double);
double  __pascal y0(double);
double  __pascal y1(double);
double  __pascal yn(int, double);
#else 
#ifndef __cplusplus
double  __cdecl cabs(struct complex);
#endif 
double  __cdecl hypot(double, double);
double  __cdecl j0(double);
double  __cdecl j1(double);
double  __cdecl jn(int, double);
double  __cdecl y0(double);
double  __cdecl y1(double);
double  __cdecl yn(int, double);
#endif 

int __cdecl dieeetomsbin(double *, double *);
int __cdecl dmsbintoieee(double *, double *);
int __cdecl fieeetomsbin(float *, float *);
int __cdecl fmsbintoieee(float *, float *);

long double  __cdecl cabsl(struct _complexl);
long double  __cdecl hypotl(long double, long double);

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_MATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h - 	Moniker and related interfaces and APIs						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else 
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;
    
    STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;


//  IRunningObjectTable::Register flags
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1

#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject, 
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName, 
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2segs.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

DECLARE_HANDLE32(HMAPKEY);
typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class __export CMapKeyToValue
{
public:
	CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey = 0, 
		int nBlockSize=10, LPFNHASHKEY lpfnHashKey = &MKVDefaultHashKey,
		UINT nHashSize = 17);
	~CMapKeyToValue();

	// number of elements
	int     GetCount() const { return m_nCount; }
	BOOL    IsEmpty() const { return m_nCount == 0; }

	// Lookup; return FALSE if not found
	BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
	BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
	BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

	// add a new (key, value) pair; return FALSE if out of memory
	BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
	BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

	// removing existing (key, ?) pair; return FALSE if no such key
	BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
	BOOL    RemoveHKey(HMAPKEY hKey);
	void    RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
			{ return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
	void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey, 
				UINT FAR* pcbKey, LPVOID pValue) const;

	// return HMAPKEY for given key; returns NULL if not currently in map
	HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

	void    AssertValid() const;

private:
	// abstracts, somewhat, variable and fixed sized keys; size is really
	// m_cbKeyInAssoc.
	union CKeyWrap
	{
		BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
		struct
		{
			LPVOID pKey;
			UINT cbKey;
		};
	};

	// Association of one key and one value; NOTE: even though in general
	// the size of the key and value varies, for any given map,
	// the size of an assoc is fixed.
	struct CAssoc 
	{
		CAssoc  FAR* pNext;
		UINT    nHashValue; // needed for efficient iteration
		CKeyWrap key;		// size is really m_cbKeyInAssoc
		// BYTE rgbValue[m_cbValue];
	};

	UINT	SizeAssoc() const
		{ return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
	CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
	void    FreeAssoc(CAssoc FAR* pAssoc);
	BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
	CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

	BOOL	SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
	void	GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
	void	FreeAssocKey(CAssoc FAR* pAssoc) const;
	void	GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
	void	GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
	void	SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

	BOOL	InitHashTable();

	UINT	m_cbValue;
	UINT	m_cbKey;			// variable length if 0
	UINT	m_cbKeyInAssoc;		// always non-zero

	CAssoc  FAR* FAR* m_pHashTable;
	UINT    m_nHashTableSize;
	LPFNHASHKEY m_lpfnHashKey;

	int     m_nCount;
	CAssoc  FAR* m_pFreeList;
	struct CPlex FAR* m_pBlocks;
	int     m_nBlockSize;
	DWORD	m_memctx;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
	int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
	size_t);
void * __cdecl memcpy(void *, const void *,
	size_t);
int __cdecl _memicmp(const void *, const void *,
	unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
	int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
	size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
	unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
	int, unsigned int);
int __cdecl memicmp(const void *, const void *,
	unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
#endif

#ifdef __cplusplus
}
#endif

#define _INC_MEMORY
#endif	/* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole1cls.h ===
/*****************************************************************************\
*                                                                             *
* ole1cls.h -   Master definition of GUIDs for OLE1 classes					  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* This file is the master definition of all GUIDs for OLE1 classes.
   
   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif
   
DEFINE_OLE1GUID(CLSID_ExcelWorksheet,   0x00030000, 0, 0, "ExcelWorksheet");
DEFINE_OLE1GUID(CLSID_ExcelChart,       0x00030001, 0, 0, "ExcelChart");
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,  0x00030002, 0, 0, "ExcelMacrosheet");
DEFINE_OLE1GUID(CLSID_WordDocument,     0x00030003, 0, 0, "WordDocument");
DEFINE_OLE1GUID(CLSID_MSPowerPoint,     0x00030004, 0, 0, "MSPowerPoint");
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,  0x00030005, 0, 0, "MSPowerPointSho");
DEFINE_OLE1GUID(CLSID_MSGraph,          0x00030006, 0, 0, "MSGraph");
DEFINE_OLE1GUID(CLSID_MSDraw,               0x00030007, 0, 0, "MSDraw");
DEFINE_OLE1GUID(CLSID_Note_It,          0x00030008, 0, 0, "Note-It");
DEFINE_OLE1GUID(CLSID_WordArt,          0x00030009, 0, 0, "WordArt");
DEFINE_OLE1GUID(CLSID_PBrush,               0x0003000a, 0, 0, "PBrush");
DEFINE_OLE1GUID(CLSID_Equation,         0x0003000b, 0, 0, "Equation");
DEFINE_OLE1GUID(CLSID_Package,          0x0003000c, 0, 0, "Package");
DEFINE_OLE1GUID(CLSID_SoundRec,         0x0003000d, 0, 0, "SoundRec");
DEFINE_OLE1GUID(CLSID_MPlayer,          0x0003000e, 0, 0, "MPlayer");

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,       0x0003000f, 0, 0, "ServerDemo");
DEFINE_OLE1GUID(CLSID_Srtest,               0x00030010, 0, 0, "Srtest");
DEFINE_OLE1GUID(CLSID_SrtInv,               0x00030011, 0, 0, "SrtInv");
DEFINE_OLE1GUID(CLSID_OleDemo,          0x00030012, 0, 0, "OleDemo");

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,    0x00030013, 0, 0, "CoromandelIntegra");
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, "CoromandelObjServer");

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, "StanfordGraphics");

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,          0x00030016, 0, 0, "DGraphCHART");
DEFINE_OLE1GUID(CLSID_DGraphDATA,           0x00030017, 0, 0, "DGraphDATA");

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,           0x00030018, 0, 0, "PhotoPaint");
DEFINE_OLE1GUID(CLSID_CShow,                    0x00030019, 0, 0, "CShow");
DEFINE_OLE1GUID(CLSID_CorelChart,           0x0003001a, 0, 0, "CorelChart");
DEFINE_OLE1GUID(CLSID_CDraw,                    0x0003001b, 0, 0, "CDraw");

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0,             0x0003001c, 0, 0, "HJWIN1.0");

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,          0x0003001d, 0, 0, "ObjMakerOLE");

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,                      0x0003001e, 0, 0, "FYI");
DEFINE_OLE1GUID(CLSID_FYIView,                  0x0003001f, 0, 0, "FYIView");

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,       0x00030020, 0, 0, "Stickynote");

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, "ShapewareVISIO10");
DEFINE_OLE1GUID(CLSID_ImportServer,     0x00030022, 0, 0, "ImportServer");


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest,          0x00030023, 0, 0, "SrvrTest");

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,        0x00030024, 0, 0, "OLE2_Embedded_Link");

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,            0x00030025, 0, 0, "Cltest");

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, "MS_ClipArt_Gallery");

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,         0x00030027, 0, 0, "MSProject");

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,      0x00030028, 0, 0, "MSWorksChart");

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, "MSWorksSpreadsheet");

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,            0x0003002A, 0, 0, "MinSvr");
DEFINE_OLE1GUID(CLSID_HierarchyList,     0x0003002B, 0, 0, "HierarchyList");
DEFINE_OLE1GUID(CLSID_BibRef,            0x0003002C, 0, 0, "BibRef");
DEFINE_OLE1GUID(CLSID_MinSvrMI,          0x0003002D, 0, 0, "MinSvrMI");
DEFINE_OLE1GUID(CLSID_TestServ,          0x0003002E, 0, 0, "TestServ");

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,    0x0003002F, 0, 0, "AmiProDocument");

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,       0x00030030, 0, 0, "WPGraphics");
DEFINE_OLE1GUID(CLSID_WPCharts,         0x00030031, 0, 0, "WPCharts");


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma,         0x00030032, 0, 0, "Charisma");
DEFINE_OLE1GUID(CLSID_Charisma_30,      0x00030033, 0, 0, "Charisma_30");
DEFINE_OLE1GUID(CLSID_CharPres_30,      0x00030034, 0, 0, "CharPres_30");

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,             0x00030035, 0, 0, "Draw");

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,      0x00030036, 0, 0, "Designer_40");


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h - 		Main OLE2 header; includes all subcomponents				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure  

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed 

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle 

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states  

#define OLE_E_CANTCONVERT			(OLE_E_FIRST+17)
// not able to convert the object 

#define OLE_E_NOSTORAGE				(OLE_E_FIRST+18)
// not able to perform the operation because object is not given storage yet.
 

#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s) 

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static 

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj", 
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0, 
    OLERENDER_DRAW   = 1, 
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD	grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE				= 1,
    OLEMISC_ONLYICONIC						= 2,
    OLEMISC_INSERTNOTREPLACE				= 4,
    OLEMISC_STATIC							= 8,
    OLEMISC_CANTLINKINSIDE					= 16,
    OLEMISC_CANLINKBYOLE1					= 32,
    OLEMISC_ISLINKOBJECT					= 64,
    OLEMISC_INSIDEOUT						= 128,
    OLEMISC_ACTIVATEWHENVISIBLE				= 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512	
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4 
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and 
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#else
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#else
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif
   

#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L // role is handler; implementation is 
										 // default handler; pCF can be NULL
#define EMBDHLP_INPROC_SERVER    0x0001L // role is server; pCF can't be NULL

#define EMBDHLP_CREATENOW    0x00000000L // create using pCF immediately; if pCF
										 // is NULL, uses std remoting handler
#define EMBDHLP_DELAYCREATE  0x00010000L // delayed create; must supply pCF


// NOTE: OleCreateEmbeddingHelper(clsid, pUnkOuter, 
// 		EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL, riid, lplpObj) 
// is the same as OleCreateDefaultHandler(clsid, pUnkOuter, riid, lplpObj);
// i.e., the embedding helper is the default handler in various roles.


/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or 
                                 //     dragsource didn't draw the object to 
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful 
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are 
                                 //    defined by OLEMISC enum. these flags 
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to 
                                 //    null-terminated string that specifies 
                                 //    Full User Type Name of the object. 
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to 
                                 //    null-terminated string that specifies
                                 //    source of the transfer. 
                                 //    dwSrcOfCOpy is normally implemented as 
                                 //    the display name of the temp-for-user 
                                 //    moniker which identifies the source of 
                                 //    the data. 
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else 
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#ifndef INITGUID
#include "oleguid.h"
#endif


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define DD_DEFSCROLLINSET		11

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define DD_DEFSCROLLDELAY		50

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval",
//                              DD_DEFSCROLLINTERVAL)
#define DD_DEFSCROLLINTERVAL	50

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define DD_DEFDRAGDELAY     	200

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define DD_DEFDRAGMINDIST		2



/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered 

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place 

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE; 
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR* pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
    
    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPSTR FAR* lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;

  
/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/
  
 
#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCSTR szContainerApp, LPCSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved, 
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg, 
                LPOLECLIENTSITE pActiveSite, 
                LONG lindex,
                HWND hwndParent,
                LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;   
    STDMETHOD(ShowObject) (THIS) PURE;  
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;    
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;      
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;


/****** OLE Runnable Object Interface **********************************/

#undef  INTERFACE
#define INTERFACE	IRunnableObject

DECLARE_INTERFACE_(IRunnableObject, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IRunnableObject methods ***
    STDMETHOD(GetRunningClass) (THIS_ LPCLSID lpClsid) PURE;
    STDMETHOD(Run) (THIS_ LPBINDCTX pbc) PURE;
    STDMETHOD_(BOOL, IsRunning) (THIS) PURE;
	STDMETHOD(LockRunning)(THIS_ BOOL fLock, BOOL fLastUnlockCloses) PURE;
	STDMETHOD(SetContainedObject)(THIS_ BOOL fContained) PURE;
};
typedef      IRunnableObject FAR* LPRUNNABLEOBJECT;


/****** OLE Container Interfaces ***************************************/
  

#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
    
    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;


/****** OLE Advise Holder Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/
  
#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif  

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying

//misc definitions
#define INPLACE_DEFBORDERWIDTH	4

//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else 
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;   
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect, 
                    LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;   
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;   
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;           
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;          
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCSTR lpszObjName) PURE; 
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCSTR lpszObjName) PURE; 
    
    
    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCSTR lpszStatusText) PURE;    
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;    
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        LPRECT lprcPosRect,
                        LPRECT lprcClipRect,
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;       
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;      
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) PURE; 
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from 
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);
                    

/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt, 
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite, 
                LPSTORAGE pStg, LPVOID FAR* ppvObj); 

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);    

                
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);
            
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite, 
            LPVOID FAR* ppvObj);
            
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined, 
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame, 
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);
                                
                                    
/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat, 
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, 
                    LPCRECT lprcBounds); 
                        
STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
STDAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

STDAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
					REFIID riid, LPVOID FAR* lplpObj);
					
STDAPI_(BOOL)	IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, 
					WORD FAR* lpwCmd);

					
/* Icon extraction Helper APIs */
					
STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,	LPSTR lpszLabel, 
					BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR lpszLabel,
					LPSTR lpszSourceFile, UINT iIconIndex);


					
/* Registration Database Helper APIs */

STDAPI 			OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
					LPSTR FAR* pszUserType);

STDAPI 			OleRegGetMiscStatus	(REFCLSID clsid, DWORD dwAspect,
					DWORD FAR* pdwStatus);

STDAPI 			OleRegEnumFormatEtc	(REFCLSID clsid, DWORD dwDirection,
					LPENUMFORMATETC FAR* ppenum);

STDAPI 			OleRegEnumVerbs	(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);



/* OLE 1.0 conversion APIS */

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE			pstg,
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                polestm,
     LPSTORAGE                  pstg,
     const DVTARGETDEVICE FAR*  ptd);

STDAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE			pstg,
									// Presentation data to OLESTREAM
	 CLIPFORMAT			cfFormat,	//		format
	 LONG				lWidth,		//		width
	 LONG				lHeight,	//		height
	 DWORD				dwSize,		//		size in bytes
     LPSTGMEDIUM		pmedium,	//		bits
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM		polestm,
	 LPSTORAGE			pstg,
									// Presentation data from OLESTREAM
	 CLIPFORMAT FAR*	pcfFormat,	//		format
	 LONG FAR*			plwWidth,	//		width
	 LONG FAR*			plHeight,	//		height
	 DWORD FAR*			pdwSize,	//		size in bytes
	 LPSTGMEDIUM		pmedium);	//		bits



/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2dbg.h ===
/*
	ole2dbg.h:	This header file contains the function declarations for the publicly
	exported debugging interfaces.

	Include *after* standard OLE2 includes.
	
	Copyright (c) 1992-1993, Microsoft Corp. All rights reserved.
*/

#ifndef __OLE2DBG_H
#define __OLE2DBG_H

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved);
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved );

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk );
STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2int.h ===
/*
 *  This is the internal ole2 header, which means it contains those
 *  interfaces which might eventually be exposed to the outside
 *  and which will be exposed to our implementations. We don't want
 *  to expose these now, so I have put them in a separate file.
 */

#if !defined( _OLE2INT_H_ )
#define _OLE2INT_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OLE2INT.H from " __FILE__)
#endif  /* RC_INVOKED */

// ------------------------------------
// system includes
#include <string.h>
#include <StdLib.h>

#ifndef _MAC

#ifdef WIN32
#define _INC_OLE      // Don't include ole.h (ole2.h included below)
#define __RPC_H__     // Don't include rpc.h (compobj.h included below)
#endif

#include <windows.h>

#include <malloc.h>

#include <shellapi.h>
#else
#include <mac.h>
#endif

#ifdef WIN32

#define __loadds            // Not used
#define UnlockData(ds)      // Not used

#define GlobalLock(h) ((LPSTR) GlobalLock(h)) // Retunred type has changed

#define _fmalloc  malloc
#define _frealloc realloc
#define _ffree    free

#define _fmemset  memset
#define _fmemcpy  memcpy
#define _fmemcmp  memcmp
#define _fmemmove memmove

#define _fstrcpy   strcpy    // - you should use strcpy
#define _fstrcat   strcat    // - you should use strcat
#define _fstrlen   strlen    // - you should use strlen
#define _fstrchr   strchr    // - you should use strchr
#define _fstrcmp   strcmp    // - you should use strcmp
#define _fstrncmp  strncmp   // - you should use strncmp
#define _fstricmp  stricmp   // - you should use stricmp
#define _fstrnicmp strnicmp  // - you should use strnicmp
#define _fstrtok   strtok    // - you should use strtok

#endif

#ifdef WIN32
#define HTASK DWORD         // Use Proccess id / Thread id
#define GetCurrentThread()  GetCurrentThreadId()
#define GetCurrentProcess() GetCurrentProcessId()
#define GetWindowThread(h)  ((HTASK)GetWindowTask(h))
#else
#define GetCurrentThread()  GetCurrentTask()
#define GetCurrentProcess() GetCurrentTask()
#define GetWindowThread(h)  GetWindowTask(h)
#endif

#ifdef WIN32
#define LocalHandle(p) LocalHandle((void*)(p))
#else
#define LocalHandle(p) LocalHandle((UINT)(p))
#endif

#ifdef WIN32
#define SetWindowOrg(h,x,y)       SetWindowOrgEx((h),(x),(y),NULL)
#define SetWindowExt(h,x,y)       SetWindowExtEx((h),(x),(y),NULL)
#define SetViewportOrg(h,x,y)     SetViewportOrgEx((h),(x),(y),NULL)
#define SetViewportExt(h,x,y)     SetViewportExtEx((h),(x),(y),NULL)
#define SetBitmapDimension(h,x,y) SetBitmapDimensionEx((h),(x),(y),NULL)
#endif


#ifdef WIN32
#define WEP_FREE_DLL 0
#define WEP_SYSTEM_EXIT 1
#endif


#ifdef WIN32
// "BarryM needs to look at this
// Probably reverse the logic (that is do path to drive index translation
// within a GetDriveTypeEx(char FAR* pszRoot))
// This also is used by dde code"
//
// 15-Feb-2000  At this point changing anything would break more than it
//              helped.
//

inline UINT GetDriveType16(int i)
{
    char s[4];
    if (i < 0 || i > 26)
        return 0;

    s[0] = i + 'A'; s[1] = ':'; s[2] = '\\'; s[3] = '\0';

    return GetDriveTypeA(s); // GetDriveType already mapped to GetDriveType16
}

#undef GetDriveType // Remove mapping to GetDriveTypeA

#define GetDriveType(i) GetDriveType16(i)

#endif

#ifdef WIN32
#undef RegQueryValue // Remove mapping to RegQueryValueA
#define RegQueryValue(hkey,lpszKey,lpszVal,lpcb) \
        RegQueryValueA((hkey),(lpszKey),(lpszVal),((DWORD*) (lpcb)))
#undef RegOpenKey // Remove mapping to RegOpenKeyA
#define RegOpenKey(hkey,lpszSubKey,phkey) \
        RegOpenKeyA((hkey),((LPSTR)(lpszSubKey)),(phkey))
#endif


#ifdef WIN32
extern void *pvtblIDebug;
extern void *pvtblCBaseMoniker;
extern void *pvtblCFileMoniker;
extern void *pvtblCItemMoniker;
extern void *pvtblCCompositeMoniker;
extern void *pvtblCAntiMoniker;
extern void *pvtblCPointerMoniker;
extern void *pvtblCRunningObjectTable;
extern void *pvtblCROTEnumMoniker;
extern void SetpVtbl(void *pvtbl);
#define SETPVTBL(Name)  if (PlacementOf(this) == SHARED) SetpVtbl(pvtbl##Name)
#else
#define SETPVTBL(Name)
#endif

// ------------------------------------
// public includes
#include <ole2anac.h>
#include <ole2.h>
#include <cobjps.h>
#include <ole2sp.h>

// ------------------------------------
// internal includes
#include <olemem.h>
#include <cmacs.h>
#include <utils.h>
#include <olecoll.h>
#include <valid.h>
#include <array_fv.h>
#include <map_kv.h>
#include <privguid.h>

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#if defined(_M_I86SM) || defined(_M_I86MM)
#define _NEARDATA
#endif

#include <utstream.h>

/*
 *      Warning disables:
 *
 *      We compile with warning level 4, with the following warnings
 *      disabled:
 *
 *      4355: 'this' used in base member initializer list
 *
 *              We don't see the point of this message and we do this all
 *              the time.
 *
 *      4505: Unreferenced local function has been removed -- the given
 *      function is local and not referenced in the body of the module.
 *
 *              Unfortunately, this is generated for every inline function
 *              seen in the header files that is not used in the module.
 *              Since we use a number of inlines, this is a nuisance
 *              warning.  It would be nice if the compiler distinguished
 *              between inlines and regular functions.
 *
 *      4706: Assignment within conditional expression.
 *
 *              We use this style of programming extensively, so this
 *              warning is disabled.
 */

#pragma warning(disable:4355)
#pragma warning(disable:4068)
/*
 *      MACROS for Mac/PC core code
 *
 *      The following macros reduce the proliferation of #ifdefs.  They
 *      allow tagging a fragment of code as Mac only, PC only, or with
 *      variants which differ on the PC and the Mac.
 *
 *      Usage:
 *
 *
 *      h = GetHandle();
 *      Mac(DisposeHandle(h));
 *
 *
 *      h = GetHandle();
 *      MacWin(h2 = h, CopyHandle(h, h2));
 *
 */
#ifdef _MAC
#define Mac(x) x
#define Win(x)
#define MacWin(x,y) x
#else
#define Mac(x)
#define Win(x) x
#define MacWin(x,y) y
#endif


// Macros for Double-Byte Character Support
#ifdef _MAC
#define IncLpch IncLpch
#define DecLpch DecLpch
#else
// Beware of double evaluation
#define IncLpch(sz)          ((sz)=CharNext ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))
#endif


#ifndef _MAC
/* dlls instance and module handles */

extern HMODULE          hmodOLE2;

/* Variables for registered clipboard formats */

extern  CLIPFORMAT   cfObjectLink;
extern  CLIPFORMAT   cfOwnerLink;
extern  CLIPFORMAT   cfNative;
extern  CLIPFORMAT   cfLink;
extern  CLIPFORMAT   cfBinary;
extern  CLIPFORMAT   cfFileName;
extern  CLIPFORMAT   cfNetworkName;
extern  CLIPFORMAT   cfDataObject;
extern  CLIPFORMAT   cfEmbeddedObject;
extern  CLIPFORMAT   cfEmbedSource;
extern  CLIPFORMAT   cfLinkSource;
extern  CLIPFORMAT   cfOleDraw;
extern  CLIPFORMAT   cfLinkSrcDescriptor;
extern  CLIPFORMAT   cfObjectDescriptor;
extern  CLIPFORMAT       cfCustomLinkSource;
extern  CLIPFORMAT       cfPBrush;
extern  CLIPFORMAT       cfMSDraw;

#endif


/* Number of logical pixels per inch for current driver */
extern  int     giPpliX;
extern  int             giPpliY;


/* Exported CLSIDs.. */
#define CLSID_StaticMetafile    CLSID_Picture_Metafile
#define CLSID_StaticDib                 CLSID_Picture_Dib


// special Assert for asserts below (since the expression is so large)
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, _szAssertFile, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
        AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(char)) || \
        FAILED(hr) && (p) == NULL, \
        szBadOutParam)

#define AssertOutPtrIface(hr, p) \
        AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
        FAILED(hr) && (p) == NULL, \
        szBadOutIface)

#define AssertOutPtrFailed(p) \
        AssertOut((p) == NULL, \
        szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
        AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
        FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
        szBadOutStgm)


// assert data for above assert out macros; once per dll
#define ASSERTOUTDATA \
        char szCheckOutParam[] = "check out param"; \
        char szBadOutParam[] = "Out pointer param conventions not followed"; \
        char szBadOutIface[] = "Out pointer interface conventions not followed"; \
        char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
        char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


/***********************************************************************/
/****                   C++ memory management                                                       ****/
/***********************************************************************/


// these should never be called (and assert if they are)
void * operator new(size_t size);
void operator delete(void * ptr);



void FAR* operator new(size_t size);            // same as new (MEMCTX_TASK)
void FAR* operator new(size_t size, DWORD memctx, void FAR* lpvSame=NULL);
void operator delete(void FAR* ptr);

// example usage:
//              lp = new(MEMCTX_TASK) CClass;
//              lp = new(MEMCTX_SHARED) CClass;
//              lp = new(MEMCTX_SAME, lpv) CClass;

// MEMCTX for compobj internal memory (only used by compobj code)
// NOTE: this value is not represented in the MEMCTX enum in compobj.h
#define MEMCTX_COPRIVATE 5

// exports from compobj.dll:
// returns MEMCTX of existing pointer
STDAPI_(DWORD) CoMemctxOf(void const FAR* lpv);
STDAPI_(void FAR*) CoMemAlloc(ULONG cb ,DWORD memctx, void FAR* lpvSame);
STDAPI_(void) CoMemFree(void FAR* lpv, DWORD memctx);


// old names
#define MemoryPlacement DWORD
#define PlacementOf     CoMemctxOf
#define TASK                    MEMCTX_TASK, NULL
#define SHARED                  MEMCTX_SHARED, NULL
#define SAME                    MEMCTX_SAME, NULL


/***********************************************************************/
/****                   FILE FORMAT RELATED INFO                                                        ****/
/***********************************************************************/

// Coponent object stream information

#define COMPOBJ_STREAM                          "\1CompObj"
#define BYTE_ORDER_INDICATOR            0xfffe    // for MAC it could be different
#define COMPOBJ_STREAM_VERSION          0x0001

// OLE defines values for different OSs
#define OS_WIN                                          0x0000
#define OS_MAC                                          0x0001
#define OS_NT                                           0x0002

// HIGH WORD is OS indicator, LOW WORD is OS version number
extern  DWORD   gdwOrgOSVersion;
extern  DWORD  gdwOleVersion;


// Ole streams information
#define OLE_STREAM                                      "\1Ole"
#define OLE_PRODUCT_VERSION                     0x0200          // (HIGH BYTE major version)
#define OLE_STREAM_VERSION                      0x0001

#define OLE10_NATIVE_STREAM                     "\1Ole10Native"
#define OLE10_ITEMNAME_STREAM           "\1Ole10ItemName"
#define OLE_PRESENTATION_STREAM         "\2OlePres000"
#define CONTENTS_STREAM                         "CONTENTS"

/***********************************************************************
                                Storage APIs internally used
*************************************************************************/

OLEAPI  ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf);
OLEAPI  WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf);

OLEAPI WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk);
OLEAPI ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* pmk);

OLEAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem);
OLEAPI_(LPSTREAM) CloneMemStm(HANDLE hMem);
OLEAPI_(void)     ReleaseMemStm (LPHANDLE hMem, BOOL fInternalOnly = FALSE);

/*************************************************************************
                        Initialization code for individual modules
*************************************************************************/

INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
);

INTERNAL_(BOOL) DDELibMain (
        HANDLE  hInst,
        WORD    wDataSeg,
        WORD    cbHeapSize,
        LPSTR   lpszCmdLine
);

BOOL    InitializeRunningObjectTable(void);
void    DestroyRunningObjectTable(void);


#ifdef _MAC
#define BITMAP_TO_DIB(foretc)
#else
#define BITMAP_TO_DIB(foretc) \
        if (foretc.cfFormat == CF_BITMAP) {\
                foretc.cfFormat = CF_DIB;\
                foretc.tymed = TYMED_HGLOBAL;\
        }
#endif


#define VERIFY_ASPECT_SINGLE(dwAsp) {\
        if (!(dwAsp && !(dwAsp & (dwAsp-1)) && (dwAsp <= DVASPECT_DOCPRINT))) {\
                AssertSz(FALSE, "More than 1 aspect is specified");\
                return ResultFromScode(DV_E_DVASPECT);\
        }\
}


#define VERIFY_TYMED_SINGLE(tymed) {\
        if (!(tymed && !(tymed & (tymed-1)) && (tymed <= TYMED_MFPICT))) \
                return ResultFromScode(DV_E_TYMED); \
}


#define VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pfetc) {\
        if ((pfetc->cfFormat==CF_METAFILEPICT && pfetc->tymed!=TYMED_MFPICT)\
                        || (pfetc->cfFormat==CF_BITMAP && pfetc->tymed!=TYMED_GDI)\
                        || (pfetc->cfFormat!=CF_METAFILEPICT && \
                                pfetc->cfFormat!=CF_BITMAP && \
                                pfetc->tymed!=TYMED_HGLOBAL))\
                return ResultFromScode(DV_E_TYMED); \
}




// REVIEW ...
// Only DDE layer will test for these values. And only for advises on cached
// formats do we use these values

#define ADVFDDE_ONSAVE          0x40000000
#define ADVFDDE_ONCLOSE         0x80000000


// Used in Ole Private Stream
typedef enum tagOBJFLAGS
{
        OBJFLAGS_LINK=1L,
        OBJFLAGS_DOCUMENT=2L,           // this bit is owned by container and is
                                                                // propogated through saves
        OBJFLAGS_CONVERT=4L,
} OBJFLAGS;



/*****************************************
 Prototypes for dde\client\ddemnker.cpp
******************************************/

INTERNAL DdeBindToObject
        (LPCSTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        LPBC pbc,                         // not used
        LPMONIKER pmkToLeft,  // not used
        REFIID   iid,
        LPLPVOID ppv);

INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCSTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);


/**************************************
 Prototypes for moniker\mkparse.cpp
***************************************/

INTERNAL Ole10_ParseMoniker
        (LPMONIKER pmk,
        LPSTR FAR* pszFile,
        LPSTR FAR* pszItem);


/****************************************************************************/
/*                              Utility APIs, might get exposed later                                           */
/****************************************************************************/

OLEAPI  OleGetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetcIn,
                                                LPSTGMEDIUM pmedium, BOOL fGetOwnership);
OLEAPI  OleSetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetc,
                                                STGMEDIUM FAR * pmedium, BOOL fRelease);
STDAPI  OleDuplicateMedium(LPSTGMEDIUM lpMediumSrc, LPSTGMEDIUM lpMediumDest);

OLEAPI_(BOOL)    OleIsDcMeta (HDC hdc);

INTERNAL SzFixNet( LPBINDCTX pbc, LPSTR szUNCName, LPSTR FAR * lplpszReturn,
    UINT FAR * pEndServer, BOOL fForceConnection = TRUE);

FARINTERNAL ReadFmtUserTypeProgIdStg
        (IStorage FAR * pstg,
        CLIPFORMAT FAR* pcf,
        LPSTR FAR* pszUserType,
        LPSTR    szProgID);

/****************************************************************************/
/*                              Internal StubManager APIs, might get exposed later                      */
/****************************************************************************/
OLEAPI  CoDisconnectWeakExternal(IUnknown FAR* pUnk, DWORD dwReserved);


#pragma warning(disable: 4073) // disable warning about using init_seg
#pragma init_seg(lib)
#include "ole2segs.h"
#include "cosegs.h"
#include "prxsegs.h"
#endif  //      _OLE2INT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2anac.h ===
// ole2anac.h - anachronisms for pre-release code

#if !defined( _OLE2ANAC_H_ )
#define _OLE2ANAC_H_

#define IIDEQ(riid1, riid2) IsEqualIID(riid1, riid2)
#define CLSIDEQ(rclsid1, rclsid2) IsEqualCLSID(rclsid1, rclsid2)

#define RetryRejectedCall RetryRejectedMessage

#define FileTimeToDosDateTime(pft,pdd,pdt) CoFileTimeToDosDateTime(pft,pdd,pdt)
#define DosDateTimeToFileTime(pdd,pdt,pft) CoDosDateTimeToFileTime(pdd,pdt,pft)

typedef enum tagSTGSTATE
{
    STGSTATE_DOC         = 1,
    STGSTATE_CONVERT     = 2,
    STGSTATE_FILESTGSAME = 4
} STGSTATE;


#define MK_E_EXCEEDED_DEADLINE      MK_E_EXCEEDEDDEADLINE
#define MK_E_NEED_GENERIC           MK_E_NEEDGENERIC
#define MK_E_INVALID_EXTENSION      MK_E_INVALIDEXTENSION 
#define MK_E_INTERMEDIATE_INTERFACE_NOT_SUPPORTED \
    MK_E_INTERMEDIATEINTERFACENONOT_SUPPORTED
#define MK_E_NOT_BINDABLE           MK_E_NOTBINDABLE 
#define S_TRUE                      S_OK


#define OLEMETHODCALLTYPE       STDMETHODCALLTYPE
#define OLEAPICALLTYPE          STDAPICALLTYPE

#define OLEAPI                  STDAPI
#define OLEAPI_(type)           STDAPI_(type)

#define OLEMETHOD(method)       STDMETHOD(method)
#define OLEMETHOD_(type,method) STDMETHOD_(type,method)

#define OLEMETHODIMP            STDMETHODIMP
#define OLEMETHODIMP_(type)     STDMETHODIMP_(type)

#define OLESTATIC_(type) static type __export
#define OLESTATICIMP_(type) type __export


#define E_BLANK             OLE_E_BLANK
#define E_STATIC            OLE_E_STATIC
#define E_NOTRUNNING        OLE_E_NOTRUNNING
#define E_FORMAT            DV_E_CLIPFORMAT
#define E_UNSPEC            E_FAIL
#define OLE_E_CLSID         REGDB_E_CLASSNOTREG
#define OLE_E_NOTSUPPORTED  E_NOTIMPL
#define OLE_E_REGDB_KEY     REGDB_E_KEYMISSING
#define OLE_E_REGDB_FMT     REGDB_E_INVALIDVALUE


#define OLEVERB_PRIMARY     OLEIVERB_PRIMARY
#define OLEVERB_SHOW        OLEIVERB_SHOW

#define DAdvise Advise
#define DUnadvise Unadvise
#define EnumDAdvise EnumAdvise


// these DDE error codes are not returned anymore; these definitions are
// here just to make existing code compile without changes.
#define RPC_E_DDE_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x100)

#define RPC_E_DDE_BUSY              (RPC_E_DDE_FIRST + 0x0)         
#define RPC_E_DDE_CANT_UPDATE       (RPC_E_DDE_FIRST + 0x1)
#define RPC_E_DDE_INIT              (RPC_E_DDE_FIRST + 0x2)
#define RPC_E_DDE_NACK              E_FAIL
#define RPC_E_DDE_LAUNCH            CO_E_APPNOTFOUND
#define RPC_E_DDE_POST              RPC_E_SERVER_DIED
#define RPC_E_DDE_PROTOCOL          (RPC_E_DDE_FIRST + 0x6)
#define RPC_E_DDE_REVOKE            (RPC_E_DDE_FIRST + 0x7)
#define RPC_E_DDE_SYNTAX_EXECUTE    RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_SYNTAX_ITEM       RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_UNEXP_MSG     	(RPC_E_DDE_FIRST + 0xa)
#define RPC_E_DDE_DATA              RPC_E_INVALID_PARAMETER


#define RPC_E_CONNECTION_LOST           (RPC_E_FIRST + 0x6)         
#define RPC_E_BUSY                      (RPC_E_FIRST + 0x0)         
#define RPC_E_MSG_REJECTED              (RPC_E_FIRST + 0x1)         
#define RPC_E_CANCELLED                 (RPC_E_FIRST + 0x2)         
#define RPC_E_DISPATCH_ASYNCCALL        (RPC_E_FIRST + 0x4)         


#endif // _OLE2ANAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2ver.h ===
#define rmj		0
#define rmm		23
#define rup		640
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2sp.h ===
/* ole2sp.h - semi-private info; only for test apps within the development group
*/

#if !defined( _OLE2SP_H_ )
#define _OLE2SP_H_

#include <shellapi.h>

// For MAC, M_PROLOG and M_EPILOG are macros which assist us in setting up the A5
// world for a DLL when a method in the DLL is called from outside the DLL.

#ifdef _MAC

#define _MAX_PATH 260

#ifdef __cplusplus

class  CSetA5
{
public:
    CSetA5 (ULONG savedA5){ A5save = SetA5(savedA5);}
    ~CSetA5 (){ SetA5(A5save);}

private:
    ULONG A5save;
};

pascal long     GetA5(void) = 0x2E8D;

#define M_PROLOG(where) CSetA5 Dummy((where)->savedA5)
#define SET_A5          ULONG savedA5
#define GET_A5()        savedA5 = GetA5()

// These macros assist Mac in manually saving/setting/restoring A5 in routines that contain
// goto's.

#define A5_PROLOG(where) ULONG A5save = SetA5(where->savedA5)
#define RESTORE_A5()     SetA5(A5save)

// Lets MAC name our segments without ifdef's.

#define NAME_SEG(x)

#endif // ccplus

#else

#define M_PROLOG(where)
#define SET_A5
#define GET_A5()
#define A5_PROLOG(where)
#define RESTORE_A5()
#define NAME_SEG(x)


#define IGetProcAddress(a,b) GetProcAddress((a),(b))

#endif


#define ReportResult(a,b,c,d) ResultFromScode(b)


#ifdef WIN32
#define MAP16(v16)
#define MAP32(v32) v32
#define MAP1632(v16,v32)   v32
#else
#define MAP16(v16) v16
#define MAP32(v32)
#define MAP1632(v16,v32)   v16
#endif


/****** Misc defintions ***************************************************/

#ifdef __TURBOC__
#define implement struct huge
#else
#define implement struct
#endif
#define ctor_dtor private
#define implementations private
#define shared_state private

// helpers for internal methods and functions which follow the same convention
// as the external ones

#ifdef __cplusplus
#define INTERNALAPI_(type) extern "C" type
#else
#define INTERNALAPI_(type) type
#endif

#define INTERNAL HRESULT
#define INTERNAL_(type) type
#define FARINTERNAL HRESULT FAR
#define FARINTERNAL_(type) type FAR
#define NEARINTERNAL HRESULT NEAR
#define NEARINTERNAL_(type) type NEAR



//BEGIN REVIEW: We may not need all the following ones

#define OT_LINK     1L
#define OT_EMBEDDED 2L
#define OT_STATIC   3L


//END REVIEW .....


/****** Old Error Codes    ************************************************/

#define S_OOM               E_OUTOFMEMORY
#define S_BADARG            E_INVALIDARG
#define S_BLANK             E_BLANK
#define S_FORMAT            E_FORMAT
#define S_NOT_RUNNING       E_NOTRUNNING
#define E_UNSPEC            E_FAIL



/****** Macros for nested clases ******************************************/

/* To overcome problems with nested classes on MAC
 *
 * NC(a,b) is used to define a member function of a nested class:
 *
 * STDMETHODIMP_(type) NC(ClassName,NestedClassName)::MemberFunction(...)
 *
 * DECLARE_NC(a,b) is used within a class declaration to let a nested class
 * access it container class:
 *
 * class ClassName {
 *     ..............
 *
 *     class NestedClassName {
 *         .............
 *     };
 *     DECLARE_NC(ClassName,NestedClassName)
 *     ..............
 * };
 */

#ifdef _MAC

#define NESTED_CLASS(a,b) struct a##_##b
#define NC(a,b) a##__##b
#define NC1(a,b) a##_##b
#define DECLARE_NC(a,b) typedef a##::##b a##__##b; friend a##__##b;
#define DECLARE_NC2(a,b) typedef a##::a##_##b a##__##b; friend a##__##b;

#else

#define NC(a,b) a##::##b
#define DECLARE_NC(a,b) friend b;

#endif


/****** More Misc defintions **********************************************/


// LPLPVOID should not be made a typedef.  typedef won't compile; worse
// within complicated macros the compiler generates unclear error messages
//
#define LPLPVOID void FAR * FAR *

#define UNREFERENCED(a) ((void)(a))

#ifndef BASED_CODE
#ifdef WIN32
#define BASED_CODE
#else
#define BASED_CODE __based(__segname("_CODE"))
#endif
#endif


/****** Standard IUnknown Implementation **********************************/

/*
 *      The following macro declares a nested class CUnknownImpl,
 *      creates an object of that class in the outer class, and
 *      declares CUnknownImpl to be a friend of the outer class.  After
 *      writing about 20 class headers, it became evident that the
 *      implementation of CUnknownImpl was very similar in all cases,
 *      and this macro captures the similarity.  The classname
 *      parameter is the name of the outer class WITHOUT the leading
 *      "C"; i.e., for CFileMoniker, classname is FileMoniker.
 */

#define noError return NOERROR

#ifdef _MAC

#define STDUNKDECL(cclassname,classname) NESTED_CLASS(cclassname, CUnknownImpl):IUnknown { public: \
    NC1(cclassname,CUnknownImpl)( cclassname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: cclassname FAR* m_p##classname; }; \
    DECLARE_NC2(cclassname, CUnknownImpl) \
    NC(cclassname, CUnknownImpl) m_Unknown;

#else  // _MAC

#define STDUNKDECL( ignore, classname ) implement CUnknownImpl:IUnknown { public: \
    CUnknownImpl( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: C##classname FAR* m_p##classname; }; \
    DECLARE_NC(C##classname, CUnknownImpl) \
    CUnknownImpl m_Unknown;
#endif

/*
 *      The following macro implements all the methods of a nested
 *      CUnknownImpl class EXCEPT FOR QUERYINTERFACE.  This macro was
 *      written after about 20 classes were written in which the
 *      implementations of CUnknownImpl were all the same.
 */

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void ){ \
    return ++m_p##classname->m_refs; } \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void ){ \
    if (--m_p##classname->m_refs == 0) { delete m_p##classname; return 0; } \
    return m_p##classname->m_refs;}


/*
 *      The following macro implements class::CUnknownImpl::QueryInterface IN
 *      THE SPECIAL CASE IN WHICH THE OUTER CLASS PRESENTS ONLY ONE INTERFACE
 *      OTHER THAN IUNKNOWN AND IDEBUG.  This is not universally the case,
 *      but it is common enough that this macro will save time and space.
 */

#ifdef _DEBUG
#define STDDEB_QI(classname) \
    if (iidInterface == IID_IDebug) {*ppv = (void FAR *)&(m_p##classname->m_Debug); return 0;} else
#else
#define STDDEB_QI(classname)
#endif

#define STDUNK_QI_IMPL(classname, interfacename) \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface \
    (REFIID iidInterface, void FAR * FAR * ppv) { \
    if (iidInterface == IID_IUnknown) {\
        *ppv = (void FAR *)&m_p##classname->m_Unknown;\
        AddRef(); noError;\
    } else if (iidInterface == IID_I##interfacename) { \
        *ppv = (void FAR *) &(m_p##classname->m_##classname); \
        m_p##classname->m_pUnkOuter->AddRef(); return NOERROR; \
    } else \
        STDDEB_QI(classname) \
        {*ppv = NULL; return ResultFromScode(E_NOINTERFACE);} \
}


/*
 *      The following macro implements the IUnknown methods inherited
 *      by the implementation of another interface.  The implementation
 *      is simply to delegate all calls to m_pUnkOuter.  Parameters:
 *      ocname is the outer class name, icname is the implementation
 *      class name.
 *
 */

#define STDUNKIMPL_FORDERIVED(ocname, icname) \
STDMETHODIMP NC(C##ocname,C##icname)::QueryInterface \
(REFIID iidInterface, LPLPVOID ppvObj) { \
    return m_p##ocname->m_pUnkOuter->QueryInterface(iidInterface, ppvObj);} \
STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::AddRef(void) { \
    return m_p##ocname->m_pUnkOuter->AddRef(); } \
STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::Release(void) { \
    return m_p##ocname->m_pUnkOuter->Release(); }


/****** Debug defintions **************************************************/

#include <debug.h>


/****** Other API defintions **********************************************/

//  Utility function not in the spec; in ole2.dll.
//  Read and write length-prefixed strings.  Open/Create stream.
//  ReadStringStream does allocation, returns length of
//  required buffer (strlen + 1 for terminating null)

STDAPI  ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz );
STDAPI  WriteStringStream( LPSTREAM pstm, LPCSTR psz );
STDAPI  OpenOrCreateStream( IStorage FAR * pstg, const char FAR * pwcsName,
                                                      IStream FAR* FAR* ppstm);


// read and write ole control stream (in ole2.dll)
STDAPI  WriteOleStg (LPSTORAGE pstg, IOleObject FAR* pOleObj,
			DWORD dwReserved, LPSTREAM FAR* ppstmOut);
STDAPI  ReadOleStg (LPSTORAGE pstg, DWORD FAR* pdwFlags,
                DWORD FAR* pdwOptUpdate, DWORD FAR* pdwReserved,
				LPMONIKER FAR* ppmk, LPSTREAM FAR* pstmOut);
STDAPI ReadM1ClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteM1ClassStm(LPSTREAM pStm, REFCLSID rclsid);


// low level reg.dat access (in compobj.dll)
STDAPI CoGetInProcDll(REFCLSID rclsid, BOOL fServer, LPSTR lpszDll, int cbMax);
STDAPI CoGetLocalExe(REFCLSID rclsid, LPSTR lpszExe, int cbMax);
STDAPI CoGetPSClsid(REFIID iid, LPCLSID lpclsid);


// simpler alternatives to public apis
#define StringFromCLSID2(rclsid, lpsz, cbMax) \
    StringFromGUID2(rclsid, lpsz, cbMax)

#define StringFromIID2(riid, lpsz, cbMax) \
    StringFromGUID2(riid, lpsz, cbMax)

STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPSTR lpsz, int cbMax);
STDAPI_(BOOL) GUIDFromString(LPCSTR lpsz, LPGUID pguid);
STDAPI CLSIDFromOle1Class(LPCSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
STDAPI_(BOOL)  CoIsHashedOle1Class(REFCLSID rclsid);
STDAPI       CoOpenClassKey(REFCLSID clsid, HKEY FAR* lphkeyClsid);


// were public; now not
STDAPI  SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument);
STDAPI  GetDocumentBitStg(LPSTORAGE pStg);



/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)


#endif // _OLE2SP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\olecoll.h ===
// Microsoft OLE library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// olecoll.h - global defines for collections and element definitions

#ifndef __OLECOLL_H__
#define __OLECOLL_H__


// ---------------------------------------------------------------------------
// general defines for collections

typedef void FAR* POSITION;

#define BEFORE_START_POSITION ((POSITION)(ULONG)-1L)
#define _AFX_FP_OFF(thing) (*((UINT FAR*)&(thing)))
#define _AFX_FP_SEG(lp) (*((UINT FAR*)&(lp)+1))

#ifdef _DEBUG
#define ASSERT_VALID(p) p->AssertValid()
#else
#define ASSERT_VALID(p)
#endif


// ---------------------------------------------------------------------------
// element defintions; can only depend upon definitions in ole2int.h

// per-task data; warning, there is no destructor and so
// releasing the elements of the mapping must be done by hand;
// this also means that RemoveAll should not be called and that
// RemoveKey should be called only after freeing the contained maps.
typedef struct FAR Etask
{
	DWORD m_pid;						// unique process id
	DWORD m_Dllinits;						// number of times init'd
	HTASK m_htask;
	DWORD m_inits;						// number of times init'd
	DWORD m_oleinits;					// number of OleInit
	DWORD m_reserved;					// reserved
	IMalloc FAR* m_pMalloc;				// task allocator (always one)
	IMalloc FAR* m_pMallocShared;		// shared allocator (always one)
	IMalloc FAR* m_pMallocSBlock;		// shared block allocator (if one)
	IMalloc FAR* m_pMallocPrivate;		// private allocator (if one)
	class CDlls FAR* m_pDlls;			// list of dlls loaded and their counts
	class CMapGUIDToPtr FAR* m_pMapToServerCO;//server class obj if reg/loaded
	class CMapGUIDToPtr FAR* m_pMapToHandlerCO;//handler CO obj if reg/loaded

	class CSHArray FAR* m_pArraySH;		// array of server/handler entries

	class CThrd FAR* m_pCThrd;			// pointer to header of thread list
	HWND  m_hwndClip;					// hwnd of our clip window
	HWND  m_hwndDde;					// hwnd of system dde window
	IUnknown FAR* m_punkState;		// Storage for CoGet/SetState
} _Etask;

#endif //!__OLECOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\prxsegs.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ole2ui.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

/* NOTE: All dialog and string resource ID's defined in this file are
 *    in the range:
 *          32248 - 32504   (0x7DF8 - 0x7EF8)
*/


#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#if !defined(__cplusplus) && !defined( __TURBOC__)
#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)
#endif

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include <dlgs.h>           //For fileopen dlg; standard include
#include "olestd.h"

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

#ifdef WIN32
#define _fmemset memset
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrrchr strrchr
#define _fstrtok strtok
#define lstrcpyn strncpy

// isspace function does not seem to work properly
#undef isspace
#define isspace(j) (j==' ' || j=='\t' || j=='\n')
#endif  // WIN32

#if !defined( EXPORT )
#ifdef WIN32
#define EXPORT
#else
#define EXPORT  __export
#endif  // WIN32
#endif  // !EXPORT

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * must be called prior to using any functions in OLE2UI, and OleUIUnInitialize
 * must be called before you app shuts down and when you are done using the
 * library.
 *
 * NOTE:  If you are using the DLL version of this library, these functions
 * are automatically called in the DLL's LibMain and WEP, so you should
 * not call them directly from your application.
 */

// Backward compatibility with older library
#define OleUIUninitialize OleUIUnInitialize

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance, HINSTANCE hPrevInst);
STDAPI_(BOOL) OleUIUninitialize(void);

#if !defined( SZCLASSICONBOX )
#define SZCLASSICONBOX  "ole2uiIBCls"
#endif

#if !defined( SZCLASSRESULTIMAGE )
#define SZCLASSRESULTIMAGE  "ole2uiRICls"
#endif

// object count, used to support DllCanUnloadNow and OleUICanUnloadNow
extern DWORD g_dwObjectCount;

STDAPI OleUICanUnloadNow(void);
STDAPI OleUILockLibrary(BOOL fLock);


//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        32248
#define IDD_CHANGEICON          32249
#define IDD_CONVERT             32250
#define IDD_PASTESPECIAL        32251
#define IDD_EDITLINKS           32252
#define IDD_FILEOPEN            32253
#define IDD_BUSY                32254
#define IDD_UPDATELINKS         32255
#define IDD_CANNOTUPDATELINK    32256
#define IDD_CHANGESOURCE        32257
#define IDD_INSERTFILEBROWSE    32258
#define IDD_CHANGEICONBROWSE    32259

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_LINKSOURCEUNAVAILABLE   32260
#define IDD_SERVERNOTREG        32261
#define IDD_LINKTYPECHANGED     32262
#define IDD_SERVERNOTFOUND      32263
#define IDD_OUTOFMEMORY         32264

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       32300
#define IDS_OLE2UILINK          32301
#define IDS_OLE2UIOBJECT        32302
#define IDS_OLE2UIEDIT          32303
#define IDS_OLE2UICONVERT       32304
#define IDS_OLE2UIEDITLINKCMD_1VERB     32305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   32306
#define IDS_OLE2UIEDITLINKCMD_NVERB     32307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   32308
#define IDS_OLE2UIEDITNOOBJCMD  32309
// def. icon label (usu. "Document")
#define IDS_DEFICONLABEL        32310
#define IDS_OLE2UIPASTELINKEDTYPE  32311


#define IDS_FILTERS             32320
#define IDS_ICONFILTERS         32321
#define IDS_BROWSE              32322

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  32325
#define IDB_RESULTSVGA                  32326
#define IDB_RESULTSHIRESVGA             32327


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

//Standard error definitions
#define OLEUI_FALSE                     0
#define OLEUI_SUCCESS                   1     //No error, same as OLEUI_OK
#define OLEUI_OK                        1     //OK button pressed
#define OLEUI_CANCEL                    2     //Cancel button pressed

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             256

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
							 LPSTR lpszShortType,
							 HMENU hMenu,
							 UINT uPos,
							 UINT uIDVerbMin,
							 UINT uIDVerbMax,
							 BOOL bAddConvert,
							 UINT idConvert,
							 HMENU FAR *lphMenu);

//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Return space for class ID
	LPSTR           lpszFile;         //Filename for inserts or links
	UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
	UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

	//Specific to create objects if flags say so
	IID             iid;              //Requested interface on creation.
	DWORD           oleRender;        //Rendering option
	LPFORMATETC     lpFormatEtc;      //Desired format
	LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
	LPSTORAGE       lpIStorage;       //Storage used for the object
	LPVOID FAR     *ppvObj;           //Where the object is returned.
	SCODE           sc;               //Result of creation calls.
	HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
									  //IFF we couldn't stuff it in the cache.
	} OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L
#define IOF_DISABLEDISPLAYASICON    0x00000400L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113

// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 32400
#define IDS_IORESULTNEWICON             32401
#define IDS_IORESULTFROMFILE1           32402
#define IDS_IORESULTFROMFILE2           32403
#define IDS_IORESULTFROMFILEICON2       32404
#define IDS_IORESULTLINKFILE1           32405
#define IDS_IORESULTLINKFILE2           32406
#define IDS_IORESULTLINKFILEICON1       32407
#define IDS_IORESULTLINKFILEICON2       32408

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUIPASTESPECIAL.

	//IN  fields
	LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the
										// clipboard) for data to paste

	LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which
										// specifies acceptable formats. See
										// OLEUIPASTEENTRY for more info.
	int             cPasteEntries;      //No. of OLEUIPASTEENTRY array entries

	UINT        FAR *arrLinkTypes;      //List of link types that are
										// acceptable. Link types are referred
										// to using OLEUIPASTEFLAGS in
										// arrPasteEntries
	int             cLinkTypes;         //Number of link types
	UINT            cClsidExclude;      //Number of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;     //List of CLSIDs to exclude from list.

	//OUT fields
	int             nSelectedIndex;     //Index of arrPasteEntries[] that the
										// user selected
	BOOL            fLink;              //Indicates if Paste or Paste Link was
										// selected by the user
	HGLOBAL         hMetaPict;          //Handle to Metafile containing icon
										// and icon title selected by the user
										// Use the Metafile utility functions
										// defined in this header to
										// manipulate hMetaPict
	SIZEL           sizel;              // size of object/link in its source
										//  if the display aspect chosen by
										//  the user matches the aspect
										//  displayed in the source. if
										//  different aspect is chosen then
										//  sizel.cx=sizel.cy=0 is returned.
										//  sizel displayed in source is
										//  retrieved from the
										//  ObjectDescriptor if fLink is FALSE
										//  LinkSrcDescriptor if fLink is TRUE
	} OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L

//Select Paste radio button at dialog startup. This is the default if
// PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also specifies
// state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L

//Select PasteLink radio button at dialog startup. Also specifies state of
// button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L

//Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag
#define PSF_CHECKDISPLAYASICON      0x00000008L
#define PSF_DISABLEDISPLAYASICON    0x00000010L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                32410
#define IDS_PSPASTEOBJECT              32411
#define IDS_PSPASTEOBJECTASICON        32412
#define IDS_PSPASTELINKDATA            32413
#define IDS_PSPASTELINKOBJECT          32414
#define IDS_PSPASTELINKOBJECTASICON    32415
#define IDS_PSNONOLE                   32416
#define IDS_PSUNKNOWNTYPE              32417
#define IDS_PSUNKNOWNSRC               32418
#define IDS_PSUNKNOWNAPP               32419


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
	//*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
	STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
	STDMETHOD(SetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR       lpszDisplayName,
			ULONG       lenFileName,
			ULONG FAR*  pchEaten,
			BOOL        fValidateSource) PURE;
	STDMETHOD(GetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR FAR*  lplpszDisplayName,
			ULONG FAR*  lplenFileName,
			LPSTR FAR*  lplpszFullLinkType,
			LPSTR FAR*  lplpszShortLinkType,
			BOOL FAR*   lpfSourceAvailable,
			BOOL FAR*   lpfIsSelected) PURE;
	STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(UpdateLink) (THIS_
			DWORD dwLink,
			BOOL fErrorMessage,
			BOOL fErrorAction) PURE;
	STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

	LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
												//links in the container
	} OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L
#define ELF_DISABLEUPDATENOW        0x00000002L
#define ELF_DISABLEOPENSOURCE       0x00000004L
#define ELF_DISABLECHANGESOURCE     0x00000008L
#define ELF_DISABLECANCELLINK       0x00000010L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_COL1                     220
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
	HGLOBAL         hMetaPict;      //Current and final image.  Source of the
									//icon is embedded in the metafile itself.
	CLSID           clsid;          //IN only: class used to get Default icon
	char            szIconExe[OLEUI_CCHPATHMAX];
	int             cchIconExe;
	} OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         32430
#define IDS_CIINVALIDFILE           32431
#define IDS_CIFILEACCESS            32432
#define IDS_CIFILESHARE             32433
#define IDS_CIFILEOPENFAIL          32434



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Class ID sent in to dialog: IN only
	CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
	CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

	CLSID           clsidNew;         //Selected Class ID: OUT only
	DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
									  //DVASPECT_ICON
	WORD            wFormat;          //Original data format
	BOOL            fIsLinkedObject;  //IN only; true if object is linked
	HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
	LPSTR           lpszUserType;     //IN-OUT: user type name of original class.
									  //  We'll do lookup if it's NULL.
									  //  This gets freed on exit.
	BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)
	LPSTR           lpszDefLabel;     //IN-OUT: default label to use for icon.
									  //  if NULL, the short user type name
									  //  will be used. if the object is a
									  //  link, the caller should pass the
									  //  DisplayName of the link source
									  //  This gets freed on exit.

	UINT            cClsidExclude;    //IN: No. of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //IN: List of CLSIDs to exclude from list
	} OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

// Determine if there is at least one class that can Convert or ActivateAs
// the given clsid.
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
		REFCLSID    rClsid,
		BOOL        fIsLinkedObject,
		WORD        wFormat
);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L
#define CF_DISABLEDISPLAYASICON    0x00000020L
#define CF_DISABLEACTIVATEAS       0x00000040L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     32440
#define IDS_CVRESULTCONVERTTO       32441
#define IDS_CVRESULTNOCHANGE        32442
#define IDS_CVRESULTDISPLAYASICON   32443
#define IDS_CVRESULTACTIVATEAS      32444
#define IDS_CVRESULTACTIVATEDIFF    32445


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIBUSY.
	HTASK           hTask;            //IN: HTask which is blocking
	HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
	} OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            32447
#define IDS_BZRESULTTEXTNOTRESPONDING   32448

// Links dialog stringtable defines
#define IDS_LINK_AUTO           32450
#define IDS_LINK_MANUAL         32451
#define IDS_LINK_UNKNOWN        32452
#define IDS_LINKS               32453
#define IDS_FAILED              32454
#define IDS_CHANGESOURCE        32455
#define IDS_INVALIDSOURCE       32456
#define IDS_ERR_GETLINKSOURCE   32457
#define IDS_ERR_GETLINKUPDATEOPTIONS    32458
#define IDS_ERR_ADDSTRING       32459
#define IDS_CHANGEADDITIONALLINKS   32460
#define IDS_CLOSE               32461


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C"
#endif
int EXPORT FAR CDECL OleUIPromptUser(WORD nTemplate, HWND hwndParent, ...);

#define UPDATELINKS_STARTDELAY  2000    // Delay before 1st link updates
										//  to give the user a chance to
										//  dismiss the dialog before any
										//  links update.

STDAPI_(BOOL) OleUIUpdateLinks(
		LPOLEUILINKCONTAINER lpOleUILinkCntr,
		HWND hwndParent,
		LPSTR lpszTitle,
		int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
		HWND        hWndHatch,
		LPRECT      lprcIPObjRect,
		LPRECT      lprcClipRect,
		LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,				0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

struct FAR CPlex    // warning variable length structure
{
	CPlex FAR* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	INTERNAL_(void FAR*) data() { return this+1; }

	static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, DWORD mp, UINT nMax, UINT cbElement);

	INTERNAL_(void) FreeDataChain(DWORD mp);       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\olemem.h ===
#if !defined( _OLEMEM_H_ )
#define _OLEMEM_H_

// All the following Global calls deal with LPSTR

#ifdef _MAC
pascal DWORD OleGlobalSize(HANDLE);
pascal LPSTR OleGlobalAlloc(WORD, DWORD);
pascal BOOL OleGlobalFree(LPSTR);	// true success, false fail
pascal LPSTR OleGlobalLock(HANDLE);
pascal BOOL OleGlobalUnlock(LPSTR);	// true success, false fail

#else

#define	OleGlobalAlloc(flags,dwSize) ( \
	Win(GlobalLock(GlobalAlloc(flags, dwSize)))\
)

#define OleGlobalFree(lp) ( \
	Win(GlobalFree((HANDLE)GlobalHandle((__segment)lp))) \
)

#define OleGlobalLock(hMem) ( \
	Win(GlobalLock(hMem))\
)
		
#define OleGlobalUnlock(lp) ( \
	Win(GlobalUnlock((HANDLE)GlobalHandle((__segment)lp))) \
)

#endif


		
#ifndef _MAC	// Windows 

// All the following Local calls deal with PSTR

#define	OleLocalAlloc(flags,wSize)		(LocalLock(LocalAlloc(flags, wSize)))

#define OleLocalFree(np) {\
	LocalUnlock((HANDLE)LocalHandle((WORD)np)); \
	LocalFree((HANDLE)LocalHandle((WORD)np)); \
}

#define OleLocalLock(hMem)		(LocalLock(hMem))
		
#define OleLocalUnlock(np)		(LocalUnlock((HANDLE)LocalHandle((WORD)np)))

#else			// MAC
	
#define	OleLocalAlloc(flags,wSize)		OleGlobalAlloc(flags, wSize)
#define OleLocalFree (ptr)				OleGlobalFree(ptr)
#define OleLocalLock(hMem)				OleGlobalLock(hMem)
#define OleLocalUnlock(ptr)				OleGlobalUnlock(ptr)

#endif

#endif // _OLEMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\olerem.h ===
// olerem.h - private defintions for OLE implementation of REMoting

#if !defined( _OLEREM_H_ )
#define _OLEREM_H_

// name changes
#define ILrpc IRpcChannel
#define IStub IRpcStub
#define IProxy IRpcProxy
#define Dispatch Invoke

#define IID_ILrpc IID_IRpcChannel
#define IID_IStub IID_IRpcStub
#define IID_IProxy IID_IRpcProxy

// -----------------------------------------------------------------------
// init/term

STDAPI RemInitialize(void);
STDAPI_(void) RemUninitialize(void);

#ifdef _MAC
// entry point for lrpc HLE's
STDAPI RemProcessLrpcHLE(EventRecord *pHle);
#endif

// -----------------------------------------------------------------------
// Communications Layer

typedef LONG OID;

STDAPI_(OID) RemAllocOID(interface IStubManager FAR* pSM);
STDAPI_(BOOL) RemFreeOID(OID oid);

// NOTE: ILrpc defined in stdps.h

STDAPI RemConnectToObject(OID oid, ILrpc FAR* FAR* ppLrpc);
STDAPI RemDisconnectObject(OID oid, DWORD dwReserved);


// -----------------------------------------------------------------------
// State Management

// Class Factory Table

STDAPI RemRegisterFactory(REFCLSID rclsid, IUnknown FAR* pUnk, DWORD dwContext,
            DWORD flags, LPDWORD lpdwRegister);
STDAPI RemRevokeFactory(DWORD dwRegister, LPCLSID lpclsid,
            IUnknown FAR* FAR* ppUnk, LPDWORD lpdwContext);
STDAPI RemLookupFactory(REFCLSID rclsid, BOOL fHide, OID FAR *pOid);


// Handler Table

interface IProxyManager : public IUnknown
{
    STDMETHOD(CreateServer)(REFCLSID rclsid) = 0;
    STDMETHOD(Connect)(OID oid, REFCLSID rclsid) = 0;
    STDMETHOD(LockConnection)(BOOL fLock, BOOL fLastUnlockReleases) = 0;
    STDMETHOD_(void, GetClassID)(CLSID FAR* pClsid) = 0;
    STDMETHOD_(OID, GetOID)() = 0;
    STDMETHOD_(BOOL, IsConnected)(void) = 0;
    STDMETHOD(EstablishIID)(REFIID iid, LPVOID FAR* ppv) = 0;
    STDMETHOD_(void, Disconnect)() = 0;
};

INTERNAL RemSetHandler(OID oid, REFCLSID clsid, IProxyManager FAR* pPM);
INTERNAL RemClearHandler(OID oid, IProxyManager FAR* pPM);



// Server Table

interface IStubManager : public IUnknown
{
    STDMETHOD_(void, SetReg)(OID oid) = 0;
    STDMETHOD_(void, Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)() = 0;
    STDMETHOD_(OID, GetOID)() = 0;
    STDMETHOD_(IUnknown FAR*, GetServer)(BOOL fAddRef) = 0;
    STDMETHOD_(void, AddRefRegConn)(DWORD mshlflags) = 0;
    STDMETHOD_(void, ReleaseRegConn)(DWORD mshlflags, BOOL fLastUR) = 0;
    STDMETHOD (Dispatch)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx, BOOL FAR* lpfStrongConn) = 0;
};

// tables are now merged; combined registration:

// MSHLHDR: first part of what is written to marshal stream
struct FAR MSHLHDR
{
	CLSID clsid;					// oid == NULL -> unmarshal class
									// oid != NULL -> class of handler
	OID oid;						// global id for object
	DWORD mshlflags;				// marshal flags
};


struct FAR SHREG
{
	MSHLHDR m_hdr;					// simplifies things; see below
	IUnknown FAR* m_pUnkLookup;		// NOTE: no addref
	IStubManager FAR* m_pSM;		// if NULL, have handler
};

// There are two forms of SHREG:
// 1. server registration:
//		m_hdr.clsid is class of handler
//		m_hdr.oid is non-NULL
//		m_hdr.mshlflags is NULL
//		m_pUnkLookup = non-addref'd pointer to server; not necessarily valid
//				(not valid when stubmgr disconnected, but still registered)
//		m_pSM = addref'd pointer to stubmgr.
//
// 2. handler registration (when connected to server)
//		m_hdr.clsid is class of handler (same as above)
//		m_hdr.oid is non-NULL
//		m_hdr.mshlflags is NULL
//		m_pUnkLookup = non-addref'd pProxyManager of handler; always valid
//		m_pSM = NULL
//
// NOTE: the MSHLHDR is present in the SHREG so as to make CoMarshalInterface
// faster.  The m_hdr.mshlflags is always zero in a reg entry; is set before
// writing the hdr to a stream.
//
// We get and save the clsid so that we don't have to figure it out each
// time we marshal the interface.

// see olerem2.h for inline functions that manipulate SHREGs.

STDAPI RemRegisterServer(IUnknown FAR* pUnk, DWORD mshlflags, SHREG FAR* pshreg);
STDAPI RemRevokeServer(OID oid);
STDAPI RemLookupSHOID(OID oid, IProxyManager FAR* FAR* ppPM,
				IStubManager FAR* FAR* ppSM);
STDAPI RemLookupSHUnk(IUnknown FAR* pUnkGiven, IUnknown FAR* FAR* ppUnkServer, SHREG FAR* pshreg);


// -----------------------------------------------------------------------
// Other Routines

STDAPI RemCreateRemoteHandler(REFCLSID rclsid, IUnknown FAR* pUnkOuter, REFIID riid, void FAR* FAR* ppv);

INTERNAL RemCreateRHClassObject(REFCLSID rclsid, IID iid, void FAR* FAR* ppv);

INTERNAL RemEnsureLocalClassObject(REFCLSID rclsid, OID FAR* pOidCF);

INTERNAL RemEnsureUniqueHandler(REFCLSID rclsid, OID oid,
				IUnknown FAR* FAR* ppUnk, IProxyManager FAR* FAR* ppPM);


// REVIEW MM2 (craigwi): these aren't used much; do we keep them?

/* -----------------------------------------------------------------------
 * Proxy/Stub macros
 *
 * The follwoing macros can be used to implement Proxy/Stub classes for
 * classes that support only one or more interfaces other then IUnknown
 * (and maybe IDebug).  The resulting classes will support IProxy, IStub
 * interface in addition to the interfaces supported by the original class.
 * Assuming the interfaces supported is IName and it is implemented
 * by a class CName:
 *
 * Declaration (in *.h):
 *
 * class CName {                class CNameProxy {                  class CNameStub {
 *   ............                   ............                        ............
 *   STDUNKDECL(CName,Name)         STDUNKDECL(CNameProxy,NameProxy)     STDUNKDECL(CNameStub,NameStub)
 *   STDDEBDECL(CName,Name)         STDDEBDECL(CNameProxy,NameProxy)     STDDEBDECL(CNameStub,NameStub)
 *                                  STDPROXYDECL(CNameProxy,NameProxy)   STDSTUBDECL(NameStub,1)
 *   <IName Declaration>            <IName for proxy>                   <IName for stub>
 *   ............                   ............                        ............
 * };                           };                                  };
 *
 * Implementation (in *.cpp):
 *
 * For original object:
 *
 * STDUNKIMPL(Name)
 *
 * STDUNK_QI_IMPL(Name,Name)
 *
 * STDUNKIMPL_FORDERIVED(Name,NameImpl)
 *
 * <Implementation of IName: CNameImpl>
 *
 *
 * For proxy object:
 *
 * STDUNKIMPL(NameProxy)
 *
 * STDUNK_PROXY_QI_IMPL(NameProxy,Name)
 *
 * STDUNKIMPL_FORDERIVED(NameProxy,NameProxyImpl)
 *
 * STDPROXYIMPL(NameProxy)
 *
 * <Implementation of IName: CNameProxyImpl>
 *
 *
 * For stub object:
 *
 * STDUNKIMPL(NameStub)
 *
 * STDUNK_STUB_QI_IMPL(NameStub,Name)
 *
 * STDUNKIMPL_FORDERIVED(NameStub,NameStubImpl)
 *
 * STDSTUBIMPL(NameStub)
 *
 * <Implementation of IName: CNameStubImpl>
 *
 *
 */

// Mattp: I have moved the body of destructor to the implementation macro. ( STDPROXYIMPL)

#define STDPROXYDECL(ignore, classname)                        \
    implement CProxy : IProxy                  { public:      \
    CProxy(C##classname FAR* p##classname)             \
        { m_p##classname = p##classname; }            \
    ~CProxy(void);                                       \
    STDMETHOD(QueryInterface)(REFIID iid, LPLPVOID ppvObj);\
    STDMETHOD_(ULONG,AddRef)(void);                            \
    STDMETHOD_(ULONG,Release)(void);                           \
    STDMETHOD(Connect)(ILrpc FAR* pILrpc);              \
    STDMETHOD_(void, Disconnect)(void);                        \
    private: C##classname FAR* m_p##classname; };      \
    DECLARE_NC(C##classname,CProxy)                    \
    CProxy m_Proxy;


#define STDSTUBDECL(ignore, classname,cIface)                  \
    implement CStub : IStub                    { public:      \
    CStub(C##classname FAR* p##classname)              \
         { m_p##classname = p##classname; m_pUnkObject = NULL; }            \
    ~CStub(void)                                       \
           { M_PROLOG(m_p##classname); if (m_pUnkObject != NULL) m_pUnkObject->Release(); } \
    INTERNAL_(BOOL) Init(IUnknown FAR* pUnkObject);     \
    STDMETHOD(QueryInterface)(REFIID iid, LPLPVOID ppvObj);\
    STDMETHOD_(ULONG,AddRef)(void);                            \
    STDMETHOD_(ULONG,Release)(void);                           \
    STDMETHOD(Connect)(IUnknown FAR* pUnkObject);       \
    STDMETHOD_(void, Disconnect)(void);                        \
    STDMETHOD(Dispatch)(REFIID iid, int iMethod, IStream FAR* pIStream,  \
            DWORD dwDestCtx, LPVOID lpvDestCtx);            \
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid); \
    STDMETHOD_(ULONG, CountRefs)(void); \
    private: C##classname FAR* m_p##classname; \
             IUnknown FAR* m_pUnkObject; \
             IUnknown FAR* m_aStubIface[cIface]; };      \
    DECLARE_NC(C##classname,CStub)                     \
    CStub m_Stub;


#define CONSTRUCT_PROXY m_Proxy(this),
#define CONSTRUCT_STUB m_Stub(this),


#define STDUNK_PROXY_QI_IMPL(classname,interfacename)  \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface    \
                    (REFIID iidInterface, void FAR* FAR* ppv) {  \
    M_PROLOG(m_p##classname);                               \
    if (iidInterface == IID_IUnknown)                  \
        { *ppv = (void FAR*)&m_p##classname->m_Unknown; AddRef(); noError; }  \
    else if (iidInterface == IID_I##interfacename)     \
        { *ppv = (void FAR*) &(m_p##classname->m_##classname); \
          m_p##classname->m_pUnkOuter->AddRef(); noError; } \
    else if (iidInterface == IID_IProxy)               \
        { *ppv = (void FAR*) &(m_p##classname->m_Proxy); AddRef(); noError; } \
    else                                               \
    STDDEB_QI(classname)                               \
    { *ppv = NULL; return ResultFromScode(E_NOINTERFACE); }                   \
    }


#define STDUNK_STUB_QI_IMPL(classname,interfacename)   \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface    \
                    (REFIID iidInterface, void FAR* FAR* ppv) {  \
    A5_PROLOG(m_p##classname);                              \
    if (iidInterface == IID_IUnknown)                  \
        *ppv = (void FAR*)&m_p##classname->m_Unknown;  \
    else if (iidInterface == IID_IStub)                \
        *ppv = (void FAR*) &(m_p##classname->m_Stub);  \
    else                                               \
    STDDEB_QI(classname)                               \
    { *ppv = NULL; RESTORE_A5(); return ResultFromScode(E_NOINTERFACE); }                        \
    ++(m_p##classname->m_refs); RESTORE_A5(); noError; }

// Mattp: The destructor implementation has been moved to here to allow us the outer
// reference to 'm_pILrpc'.

#define STDPROXYIMPL(classname) \
    NC(C##classname,CProxy)::~CProxy(void) \
        { M_PROLOG(m_p##classname);if (m_p##classname->m_pILrpc) m_p##classname->m_pILrpc->Release();}\
    STDMETHODIMP  NC(C##classname,CProxy)::QueryInterface(REFIID iid, LPLPVOID ppvObj) \
        {  M_PROLOG(m_p##classname);return m_p##classname->m_Unknown.QueryInterface (iid, ppvObj); } \
    STDMETHODIMP_(ULONG)  NC(C##classname,CProxy)::AddRef(void)                    \
        {  M_PROLOG(m_p##classname);return m_p##classname->m_Unknown.AddRef(); }                     \
    STDMETHODIMP_(ULONG)  NC(C##classname,CProxy)::Release(void)                   \
        {  M_PROLOG(m_p##classname);return m_p##classname->m_Unknown.Release(); }                    \
    STDMETHODIMP NC(C##classname,CProxy)::Connect(ILrpc FAR* pILrpc)       \
        {                                                                  \
            M_PROLOG(m_p##classname);                                       \
            if (pILrpc) {                                                  \
              pILrpc->AddRef();                                            \
              m_p##classname->m_pILrpc = pILrpc;                           \
              return NOERROR;                                                 \
          } else                                                           \
              return ResultFromScode(E_UNSPEC);                                             \
        }                                                                  \
    STDMETHODIMP_(void) NC(C##classname,CProxy)::Disconnect(void)          \
        {                                                                  \
            M_PROLOG(m_p##classname);                                       \
            if (m_p##classname->m_pILrpc)                                  \
                m_p##classname->m_pILrpc->Release();                       \
            m_p##classname->m_pILrpc = NULL;                               \
        }


#define STDSTUBIMPL(classname) STDUNKIMPL_FORDERIVED(classname,Stub)    \
    STDMETHODIMP NC(C##classname,CStub)::Connect(IUnknown FAR* pUnkObject)   \
        { M_PROLOG(m_p##classname);return Init(pUnkObject) ? NOERROR : ResultFromScode(E_UNSPEC); } \
    STDMETHODIMP_(void) NC(C##classname,CStub)::Disconnect(void)             \
        {M_PROLOG(m_p##classname); Init(NULL); }


/*
 * Ole2 marshalling stuff
 *
 * REVIEW: this should go into ole2sp.h, but ILrpc is defined here and
 * olerem.h is included after ole2sp.h ...
 */

//
//  MOP is a single instruction to the interpreter that encodes,
//  decodes parameters sent via LRPC.  A string of Mops describes how to
//  marshal, unmarshal function's paramaters.
//
//

typedef enum MOP {
    NilMop,
               // Basic types                 size of type (win3.1)
    Void,          // No value                   0b
    This,          // FAR* this                  -- Not used
    Int,           // (INT == int)               2b
    uInt,          // (UINT == unsigned int)     2b
    Long,          // (LONG == long)             4b
    uLong,         // (ULONG == unsigned long)   4b
    Word,          // WORD                       2b
    dWord,         // DWORD                      4b
    Bool,          // BOOL                       2b
    lpStr,         // LPSTR                      -- (zero terminated)
    lplpStr,       // LPLPSTR                    -- (zero terminated)
    pBuf,          // void FAR*                  -- (size in following long)

               // Windows types
    wParam,        // WPARAM                     2b
    lParam,        // LPARAM                     4b
    _Handle,       // HANDLE                     2b
    hWnd,          // HWND                       2b
    hDc,           // HDC                        2b
    hRgn,          // HRGN                       2b
    hClip,         // HANDLE                     2b
    _Point,        // POINT                      4b
    _Size,         // SIZE                       4b
    _Rect,         // RECT                       8b
    Msg,           // MSG                       18b

               // Ole/Win32 types
    _Pointl,       // POINTL                     8b
    _Sizel,        // SIZEL                      8b
    _Rectl,        // RECTL                     16b

               // Ole types
    Hresult,       // HRESULT                    4b
    Cid,           // CID                       16b
    Iid,           // IID                       16b
    wChar,         // WCHAR                      2b
    Time,          // TIME_T                     4b
    StatStg,       // STATSTG                 > 38b + size of member lpstr
    Layout,        // OLELAYOUT                  2b   bad size
    ClipFor,       // CLIPFORMAT                 2b   MAC bad size
    DAspect,       // DVASPECT                   4b
    TyMed,         // TYMED                      4b
    Verb,          // OLEVERB                 > 14b + size of member lpstr
    TDev,          // DVTARGETDEVICE          > 16b
    SMedium,       // STGMEDIUM               > 12b + size of member lpstr
    ForEtc,        // FORMATETC               > 18b + size of member tdev
    StatDat,       // STATDATA                > 48b + size of member foretc
    IFace,         // interface FAR*          > 40b
    MenuWidths,    // OLEMENUGROUP_WIDTHS       24b
    hMenu,         // HMENU                      2b
    hOMenu,        // HOLEMENU                   2b
    hAccel,        // HACCEL                     2b
    FrameInfo,     // OLEINPLACEFRAMEINFO       10b
    BindOpt,       // BIND_OPTS                 12b   might change (02/15/2000-- not likely)
    LogPal,        // LOGPALETTE              >  8b

	ArraySize,	   // the following is an array arg list
    GenMops,	   // generic mop: used for with eg. Enum Next
	RunArg,		   // inidicates a run modifier: Min or Mout based of return or not
	// ->see example

               // Modifiers
    MMask = 0xc0,
    MIn   = 0x40,  // FAR Pointer to in parameter
    MOut  = 0x80,  // FAR Pointer to out parameter
    MIO   = 0xc0,  // FAR Pointer to in, out parameter

               // Interface indexes (overlap mop values)
    ILast = 1,     // Use last marshalled interface
    IUnk,          // IUnknown
    IMnk,          // IMoniker
    IStg,          // IStorage

    IDObj,         // IDataObject
    IVObj,         // IViewObject
    IOleObj,       // IOleObject
    IIpObj,        // IOleInPlaceObject

    ICSite,        // IOleClientSite
    IIpSite,       // IOleInPlaceSite
    IAdvSink,      // IAdviseSink

    IPDName,       // IParseDisplayName
    IOleCont,      // IOleContainer
    IOleItemCont,  // IOleItemContainer
    IBCtx,         // IBindCtx

    IEStatData,    // IEnumSTATDATA
    IEForEtc,      // IEnumFORMATETC
    IEStr,         // IEnumString
    IEVerbs,       // IEnumOLEVERB
    IEMnk,         // IEnumMoniker

    IOleWnd,       // IOleWIndow
    IIpUiWnd,      // IOleInPlaceUIWindow
    IIpFrame,      // IOleInPlaceFrame
    IIpAObj,       // IOleInPlaceActiveObject

    IStStream,
    IEnumStatStg
} MOP;
//
// Modifiers combine with other types to indicate pointer to the type:
// - MIn  values are passed on call, but not updated upon return
// - MOut values are not passed on call, but are updated upon return
// - MIO  values are passed on call, and updated upon return.
//
// M** indicates the argument is a pointer to the type.  For types
// which imply pointer (lpStr, pBuf, IMnk) M** indicates pointer to a pointer
// (as in LPSTR FAR*, IEnumClipFormat FAR* FAR*).  For MOut the value pointed
// (i.e. the interface pointer) is ignored.  MIn, MIO not supported.
//
// Interface indexes follow IFace mop to specify type of interface being
// marshalled.  ILast specify last IID marshalled.
//
// By convention the return value is always an HRESULT.
//
// MOP is an 8-bit value; it fits in a BYTE.  Example:
//
// static mopsSomeFunc[] { pBuf | MIn, uLong, IFace, IDObj, ..., NilMop };
//

// Example for generic mops!
// static BYTE ForEtcMop[] = { MopSize(22), ClipFor, RunArg, TDev, DAspect, Long, TyMed, NilMop };
// static BYTE mopsForEtcNext[] = { uLong, ArraySize, GenMops | MOut, MopPtr(ForEtcMop), uLong | MOut, NilMop };
//



// FNI describes how to marshal, unmarshal specific function
//
typedef int FNITYPE;

#define FNITYPE_NilFni  0
#define FNITYPE_RevArg  0x01    // Arguments pushed left-to-right (pascal)
#define FNITYPE_Clean   0x02    // Callee cleans stack (pascal)
#define FNITYPE_Method  0x04    // Class method.
#define FNITYPE_Virtual 0x08    // Virtual function
#define FNITYPE_Send    0x10    // Use SendMessage (not PostMessage)
#define FNITYPE_NoWait  0x20    // Do not wait for reply (only when PostMessage)

struct FAR FNI {            // Static data for function marshalling
    FNITYPE m_type;         // Function description
    struct {                // For virtual function
       const IID FAR* lpIID;//     far pointer to Interface ID
       int iMethod;         //     Method index
    } m_loc;                // ----
    UINT m_cbStk;           // Stack space for pushing all arguments
    UINT m_cbStm;           // Stream space for marshalling arguments
    UINT m_cbExtStm;        // Additional stream space for strings, buffers
    BYTE FAR* m_args;       // Arguments MOPs
};

//
// Example
//
//static FNI fniSomeFunc = {
//                FNITYPE_Method | FNITYPE_Virtual,
//                {                          //interface and method Indices
//                    &_IID_ISomeIface,
//                    IFUNC_SomeFunc
//                },
//                64,             // Stack space
//                96,             // Minimun Stream space
//                48,             // Estimated extra stream space
//                mopsSomeFunc    // The mops
//};
//
// _IID_ISomeIface is the IID for the interface of this object,
// IIFACE_SomeFunc is the index of this method within the interface.
//


STDAPI LrpcCall(ILrpc FAR* pILrpc, FNI FAR* pfni, void FAR* pFirstArg);

STDAPI LrpcDispatch(IStream FAR* pIStream, FNI FAR* pfni, void FAR* pObj);

BOOL IsValidOID(OID oid);

#endif // _OLEREM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\olestd.h ===
/*************************************************************************
**
**    OLE 2.0 Standard Utilities
**
**    olestd.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for the common OLE 2.0
**    utilities.
**    These utilities include the following:
**          Debuging Assert/Verify macros
**          HIMETRIC conversion routines
**          reference counting debug support
**          OleStd API's for common compound-document app support
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#if !defined( _OLESTD_H_ )
#define _OLESTD_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OLESTD.H from " __FILE__)
#endif  /* RC_INVOKED */

#if defined( __TURBOC__ ) || defined( WIN32 )
#define _based(a)
#endif

#ifndef RC_INVOKED
#include <dos.h>        // needed for filetime
#endif  /* RC_INVOKED */

#include <commdlg.h>    // needed for LPPRINTDLG
#include <shellapi.h>   // needed for HKEY

// String table defines...
#define  IDS_OLESTDNOCREATEFILE   700
#define  IDS_OLESTDNOOPENFILE     701
#define  IDS_OLESTDDISKFULL       702


/*
 * Some C interface declaration stuff
 */

#if ! defined(__cplusplus)
typedef struct tagINTERFACEIMPL {
        IUnknownVtbl FAR*       lpVtbl;
        LPVOID                  lpBack;
        int                     cRef;   // interface specific ref count.
} INTERFACEIMPL, FAR* LPINTERFACEIMPL;

#define INIT_INTERFACEIMPL(lpIFace, pVtbl, pBack)   \
        ((lpIFace)->lpVtbl = pVtbl, \
            ((LPINTERFACEIMPL)(lpIFace))->lpBack = (LPVOID)pBack,   \
            ((LPINTERFACEIMPL)(lpIFace))->cRef = 0  \
        )

#if defined( _DEBUG )
#define OleDbgQueryInterfaceMethod(lpUnk)   \
        ((lpUnk) != NULL ? ((LPINTERFACEIMPL)(lpUnk))->cRef++ : 0)
#define OleDbgAddRefMethod(lpThis, iface)   \
        ((LPINTERFACEIMPL)(lpThis))->cRef++

#if _DEBUGLEVEL >= 2
#define OleDbgReleaseMethod(lpThis, iface) \
        (--((LPINTERFACEIMPL)(lpThis))->cRef == 0 ? \
            OleDbgOut("\t" iface "* RELEASED (cRef == 0)\r\n"),1 : \
             (((LPINTERFACEIMPL)(lpThis))->cRef < 0) ? \
                ( \
                    DebugBreak(), \
                    OleDbgOut(  \
                        "\tERROR: " iface "* RELEASED TOO MANY TIMES\r\n") \
                ),1 : \
                1)

#else       // if _DEBUGLEVEL < 2
#define OleDbgReleaseMethod(lpThis, iface) \
        (--((LPINTERFACEIMPL)(lpThis))->cRef == 0 ? \
            1 : \
             (((LPINTERFACEIMPL)(lpThis))->cRef < 0) ? \
                ( \
                    OleDbgOut(  \
                        "\tERROR: " iface "* RELEASED TOO MANY TIMES\r\n") \
        ),1 : \
                1)

#endif      // if _DEBUGLEVEL < 2

#else       // ! defined (_DEBUG)

#define OleDbgQueryInterfaceMethod(lpUnk)
#define OleDbgAddRefMethod(lpThis, iface)
#define OleDbgReleaseMethod(lpThis, iface)

#endif      // if defined( _DEBUG )

#endif      // ! defined(__cplusplus)

/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

/*
 * Some moniker stuff
 */

// Delimeter used to separate ItemMoniker pieces of a composite moniker
#if defined( _MAC )
#define OLESTDDELIM ":"
#else
#define OLESTDDELIM "\\"
#endif

/*
 * Some Concurrency stuff
 */

/* standard Delay (in msec) to wait before retrying an LRPC call.
**    this value is returned from IMessageFilter::RetryRejectedCall
*/
#define OLESTDRETRYDELAY    (DWORD)5000

/* Cancel the pending outgoing LRPC call.
**    this value is returned from IMessageFilter::RetryRejectedCall
*/
#define OLESTDCANCELRETRY   (DWORD)-1

/*
 * Some Icon support stuff.
 *
 * The following API's are now OBSOLETE because equivalent API's have been
 * added to the OLE2.DLL library
 *      GetIconOfFile       superceeded by OleGetIconOfFile
 *      GetIconOfClass      superceeded by OleGetIconOfClass
 *      OleUIMetafilePictFromIconAndLabel 
 *                          superceeded by OleMetafilePictFromIconAndLabel
 *
 * The following macros are defined for backward compatibility with previous
 * versions of the OLE2UI library. It is recommended that the new Ole* API's
 * should be used instead.
 */
#define GetIconOfFile(hInst, lpszFileName, fUseFileAsLabel) \
    OleGetIconOfFile(lpszFileName, fUseFileAsLabel)

#define GetIconOfClass(hInst, rclsid, lpszLabel, fUseTypeAsLabel) \
    OleGetIconOfClass(rclsid, lpszLabel, fUseTypeAsLabel)
        
#define OleUIMetafilePictFromIconAndLabel(hIcon,pszLabel,pszSourceFile,iIcon)\
    OleMetafilePictFromIconAndLabel(hIcon, pszLabel, pszSourceFile, iIcon)
        

/*
 * Some Clipboard Copy/Paste & Drag/Drop support stuff
 */

//Macro to set all FormatEtc fields
#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
     (fe).dwAspect=asp, \
     (fe).ptd=td, \
     (fe).tymed=med, \
     (fe).lindex=li)

//Macro to set interesting FormatEtc fields defaulting the others.
#define SETDEFAULTFORMATETC(fe, cf, med)  \
    ((fe).cfFormat=cf, \
     (fe).dwAspect=DVASPECT_CONTENT, \
     (fe).ptd=NULL, \
     (fe).tymed=med, \
     (fe).lindex=-1)

// Macro to test if two FormatEtc structures are an exact match
#define IsEqualFORMATETC(fe1, fe2)  \
    (OleStdCompareFormatEtc(&(fe1), &(fe2))==0)

// Clipboard format strings
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_CUSTOMLINKSOURCE "Custom Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_LINKSRCDESCRIPTOR "Link Source Descriptor"
#define CF_OWNERLINK        "OwnerLink"
#define CF_FILENAME         "FileName"

#define OleStdQueryOleObjectData(lpformatetc)   \
    (((lpformatetc)->tymed & TYMED_ISTORAGE) ?    \
            NOERROR : ResultFromScode(DV_E_FORMATETC))

#define OleStdQueryLinkSourceData(lpformatetc)   \
    (((lpformatetc)->tymed & TYMED_ISTREAM) ?    \
            NOERROR : ResultFromScode(DV_E_FORMATETC))

#define OleStdQueryObjectDescriptorData(lpformatetc)    \
    (((lpformatetc)->tymed & TYMED_HGLOBAL) ?    \
            NOERROR : ResultFromScode(DV_E_FORMATETC))
                
#define OleStdQueryFormatMedium(lpformatetc, tymd)  \
    (((lpformatetc)->tymed & tymd) ?    \
            NOERROR : ResultFromScode(DV_E_FORMATETC))

// Make an independent copy of a MetafilePict
#define OleStdCopyMetafilePict(hpictin, phpictout)  \
    (*(phpictout) = OleDuplicateData(hpictin,CF_METAFILEPICT,GHND|GMEM_SHARE))


// REVIEW: these need to be added to OLE2.H
#if !defined( DD_DEFSCROLLINTERVAL )
#define DD_DEFSCROLLINTERVAL    50
#endif

#if !defined( DD_DEFDRAGDELAY )
#define DD_DEFDRAGDELAY         200
#endif

#if !defined( DD_DEFDRAGMINDIST )
#define DD_DEFDRAGMINDIST       2
#endif


/* OleStdGetDropEffect
** -------------------
**
** Convert a keyboard state into a DROPEFFECT.
**
** returns the DROPEFFECT value derived from the key state.
**    the following is the standard interpretation:
**          no modifier -- Default Drop     (NULL is returned)
**          CTRL        -- DROPEFFECT_COPY
**          SHIFT       -- DROPEFFECT_MOVE
**          CTRL-SHIFT  -- DROPEFFECT_LINK
**
**    Default Drop: this depends on the type of the target application.
**    this is re-interpretable by each target application. a typical
**    interpretation is if the drag is local to the same document
**    (which is source of the drag) then a MOVE operation is
**    performed. if the drag is not local, then a COPY operation is
**    performed.
*/
#define OleStdGetDropEffect(grfKeyState)    \
    ( (grfKeyState & MK_CONTROL) ?          \
        ( (grfKeyState & MK_SHIFT) ? DROPEFFECT_LINK : DROPEFFECT_COPY ) :  \
        ( (grfKeyState & MK_SHIFT) ? DROPEFFECT_MOVE : 0 ) )

                
/* The OLEUIPASTEFLAG enumeration is used by the OLEUIPASTEENTRY structure.
 *
 * OLEUIPASTE_ENABLEICON    If the container does not specify this flag for the entry in the
 *   OLEUIPASTEENTRY array passed as input to OleUIPasteSpecial, the DisplayAsIcon button will be
 *   unchecked and disabled when the the user selects the format that corresponds to the entry.
 *
 * OLEUIPASTE_PASTEONLY     Indicates that the entry in the OLEUIPASTEENTRY array is valid for pasting only.
 * OLEUIPASTE_PASTE         Indicates that the entry in the OLEUIPASTEENTRY array is valid for pasting. It
 *   may also be valid for linking if any of the following linking flags are specified.
 *
 * If the entry in the OLEUIPASTEENTRY array is valid for linking, the following flags indicate which link
 * types are acceptable by OR'ing together the appropriate OLEUIPASTE_LINKTYPE<#> values.
 * These values correspond as follows to the array of link types passed to OleUIPasteSpecial:
 *   OLEUIPASTE_LINKTYPE1=arrLinkTypes[0]
 *   OLEUIPASTE_LINKTYPE2=arrLinkTypes[1]
 *   OLEUIPASTE_LINKTYPE3=arrLinkTypes[2]
 *   OLEUIPASTE_LINKTYPE4=arrLinkTypes[3]
 *   OLEUIPASTE_LINKTYPE5=arrLinkTypes[4]
 *   OLEUIPASTE_LINKTYPE6=arrLinkTypes[5]
 *   OLEUIPASTE_LINKTYPE7=arrLinkTypes[6]
 *  OLEUIPASTE_LINKTYPE8=arrLinkTypes[7]
 *
 * where,
 *   UINT arrLinkTypes[8] is an array of registered clipboard formats for linking. A maximium of 8 link
 *   types are allowed.
 */

typedef enum tagOLEUIPASTEFLAG
{
   OLEUIPASTE_ENABLEICON    = 2048,     // enable display as icon
   OLEUIPASTE_PASTEONLY     = 0,
   OLEUIPASTE_PASTE         = 512,
   OLEUIPASTE_LINKANYTYPE   = 1024,
   OLEUIPASTE_LINKTYPE1     = 1,
   OLEUIPASTE_LINKTYPE2     = 2,
   OLEUIPASTE_LINKTYPE3     = 4,
   OLEUIPASTE_LINKTYPE4     = 8,
   OLEUIPASTE_LINKTYPE5     = 16,
   OLEUIPASTE_LINKTYPE6     = 32,
   OLEUIPASTE_LINKTYPE7     = 64,
   OLEUIPASTE_LINKTYPE8     = 128
} OLEUIPASTEFLAG;

/*
 * PasteEntry structure
 * --------------------
 * An array of OLEUIPASTEENTRY entries is specified for the PasteSpecial dialog
 * box. Each entry includes a FORMATETC which specifies the formats that are
 * acceptable, a string that is to represent the format in the  dialog's list
 * box, a string to customize the result text of the dialog and a set of flags
 * from the OLEUIPASTEFLAG enumeration.  The flags indicate if the entry is
 * valid for pasting only, linking only or both pasting and linking. If the
 * entry is valid for linking, the flags indicate which link types are
 * acceptable by OR'ing together the appropriate OLEUIPASTE_LINKTYPE<#> values.
 * These values correspond to the array of link types as follows:
 *   OLEUIPASTE_LINKTYPE1=arrLinkTypes[0]
 *   OLEUIPASTE_LINKTYPE2=arrLinkTypes[1]
 *   OLEUIPASTE_LINKTYPE3=arrLinkTypes[2]
 *   OLEUIPASTE_LINKTYPE4=arrLinkTypes[3]
 *   OLEUIPASTE_LINKTYPE5=arrLinkTypes[4]
 *   OLEUIPASTE_LINKTYPE6=arrLinkTypes[5]
 *   OLEUIPASTE_LINKTYPE7=arrLinkTypes[6]
 *   OLEUIPASTE_LINKTYPE8=arrLinkTypes[7]
 *   UINT arrLinkTypes[8]; is an array of registered clipboard formats
 *                        for linking. A maximium of 8 link types are allowed.
 */

typedef struct tagOLEUIPASTEENTRY
{
   FORMATETC        fmtetc;            // Format that is acceptable. The paste
                                       //   dialog checks if this format is
                                       //   offered by the object on the
                                       //   clipboard and if so offers it for
                                       //   selection to the user.
   LPCSTR           lpstrFormatName;   // String that represents the format to the user. Any %s
                                       //   in this string is replaced by the FullUserTypeName
                                       //   of the object on the clipboard and the resulting string
                                       //   is placed in the list box of the dialog. Atmost
                                       //   one %s is allowed. The presence or absence of %s indicates
                                       //   if the result text is to indicate that data is
                                       //   being pasted or that an object that can be activated by
                                       //   an application is being pasted. If %s is
                                       //   present, the result-text says that an object is being pasted.
                                       //   Otherwise it says that data is being pasted.
   LPCSTR           lpstrResultText;   // String to customize the result text of the dialog when
                                       //  the user selects the format correspoding to this
                                       //  entry. Any %s in this string is replaced by the the application
                                       //  name or FullUserTypeName of the object on
                                       //  the clipboard. Atmost one %s is allowed.
   DWORD            dwFlags;           // Values from OLEUIPASTEFLAG enum
   DWORD            dwScratchSpace;    // Scratch space available to be used
                                       //   by routines which loop through an
                                       //   IEnumFORMATETC* to mark if the
                                       //   PasteEntry format is available.
                                       //   this field CAN be left uninitialized.
} OLEUIPASTEENTRY, *POLEUIPASTEENTRY, FAR *LPOLEUIPASTEENTRY;

#define OLESTDDROP_NONE         0
#define OLESTDDROP_DEFAULT      1
#define OLESTDDROP_NONDEFAULT   2


/*
 * Some misc stuff
 */

#define EMBEDDINGFLAG "Embedding"     // Cmd line switch for launching a srvr

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH        72        // number points (font size) per inch

#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

// Returns TRUE if all fields of the two Rect's are equal, else FALSE. 
#define AreRectsEqual(lprc1, lprc2)     \
    (((lprc1->top == lprc2->top) &&     \
      (lprc1->left == lprc2->left) &&   \
      (lprc1->right == lprc2->right) && \
      (lprc1->bottom == lprc2->bottom)) ? TRUE : FALSE)

#define LSTRCPYN(lpdst, lpsrc, cch) \
(\
    (lpdst)[(cch)-1] = '\0', \
    (cch>1 ? lstrcpyn(lpdst, lpsrc, (cch)-1) : 0)\
)


/****** DEBUG Stuff *****************************************************/

#ifdef _DEBUG

#if !defined( _DBGTRACE )
#define _DEBUGLEVEL 2
#else
#define _DEBUGLEVEL _DBGTRACE
#endif


#if defined( NOASSERT )

#define OLEDBGASSERTDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)
#define OleDbgVerifySz(a, b)

#else   // ! NOASSERT

#define OLEDBGASSERTDATA    \
        static char _based(_segname("_CODE")) _szAssertFile[]= __FILE__;

#define OleDbgAssert(a) \
        (!(a) ? FnAssert(#a, NULL, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgAssertSz(a, b)    \
        (!(a) ? FnAssert(#a, b, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgVerify(a) \
        OleDbgAssert(a)

#define OleDbgVerifySz(a, b)    \
        OleDbgAssertSz(a, b)

#endif  // ! NOASSERT


#define OLEDBGDATA_MAIN(szPrefix)   \
        char near g_szDbgPrefix[] = szPrefix;    \
        OLEDBGASSERTDATA
#define OLEDBGDATA  \
        extern char near g_szDbgPrefix[];    \
        OLEDBGASSERTDATA

#define OLEDBG_BEGIN(lpsz) \
        OleDbgPrintAlways(g_szDbgPrefix,lpsz,1);

#define OLEDBG_END  \
        OleDbgPrintAlways(g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOut(lpsz) \
        OleDbgPrintAlways(g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix(lpsz) \
        OleDbgPrintAlways("",lpsz,0)

#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)      \
        OleDbgPrintRefCntAlways(g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect(lpsz,lpRect)      \
        OleDbgPrintRectAlways(g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOutHResult(lpsz,hr)   \
        OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,GetScode(hr))

#define OleDbgOutScode(lpsz,sc) \
        OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,sc)

#define OleDbgOut1(lpsz)    \
        OleDbgPrint(1,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix1(lpsz)    \
        OleDbgPrint(1,"",lpsz,0)

#define OLEDBG_BEGIN1(lpsz)    \
        OleDbgPrint(1,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END1 \
        OleDbgPrint(1,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)     \
        OleDbgPrintRefCnt(1,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect1(lpsz,lpRect)     \
        OleDbgPrintRect(1,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut2(lpsz)    \
        OleDbgPrint(2,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix2(lpsz)    \
        OleDbgPrint(2,"",lpsz,0)

#define OLEDBG_BEGIN2(lpsz)    \
        OleDbgPrint(2,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END2 \
        OleDbgPrint(2,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)     \
        OleDbgPrintRefCnt(2,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect2(lpsz,lpRect)     \
        OleDbgPrintRect(2,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut3(lpsz)    \
        OleDbgPrint(3,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix3(lpsz)    \
        OleDbgPrint(3,"",lpsz,0)

#define OLEDBG_BEGIN3(lpsz)    \
        OleDbgPrint(3,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END3 \
        OleDbgPrint(3,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)     \
        OleDbgPrintRefCnt(3,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect3(lpsz,lpRect)     \
        OleDbgPrintRect(3,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut4(lpsz)    \
        OleDbgPrint(4,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix4(lpsz)    \
        OleDbgPrint(4,"",lpsz,0)

#define OLEDBG_BEGIN4(lpsz)    \
        OleDbgPrint(4,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END4 \
        OleDbgPrint(4,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)     \
        OleDbgPrintRefCnt(4,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect4(lpsz,lpRect)     \
        OleDbgPrintRect(4,g_szDbgPrefix,lpsz,lpRect)

#else   //  !_DEBUG

#define OLEDBGDATA_MAIN(szPrefix)
#define OLEDBGDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)         (a)
#define OleDbgVerifySz(a, b)    (a)
#define OleDbgOutHResult(lpsz,hr)
#define OleDbgOutScode(lpsz,sc)
#define OLEDBG_BEGIN(lpsz) 
#define OLEDBG_END
#define OleDbgOut(lpsz)
#define OleDbgOut1(lpsz)
#define OleDbgOut2(lpsz)
#define OleDbgOut3(lpsz)
#define OleDbgOut4(lpsz)
#define OleDbgOutNoPrefix(lpsz)
#define OleDbgOutNoPrefix1(lpsz)
#define OleDbgOutNoPrefix2(lpsz)
#define OleDbgOutNoPrefix3(lpsz)
#define OleDbgOutNoPrefix4(lpsz)
#define OLEDBG_BEGIN1(lpsz)
#define OLEDBG_BEGIN2(lpsz)
#define OLEDBG_BEGIN3(lpsz)
#define OLEDBG_BEGIN4(lpsz)
#define OLEDBG_END1
#define OLEDBG_END2
#define OLEDBG_END3
#define OLEDBG_END4
#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)
#define OleDbgOutRect(lpsz,lpRect)
#define OleDbgOutRect1(lpsz,lpRect)
#define OleDbgOutRect2(lpsz,lpRect)
#define OleDbgOutRect3(lpsz,lpRect)
#define OleDbgOutRect4(lpsz,lpRect)

#endif  //  _DEBUG


/*************************************************************************
** Function prototypes
*************************************************************************/


//OLESTD.C
STDAPI_(int) SetDCToAnisotropic(HDC hDC, LPRECT lprcPhysical, LPRECT lprcLogical, LPRECT lprcWindowOld, LPRECT lprcViewportOld);
STDAPI_(int) SetDCToDrawInHimetricRect(HDC, LPRECT, LPRECT, LPRECT, LPRECT);
STDAPI_(int) ResetOrigDC(HDC, int, LPRECT, LPRECT);

STDAPI_(int)        XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int)        XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int)        XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int)        XformHeightInPixelsToHimetric(HDC, int);

STDAPI_(void) XformRectInPixelsToHimetric(HDC, LPRECT, LPRECT);
STDAPI_(void) XformRectInHimetricToPixels(HDC, LPRECT, LPRECT);
STDAPI_(void) XformSizeInPixelsToHimetric(HDC, LPSIZEL, LPSIZEL);
STDAPI_(void) XformSizeInHimetricToPixels(HDC, LPSIZEL, LPSIZEL);
STDAPI_(int) XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int) XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int) XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int) XformHeightInPixelsToHimetric(HDC, int);

STDAPI_(void) ParseCmdLine(LPSTR, BOOL FAR *, LPSTR);

STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk);
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid);
STDAPI_(LPSTORAGE) OleStdCreateRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdOpenRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdOpenOrCreateRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdCreateChildStorage(LPSTORAGE lpStg, LPSTR lpszStgName);
STDAPI_(LPSTORAGE) OleStdOpenChildStorage(LPSTORAGE lpStg, LPSTR lpszStgName, DWORD grfMode);
STDAPI_(BOOL) OleStdCommitStorage(LPSTORAGE lpStg);
STDAPI OleStdDestroyAllElements(LPSTORAGE lpStg);

STDAPI_(LPSTORAGE) OleStdCreateStorageOnHGlobal(
        HANDLE hGlobal,
        BOOL fDeleteOnRelease,
        DWORD dwgrfMode
);
STDAPI_(LPSTORAGE) OleStdCreateTempStorage(BOOL fUseMemory, DWORD grfMode);
STDAPI OleStdDoConvert(LPSTORAGE lpStg, REFCLSID rClsidNew);
STDAPI_(BOOL) OleStdGetTreatAsFmtUserType(
        REFCLSID        rClsidApp,
        LPSTORAGE       lpStg,
        CLSID FAR*      lpclsid,
        CLIPFORMAT FAR* lpcfFmt,
        LPSTR FAR*      lplpszType
);
STDAPI OleStdDoTreatAsClass(LPSTR lpszUserType, REFCLSID rclsid, REFCLSID rclsidNew);
STDAPI_(BOOL) OleStdSetupAdvises(LPOLEOBJECT lpOleObject, DWORD dwDrawAspect,
                    LPSTR lpszContainerApp, LPSTR lpszContainerObj,
                    LPADVISESINK lpAdviseSink, BOOL fCreate);
STDAPI OleStdSwitchDisplayAspect(
        LPOLEOBJECT             lpOleObj,
        LPDWORD                 lpdwCurAspect,
        DWORD                   dwNewAspect,
        HGLOBAL                 hMetaPict,
        BOOL                    fDeleteOldAspect,
        BOOL                    fSetupViewAdvise,
        LPADVISESINK            lpAdviseSink,
        BOOL FAR*               lpfMustUpdate
);
STDAPI OleStdSetIconInCache(LPOLEOBJECT lpOleObj, HGLOBAL hMetaPict);
STDAPI_(HGLOBAL) OleStdGetData(
        LPDATAOBJECT        lpDataObj,
        CLIPFORMAT          cfFormat,
        DVTARGETDEVICE FAR* lpTargetDevice,
        DWORD               dwAspect,
        LPSTGMEDIUM         lpMedium
);
STDAPI_(void) OleStdMarkPasteEntryList(
        LPDATAOBJECT        lpSrcDataObj,
        LPOLEUIPASTEENTRY   lpPriorityList,
        int                 cEntries
);
STDAPI_(int) OleStdGetPriorityClipboardFormat(
        LPDATAOBJECT        lpSrcDataObj,
        LPOLEUIPASTEENTRY   lpPriorityList,
        int                 cEntries
);
STDAPI_(BOOL) OleStdIsDuplicateFormat(
        LPFORMATETC         lpFmtEtc,
        LPFORMATETC         arrFmtEtc,
        int                 nFmtEtc
);
STDAPI_(void) OleStdRegisterAsRunning(LPUNKNOWN lpUnk, LPMONIKER lpmkFull, DWORD FAR* lpdwRegister);
STDAPI_(void) OleStdRevokeAsRunning(DWORD FAR* lpdwRegister);
STDAPI_(void) OleStdNoteFileChangeTime(LPSTR lpszFileName, DWORD dwRegister);
STDAPI_(void) OleStdNoteObjectChangeTime(DWORD dwRegister);
STDAPI OleStdGetOleObjectData(
        LPPERSISTSTORAGE    lpPStg,
        LPFORMATETC         lpformatetc,
        LPSTGMEDIUM         lpMedium,
        BOOL                fUseMemory
);
STDAPI OleStdGetLinkSourceData(
        LPMONIKER           lpmk,
        LPCLSID             lpClsID,
        LPFORMATETC         lpformatetc,
        LPSTGMEDIUM         lpMedium
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
        CLSID               clsid,
        DWORD               dwAspect,
        SIZEL               sizel,
        POINTL              pointl,
        DWORD               dwStatus,
        LPSTR               lpszFullUserTypeName,
        LPSTR               lpszSrcOfCopy
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorDataFromOleObject(
        LPOLEOBJECT         lpOleObj,
        LPSTR               lpszSrcOfCopy,
        DWORD               dwAspect,
        POINTL              pointl,
        LPSIZEL             lpSizelHim
);
STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
        LPDATAOBJECT       lpDataObject,
        LPSTGMEDIUM        lpmedium,
        CLIPFORMAT FAR*    lpcfFmt
);
STDAPI_(HANDLE) OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd
);

STDAPI_(void) OleStdCreateTempFileMoniker(LPSTR lpszPrefixString, UINT FAR* lpuUnique, LPSTR lpszName, LPMONIKER FAR* lplpmk);
STDAPI_(LPMONIKER) OleStdGetFirstMoniker(LPMONIKER lpmk);
STDAPI_(ULONG) OleStdGetLenFilePrefixOfMoniker(LPMONIKER lpmk);
STDAPI OleStdMkParseDisplayName(
        REFCLSID        rClsid, 
        LPBC            lpbc, 
        LPSTR           lpszUserName, 
        ULONG FAR*      lpchEaten, 
        LPMONIKER FAR*  lplpmk
);
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem);
STDAPI_(void) OleStdFreeString(LPSTR lpsz, LPMALLOC lpMalloc);
STDAPI_(LPSTR) OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
STDAPI_(ULONG) OleStdGetItemToken(LPSTR lpszSrc, LPSTR lpszDst,int nMaxChars);

STDAPI_(UINT)     OleStdIconLabelTextOut(HDC        hDC, 
                                         HFONT      hFont,
                                         int        nXStart, 
                                         int        nYStart, 
                                         UINT       fuOptions, 
                                         RECT FAR * lpRect, 
                                         LPSTR      lpszString, 
                                         UINT       cchString, 
                                         int FAR *  lpDX);

// registration database query functions
STDAPI_(UINT)     OleStdGetAuxUserType(REFCLSID rclsid,
                                      WORD   wAuxUserType, 
                                      LPSTR  lpszAuxUserType, 
                                      int    cch,
                                      HKEY   hKey);

STDAPI_(UINT)     OleStdGetUserTypeOfClass(REFCLSID rclsid, 
                                           LPSTR lpszUserType, 
                                           UINT cch, 
                                           HKEY hKey);

STDAPI_(BOOL) OleStdGetMiscStatusOfClass(REFCLSID, HKEY, DWORD FAR *);
STDAPI_(CLIPFORMAT) OleStdGetDefaultFileFormatOfClass(
        REFCLSID        rclsid, 
        HKEY            hKey
);

STDAPI_(void) OleStdInitVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl);
STDMETHODIMP OleStdNullMethod(LPUNKNOWN lpThis);
STDAPI_(BOOL) OleStdCheckVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl, LPSTR lpszIface);
STDAPI_(ULONG) OleStdVerifyRelease(LPUNKNOWN lpUnk, LPSTR lpszMsg);
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk);

STDAPI_(HDC) OleStdCreateDC(DVTARGETDEVICE FAR* ptd);
STDAPI_(HDC) OleStdCreateIC(DVTARGETDEVICE FAR* ptd);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCreateTargetDevice(LPPRINTDLG lpPrintDlg);
STDAPI_(BOOL) OleStdDeleteTargetDevice(DVTARGETDEVICE FAR* ptd);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);
STDAPI_(int) OleStdCompareFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight);
STDAPI_(BOOL) OleStdCompareTargetDevice
    (DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight);


STDAPI_(void) OleDbgPrint(
        int     nDbgLvl,
        LPSTR   lpszPrefix,
        LPSTR   lpszMsg,
        int     nIndent
);
STDAPI_(void) OleDbgPrintAlways(LPSTR lpszPrefix, LPSTR lpszMsg, int nIndent);
STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl);
STDAPI_(int) OleDbgGetDbgLevel( void );
STDAPI_(void) OleDbgIndent(int n);
STDAPI_(void) OleDbgPrintRefCnt(
        int         nDbgLvl,
        LPSTR       lpszPrefix,
        LPSTR       lpszMsg,
        LPVOID      lpObj,
        ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRefCntAlways(
        LPSTR       lpszPrefix,
        LPSTR       lpszMsg,
        LPVOID      lpObj,
        ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRect(
        int         nDbgLvl,
        LPSTR       lpszPrefix,
        LPSTR       lpszMsg,
        LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintRectAlways(
        LPSTR       lpszPrefix,
        LPSTR       lpszMsg,
        LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintScodeAlways(LPSTR lpszPrefix, LPSTR lpszMsg, SCODE sc);

// debug implementation of the IMalloc interface.
STDAPI OleStdCreateDbAlloc(ULONG reserved, IMalloc FAR* FAR* ppmalloc);


STDAPI_(LPENUMFORMATETC)        
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc);
  
STDAPI_(LPENUMSTATDATA)        
  OleStdEnumStatData_Create(ULONG nCount, LPSTATDATA lpStat);

STDAPI_(BOOL)
  OleStdCopyStatData(LPSTATDATA pDest, LPSTATDATA pSrc);

STDAPI_(HPALETTE)
  OleStdCreateStandardPalette(void);

#if defined( OBSOLETE )

/*************************************************************************
** The following API's have been converted into macros:
**          OleStdQueryOleObjectData
**          OleStdQueryLinkSourceData
**          OleStdQueryObjectDescriptorData
**          OleStdQueryFormatMedium
**          OleStdCopyMetafilePict
**          AreRectsEqual
**          OleStdGetDropEffect
**    
**    These macros are defined above
*************************************************************************/
STDAPI_(BOOL) AreRectsEqual(LPRECT lprc1, LPRECT lprc2);
STDAPI_(BOOL) OleStdCopyMetafilePict(HANDLE hpictin, HANDLE FAR* phpictout);
STDAPI OleStdQueryOleObjectData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryLinkSourceData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryObjectDescriptorData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryFormatMedium(LPFORMATETC lpformatetc, TYMED tymed);
STDAPI_(DWORD) OleStdGetDropEffect ( DWORD grfKeyState );
#endif  // OBSOLETE


#endif // _OLESTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\privguid.h ===
/* this file is the master definition of all OLE2 product GUIDs (public and 
   private).  All GUIDs used by the ole2 product are of the form:

	   xxxxxxxx-xxxx-xxxY-C000-000000000046

   This range is broken down as follows:

	   000000xx-0000-0000-C000-000000000046 compobj IIDs (coguid.h)
	   000001xx-0000-0000-C000-000000000046 ole2 IIDs (oleguid.h)
	   000002xx-0000-0000-C000-000000000046 smoke test (testguid.h)
	   000003xx-0000-0000-C000-000000000046 ole2 CLSIDs (privguid.h; this file)
	   000004xx-0000-0000-C000-000000000046 ole2 sample apps (see DouglasH)

   Other interesting ranges are as follows:

	   0003xxxx-0000-0000-C000-000000000046 ole1 CLSIDs (ole1cls.h)
	   0004xxxx-0000-0000-C000-000000000046 hashed ole1 CLSIDs

*/
   

DEFINE_OLEGUID(CLSID_StdOleLink,		0x00000300, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemStm,			0x00000301, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemBytes,		0x00000302, 0, 0);
DEFINE_OLEGUID(CLSID_FileMoniker,		0x00000303, 0, 0);
DEFINE_OLEGUID(CLSID_ItemMoniker,		0x00000304, 0, 0);
DEFINE_OLEGUID(CLSID_AntiMoniker,		0x00000305, 0, 0);
DEFINE_OLEGUID(CLSID_PointerMoniker,	0x00000306, 0, 0);
// NOT TO BE USED						0x00000307, 0, 0);
DEFINE_OLEGUID(CLSID_PackagerMoniker,	0x00000308, 0, 0);
DEFINE_OLEGUID(CLSID_CompositeMoniker,	0x00000309, 0, 0);
// NOT TO BE USED						0x0000030a, 0, 0);
DEFINE_OLEGUID(CLSID_DfMarshal,			0x0000030b, 0, 0);

// clsids for proxy/stub objects
DEFINE_OLEGUID(CLSID_PSGenObject,		0x0000030c, 0, 0);
DEFINE_OLEGUID(CLSID_PSClientSite,		0x0000030d, 0, 0);
DEFINE_OLEGUID(CLSID_PSClassObject,		0x0000030e, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceActive,	0x0000030f, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceFrame,	0x00000310, 0, 0);
DEFINE_OLEGUID(CLSID_PSDragDrop,		0x00000311, 0, 0);
DEFINE_OLEGUID(CLSID_PSBindCtx,			0x00000312, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumerators,		0x00000313, 0, 0);
DEFINE_OLEGUID(CLSID_PSStore,			0x00000314, 0, 0);

/* These 2 are defined in "oleguid.h"
DEFINE_OLEGUID(CLSID_StaticMetafile,	0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,			0x00000316, 0, 0);
*/

/* NOTE: LSB values 0x17 through 0xff are reserved */

// copies from ole1cls.h; reduces the size of ole2.dll
DEFINE_OLEGUID(CLSID_MSDraw,            0x00030007, 0, 0);
DEFINE_OLEGUID(CLSID_Package,           0x0003000c, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelWorksheet,   	0x00030000, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelChart,       	0x00030001, 0, 0);
DEFINE_OLEGUID(CLSID_ExcelMacrosheet,  	0x00030002, 0, 0);
DEFINE_OLEGUID(CLSID_PBrush,  			0x0003000a, 0, 0);
DEFINE_OLEGUID(CLSID_WordDocument,      0x00030003, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\reterr.h ===
/* Jason's error handling macros */

#ifndef fRetErr_h
#define fRetErr_h

#ifdef _DEBUG
FARINTERNAL_(void) wWarn (LPSTR sz, LPSTR szFile, int iLine);
#define Warn(sz) wWarn(sz,_szAssertFile,__LINE__)
#else
#define Warn(sz)
#endif // _DEBUG

// Call x.  If hresult is not NOERROR, goto errRtn.
#define ErrRtn(x) do {if (NOERROR != (x)) {Warn(NULL); goto errRtn;}} while (0)

// Call x.  If hresult is not NOERROR, store it in hresult and goto errRtn.
#define ErrRtnH(x) do {if (NOERROR != (hresult=(x))) {Warn(NULL); goto errRtn;}} while (0)

// If x, goto errRtn.
#define ErrNz(x) do {if (x) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn.
#define ErrZ(x) do {if (!(x)) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn with a specific scode
#define ErrZS(x, scode) do {if (!(x)) {Warn(NULL); hresult=ResultFromScode(scode); goto errRtn;}} while (0)


// Call x.  If hresult is not NOERROR, return that hresult.
#define RetErr(x) do {HRESULT hresult; if (NOERROR != (hresult=(x))) {Warn(NULL); return hresult;}} while (0)

// Return unexpected error if x is non-zero
#define RetNz(x)  do {if (x) {AssertSz(0,#x); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is non-zero
#define RetNzS(x, scode)  do {if (x) {Warn(NULL); return ResultFromScode (scode);}} while (0)

// Return unexpected error if x is zero
#define RetZ(x)   do {if (!(x)) {AssertSz(0,#x); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is zero
#define RetZS(x, scode) do {if (!(x)) {Warn(NULL); return ResultFromScode (scode);}} while (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINDLL
#define _FARARG_ __far
#else
#define _FARARG_
#endif

#if (_MSC_VER <= 600)
#define __far       _far
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif

#define _INC_STDARG
#endif	/* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\scode.h ===
/*****************************************************************************\
*                                                                             *
* scode.h - 	Defines standard status code services.						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\taskmap.h ===
// taskmap.h - definitions for managing the etask (per task data).

// NOTE: this is private to compobj.dll for now; it can be made public if necc.

STDAPI_(BOOL) LookupEtask(HTASK FAR& hTask, Etask FAR& etask);
STDAPI_(BOOL) SetEtask(HTASK hTask, Etask FAR& etask);

extern IMalloc FAR* v_pMallocShared;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#define _NFILE	20
#define EOF	(-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *	+ 1 (in case _P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER	0

/* max number of windows */
#define _WFILE		20

/* values for windows screen buffer size */
#define _WINBUFINF	0
#define _WINBUFDEF	-1

/* size/move settings */
#define _WINSIZEMIN	1
#define _WINSIZEMAX	2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR	4

/* size/move query types */
#define _WINMAXREQ	100
#define _WINCURRREQ	101

/* values for closing window */
#define _WINPERSIST	1
#define _WINNOPERSIST	0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND	-1

/* menu items */
#define _WINSTATBAR	1
#define _WINTILE	2
#define _WINCASCADE	3
#define _WINARRANGE	4

/* quickwin exit options */
#define _WINEXITPROMPT		1
#define _WINEXITNOPERSIST	2
#define _WINEXITPERSIST 	3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
	unsigned int _version;
	const char __far * _title;
	long _wbufsize;
	};
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
	unsigned int _version;
	unsigned int _type;
	unsigned int _x;
	unsigned int _y;
	unsigned int _h;
	unsigned int _w;
	};
#define _WINFO_DEFINED
#endif
#endif
#endif

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
	const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
	const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
	const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif
#endif
size_t __cdecl fwrite(const void *, size_t, size_t,
	FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif
int __cdecl printf(const char *, ...);
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
int __cdecl vprintf(const char *, va_list);
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)
#endif


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux	  _stdaux
#define stdprn	  _stdprn
#endif

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_STDIO
#endif	/* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};

typedef IEnumSTATSTG FAR* LPENUMSTATSTG;



/****** ILockBytes Interface ************************************************/

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef ILockBytes FAR* LPLOCKBYTES;



/****** IStream Interface ***************************************************/


#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};

typedef IStream FAR* LPSTREAM;



/****** IStorage Interface **************************************************/

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef IStorage FAR* LPSTORAGE;



/****** IRootStorage Interface **********************************************/

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};

typedef IRootStorage FAR* LPROOTSTORAGE;



/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
		  FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef	unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
	int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
	size_t);
int __cdecl _memicmp(const void *, const void *,
	unsigned int);
void * __cdecl memcpy(void *, const void *,
	size_t);
void * __cdecl memmove(void *, const void *,
	size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
	size_t);
int __cdecl strncmp(const char *, const char *,
	size_t);
int __cdecl _strnicmp(const char *, const char *,
	size_t);
char * __cdecl strncpy(char *, const char *,
	size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
	const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
	const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
	size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
	int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
	size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
	unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
	size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
	size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
	size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
	size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
	size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
	const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
	const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
	int, unsigned int);
int __cdecl memicmp(const void *, const void *,
	unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
	size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif

#ifdef __cplusplus
}
#endif

#define _INC_STRING
#endif	/* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*	Copyright (c) 1991-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Definitions for generic international functions, mostly defines
*	which map string/formatted-io/ctype functions to char, wchar_t, or
*	MBCS versions.  To be used for compatibility between single-byte,
*	multi-byte and Unicode text models.
*	
*
*
****/

#ifndef _INC_TCHAR

#ifdef	_MSC_VER
#pragma warning(disable:4505)		/* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4505) */	/* use this to reenable, if necessary */
#endif	/* _MSC_VER */

#ifdef	__cplusplus
extern "C" {
#endif


/* No Model-independent functions under Win32 */

#define __far


/* Default for Win32 is no inlining. Define _USE_INLINING to overide */

#ifndef _USE_INLINING
#define _NO_INLINING
#endif


/* No model-independent string functions for Win32 */

#define _ftcscat	_tcscat
#define _ftcschr	_tcschr
#define _ftcscmp	_tcscmp
#define _ftcscpy	_tcscpy
#define _ftcscspn	_tcscspn
#define _ftcslen	_tcslen
#define _ftcsncat	_tcsncat
#define _ftcsncmp	_tcsncmp
#define _ftcsncpy	_tcsncpy
#define _ftcspbrk	_tcspbrk
#define _ftcsrchr	_tcsrchr
#define _ftcsspn	_tcsspn
#define _ftcsstr	_tcsstr
#define _ftcstok	_tcstok

#define _ftcsdup	_tcsdup
#define _ftcsicmp	_tcsicmp
#define _ftcsnicmp	_tcsnicmp
#define _ftcsnset	_tcsnset
#define _ftcsrev	_tcsrev
#define _ftcsset	_tcsset


/* Redundant "logical-character" mappings */

#define _ftcsclen	_tcsclen
#define _ftcsnccat	_tcsnccat
#define _ftcsnccpy	_tcsnccpy
#define _ftcsnccmp	_tcsnccmp
#define _ftcsncicmp	_tcsncicmp
#define _ftcsncset	_tcsncset

#define	_ftcsdec	_tcsdec
#define	_ftcsinc	_tcsinc
#define	_ftcsnbcnt	_tcsncnt
#define	_ftcsnccnt	_tcsncnt
#define	_ftcsnextc	_tcsnextc
#define	_ftcsninc	_tcsninc
#define	_ftcsspnp	_tcsspnp

#define _ftcslwr	_tcslwr
#define _ftcsupr	_tcsupr

#define _ftclen		_tclen
#define	_ftccpy		_tccpy
#define _ftccmp		_tccmp


#ifdef	_UNICODE


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t		_TCHAR;
typedef wint_t		_TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef wchar_t		TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF		WEOF

#define __T(x)		L ## x


/* Formatted i/o */
  
#define _tprintf	wprintf
#define _ftprintf	fwprintf
#define _stprintf	swprintf
#define _sntprintf	_snwprintf
#define _vtprintf	vwprintf
#define _vftprintf	vfwprintf
#define _vstprintf	vswprintf
#define _vsntprintf	_vsnwprintf
#define _tscanf		wscanf
#define _ftscanf	fwscanf
#define _stscanf	swscanf


/* Unformatted i/o */

#define _fgettc		fgetwc
#define _fgettchar	_fgetwchar
#define _fgetts		fgetws
#define _fputtc		fputwc
#define _fputtchar	_fputwchar
#define _fputts		fputws
#define _gettc		getwc
#define _gettchar	getwchar
#define _puttc		putwc
#define _puttchar	putwchar
#define _ungettc	ungetwc


/* String conversion functions */

#define _tcstod		wcstod
#define _tcstol		wcstol
#define _tcstoul	wcstoul


/* String functions */

#define _tcscat		wcscat
#define _tcschr		wcschr
#define _tcscmp		wcscmp
#define _tcscpy		wcscpy
#define _tcscspn	wcscspn
#define _tcslen		wcslen
#define _tcsncat	wcsncat
#define _tcsncmp	wcsncmp
#define _tcsncpy	wcsncpy
#define _tcspbrk	wcspbrk
#define _tcsrchr	wcsrchr
#define _tcsspn		wcsspn
#define _tcsstr		wcsstr
#define _tcstok		wcstok

#define _tcsdup		_wcsdup
#define _tcsicmp	_wcsicmp
#define _tcsnicmp	_wcsnicmp
#define _tcsnset	_wcsnset
#define _tcsrev		_wcsrev
#define _tcsset		_wcsset


/* Redundant "logical-character" mappings */

#define _tcsclen	wcslen
#define _tcsnccat	wcsncat
#define _tcsnccpy	wcsncpy
#define _tcsnccmp	wcsncmp
#define _tcsncicmp	_wcsnicmp
#define _tcsncset	_wcsnset

#define	_tcsdec		_wcsdec
#define	_tcsinc		_wcsinc
#define	_tcsnbcnt	_wcsncnt
#define	_tcsnccnt	_wcsncnt
#define	_tcsnextc	_wcsnextc
#define	_tcsninc	_wcsninc
#define	_tcsspnp	_wcsspnp

#define _tcslwr		_wcslwr
#define _tcsupr		_wcsupr
#define _tcsxfrm	wcsxfrm
#define _tcscoll	wcscoll
#define _tcsicoll	_wcsicoll


#if	!__STDC__ || defined(_NO_INLINING)
#define _tclen(_pc)	(1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else
__inline size_t _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif


/* ctype functions */

#define _istalpha	iswalpha
#define _istupper	iswupper
#define _istlower	iswlower
#define _istdigit	iswdigit
#define _istxdigit	iswxdigit
#define _istspace	iswspace
#define _istpunct	iswpunct
#define _istalnum	iswalnum
#define _istprint	iswprint
#define _istgraph	iswgraph
#define _istcntrl	iswcntrl
#define _istascii	iswascii

#define _totupper	towupper
#define _totlower	towlower

#define _istlegal	(1)


#if	!__STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc, _pc) ((_pc)-1)
#define _wcsinc(_pc)	((_pc)+1)
#define _wcsnextc(_cpc)	((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else
__inline wchar_t * _wcsdec(const wchar_t * _cpc, const wchar_t * _pc) { return (wchar_t *)(_cpc,(_pc-1)); }
__inline wchar_t * _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif


#else	/* ndef _UNICODE */


#if !defined(_CHAR_UNSIGNED) && !defined(_JWARNING_DEFINED)
/* #pragma message("TCHAR.H: Warning: The /J option is recommended for international compilation") */
#define _JWARNING_DEFINED
#endif


#include <string.h>


#define __T(x)		x


/* Formatted i/o */

#define _tprintf	printf
#define _ftprintf	fprintf
#define _stprintf	sprintf
#define _sntprintf	_snprintf
#define _vtprintf	vprintf
#define _vftprintf	vfprintf
#define _vstprintf	vsprintf
#define _vsntprintf	_vsnprintf
#define _tscanf		scanf
#define _ftscanf	fscanf
#define _stscanf	sscanf


/* Unformatted i/o */

#define _fgettc(_f)	(_TINT)fgetc((_f))
#define _fgettchar	(_TINT)_fgetchar
#define _fgetts(_s,_i,_f) fgets((_s),(_i),(_f))
#define _fputtc(_i,_f)	(_TINT)fputc((int)(_i),(_f))
#define _fputtchar(_i)	(_TINT)_fputchar((int)(_i))
#define _fputts(_s,_f)	(_TINT)fputs((_s),(_f))
#define _gettc(_f)	(_TINT)getc((_f))
#define _gettchar	(_TINT)getchar
#define _puttc(_i,_f)	(_TINT)putc((int)(_i),(_f))
#define _puttchar(_i)	(_TINT)putchar((int)(_i))
#define _ungettc(_i,_f)	(_TINT)ungetc((int)(_i),(_f))


/* String conversion functions */

#define _tcstod		strtod
#define _tcstol		strtol
#define _tcstoul	strtoul


#ifdef _MBCS

#ifndef __TCHAR_DEFINED
typedef char		_TCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef char		TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF		EOF


#include <mbstring.h>


/* Helper macros for MB casts */

#define _MB(_s)  ((unsigned char *)(_s))
#define _CMB(_s) ((const unsigned char *)(_s))


/* String functions */

#define _tcscat(_s1,_s2)	(_TCHAR*)_mbscat(_MB(_s1),_CMB(_s2))
#define _tcschr(_s,_i)		(_TCHAR*)_mbschr(_CMB(_s),(_i))
#define _tcscmp(_s1,_s2)	_mbscmp(_CMB(_s1),_CMB(_s2))
#define _tcscpy(_s1,_s2)	(_TCHAR*)_mbscpy(_MB(_s1),_CMB(_s2))
#define _tcscspn(_s1,_s2)	_mbscspn(_CMB(_s1),_CMB(_s2))
#define _tcslen(_s)		strlen((_s))
#define _tcsncat(_s1,_s2,_n)	(_TCHAR*)_mbsnbcat(_MB(_s1),_CMB(_s2),(_n))
#define _tcsncmp(_s1,_s2,_n)	_mbsnbcmp(_CMB(_s1),_CMB(_s2),(_n))
#define _tcsncpy(_s1,_s2,_n)	(_TCHAR*)_mbsnbcpy(_MB(_s1),_CMB(_s2),(_n))
#define _tcspbrk(_s1,_s2)	(_TCHAR*)_mbspbrk(_CMB(_s1),_CMB(_s2))
#define _tcsrchr(_s,_i)		(_TCHAR*)_mbsrchr(_CMB(_s),(_i))
#define _tcsspn(_s1,_s2)	_mbsspn(_CMB(_s1),_CMB(_s2))
#define _tcsstr(_s1,_s2)	(_TCHAR*)_mbsstr(_CMB(_s1),_CMB(_s2))
#define _tcstok(_s1,_s2)	(_TCHAR*)_mbstok(_MB(_s1),_CMB(_s2))

#define _tcsdup(_s)		(_TCHAR*)_mbsdup(_CMB(_s))
#define _tcsicmp(_s1,_s2)	_mbsicmp(_CMB(_s1),_CMB(_s2))
#define _tcsnicmp(_s1,_s2,_n)	_mbsnbicmp(_CMB(_s1),_CMB(_s2),(_n))
#define _tcsnset(_s,_i,_n)	(_TCHAR*)_mbsnbset(_MB(_s),(_i),(_n))
#define _tcsrev(_s)		(_TCHAR*)_mbsrev(_MB(_s))
#define _tcsset(_s,_i)		(_TCHAR*)_mbsset(_MB(_s),(_i))


/* "logical-character" mappings */

#define _tcsclen(_s)		_mbslen(_MB(_s))
#define _tcsnccat(_s1,_s2,_n)	(_TCHAR*)_mbsncat(_MB(_s1),_CMB(_s2),(_n))
#define _tcsnccpy(_s1,_s2,_n)	(_TCHAR*)_mbsncpy(_MB(_s1),_CMB(_s2),(_n))
#define _tcsnccmp(_s1,_s2,_n)	_mbsncmp(_CMB(_s1),_CMB(_s2),(_n))
#define _tcsncicmp(_s1,_s2,_n)	_mbsnicmp(_CMB(_s1),_CMB(_s2),(_n))
#define _tcsncset(_s,_i,_n)	(_TCHAR*)_mbsnset(_MB(_s),(_i),(_n))


/* MBCS-specific mappings */

#define	_tcsdec(_s1,_s2)	(_TCHAR*)_mbsdec(_CMB(_s1),_CMB(_s2))
#define	_tcsinc(_s)		(_TCHAR*)_mbsinc(_CMB(_s))
#define	_tcsnbcnt(_s,_n)	_mbsnbcnt(_CMB(_s),(_n))
#define	_tcsnccnt(_s,_n)	_mbsnccnt(_CMB(_s),(_n))
#define	_tcsnextc(_s)		_mbsnextc(_CMB(_s))
#define	_tcsninc(_s,_n)		(_TCHAR*)_mbsninc(_CMB(_s),(_n))
#define	_tcsspnp(_s1,_s2)	(_TCHAR*)_mbsspnp(_CMB(_s1),_CMB(_s2))

#define _tcslwr(_s)		(_TCHAR*)_mbslwr(_MB(_s))
#define _tcsupr(_s)		(_TCHAR*)_mbsupr(_MB(_s))
#define _tcsxfrm(_d,_s,_n)	(strncpy((_d),(_s),(_n)),strlen((_s)))
#define _tcscoll		_tcscmp
#define _tcsicoll		_tcsicmp

#define _tclen(_s)		_mbclen(_CMB(_s))
#define _tccpy(_s1,_s2)		_mbccpy(_MB(_s1),_CMB(_s2))
#define	_tccmp(_s1,_s2)		_tcsnccmp((_s1),(_s2),1)


/* ctype functions */

#define _istalpha	_ismbcalpha
#define _istupper	_ismbcupper
#define _istlower	_ismbclower
#define _istdigit	_ismbcdigit
#define _istxdigit	_isxdigit
#define _istspace	_ismbcspace
#define _istprint	_ismbcprint
#define _istcntrl	_iscntrl
#define _istascii	_isascii

#define _totupper	_mbctoupper
#define _totlower	_mbctolower

#define _istlegal	_ismbclegal


#else	/* !_MBCS */


#ifndef __TCHAR_DEFINED
typedef char		_TCHAR;
typedef int		_TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef char		TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF		EOF


/* String functions */

#define _tcscat		strcat
#define _tcschr		strchr
#define _tcscmp		strcmp
#define _tcscpy		strcpy
#define _tcscspn	strcspn
#define _tcslen		strlen
#define _tcsncat	strncat
#define _tcsncmp	strncmp
#define _tcsncpy	strncpy
#define _tcspbrk	strpbrk
#define _tcsrchr	strrchr
#define _tcsspn		strspn
#define _tcsstr		strstr
#define _tcstok		strtok

#define _tcsdup		_strdup
#define _tcsicmp	_stricmp
#define _tcsnicmp	_strnicmp
#define _tcsnset	_strnset
#define _tcsrev		_strrev
#define _tcsset		_strset


/* "logical-character" mappings */

#define _tcsclen	strlen
#define _tcsnccat	strncat
#define _tcsnccpy	strncpy
#define _tcsnccmp	strncmp
#define _tcsncicmp	_strnicmp
#define _tcsncset	_strnset


/* MBCS-specific functions */

#define	_tcsdec		_strdec
#define	_tcsinc		_strinc
#define	_tcsnbcnt	_strncnt
#define	_tcsnccnt	_strncnt
#define	_tcsnextc	_strnextc
#define	_tcsninc	_strninc
#define	_tcsspnp	_strspnp

#define _tcslwr		_strlwr
#define _tcsupr		_strupr
#define _tcsxfrm	strxfrm
#define _tcscoll	strcoll
#define _tcsicoll	_stricoll


#if	!__STDC__ || defined(_NO_INLINING)
#define _tclen(_pc)	(1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else
__inline size_t _tclen(const char *_cpc) { return (_cpc,1); }
__inline void _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif


/* ctype-functions */

#define _istalpha	isalpha
#define _istupper	isupper
#define _istlower	islower
#define _istdigit	isdigit
#define _istxdigit	isxdigit
#define _istspace	isspace
#define _istpunct	ispunct
#define _istalnum	isalnum
#define _istprint	isprint
#define _istgraph	isgraph
#define _istcntrl	iscntrl
#define _istascii	isascii

#define _totupper	toupper
#define _totlower	tolower

#define _istlegal	(1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


#if	!__STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc, _pc) ((_pc)-1)
#define _strinc(_pc)	((_pc)+1)
#define _strnextc(_cpc)	((unsigned int) *(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else	/* __STDC__ */
__inline char * _strdec(const char * _cpc, const char * _pc) { return (char *)(_cpc,(_pc-1)); }
__inline char * _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int _strnextc(const char * _cpc) { return (unsigned int)*_cpc; }
__inline char * _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif	/* __STDC__ */


#endif	/* _MBCS */

#endif	/* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */
   
#define _T(x)		__T(x)
#define _TEXT(x)	__T(x)


#ifdef __cplusplus
}
#endif

#define _INC_TCHAR
#endif	/* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\testmess.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	testmess.h
//
//  Contents:	Declarations for private test messages
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTMESS_H
#define __TESTMESS_H

#define TEST_SUCCESS	0
#define TEST_FAILURE	1
#define TEST_UNKNOWN	2

// Test End:  sent back to the driver from the test app idicating the
// success or failure of the test (and optionally a failure code)
//	wParam == TEST_SUCCESS | TEST_FAILURE
//	lParam == HRESULT (optional)
#define	WM_TESTEND	WM_USER + 1

// Test Register: sent back to the driver from the test app giving
// the driver a window handle that it can send messages to.
//	wParam == HWND of the test app
#define WM_TESTREG	WM_USER + 2

// Tests Completed:  used to indicate that all requested tests have
// been completed
#define WM_TESTSCOMPLETED WM_USER + 3

// Test Start: used to kick the task stack interpreter into action
#define WM_TESTSTART	WM_USER + 4

// Individual test messages.  Sent by the driver app to the test app
// telling it to start an individual test.
#define WM_TEST1	WM_USER + 10
#define WM_TEST2	WM_USER + 11
#define WM_TEST3	WM_USER + 12
#define WM_TEST4	WM_USER + 13
#define WM_TEST5	WM_USER + 14

#endif  // !__TESTMESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* exit() arg values */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)	(((a) > (b)) ? (a) : (b))
#define __min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

extern int __near __cdecl volatile errno;	/* error value */
extern int __near __cdecl _doserrno;		/* OS system error value */

extern char * __near __cdecl _sys_errlist[];	/* perror error message table */
extern int __near __cdecl _sys_nerr;		/* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ; 	/* pointer to environment table */
extern int __near __cdecl _fmode;		/* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int __near __cdecl _psp;	/* Program Segment Prefix */

/* OS major/minor version numbers */

extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;

/* OS mode */

#define _DOS_MODE	0	/* DOS */
#define _OS2_MODE	1	/* OS/2 */
#define _WIN_MODE	2	/* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE	0	/* real mode */
#define _PROT_MODE	1	/* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
	size_t, size_t, int (__cdecl *)(const void *,
	const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
	size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
	const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
	(const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
	char *);
void __cdecl _splitpath(const char *, char *,
	char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
	int);
long double __cdecl _strtold(const char *,
	char * *);
unsigned long __cdecl strtoul(const char *,
	char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
	size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
	size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
	size_t);

#ifndef tolower 	/* tolower has been undefined - use function */
int __cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int __cdecl toupper(int);
#endif	/* toupper */

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#define _INC_STDLIB
#endif	/* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\verinfo.h ===
#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.1\0"
#define VER_FILEVERSION          2,0010,0035,0035

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.1 16/32 Interoperability for Windows\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1994\0"
#define VER_PRODUCTVERSION_STR   "2.1\0"
#define VER_PRODUCTVERSION       2,0010,0035,0035
#define VER_COMMENT_STR          "Windows OLE 16/32 Interoperability DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "OLE 2.1 16/32 Interoperability Library\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\utstream.h ===
#if !defined( _UTSTREAM_H_ )
#define _UTSTREAM_H_

/* stream ids used in the call to StGetStream */

FARINTERNAL_(HRESULT) StRead (IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen);
#define StWrite(lpstream, lpBuf, ulLen) lpstream->Write(lpBuf, ulLen, NULL)
FARINTERNAL_(ATOM)  StReadAtom (IStream FAR * lpstream);
FARINTERNAL_(HRESULT) StWriteAtom (IStream FAR * lpstream, ATOM at);

FARINTERNAL StSave10NativeData(IStorage FAR* pstgSave, HANDLE hNative, BOOL fIsOle1Interop);
FARINTERNAL StRead10NativeData(IStorage FAR* pstgSave, HANDLE FAR *phNative);
FARINTERNAL StSave10ItemName (IStorage FAR* pstg, LPCSTR szItemName);
OLEAPI		ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz);
OLEAPI		WriteStringStream( LPSTREAM pstm, LPCSTR psz);

FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize = 0, BOOL fRelative = TRUE);

#endif // _UTSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\utils.h ===
#if !defined( _UTILS_H_ )
#define _UTILS_H_


#define	STREAMTYPE_CONTROL		0x00000001
#define	STREAMTYPE_CACHE		0x00000002
#define	STREAMTYPE_CONTAINER	0x00000004
#define STREAMTYPE_OTHER \
	(!(STREAMTYPE_CONTROL | STREAMTYPE_CACHE | STREAMTYPE_CONTAINER))
#define	STREAMTYPE_ALL			0xFFFFFFFF


#define OPCODE_COPY					1
#define OPCODE_REMOVE				2
#define OPCODE_MOVE					3
#define OPCODE_EXCLUDEFROMCOPY		4

#define CONVERT_NOSOURCE			1
#define CONVERT_NODESTINATION		2

typedef struct tagPLACEABLEMETAHEADER {
	DWORD	key;		/* must be 0x9AC6CDD7L */
	HANDLE	hmf;		/* must be zero */
	RECT	bbox;		/* bounding rectangle of the metafile */
	WORD	inch;		/* # of metafile units per inch must be < 1440 */
						/* most apps use 576 or 1000 */
	DWORD	reserved;	/* must be zero */
	WORD	checksum;
} PLACEABLEMETAHEADER;




#ifdef  _MAC
#define UtMemCpy(lpdst,lpsrc,dwCount)   (BlockMove(lpsrc, lpdst, dwCount))
#else
#define UtMemCpy(lpdst,lpsrc,dwCount)   (hmemcpy(lpdst, lpsrc, dwCount))
#endif

FARINTERNAL_(BOOL)		UtGlobalHandleCpy(HANDLE FAR* lphdst, HANDLE hsrc);

FARINTERNAL_(HANDLE)	UtDupGlobal (HANDLE hSrc, UINT uiFlags=GMEM_MOVEABLE);

FARINTERNAL_(BOOL)		UtIsFormatSupported (LPDATAOBJECT lpObj, BOOL fGet,
							BOOL fSet, CLIPFORMAT cfFormat);

FARINTERNAL_(LPSTR)		UtDupString(LPCSTR lpszIn);


FARINTERNAL_(BOOL)		UtCopyFormatEtc(FORMATETC FAR* pFetcIn, 
							FORMATETC FAR* pFetcCopy);

FARINTERNAL_(int)		UtCompareFormatEtc(FORMATETC FAR* pFetcLeft, 
							FORMATETC FAR* pFetcRight);

FARINTERNAL_(BOOL)		UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft, 
							DVTARGETDEVICE FAR* ptdRight);

FARINTERNAL_(BOOL)		UtCopyStatData(STATDATA FAR* pSDIn, 
							STATDATA FAR* pSDCopy);

FARINTERNAL_(void)		UtReleaseStatData(STATDATA FAR* pStatData);


FARINTERNAL_(HPALETTE)	UtDupPalette(HPALETTE hpalette);

FARINTERNAL_(int)		UtPaletteSize (int iBitCount);

FARINTERNAL_(DWORD)		UtFormatToTymed	(CLIPFORMAT cf);


FARINTERNAL_(BOOL)		UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj, 
								LPFORMATETC	lpforetc);
								
FARINTERNAL_(HBITMAP)	UtConvertDibToBitmap(HANDLE hDib);
								
FARINTERNAL_(HANDLE)	UtConvertBitmapToDib(HBITMAP hBitmapm, 
								HPALETTE hpal = NULL);

FARINTERNAL_(void)		UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid);

FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd);

FARINTERNAL				UtGetIconData(LPDATAOBJECT lpSrcDataObj, 
							REFCLSID rclsid, LPFORMATETC lpforetc, 
							LPSTGMEDIUM lpstgmed);

OLEAPI					UtDoStreamOperation (LPSTORAGE pstgSrc, 
							LPSTORAGE pstgDst, int iOpCode, 
							DWORD grfAllowedStmTypes);

							
FARINTERNAL_(LPSTR)		UtStrRChr (LPCSTR sz, const char ch);

FARINTERNAL_(void)		UtGetPresStreamName (LPSTR lpszName, int iStreamNum);

FARINTERNAL_(void)		UtRemoveExtraOlePresStreams (LPSTORAGE pstg, 
							int iStart);

							
							
/*** Following routines can be found in convert.cpp *****/

FARINTERNAL				UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize, 
							HANDLE FAR* lphPres);
							
FARINTERNAL				UtGetHDIBFromDIBFileStm(LPSTREAM pstm, 
							HANDLE FAR* lphdata);

FARINTERNAL_(HANDLE)	UtGetHMFPICT(HMETAFILE hMF, BOOL fDeletOnError,
							DWORD xExt, DWORD yExt);
							
FARINTERNAL				UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize, 
							BOOL fConvert, HANDLE FAR* lphPres);

FARINTERNAL				UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
							DWORD FAR* dwSize, LONG FAR* plWidth,  
							LONG FAR* plHeight);
		 
FARINTERNAL				UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, 
							HANDLE FAR* lphdata);

FARINTERNAL				UtHGLOBALToStm(HANDLE hdata, DWORD dwSize, 
							LPSTREAM pstm);

FARINTERNAL_(void)		UtGetDibExtents (LPBITMAPINFOHEADER lpbmi, 
							LONG FAR* plWidth, LONG FAR* plHeight);

FARINTERNAL				UtHDIBToDIBFileStm(HANDLE hdata, 
							DWORD dwSize, LPSTREAM pstm);

FARINTERNAL				UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, 
							DWORD dwSize, LPSTREAM pstmDIBFile);

FARINTERNAL				UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm);

FARINTERNAL				UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, 
							LPSTREAM lpstream); 
							
FARINTERNAL				UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, 
							DWORD dwSize, LONG lWidth, LONG lHeight,
							LPSTREAM pstm);		
								
FARINTERNAL				UtMFStmToPlaceableMFStm(LPSTREAM pstmMF,
							DWORD dwSize, LONG lWidth, LONG lHeight, 
							LPSTREAM pstmPMF);

FARINTERNAL				UtReadOlePresStmHeader (LPSTREAM pstm, 
							LPFORMATETC pforetc, DWORD FAR* pdwAdvf, 
							BOOL FAR* pfConvert);

FARINTERNAL				UtWriteOlePresStmHeader(LPSTREAM lppstream, 
							LPFORMATETC pforetc, DWORD dwAdvf);

FARINTERNAL				UtOlePresStmToContentsStm (LPSTORAGE pstg, 
							LPSTR lpszPresStm, BOOL fDeletePresStm,
							UINT FAR* puiStatus);
							
/*** Following routines can be found in ..\dde\client\ddecnvrt.cpp *****/

							
FARINTERNAL				UtGetHMFPICTFromMSDrawNativeStm (LPSTREAM pstm,	
							DWORD dwSize, HANDLE FAR* lphdata);	
							
FARINTERNAL				UtPlaceableMFStmToMSDrawNativeStm (LPSTREAM pstmPMF, 
							LPSTREAM pstmMSDraw);
			
FARINTERNAL				UtDIBFileStmToPBrushNativeStm (LPSTREAM pstmDIBFile, 
							LPSTREAM pstmPBrush);
							
FARINTERNAL_(HANDLE)	UtGetHPRESFromNative (LPSTORAGE pstg, 
							CLIPFORMAT cfFormat, BOOL fOle10Native);
							
FARINTERNAL				UtContentsStmTo10NativeStm (LPSTORAGE pstg, 
							REFCLSID rclsid, BOOL fDeleteContents, 
							UINT FAR* puiStatus);

FARINTERNAL				Ut10NativeStmToContentsStm(LPSTORAGE pstg, 
							REFCLSID rclsid, BOOL fDeleteSrcStm);
		
#endif // _UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\valid.h ===
//
// WARNING: IsValidPtrIn and IsValidPtrOut are defined as macros
// here. They are also defined as ISVALIDPTRIN and ISVALIDPTROUT
// in compobj\valid.cxx, which are functions. The functions are
// used to keep backward compatibility, while the macros are
// smaller and faster to use.
//

#define IsValidPtrIn(pv,cb)  (!IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );


#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 _far
#define NEAR		    _near
#define PASCAL		    _pascal
#define CDECL		    _cdecl

#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
c